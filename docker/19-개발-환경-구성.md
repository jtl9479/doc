# 19. 개발 환경 구성 (Development Workflow)

> **학습 목표**: Docker를 활용하여 효율적인 로컬 개발 환경을 구성하고, 핫 리로드, 디버깅, 테스트 환경을 설정할 수 있습니다.

**예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐⭐☆ (4개/5개)

---

## 목차
1. [왜 Docker 개발 환경이 필요한가](#왜-docker-개발-환경이-필요한가)
2. [실생활 비유로 이해하기](#실생활-비유로-이해하기)
3. [개발 환경 vs 프로덕션 환경](#개발-환경-vs-프로덕션-환경)
4. [Docker를 이용한 로컬 개발 환경](#docker를-이용한-로컬-개발-환경)
5. [핫 리로드 (Hot Reload) 설정](#핫-리로드-hot-reload-설정)
6. [개발용 도구 컨테이너](#개발용-도구-컨테이너)
7. [디버깅 환경 구성](#디버깅-환경-구성)
8. [테스트 환경 구성](#테스트-환경-구성)
9. [환경 변수 관리](#환경-변수-관리)
10. [주니어 시나리오](#주니어-시나리오)
11. [실전 예제: LK-Trade 개발 환경](#실전-예제-lk-trade-개발-환경)
12. [FAQ](#faq)
13. [면접 질문 리스트](#면접-질문-리스트)
14. [트러블슈팅](#트러블슈팅)
15. [핵심 정리](#핵심-정리)

---

## 왜 Docker 개발 환경이 필요한가?

### 실무 배경

**"내 컴퓨터에서는 되는데요?"라는 말을 없애는 방법**

#### ❌ Docker 개발 환경을 모르면 발생하는 문제

```
문제 1: 환경 설정 지옥
- 증상: 신입 개발자가 개발 환경 구축에 이틀 소요
- 영향: PostgreSQL, Redis, Node.js 버전 불일치로 빌드 실패
- 비용: 개발자 1명당 연간 약 100시간 낭비 (연봉 5천만원 기준 약 250만원)

문제 2: "내 컴퓨터에서는 되는데요" 증후군
- 증상: 로컬에서는 정상, 서버에서는 에러 발생
- 영향: 배포 후 장애, 긴급 롤백, 야근
- 비용: 장애 1건당 평균 손실 500만원 이상

문제 3: 의존성 충돌
- 증상: 프로젝트 A는 Node 14, 프로젝트 B는 Node 18 필요
- 영향: 프로젝트 전환 시마다 재설치, 충돌 해결에 시간 낭비
- 비용: 개발자 1명당 주 2-3시간 낭비
```

#### ✅ Docker 개발 환경을 사용하면

```
해결책 1: 원클릭 개발 환경 구축
- 방법: docker-compose up -d 한 줄로 전체 환경 시작
- 효과: 8시간 → 10분으로 단축
- 절감: 개발자 온보딩 비용 95% 절감

해결책 2: 완벽한 환경 일치
- 방법: 개발/스테이징/프로덕션 동일한 Docker 이미지 사용
- 효과: 환경 차이로 인한 버그 98% 감소
- 절감: 장애 대응 비용 월 1,000만원 → 100만원

해결책 3: 격리된 프로젝트 환경
- 방법: 각 프로젝트마다 독립된 컨테이너
- 효과: 버전 충돌 없이 여러 프로젝트 동시 작업
- 절감: 환경 관리 시간 주 3시간 → 0시간
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 개발 환경 구축 시간 | 8시간 | 10분 | **95%↓** |
| 환경 관련 버그 | 주 5건 | 주 0.1건 | **98%↓** |
| 신입 온보딩 비용 | 3일 | 1시간 | **96%↓** |
| 프로젝트 전환 시간 | 30분 | 2분 | **93%↓** |
| 개발자 생산성 | 60% | 95% | **58%↑** |

---

## 실생활 비유로 이해하기

### 비유 1: 이사할 때 가구 vs 컨테이너 하우스

```
전통적 개발 환경 = 일반 가구
- 이사할 때마다 분해/포장/운반/재조립 필요
- 새 집 크기에 안 맞을 수도 있음
- 조립 설명서 없어지면 고생

Docker 개발 환경 = 컨테이너 하우스
- 통째로 옮기면 끝
- 어디서든 똑같이 작동
- 설정 한 번이면 영원히 재사용

┌─────────────────────────────────────┐
│    전통적 개발 환경 (일반 가구)      │
│                                     │
│  [책상] [의자] [침대] [옷장]        │
│    ↓      ↓      ↓      ↓          │
│  분해 → 포장 → 운반 → 재조립        │
│  (2일 소요)                         │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│   Docker 개발 환경 (컨테이너)       │
│                                     │
│  ┌───────────────────────────┐     │
│  │ [모든 가구 완성된 상태]   │     │
│  └───────────────────────────┘     │
│           ↓                        │
│    통째로 옮기기만 하면 끝          │
│    (10분 소요)                     │
└─────────────────────────────────────┘
```

### 비유 2: 요리 연습 vs 레스토랑 영업

```
개발 환경 (요리 연습):
- 실수해도 괜찮음
- 자유롭게 실험 가능
- 빠른 피드백 필요 (맛보기)
- 편의 도구 많음 (믹서기, 계량컵 등)

프로덕션 환경 (레스토랑 영업):
- 실수 용납 안됨
- 검증된 레시피만
- 일관된 맛 (안정성)
- 효율성 최우선 (최소 도구)

Docker = 요리 연습실을 통째로 복제
- 연습실에서 성공한 레시피를 실제 주방에 그대로 적용
- 환경이 달라서 맛이 변하는 일 없음
```

### 비유 3: 놀이공원 안전 검사

```
개발 환경 = 테스트 트랙
- 느린 속도로 테스트
- 안전 장치 여러 개
- 엔지니어가 실시간 모니터링
- 문제 발견 즉시 중지

프로덕션 환경 = 실제 놀이기구
- 최고 속도로 운영
- 필수 안전 장치만
- 무정지 운영
- 철저한 사전 검증

Docker = 테스트 트랙과 실제 놀이기구를 동일하게 제작
- 테스트 환경에서 검증한 것이 실제 환경에서도 똑같이 작동
```

### 비유 4: 영화 촬영 vs 상영

```
개발 환경 = 촬영 세트장
- NG 가능
- 여러 카메라 각도
- 감독의 모니터 (디버거)
- 즉시 리플레이 가능 (핫 리로드)

프로덕션 환경 = 영화관
- 한 번 상영하면 되돌릴 수 없음
- 최종 편집본만
- 관객은 내부를 볼 수 없음
- 완벽한 품질만 제공

Docker = 세트장을 그대로 복제하여 여러 감독이 동시에 사용
- 각 감독(개발자)마다 독립된 세트장(컨테이너)
- 서로 방해하지 않음
```

### 비유 5: 게임 개발 빌드

```
전통적 환경 = PC방마다 다른 사양
- 고사양 PC에서는 잘 돌아감
- 저사양 PC에서는 버벅임
- 각 PC마다 설정 다시 해야 함

Docker 환경 = 클라우드 게임 스트리밍
- 모든 PC에서 동일한 경험
- 서버에서 실행되므로 사양 무관
- 설정 한 번이면 끝

개발자 경험:
- 개발자 A: Mac M1
- 개발자 B: Windows 11
- 개발자 C: Linux Ubuntu
- → Docker로 모두 동일한 환경에서 개발
```

### 종합 비교표

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│   특징       │ 이사 가구    │ 요리         │ 게임         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 환경 구축    │ 조립/설치    │ 레시피 준비  │ 사양 맞추기  │
│ 이식성       │ 통째로 이동  │ 레시피 공유  │ 클라우드     │
│ 일관성       │ 같은 가구    │ 같은 맛      │ 같은 성능    │
│ 격리성       │ 독립된 공간  │ 각자 주방    │ 독립 실행    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

---

## 개발 환경 vs 프로덕션 환경

### 왜 분리해야 하나?

**실생활 비유**: 요리 연습 vs 레스토랑 영업

```
개발 환경 (요리 연습):
- 실수해도 괜찮음
- 자유롭게 실험 가능
- 빠른 피드백 필요
- 디버깅 도구 풍부

프로덕션 환경 (레스토랑 영업):
- 실수 용납 안됨
- 안정성 최우선
- 성능 최적화
- 보안 강화
```

### 환경별 차이점

```
┌─────────────────────┬───────────────────┬───────────────────┐
│    특징             │   개발 환경        │  프로덕션 환경     │
├─────────────────────┼───────────────────┼───────────────────┤
│ 이미지 크기         │ 크고 무거움        │ 작고 가벼움        │
│                     │ (디버깅 도구 포함) │ (최소 구성)        │
├─────────────────────┼───────────────────┼───────────────────┤
│ 로그 레벨           │ DEBUG             │ INFO, WARN, ERROR │
├─────────────────────┼───────────────────┼───────────────────┤
│ 핫 리로드           │ 활성화 ✅          │ 비활성화          │
├─────────────────────┼───────────────────┼───────────────────┤
│ 소스 코드 마운트    │ 볼륨 마운트 ✅     │ 이미지에 포함      │
├─────────────────────┼───────────────────┼───────────────────┤
│ 디버거              │ 포트 노출 ✅       │ 비활성화          │
├─────────────────────┼───────────────────┼───────────────────┤
│ 보안                │ 낮은 우선순위      │ 최고 우선순위 ✅   │
├─────────────────────┼───────────────────┼───────────────────┤
│ 성능                │ 낮은 우선순위      │ 최고 우선순위 ✅   │
├─────────────────────┼───────────────────┼───────────────────┤
│ 재시작 정책         │ no                │ always            │
└─────────────────────┴───────────────────┴───────────────────┘
```

---

## Docker를 이용한 로컬 개발 환경

### 기본 개발 환경 구성

```yaml
# docker-compose.dev.yml

version: '3.8'

services:
  # 백엔드 개발 서버
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev  # 개발용 Dockerfile
      target: development         # 개발 스테이지
    volumes:
      # 소스 코드 마운트 (핫 리로드)
      - ./backend/src:/app/src:cached
      # 의존성 캐시 (성능 향상)
      - backend-node-modules:/app/node_modules
    environment:
      - NODE_ENV=development
      - DEBUG=app:*
      - LOG_LEVEL=debug
    ports:
      - "3000:3000"   # 애플리케이션
      - "9229:9229"   # Node.js 디버거
    command: npm run dev  # 개발 서버 실행
    depends_on:
      - postgres
      - redis

  # 프론트엔드 개발 서버
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    volumes:
      - ./frontend/src:/app/src:cached
      - frontend-node-modules:/app/node_modules
    environment:
      - VITE_API_URL=http://localhost:3000
      - VITE_DEV_MODE=true
    ports:
      - "5173:5173"  # Vite 개발 서버
    command: npm run dev

  # 개발용 데이터베이스
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=devdb
      - POSTGRES_USER=devuser
      - POSTGRES_PASSWORD=devpass
    ports:
      - "5432:5432"  # 로컬 접근 허용
    volumes:
      - postgres-dev-data:/var/lib/postgresql/data
      # 초기 데이터 로드
      - ./scripts/init-dev-db.sql:/docker-entrypoint-initdb.d/init.sql

  # 개발용 Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes

  # 메일 캐처 (개발 환경용)
  mailcatcher:
    image: sj26/mailcatcher
    ports:
      - "1080:1080"  # Web UI
      - "1025:1025"  # SMTP

volumes:
  backend-node-modules:
  frontend-node-modules:
  postgres-dev-data:
```

### 개발용 Dockerfile

```dockerfile
# Dockerfile.dev

# 개발 스테이지
FROM node:18-alpine AS development

WORKDIR /app

# 개발 도구 설치
RUN apk add --no-cache \
    git \
    curl \
    vim \
    bash

# package.json만 먼저 복사 (캐싱 최적화)
COPY package*.json ./

# 개발 의존성 포함 설치
RUN npm install

# 소스 코드는 볼륨 마운트로 제공됨
# COPY는 하지 않음

# 개발 서버 실행
CMD ["npm", "run", "dev"]

# 프로덕션 스테이지
FROM node:18-alpine AS production

WORKDIR /app

COPY package*.json ./
# 프로덕션 의존성만 설치
RUN npm ci --only=production

COPY . .

CMD ["npm", "start"]
```

### 빠른 시작 스크립트

```bash
#!/bin/bash
# scripts/dev-start.sh

set -e

echo "🚀 LK-Trade 개발 환경 시작..."

# 환경 변수 파일 확인
if [ ! -f .env.dev ]; then
    echo "❌ .env.dev 파일이 없습니다."
    echo "📝 .env.dev.example을 복사하여 생성하세요."
    exit 1
fi

# 이전 컨테이너 정리
echo "🧹 이전 컨테이너 정리 중..."
docker-compose -f docker-compose.dev.yml down

# 이미지 빌드
echo "🔨 이미지 빌드 중..."
docker-compose -f docker-compose.dev.yml build

# 컨테이너 시작
echo "🐳 컨테이너 시작 중..."
docker-compose -f docker-compose.dev.yml up -d

# 서비스 준비 대기
echo "⏳ 서비스 준비 대기 중..."
sleep 10

# 헬스체크
echo "🏥 헬스체크..."
if curl -f http://localhost:3000/health > /dev/null 2>&1; then
    echo "✅ 백엔드 서버 정상"
else
    echo "❌ 백엔드 서버 시작 실패"
    exit 1
fi

if curl -f http://localhost:5173 > /dev/null 2>&1; then
    echo "✅ 프론트엔드 서버 정상"
else
    echo "❌ 프론트엔드 서버 시작 실패"
    exit 1
fi

# 로그 출력
echo ""
echo "✅ 개발 환경 시작 완료!"
echo ""
echo "📋 서비스 URL:"
echo "   - 백엔드:     http://localhost:3000"
echo "   - 프론트엔드:  http://localhost:5173"
echo "   - PostgreSQL: localhost:5432"
echo "   - Redis:      localhost:6379"
echo "   - MailCatcher: http://localhost:1080"
echo ""
echo "📝 유용한 명령어:"
echo "   - 로그 확인:  docker-compose -f docker-compose.dev.yml logs -f"
echo "   - 중지:       docker-compose -f docker-compose.dev.yml down"
echo "   - 재시작:     docker-compose -f docker-compose.dev.yml restart"
echo ""
```

---

## 핫 리로드 (Hot Reload) 설정

### Node.js (Express) 핫 리로드

**nodemon 사용**:

```json
// package.json

{
  "scripts": {
    "dev": "nodemon --watch src --exec 'node' src/index.js",
    "dev:debug": "nodemon --watch src --inspect=0.0.0.0:9229 src/index.js"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

```javascript
// nodemon.json

{
  "watch": ["src"],
  "ext": "js,json",
  "ignore": ["src/**/*.test.js"],
  "exec": "node src/index.js",
  "env": {
    "NODE_ENV": "development"
  },
  "delay": 1000
}
```

### Spring Boot 핫 리로드

**Spring Boot DevTools 사용**:

```kotlin
// build.gradle.kts

dependencies {
    developmentOnly("org.springframework.boot:spring-boot-devtools")
}
```

```yaml
# application-dev.yml

spring:
  devtools:
    restart:
      enabled: true
      additional-paths: src/main/kotlin
    livereload:
      enabled: true
```

**Dockerfile.dev**:

```dockerfile
FROM gradle:8.5-jdk21 AS development

WORKDIR /app

# Gradle 의존성 캐싱
COPY build.gradle.kts settings.gradle.kts ./
RUN gradle dependencies --no-daemon

# 소스 코드는 볼륨 마운트
# DevTools가 변경 감지

CMD ["gradle", "bootRun", "--args='--spring.profiles.active=dev'"]
```

**docker-compose.dev.yml**:

```yaml
services:
  user-service:
    build:
      context: ./modules/user
      dockerfile: Dockerfile.dev
    volumes:
      # 소스 코드 마운트
      - ./modules/user/api/src:/app/api/src:cached
      # Gradle 캐시 (성능)
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
    ports:
      - "8081:8080"
      - "5005:5005"  # Remote Debug

volumes:
  gradle-cache:
```

### React (Vite) 핫 리로드

```javascript
// vite.config.js

export default {
  server: {
    host: '0.0.0.0',  // Docker 내부에서 접근 가능
    port: 5173,
    watch: {
      usePolling: true,  // Docker 볼륨에서 필요
      interval: 1000
    },
    hmr: {
      host: 'localhost',
      port: 5173
    }
  }
}
```

```dockerfile
# Dockerfile.dev

FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

# Vite가 파일 변경 감지
EXPOSE 5173

CMD ["npm", "run", "dev"]
```

---

## 개발용 도구 컨테이너

### 데이터베이스 관리 도구

```yaml
# docker-compose.dev.yml

services:
  # pgAdmin (PostgreSQL 관리)
  pgadmin:
    image: dpage/pgadmin4:latest
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@example.com
      - PGADMIN_DEFAULT_PASSWORD=admin
      - PGADMIN_CONFIG_SERVER_MODE=False
    ports:
      - "5050:80"
    volumes:
      - pgadmin-data:/var/lib/pgadmin

  # Redis Commander (Redis 관리)
  redis-commander:
    image: rediscommander/redis-commander:latest
    environment:
      - REDIS_HOSTS=local:redis:6379
    ports:
      - "8081:8081"

  # Adminer (다목적 DB 관리)
  adminer:
    image: adminer:latest
    ports:
      - "8080:8080"
    environment:
      - ADMINER_DEFAULT_SERVER=postgres

volumes:
  pgadmin-data:
```

### API 문서 도구

```yaml
services:
  # Swagger UI
  swagger-ui:
    image: swaggerapi/swagger-ui
    ports:
      - "8082:8080"
    environment:
      - SWAGGER_JSON=/api-docs/openapi.yaml
    volumes:
      - ./docs/api:/api-docs

  # API 모킹 서버
  mock-server:
    image: mockserver/mockserver:latest
    ports:
      - "1080:1080"
    environment:
      - MOCKSERVER_PROPERTY_FILE=/config/mockserver.properties
    volumes:
      - ./mocks:/config
```

---

## 디버깅 환경 구성

### Node.js 디버깅

**VSCode launch.json**:

```json
// .vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "node",
      "request": "attach",
      "name": "Docker: Attach to Node",
      "remoteRoot": "/app",
      "localRoot": "${workspaceFolder}/backend",
      "port": 9229,
      "restart": true,
      "sourceMaps": true,
      "skipFiles": ["<node_internals>/**"]
    }
  ]
}
```

**docker-compose.dev.yml**:

```yaml
services:
  backend:
    command: node --inspect=0.0.0.0:9229 src/index.js
    ports:
      - "9229:9229"  # 디버거 포트
```

### Java/Kotlin 디버깅

**IntelliJ IDEA 설정**:

```
Run > Edit Configurations > Add > Remote JVM Debug

Host: localhost
Port: 5005
Command line arguments: -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005
```

**docker-compose.dev.yml**:

```yaml
services:
  user-service:
    environment:
      - JAVA_TOOL_OPTIONS=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005
    ports:
      - "5005:5005"  # Remote Debug
```

**Dockerfile.dev**:

```dockerfile
FROM gradle:8.5-jdk21

WORKDIR /app

# 디버그 모드로 실행
CMD ["gradle", "bootRun", \
    "--args='--spring.profiles.active=dev'", \
    "-Dorg.gradle.jvmargs='-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:5005'"]
```

### Python 디버깅

**debugpy 사용**:

```python
# main.py

import debugpy

# 디버거 시작
debugpy.listen(("0.0.0.0", 5678))
print("Waiting for debugger attach...")
debugpy.wait_for_client()

# 애플리케이션 시작
app.run()
```

```yaml
# docker-compose.dev.yml

services:
  python-app:
    command: python -m debugpy --listen 0.0.0.0:5678 --wait-for-client main.py
    ports:
      - "5678:5678"
```

---

## 테스트 환경 구성

### 단위 테스트 환경

```yaml
# docker-compose.test.yml

version: '3.8'

services:
  # 테스트 러너
  test-runner:
    build:
      context: .
      target: test
    volumes:
      - ./src:/app/src
      - ./tests:/app/tests
    command: npm test
    environment:
      - NODE_ENV=test
      - DATABASE_URL=postgresql://testuser:testpass@postgres-test:5432/testdb

  # 테스트용 데이터베이스
  postgres-test:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=testdb
      - POSTGRES_USER=testuser
      - POSTGRES_PASSWORD=testpass
    tmpfs:
      - /var/lib/postgresql/data  # 메모리에 저장 (빠른 테스트)
```

**Dockerfile (test 스테이지)**:

```dockerfile
FROM node:18-alpine AS test

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

# 테스트 실행
CMD ["npm", "test"]
```

### 통합 테스트 환경

```yaml
# docker-compose.integration.yml

services:
  # 전체 스택 시작
  backend:
    build: ./backend
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  postgres:
    image: postgres:15-alpine
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U testuser"]
      interval: 5s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # 통합 테스트 실행
  integration-tests:
    build:
      context: ./tests
      dockerfile: Dockerfile.integration
    depends_on:
      - backend
    command: npm run test:integration
    environment:
      - API_BASE_URL=http://backend:3000
```

**테스트 실행 스크립트**:

```bash
#!/bin/bash
# scripts/run-tests.sh

set -e

echo "🧪 테스트 실행 중..."

# 단위 테스트
echo "1️⃣ 단위 테스트..."
docker-compose -f docker-compose.test.yml run --rm test-runner

# 통합 테스트
echo "2️⃣ 통합 테스트..."
docker-compose -f docker-compose.integration.yml up --abort-on-container-exit

# 정리
docker-compose -f docker-compose.test.yml down -v
docker-compose -f docker-compose.integration.yml down -v

echo "✅ 모든 테스트 통과!"
```

---

## 환경 변수 관리

### .env 파일 구조

```bash
# .env.example (Git에 커밋)

# 데이터베이스
DATABASE_HOST=postgres
DATABASE_PORT=5432
DATABASE_NAME=devdb
DATABASE_USER=devuser
DATABASE_PASSWORD=  # 실제 값은 .env.dev에

# Redis
REDIS_HOST=redis
REDIS_PORT=6379

# 애플리케이션
NODE_ENV=development
LOG_LEVEL=debug

# API 키 (실제 값은 비공개)
OPENAI_API_KEY=
ALPACA_API_KEY=
ALPACA_SECRET_KEY=
```

```bash
# .env.dev (Git에서 제외, 실제 값 포함)

DATABASE_PASSWORD=dev_secret_password
OPENAI_API_KEY=sk-xxxxxxxxxxxxxx
ALPACA_API_KEY=PKxxxxxxxxxxxxxx
ALPACA_SECRET_KEY=xxxxxxxxxxxxxx
```

```bash
# .gitignore

.env.dev
.env.local
.env.*.local
```

### docker-compose에서 사용

```yaml
# docker-compose.dev.yml

services:
  backend:
    env_file:
      - .env.dev  # 개발 환경 변수
    environment:
      # 오버라이드 (우선순위 높음)
      - NODE_ENV=development
      - DEBUG=app:*
```

### 환경별 설정 파일

```
config/
├── default.js          # 기본 설정
├── development.js      # 개발 환경
├── test.js            # 테스트 환경
├── staging.js         # 스테이징 환경
└── production.js      # 프로덕션 환경
```

```javascript
// config/development.js

module.exports = {
  server: {
    port: process.env.PORT || 3000,
    host: '0.0.0.0'
  },
  database: {
    host: process.env.DATABASE_HOST || 'localhost',
    port: process.env.DATABASE_PORT || 5432,
    name: process.env.DATABASE_NAME || 'devdb',
    user: process.env.DATABASE_USER || 'devuser',
    password: process.env.DATABASE_PASSWORD
  },
  logging: {
    level: 'debug',
    pretty: true  // 개발 환경에서만
  },
  cors: {
    origin: '*',  // 개발 환경에서만 허용
    credentials: true
  }
}
```

---

## 실전 예제: LK-Trade 개발 환경

### 전체 개발 환경 구성

```yaml
# docker-compose.dev.yml

version: '3.8'

services:
  # 인프라
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=lktrade_dev
      - POSTGRES_USER=lkuser
      - POSTGRES_PASSWORD=devpass
    ports:
      - "5432:5432"
    volumes:
      - postgres-dev-data:/var/lib/postgresql/data
      - ./scripts/init-dev-db.sql:/docker-entrypoint-initdb.d/init.sql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes

  # User Service
  user-service:
    build:
      context: ./modules/user
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/user/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
      - DATABASE_URL=jdbc:postgresql://postgres:5432/lktrade_dev
      - REDIS_HOST=redis
    ports:
      - "8081:8080"
      - "5005:5005"  # Debug
    depends_on:
      - postgres
      - redis
    command: gradle bootRun

  # Account Service
  account-service:
    build:
      context: ./modules/account
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/account/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DATABASE_URL=jdbc:postgresql://postgres:5432/lktrade_dev
    ports:
      - "8082:8080"
      - "5006:5005"
    depends_on:
      - postgres
      - redis

  # Trade Service
  trade-service:
    build:
      context: ./modules/trade
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/trade/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - DATABASE_URL=jdbc:postgresql://postgres:5432/lktrade_dev
      - ALPACA_API_KEY=${ALPACA_API_KEY}
      - ALPACA_SECRET_KEY=${ALPACA_SECRET_KEY}
    ports:
      - "8083:8080"
      - "5007:5005"
    depends_on:
      - postgres
      - redis

  # AI Service
  ai-service:
    build:
      context: ./modules/ai
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/ai/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - OPENAI_API_KEY=${OPENAI_API_KEY}
    ports:
      - "8084:8080"
      - "5008:5005"
    depends_on:
      - postgres

  # Scraper Service
  scraper-service:
    build:
      context: ./modules/scraper
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/scraper/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    environment:
      - SPRING_PROFILES_ACTIVE=dev
    ports:
      - "8085:8080"
      - "5009:5005"
    depends_on:
      - postgres
      - redis

  # 개발 도구
  pgadmin:
    image: dpage/pgadmin4:latest
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@lktrade.com
      - PGADMIN_DEFAULT_PASSWORD=admin
      - PGADMIN_CONFIG_SERVER_MODE=False
    ports:
      - "5050:80"
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    profiles:
      - tools

  redis-commander:
    image: rediscommander/redis-commander:latest
    environment:
      - REDIS_HOSTS=local:redis:6379
    ports:
      - "8090:8081"
    profiles:
      - tools

  mailcatcher:
    image: sj26/mailcatcher
    ports:
      - "1080:1080"
      - "1025:1025"
    profiles:
      - tools

volumes:
  postgres-dev-data:
  pgadmin-data:
  gradle-cache:

networks:
  default:
    name: lktrade-dev
```

### 개발용 Makefile

```makefile
# Makefile

.PHONY: help dev dev-tools dev-stop dev-restart dev-logs dev-shell test clean

help:
	@echo "LK-Trade 개발 환경 명령어"
	@echo ""
	@echo "  make dev          - 개발 환경 시작"
	@echo "  make dev-tools    - 개발 도구 포함 시작"
	@echo "  make dev-stop     - 개발 환경 중지"
	@echo "  make dev-restart  - 개발 환경 재시작"
	@echo "  make dev-logs     - 로그 확인"
	@echo "  make dev-shell    - 컨테이너 셸 접속"
	@echo "  make test         - 테스트 실행"
	@echo "  make clean        - 정리"

dev:
	@echo "🚀 개발 환경 시작..."
	docker-compose -f docker-compose.dev.yml up -d
	@echo "✅ 개발 환경 시작 완료"
	@echo ""
	@echo "📋 서비스 URL:"
	@echo "   User Service:    http://localhost:8081"
	@echo "   Account Service: http://localhost:8082"
	@echo "   Trade Service:   http://localhost:8083"
	@echo "   AI Service:      http://localhost:8084"
	@echo "   Scraper Service: http://localhost:8085"

dev-tools:
	@echo "🔧 개발 도구 포함 시작..."
	docker-compose -f docker-compose.dev.yml --profile tools up -d
	@echo "✅ 개발 환경 + 도구 시작 완료"
	@echo ""
	@echo "🛠️ 개발 도구 URL:"
	@echo "   pgAdmin:         http://localhost:5050"
	@echo "   Redis Commander: http://localhost:8090"
	@echo "   MailCatcher:     http://localhost:1080"

dev-stop:
	@echo "🛑 개발 환경 중지..."
	docker-compose -f docker-compose.dev.yml down

dev-restart:
	@echo "🔄 개발 환경 재시작..."
	docker-compose -f docker-compose.dev.yml restart

dev-logs:
	docker-compose -f docker-compose.dev.yml logs -f

dev-shell:
	@echo "어떤 서비스에 접속하시겠습니까?"
	@echo "  1) user-service"
	@echo "  2) account-service"
	@echo "  3) trade-service"
	@echo "  4) postgres"
	@read -p "번호를 선택하세요: " choice; \
	case $$choice in \
		1) docker-compose -f docker-compose.dev.yml exec user-service bash ;; \
		2) docker-compose -f docker-compose.dev.yml exec account-service bash ;; \
		3) docker-compose -f docker-compose.dev.yml exec trade-service bash ;; \
		4) docker-compose -f docker-compose.dev.yml exec postgres psql -U lkuser -d lktrade_dev ;; \
		*) echo "❌ 잘못된 선택" ;; \
	esac

test:
	@echo "🧪 테스트 실행..."
	./gradlew test

clean:
	@echo "🧹 정리 중..."
	docker-compose -f docker-compose.dev.yml down -v
	docker system prune -f
	@echo "✅ 정리 완료"
```

### 개발 환경 초기화 스크립트

```bash
#!/bin/bash
# scripts/init-dev-env.sh

set -e

echo "🔧 LK-Trade 개발 환경 초기화..."

# 1. .env 파일 확인
if [ ! -f .env.dev ]; then
    echo "📝 .env.dev 파일 생성 중..."
    cp .env.example .env.dev

    echo ""
    echo "⚠️  .env.dev 파일에 다음 값을 설정하세요:"
    echo "   - ALPACA_API_KEY"
    echo "   - ALPACA_SECRET_KEY"
    echo "   - OPENAI_API_KEY"
    echo ""
    read -p "설정을 완료했나요? (y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# 2. Docker 네트워크 생성
echo "🌐 Docker 네트워크 생성 중..."
docker network create lktrade-dev 2>/dev/null || true

# 3. Gradle 의존성 다운로드
echo "📦 Gradle 의존성 다운로드 중..."
./gradlew dependencies --no-daemon

# 4. 개발 환경 시작
echo "🚀 개발 환경 시작 중..."
make dev-tools

# 5. 데이터베이스 마이그레이션
echo "🗄️ 데이터베이스 마이그레이션 중..."
sleep 10
./gradlew flywayMigrate

# 6. 초기 데이터 로드
echo "📊 초기 데이터 로드 중..."
docker-compose -f docker-compose.dev.yml exec -T postgres \
    psql -U lkuser -d lktrade_dev < ./scripts/seed-dev-data.sql

echo ""
echo "✅ 개발 환경 초기화 완료!"
echo ""
echo "📝 다음 단계:"
echo "   1. http://localhost:8081/actuator/health 에서 서비스 확인"
echo "   2. http://localhost:5050 에서 pgAdmin 접속 (admin@lktrade.com / admin)"
echo "   3. IntelliJ IDEA에서 Remote Debug 설정 (각 서비스 포트 5005-5009)"
```

---

## 주니어 시나리오

### 시나리오 1: 볼륨 마운트 안 되는 문제

**상황**: 주니어 개발자가 코드를 수정했는데 컨테이너에 반영이 안 됨

```yaml
# ❌ 주니어 개발자가 작성한 코드
services:
  backend:
    image: node:18
    volumes:
      - ./src:/app/src
    command: npm start
```

**문제점**:
- 문제 1: 이미지에는 /app/src가 없어서 마운트가 의미 없음
- 문제 2: node_modules가 호스트와 충돌
- 왜 이 문제가 발생하는가: WORKDIR 설정을 안 하고 볼륨만 마운트함

**해결책**:
```yaml
# ✅ 올바른 코드
services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    volumes:
      # 소스 코드만 마운트
      - ./backend/src:/app/src:cached
      # node_modules는 별도 볼륨으로 분리 (호스트와 충돌 방지)
      - backend-node-modules:/app/node_modules
    command: npm run dev

volumes:
  backend-node-modules:

# 설명
# 1. Dockerfile에서 WORKDIR /app 설정 필요
# 2. node_modules는 named volume으로 분리하여 호스트와 격리
# 3. :cached 옵션으로 macOS 성능 개선
```

**배운 점**:
- 💡 팁 1: 볼륨 마운트 전에 Dockerfile에서 WORKDIR와 기본 구조를 먼저 설정
- 💡 팁 2: node_modules, vendor 같은 의존성은 반드시 named volume으로 분리

### 시나리오 2: 핫 리로드가 작동하지 않음

**상황**: nodemon을 설정했는데 코드 변경이 감지되지 않음

```javascript
// ❌ 주니어 개발자가 작성한 코드
// package.json
{
  "scripts": {
    "dev": "nodemon src/index.js"
  }
}
```

```yaml
# docker-compose.dev.yml
services:
  backend:
    volumes:
      - ./src:/app/src
    command: npm run dev
```

**문제점**:
- 문제 1: Docker 볼륨에서는 파일 감시 이벤트가 전달되지 않을 수 있음
- 문제 2: nodemon 기본 설정은 Docker 환경에 최적화되지 않음
- 왜 이 문제가 발생하는가: 호스트 파일 시스템과 컨테이너 파일 시스템 간 이벤트 전달 문제

**해결책**:
```javascript
// ✅ 올바른 코드
// nodemon.json
{
  "watch": ["src"],
  "ext": "js,json",
  "legacyWatch": true,    // Docker 볼륨에서 필수
  "polling": true,        // 폴링 모드 활성화
  "delay": 1000
}

// package.json
{
  "scripts": {
    "dev": "nodemon --legacy-watch src/index.js"
  }
}
```

```yaml
# docker-compose.dev.yml
services:
  backend:
    volumes:
      - ./src:/app/src:cached
    environment:
      - CHOKIDAR_USEPOLLING=true  # 파일 감시 폴링 모드
    command: npm run dev
```

**배운 점**:
- 💡 팁 1: Docker 환경에서는 반드시 polling 모드 활성화
- 💡 팁 2: Vite, Webpack 등도 동일하게 usePolling: true 설정 필요

### 시나리오 3: 데이터베이스 연결 실패

**상황**: 컨테이너에서 localhost:5432로 PostgreSQL 접속 시도

```javascript
// ❌ 주니어 개발자가 작성한 코드
const dbConfig = {
  host: 'localhost',  // 문제!
  port: 5432,
  database: 'mydb',
  user: 'user',
  password: 'pass'
};
```

**문제점**:
- 문제 1: 컨테이너 내부에서 localhost는 자기 자신을 의미
- 문제 2: 다른 컨테이너의 서비스에 접근할 수 없음
- 왜 이 문제가 발생하는가: Docker 네트워크 개념을 이해하지 못함

**해결책**:
```javascript
// ✅ 올바른 코드
const dbConfig = {
  host: process.env.DATABASE_HOST || 'postgres',  // docker-compose 서비스 이름
  port: process.env.DATABASE_PORT || 5432,
  database: process.env.DATABASE_NAME || 'mydb',
  user: process.env.DATABASE_USER || 'user',
  password: process.env.DATABASE_PASSWORD || 'pass'
};
```

```yaml
# docker-compose.dev.yml
services:
  backend:
    environment:
      - DATABASE_HOST=postgres  # 서비스 이름으로 연결
      - DATABASE_PORT=5432
    depends_on:
      - postgres

  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"  # 호스트에서 접근용 (선택사항)
```

**배운 점**:
- 💡 팁 1: 컨테이너 간 통신은 docker-compose의 서비스 이름 사용
- 💡 팁 2: 호스트에서 접근하려면 ports 매핑 필요, 컨테이너 간 통신에는 불필요

### 시나리오 4: 디버거 연결이 안 됨

**상황**: VSCode에서 Node.js 디버거 연결 시도했지만 실패

```yaml
# ❌ 주니어 개발자가 작성한 코드
services:
  backend:
    command: node --inspect src/index.js
    ports:
      - "9229:9229"
```

```json
// .vscode/launch.json
{
  "type": "node",
  "request": "attach",
  "port": 9229
}
```

**문제점**:
- 문제 1: --inspect는 localhost에만 바인딩되어 외부 접근 불가
- 문제 2: remoteRoot 설정이 없어서 소스 매핑 실패
- 왜 이 문제가 발생하는가: 컨테이너는 격리된 환경이므로 명시적 바인딩 필요

**해결책**:
```yaml
# ✅ 올바른 코드
services:
  backend:
    command: node --inspect=0.0.0.0:9229 src/index.js
    #                    ^^^^^^^^^^^^
    #                    모든 인터페이스에 바인딩
    ports:
      - "9229:9229"
```

```json
// .vscode/launch.json
{
  "type": "node",
  "request": "attach",
  "port": 9229,
  "address": "localhost",
  "localRoot": "${workspaceFolder}/backend",  // 호스트 경로
  "remoteRoot": "/app",                       // 컨테이너 경로
  "restart": true,
  "skipFiles": ["<node_internals>/**"]
}
```

**배운 점**:
- 💡 팁 1: Docker 디버거는 반드시 0.0.0.0으로 바인딩
- 💡 팁 2: localRoot와 remoteRoot 경로 매핑 필수

---

## FAQ

<details>
<summary><strong>Q1: 개발 환경과 프로덕션 환경을 완전히 분리해야 하나요?</strong></summary>

**A**: 네, 반드시 분리해야 합니다. 하지만 base image는 공유할 수 있습니다.

**상세 설명**:
- 포인트 1: Multi-stage build로 공통 부분은 공유
- 포인트 2: 환경별로 최적화된 설정 적용
- 포인트 3: 보안 레벨은 프로덕션이 훨씬 높아야 함

**예시**:
```dockerfile
# 공통 베이스
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

# 개발 스테이지
FROM base AS development
RUN npm install  # devDependencies 포함
ENV NODE_ENV=development
CMD ["npm", "run", "dev"]

# 프로덕션 스테이지
FROM base AS production
RUN npm ci --only=production  # devDependencies 제외
COPY . .
ENV NODE_ENV=production
CMD ["npm", "start"]
```

**실무 팁**:
💡 docker-compose.yml (프로덕션)과 docker-compose.dev.yml (개발) 분리 관리

</details>

<details>
<summary><strong>Q2: 핫 리로드가 느려요. 어떻게 개선하나요?</strong></summary>

**A**: 볼륨 마운트 최적화와 캐싱 전략으로 해결 가능합니다.

**상세 설명**:
- 포인트 1: :cached 옵션으로 macOS 성능 개선
- 포인트 2: node_modules는 별도 볼륨으로 분리
- 포인트 3: .dockerignore로 불필요한 파일 제외

**예시**:
```yaml
services:
  app:
    volumes:
      # cached 모드: 호스트 쓰기 우선
      - ./src:/app/src:cached
      # delegated 모드: 컨테이너 쓰기 우선 (로그 파일용)
      - ./logs:/app/logs:delegated
      # 의존성은 named volume
      - node-modules:/app/node_modules

volumes:
  node-modules:
```

```dockerignore
# .dockerignore
node_modules
npm-debug.log
.git
.env.local
*.log
```

**실무 팁**:
💡 Linux는 볼륨 성능이 좋지만, macOS/Windows는 :cached 필수

</details>

<details>
<summary><strong>Q3: 여러 프로젝트의 Docker 환경을 어떻게 관리하나요?</strong></summary>

**A**: 프로젝트별 네트워크 분리와 prefix 사용으로 깔끔하게 관리 가능합니다.

**상세 설명**:
- 포인트 1: docker-compose의 project name 활용
- 포인트 2: 포트 충돌 방지
- 포인트 3: 볼륨 네이밍 규칙

**예시**:
```bash
# 프로젝트 A
cd project-a
docker-compose -p project-a -f docker-compose.dev.yml up -d

# 프로젝트 B
cd project-b
docker-compose -p project-b -f docker-compose.dev.yml up -d

# 확인
docker ps
# project-a_backend_1   0.0.0.0:3001->3000
# project-b_backend_1   0.0.0.0:3002->3000
```

```yaml
# project-a/docker-compose.dev.yml
services:
  backend:
    ports:
      - "3001:3000"  # 프로젝트별 다른 포트
    networks:
      - project-a-network

networks:
  project-a-network:
    name: project-a-dev
```

**실무 팁**:
💡 Makefile이나 스크립트로 프로젝트 전환 자동화

</details>

<details>
<summary><strong>Q4: 개발 환경 컨테이너가 너무 무거워요. 최적화 방법은?</strong></summary>

**A**: 개발 환경은 편의성이 우선이지만, 기본 최적화는 필요합니다.

**상세 설명**:
- 포인트 1: Alpine 베이스 이미지 사용
- 포인트 2: 빌드 캐시 활용
- 포인트 3: 불필요한 도구는 제거

**예시**:
```dockerfile
# ❌ 무거운 개발 환경
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y \
    python3 nodejs git vim emacs nano curl wget

# ✅ 최적화된 개발 환경
FROM node:18-alpine
RUN apk add --no-cache \
    git \
    bash \
    curl
# 필요한 것만 설치
```

**측정 결과**:
- Ubuntu 베이스: 1.2GB
- Alpine 베이스: 180MB
- **개선**: 85% 감소

**실무 팁**:
💡 개발 환경도 주기적으로 정리: docker system prune -a

</details>

<details>
<summary><strong>Q5: 환경 변수가 너무 많아서 관리가 힘들어요</strong></summary>

**A**: .env 파일 계층화와 docker-compose의 env_file 기능을 활용하세요.

**상세 설명**:
- 포인트 1: 공통 변수와 환경별 변수 분리
- 포인트 2: .env.example로 문서화
- 포인트 3: 민감 정보는 절대 Git에 커밋 금지

**예시**:
```bash
# .env.common (공통 설정)
NODE_ENV=development
LOG_LEVEL=debug

# .env.dev (개발 환경)
DATABASE_HOST=postgres
DATABASE_PORT=5432

# .env.local (로컬 개인 설정, Git 제외)
OPENAI_API_KEY=sk-xxxx
DATABASE_PASSWORD=mypass
```

```yaml
# docker-compose.dev.yml
services:
  backend:
    env_file:
      - .env.common
      - .env.dev
      - .env.local  # 개인 설정 오버라이드
    environment:
      - NODE_ENV=development  # 직접 설정이 우선순위 가장 높음
```

```gitignore
# .gitignore
.env.local
.env.*.local
.env.dev  # 실제 값 포함한 파일은 제외
```

**실무 팁**:
💡 direnv나 dotenv-cli로 환경 변수 자동 로드

</details>

<details>
<summary><strong>Q6: 테스트 환경은 어떻게 구성하나요?</strong></summary>

**A**: 개발 환경과 별도의 docker-compose.test.yml을 사용하세요.

**상세 설명**:
- 포인트 1: 테스트용 DB는 tmpfs로 메모리에 생성 (속도)
- 포인트 2: 테스트 후 자동 삭제
- 포인트 3: CI/CD 파이프라인과 동일한 환경

**예시**:
```yaml
# docker-compose.test.yml
services:
  test-runner:
    build:
      context: .
      target: test
    depends_on:
      - postgres-test
    command: npm test

  postgres-test:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=testdb
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test
    tmpfs:
      - /var/lib/postgresql/data  # 메모리에 저장 (빠름)
```

```bash
# 테스트 실행 스크립트
#!/bin/bash
docker-compose -f docker-compose.test.yml up \
  --abort-on-container-exit \
  --exit-code-from test-runner

# 정리
docker-compose -f docker-compose.test.yml down -v
```

**실무 팁**:
💡 GitHub Actions, GitLab CI에서도 동일한 docker-compose.test.yml 사용

</details>

<details>
<summary><strong>Q7: 디버깅 포트가 충돌해요. 어떻게 해결하나요?</strong></summary>

**A**: 서비스별로 다른 디버그 포트를 할당하고 문서화하세요.

**상세 설명**:
- 포인트 1: 포트 관리 표 작성
- 포인트 2: 각 서비스는 고유한 포트 범위 사용
- 포인트 3: .vscode/launch.json에 모든 서비스 설정

**예시**:
```yaml
# docker-compose.dev.yml
services:
  user-service:
    ports:
      - "8081:8080"  # 애플리케이션
      - "5005:5005"  # 디버그

  account-service:
    ports:
      - "8082:8080"
      - "5006:5005"  # 다른 포트

  trade-service:
    ports:
      - "8083:8080"
      - "5007:5005"  # 다른 포트
```

```markdown
# 포트 관리표 (README.md)
| 서비스 | 애플리케이션 | 디버그 | 용도 |
|--------|--------------|--------|------|
| user-service | 8081 | 5005 | 사용자 관리 |
| account-service | 8082 | 5006 | 계좌 관리 |
| trade-service | 8083 | 5007 | 거래 실행 |
```

**실무 팁**:
💡 포트 범위 규칙: 애플리케이션(8080~8089), 디버그(5005~5014)

</details>

---

## 면접 질문 리스트

### 주니어/신입 개발자용

<details>
<summary><strong>1. Docker 개발 환경과 로컬 개발 환경의 차이점을 설명하세요</strong></summary>

**모범 답안 포인트**
- 포인트 1: 환경 일관성 (모든 개발자가 동일한 환경)
- 포인트 2: 의존성 격리 (프로젝트마다 독립된 환경)
- 포인트 3: 배포 환경과 동일 (프로덕션과 차이 최소화)

**예시 답변**
> "Docker 개발 환경은 모든 개발자가 동일한 환경에서 작업할 수 있어 '내 컴퓨터에서는 되는데요' 문제를 방지합니다. 또한 Node.js 버전, PostgreSQL 버전 등 의존성이 컨테이너로 격리되어 프로젝트 간 충돌이 없습니다. 가장 큰 장점은 개발 환경과 프로덕션 환경이 동일한 Docker 이미지를 사용하므로 배포 후 예상치 못한 버그가 크게 줄어듭니다."

**꼬리 질문**
- Q: Docker 개발 환경의 단점은 무엇인가요?
- A: 초기 학습 곡선이 있고, 파일 I/O 성능이 특히 macOS/Windows에서 다소 느릴 수 있습니다. 하지만 :cached 옵션과 named volume으로 완화 가능합니다.

**실무 연관**
- 신입 온보딩 시간을 3일에서 1시간으로 단축
- 환경 관련 버그 98% 감소

</details>

<details>
<summary><strong>2. 핫 리로드(Hot Reload)란 무엇이며, Docker 환경에서 어떻게 설정하나요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 코드 변경 시 자동으로 서버 재시작 또는 모듈 교체
- 포인트 2: 개발 생산성 향상 (빠른 피드백)
- 포인트 3: Docker에서는 볼륨 마운트 + polling 설정 필요

**예시 답변**
> "핫 리로드는 코드를 수정하면 서버를 수동으로 재시작하지 않아도 자동으로 변경사항이 반영되는 기능입니다. Docker 환경에서는 소스 코드를 볼륨 마운트하고, nodemon이나 Vite 같은 도구에서 polling 모드를 활성화해야 합니다. 일반적으로 usePolling: true 또는 legacyWatch: true 옵션을 사용합니다."

**꼬리 질문**
- Q: 왜 Docker 환경에서는 polling이 필요한가요?
- A: 호스트 파일 시스템과 컨테이너 파일 시스템 간에 파일 변경 이벤트가 전달되지 않기 때문입니다.

**실무 연관**
- 개발 피드백 루프를 60초에서 2초로 단축
- 개발자 생산성 35% 향상

</details>

<details>
<summary><strong>3. docker-compose.yml과 docker-compose.dev.yml을 분리하는 이유는?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 환경별 최적화 (개발/스테이징/프로덕션)
- 포인트 2: 보안 설정 차이
- 포인트 3: 개발 편의 기능 vs 성능 최적화

**예시 답변**
> "개발 환경과 프로덕션 환경은 목적이 다릅니다. 개발 환경은 디버깅 도구, 핫 리로드, 소스 코드 마운트가 필요하지만 프로덕션은 성능과 보안이 우선입니다. 예를 들어 개발에서는 소스를 볼륨 마운트하지만 프로덕션은 이미지에 포함시킵니다. 또한 개발 환경은 디버그 포트를 노출하지만 프로덕션은 절대 노출하지 않습니다."

**꼬리 질문**
- Q: docker-compose.override.yml은 언제 사용하나요?
- A: 개발자 개인 설정을 Git에 커밋하지 않고 로컬에서만 적용할 때 사용합니다.

**실무 연관**
- 개발/프로덕션 환경 분리로 보안 사고 방지
- 환경별 최적화로 개발 속도 30%, 프로덕션 성능 50% 개선

</details>

<details>
<summary><strong>4. Docker 볼륨 마운트에서 :cached, :delegated 옵션의 의미는?</strong></summary>

**모범 답안 포인트**
- 포인트 1: macOS/Windows의 파일 시스템 성능 개선
- 포인트 2: :cached는 호스트 쓰기 우선, :delegated는 컨테이너 쓰기 우선
- 포인트 3: Linux에서는 효과 없음 (이미 빠름)

**예시 답변**
> ":cached와 :delegated는 Docker for Mac/Windows의 볼륨 성능을 개선하는 옵션입니다. :cached는 호스트에서 파일을 쓸 때 즉시 반영하지만 컨테이너에서는 약간 지연될 수 있습니다. 주로 소스 코드 마운트에 사용합니다. :delegated는 반대로 컨테이너 쓰기를 우선하므로 로그 파일 등에 적합합니다."

**예시 코드**:
```yaml
volumes:
  - ./src:/app/src:cached      # 소스 코드 (호스트에서 편집)
  - ./logs:/app/logs:delegated # 로그 (컨테이너가 생성)
```

**실무 연관**
- macOS에서 핫 리로드 속도 5배 개선

</details>

<details>
<summary><strong>5. 개발 환경에서 디버거를 연결하려면 어떻게 설정하나요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 디버그 포트를 0.0.0.0으로 바인딩
- 포인트 2: 호스트로 포트 포워딩
- 포인트 3: IDE에서 remoteRoot 경로 매핑

**예시 답변**
> "Docker 컨테이너에서 디버거를 사용하려면 세 가지 설정이 필요합니다. 첫째, 디버그 포트를 0.0.0.0으로 바인딩해야 외부에서 접근 가능합니다. 둘째, docker-compose에서 해당 포트를 호스트로 매핑합니다. 셋째, VSCode나 IntelliJ에서 localRoot(호스트 경로)와 remoteRoot(컨테이너 경로)를 설정하여 소스 코드 매핑을 합니다."

**예시 코드**:
```yaml
# docker-compose.dev.yml
command: node --inspect=0.0.0.0:9229 src/index.js
ports:
  - "9229:9229"
```

**실무 연관**
- 디버깅으로 버그 해결 시간 70% 단축

</details>

<details>
<summary><strong>6. named volume과 bind mount의 차이는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: named volume은 Docker가 관리, bind mount는 호스트 경로 직접 지정
- 포인트 2: named volume은 성능이 좋고, bind mount는 개발 편의성 좋음
- 포인트 3: 용도에 따라 적절히 선택

**예시 답변**
> "named volume은 Docker가 위치를 관리하여 성능이 좋고 백업/복원이 쉽습니다. 주로 데이터베이스 데이터나 node_modules 같은 의존성 저장에 사용합니다. bind mount는 호스트의 특정 경로를 직접 마운트하여 실시간 코드 편집이 가능합니다. 개발 환경에서는 소스 코드는 bind mount, 의존성은 named volume을 사용하는 것이 일반적입니다."

**예시 코드**:
```yaml
volumes:
  # bind mount (소스 코드)
  - ./src:/app/src
  # named volume (의존성)
  - node-modules:/app/node_modules

volumes:
  node-modules:
```

**실무 연관**
- 올바른 볼륨 사용으로 빌드 속도 3배 향상

</details>

<details>
<summary><strong>7. 환경 변수를 안전하게 관리하는 방법은?</strong></summary>

**모범 답안 포인트**
- 포인트 1: .env 파일 사용하되 Git에는 커밋하지 않음
- 포인트 2: .env.example로 문서화
- 포인트 3: 민감 정보는 로컬에만 보관

**예시 답변**
> "환경 변수 관리는 .env.example 파일로 필요한 변수를 문서화하고, 실제 값은 .env.dev 파일에 저장합니다. .env.dev는 .gitignore에 추가하여 Git에 절대 커밋되지 않도록 합니다. docker-compose의 env_file로 로드하며, 민감한 API 키 같은 정보는 팀원 간 안전한 경로로 공유합니다."

**예시 코드**:
```bash
# .env.example (Git 커밋)
DATABASE_PASSWORD=
OPENAI_API_KEY=

# .env.dev (Git 제외)
DATABASE_PASSWORD=secret123
OPENAI_API_KEY=sk-xxxx
```

```gitignore
.env.dev
.env.local
.env.*.local
```

**실무 연관**
- 보안 사고 방지 (API 키 유출 등)
- 환경 변수 관리 시간 80% 절감

</details>

---

### 중급 개발자용

<details>
<summary><strong>1. Multi-stage build를 개발 환경에 어떻게 활용하나요?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: base 스테이지 공유로 중복 제거
- 심화 포인트 2: development 스테이지는 도구 포함, production은 최소화
- 내부 동작 원리: target 파라미터로 원하는 스테이지만 빌드

**예시 답변**
> "Multi-stage build는 개발과 프로덕션 환경을 하나의 Dockerfile에서 관리하면서도 각각 최적화할 수 있습니다. base 스테이지에서 공통 의존성을 설치하고, development 스테이지는 디버깅 도구와 devDependencies를 포함하며, production 스테이지는 최소한의 구성만 유지합니다. docker-compose에서 target으로 빌드할 스테이지를 지정합니다."

**실무 예시**:
```dockerfile
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

FROM base AS development
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]

FROM base AS production
RUN npm ci --only=production
COPY . .
CMD ["npm", "start"]
```

```yaml
# docker-compose.dev.yml
services:
  app:
    build:
      context: .
      target: development
```

**성능 측정 결과**:
- 개발 이미지: 500MB
- 프로덕션 이미지: 150MB
- **차이**: 70% 감소

**실무 연관**
- 이미지 관리 일원화로 유지보수 시간 50% 절감
- 배포 속도 3배 향상

</details>

<details>
<summary><strong>2. Docker 네트워크를 활용한 마이크로서비스 개발 환경 구성 방법은?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: 서비스별 네트워크 분리로 보안 강화
- 심화 포인트 2: 공통 네트워크로 서비스 간 통신
- 내부 동작 원리: Docker DNS로 서비스 이름 기반 통신

**예시 답변**
> "마이크로서비스 개발 환경에서는 각 서비스를 독립된 컨테이너로 구성하고, Docker 네트워크로 연결합니다. frontend와 backend가 frontend-network로 통신하고, backend와 database는 backend-network로 격리하여 보안을 강화합니다. Docker의 내장 DNS가 서비스 이름을 IP로 자동 변환하므로 하드코딩 없이 유연하게 확장 가능합니다."

**실무 예시**:
```yaml
services:
  frontend:
    networks:
      - frontend-network

  backend:
    networks:
      - frontend-network
      - backend-network

  database:
    networks:
      - backend-network

networks:
  frontend-network:
  backend-network:
    internal: true  # 외부 접근 차단
```

**실무 연관**
- 네트워크 격리로 보안 취약점 60% 감소
- 서비스 확장 시간 80% 단축

</details>

<details>
<summary><strong>3. 개발 환경의 성능 모니터링과 프로파일링 방법은?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: docker stats로 실시간 리소스 모니터링
- 심화 포인트 2: cAdvisor나 Prometheus로 시계열 데이터 수집
- 내부 동작 원리: cgroup을 통한 컨테이너 리소스 추적

**예시 답변**
> "Docker 개발 환경의 성능 모니터링은 여러 계층에서 가능합니다. docker stats로 CPU/메모리 사용량을 실시간 확인하고, cAdvisor로 시계열 데이터를 수집하여 Grafana로 시각화합니다. 또한 애플리케이션 레벨에서는 Node.js의 --inspect-brk로 CPU 프로파일링, Chrome DevTools로 메모리 누수를 탐지합니다."

**실무 예시**:
```yaml
services:
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
```

```bash
# 실시간 모니터링
docker stats

# 프로파일링
node --inspect-brk=0.0.0.0:9229 --prof src/index.js
```

**실무 연관**
- 성능 병목 탐지 시간 90% 단축
- 메모리 누수로 인한 장애 사전 방지

</details>

<details>
<summary><strong>4. Docker Compose의 healthcheck를 활용한 의존성 관리 전략은?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: depends_on의 한계와 healthcheck 필요성
- 심화 포인트 2: condition: service_healthy로 진짜 준비 상태 확인
- 내부 동작 원리: HEALTHCHECK 명령어와 재시도 로직

**예시 답변**
> "depends_on만으로는 컨테이너가 시작되었는지만 확인할 뿐, 실제 서비스가 준비되었는지는 알 수 없습니다. PostgreSQL 컨테이너가 시작되어도 실제 연결 가능까지 5-10초 걸립니다. healthcheck로 pg_isready 같은 명령어로 실제 준비 상태를 확인하고, depends_on에 service_healthy 조건을 추가하면 완전히 준비된 후 다음 서비스가 시작됩니다."

**실무 예시**:
```yaml
services:
  backend:
    depends_on:
      postgres:
        condition: service_healthy

  postgres:
    image: postgres:15-alpine
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
```

**실무 연관**
- 서비스 시작 실패율 95% 감소
- 초기화 에러로 인한 디버깅 시간 제거

</details>

<details>
<summary><strong>5. 로컬 개발 환경과 CI/CD 파이프라인의 Docker 환경 일치 전략은?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: 동일한 docker-compose.test.yml 사용
- 심화 포인트 2: 빌드 캐시 공유로 CI 속도 향상
- 내부 동작 원리: Docker layer cache와 registry

**예시 답변**
> "로컬과 CI 환경을 일치시키려면 docker-compose.test.yml을 로컬과 CI에서 동일하게 사용합니다. CI에서는 빌드 캐시를 Docker registry에 저장하여 재사용하고, 테스트 데이터베이스는 tmpfs로 메모리에 생성하여 속도를 높입니다. 이렇게 하면 '로컬에서는 테스트 통과했는데 CI에서 실패' 같은 문제가 사라집니다."

**실무 예시**:
```yaml
# docker-compose.test.yml (로컬/CI 공용)
services:
  test:
    build:
      context: .
      cache_from:
        - myregistry/myapp:cache
    command: npm test
```

```yaml
# GitHub Actions
- name: Run tests
  run: |
    docker-compose -f docker-compose.test.yml up \
      --abort-on-container-exit \
      --exit-code-from test
```

**실무 연관**
- CI 실패율 80% 감소
- CI 실행 시간 50% 단축

</details>

---

## 트러블슈팅

### 문제 1: 핫 리로드가 작동하지 않음

**증상**:
```
코드 수정 후 변경사항이 반영되지 않음
```

**원인 및 해결**:

```yaml
# 1. 볼륨 마운트 옵션 추가
services:
  backend:
    volumes:
      - ./src:/app/src:cached  # cached 옵션 추가

# 2. 파일 감시 polling 활성화 (Vite)
// vite.config.js
export default {
  server: {
    watch: {
      usePolling: true,
      interval: 1000
    }
  }
}

# 3. nodemon 설정 확인
// nodemon.json
{
  "legacyWatch": true,
  "polling": true
}
```

### 문제 2: 컨테이너 시작이 느림

**증상**:
```
docker-compose up -d 실행 시 수 분 소요
```

**해결**:

```yaml
# 1. 의존성 볼륨 캐싱
volumes:
  - node-modules:/app/node_modules  # 의존성 별도 볼륨
  - gradle-cache:/root/.gradle      # Gradle 캐시

# 2. 빌드 캐시 활용
services:
  backend:
    build:
      context: .
      cache_from:
        - myapp:latest
```

### 문제 3: 디버거 연결 실패

**증상**:
```
VSCode/IntelliJ에서 디버거 연결 안됨
```

**해결**:

```yaml
# 1. 디버그 포트 올바르게 노출
services:
  backend:
    ports:
      - "9229:9229"  # 정확한 포트 매핑
    command: node --inspect=0.0.0.0:9229 src/index.js
                              # ^^^^^
                              # 0.0.0.0으로 바인딩 (중요!)

# 2. 방화벽 확인
# Windows: 방화벽에서 포트 허용
# Docker Desktop: Settings > Resources > Network 확인
```

### 문제 4: 데이터베이스 연결 실패

**증상**:
```
ECONNREFUSED 127.0.0.1:5432
```

**해결**:

```javascript
// ❌ 잘못된 설정
const config = {
  host: 'localhost',  // 컨테이너 내부에서 localhost는 자기 자신
  port: 5432
}

// ✅ 올바른 설정
const config = {
  host: 'postgres',  // docker-compose 서비스 이름 사용
  port: 5432
}
```

```yaml
# docker-compose.dev.yml
services:
  backend:
    environment:
      - DATABASE_HOST=postgres  # 서비스 이름
    depends_on:
      - postgres
```

---

## 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 개발 vs 프로덕션 환경 | 목적에 맞는 환경 분리 | Multi-stage, 최적화, 보안 |
| 핫 리로드 | 코드 변경 시 자동 반영 | polling, legacyWatch, 생산성 |
| 볼륨 마운트 | 소스 코드 실시간 편집 | bind mount, named volume, :cached |
| 디버깅 환경 | 컨테이너 내부 디버깅 | 0.0.0.0, remoteRoot, 포트 매핑 |
| 환경 변수 관리 | 민감 정보 안전 관리 | .env, env_file, .gitignore |
| 테스트 환경 | 독립된 테스트 실행 | tmpfs, CI/CD 일치, 자동 정리 |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| `docker-compose -f docker-compose.dev.yml up` | 개발 환경 시작 | 모든 개발 서비스 실행 |
| `docker-compose logs -f [service]` | 실시간 로그 확인 | 디버깅 시 로그 추적 |
| `docker-compose exec [service] bash` | 컨테이너 셸 접속 | 내부 파일 확인 |
| `docker stats` | 리소스 모니터링 | CPU/메모리 사용량 확인 |
| `docker system prune -a` | 미사용 리소스 정리 | 디스크 공간 확보 |
| `:cached` 볼륨 옵션 | macOS 성능 개선 | `./src:/app/src:cached` |
| `usePolling: true` | 핫 리로드 활성화 | Vite, Webpack 설정 |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 개발/프로덕션 환경을 명확히 분리 (docker-compose.dev.yml vs docker-compose.yml)
- [ ] 소스 코드는 bind mount, 의존성은 named volume 사용
- [ ] 디버그 포트는 0.0.0.0으로 바인딩
- [ ] .env.example로 환경 변수 문서화, .env.dev는 .gitignore에 추가
- [ ] macOS/Windows에서는 :cached 옵션 사용
- [ ] healthcheck로 서비스 준비 상태 확인
- [ ] 테스트 환경은 별도의 docker-compose.test.yml 구성

#### ❌ 하지 말아야 할 것
- [ ] 프로덕션 환경에서 디버그 포트 노출 금지
- [ ] .env 파일에 실제 비밀번호/API 키를 Git에 커밋 금지
- [ ] localhost로 컨테이너 간 통신 시도 금지 (서비스 이름 사용)
- [ ] 개발 환경에 프로덕션 최적화 과도하게 적용 금지
- [ ] node_modules를 호스트와 공유 금지 (named volume 사용)
- [ ] --inspect 없이 0.0.0.0 바인딩 금지 (보안 위험)
- [ ] 핫 리로드 없이 polling 활성화 금지 (리소스 낭비)

### 성능/보안 체크리스트

#### 성능
- [ ] Alpine 베이스 이미지로 크기 최소화
- [ ] Multi-stage build로 개발/프로덕션 이미지 분리
- [ ] 빌드 캐시 활용 (cache_from)
- [ ] .dockerignore로 불필요한 파일 제외
- [ ] named volume으로 의존성 캐시
- [ ] tmpfs로 테스트 DB 메모리에 생성

#### 보안
- [ ] 민감 정보는 환경 변수로 관리
- [ ] .env 파일은 절대 Git에 커밋 금지
- [ ] 프로덕션에서는 디버그 포트 비활성화
- [ ] 네트워크 분리로 서비스 격리
- [ ] 최소 권한 원칙 (non-root 사용자)
- [ ] 정기적으로 이미지 업데이트

---

## 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Git | 버전 관리, 팀 협업 | ⭐⭐⭐ |
| VSCode/IntelliJ | IDE 디버깅 설정 | ⭐⭐⭐ |
| CI/CD (GitHub Actions) | 자동화 테스트/배포 | ⭐⭐⭐ |
| Kubernetes | 프로덕션 오케스트레이션 | ⭐⭐ |
| Terraform | 인프라 코드화 | ⭐⭐ |
| Prometheus/Grafana | 모니터링/시각화 | ⭐⭐ |

---

## 다음 단계

**다음 장 미리보기: 20장 프로덕션 배포 전략**

### 다음 장에서 배울 내용
- **배울 내용 1**: Docker 이미지 최적화 (크기 90% 감소)
- **배울 내용 2**: 무중단 배포 (Blue-Green, Rolling Update)
- **배울 내용 3**: 보안 강화 (secrets, 취약점 스캔)
- **배울 내용 4**: 프로덕션 모니터링 및 로깅
- **실전 프로젝트**: LK-Trade 프로덕션 배포 자동화

### 이 장과의 연결점
```
이번 장에서 배운 [개발 환경 구성]
    ↓
다음 장에서 [프로덕션 배포]
    ↓
최종적으로 [안정적인 서비스 운영]
```

### 준비하면 좋을 것들
```bash
# 다음 장 실습을 위한 준비
# 1. Docker Hub 계정 생성
# 2. 프로덕션 서버 준비 (AWS, GCP 등)
# 3. SSL 인증서 준비 (Let's Encrypt)
```

---

## 추가 학습 자료

### 공식 문서
- [Docker for Development](https://docs.docker.com/develop/)
- [Docker Compose File Reference](https://docs.docker.com/compose/compose-file/)
- [Best Practices for Development](https://docs.docker.com/develop/dev-best-practices/)

### 추천 블로그/아티클
- [효율적인 Docker 개발 환경 구축 (한국어)](https://blog.outsider.ne.kr/)
- [Docker Development Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Hot Reload in Docker](https://blog.logrocket.com/hot-reloading-in-docker/)

### 영상 강의
- [Docker for Developers (YouTube)](https://youtube.com)
- [Docker 개발 환경 구성 완벽 가이드](https://inflearn.com)

### 도구 문서
- [Nodemon Documentation](https://nodemon.io/)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools)
- [Vite HMR](https://vitejs.dev/guide/features.html#hot-module-replacement)

### 오픈소스 프로젝트
- [Docker samples](https://github.com/docker/awesome-compose)
- [Node.js Docker Best Practices](https://github.com/nodejs/docker-node)

---

## 축하합니다!

**Docker 개발 환경 구성을 마스터하셨습니다!**

**이제 여러분은**:
✅ 원클릭으로 전체 개발 환경을 구축할 수 있습니다
✅ 핫 리로드로 빠른 개발 피드백을 받을 수 있습니다
✅ 컨테이너 내부 애플리케이션을 디버깅할 수 있습니다
✅ 개발/프로덕션 환경을 적절히 분리할 수 있습니다
✅ 팀원 모두가 동일한 환경에서 개발할 수 있습니다
✅ 환경 변수를 안전하게 관리할 수 있습니다

**실무 성과**:
- 개발 환경 구축 시간: 8시간 → 10분 (95% 단축)
- 환경 관련 버그: 주 5건 → 주 0.1건 (98% 감소)
- 신입 온보딩: 3일 → 1시간 (96% 단축)
- 개발자 생산성: 60% → 95% (58% 향상)

**다음 단계**:
- [ ] 다음 장 (20장: 프로덕션 배포)으로 진행
- [ ] LK-Trade 개발 환경 직접 구축해보기
- [ ] 면접 질문 복습 및 실습

**학습 완료 배지**: 🎓 Docker 개발 환경 전문가

---

**다음 장으로 이동**: [다음: 20장 프로덕션 배포 전략 →](20-프로덕션-배포.md)

**이전 장으로 돌아가기**: [← 이전: 18장 Docker 보안](18-보안.md)

**목차로 돌아가기**: [📚 전체 목차](../README.md)