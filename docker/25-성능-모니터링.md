# 25. 컨테이너 성능 모니터링

## 목차
1. [성능 모니터링의 중요성](#성능-모니터링의-중요성)
2. [docker stats 활용](#docker-stats-활용)
3. [cAdvisor 설치 및 사용](#cadvisor-설치-및-사용)
4. [Prometheus + Grafana 연동](#prometheus-grafana-연동)
5. [성능 메트릭 분석](#성능-메트릭-분석)
6. [병목 지점 찾기](#병목-지점-찾기)
7. [알림 설정](#알림-설정)
8. [실전 예제: LK-Trade 모니터링](#실전-예제-lk-trade-모니터링)
9. [트러블슈팅](#트러블슈팅)

---

## 성능 모니터링의 중요성

### 왜 모니터링이 필요한가?

**실생활 비유**: 자동차 계기판

```
계기판 없는 자동차:
- 속도를 모름
- 연료가 얼마나 남았는지 모름
- 엔진 과열 여부 모름
→ 언제 고장날지 예측 불가능 ❌

계기판 있는 자동차:
- 실시간 속도 확인
- 연료 잔량 확인
- 엔진 온도 확인
→ 문제 발생 전 조치 가능 ✅
```

**Docker 환경**:
```
모니터링 없음:
- CPU 사용률? 모름
- 메모리 사용량? 모름
- 디스크 I/O? 모름
→ 서비스 다운 후 원인 파악 ❌

모니터링 있음:
- CPU 95% → 스케일 아웃 필요
- 메모리 90% → 증설 필요
- 디스크 I/O 병목 → 튜닝 필요
→ 문제 발생 전 예방 ✅
```

### 모니터링해야 할 주요 메트릭

```
┌─────────────────────┬──────────────────────────────────┐
│   메트릭 종류       │          의미                    │
├─────────────────────┼──────────────────────────────────┤
│ CPU 사용률          │ 프로세서 부하 수준               │
│                     │ (높으면 스케일 아웃 필요)        │
├─────────────────────┼──────────────────────────────────┤
│ 메모리 사용량       │ RAM 사용 정도                    │
│                     │ (높으면 메모리 증설 또는 누수)   │
├─────────────────────┼──────────────────────────────────┤
│ 네트워크 I/O        │ 송수신 데이터량                  │
│                     │ (대역폭 병목 확인)               │
├─────────────────────┼──────────────────────────────────┤
│ 디스크 I/O          │ 읽기/쓰기 속도                   │
│                     │ (스토리지 병목 확인)             │
├─────────────────────┼──────────────────────────────────┤
│ 응답 시간           │ 요청 처리 시간                   │
│                     │ (사용자 경험 지표)               │
├─────────────────────┼──────────────────────────────────┤
│ 에러율              │ 실패한 요청 비율                 │
│                     │ (서비스 안정성 지표)             │
└─────────────────────┴──────────────────────────────────┘
```

---

## docker stats 활용

### 기본 사용법

```bash
# 실시간 모니터링 (계속 갱신)
docker stats

# 1회만 출력
docker stats --no-stream

# 특정 컨테이너만
docker stats user-service account-service

# 모든 컨테이너 (중지된 것 포함)
docker stats --all
```

### 출력 형식

```
CONTAINER ID   NAME           CPU %   MEM USAGE / LIMIT   MEM %   NET I/O         BLOCK I/O
a1b2c3d4e5f6   user-service   2.50%   450MiB / 1GiB       43.95%  1.2kB / 648B    0B / 0B
```

**각 열의 의미**:
- **CPU %**: CPU 사용률 (멀티코어 환경에서는 100% 이상 가능)
- **MEM USAGE / LIMIT**: 현재 메모리 / 제한
- **MEM %**: 메모리 사용 비율
- **NET I/O**: 네트워크 송수신량 (전체 누적)
- **BLOCK I/O**: 디스크 읽기/쓰기 (전체 누적)

### 커스텀 포맷

```bash
# CPU와 메모리만 출력
docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"

# JSON 형식
docker stats --format "{{json .}}" --no-stream

# CSV 형식
docker stats --no-stream --format "{{.Name}},{{.CPUPerc}},{{.MemUsage}}"
```

### 모니터링 스크립트

```bash
#!/bin/bash
# scripts/stats-monitor.sh

# 실시간 모니터링 + 로그 저장

LOG_DIR="./logs/stats"
LOG_FILE="$LOG_DIR/stats_$(date +%Y%m%d).csv"

mkdir -p $LOG_DIR

# 헤더 작성 (처음 실행 시)
if [ ! -f "$LOG_FILE" ]; then
    echo "Timestamp,Container,CPU,Memory,MemoryPercent,NetIO,BlockIO" > $LOG_FILE
fi

# 무한 루프 모니터링
while true; do
    TIMESTAMP=$(date +"%Y-%m-%d %H:%M:%S")

    docker stats --no-stream --format "{{.Name}},{{.CPUPerc}},{{.MemUsage}},{{.MemPerc}},{{.NetIO}},{{.BlockIO}}" | while read line; do
        echo "$TIMESTAMP,$line" >> $LOG_FILE
    done

    sleep 60  # 1분마다 수집
done
```

### 고급 분석 스크립트

```bash
#!/bin/bash
# scripts/stats-analyzer.sh

LOG_FILE=$1

if [ -z "$LOG_FILE" ]; then
    echo "Usage: $0 <log-file>"
    exit 1
fi

echo "📊 통계 분석: $LOG_FILE"
echo ""

# 컨테이너별 평균 CPU 사용률
echo "=== 평균 CPU 사용률 ==="
awk -F',' 'NR>1 {cpu[$2]+=$3; count[$2]++} END {for(c in cpu) printf "%s: %.2f%%\n", c, cpu[c]/count[c]}' $LOG_FILE | sort -t: -k2 -rn

echo ""

# 컨테이너별 최대 메모리 사용량
echo "=== 최대 메모리 사용량 ==="
awk -F',' 'NR>1 {if($4 > max[$2]) max[$2]=$4} END {for(c in max) print c": "max[c]}' $LOG_FILE | sort -t: -k2 -rn

echo ""

# CPU 사용률 90% 이상 경고
echo "=== CPU 경고 (90% 이상) ==="
awk -F',' 'NR>1 {gsub("%","",$3); if($3+0 > 90) print $1, $2, $3"%"}' $LOG_FILE
```

---

## cAdvisor 설치 및 사용

### cAdvisor란?

Google이 개발한 컨테이너 모니터링 도구로, 더 상세한 메트릭을 제공합니다.

```
docker stats vs cAdvisor:

docker stats:
- 기본 메트릭 (CPU, 메모리, 네트워크)
- CLI 기반
- 히스토리 없음

cAdvisor:
- 상세 메트릭 (파일시스템, 네트워크 인터페이스별 등)
- Web UI 제공
- 짧은 히스토리 제공 (최근 1분)
- Prometheus 연동 가능
```

### cAdvisor 설치

```yaml
# docker-compose.monitoring.yml

version: '3.8'

services:
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: cadvisor
    restart: unless-stopped
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
      - /dev/disk/:/dev/disk:ro
    privileged: true
    devices:
      - /dev/kmsg
    command:
      - '--housekeeping_interval=10s'
      - '--docker_only=true'
      - '--disable_metrics=disk,network,tcp,udp,percpu,sched,process'
```

**Windows (Docker Desktop)**:
```yaml
services:
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - /var/lib/docker/:/var/lib/docker:ro
```

### cAdvisor 실행

```bash
# 실행
docker-compose -f docker-compose.monitoring.yml up -d cadvisor

# 확인
curl http://localhost:8080/containers/
```

### cAdvisor Web UI

브라우저에서 접속: `http://localhost:8080`

**주요 기능**:
- **Docker Containers**: 모든 컨테이너 목록 및 상세 정보
- **Metrics**: CPU, 메모리, 네트워크, 파일시스템 그래프
- **Subcontainers**: 컨테이너 계층 구조

### cAdvisor API

```bash
# 전체 컨테이너 메트릭
curl http://localhost:8080/api/v2.0/stats?count=1

# 특정 컨테이너
curl http://localhost:8080/api/v2.0/docker/<container_id>

# Prometheus 형식 메트릭
curl http://localhost:8080/metrics
```

---

## Prometheus + Grafana 연동

### 아키텍처

```
┌──────────────────────────────────────────────────┐
│                  Grafana (시각화)                 │
│            http://localhost:3000                 │
└────────────────┬─────────────────────────────────┘
                 │ 쿼리
                 ↓
┌──────────────────────────────────────────────────┐
│              Prometheus (메트릭 저장)             │
│            http://localhost:9090                 │
└────────────────┬─────────────────────────────────┘
                 │ 스크랩 (수집)
      ┌──────────┴──────────┐
      ↓                     ↓
┌─────────────┐      ┌─────────────┐
│  cAdvisor   │      │   Node      │
│  (컨테이너)  │      │  Exporter   │
│             │      │  (호스트)    │
└─────────────┘      └─────────────┘
```

### Prometheus 설정

```yaml
# docker-compose.monitoring.yml

services:
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'

volumes:
  prometheus-data:
```

```yaml
# prometheus/prometheus.yml

global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  # cAdvisor (컨테이너 메트릭)
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']

  # Node Exporter (호스트 메트릭)
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']

  # Spring Boot Actuator (애플리케이션 메트릭)
  - job_name: 'user-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['user-service:8080']

  - job_name: 'account-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['account-service:8080']

  - job_name: 'trade-service'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['trade-service:8080']
```

### Grafana 설정

```yaml
# docker-compose.monitoring.yml

services:
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
      - ./grafana/dashboards:/var/lib/grafana/dashboards:ro
    depends_on:
      - prometheus

volumes:
  grafana-data:
```

### Grafana 데이터 소스 자동 설정

```yaml
# grafana/provisioning/datasources/prometheus.yml

apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
    editable: false
```

### 전체 모니터링 스택

```yaml
# docker-compose.monitoring.yml (완전판)

version: '3.8'

services:
  # cAdvisor (컨테이너 메트릭)
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: cadvisor
    restart: unless-stopped
    ports:
      - "8080:8080"
    volumes:
      - /:/rootfs:ro
      - /var/run:/var/run:ro
      - /sys:/sys:ro
      - /var/lib/docker/:/var/lib/docker:ro
    privileged: true
    networks:
      - monitoring

  # Node Exporter (호스트 메트릭)
  node-exporter:
    image: prom/node-exporter:latest
    container_name: node-exporter
    restart: unless-stopped
    ports:
      - "9100:9100"
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)'
    networks:
      - monitoring

  # Prometheus (메트릭 수집 및 저장)
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./prometheus/alerts.yml:/etc/prometheus/alerts.yml:ro
      - prometheus-data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
    networks:
      - monitoring
    depends_on:
      - cadvisor
      - node-exporter

  # Grafana (시각화)
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
    networks:
      - monitoring
    depends_on:
      - prometheus

  # Alertmanager (알림)
  alertmanager:
    image: prom/alertmanager:latest
    container_name: alertmanager
    restart: unless-stopped
    ports:
      - "9093:9093"
    volumes:
      - ./alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml:ro
      - alertmanager-data:/alertmanager
    command:
      - '--config.file=/etc/alertmanager/alertmanager.yml'
      - '--storage.path=/alertmanager'
    networks:
      - monitoring

networks:
  monitoring:
    driver: bridge

volumes:
  prometheus-data:
  grafana-data:
  alertmanager-data:
```

---

## 성능 메트릭 분석

### 주요 PromQL 쿼리

#### CPU 메트릭

```promql
# 컨테이너별 CPU 사용률 (%)
rate(container_cpu_usage_seconds_total[5m]) * 100

# 5분 평균 CPU 사용률
avg(rate(container_cpu_usage_seconds_total[5m])) by (name) * 100

# CPU 사용률 상위 5개 컨테이너
topk(5, rate(container_cpu_usage_seconds_total[5m])) * 100
```

#### 메모리 메트릭

```promql
# 컨테이너별 메모리 사용량 (MB)
container_memory_usage_bytes / 1024 / 1024

# 메모리 사용률 (%)
(container_memory_usage_bytes / container_spec_memory_limit_bytes) * 100

# 메모리 사용률 80% 이상
(container_memory_usage_bytes / container_spec_memory_limit_bytes) * 100 > 80
```

#### 네트워크 메트릭

```promql
# 네트워크 수신 속도 (bytes/sec)
rate(container_network_receive_bytes_total[5m])

# 네트워크 송신 속도 (bytes/sec)
rate(container_network_transmit_bytes_total[5m])

# 총 네트워크 I/O
rate(container_network_receive_bytes_total[5m]) + rate(container_network_transmit_bytes_total[5m])
```

#### 디스크 I/O 메트릭

```promql
# 디스크 읽기 속도 (bytes/sec)
rate(container_fs_reads_bytes_total[5m])

# 디스크 쓰기 속도 (bytes/sec)
rate(container_fs_writes_bytes_total[5m])
```

### Grafana 대시보드 JSON

```json
{
  "dashboard": {
    "title": "LK-Trade Docker 모니터링",
    "panels": [
      {
        "title": "CPU 사용률",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(container_cpu_usage_seconds_total{name=~\".*-service\"}[5m]) * 100",
            "legendFormat": "{{name}}"
          }
        ],
        "yaxes": [
          {
            "format": "percent",
            "max": 100
          }
        ]
      },
      {
        "title": "메모리 사용량",
        "type": "graph",
        "targets": [
          {
            "expr": "container_memory_usage_bytes{name=~\".*-service\"} / 1024 / 1024",
            "legendFormat": "{{name}}"
          }
        ],
        "yaxes": [
          {
            "format": "megabytes"
          }
        ]
      },
      {
        "title": "네트워크 I/O",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(container_network_receive_bytes_total{name=~\".*-service\"}[5m])",
            "legendFormat": "{{name}} RX"
          },
          {
            "expr": "rate(container_network_transmit_bytes_total{name=~\".*-service\"}[5m])",
            "legendFormat": "{{name}} TX"
          }
        ],
        "yaxes": [
          {
            "format": "Bps"
          }
        ]
      },
      {
        "title": "컨테이너 상태",
        "type": "stat",
        "targets": [
          {
            "expr": "count(container_last_seen{name=~\".*-service\"})"
          }
        ]
      }
    ]
  }
}
```

---

## 병목 지점 찾기

### 1. CPU 병목

**증상**:
- API 응답 시간 증가
- docker stats에서 CPU 90% 이상

**진단**:
```bash
# CPU 사용률 높은 컨테이너 찾기
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}" | sort -k2 -rn | head -5

# 컨테이너 내부 프로세스 확인
docker exec container_id top -bn1

# JVM 스레드 덤프
docker exec container_id jstack 1 > thread-dump.txt
```

**해결**:
```yaml
# CPU 증가
services:
  user-service:
    cpus: 2.0  # 1.0 → 2.0

# 또는 스케일 아웃
docker-compose up -d --scale user-service=3
```

### 2. 메모리 병목

**증상**:
- OOM Killed (Exit Code 137)
- 스왑 사용 증가

**진단**:
```bash
# 메모리 사용률 확인
docker stats --no-stream --format "table {{.Name}}\t{{.MemUsage}}\t{{.MemPerc}}"

# JVM 힙 덤프
docker exec container_id jmap -dump:format=b,file=/tmp/heap.hprof 1
docker cp container_id:/tmp/heap.hprof ./heap.hprof
```

**해결**:
```yaml
# 메모리 증가
services:
  user-service:
    mem_limit: 2g  # 1g → 2g
    environment:
      - JAVA_OPTS=-XX:MaxRAMPercentage=75.0
```

### 3. 네트워크 병목

**증상**:
- 높은 네트워크 지연
- 패킷 손실

**진단**:
```bash
# 네트워크 I/O 확인
docker stats --no-stream --format "table {{.Name}}\t{{.NetIO}}"

# 네트워크 지연 테스트
docker exec container_a ping -c 10 container_b

# 대역폭 테스트
docker exec container_a iperf3 -c container_b
```

**해결**:
- 네트워크 드라이버 변경 (bridge → host)
- 네트워크 최적화 설정

### 4. 디스크 I/O 병목

**증상**:
- 느린 데이터베이스 쿼리
- 파일 읽기/쓰기 지연

**진단**:
```bash
# 디스크 I/O 확인
docker stats --no-stream --format "table {{.Name}}\t{{.BlockIO}}"

# 디스크 사용량
docker exec container_id df -h

# I/O 대기 시간
docker exec container_id iostat -x 1 10
```

**해결**:
```yaml
# SSD 사용, I/O 제한 해제
services:
  postgres:
    volumes:
      - postgres-data:/var/lib/postgresql/data  # SSD 볼륨 사용
```

---

## 알림 설정

### Prometheus Alert 규칙

```yaml
# prometheus/alerts.yml

groups:
  - name: container_alerts
    interval: 30s
    rules:
      # CPU 사용률 80% 이상
      - alert: HighCPUUsage
        expr: rate(container_cpu_usage_seconds_total[5m]) * 100 > 80
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "컨테이너 CPU 사용률 높음"
          description: "{{ $labels.name }} CPU 사용률이 {{ $value }}% 입니다."

      # 메모리 사용률 90% 이상
      - alert: HighMemoryUsage
        expr: (container_memory_usage_bytes / container_spec_memory_limit_bytes) * 100 > 90
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "컨테이너 메모리 사용률 높음"
          description: "{{ $labels.name }} 메모리 사용률이 {{ $value }}% 입니다."

      # 컨테이너 다운
      - alert: ContainerDown
        expr: up{job="cadvisor"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "컨테이너 다운"
          description: "{{ $labels.instance }} 컨테이너가 다운되었습니다."

      # 디스크 사용률 85% 이상
      - alert: HighDiskUsage
        expr: (container_fs_usage_bytes / container_fs_limit_bytes) * 100 > 85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "디스크 사용률 높음"
          description: "{{ $labels.name }} 디스크 사용률이 {{ $value }}% 입니다."
```

### Alertmanager 설정

```yaml
# alertmanager/alertmanager.yml

global:
  resolve_timeout: 5m

route:
  group_by: ['alertname', 'severity']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 12h
  receiver: 'slack'

receivers:
  # Slack 알림
  - name: 'slack'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK'
        channel: '#alerts'
        title: '{{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
        send_resolved: true

  # 이메일 알림
  - name: 'email'
    email_configs:
      - to: 'admin@lktrade.com'
        from: 'alertmanager@lktrade.com'
        smarthost: 'smtp.gmail.com:587'
        auth_username: 'alertmanager@lktrade.com'
        auth_password: 'password'
        headers:
          Subject: '[LK-Trade] {{ .GroupLabels.alertname }}'

inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname']
```

---

## 실전 예제: LK-Trade 모니터링

### 모니터링 시작

```bash
#!/bin/bash
# scripts/start-monitoring.sh

echo "📊 LK-Trade 모니터링 스택 시작..."

# 1. 모니터링 스택 시작
docker-compose -f docker-compose.monitoring.yml up -d

# 2. 서비스 준비 대기
echo "⏳ 서비스 준비 중..."
sleep 15

# 3. 헬스체크
echo "🏥 헬스체크..."
curl -f http://localhost:8080/containers/ > /dev/null 2>&1 && echo "  ✅ cAdvisor" || echo "  ❌ cAdvisor"
curl -f http://localhost:9090/-/healthy > /dev/null 2>&1 && echo "  ✅ Prometheus" || echo "  ❌ Prometheus"
curl -f http://localhost:3000/api/health > /dev/null 2>&1 && echo "  ✅ Grafana" || echo "  ❌ Grafana"

echo ""
echo "✅ 모니터링 스택 시작 완료!"
echo ""
echo "📋 접속 정보:"
echo "  - cAdvisor:    http://localhost:8080"
echo "  - Prometheus:  http://localhost:9090"
echo "  - Grafana:     http://localhost:3000 (admin/admin)"
echo "  - Alertmanager: http://localhost:9093"
```

### Makefile 통합

```makefile
# Makefile

.PHONY: monitoring monitoring-stop monitoring-logs

# 모니터링 시작
monitoring:
	@echo "📊 모니터링 스택 시작..."
	@docker-compose -f docker-compose.monitoring.yml up -d
	@sleep 10
	@echo "✅ 모니터링 준비 완료"
	@echo ""
	@echo "접속 URL:"
	@echo "  Grafana: http://localhost:3000"
	@echo "  Prometheus: http://localhost:9090"

# 모니터링 중지
monitoring-stop:
	@docker-compose -f docker-compose.monitoring.yml down

# 모니터링 로그
monitoring-logs:
	@docker-compose -f docker-compose.monitoring.yml logs -f
```

---

## 트러블슈팅

### 문제 1: cAdvisor가 메트릭을 수집하지 않음

**증상**:
```
cAdvisor Web UI에서 컨테이너 목록이 비어있음
```

**해결**:
```yaml
# docker-compose.monitoring.yml
services:
  cadvisor:
    privileged: true  # 권한 추가
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro  # Docker 소켓 마운트
```

### 문제 2: Prometheus가 타겟을 스크랩하지 못함

**진단**:
```bash
# Prometheus 타겟 상태 확인
curl http://localhost:9090/api/v1/targets | jq
```

**해결**:
```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']  # 컨테이너 이름 사용
```

### 문제 3: Grafana 대시보드에 데이터가 없음

**진단**:
1. Prometheus에서 데이터 확인: `http://localhost:9090/graph`
2. 쿼리 테스트: `up`

**해결**:
- 데이터 소스 연결 확인
- PromQL 쿼리 수정

---

## 다음 단계

### 26. 로그 관리
- 로그 드라이버 종류
- 중앙화된 로그 수집
- ELK 스택

### 학습 자료

**모니터링**:
- [Prometheus 공식 문서](https://prometheus.io/docs/introduction/overview/)
- [Grafana 공식 문서](https://grafana.com/docs/)
- [cAdvisor GitHub](https://github.com/google/cadvisor)

---

**축하합니다! 🎉** Docker 성능 모니터링을 마스터했습니다!