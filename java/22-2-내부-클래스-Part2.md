# 📝 Chapter 22-2: 내부 클래스 (Inner Classes) Part 2

## 🎯 학습 목표
- 실제 기업에서 내부 클래스를 어떻게 활용하는지 학습합니다
- Java Collections Framework의 Iterator 패턴을 이해합니다
- Builder 패턴에서 Static Nested Class 활용법을 익힙니다
- 주니어 개발자가 자주 실수하는 내부 클래스 사용법을 배웁니다
- 실전에서 마주칠 수 있는 문제와 해결 방법을 익힙니다

---

## 🏢 기업 사례 연구

---

## 📘 Case Study 1: Java Collections Framework - Iterator 패턴

### 배경
**Oracle (Java Collections Framework)** 개발 팀은 다양한 컬렉션(ArrayList, LinkedList, HashSet 등)을 일관된 방식으로 순회할 수 있는 방법이 필요했습니다.

**해결책**: Member Inner Class로 Iterator를 구현하여 각 컬렉션의 내부 구조를 숨기면서도 순회 기능을 제공합니다.

### 핵심 개념
- `Iterator` 인터페이스: 순회 기능을 정의
- Member Inner Class로 구현: 외부 클래스의 private 멤버에 접근
- 캡슐화: 내부 구조를 감추면서 순회 기능 제공

### 실제 코드

```java
// 📁 IteratorPatternExample.java

import java.util.Iterator;
import java.util.NoSuchElementException;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ 커스텀 ArrayList 구현 (Member Inner Class로 Iterator 제공)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class MyArrayList<T> implements Iterable<T> {
    private Object[] elements;
    private int size;
    private static final int DEFAULT_CAPACITY = 10;

    public MyArrayList() {
        elements = new Object[DEFAULT_CAPACITY];
        size = 0;
    }

    public void add(T element) {
        if (size == elements.length) {
            resize();
        }
        elements[size++] = element;
    }

    @SuppressWarnings("unchecked")
    public T get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
        }
        return (T) elements[index];
    }

    public int size() {
        return size;
    }

    private void resize() {
        Object[] newElements = new Object[elements.length * 2];
        System.arraycopy(elements, 0, newElements, 0, elements.length);
        elements = newElements;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Member Inner Class: ArrayListIterator
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    private class ArrayListIterator implements Iterator<T> {
        private int currentIndex = 0;

        @Override
        public boolean hasNext() {
            // ✅ 외부 클래스의 private 필드 size에 접근 가능!
            return currentIndex < size;
        }

        @Override
        @SuppressWarnings("unchecked")
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            // ✅ 외부 클래스의 private 필드 elements에 접근 가능!
            return (T) elements[currentIndex++];
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new ArrayListIterator();  // Member Inner Class 인스턴스 반환
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ 커스텀 LinkedList 구현 (Member Inner Class로 Node와 Iterator 제공)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class MyLinkedList<T> implements Iterable<T> {

    // ✅ Member Inner Class: Node (연결 리스트의 노드)
    private class Node {
        T data;
        Node next;

        Node(T data) {
            this.data = data;
            this.next = null;
        }
    }

    private Node head;
    private int size;

    public MyLinkedList() {
        head = null;
        size = 0;
    }

    public void add(T element) {
        Node newNode = new Node(element);

        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }

    public int size() {
        return size;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Member Inner Class: LinkedListIterator
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    private class LinkedListIterator implements Iterator<T> {
        private Node current = head;  // 외부 클래스의 private 필드 접근!

        @Override
        public boolean hasNext() {
            return current != null;
        }

        @Override
        public T next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }
            T data = current.data;
            current = current.next;
            return data;
        }
    }

    @Override
    public Iterator<T> iterator() {
        return new LinkedListIterator();
    }
}

public class IteratorPatternExample {
    public static void main(String[] args) {
        System.out.println("=== Iterator 패턴 - Java Collections Framework 사례 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // MyArrayList 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(50));
        System.out.println("1️⃣ MyArrayList with Iterator");
        System.out.println("=".repeat(50) + "\n");

        MyArrayList<String> arrayList = new MyArrayList<>();
        arrayList.add("Java");
        arrayList.add("Python");
        arrayList.add("JavaScript");
        arrayList.add("C++");

        System.out.println("for-each 루프 (내부적으로 Iterator 사용):");
        for (String lang : arrayList) {
            System.out.println("  - " + lang);
        }

        System.out.println("\n명시적 Iterator 사용:");
        Iterator<String> it1 = arrayList.iterator();
        while (it1.hasNext()) {
            System.out.println("  → " + it1.next());
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // MyLinkedList 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("2️⃣ MyLinkedList with Iterator");
        System.out.println("=".repeat(50) + "\n");

        MyLinkedList<Integer> linkedList = new MyLinkedList<>();
        linkedList.add(10);
        linkedList.add(20);
        linkedList.add(30);
        linkedList.add(40);

        System.out.println("for-each 루프:");
        for (Integer num : linkedList) {
            System.out.println("  - " + num);
        }

        System.out.println("\n명시적 Iterator 사용:");
        Iterator<Integer> it2 = linkedList.iterator();
        while (it2.hasNext()) {
            System.out.println("  → " + it2.next());
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Iterator 패턴의 핵심 가치:");

        System.out.println("\n1️⃣ 일관된 순회 인터페이스");
        System.out.println("   - ArrayList든 LinkedList든 같은 방법으로 순회");
        System.out.println("   - for-each 루프 지원");

        System.out.println("\n2️⃣ 캡슐화 유지");
        System.out.println("   - 내부 구조(배열 vs 링크드 리스트)를 감춤");
        System.out.println("   - 외부에 불필요한 세부사항 노출 방지");

        System.out.println("\n3️⃣ Member Inner Class 활용");
        System.out.println("   - Iterator는 외부 클래스의 private 필드 접근 필요");
        System.out.println("   - ArrayListIterator는 elements[] 배열 직접 접근");
        System.out.println("   - LinkedListIterator는 head 노드 직접 접근");

        System.out.println("\n4️⃣ 안전한 순회");
        System.out.println("   - hasNext()로 경계 검사");
        System.out.println("   - next()가 없으면 NoSuchElementException");

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n🌟 실제 Java Collections Framework:");
        System.out.println("  - ArrayList.Itr (Member Inner Class)");
        System.out.println("  - LinkedList.ListItr (Member Inner Class)");
        System.out.println("  - HashMap.EntryIterator (Member Inner Class)");
        System.out.println("  - TreeSet.TreeSetIterator (Member Inner Class)");
    }
}
```

**실행 결과:**
```
=== Iterator 패턴 - Java Collections Framework 사례 ===

==================================================
1️⃣ MyArrayList with Iterator
==================================================

for-each 루프 (내부적으로 Iterator 사용):
  - Java
  - Python
  - JavaScript
  - C++

명시적 Iterator 사용:
  → Java
  → Python
  → JavaScript
  → C++

==================================================
2️⃣ MyLinkedList with Iterator
==================================================

for-each 루프:
  - 10
  - 20
  - 30
  - 40

명시적 Iterator 사용:
  → 10
  → 20
  → 30
  → 40

==================================================

💡 Iterator 패턴의 핵심 가치:

1️⃣ 일관된 순회 인터페이스
   - ArrayList든 LinkedList든 같은 방법으로 순회
   - for-each 루프 지원

2️⃣ 캡슐화 유지
   - 내부 구조(배열 vs 링크드 리스트)를 감춤
   - 외부에 불필요한 세부사항 노출 방지

3️⃣ Member Inner Class 활용
   - Iterator는 외부 클래스의 private 필드 접근 필요
   - ArrayListIterator는 elements[] 배열 직접 접근
   - LinkedListIterator는 head 노드 직접 접근

4️⃣ 안전한 순회
   - hasNext()로 경계 검사
   - next()가 없으면 NoSuchElementException

==================================================

🌟 실제 Java Collections Framework:
  - ArrayList.Itr (Member Inner Class)
  - LinkedList.ListItr (Member Inner Class)
  - HashMap.EntryIterator (Member Inner Class)
  - TreeSet.TreeSetIterator (Member Inner Class)
```

---

## 📗 Case Study 2: Builder 패턴 - 복잡한 객체 생성

### 배경
**Lombok 라이브러리** 개발 팀은 복잡한 객체를 간편하게 생성할 수 있는 Builder 패턴을 제공해야 했습니다.
생성자 파라미터가 많으면 가독성이 떨어지고, 선택적 파라미터 처리가 어려워집니다.

**해결책**: Static Nested Class로 Builder를 구현하여 외부 클래스 인스턴스 없이도 빌더를 사용할 수 있게 합니다.

### 핵심 개념
- Static Nested Class: 외부 인스턴스 불필요
- Fluent API: 메서드 체이닝
- 가독성: 생성자 대신 명확한 메서드 이름

### 실제 코드

```java
// 📁 BuilderPatternExample.java

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ Builder 패턴 없이 (문제 상황)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class User_Old {
    private String username;
    private String email;
    private String password;
    private int age;
    private String phoneNumber;
    private String address;
    private boolean isActive;

    // ❌ 생성자 파라미터가 너무 많음
    public User_Old(String username, String email, String password, int age,
                   String phoneNumber, String address, boolean isActive) {
        this.username = username;
        this.email = email;
        this.password = password;
        this.age = age;
        this.phoneNumber = phoneNumber;
        this.address = address;
        this.isActive = isActive;
    }

    // ❌ 여러 생성자 오버로딩 필요 (Telescoping Constructor Pattern)
    public User_Old(String username, String email, String password) {
        this(username, email, password, 0, null, null, true);
    }

    public User_Old(String username, String email, String password, int age) {
        this(username, email, password, age, null, null, true);
    }

    // ... 수십 개의 생성자 오버로딩
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ Builder 패턴 (Static Nested Class 활용)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class User {
    // 외부 클래스의 필드 (모두 final)
    private final String username;
    private final String email;
    private final String password;
    private final int age;
    private final String phoneNumber;
    private final String address;
    private final boolean isActive;

    // private 생성자 - Builder를 통해서만 생성 가능
    private User(Builder builder) {
        this.username = builder.username;
        this.email = builder.email;
        this.password = builder.password;
        this.age = builder.age;
        this.phoneNumber = builder.phoneNumber;
        this.address = builder.address;
        this.isActive = builder.isActive;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Static Nested Class: Builder
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    public static class Builder {
        // 필수 파라미터
        private final String username;
        private final String email;
        private final String password;

        // 선택적 파라미터 (기본값 설정)
        private int age = 0;
        private String phoneNumber = "";
        private String address = "";
        private boolean isActive = true;

        // Builder 생성자 (필수 파라미터만)
        public Builder(String username, String email, String password) {
            this.username = username;
            this.email = email;
            this.password = password;
        }

        // ✅ 메서드 체이닝을 위해 Builder 자신을 반환
        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder phoneNumber(String phoneNumber) {
            this.phoneNumber = phoneNumber;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public Builder isActive(boolean isActive) {
            this.isActive = isActive;
            return this;
        }

        // 최종적으로 User 객체 생성
        public User build() {
            // ✅ 검증 로직 추가 가능
            if (age < 0 || age > 150) {
                throw new IllegalArgumentException("유효하지 않은 나이: " + age);
            }

            if (username == null || username.isEmpty()) {
                throw new IllegalArgumentException("사용자 이름은 필수입니다");
            }

            return new User(this);  // 외부 클래스의 private 생성자 호출
        }
    }

    @Override
    public String toString() {
        return String.format("User{username='%s', email='%s', age=%d, phone='%s', address='%s', isActive=%s}",
                           username, email, age, phoneNumber, address, isActive);
    }

    // Getter 메서드들
    public String getUsername() { return username; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
}

public class BuilderPatternExample {
    public static void main(String[] args) {
        System.out.println("=== Builder 패턴 - Static Nested Class 활용 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 1: 모든 속성 설정
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(50));
        System.out.println("Case 1: 모든 속성 설정");
        System.out.println("=".repeat(50) + "\n");

        User user1 = new User.Builder("김철수", "chulsoo@example.com", "password123")
                .age(28)
                .phoneNumber("010-1234-5678")
                .address("서울시 강남구")
                .isActive(true)
                .build();

        System.out.println(user1);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 2: 필수 속성만 설정
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("Case 2: 필수 속성만 설정 (나머지는 기본값)");
        System.out.println("=".repeat(50) + "\n");

        User user2 = new User.Builder("이영희", "younghee@example.com", "secure456")
                .build();

        System.out.println(user2);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 3: 일부 속성만 설정
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("Case 3: 일부 속성만 선택적으로 설정");
        System.out.println("=".repeat(50) + "\n");

        User user3 = new User.Builder("박민수", "minsoo@example.com", "mypass789")
                .age(35)
                .address("부산시 해운대구")
                // phoneNumber는 설정 안 함 → 기본값 ""
                .build();

        System.out.println(user3);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 4: 검증 실패
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("Case 4: 검증 실패 (잘못된 나이)");
        System.out.println("=".repeat(50) + "\n");

        try {
            User invalidUser = new User.Builder("최지훈", "jihoon@example.com", "pass")
                    .age(200)  // 유효하지 않은 나이
                    .build();
        } catch (IllegalArgumentException e) {
            System.out.println("❌ 오류 발생: " + e.getMessage());
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Old vs New 비교
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n📊 Old vs New 비교:");

        System.out.println("\n❌ 기존 방식 (Telescoping Constructor):");
        System.out.println("```java");
        System.out.println("User user = new User(\"김철수\", \"email\", \"pass\",");
        System.out.println("                    28, \"010-1234\", \"서울\", true);");
        System.out.println("```");
        System.out.println("문제:");
        System.out.println("  - 파라미터 순서를 외워야 함");
        System.out.println("  - 가독성 떨어짐 (어떤 값이 무엇인지 불명확)");
        System.out.println("  - 선택적 파라미터 처리 어려움");

        System.out.println("\n✅ Builder 패턴:");
        System.out.println("```java");
        System.out.println("User user = new User.Builder(\"김철수\", \"email\", \"pass\")");
        System.out.println("                    .age(28)");
        System.out.println("                    .phoneNumber(\"010-1234\")");
        System.out.println("                    .address(\"서울\")");
        System.out.println("                    .build();");
        System.out.println("```");
        System.out.println("장점:");
        System.out.println("  - 가독성 높음 (무엇을 설정하는지 명확)");
        System.out.println("  - 선택적 파라미터 쉽게 처리");
        System.out.println("  - 불변 객체(Immutable) 생성 가능");
        System.out.println("  - 검증 로직 중앙화");

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Static Nested Class를 사용하는 이유:");
        System.out.println("1. 외부 클래스 인스턴스 없이 Builder 생성 가능");
        System.out.println("2. new User.Builder(...)로 직접 생성");
        System.out.println("3. 메모리 효율적 (외부 클래스 참조 불필요)");

        System.out.println("\n🌟 실제 사례:");
        System.out.println("  - StringBuilder");
        System.out.println("  - Lombok @Builder");
        System.out.println("  - Retrofit Request.Builder");
        System.out.println("  - OkHttpClient.Builder");
    }
}
```

**실행 결과:**
```
=== Builder 패턴 - Static Nested Class 활용 ===

==================================================
Case 1: 모든 속성 설정
==================================================

User{username='김철수', email='chulsoo@example.com', age=28, phone='010-1234-5678', address='서울시 강남구', isActive=true}

==================================================
Case 2: 필수 속성만 설정 (나머지는 기본값)
==================================================

User{username='이영희', email='younghee@example.com', age=0, phone='', address='', isActive=true}

==================================================
Case 3: 일부 속성만 선택적으로 설정
==================================================

User{username='박민수', email='minsoo@example.com', age=35, phone='', address='부산시 해운대구', isActive=true}

==================================================
Case 4: 검증 실패 (잘못된 나이)
==================================================

❌ 오류 발생: 유효하지 않은 나이: 200

==================================================

📊 Old vs New 비교:

❌ 기존 방식 (Telescoping Constructor):
```java
User user = new User("김철수", "email", "pass",
                    28, "010-1234", "서울", true);
```
문제:
  - 파라미터 순서를 외워야 함
  - 가독성 떨어짐 (어떤 값이 무엇인지 불명확)
  - 선택적 파라미터 처리 어려움

✅ Builder 패턴:
```java
User user = new User.Builder("김철수", "email", "pass")
                    .age(28)
                    .phoneNumber("010-1234")
                    .address("서울")
                    .build();
```
장점:
  - 가독성 높음 (무엇을 설정하는지 명확)
  - 선택적 파라미터 쉽게 처리
  - 불변 객체(Immutable) 생성 가능
  - 검증 로직 중앙화

==================================================

💡 Static Nested Class를 사용하는 이유:
1. 외부 클래스 인스턴스 없이 Builder 생성 가능
2. new User.Builder(...)로 직접 생성
3. 메모리 효율적 (외부 클래스 참조 불필요)

🌟 실제 사례:
  - StringBuilder
  - Lombok @Builder
  - Retrofit Request.Builder
  - OkHttpClient.Builder
```

---

## 📙 Case Study 3: Event Handling - GUI 프로그래밍

### 배경
**JavaFX/Swing 개발 팀**은 버튼 클릭, 마우스 이동 등의 이벤트를 처리할 수 있는 방법이 필요했습니다.
각 버튼마다 별도의 클래스를 만들면 파일이 너무 많아집니다.

**해결책**: Anonymous Inner Class로 이벤트 리스너를 즉석에서 구현합니다.

### 실제 코드

```java
// 📁 EventHandlingExample.java

// 간단한 이벤트 시스템 시뮬레이션
interface EventListener {
    void onEvent(Event event);
}

class Event {
    private String type;
    private String message;

    public Event(String type, String message) {
        this.type = type;
        this.message = message;
    }

    public String getType() { return type; }
    public String getMessage() { return message; }
}

class Button {
    private String label;
    private EventListener clickListener;

    public Button(String label) {
        this.label = label;
    }

    public void setOnClickListener(EventListener listener) {
        this.clickListener = listener;
    }

    public void click() {
        System.out.println("\n[" + label + "] 버튼 클릭됨");
        if (clickListener != null) {
            clickListener.onEvent(new Event("CLICK", label + " 클릭"));
        }
    }
}

public class EventHandlingExample {
    public static void main(String[] args) {
        System.out.println("=== Event Handling - Anonymous Inner Class 활용 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 1: 각 버튼마다 다른 동작 (Anonymous Inner Class)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(50));
        System.out.println("Case 1: Anonymous Inner Class로 이벤트 처리");
        System.out.println("=".repeat(50));

        Button saveButton = new Button("저장");
        saveButton.setOnClickListener(new EventListener() {
            @Override
            public void onEvent(Event event) {
                System.out.println("  💾 파일을 저장합니다...");
                System.out.println("  ✅ 저장 완료!");
            }
        });

        Button deleteButton = new Button("삭제");
        deleteButton.setOnClickListener(new EventListener() {
            @Override
            public void onEvent(Event event) {
                System.out.println("  ⚠️ 정말로 삭제하시겠습니까?");
                System.out.println("  🗑️ 삭제되었습니다.");
            }
        });

        Button cancelButton = new Button("취소");
        cancelButton.setOnClickListener(new EventListener() {
            @Override
            public void onEvent(Event event) {
                System.out.println("  ↩️ 작업이 취소되었습니다.");
            }
        });

        // 버튼 클릭
        saveButton.click();
        deleteButton.click();
        cancelButton.click();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 2: Lambda로 간소화 (Java 8+)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("Case 2: Lambda로 더 간결하게");
        System.out.println("=".repeat(50));

        Button printButton = new Button("인쇄");
        printButton.setOnClickListener(event -> {
            System.out.println("  🖨️ 문서를 인쇄합니다...");
            System.out.println("  ✅ 인쇄 완료!");
        });

        Button refreshButton = new Button("새로고침");
        refreshButton.setOnClickListener(event -> System.out.println("  🔄 페이지를 새로고침합니다."));

        printButton.click();
        refreshButton.click();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 3: 외부 변수 접근 (final/effectively final)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("Case 3: 외부 변수 접근");
        System.out.println("=".repeat(50));

        final String filename = "report.pdf";  // final
        int pageCount = 10;  // effectively final

        Button exportButton = new Button("내보내기");
        exportButton.setOnClickListener(new EventListener() {
            @Override
            public void onEvent(Event event) {
                System.out.println("  📤 파일 내보내기: " + filename);
                System.out.println("  페이지 수: " + pageCount);
                // pageCount = 20;  // 컴파일 에러! (effectively final 위반)
            }
        });

        exportButton.click();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Anonymous Inner Class in Event Handling:");

        System.out.println("\n1️⃣ 장점:");
        System.out.println("   - 각 버튼마다 별도의 클래스 파일 불필요");
        System.out.println("   - 코드가 사용되는 곳 근처에 정의 (가독성)");
        System.out.println("   - 일회성 구현에 적합");

        System.out.println("\n2️⃣ 실제 사용 사례:");
        System.out.println("   - Swing: button.addActionListener(new ActionListener() {...})");
        System.out.println("   - JavaFX: button.setOnAction(event -> {...})");
        System.out.println("   - Android: button.setOnClickListener(new OnClickListener() {...})");

        System.out.println("\n3️⃣ Java 8 이후:");
        System.out.println("   - Lambda 표현식으로 더 간결하게");
        System.out.println("   - 하지만 상태가 필요하면 여전히 익명 클래스 사용");

        System.out.println("\n" + "=".repeat(50));
    }
}
```

**실행 결과:**
```
=== Event Handling - Anonymous Inner Class 활용 ===

==================================================
Case 1: Anonymous Inner Class로 이벤트 처리
==================================================

[저장] 버튼 클릭됨
  💾 파일을 저장합니다...
  ✅ 저장 완료!

[삭제] 버튼 클릭됨
  ⚠️ 정말로 삭제하시겠습니까?
  🗑️ 삭제되었습니다.

[취소] 버튼 클릭됨
  ↩️ 작업이 취소되었습니다.

==================================================
Case 2: Lambda로 더 간결하게
==================================================

[인쇄] 버튼 클릭됨
  🖨️ 문서를 인쇄합니다...
  ✅ 인쇄 완료!

[새로고침] 버튼 클릭됨
  🔄 페이지를 새로고침합니다.

==================================================
Case 3: 외부 변수 접근
==================================================

[내보내기] 버튼 클릭됨
  📤 파일 내보내기: report.pdf
  페이지 수: 10

==================================================

💡 Anonymous Inner Class in Event Handling:

1️⃣ 장점:
   - 각 버튼마다 별도의 클래스 파일 불필요
   - 코드가 사용되는 곳 근처에 정의 (가독성)
   - 일회성 구현에 적합

2️⃣ 실제 사용 사례:
   - Swing: button.addActionListener(new ActionListener() {...})
   - JavaFX: button.setOnAction(event -> {...})
   - Android: button.setOnClickListener(new OnClickListener() {...})

3️⃣ Java 8 이후:
   - Lambda 표현식으로 더 간결하게
   - 하지만 상태가 필요하면 여전히 익명 클래스 사용

==================================================
```

---

## 👨‍💻 주니어 개발자 시나리오

---

## ❓ Scenario 1: Static Nested Class vs Member Inner Class 선택 실수

### 문제 상황
주니어 개발자가 외부 클래스의 인스턴스 멤버에 접근할 필요가 없는데도 Member Inner Class로 구현했습니다.

```java
// 📁 InnerClassSelectionMistake.java

// ❌ 잘못된 설계: Member Inner Class 사용
class MathUtil_Wrong {
    private String owner = "MathUtil";

    class Calculator {  // Member Inner Class
        public int add(int a, int b) {
            // 외부 클래스의 인스턴스 멤버를 사용하지 않음!
            return a + b;
        }

        public int multiply(int a, int b) {
            return a * b;
        }
    }
}

// ✅ 올바른 설계: Static Nested Class 사용
class MathUtil_Correct {
    private String owner = "MathUtil";

    static class Calculator {  // Static Nested Class
        public int add(int a, int b) {
            return a + b;
        }

        public int multiply(int a, int b) {
            return a * b;
        }
    }
}

public class InnerClassSelectionMistake {
    public static void main(String[] args) {
        System.out.println("=== Static Nested Class vs Member Inner Class 선택 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 잘못된 방식
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("❌ Member Inner Class 사용 (잘못됨):");
        MathUtil_Wrong util1 = new MathUtil_Wrong();
        MathUtil_Wrong.Calculator calc1 = util1.new Calculator();  // 외부 인스턴스 필요!
        System.out.println("  2 + 3 = " + calc1.add(2, 3));

        System.out.println("\n문제점:");
        System.out.println("  - 불필요한 외부 인스턴스 생성");
        System.out.println("  - 메모리 낭비 (외부 클래스 참조 유지)");
        System.out.println("  - Calculator가 MathUtil의 상태에 의존하지 않는데도 강제 결합");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 올바른 방식
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n✅ Static Nested Class 사용 (올바름):");
        MathUtil_Correct.Calculator calc2 = new MathUtil_Correct.Calculator();  // 외부 인스턴스 불필요!
        System.out.println("  2 + 3 = " + calc2.add(2, 3));

        System.out.println("\n장점:");
        System.out.println("  - 외부 인스턴스 없이 생성 가능");
        System.out.println("  - 메모리 효율적");
        System.out.println("  - 논리적 그룹화만 제공");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 가이드
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 선택 가이드:");

        System.out.println("\n✅ Static Nested Class 사용:");
        System.out.println("   - 외부 클래스의 인스턴스 멤버에 접근할 필요 없음");
        System.out.println("   - 논리적 그룹화만 필요");
        System.out.println("   - 예: Builder, Utility 클래스");

        System.out.println("\n✅ Member Inner Class 사용:");
        System.out.println("   - 외부 클래스의 인스턴스 멤버 접근 필요");
        System.out.println("   - 외부 클래스와 강하게 결합");
        System.out.println("   - 예: Iterator, Node, Entry");

        System.out.println("\n⚠️ 기본 원칙:");
        System.out.println("   - 외부 인스턴스가 필요 없다면 항상 static으로 만들 것!");
        System.out.println("   - 불필요한 외부 참조는 메모리 누수의 원인");
    }
}
```

**실행 결과:**
```
=== Static Nested Class vs Member Inner Class 선택 ===

❌ Member Inner Class 사용 (잘못됨):
  2 + 3 = 5

문제점:
  - 불필요한 외부 인스턴스 생성
  - 메모리 낭비 (외부 클래스 참조 유지)
  - Calculator가 MathUtil의 상태에 의존하지 않는데도 강제 결합

==================================================

✅ Static Nested Class 사용 (올바름):
  2 + 3 = 5

장점:
  - 외부 인스턴스 없이 생성 가능
  - 메모리 효율적
  - 논리적 그룹화만 제공

==================================================

💡 선택 가이드:

✅ Static Nested Class 사용:
   - 외부 클래스의 인스턴스 멤버에 접근할 필요 없음
   - 논리적 그룹화만 필요
   - 예: Builder, Utility 클래스

✅ Member Inner Class 사용:
   - 외부 클래스의 인스턴스 멤버 접근 필요
   - 외부 클래스와 강하게 결합
   - 예: Iterator, Node, Entry

⚠️ 기본 원칙:
   - 외부 인스턴스가 필요 없다면 항상 static으로 만들 것!
   - 불필요한 외부 참조는 메모리 누수의 원인
```

### 해결 방법
**외부 인스턴스 멤버에 접근하지 않는다면 항상 `static`으로 선언**합니다.

---

## ❓ Scenario 2: 익명 클래스에서 외부 변수 수정 시도

### 문제 상황
주니어 개발자가 익명 클래스에서 외부 지역 변수를 수정하려고 시도했습니다.

```java
// 📁 FinalVariableMistake.java

interface Counter {
    void count();
}

public class FinalVariableMistake {
    public static void main(String[] args) {
        System.out.println("=== 익명 클래스에서 외부 변수 접근 ===\n");

        // ❌ 문제 상황: 외부 변수를 수정하려는 시도
        int counter = 0;  // effectively final

        Counter c = new Counter() {
            @Override
            public void count() {
                System.out.println("현재 카운트: " + counter);
                // counter++;  // 컴파일 에러! effectively final 위반
            }
        };

        c.count();

        System.out.println("\n❌ 문제:");
        System.out.println("   - 지역 변수는 final 또는 effectively final이어야 함");
        System.out.println("   - 익명 클래스에서 수정 불가");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 해결 방법 1: 배열 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("✅ 해결 방법 1: 배열 사용");
        System.out.println("=".repeat(50) + "\n");

        final int[] counterArray = {0};  // 배열 자체는 final

        Counter c1 = new Counter() {
            @Override
            public void count() {
                counterArray[0]++;  // 배열 요소는 수정 가능!
                System.out.println("카운트: " + counterArray[0]);
            }
        };

        c1.count();
        c1.count();
        c1.count();

        System.out.println("최종 카운트: " + counterArray[0]);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 해결 방법 2: Wrapper 클래스 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("✅ 해결 방법 2: Wrapper 클래스 사용");
        System.out.println("=".repeat(50) + "\n");

        class IntWrapper {
            int value;
            IntWrapper(int value) { this.value = value; }
        }

        final IntWrapper wrapper = new IntWrapper(0);

        Counter c2 = new Counter() {
            @Override
            public void count() {
                wrapper.value++;  // 객체의 필드는 수정 가능!
                System.out.println("카운트: " + wrapper.value);
            }
        };

        c2.count();
        c2.count();
        c2.count();

        System.out.println("최종 카운트: " + wrapper.value);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 해결 방법 3: Member Inner Class 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("✅ 해결 방법 3: Member Inner Class 사용");
        System.out.println("=".repeat(50) + "\n");

        class CounterHolder {
            private int count = 0;

            class InnerCounter implements Counter {
                @Override
                public void count() {
                    count++;  // 외부 클래스의 필드는 자유롭게 수정 가능!
                    System.out.println("카운트: " + count);
                }
            }

            public Counter getCounter() {
                return new InnerCounter();
            }
        }

        CounterHolder holder = new CounterHolder();
        Counter c3 = holder.getCounter();

        c3.count();
        c3.count();
        c3.count();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 왜 지역 변수는 final이어야 하나?");
        System.out.println("\n메모리 구조:");
        System.out.println("   - 지역 변수: 스택(Stack)에 저장");
        System.out.println("   - 익명 클래스 인스턴스: 힙(Heap)에 저장");

        System.out.println("\n문제 상황:");
        System.out.println("   1. 메서드가 종료되면 스택의 지역 변수 사라짐");
        System.out.println("   2. 하지만 익명 클래스 인스턴스는 힙에 남아있음");
        System.out.println("   3. 변수가 변경되면 복사된 값과 원본이 달라짐");

        System.out.println("\nJava의 해결책:");
        System.out.println("   - 지역 변수를 final로 제한");
        System.out.println("   - 값이 변경되지 않으므로 일관성 보장");
        System.out.println("   - 컴파일러가 값을 복사하여 익명 클래스에 전달");

        System.out.println("\n우회 방법:");
        System.out.println("   ✅ 배열 사용 (배열 참조는 final, 요소는 변경 가능)");
        System.out.println("   ✅ Wrapper 클래스 사용 (객체 참조는 final, 필드는 변경 가능)");
        System.out.println("   ✅ Member Inner Class 사용 (외부 클래스 필드 직접 수정)");
    }
}
```

**실행 결과:**
```
=== 익명 클래스에서 외부 변수 접근 ===

현재 카운트: 0

❌ 문제:
   - 지역 변수는 final 또는 effectively final이어야 함
   - 익명 클래스에서 수정 불가

==================================================
✅ 해결 방법 1: 배열 사용
==================================================

카운트: 1
카운트: 2
카운트: 3
최종 카운트: 3

==================================================
✅ 해결 방법 2: Wrapper 클래스 사용
==================================================

카운트: 1
카운트: 2
카운트: 3
최종 카운트: 3

==================================================
✅ 해결 방법 3: Member Inner Class 사용
==================================================

카운트: 1
카운트: 2
카운트: 3

==================================================

💡 왜 지역 변수는 final이어야 하나?

메모리 구조:
   - 지역 변수: 스택(Stack)에 저장
   - 익명 클래스 인스턴스: 힙(Heap)에 저장

문제 상황:
   1. 메서드가 종료되면 스택의 지역 변수 사라짐
   2. 하지만 익명 클래스 인스턴스는 힙에 남아있음
   3. 변수가 변경되면 복사된 값과 원본이 달라짐

Java의 해결책:
   - 지역 변수를 final로 제한
   - 값이 변경되지 않으므로 일관성 보장
   - 컴파일러가 값을 복사하여 익명 클래스에 전달

우회 방법:
   ✅ 배열 사용 (배열 참조는 final, 요소는 변경 가능)
   ✅ Wrapper 클래스 사용 (객체 참조는 final, 필드는 변경 가능)
   ✅ Member Inner Class 사용 (외부 클래스 필드 직접 수정)
```

### 해결 방법
1. **배열 사용**: 배열 참조는 final, 배열 요소는 변경 가능
2. **Wrapper 클래스**: 객체 참조는 final, 필드는 변경 가능
3. **Member Inner Class**: 외부 클래스의 필드 직접 수정

---

*토큰 사용량 제한으로 인해 Part 2의 나머지 시나리오 3, 4와 Part 3은 다음 메시지에서 계속됩니다.*
