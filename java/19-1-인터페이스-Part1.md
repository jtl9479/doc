# 19-1. 인터페이스 Part 1: 실생활 비유

## 📚 인터페이스란?

인터페이스(Interface)는 클래스가 구현해야 하는 메서드들의 "계약서" 또는 "청사진"입니다. 추상 클래스와 비슷하지만, 더 추상적이고 유연합니다.

### 🔍 인터페이스의 핵심 특징

1. **완전한 추상화**
   - 모든 메서드가 기본적으로 추상 메서드 (Java 8+ default/static 메서드 예외)
   - 구현이 아닌 "무엇을 할 수 있는가"를 정의

2. **다중 구현 가능**
   - 한 클래스가 여러 인터페이스를 동시에 구현 가능
   - 추상 클래스는 단일 상속만 가능하지만, 인터페이스는 다중 구현 가능

3. **계약(Contract) 역할**
   - "이 인터페이스를 구현하면 이러한 기능을 제공한다"는 약속
   - 외부에서는 구현 방법을 몰라도 사용 가능

4. **타입으로 사용**
   - 인터페이스 타입의 변수 선언 가능
   - 다형성을 통한 유연한 프로그래밍

### 📋 인터페이스 vs 추상 클래스 비교

| 구분 | 인터페이스 | 추상 클래스 |
|------|-----------|-----------|
| 키워드 | `interface` | `abstract class` |
| 상속/구현 | 다중 구현 가능 (`implements`) | 단일 상속만 가능 (`extends`) |
| 필드 | 상수만 가능 (`public static final`) | 모든 종류의 필드 가능 |
| 메서드 | 추상/default/static (Java 8+) | 추상/일반/static/final 모두 가능 |
| 생성자 | 불가능 | 가능 |
| 목적 | "무엇을 할 수 있는가" (CAN-DO) | "무엇인가" (IS-A) |
| 예시 | `Flyable`, `Swimmable`, `Serializable` | `Animal`, `Vehicle`, `Employee` |

### 💻 기본 문법

```java
// 인터페이스 선언
public interface MyInterface {
    // 상수 (public static final이 자동으로 붙음)
    int MAX_VALUE = 100;

    // 추상 메서드 (public abstract가 자동으로 붙음)
    void doSomething();
    int calculate(int x, int y);

    // default 메서드 (Java 8+)
    default void defaultMethod() {
        System.out.println("기본 구현");
    }

    // static 메서드 (Java 8+)
    static void staticMethod() {
        System.out.println("정적 메서드");
    }

    // private 메서드 (Java 9+)
    private void helperMethod() {
        System.out.println("내부 헬퍼 메서드");
    }
}

// 인터페이스 구현
public class MyClass implements MyInterface {
    @Override
    public void doSomething() {
        System.out.println("구현");
    }

    @Override
    public int calculate(int x, int y) {
        return x + y;
    }
}

// 다중 인터페이스 구현
public class MultiClass implements Interface1, Interface2, Interface3 {
    // 모든 인터페이스의 추상 메서드를 구현해야 함
}
```

---

## 🌟 실생활 비유 1: 전자기기 충전 인터페이스 (USB-C, Lightning, Micro-USB)

### 📖 비유 설명

전자기기를 충전할 때 다양한 충전 포트(USB-C, Lightning, Micro-USB)가 있습니다. 각 포트는 "충전할 수 있다"는 공통 기능을 제공하지만, 실제 충전 방식(전압, 전류, 프로토콜)은 다릅니다. 이것이 인터페이스의 개념과 정확히 일치합니다!

**핵심 개념:**
- 모든 충전 포트는 "충전할 수 있다"는 기능을 가짐 (인터페이스)
- 각 포트의 구체적인 충전 방식은 다름 (구현)
- 하나의 기기가 여러 충전 방식을 지원할 수 있음 (다중 구현)

### 💻 Java 코드 구현

```java
/**
 * 충전 가능한 기기의 인터페이스
 */
interface Chargeable {
    void charge(int voltage, int current);
    int getBatteryLevel();
    boolean isFullyCharged();
}

/**
 * 빠른 충전 지원 인터페이스
 */
interface FastChargeable {
    void fastCharge(int wattage);
    int getFastChargeMaxWattage();
}

/**
 * 무선 충전 지원 인터페이스
 */
interface WirelessChargeable {
    void wirelessCharge(int wattage);
    boolean supportsQiStandard();
}

/**
 * 데이터 전송 가능 인터페이스
 */
interface DataTransferable {
    void transferData(String data);
    int getTransferSpeed(); // Mbps
}

/**
 * USB-C 포트를 가진 기기 (다중 인터페이스 구현)
 */
class UsbCDevice implements Chargeable, FastChargeable, DataTransferable {
    private String deviceName;
    private int batteryLevel;
    private int batteryCapacity;
    private final int MAX_WATTAGE = 100; // USB-C PD는 최대 100W

    public UsbCDevice(String deviceName, int batteryCapacity) {
        this.deviceName = deviceName;
        this.batteryCapacity = batteryCapacity;
        this.batteryLevel = 20; // 초기 배터리 20%
    }

    @Override
    public void charge(int voltage, int current) {
        int wattage = voltage * current / 1000;
        System.out.println("[USB-C] " + deviceName + " 일반 충전 중...");
        System.out.println("  전압: " + voltage + "V, 전류: " + current + "mA");
        System.out.println("  전력: " + wattage + "W");

        batteryLevel += 10;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getBatteryLevel() {
        return batteryLevel;
    }

    @Override
    public boolean isFullyCharged() {
        return batteryLevel >= 100;
    }

    @Override
    public void fastCharge(int wattage) {
        if (wattage > MAX_WATTAGE) {
            System.out.println("[USB-C] 경고: 최대 전력 초과! " + MAX_WATTAGE + "W로 제한합니다.");
            wattage = MAX_WATTAGE;
        }

        System.out.println("[USB-C] " + deviceName + " 급속 충전 중! ⚡");
        System.out.println("  전력: " + wattage + "W (USB Power Delivery)");

        batteryLevel += 30;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getFastChargeMaxWattage() {
        return MAX_WATTAGE;
    }

    @Override
    public void transferData(String data) {
        System.out.println("[USB-C] 데이터 전송 중...");
        System.out.println("  데이터: " + data);
        System.out.println("  전송 속도: " + getTransferSpeed() + " Mbps");
        System.out.println("  전송 완료!");
    }

    @Override
    public int getTransferSpeed() {
        return 10000; // USB 3.1 Gen 2: 10 Gbps
    }

    public String getDeviceName() {
        return deviceName;
    }
}

/**
 * Lightning 포트를 가진 기기 (Apple)
 */
class LightningDevice implements Chargeable, FastChargeable, DataTransferable {
    private String deviceName;
    private int batteryLevel;
    private final int MAX_WATTAGE = 30; // iPhone은 최대 30W

    public LightningDevice(String deviceName) {
        this.deviceName = deviceName;
        this.batteryLevel = 15;
    }

    @Override
    public void charge(int voltage, int current) {
        int wattage = voltage * current / 1000;
        System.out.println("[Lightning] " + deviceName + " 충전 중... 🍎");
        System.out.println("  전압: " + voltage + "V, 전류: " + current + "mA");

        batteryLevel += 8;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getBatteryLevel() {
        return batteryLevel;
    }

    @Override
    public boolean isFullyCharged() {
        return batteryLevel >= 100;
    }

    @Override
    public void fastCharge(int wattage) {
        if (wattage > MAX_WATTAGE) {
            wattage = MAX_WATTAGE;
        }

        System.out.println("[Lightning] " + deviceName + " 빠른 충전 중! ⚡🍎");
        System.out.println("  전력: " + wattage + "W");

        batteryLevel += 25;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getFastChargeMaxWattage() {
        return MAX_WATTAGE;
    }

    @Override
    public void transferData(String data) {
        System.out.println("[Lightning] iTunes를 통한 데이터 전송...");
        System.out.println("  데이터: " + data);
        System.out.println("  전송 속도: " + getTransferSpeed() + " Mbps");
    }

    @Override
    public int getTransferSpeed() {
        return 480; // USB 2.0: 480 Mbps
    }
}

/**
 * 무선 충전 지원 스마트폰
 */
class WirelessPhone implements Chargeable, FastChargeable, WirelessChargeable, DataTransferable {
    private String deviceName;
    private int batteryLevel;

    public WirelessPhone(String deviceName) {
        this.deviceName = deviceName;
        this.batteryLevel = 30;
    }

    @Override
    public void charge(int voltage, int current) {
        System.out.println("[유선] " + deviceName + " 충전 중...");
        batteryLevel += 10;
        if (batteryLevel > 100) batteryLevel = 100;
        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getBatteryLevel() {
        return batteryLevel;
    }

    @Override
    public boolean isFullyCharged() {
        return batteryLevel >= 100;
    }

    @Override
    public void fastCharge(int wattage) {
        System.out.println("[유선 급속] " + deviceName + " 충전 중! ⚡");
        System.out.println("  전력: " + wattage + "W");
        batteryLevel += 30;
        if (batteryLevel > 100) batteryLevel = 100;
        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getFastChargeMaxWattage() {
        return 65;
    }

    @Override
    public void wirelessCharge(int wattage) {
        System.out.println("[무선] " + deviceName + " 무선 충전 중... 📡");
        System.out.println("  전력: " + wattage + "W (Qi 표준)");

        batteryLevel += 15;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public boolean supportsQiStandard() {
        return true;
    }

    @Override
    public void transferData(String data) {
        System.out.println("[무선] " + deviceName + " 데이터 전송 (WiFi/Bluetooth)");
        System.out.println("  데이터: " + data);
    }

    @Override
    public int getTransferSpeed() {
        return 1200; // WiFi: 1.2 Gbps
    }
}

/**
 * 레거시 기기 (Micro-USB만 지원)
 */
class MicroUsbDevice implements Chargeable {
    private String deviceName;
    private int batteryLevel;

    public MicroUsbDevice(String deviceName) {
        this.deviceName = deviceName;
        this.batteryLevel = 40;
    }

    @Override
    public void charge(int voltage, int current) {
        System.out.println("[Micro-USB] " + deviceName + " 충전 중...");
        System.out.println("  전압: " + voltage + "V, 전류: " + current + "mA");

        batteryLevel += 5;
        if (batteryLevel > 100) batteryLevel = 100;

        System.out.println("  배터리: " + batteryLevel + "%");
    }

    @Override
    public int getBatteryLevel() {
        return batteryLevel;
    }

    @Override
    public boolean isFullyCharged() {
        return batteryLevel >= 100;
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 충전 인터페이스 테스트
 */
public class ChargingInterfaceTest {

    public static void main(String[] args) {

        System.out.println("==============================================");
        System.out.println("전자기기 충전 인터페이스 테스트");
        System.out.println("==============================================\n");

        // 다양한 기기 생성
        UsbCDevice laptop = new UsbCDevice("맥북 프로", 5000);
        LightningDevice iphone = new LightningDevice("iPhone 15 Pro");
        WirelessPhone galaxy = new WirelessPhone("갤럭시 S24");
        MicroUsbDevice oldPhone = new MicroUsbDevice("구형 안드로이드폰");

        // 테스트 1: USB-C 기기 충전 및 데이터 전송
        test1_UsbCDevice(laptop);

        // 테스트 2: Lightning 기기 충전
        test2_LightningDevice(iphone);

        // 테스트 3: 무선 충전 지원 기기
        test3_WirelessDevice(galaxy);

        // 테스트 4: 레거시 기기
        test4_LegacyDevice(oldPhone);

        // 테스트 5: 다형성 - 모든 충전 가능한 기기를 동일하게 처리
        test5_Polymorphism(laptop, iphone, galaxy, oldPhone);
    }

    static void test1_UsbCDevice(UsbCDevice device) {
        System.out.println("### 테스트 1: USB-C 기기 ###");
        System.out.println("기기: " + device.getDeviceName());
        System.out.println("초기 배터리: " + device.getBatteryLevel() + "%\n");

        // 일반 충전
        device.charge(5, 3000); // 5V, 3A = 15W
        System.out.println();

        // 급속 충전
        device.fastCharge(100); // 100W
        System.out.println();

        // 데이터 전송
        device.transferData("프로젝트 파일 (2.5GB)");
        System.out.println("\n");
    }

    static void test2_LightningDevice(LightningDevice device) {
        System.out.println("### 테스트 2: Lightning 기기 ###");
        System.out.println("초기 배터리: " + device.getBatteryLevel() + "%\n");

        device.charge(5, 2400); // 5V, 2.4A = 12W
        System.out.println();

        device.fastCharge(30); // 30W
        System.out.println();

        device.transferData("사진 앨범 (500장)");
        System.out.println("\n");
    }

    static void test3_WirelessDevice(WirelessPhone device) {
        System.out.println("### 테스트 3: 무선 충전 지원 기기 ###");
        System.out.println("초기 배터리: " + device.getBatteryLevel() + "%\n");

        // 유선 충전
        device.fastCharge(45);
        System.out.println();

        // 무선 충전
        if (device instanceof WirelessChargeable) {
            WirelessChargeable wireless = (WirelessChargeable) device;
            if (wireless.supportsQiStandard()) {
                wireless.wirelessCharge(15); // 15W 무선 충전
            }
        }
        System.out.println();

        device.transferData("연락처 및 메시지");
        System.out.println("\n");
    }

    static void test4_LegacyDevice(MicroUsbDevice device) {
        System.out.println("### 테스트 4: 레거시 기기 (Micro-USB) ###");
        System.out.println("초기 배터리: " + device.getBatteryLevel() + "%\n");

        device.charge(5, 1000); // 5V, 1A = 5W
        System.out.println("\n");
    }

    static void test5_Polymorphism(Chargeable... devices) {
        System.out.println("### 테스트 5: 다형성 - 일괄 충전 ###");
        System.out.println("모든 기기를 일반 충전 모드로 충전합니다.\n");

        for (Chargeable device : devices) {
            System.out.println("배터리: " + device.getBatteryLevel() + "%");
            device.charge(5, 2000);

            // 급속 충전 지원 확인
            if (device instanceof FastChargeable) {
                FastChargeable fastDevice = (FastChargeable) device;
                System.out.println("  → 급속 충전 지원 (최대 " +
                    fastDevice.getFastChargeMaxWattage() + "W)");
            }

            System.out.println("  → 충전 후 배터리: " + device.getBatteryLevel() + "%");
            System.out.println();
        }
    }
}
```

### 🎯 핵심 포인트

1. **다중 인터페이스 구현**
   - `UsbCDevice`는 3개의 인터페이스를 구현 (`Chargeable`, `FastChargeable`, `DataTransferable`)
   - `WirelessPhone`은 4개의 인터페이스를 구현 (무선 충전 추가)
   - 이것이 인터페이스의 가장 큰 장점!

2. **다형성 활용**
   - 모든 기기를 `Chargeable` 타입으로 통일하여 처리 가능
   - `instanceof`로 특정 기능 지원 여부 확인

3. **확장성**
   - 새로운 충전 방식(예: 태양광 충전)을 추가하려면 새 인터페이스만 만들면 됨
   - 기존 코드 수정 없이 확장 가능

---

## 🌟 실생활 비유 2: 결제 수단 (Payment Methods)

### 📖 비유 설명

온라인 쇼핑몰에서 다양한 결제 수단(신용카드, 체크카드, 계좌이체, 간편결제, 암호화폐)을 지원합니다. 모든 결제 수단은 "결제할 수 있다"는 공통 기능을 제공하지만, 실제 결제 과정은 완전히 다릅니다.

**핵심 개념:**
- 모든 결제 수단은 "결제 가능" 인터페이스를 구현
- 일부는 "환불 가능", "할부 가능", "포인트 적립 가능" 등의 추가 인터페이스 구현
- 쇼핑몰은 결제 수단의 구체적인 방법을 몰라도 인터페이스만으로 결제 처리

### 💻 Java 코드 구현

```java
/**
 * 결제 가능 인터페이스 (필수)
 */
interface Payable {
    boolean pay(int amount, String orderId);
    String getPaymentMethodName();
}

/**
 * 환불 가능 인터페이스
 */
interface Refundable {
    boolean refund(String transactionId, int amount);
    int getRefundProcessingDays();
}

/**
 * 할부 결제 가능 인터페이스
 */
interface Installmentable {
    boolean payWithInstallment(int amount, String orderId, int months);
    int[] getAvailableInstallmentMonths();
}

/**
 * 포인트 적립 가능 인터페이스
 */
interface PointEarnable {
    int earnPoints(int amount);
    int getPointRate(); // 포인트 적립률 (%)
}

/**
 * 해외 결제 가능 인터페이스
 */
interface InternationalPayable {
    boolean payInternational(int amount, String orderId, String currency);
    String[] getSupportedCurrencies();
}

/**
 * 신용카드 결제
 */
class CreditCardPayment implements Payable, Refundable, Installmentable,
                                   PointEarnable, InternationalPayable {

    private String cardNumber;
    private String cardHolderName;
    private java.util.Map<String, Integer> transactions = new java.util.HashMap<>();

    public CreditCardPayment(String cardNumber, String cardHolderName) {
        this.cardNumber = maskCardNumber(cardNumber);
        this.cardHolderName = cardHolderName;
    }

    @Override
    public boolean pay(int amount, String orderId) {
        System.out.println("\n[신용카드 결제]");
        System.out.println("  카드 번호: " + cardNumber);
        System.out.println("  카드 소유자: " + cardHolderName);
        System.out.println("  결제 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  주문 번호: " + orderId);

        // 카드사 승인 시뮬레이션
        System.out.println("  카드사 승인 요청 중...");
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        String transactionId = "TXN-" + System.currentTimeMillis();
        transactions.put(transactionId, amount);

        System.out.println("  ✓ 승인 완료 (거래번호: " + transactionId + ")");

        // 포인트 적립
        int points = earnPoints(amount);
        System.out.println("  ✓ 포인트 적립: " + points + "P");

        return true;
    }

    @Override
    public String getPaymentMethodName() {
        return "신용카드";
    }

    @Override
    public boolean refund(String transactionId, int amount) {
        System.out.println("\n[신용카드 환불]");
        System.out.println("  거래번호: " + transactionId);
        System.out.println("  환불 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  ✓ 환불 승인 (영업일 기준 " + getRefundProcessingDays() + "일 소요)");
        return true;
    }

    @Override
    public int getRefundProcessingDays() {
        return 3; // 3영업일
    }

    @Override
    public boolean payWithInstallment(int amount, String orderId, int months) {
        System.out.println("\n[신용카드 할부 결제]");
        System.out.println("  카드 번호: " + cardNumber);
        System.out.println("  결제 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  할부 개월: " + months + "개월");
        System.out.println("  월 납입금: " + String.format("%,d", amount / months) + "원");
        System.out.println("  ✓ 할부 승인 완료");
        return true;
    }

    @Override
    public int[] getAvailableInstallmentMonths() {
        return new int[]{2, 3, 6, 12, 24};
    }

    @Override
    public int earnPoints(int amount) {
        return amount * getPointRate() / 100;
    }

    @Override
    public int getPointRate() {
        return 1; // 1% 적립
    }

    @Override
    public boolean payInternational(int amount, String orderId, String currency) {
        System.out.println("\n[해외 결제]");
        System.out.println("  카드 번호: " + cardNumber);
        System.out.println("  결제 금액: " + amount + " " + currency);
        System.out.println("  ✓ 해외 결제 승인");
        return true;
    }

    @Override
    public String[] getSupportedCurrencies() {
        return new String[]{"USD", "EUR", "JPY", "CNY", "GBP"};
    }

    private String maskCardNumber(String cardNumber) {
        if (cardNumber.length() < 4) return "****";
        return "****-****-****-" + cardNumber.substring(cardNumber.length() - 4);
    }
}

/**
 * 계좌이체 결제
 */
class BankTransferPayment implements Payable, Refundable {

    private String bankName;
    private String accountNumber;

    public BankTransferPayment(String bankName, String accountNumber) {
        this.bankName = bankName;
        this.accountNumber = maskAccount(accountNumber);
    }

    @Override
    public boolean pay(int amount, String orderId) {
        System.out.println("\n[계좌이체 결제]");
        System.out.println("  은행: " + bankName);
        System.out.println("  계좌번호: " + accountNumber);
        System.out.println("  이체 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  주문 번호: " + orderId);

        System.out.println("  계좌 잔액 확인 중...");
        System.out.println("  이체 처리 중...");

        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("  ✓ 이체 완료");
        return true;
    }

    @Override
    public String getPaymentMethodName() {
        return "계좌이체";
    }

    @Override
    public boolean refund(String transactionId, int amount) {
        System.out.println("\n[계좌이체 환불]");
        System.out.println("  환불 계좌: " + bankName + " " + accountNumber);
        System.out.println("  환불 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  ✓ 환불 처리 (영업일 기준 " + getRefundProcessingDays() + "일 소요)");
        return true;
    }

    @Override
    public int getRefundProcessingDays() {
        return 1; // 1영업일
    }

    private String maskAccount(String account) {
        if (account.length() < 4) return "***";
        return account.substring(0, 3) + "-******-" + account.substring(account.length() - 2);
    }
}

/**
 * 간편결제 (카카오페이, 네이버페이 등)
 */
class SimplePayment implements Payable, Refundable, PointEarnable {

    private String serviceName;
    private String userId;

    public SimplePayment(String serviceName, String userId) {
        this.serviceName = serviceName;
        this.userId = userId;
    }

    @Override
    public boolean pay(int amount, String orderId) {
        System.out.println("\n[" + serviceName + " 결제]");
        System.out.println("  사용자: " + userId);
        System.out.println("  결제 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  주문 번호: " + orderId);

        System.out.println("  생체 인증 중...");
        System.out.println("  ✓ 인증 완료");
        System.out.println("  ✓ 결제 완료");

        // 캐시백
        int points = earnPoints(amount);
        System.out.println("  ✓ 캐시백: " + points + "원");

        return true;
    }

    @Override
    public String getPaymentMethodName() {
        return serviceName;
    }

    @Override
    public boolean refund(String transactionId, int amount) {
        System.out.println("\n[" + serviceName + " 환불]");
        System.out.println("  환불 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  ✓ 즉시 환불 완료");
        return true;
    }

    @Override
    public int getRefundProcessingDays() {
        return 0; // 즉시 환불
    }

    @Override
    public int earnPoints(int amount) {
        return amount * getPointRate() / 100;
    }

    @Override
    public int getPointRate() {
        return 2; // 2% 캐시백
    }
}

/**
 * 암호화폐 결제
 */
class CryptoPayment implements Payable, InternationalPayable {

    private String walletAddress;
    private String cryptoType;

    public CryptoPayment(String cryptoType, String walletAddress) {
        this.cryptoType = cryptoType;
        this.walletAddress = walletAddress;
    }

    @Override
    public boolean pay(int amount, String orderId) {
        System.out.println("\n[" + cryptoType + " 결제]");
        System.out.println("  지갑 주소: " + walletAddress);
        System.out.println("  결제 금액: " + String.format("%,d", amount) + "원");
        System.out.println("  주문 번호: " + orderId);

        System.out.println("  블록체인 트랜잭션 생성 중...");

        try {
            Thread.sleep(800);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("  ✓ 트랜잭션 승인 (블록 높이: 850234)");
        return true;
    }

    @Override
    public String getPaymentMethodName() {
        return cryptoType + " (암호화폐)";
    }

    @Override
    public boolean payInternational(int amount, String orderId, String currency) {
        System.out.println("\n[" + cryptoType + " 국제 결제]");
        System.out.println("  결제 금액: " + amount + " " + currency);
        System.out.println("  ✓ 국경 없는 결제 완료");
        return true;
    }

    @Override
    public String[] getSupportedCurrencies() {
        return new String[]{"BTC", "ETH", "USDT", "BNB"};
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 결제 수단 인터페이스 테스트
 */
public class PaymentInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("온라인 쇼핑몰 결제 시스템");
        System.out.println("===============================================");

        // 다양한 결제 수단 생성
        CreditCardPayment creditCard = new CreditCardPayment(
            "1234-5678-9012-3456",
            "김철수"
        );

        BankTransferPayment bankTransfer = new BankTransferPayment(
            "국민은행",
            "123-456-789012"
        );

        SimplePayment kakaoPay = new SimplePayment("카카오페이", "user@kakao.com");
        CryptoPayment bitcoin = new CryptoPayment("Bitcoin", "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa");

        // 주문 정보
        String orderId = "ORDER-2024-001";
        int amount = 150000;

        // 테스트 1: 신용카드 결제 (모든 기능 지원)
        test1_CreditCardPayment(creditCard, orderId, amount);

        // 테스트 2: 계좌이체
        test2_BankTransferPayment(bankTransfer, orderId, amount);

        // 테스트 3: 간편결제
        test3_SimplePayment(kakaoPay, orderId, amount);

        // 테스트 4: 암호화폐
        test4_CryptoPayment(bitcoin, orderId, amount);

        // 테스트 5: 다형성 - 모든 결제 수단을 동일하게 처리
        test5_ProcessAllPayments(creditCard, bankTransfer, kakaoPay, bitcoin);
    }

    static void test1_CreditCardPayment(CreditCardPayment card, String orderId, int amount) {
        System.out.println("\n### 테스트 1: 신용카드 결제 (전체 기능) ###");

        // 일반 결제
        card.pay(amount, orderId);

        // 할부 결제
        card.payWithInstallment(amount, orderId + "-INST", 12);

        // 해외 결제
        card.payInternational(100, orderId + "-INT", "USD");

        // 환불
        card.refund("TXN-123456", 50000);

        System.out.println();
    }

    static void test2_BankTransferPayment(BankTransferPayment bank, String orderId, int amount) {
        System.out.println("\n### 테스트 2: 계좌이체 ###");

        bank.pay(amount, orderId);
        bank.refund("TXN-789012", amount);

        System.out.println();
    }

    static void test3_SimplePayment(SimplePayment simple, String orderId, int amount) {
        System.out.println("\n### 테스트 3: 간편결제 ###");

        simple.pay(amount, orderId);
        simple.refund("TXN-345678", 30000);

        System.out.println();
    }

    static void test4_CryptoPayment(CryptoPayment crypto, String orderId, int amount) {
        System.out.println("\n### 테스트 4: 암호화폐 결제 ###");

        crypto.pay(amount, orderId);
        crypto.payInternational(50, orderId + "-CRYPTO", "BTC");

        System.out.println();
    }

    static void test5_ProcessAllPayments(Payable... payments) {
        System.out.println("\n### 테스트 5: 통합 결제 처리 (다형성) ###");

        String orderId = "ORDER-BATCH-001";
        int amount = 50000;

        for (Payable payment : payments) {
            System.out.println("\n----------------------------------------");
            System.out.println("결제 수단: " + payment.getPaymentMethodName());

            // 결제 실행
            boolean success = payment.pay(amount, orderId);

            // 추가 기능 확인
            System.out.print("지원 기능: ");

            if (payment instanceof Refundable) {
                System.out.print("환불 ");
            }
            if (payment instanceof Installmentable) {
                System.out.print("할부 ");
            }
            if (payment instanceof PointEarnable) {
                PointEarnable pointPayment = (PointEarnable) payment;
                System.out.print("포인트(" + pointPayment.getPointRate() + "%) ");
            }
            if (payment instanceof InternationalPayable) {
                System.out.print("해외결제 ");
            }

            System.out.println();
            System.out.println("결제 결과: " + (success ? "✓ 성공" : "✗ 실패"));
        }
    }
}
```

### 🎯 핵심 포인트

1. **기능별 인터페이스 분리**
   - `Payable`: 기본 결제 기능
   - `Refundable`: 환불 기능
   - `Installmentable`: 할부 기능
   - `PointEarnable`: 포인트 적립
   - `InternationalPayable`: 해외 결제

2. **선택적 기능 구현**
   - 신용카드: 5개 인터페이스 모두 구현
   - 계좌이체: 2개만 구현 (결제, 환불)
   - 간편결제: 3개 구현 (결제, 환불, 포인트)
   - 암호화폐: 2개 구현 (결제, 해외결제)

3. **유연한 확장**
   - 새로운 결제 수단(예: QR코드 결제) 추가 시 기존 코드 수정 불필요
   - 필요한 인터페이스만 선택하여 구현

---

## 🌟 실생활 비유 3: 운송 수단 (Transportation)

### 📖 비유 설명

사람들은 다양한 방법으로 이동합니다: 걷기, 자전거, 자동차, 비행기, 배 등. 모든 운송 수단은 "이동할 수 있다"는 공통 기능을 가지지만, 이동 방식(육상, 해상, 항공)은 완전히 다릅니다.

**핵심 개념:**
- `Movable`: 모든 운송 수단의 기본 인터페이스
- `LandMovable`, `WaterMovable`, `AirMovable`: 이동 방식별 인터페이스
- 일부 운송 수단은 여러 방식을 지원 (수륙양용차, 비행보트 등)

### 💻 Java 코드 구현

```java
/**
 * 이동 가능 인터페이스 (기본)
 */
interface Movable {
    void move(int distance);
    int getSpeed(); // km/h
    String getTransportationType();
}

/**
 * 육상 이동 인터페이스
 */
interface LandMovable extends Movable {
    void driveOnRoad();
    int getNumberOfWheels();
}

/**
 * 해상 이동 인터페이스
 */
interface WaterMovable extends Movable {
    void sail();
    boolean canDiveUnderwater();
}

/**
 * 항공 이동 인터페이스
 */
interface AirMovable extends Movable {
    void fly();
    int getMaxAltitude(); // 최대 고도 (미터)
}

/**
 * 승객 탑승 가능 인터페이스
 */
interface PassengerCarriable {
    void boardPassengers(int count);
    int getMaxPassengerCapacity();
}

/**
 * 화물 운송 가능 인터페이스
 */
interface CargoCarriable {
    void loadCargo(int weightInKg);
    int getMaxCargoWeight();
}

/**
 * 자동차 - 육상 이동
 */
class Car implements LandMovable, PassengerCarriable {
    private String model;
    private int currentPassengers;

    public Car(String model) {
        this.model = model;
        this.currentPassengers = 0;
    }

    @Override
    public void move(int distance) {
        System.out.println("[자동차] " + model + "이(가) " + distance + "km 주행 중...");
        driveOnRoad();
    }

    @Override
    public int getSpeed() {
        return 120; // km/h
    }

    @Override
    public String getTransportationType() {
        return "육상 운송 (자동차)";
    }

    @Override
    public void driveOnRoad() {
        System.out.println("  도로를 달립니다 🚗 (속도: " + getSpeed() + " km/h)");
    }

    @Override
    public int getNumberOfWheels() {
        return 4;
    }

    @Override
    public void boardPassengers(int count) {
        currentPassengers += count;
        System.out.println("  승객 " + count + "명 탑승 (총 " + currentPassengers + "명)");
    }

    @Override
    public int getMaxPassengerCapacity() {
        return 5;
    }
}

/**
 * 비행기 - 항공 이동
 */
class Airplane implements AirMovable, PassengerCarriable, CargoCarriable {
    private String flightNumber;
    private int currentPassengers;
    private int currentCargoWeight;

    public Airplane(String flightNumber) {
        this.flightNumber = flightNumber;
        this.currentPassengers = 0;
        this.currentCargoWeight = 0;
    }

    @Override
    public void move(int distance) {
        System.out.println("[비행기] " + flightNumber + " 편이 " + distance + "km 비행 중...");
        fly();
    }

    @Override
    public int getSpeed() {
        return 900; // km/h
    }

    @Override
    public String getTransportationType() {
        return "항공 운송";
    }

    @Override
    public void fly() {
        System.out.println("  하늘을 날아갑니다 ✈️ (고도: " + getMaxAltitude() + "m, 속도: " + getSpeed() + " km/h)");
    }

    @Override
    public int getMaxAltitude() {
        return 12000; // 12,000m
    }

    @Override
    public void boardPassengers(int count) {
        currentPassengers += count;
        System.out.println("  승객 " + count + "명 탑승 (총 " + currentPassengers + "명/" + getMaxPassengerCapacity() + "명)");
    }

    @Override
    public int getMaxPassengerCapacity() {
        return 300;
    }

    @Override
    public void loadCargo(int weightInKg) {
        currentCargoWeight += weightInKg;
        System.out.println("  화물 " + weightInKg + "kg 적재 (총 " + currentCargoWeight + "kg/" + getMaxCargoWeight() + "kg)");
    }

    @Override
    public int getMaxCargoWeight() {
        return 50000; // 50톤
    }
}

/**
 * 배 - 해상 이동
 */
class Ship implements WaterMovable, PassengerCarriable, CargoCarriable {
    private String shipName;
    private int currentPassengers;
    private int currentCargoWeight;

    public Ship(String shipName) {
        this.shipName = shipName;
        this.currentPassengers = 0;
        this.currentCargoWeight = 0;
    }

    @Override
    public void move(int distance) {
        System.out.println("[선박] " + shipName + "호가 " + distance + "km 항해 중...");
        sail();
    }

    @Override
    public int getSpeed() {
        return 40; // km/h (약 22 knots)
    }

    @Override
    public String getTransportationType() {
        return "해상 운송";
    }

    @Override
    public void sail() {
        System.out.println("  바다를 항해합니다 🚢 (속도: " + getSpeed() + " km/h)");
    }

    @Override
    public boolean canDiveUnderwater() {
        return false; // 일반 배는 잠수 불가
    }

    @Override
    public void boardPassengers(int count) {
        currentPassengers += count;
        System.out.println("  승객 " + count + "명 승선 (총 " + currentPassengers + "명)");
    }

    @Override
    public int getMaxPassengerCapacity() {
        return 2000;
    }

    @Override
    public void loadCargo(int weightInKg) {
        currentCargoWeight += weightInKg;
        System.out.println("  화물 " + weightInKg + "kg 적재 (총 " + currentCargoWeight + "kg)");
    }

    @Override
    public int getMaxCargoWeight() {
        return 100000000; // 100,000톤
    }
}

/**
 * 잠수함 - 해상 이동 (수중 이동 가능)
 */
class Submarine implements WaterMovable, PassengerCarriable {
    private String submarineName;
    private boolean underwater;

    public Submarine(String submarineName) {
        this.submarineName = submarineName;
        this.underwater = false;
    }

    @Override
    public void move(int distance) {
        System.out.println("[잠수함] " + submarineName + "호가 " + distance + "km 이동 중...");
        if (underwater) {
            System.out.println("  수중을 이동합니다 🔱");
        } else {
            sail();
        }
    }

    @Override
    public int getSpeed() {
        return underwater ? 30 : 40; // 수중/수상 속도
    }

    @Override
    public String getTransportationType() {
        return "해상/수중 운송";
    }

    @Override
    public void sail() {
        System.out.println("  수면 위를 항해합니다 🚢");
        underwater = false;
    }

    @Override
    public boolean canDiveUnderwater() {
        return true;
    }

    public void dive() {
        System.out.println("  잠수 시작! 🔽");
        underwater = true;
    }

    public void surface() {
        System.out.println("  부상 시작! 🔼");
        underwater = false;
    }

    @Override
    public void boardPassengers(int count) {
        System.out.println("  승무원 " + count + "명 탑승");
    }

    @Override
    public int getMaxPassengerCapacity() {
        return 100;
    }
}

/**
 * 수륙양용차 - 육상 + 해상 이동
 */
class AmphibiousVehicle implements LandMovable, WaterMovable, PassengerCarriable {
    private String vehicleName;
    private boolean inWater;

    public AmphibiousVehicle(String vehicleName) {
        this.vehicleName = vehicleName;
        this.inWater = false;
    }

    @Override
    public void move(int distance) {
        System.out.println("[수륙양용차] " + vehicleName + "이(가) " + distance + "km 이동 중...");
        if (inWater) {
            sail();
        } else {
            driveOnRoad();
        }
    }

    @Override
    public int getSpeed() {
        return inWater ? 10 : 100; // 물에서는 느림
    }

    @Override
    public String getTransportationType() {
        return "육상/해상 운송 (수륙양용)";
    }

    @Override
    public void driveOnRoad() {
        System.out.println("  육지를 달립니다 🚙 (속도: " + getSpeed() + " km/h)");
        inWater = false;
    }

    @Override
    public int getNumberOfWheels() {
        return 4;
    }

    @Override
    public void sail() {
        System.out.println("  물 위를 항해합니다 🌊 (속도: " + getSpeed() + " km/h)");
        inWater = true;
    }

    @Override
    public boolean canDiveUnderwater() {
        return false;
    }

    @Override
    public void boardPassengers(int count) {
        System.out.println("  승객 " + count + "명 탑승");
    }

    @Override
    public int getMaxPassengerCapacity() {
        return 8;
    }

    public void enterWater() {
        System.out.println("  물에 진입합니다! 💦");
        inWater = true;
    }

    public void exitWater() {
        System.out.println("  육지로 올라갑니다! 🏖️");
        inWater = false;
    }
}

/**
 * 트럭 - 육상 이동, 화물 전문
 */
class Truck implements LandMovable, CargoCarriable {
    private String truckModel;
    private int currentCargoWeight;

    public Truck(String truckModel) {
        this.truckModel = truckModel;
        this.currentCargoWeight = 0;
    }

    @Override
    public void move(int distance) {
        System.out.println("[트럭] " + truckModel + "이(가) " + distance + "km 운송 중...");
        driveOnRoad();
    }

    @Override
    public int getSpeed() {
        return 80; // km/h
    }

    @Override
    public String getTransportationType() {
        return "육상 화물 운송";
    }

    @Override
    public void driveOnRoad() {
        System.out.println("  도로를 달립니다 🚚 (적재량: " + currentCargoWeight + "kg)");
    }

    @Override
    public int getNumberOfWheels() {
        return 18; // 대형 트럭
    }

    @Override
    public void loadCargo(int weightInKg) {
        currentCargoWeight += weightInKg;
        System.out.println("  화물 " + weightInKg + "kg 적재 (총 " + currentCargoWeight + "kg/" + getMaxCargoWeight() + "kg)");
    }

    @Override
    public int getMaxCargoWeight() {
        return 20000; // 20톤
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 운송 수단 인터페이스 테스트
 */
public class TransportationInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("운송 수단 시스템 테스트");
        System.out.println("===============================================\n");

        // 다양한 운송 수단 생성
        Car car = new Car("테슬라 모델 3");
        Airplane airplane = new Airplane("KE123");
        Ship ship = new Ship("타이타닉");
        Submarine submarine = new Submarine("USS Nautilus");
        AmphibiousVehicle amphibious = new AmphibiousVehicle("미군 LARC-V");
        Truck truck = new Truck("볼보 FH16");

        // 테스트 1: 육상 운송
        test1_LandTransportation(car, truck, amphibious);

        // 테스트 2: 해상 운송
        test2_WaterTransportation(ship, submarine, amphibious);

        // 테스트 3: 항공 운송
        test3_AirTransportation(airplane);

        // 테스트 4: 승객 운송
        test4_PassengerTransportation(car, airplane, ship);

        // 테스트 5: 화물 운송
        test5_CargoTransportation(truck, airplane, ship);

        // 테스트 6: 다형성 - 모든 운송 수단 이동
        test6_MoveAll(car, airplane, ship, submarine, amphibious, truck);
    }

    static void test1_LandTransportation(LandMovable... vehicles) {
        System.out.println("### 테스트 1: 육상 운송 ###\n");

        for (LandMovable vehicle : vehicles) {
            System.out.println("운송 수단: " + vehicle.getTransportationType());
            System.out.println("바퀴 수: " + vehicle.getNumberOfWheels() + "개");
            vehicle.move(100);
            System.out.println();
        }
    }

    static void test2_WaterTransportation(WaterMovable... vessels) {
        System.out.println("### 테스트 2: 해상 운송 ###\n");

        for (WaterMovable vessel : vessels) {
            System.out.println("운송 수단: " + vessel.getTransportationType());
            System.out.println("잠수 가능: " + (vessel.canDiveUnderwater() ? "예" : "아니오"));
            vessel.move(500);

            // 잠수 가능한 경우 잠수 시연
            if (vessel instanceof Submarine) {
                Submarine sub = (Submarine) vessel;
                sub.dive();
                sub.move(200);
                sub.surface();
            }

            System.out.println();
        }
    }

    static void test3_AirTransportation(AirMovable... aircrafts) {
        System.out.println("### 테스트 3: 항공 운송 ###\n");

        for (AirMovable aircraft : aircrafts) {
            System.out.println("운송 수단: " + aircraft.getTransportationType());
            System.out.println("최대 고도: " + aircraft.getMaxAltitude() + "m");
            aircraft.move(1000);
            System.out.println();
        }
    }

    static void test4_PassengerTransportation(PassengerCarriable... transports) {
        System.out.println("### 테스트 4: 승객 운송 ###\n");

        for (PassengerCarriable transport : transports) {
            if (transport instanceof Movable) {
                Movable movable = (Movable) transport;
                System.out.println("운송 수단: " + movable.getTransportationType());
            }

            System.out.println("최대 승객: " + transport.getMaxPassengerCapacity() + "명");
            transport.boardPassengers(50);
            System.out.println();
        }
    }

    static void test5_CargoTransportation(CargoCarriable... transports) {
        System.out.println("### 테스트 5: 화물 운송 ###\n");

        for (CargoCarriable transport : transports) {
            if (transport instanceof Movable) {
                Movable movable = (Movable) transport;
                System.out.println("운송 수단: " + movable.getTransportationType());
            }

            System.out.println("최대 적재량: " + String.format("%,d", transport.getMaxCargoWeight()) + "kg");
            transport.loadCargo(5000);
            System.out.println();
        }
    }

    static void test6_MoveAll(Movable... transports) {
        System.out.println("### 테스트 6: 통합 이동 시스템 (다형성) ###\n");

        int distance = 200;

        for (Movable transport : transports) {
            System.out.println("----------------------------------------");
            System.out.println("운송 수단: " + transport.getTransportationType());
            System.out.println("속도: " + transport.getSpeed() + " km/h");

            // 이동 시간 계산
            double timeInHours = (double) distance / transport.getSpeed();
            System.out.printf("예상 시간: %.2f시간\n", timeInHours);

            // 이동
            transport.move(distance);

            // 지원 기능 표시
            System.out.print("지원 기능: ");
            if (transport instanceof PassengerCarriable) System.out.print("승객운송 ");
            if (transport instanceof CargoCarriable) System.out.print("화물운송 ");
            if (transport instanceof LandMovable) System.out.print("육상 ");
            if (transport instanceof WaterMovable) System.out.print("해상 ");
            if (transport instanceof AirMovable) System.out.print("항공 ");

            System.out.println("\n");
        }
    }
}
```

### 🎯 핵심 포인트

1. **인터페이스 상속**
   - `LandMovable`, `WaterMovable`, `AirMovable`이 모두 `Movable`을 상속
   - 계층적 인터페이스 구조

2. **다중 이동 방식**
   - `AmphibiousVehicle`: 육상 + 해상 이동 (2개 인터페이스 구현)
   - `Submarine`: 수상 + 수중 이동
   - 실제 세계의 복잡한 기능을 모델링

3. **역할 기반 인터페이스**
   - `PassengerCarriable`: 승객 운송 가능
   - `CargoCarriable`: 화물 운송 가능
   - 기능별로 인터페이스를 분리하여 명확한 계약

---

## 🌟 실생활 비유 4: 미디어 플레이어 (Media Players)

### 📖 비유 설명

우리는 다양한 기기에서 음악과 영상을 재생합니다: 스마트폰, 컴퓨터, TV, 스마트 스피커 등. 모든 기기는 "재생할 수 있다"는 공통 기능을 가지지만, 지원하는 포맷, 화질, 추가 기능은 각기 다릅니다.

**핵심 개념:**
- `Playable`: 기본 재생 인터페이스
- `AudioPlayable`, `VideoPlayable`: 오디오/비디오 재생
- `Streamable`: 스트리밍 지원
- `Downloadable`: 다운로드 지원
- 기기마다 필요한 기능만 선택적으로 구현

### 💻 Java 코드 구현

```java
/**
 * 재생 가능 인터페이스 (기본)
 */
interface Playable {
    void play(String mediaName);
    void pause();
    void stop();
    String getPlayerName();
}

/**
 * 오디오 재생 인터페이스
 */
interface AudioPlayable extends Playable {
    void playAudio(String audioFile);
    String[] getSupportedAudioFormats();
    void setVolume(int level);
}

/**
 * 비디오 재생 인터페이스
 */
interface VideoPlayable extends Playable {
    void playVideo(String videoFile);
    String[] getSupportedVideoFormats();
    void setResolution(String resolution);
}

/**
 * 스트리밍 지원 인터페이스
 */
interface Streamable {
    void streamFrom(String url);
    boolean supportsLiveStreaming();
    int getStreamingQuality();
}

/**
 * 다운로드 지원 인터페이스
 */
interface Downloadable {
    void download(String mediaUrl, String savePath);
    int getDownloadProgress();
    void pauseDownload();
    void resumeDownload();
}

/**
 * 재생 목록 관리 인터페이스
 */
interface PlaylistManageable {
    void addToPlaylist(String mediaName);
    void removeFromPlaylist(String mediaName);
    void shufflePlaylist();
    void repeatMode(boolean enabled);
}

/**
 * 스마트폰 음악 플레이어
 */
class SmartphoneMusicPlayer implements AudioPlayable, Streamable, Downloadable, PlaylistManageable {
    private String playerName;
    private int volume;
    private boolean isPlaying;
    private int downloadProgress;
    private java.util.List<String> playlist = new java.util.ArrayList<>();

    public SmartphoneMusicPlayer(String playerName) {
        this.playerName = playerName;
        this.volume = 50;
        this.isPlaying = false;
    }

    @Override
    public void play(String mediaName) {
        isPlaying = true;
        System.out.println("[" + playerName + "] 재생: " + mediaName + " 🎵");
    }

    @Override
    public void pause() {
        isPlaying = false;
        System.out.println("[" + playerName + "] 일시 정지");
    }

    @Override
    public void stop() {
        isPlaying = false;
        System.out.println("[" + playerName + "] 정지");
    }

    @Override
    public String getPlayerName() {
        return playerName;
    }

    @Override
    public void playAudio(String audioFile) {
        System.out.println("[" + playerName + "] 오디오 파일 재생");
        System.out.println("  파일: " + audioFile);
        System.out.println("  볼륨: " + volume + "%");
        play(audioFile);
    }

    @Override
    public String[] getSupportedAudioFormats() {
        return new String[]{"MP3", "AAC", "FLAC", "WAV", "OGG"};
    }

    @Override
    public void setVolume(int level) {
        this.volume = Math.max(0, Math.min(100, level));
        System.out.println("  볼륨 설정: " + volume + "%");
    }

    @Override
    public void streamFrom(String url) {
        System.out.println("[" + playerName + "] 스트리밍");
        System.out.println("  URL: " + url);
        System.out.println("  품질: " + getStreamingQuality() + "kbps");
    }

    @Override
    public boolean supportsLiveStreaming() {
        return true;
    }

    @Override
    public int getStreamingQuality() {
        return 320; // 320 kbps
    }

    @Override
    public void download(String mediaUrl, String savePath) {
        System.out.println("[" + playerName + "] 다운로드 시작");
        System.out.println("  URL: " + mediaUrl);
        System.out.println("  저장 경로: " + savePath);
        downloadProgress = 0;

        // 다운로드 시뮬레이션
        for (int i = 0; i <= 100; i += 25) {
            downloadProgress = i;
            System.out.println("  진행률: " + downloadProgress + "%");
        }
        System.out.println("  다운로드 완료!");
    }

    @Override
    public int getDownloadProgress() {
        return downloadProgress;
    }

    @Override
    public void pauseDownload() {
        System.out.println("[" + playerName + "] 다운로드 일시 정지");
    }

    @Override
    public void resumeDownload() {
        System.out.println("[" + playerName + "] 다운로드 재개");
    }

    @Override
    public void addToPlaylist(String mediaName) {
        playlist.add(mediaName);
        System.out.println("  재생 목록에 추가: " + mediaName + " (총 " + playlist.size() + "곡)");
    }

    @Override
    public void removeFromPlaylist(String mediaName) {
        playlist.remove(mediaName);
        System.out.println("  재생 목록에서 제거: " + mediaName);
    }

    @Override
    public void shufflePlaylist() {
        System.out.println("[" + playerName + "] 재생 목록 셔플");
        java.util.Collections.shuffle(playlist);
    }

    @Override
    public void repeatMode(boolean enabled) {
        System.out.println("[" + playerName + "] 반복 재생: " + (enabled ? "ON" : "OFF"));
    }
}

/**
 * 스마트 TV
 */
class SmartTV implements VideoPlayable, Streamable {
    private String tvModel;
    private String currentResolution;

    public SmartTV(String tvModel) {
        this.tvModel = tvModel;
        this.currentResolution = "1080p";
    }

    @Override
    public void play(String mediaName) {
        System.out.println("[" + tvModel + "] 재생: " + mediaName + " 📺");
    }

    @Override
    public void pause() {
        System.out.println("[" + tvModel + "] 일시 정지");
    }

    @Override
    public void stop() {
        System.out.println("[" + tvModel + "] 정지");
    }

    @Override
    public String getPlayerName() {
        return tvModel;
    }

    @Override
    public void playVideo(String videoFile) {
        System.out.println("[" + tvModel + "] 비디오 재생");
        System.out.println("  파일: " + videoFile);
        System.out.println("  해상도: " + currentResolution);
        play(videoFile);
    }

    @Override
    public String[] getSupportedVideoFormats() {
        return new String[]{"MP4", "AVI", "MKV", "MOV", "WebM"};
    }

    @Override
    public void setResolution(String resolution) {
        this.currentResolution = resolution;
        System.out.println("  해상도 변경: " + resolution);
    }

    @Override
    public void streamFrom(String url) {
        System.out.println("[" + tvModel + "] 스트리밍");
        System.out.println("  URL: " + url);
        System.out.println("  해상도: " + currentResolution);
        System.out.println("  품질: " + getStreamingQuality() + "p");
    }

    @Override
    public boolean supportsLiveStreaming() {
        return true;
    }

    @Override
    public int getStreamingQuality() {
        return 4000; // 4K
    }
}

/**
 * MP3 플레이어 (레거시 기기)
 */
class MP3Player implements AudioPlayable {
    private int volume;

    public MP3Player() {
        this.volume = 50;
    }

    @Override
    public void play(String mediaName) {
        System.out.println("[MP3 플레이어] 재생: " + mediaName + " 🎵");
    }

    @Override
    public void pause() {
        System.out.println("[MP3 플레이어] 일시 정지");
    }

    @Override
    public void stop() {
        System.out.println("[MP3 플레이어] 정지");
    }

    @Override
    public String getPlayerName() {
        return "MP3 플레이어";
    }

    @Override
    public void playAudio(String audioFile) {
        System.out.println("[MP3 플레이어] 오디오 재생: " + audioFile);
    }

    @Override
    public String[] getSupportedAudioFormats() {
        return new String[]{"MP3"}; // MP3만 지원
    }

    @Override
    public void setVolume(int level) {
        this.volume = level;
        System.out.println("  볼륨: " + volume);
    }
}

/**
 * 노트북 미디어 플레이어
 */
class LaptopMediaPlayer implements AudioPlayable, VideoPlayable, Downloadable, PlaylistManageable {
    private int volume;
    private String resolution;
    private java.util.List<String> playlist = new java.util.ArrayList<>();

    public LaptopMediaPlayer() {
        this.volume = 60;
        this.resolution = "720p";
    }

    @Override
    public void play(String mediaName) {
        System.out.println("[노트북] 재생: " + mediaName);
    }

    @Override
    public void pause() {
        System.out.println("[노트북] 일시 정지");
    }

    @Override
    public void stop() {
        System.out.println("[노트북] 정지");
    }

    @Override
    public String getPlayerName() {
        return "노트북 미디어 플레이어";
    }

    @Override
    public void playAudio(String audioFile) {
        System.out.println("[노트북] 오디오 재생: " + audioFile);
    }

    @Override
    public String[] getSupportedAudioFormats() {
        return new String[]{"MP3", "AAC", "FLAC", "WAV", "OGG", "ALAC"};
    }

    @Override
    public void setVolume(int level) {
        this.volume = level;
        System.out.println("  볼륨: " + volume + "%");
    }

    @Override
    public void playVideo(String videoFile) {
        System.out.println("[노트북] 비디오 재생: " + videoFile);
        System.out.println("  해상도: " + resolution);
    }

    @Override
    public String[] getSupportedVideoFormats() {
        return new String[]{"MP4", "AVI", "MKV", "MOV", "WebM", "FLV"};
    }

    @Override
    public void setResolution(String resolution) {
        this.resolution = resolution;
    }

    @Override
    public void download(String mediaUrl, String savePath) {
        System.out.println("[노트북] 다운로드: " + mediaUrl + " → " + savePath);
    }

    @Override
    public int getDownloadProgress() {
        return 100;
    }

    @Override
    public void pauseDownload() {
        System.out.println("[노트북] 다운로드 일시 정지");
    }

    @Override
    public void resumeDownload() {
        System.out.println("[노트북] 다운로드 재개");
    }

    @Override
    public void addToPlaylist(String mediaName) {
        playlist.add(mediaName);
        System.out.println("  재생 목록 추가: " + mediaName);
    }

    @Override
    public void removeFromPlaylist(String mediaName) {
        playlist.remove(mediaName);
    }

    @Override
    public void shufflePlaylist() {
        System.out.println("[노트북] 재생 목록 셔플");
    }

    @Override
    public void repeatMode(boolean enabled) {
        System.out.println("[노트북] 반복 재생: " + enabled);
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 미디어 플레이어 인터페이스 테스트
 */
public class MediaPlayerInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("미디어 플레이어 시스템 테스트");
        System.out.println("===============================================\n");

        // 다양한 플레이어 생성
        SmartphoneMusicPlayer smartphone = new SmartphoneMusicPlayer("Spotify");
        SmartTV tv = new SmartTV("LG OLED C3");
        MP3Player mp3 = new MP3Player();
        LaptopMediaPlayer laptop = new LaptopMediaPlayer();

        // 테스트 1: 스마트폰 음악 플레이어 (모든 기능)
        test1_SmartphonePlayer(smartphone);

        // 테스트 2: 스마트 TV
        test2_SmartTV(tv);

        // 테스트 3: MP3 플레이어
        test3_MP3Player(mp3);

        // 테스트 4: 다형성 - 모든 플레이어를 동일하게 제어
        test4_UniversalControl(smartphone, tv, mp3, laptop);
    }

    static void test1_SmartphonePlayer(SmartphoneMusicPlayer player) {
        System.out.println("### 테스트 1: 스마트폰 음악 플레이어 ###\n");

        // 오디오 재생
        player.playAudio("좋은날 - IU.mp3");
        player.setVolume(70);
        System.out.println();

        // 재생 목록 관리
        player.addToPlaylist("Dynamite - BTS.mp3");
        player.addToPlaylist("Butter - BTS.mp3");
        player.shufflePlaylist();
        player.repeatMode(true);
        System.out.println();

        // 스트리밍
        player.streamFrom("https://music.example.com/live-radio");
        System.out.println();

        // 다운로드
        player.download("https://music.example.com/song.mp3", "/storage/music/");
        System.out.println();
    }

    static void test2_SmartTV(SmartTV tv) {
        System.out.println("### 테스트 2: 스마트 TV ###\n");

        // 비디오 재생
        tv.playVideo("어벤져스.mp4");
        tv.setResolution("4K");
        System.out.println();

        // 스트리밍
        tv.streamFrom("https://netflix.com/movie/123");
        System.out.println();
    }

    static void test3_MP3Player(MP3Player mp3) {
        System.out.println("### 테스트 3: MP3 플레이어 ###\n");

        mp3.playAudio("song.mp3");
        mp3.setVolume(80);
        mp3.pause();
        System.out.println();
    }

    static void test4_UniversalControl(Playable... players) {
        System.out.println("### 테스트 4: 통합 미디어 제어 (다형성) ###\n");

        for (Playable player : players) {
            System.out.println("----------------------------------------");
            System.out.println("플레이어: " + player.getPlayerName());

            // 재생
            player.play("테스트 미디어");

            // 기능 확인
            System.out.print("지원 기능: ");
            if (player instanceof AudioPlayable) {
                System.out.print("오디오 ");
            }
            if (player instanceof VideoPlayable) {
                System.out.print("비디오 ");
            }
            if (player instanceof Streamable) {
                System.out.print("스트리밍 ");
            }
            if (player instanceof Downloadable) {
                System.out.print("다운로드 ");
            }
            if (player instanceof PlaylistManageable) {
                System.out.print("재생목록 ");
            }

            System.out.println("\n");
        }
    }
}
```

### 🎯 핵심 포인트

1. **계층적 인터페이스**
   - `AudioPlayable`, `VideoPlayable`이 `Playable`을 상속
   - 기본 재생 기능 + 오디오/비디오 전용 기능

2. **기능 조합**
   - 스마트폰: 오디오 + 스트리밍 + 다운로드 + 재생목록
   - 스마트 TV: 비디오 + 스트리밍
   - MP3 플레이어: 오디오만
   - 노트북: 오디오 + 비디오 + 다운로드 + 재생목록

3. **유연한 확장**
   - 새로운 플레이어 타입(예: VR 헤드셋) 추가 용이
   - 기존 인터페이스 조합으로 다양한 기기 표현

---

## 🌟 실생활 비유 5: 스마트 홈 기기 (Smart Home Devices)

### 📖 비유 설명

스마트 홈에는 다양한 IoT 기기들이 있습니다: 스마트 전구, 온도조절기, 보안 카메라, 도어락, 가전제품 등. 모든 기기는 "제어 가능"하다는 공통점이 있지만, 각 기기마다 고유한 기능이 있습니다.

**핵심 개념:**
- `Controllable`: 모든 스마트 기기의 기본 제어 인터페이스
- `PowerControllable`: 전원 제어
- `SchedulableDevice`: 스케줄 설정 가능
- `VoiceControllable`: 음성 제어 지원
- `RemoteMonitorable`: 원격 모니터링 가능

### 💻 Java 코드 구현

```java
/**
 * 제어 가능 인터페이스 (기본)
 */
interface Controllable {
    void connect();
    void disconnect();
    String getDeviceName();
    String getDeviceStatus();
}

/**
 * 전원 제어 인터페이스
 */
interface PowerControllable extends Controllable {
    void turnOn();
    void turnOff();
    boolean isPoweredOn();
}

/**
 * 스케줄 설정 가능 인터페이스
 */
interface SchedulableDevice {
    void setSchedule(String time, String action);
    void removeSchedule(String scheduleId);
    void listSchedules();
}

/**
 * 음성 제어 지원 인터페이스
 */
interface VoiceControllable {
    void processVoiceCommand(String command);
    String[] getSupportedVoiceCommands();
}

/**
 * 원격 모니터링 가능 인터페이스
 */
interface RemoteMonitorable {
    String getCurrentState();
    void sendAlert(String message);
    boolean isOnline();
}

/**
 * 밝기 조절 가능 인터페이스
 */
interface Dimmable {
    void setBrightness(int level);
    int getBrightness();
}

/**
 * 온도 제어 인터페이스
 */
interface TemperatureControllable {
    void setTemperature(int celsius);
    int getCurrentTemperature();
    int getTargetTemperature();
}

/**
 * 스마트 전구
 */
class SmartLightBulb implements PowerControllable, SchedulableDevice,
                               VoiceControllable, Dimmable {
    private String deviceName;
    private boolean poweredOn;
    private int brightness;
    private boolean connected;
    private java.util.Map<String, String> schedules = new java.util.HashMap<>();

    public SmartLightBulb(String deviceName) {
        this.deviceName = deviceName;
        this.poweredOn = false;
        this.brightness = 100;
        this.connected = false;
    }

    @Override
    public void connect() {
        connected = true;
        System.out.println("[" + deviceName + "] WiFi 연결됨 💡");
    }

    @Override
    public void disconnect() {
        connected = false;
        System.out.println("[" + deviceName + "] WiFi 연결 해제");
    }

    @Override
    public String getDeviceName() {
        return deviceName;
    }

    @Override
    public String getDeviceStatus() {
        return poweredOn ? "켜짐 (밝기: " + brightness + "%)" : "꺼짐";
    }

    @Override
    public void turnOn() {
        poweredOn = true;
        System.out.println("[" + deviceName + "] 전구 켜짐 💡 (밝기: " + brightness + "%)");
    }

    @Override
    public void turnOff() {
        poweredOn = false;
        System.out.println("[" + deviceName + "] 전구 꺼짐");
    }

    @Override
    public boolean isPoweredOn() {
        return poweredOn;
    }

    @Override
    public void setSchedule(String time, String action) {
        String scheduleId = "SCH-" + System.currentTimeMillis();
        schedules.put(scheduleId, time + " : " + action);
        System.out.println("[" + deviceName + "] 스케줄 설정: " + time + " - " + action);
    }

    @Override
    public void removeSchedule(String scheduleId) {
        schedules.remove(scheduleId);
        System.out.println("[" + deviceName + "] 스케줄 제거: " + scheduleId);
    }

    @Override
    public void listSchedules() {
        System.out.println("[" + deviceName + "] 설정된 스케줄:");
        if (schedules.isEmpty()) {
            System.out.println("  없음");
        } else {
            schedules.forEach((id, schedule) ->
                System.out.println("  " + id + ": " + schedule));
        }
    }

    @Override
    public void processVoiceCommand(String command) {
        System.out.println("[" + deviceName + "] 음성 명령: \"" + command + "\"");

        command = command.toLowerCase();
        if (command.contains("켜") || command.contains("on")) {
            turnOn();
        } else if (command.contains("꺼") || command.contains("off")) {
            turnOff();
        } else if (command.contains("밝게")) {
            setBrightness(100);
        } else if (command.contains("어둡게")) {
            setBrightness(30);
        } else {
            System.out.println("  인식할 수 없는 명령입니다");
        }
    }

    @Override
    public String[] getSupportedVoiceCommands() {
        return new String[]{
            "전구 켜줘", "전구 꺼줘", "밝게 해줘", "어둡게 해줘"
        };
    }

    @Override
    public void setBrightness(int level) {
        this.brightness = Math.max(0, Math.min(100, level));
        if (poweredOn) {
            System.out.println("[" + deviceName + "] 밝기 조절: " + brightness + "%");
        }
    }

    @Override
    public int getBrightness() {
        return brightness;
    }
}

/**
 * 스마트 온도조절기
 */
class SmartThermostat implements PowerControllable, SchedulableDevice,
                                VoiceControllable, TemperatureControllable,
                                RemoteMonitorable {
    private String deviceName;
    private boolean poweredOn;
    private int currentTemperature;
    private int targetTemperature;
    private java.util.Map<String, String> schedules = new java.util.HashMap<>();

    public SmartThermostat(String deviceName) {
        this.deviceName = deviceName;
        this.poweredOn = false;
        this.currentTemperature = 20;
        this.targetTemperature = 22;
    }

    @Override
    public void connect() {
        System.out.println("[" + deviceName + "] 연결됨 🌡️");
    }

    @Override
    public void disconnect() {
        System.out.println("[" + deviceName + "] 연결 해제");
    }

    @Override
    public String getDeviceName() {
        return deviceName;
    }

    @Override
    public String getDeviceStatus() {
        return poweredOn ? "작동 중 (현재: " + currentTemperature + "°C, 목표: " +
                          targetTemperature + "°C)" : "꺼짐";
    }

    @Override
    public void turnOn() {
        poweredOn = true;
        System.out.println("[" + deviceName + "] 에어컨 켜짐");
        System.out.println("  목표 온도: " + targetTemperature + "°C");
    }

    @Override
    public void turnOff() {
        poweredOn = false;
        System.out.println("[" + deviceName + "] 에어컨 꺼짐");
    }

    @Override
    public boolean isPoweredOn() {
        return poweredOn;
    }

    @Override
    public void setSchedule(String time, String action) {
        String scheduleId = "SCH-" + System.currentTimeMillis();
        schedules.put(scheduleId, time + " : " + action);
        System.out.println("[" + deviceName + "] 스케줄 설정: " + time + " - " + action);
    }

    @Override
    public void removeSchedule(String scheduleId) {
        schedules.remove(scheduleId);
    }

    @Override
    public void listSchedules() {
        System.out.println("[" + deviceName + "] 설정된 스케줄:");
        schedules.forEach((id, schedule) ->
            System.out.println("  " + id + ": " + schedule));
    }

    @Override
    public void processVoiceCommand(String command) {
        System.out.println("[" + deviceName + "] 음성 명령: \"" + command + "\"");

        if (command.contains("켜")) {
            turnOn();
        } else if (command.contains("꺼")) {
            turnOff();
        } else if (command.contains("온도")) {
            // "온도 25도로 설정해줘" 같은 명령 처리
            System.out.println("  온도 조절 명령 인식");
        }
    }

    @Override
    public String[] getSupportedVoiceCommands() {
        return new String[]{
            "에어컨 켜줘", "에어컨 꺼줘", "온도 높여줘", "온도 낮춰줘"
        };
    }

    @Override
    public void setTemperature(int celsius) {
        this.targetTemperature = celsius;
        System.out.println("[" + deviceName + "] 목표 온도 설정: " + celsius + "°C");

        if (poweredOn) {
            // 온도 조절 시뮬레이션
            System.out.println("  현재 온도: " + currentTemperature + "°C → " +
                             targetTemperature + "°C");
        }
    }

    @Override
    public int getCurrentTemperature() {
        return currentTemperature;
    }

    @Override
    public int getTargetTemperature() {
        return targetTemperature;
    }

    @Override
    public String getCurrentState() {
        return String.format("온도: %d°C (목표: %d°C), 전원: %s",
            currentTemperature, targetTemperature, poweredOn ? "ON" : "OFF");
    }

    @Override
    public void sendAlert(String message) {
        System.out.println("[" + deviceName + "] 알림: " + message);
    }

    @Override
    public boolean isOnline() {
        return true;
    }
}

/**
 * 스마트 보안 카메라
 */
class SecurityCamera implements Controllable, PowerControllable,
                               RemoteMonitorable, SchedulableDevice {
    private String deviceName;
    private boolean poweredOn;
    private boolean recording;
    private java.util.Map<String, String> schedules = new java.util.HashMap<>();

    public SecurityCamera(String deviceName) {
        this.deviceName = deviceName;
        this.poweredOn = false;
        this.recording = false;
    }

    @Override
    public void connect() {
        System.out.println("[" + deviceName + "] 카메라 연결됨 📹");
    }

    @Override
    public void disconnect() {
        System.out.println("[" + deviceName + "] 카메라 연결 해제");
    }

    @Override
    public String getDeviceName() {
        return deviceName;
    }

    @Override
    public String getDeviceStatus() {
        return poweredOn ? (recording ? "녹화 중" : "대기 중") : "꺼짐";
    }

    @Override
    public void turnOn() {
        poweredOn = true;
        recording = true;
        System.out.println("[" + deviceName + "] 카메라 켜짐 및 녹화 시작 🔴");
    }

    @Override
    public void turnOff() {
        poweredOn = false;
        recording = false;
        System.out.println("[" + deviceName + "] 카메라 꺼짐");
    }

    @Override
    public boolean isPoweredOn() {
        return poweredOn;
    }

    @Override
    public String getCurrentState() {
        return "상태: " + getDeviceStatus() + ", 온라인: " + isOnline();
    }

    @Override
    public void sendAlert(String message) {
        System.out.println("[" + deviceName + "] ⚠️ 경고: " + message);
        System.out.println("  스마트폰으로 알림 전송됨");
    }

    @Override
    public boolean isOnline() {
        return poweredOn;
    }

    @Override
    public void setSchedule(String time, String action) {
        String scheduleId = "SCH-" + System.currentTimeMillis();
        schedules.put(scheduleId, time + " : " + action);
        System.out.println("[" + deviceName + "] 스케줄 설정: " + time + " - " + action);
    }

    @Override
    public void removeSchedule(String scheduleId) {
        schedules.remove(scheduleId);
    }

    @Override
    public void listSchedules() {
        System.out.println("[" + deviceName + "] 설정된 스케줄:");
        schedules.forEach((id, schedule) ->
            System.out.println("  " + id + ": " + schedule));
    }

    public void detectMotion() {
        if (poweredOn) {
            sendAlert("움직임 감지됨!");
        }
    }
}

/**
 * 스마트 도어락
 */
class SmartDoorLock implements Controllable, RemoteMonitorable, VoiceControllable {
    private String deviceName;
    private boolean locked;

    public SmartDoorLock(String deviceName) {
        this.deviceName = deviceName;
        this.locked = true;
    }

    @Override
    public void connect() {
        System.out.println("[" + deviceName + "] 도어락 연결됨 🔒");
    }

    @Override
    public void disconnect() {
        System.out.println("[" + deviceName + "] 도어락 연결 해제");
    }

    @Override
    public String getDeviceName() {
        return deviceName;
    }

    @Override
    public String getDeviceStatus() {
        return locked ? "잠김 🔒" : "열림 🔓";
    }

    public void lock() {
        locked = true;
        System.out.println("[" + deviceName + "] 문 잠금 🔒");
    }

    public void unlock() {
        locked = false;
        System.out.println("[" + deviceName + "] 문 열림 🔓");
        sendAlert("문이 열렸습니다");
    }

    @Override
    public String getCurrentState() {
        return getDeviceStatus();
    }

    @Override
    public void sendAlert(String message) {
        System.out.println("[" + deviceName + "] 알림: " + message);
    }

    @Override
    public boolean isOnline() {
        return true;
    }

    @Override
    public void processVoiceCommand(String command) {
        System.out.println("[" + deviceName + "] 음성 명령: \"" + command + "\"");

        if (command.contains("잠가") || command.contains("lock")) {
            lock();
        } else if (command.contains("열어") || command.contains("unlock")) {
            unlock();
        }
    }

    @Override
    public String[] getSupportedVoiceCommands() {
        return new String[]{"문 잠가줘", "문 열어줘"};
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 스마트 홈 기기 인터페이스 테스트
 */
public class SmartHomeInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("스마트 홈 시스템 테스트");
        System.out.println("===============================================\n");

        // 스마트 홈 기기 생성
        SmartLightBulb livingRoomLight = new SmartLightBulb("거실 전구");
        SmartThermostat thermostat = new SmartThermostat("거실 에어컨");
        SecurityCamera frontCamera = new SecurityCamera("현관 카메라");
        SmartDoorLock doorLock = new SmartDoorLock("현관 도어락");

        // 테스트 1: 스마트 전구 제어
        test1_SmartLight(livingRoomLight);

        // 테스트 2: 스마트 온도조절기
        test2_SmartThermostat(thermostat);

        // 테스트 3: 보안 카메라
        test3_SecurityCamera(frontCamera);

        // 테스트 4: 스마트 도어락
        test4_SmartDoorLock(doorLock);

        // 테스트 5: 음성 제어 (다형성)
        test5_VoiceControl(livingRoomLight, thermostat, doorLock);

        // 테스트 6: 원격 모니터링 (다형성)
        test6_RemoteMonitoring(thermostat, frontCamera, doorLock);
    }

    static void test1_SmartLight(SmartLightBulb light) {
        System.out.println("### 테스트 1: 스마트 전구 ###\n");

        light.connect();
        light.turnOn();
        light.setBrightness(50);
        System.out.println();

        // 스케줄 설정
        light.setSchedule("22:00", "전구 끄기");
        light.setSchedule("07:00", "전구 켜기");
        light.listSchedules();
        System.out.println();

        // 음성 제어
        light.processVoiceCommand("전구 어둡게 해줘");
        System.out.println();
    }

    static void test2_SmartThermostat(SmartThermostat thermostat) {
        System.out.println("### 테스트 2: 스마트 온도조절기 ###\n");

        thermostat.connect();
        thermostat.setTemperature(24);
        thermostat.turnOn();
        System.out.println();

        // 스케줄 설정
        thermostat.setSchedule("23:00", "에어컨 끄기");
        System.out.println();

        // 현재 상태 확인
        System.out.println("현재 상태: " + thermostat.getCurrentState());
        System.out.println();
    }

    static void test3_SecurityCamera(SecurityCamera camera) {
        System.out.println("### 테스트 3: 보안 카메라 ###\n");

        camera.connect();
        camera.turnOn();
        System.out.println();

        // 움직임 감지 시뮬레이션
        camera.detectMotion();
        System.out.println();

        // 스케줄 설정
        camera.setSchedule("23:00", "녹화 시작");
        camera.setSchedule("07:00", "녹화 중지");
        System.out.println();
    }

    static void test4_SmartDoorLock(SmartDoorLock lock) {
        System.out.println("### 테스트 4: 스마트 도어락 ###\n");

        lock.connect();
        lock.unlock();
        System.out.println();

        // 음성 제어
        lock.processVoiceCommand("문 잠가줘");
        System.out.println();
    }

    static void test5_VoiceControl(VoiceControllable... devices) {
        System.out.println("### 테스트 5: 통합 음성 제어 ###\n");

        for (VoiceControllable device : devices) {
            if (device instanceof Controllable) {
                Controllable controllable = (Controllable) device;
                System.out.println("기기: " + controllable.getDeviceName());
            }

            System.out.println("지원 명령어:");
            for (String command : device.getSupportedVoiceCommands()) {
                System.out.println("  - " + command);
            }
            System.out.println();
        }
    }

    static void test6_RemoteMonitoring(RemoteMonitorable... devices) {
        System.out.println("### 테스트 6: 원격 모니터링 대시보드 ###\n");

        for (RemoteMonitorable device : devices) {
            if (device instanceof Controllable) {
                Controllable controllable = (Controllable) device;
                System.out.println("----------------------------------------");
                System.out.println("기기: " + controllable.getDeviceName());
                System.out.println("온라인: " + (device.isOnline() ? "✓" : "✗"));
                System.out.println("상태: " + device.getCurrentState());
                System.out.println();
            }
        }
    }
}
```

### 🎯 핵심 포인트

1. **모듈화된 기능**
   - 각 인터페이스가 하나의 명확한 기능을 담당
   - `PowerControllable`: 전원 제어
   - `VoiceControllable`: 음성 제어
   - `SchedulableDevice`: 스케줄 관리
   - `RemoteMonitorable`: 원격 모니터링

2. **유연한 조합**
   - 스마트 전구: 전원 + 음성 + 스케줄 + 밝기 조절
   - 온도조절기: 전원 + 음성 + 스케줄 + 온도 제어 + 원격 모니터링
   - 보안 카메라: 전원 + 스케줄 + 원격 모니터링
   - 도어락: 음성 + 원격 모니터링

3. **실제 IoT 시스템과 유사**
   - 실제 스마트 홈 플랫폼(Google Home, Amazon Alexa)도 유사한 구조
   - 각 기기가 필요한 기능만 선택적으로 구현
   - 통합 제어 시스템에서 모든 기기를 일관되게 관리

---

## 📚 Part 1 정리

이번 Part 1에서는 5가지 실생활 비유를 통해 인터페이스의 개념을 학습했습니다:

1. **전자기기 충전 인터페이스**: 다중 인터페이스 구현, 다형성
2. **결제 수단**: 기능별 인터페이스 분리, 선택적 구현
3. **운송 수단**: 인터페이스 상속, 계층 구조
4. **미디어 플레이어**: 계층적 인터페이스, 기능 조합
5. **스마트 홈 기기**: 모듈화, IoT 시스템 설계

### 🎯 인터페이스의 핵심 장점

- ✅ **다중 구현 가능**: 한 클래스가 여러 인터페이스를 구현
- ✅ **유연한 설계**: 필요한 기능만 선택적으로 구현
- ✅ **느슨한 결합**: 구현과 사용을 분리
- ✅ **확장성**: 기존 코드 수정 없이 새 기능 추가
- ✅ **다형성**: 인터페이스 타입으로 다양한 객체 처리

다음 Part 2에서는 실제 기업 사례와 주니어 개발자 시나리오를 통해 더 깊이 있게 인터페이스를 학습하겠습니다!
