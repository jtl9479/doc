# 섹션 22: 일일 개발 루틴

> **학습 목표**: Docker를 활용한 효율적인 일일 개발 워크플로우를 구축하고, Makefile로 반복 작업을 자동화하여 개발 생산성을 3배 향상시킨다.

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐☆☆ (3개/5개)

---

## 목차
1. [💡 왜 일일 개발 루틴이 필요한가?](#-왜-일일-개발-루틴이-필요한가)
2. [🔍 실생활 비유로 이해하기](#-실생활-비유로-이해하기)
3. [아침: 개발 환경 시작](#아침-개발-환경-시작)
4. [개발 중: 모니터링과 디버깅](#개발-중-모니터링과-디버깅)
5. [코드 변경 시: 재빌드 전략](#코드-변경-시-재빌드-전략)
6. [점심/휴식: 리소스 관리](#점심휴식-리소스-관리)
7. [퇴근 전: 정리 및 백업](#퇴근-전-정리-및-백업)
8. [주간 유지보수](#주간-유지보수)
9. [효율적인 워크플로우 팁](#효율적인-워크플로우-팁)
10. [👨‍💻 주니어 개발자 시나리오](#-주니어-개발자-시나리오)
11. [❓ FAQ](#-faq)
12. [📝 면접 질문](#-면접-질문)

---

## 💡 왜 일일 개발 루틴이 필요한가?

### 실무 배경

**"매일 아침 30분을 Docker 환경 설정에 낭비하고, 퇴근 전 제대로 정리 안 해서 다음 날 문제가 발생합니다."**

#### ❌ 일일 루틴이 없으면 발생하는 문제

```
문제 1: 비효율적인 시작
- 증상: 매일 아침 컨테이너 시작에 10-30분 소요
- 영향: 하루 생산성의 5-10% 손실
- 비용: 개발자 1명 기준 연간 2주 분량의 시간 낭비

문제 2: 디스크 공간 부족
- 증상: 정기적인 Docker 정리 없이 디스크가 가득 참
- 영향: 빌드 실패, 시스템 느려짐
- 비용: 1시간 이상 정리 작업 + 작업 중단

문제 3: 데이터 손실 위험
- 증상: 퇴근 전 백업 없이 컨테이너 삭제
- 영향: 개발 데이터 손실, 작업 반복
- 비용: 1-2일 분량의 작업 재수행
```

#### ✅ 일일 루틴을 익히면

```
해결책 1: 자동화된 시작
- 방법: Makefile 명령어 1개로 완전한 환경 구성
- 효과: 시작 시간 30분 → 2분 (93% 단축)
- 절감: 연간 약 50시간 절약

해결책 2: 체계적인 리소스 관리
- 방법: 자동 정리 스크립트 + cron 작업
- 효과: 디스크 사용량 80% → 30% (안정적 유지)
- 절감: 디스크 정리 시간 제로화

해결책 3: 안전한 데이터 관리
- 방법: 자동 백업 + Git hooks
- 효과: 데이터 손실 위험 제로
- 절감: 작업 반복 제로, 스트레스 감소
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 일일 시작 시간 | 30분 | 2분 | **93%↓** |
| 디스크 사용량 | 80GB | 25GB | **69%↓** |
| 환경 문제 발생률 | 주 5회 | 월 1회 | **95%↓** |
| 데이터 손실 사고 | 월 2회 | 0회 | **100%↓** |
| 개발 생산성 | 100% | 300% | **200%↑** |

---

## 🔍 실생활 비유로 이해하기

### 비유 1: 주방의 미장센

```
레스토랑 주방장의 하루:

[오전 준비 - Mise en place]
- 칼 갈기 (Docker 업데이트)
- 재료 준비 (이미지 Pull)
- 조리 도구 배치 (컨테이너 시작)
→ 준비된 주방 = 빠른 조리

[Docker 개발 환경]
- 아침에 make morning 실행
- 모든 서비스가 준비된 상태
→ 준비된 환경 = 빠른 개발

[핵심 포인트]
제대로 된 준비 없이 요리하면 혼란스럽듯이,
준비되지 않은 개발 환경에서는 생산성이 떨어집니다.
```

### 비유 2: 자동차의 시동과 정비

```
자동차 관리:

[시동]
- 엔진 예열 (서비스 시작)
- 계기판 확인 (헬스체크)
→ 안전한 출발

[정비]
- 주유 (리소스 확보)
- 세차 (정리)
- 정기 점검 (주간 유지보수)
→ 오래 사용 가능

[Docker 루틴]
- 아침에 자동 시작
- 실시간 모니터링
- 정기적인 정리
→ 안정적인 개발 환경
```

### 비유 3: 공장의 생산 라인

```
공장 운영:

[교대 시작]
- 기계 점검 (컨테이너 상태 확인)
- 원자재 확인 (데이터베이스 상태)
- 안전 점검 (보안 설정)

[교대 종료]
- 기계 정리 (컨테이너 정지)
- 작업 기록 (로그 백업)
- 재고 정리 (리소스 정리)

[Docker 루틴]
정해진 절차를 따르면 사고 없이 효율적으로 운영됩니다.
```

---

## 아침: 개발 환경 시작

### 빠른 시작 루틴

```bash
#!/bin/bash
# scripts/morning-start.sh

echo "☀️ 좋은 아침입니다! 개발 환경을 시작합니다..."

# 1. Git 최신 상태 확인
echo "📥 Git Pull..."
git pull origin develop

# 2. 환경 변수 확인
if [ ! -f .env.dev ]; then
    echo "❌ .env.dev 파일이 없습니다!"
    exit 1
fi

# 3. Docker 상태 확인
echo "🐳 Docker 상태 확인..."
if ! docker info > /dev/null 2>&1; then
    echo "❌ Docker가 실행 중이 아닙니다."
    echo "Docker Desktop을 시작하세요."
    exit 1
fi

# 4. 불필요한 컨테이너 정리
echo "🧹 이전 컨테이너 정리..."
docker-compose down

# 5. 최신 이미지 확인 (선택사항)
read -p "이미지를 pull 하시겠습니까? (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "📦 이미지 Pull..."
    docker-compose pull
fi

# 6. 개발 환경 시작
echo "🚀 개발 환경 시작..."
docker-compose -f docker-compose.dev.yml up -d

# 7. 서비스 준비 대기
echo "⏳ 서비스 준비 중..."
sleep 15

# 8. 헬스체크
echo "🏥 헬스체크..."
SERVICES=("user-service:8081" "account-service:8082" "trade-service:8083")
ALL_HEALTHY=true

for service_port in "${SERVICES[@]}"; do
    IFS=':' read -r service port <<< "$service_port"

    if curl -f http://localhost:$port/actuator/health > /dev/null 2>&1; then
        echo "  ✅ $service"
    else
        echo "  ❌ $service (포트 $port 응답 없음)"
        ALL_HEALTHY=false
    fi
done

# 9. 결과 출력
echo ""
if [ "$ALL_HEALTHY" = true ]; then
    echo "✅ 모든 서비스가 정상 작동 중입니다!"
    echo ""
    echo "📋 개발 환경 정보:"
    echo "  - User Service:    http://localhost:8081"
    echo "  - Account Service: http://localhost:8082"
    echo "  - Trade Service:   http://localhost:8083"
    echo "  - AI Service:      http://localhost:8084"
    echo "  - Scraper Service: http://localhost:8085"
    echo "  - pgAdmin:         http://localhost:5050"
    echo "  - Redis Commander: http://localhost:8090"
    echo ""
    echo "💡 유용한 명령어:"
    echo "  - 로그 확인: docker-compose logs -f"
    echo "  - 재시작:   docker-compose restart <service>"
    echo "  - 중지:     docker-compose stop"
else
    echo "⚠️  일부 서비스에 문제가 있습니다."
    echo "로그를 확인하세요: docker-compose logs"
fi
```

### 선택적 시작 (Makefile)

```makefile
# Makefile

.PHONY: morning morning-full morning-minimal

# 기본 시작 (백엔드만)
morning:
	@echo "☀️ 개발 환경 시작 (백엔드만)..."
	@git pull origin develop
	@docker-compose down
	@docker-compose -f docker-compose.dev.yml up -d postgres redis user-service
	@sleep 10
	@make health-check

# 전체 시작 (프론트엔드 포함)
morning-full:
	@echo "☀️ 전체 개발 환경 시작..."
	@git pull origin develop
	@docker-compose down
	@docker-compose -f docker-compose.dev.yml --profile tools up -d
	@sleep 15
	@make health-check

# 최소 시작 (DB만)
morning-minimal:
	@echo "☀️ 최소 환경 시작 (DB만)..."
	@docker-compose -f docker-compose.dev.yml up -d postgres redis
	@sleep 5
	@echo "✅ 데이터베이스 준비 완료"

health-check:
	@echo "🏥 헬스체크 중..."
	@curl -f http://localhost:8081/actuator/health && echo "  ✅ User Service" || echo "  ❌ User Service"
```

### VSCode 자동 시작 설정

```json
// .vscode/tasks.json

{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Start Dev Environment",
      "type": "shell",
      "command": "make morning",
      "problemMatcher": [],
      "presentation": {
        "reveal": "always",
        "panel": "new"
      },
      "runOptions": {
        "runOn": "folderOpen"  // 폴더 열 때 자동 실행
      }
    }
  ]
}
```

---

## 개발 중: 모니터링과 디버깅

### 실시간 로그 모니터링

```bash
# 모든 서비스 로그 (tmux/screen 사용)
docker-compose logs -f

# 특정 서비스만
docker-compose logs -f user-service

# 여러 서비스
docker-compose logs -f user-service account-service

# 컬러 로그 (grc 사용)
grc docker-compose logs -f

# 에러만 필터링
docker-compose logs -f | grep -i error
```

### 터미널 멀티플렉서 설정

```bash
#!/bin/bash
# scripts/dev-tmux.sh

# tmux 세션 생성
tmux new-session -d -s dev

# 윈도우 1: 로그 모니터링
tmux rename-window -t dev:0 'logs'
tmux send-keys -t dev:0 'docker-compose logs -f user-service' C-m

# 윈도우 2: 데이터베이스
tmux new-window -t dev:1 -n 'db'
tmux send-keys -t dev:1 'docker-compose exec postgres psql -U lkuser -d lktrade_dev' C-m

# 윈도우 3: Redis
tmux new-window -t dev:2 -n 'redis'
tmux send-keys -t dev:2 'docker-compose exec redis redis-cli' C-m

# 윈도우 4: 개발 셸
tmux new-window -t dev:3 -n 'dev'

# tmux 세션 연결
tmux attach-session -t dev
```

### 개발 대시보드 (lazydocker)

```bash
# lazydocker 실행
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v ~/.config/lazydocker:/.config/jesseduffield/lazydocker \
    lazyteam/lazydocker

# 단축키:
# - [↑/↓]: 탐색
# - [l]: 로그 보기
# - [r]: 재시작
# - [s]: 중지
# - [e]: 셸 진입
# - [x]: 삭제
```

### 리소스 사용량 모니터링

```bash
#!/bin/bash
# scripts/monitor-resources.sh

watch -n 2 'docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"'

# 또는 ctop 사용
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    quay.io/vektorlab/ctop:latest
```

---

## 코드 변경 시: 재빌드 전략

### 핫 리로드 활용 (변경 즉시 반영)

**Spring Boot DevTools (자동 재시작)**:

```yaml
# docker-compose.dev.yml

services:
  user-service:
    build:
      context: ./modules/user
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/user/api/src:/app/api/src:cached  # 소스 코드 마운트
    environment:
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
    # 코드 변경 → 자동 재시작 (5초 이내)
```

**Node.js nodemon (자동 재시작)**:

```yaml
services:
  backend:
    command: nodemon --watch src src/index.js
    volumes:
      - ./src:/app/src:cached
    # 코드 변경 → 즉시 재시작
```

### 수동 재빌드가 필요한 경우

**1. 의존성 변경 (package.json, build.gradle.kts)**:

```bash
# 이미지 재빌드
docker-compose build user-service

# 컨테이너 재시작
docker-compose up -d user-service

# 또는 한 번에
docker-compose up -d --build user-service
```

**2. Dockerfile 변경**:

```bash
# 캐시 없이 재빌드 (완전 재빌드)
docker-compose build --no-cache user-service
docker-compose up -d user-service
```

**3. 환경 변수 변경 (.env)**:

```bash
# 컨테이너 재생성 (재빌드 불필요)
docker-compose up -d --force-recreate user-service
```

### 빠른 재빌드 스크립트

```bash
#!/bin/bash
# scripts/quick-rebuild.sh

SERVICE=$1

if [ -z "$SERVICE" ]; then
    echo "Usage: ./quick-rebuild.sh <service-name>"
    echo "Example: ./quick-rebuild.sh user-service"
    exit 1
fi

echo "🔨 $SERVICE 재빌드 중..."

# 1. 서비스 중지
docker-compose stop $SERVICE

# 2. 이미지 재빌드 (캐시 활용)
docker-compose build $SERVICE

# 3. 서비스 시작
docker-compose up -d $SERVICE

# 4. 로그 확인
echo "📋 로그:"
docker-compose logs -f --tail 50 $SERVICE
```

### Makefile로 간편하게

```makefile
# Makefile

.PHONY: rebuild restart rebuild-all

# 특정 서비스 재빌드
rebuild:
	@read -p "서비스 이름: " service; \
	docker-compose build $$service && \
	docker-compose up -d $$service && \
	docker-compose logs -f $$service

# 특정 서비스 재시작 (재빌드 없이)
restart:
	@read -p "서비스 이름: " service; \
	docker-compose restart $$service && \
	docker-compose logs -f $$service

# 전체 재빌드
rebuild-all:
	@echo "🔨 전체 재빌드 중..."
	@docker-compose build
	@docker-compose up -d
	@echo "✅ 재빌드 완료"

# 빠른 재시작 (주로 사용)
rr:
	@docker-compose restart user-service
	@docker-compose logs -f --tail 50 user-service
```

---

## 점심/휴식: 리소스 관리

### 일시 정지 (리소스 절약)

```bash
# 모든 컨테이너 일시 정지
docker-compose pause

# 특정 컨테이너만 일시 정지
docker-compose pause user-service account-service

# 재개
docker-compose unpause

# 완전 중지 (더 많은 리소스 절약)
docker-compose stop
```

### 리소스 자동 정리 스크립트

```bash
#!/bin/bash
# scripts/lunch-cleanup.sh

echo "🍱 점심시간 리소스 정리..."

# 1. 개발 서비스 일시 정지 (DB는 유지)
docker-compose pause user-service account-service trade-service ai-service scraper-service

# 2. 불필요한 이미지 정리
docker image prune -f

# 3. 중지된 컨테이너 정리
docker container prune -f

# 4. 로그 정리
for container in $(docker ps -a -q); do
    docker logs $container --tail 0 > /dev/null 2>&1
done

# 5. 디스크 사용량 확인
echo ""
echo "💾 Docker 디스크 사용량:"
docker system df

echo ""
echo "✅ 정리 완료! 즐거운 점심시간 되세요 🍴"
```

### cron으로 자동 정리

```bash
# crontab -e

# 매일 점심시간(12:00)에 자동 정리
0 12 * * * cd /path/to/project && ./scripts/lunch-cleanup.sh

# 매주 금요일 퇴근 전(17:00) 전체 정리
0 17 * * 5 cd /path/to/project && docker system prune -af
```

---

## 퇴근 전: 정리 및 백업

### 퇴근 루틴

```bash
#!/bin/bash
# scripts/evening-cleanup.sh

echo "🌙 퇴근 전 정리 시작..."

# 1. Git 상태 확인
echo "📝 Git 상태:"
git status

# 2. 커밋되지 않은 변경사항 확인
if ! git diff-index --quiet HEAD --; then
    echo "⚠️  커밋되지 않은 변경사항이 있습니다!"
    read -p "계속하시겠습니까? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 0
    fi
fi

# 3. 로그 백업 (선택사항)
read -p "로그를 백업하시겠습니까? (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "📋 로그 백업 중..."
    mkdir -p ./logs/$(date +%Y%m%d)

    for service in user-service account-service trade-service; do
        docker-compose logs --no-color $service > ./logs/$(date +%Y%m%d)/${service}.log
    done

    echo "✅ 로그 백업 완료: ./logs/$(date +%Y%m%d)/"
fi

# 4. 데이터베이스 백업 (선택사항)
read -p "데이터베이스를 백업하시겠습니까? (y/N) " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "🗄️ 데이터베이스 백업 중..."
    docker-compose exec -T postgres pg_dump -U lkuser lktrade_dev > ./backup/db_$(date +%Y%m%d_%H%M%S).sql
    echo "✅ 백업 완료: ./backup/db_$(date +%Y%m%d_%H%M%S).sql"
fi

# 5. 컨테이너 중지 선택
echo ""
echo "컨테이너를 어떻게 하시겠습니까?"
echo "  1) 모두 중지 (메모리 완전 해제)"
echo "  2) 일시 정지 (빠른 재시작 가능)"
echo "  3) 실행 유지 (내일 바로 시작)"
read -p "선택 (1-3): " -n 1 -r
echo

case $REPLY in
    1)
        echo "🛑 모든 컨테이너 중지..."
        docker-compose down
        ;;
    2)
        echo "⏸️  컨테이너 일시 정지..."
        docker-compose pause
        ;;
    3)
        echo "▶️  컨테이너 실행 유지"
        ;;
    *)
        echo "❌ 잘못된 선택. 실행 유지합니다."
        ;;
esac

# 6. 정리
echo ""
echo "🧹 불필요한 리소스 정리..."
docker system prune -f

# 7. 리소스 사용량 확인
echo ""
echo "💾 Docker 디스크 사용량:"
docker system df

echo ""
echo "✅ 정리 완료! 내일 봐요 👋"
```

### 자동 백업 설정

```bash
#!/bin/bash
# scripts/auto-backup.sh

BACKUP_DIR="./backup"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

# 데이터베이스 백업
docker-compose exec -T postgres pg_dump -U lkuser lktrade_dev | gzip > $BACKUP_DIR/db_$DATE.sql.gz

# 볼륨 백업
docker run --rm -v lk-trade_postgres-data:/data -v $BACKUP_DIR:/backup \
    alpine tar czf /backup/postgres-data_$DATE.tar.gz -C /data .

# 오래된 백업 삭제 (7일 이상)
find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete

echo "✅ 백업 완료: $DATE"
```

---

## 주간 유지보수

### 월요일: 이미지 업데이트

```bash
#!/bin/bash
# scripts/weekly-update.sh

echo "🔄 주간 업데이트 시작..."

# 1. Git 최신화
git pull origin develop

# 2. 베이스 이미지 업데이트
docker-compose pull postgres redis

# 3. 개발 이미지 재빌드
docker-compose build --pull

# 4. 재시작
docker-compose down
docker-compose up -d

# 5. 헬스체크
sleep 20
make health-check

echo "✅ 업데이트 완료!"
```

### 금요일: 전체 정리

```bash
#!/bin/bash
# scripts/friday-cleanup.sh

echo "🧹 주간 대청소..."

# 1. 모든 컨테이너 중지
docker-compose down -v

# 2. 미사용 리소스 정리
docker system prune -af --volumes

# 3. 빌드 캐시 정리
docker builder prune -af

# 4. 디스크 사용량 확인
echo ""
echo "💾 정리 후 디스크 사용량:"
docker system df

# 5. 다음 주 준비
echo ""
echo "📦 다음 주를 위한 이미지 다운로드..."
docker-compose pull

echo ""
echo "✅ 대청소 완료! 즐거운 주말 보내세요 🎉"
```

---

## 효율적인 워크플로우 팁

### 1. 쉘 Alias 설정

```bash
# ~/.bashrc 또는 ~/.zshrc

# Docker Compose 단축어
alias dc='docker-compose'
alias dcu='docker-compose up -d'
alias dcd='docker-compose down'
alias dcl='docker-compose logs -f'
alias dcr='docker-compose restart'
alias dce='docker-compose exec'

# 자주 사용하는 명령어
alias dcup='docker-compose -f docker-compose.dev.yml up -d'
alias dcdown='docker-compose -f docker-compose.dev.yml down'

# LK-Trade 프로젝트 전용
alias lk-start='cd ~/projects/lk-trade && make morning'
alias lk-logs='cd ~/projects/lk-trade && dc logs -f user-service'
alias lk-db='cd ~/projects/lk-trade && dc exec postgres psql -U lkuser -d lktrade_dev'
```

### 2. 커스텀 명령어 (functions)

```bash
# ~/.bashrc

# 서비스별 로그 보기
dclogs() {
    if [ -z "$1" ]; then
        docker-compose logs -f
    else
        docker-compose logs -f "$1"
    fi
}

# 서비스 재시작 + 로그
dcrestart() {
    if [ -z "$1" ]; then
        echo "Usage: dcrestart <service-name>"
        return 1
    fi
    docker-compose restart "$1"
    docker-compose logs -f --tail 50 "$1"
}

# 컨테이너 셸 진입
dcsh() {
    if [ -z "$1" ]; then
        echo "Usage: dcsh <service-name>"
        return 1
    fi
    docker-compose exec "$1" sh
}
```

### 3. Git Hooks 활용

```bash
#!/bin/bash
# .git/hooks/post-merge

# Pull 후 자동으로 컨테이너 재시작

echo "🔄 코드 업데이트 감지. 컨테이너 재시작 중..."

# 의존성 변경 확인
if git diff HEAD@{1} HEAD --name-only | grep -E "package.json|build.gradle.kts"; then
    echo "📦 의존성 변경 감지. 이미지 재빌드..."
    docker-compose build
fi

# 컨테이너 재시작
docker-compose up -d

echo "✅ 재시작 완료!"
```

### 4. 개발 체크리스트

```markdown
## 일일 개발 체크리스트

### 시작 (9:00)
- [ ] Git Pull
- [ ] 개발 환경 시작 (`make morning`)
- [ ] 헬스체크 확인
- [ ] 어제 작업 내용 확인

### 개발 중
- [ ] 로그 모니터링 (에러 확인)
- [ ] 리소스 사용량 확인 (1시간마다)
- [ ] 코드 변경 후 동작 확인
- [ ] 테스트 작성 및 실행

### 점심 (12:00-13:00)
- [ ] 작업 중인 내용 커밋
- [ ] 컨테이너 일시 정지 (선택)

### 퇴근 전 (18:00)
- [ ] Git 커밋 및 푸시
- [ ] 로그 백업 (필요시)
- [ ] 컨테이너 정리
- [ ] 내일 할 일 정리

### 주간 (금요일)
- [ ] 전체 리소스 정리
- [ ] 이미지 업데이트
- [ ] 주간 회고
```

### 5. 모니터링 대시보드

```bash
#!/bin/bash
# scripts/dashboard.sh

# tmux 대시보드 생성

tmux new-session -d -s dashboard

# 상단: 리소스 모니터링
tmux send-keys -t dashboard 'docker stats' C-m

# 하단 왼쪽: 로그
tmux split-window -v -t dashboard
tmux send-keys -t dashboard 'docker-compose logs -f user-service' C-m

# 하단 오른쪽: 명령어 입력
tmux split-window -h -t dashboard

tmux attach-session -t dashboard
```

### 6. VSCode 통합

```json
// .vscode/settings.json

{
  "docker.explorerRefreshInterval": 1000,
  "docker.showExplorer": true,

  // 작업 공간 자동 명령어
  "emeraldwalk.runonsave": {
    "commands": [
      {
        "match": ".*\\.kt$",
        "cmd": "echo 'Kotlin 파일 변경 감지. DevTools가 자동 재시작합니다.'"
      }
    ]
  }
}
```

```json
// .vscode/launch.json

{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach to User Service",
      "type": "kotlin",
      "request": "attach",
      "hostName": "localhost",
      "port": 5005,
      "timeout": 30000
    }
  ]
}
```

---

## 👨‍💻 주니어 개발자 시나리오

### 시나리오 1: 첫 출근 - 개발 환경 세팅

**상황**:
```
주니어: "팀장님, 오늘 첫 출근인데 개발 환경은 어떻게 세팅하나요?"
팀장: "README의 'Quick Start' 보고 make morning 실행해보세요."
주니어: "명령어 하나면 되나요? 이전 회사는 하루 종일 걸렸는데..."
```

**단계별 해결**:
```bash
# Step 1: 저장소 클론
$ git clone https://github.com/company/lk-trade.git
$ cd lk-trade

# Step 2: 환경 변수 복사
$ cp .env.example .env.dev
$ vi .env.dev  # 필요한 값 입력

# Step 3: 한 방에 시작!
$ make morning

# 출력:
☀️ 개발 환경 시작 (백엔드만)...
Already up to date.
✅ User Service
✅ Account Service
✅ PostgreSQL
✅ Redis
모든 서비스가 정상 작동 중입니다!

✅ 해결!
```

**배운 점**:
- Makefile로 복잡한 시작 과정을 단순화할 수 있다
- 팀 전체가 동일한 환경에서 시작할 수 있다
- 문서화와 자동화의 중요성

---

### 시나리오 2: 디스크 용량 부족 에러

**상황**:
```
주니어: "어? 갑자기 빌드가 안 돼요. 'No space left on device' 에러가 나요."
시니어: "Docker 정리 언제 마지막으로 했어요?"
주니어: "한 번도 안 했는데... 그것도 해야 하나요?"
시니어: "디스크 사용량 확인해보세요."
```

**단계별 해결**:
```bash
# Step 1: 디스크 사용량 확인
$ docker system df

# 출력:
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          45        12        28.5GB    15.2GB (53%)
Containers      15        8         2.1GB     1.8GB (85%)
Local Volumes   10        3         18.3GB    10.1GB (55%)
Build Cache     120       0         35.7GB    35.7GB (100%)

# Step 2: 불필요한 리소스 정리
$ docker system prune -af --volumes

# Step 3: 결과 확인
$ docker system df

# 출력:
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          12        12        13.3GB    0B (0%)
Containers      8         8         0.3GB     0B (0%)
Local Volumes   3         3         8.2GB     0B (0%)
Build Cache     0         0         0B        0B

✅ 해결! 80GB에서 22GB로 감소 (72% 절감)
```

**배운 점**:
- Docker 정리를 정기적으로 해야 한다
- 빌드 캐시가 가장 많은 공간을 차지한다
- 주간 정리 스크립트를 cron으로 등록하는 것이 좋다

---

### 시나리오 3: 코드 변경이 반영 안 됨

**상황**:
```
주니어: "UserService 코드를 수정했는데 변경이 반영이 안 돼요."
시니어: "핫 리로드가 켜져 있나요? 컨테이너 재시작은 해봤어요?"
주니어: "핫 리로드요? 그게 뭔가요?"
```

**단계별 해결**:
```bash
# Step 1: 현재 설정 확인
$ docker-compose exec user-service env | grep DEVTOOLS
# SPRING_DEVTOOLS_RESTART_ENABLED=false  ← 문제!

# Step 2: docker-compose.dev.yml 수정
$ vi docker-compose.dev.yml

services:
  user-service:
    environment:
      - SPRING_DEVTOOLS_RESTART_ENABLED=true  # 활성화

# Step 3: 컨테이너 재시작
$ docker-compose up -d user-service

# Step 4: 테스트
$ echo "println('test')" >> src/main/kotlin/UserService.kt
# 3초 후 자동 재시작!

# Step 5: 재빌드가 필요한 경우 (의존성 변경)
$ make rebuild
# 서비스 이름: user-service

✅ 해결!
```

**배운 점**:
- Spring DevTools로 핫 리로드 가능
- 코드 변경과 의존성 변경은 다르게 처리
- 개발 환경과 프로덕션 환경 설정을 분리

---

### 시나리오 4: 퇴근 시간, 작업 중인 데이터 보존

**상황**:
```
주니어: "퇴근 시간인데 테스트 데이터를 내일도 써야 하는데..."
주니어: "컨테이너 내리면 데이터 다 사라지는 거 아닌가요?"
시니어: "볼륨 마운트 되어 있으면 괜찮아요. 백업도 해두세요."
```

**단계별 해결**:
```bash
# Step 1: 볼륨 상태 확인
$ docker volume ls | grep postgres
# lk-trade_postgres-data

# Step 2: 백업 (안전하게)
$ docker-compose exec -T postgres pg_dump -U lkuser lktrade_dev > backup_$(date +%Y%m%d).sql
# backup_20250930.sql 생성됨

# Step 3: 컨테이너 중지 옵션 선택
$ ./scripts/evening-cleanup.sh

# 1) 모두 중지    → 메모리 완전 해제, 내일 시작 조금 느림
# 2) 일시 정지    → 메모리 유지, 내일 빠른 시작
# 3) 실행 유지    → 메모리 사용, 내일 즉시 시작

# 선택: 2 (일시 정지)

# Step 4: 다음 날 아침
$ docker-compose unpause
# 2초 만에 준비 완료!

✅ 해결!
```

**배운 점**:
- Docker 볼륨으로 데이터 영구 보존
- 정기 백업의 중요성
- 상황에 맞는 중지 방법 선택

---

## ❓ FAQ

<details>
<summary><strong>Q1: make morning이 실패합니다. 어떻게 디버그하나요?</strong></summary>

**A**: 단계별로 나누어 확인하세요.

**상세 설명**:
```bash
# 1. Docker 데몬 상태 확인
docker info

# 2. 이전 컨테이너 완전 정리
docker-compose down -v

# 3. 로그 상세 모드로 시작
docker-compose -f docker-compose.dev.yml up

# 4. 특정 서비스만 시작하여 격리 테스트
docker-compose up -d postgres
docker-compose logs -f postgres

# 5. 포트 충돌 확인
sudo lsof -i :5432  # PostgreSQL 포트
sudo lsof -i :8081  # User Service 포트
```

**Best Practice**:
> 항상 로그를 먼저 확인하세요. `docker-compose logs` 명령어는 대부분의 문제 원인을 알려줍니다.

</details>

<details>
<summary><strong>Q2: 핫 리로드가 작동하지 않습니다.</strong></summary>

**A**: 플랫폼별 해결책이 다릅니다.

**상세 설명**:

**Mac/Windows (Docker Desktop)**:
```yaml
# docker-compose.dev.yml
volumes:
  - ./src:/app/src:cached  # :cached 옵션 추가
```

**Node.js**:
```json
// nodemon.json
{
  "legacyWatch": true,
  "polling": true,
  "pollingInterval": 1000
}
```

**Spring Boot**:
```yaml
environment:
  - SPRING_DEVTOOLS_RESTART_ENABLED=true
  - SPRING_DEVTOOLS_RESTART_POLL_INTERVAL=2s
  - SPRING_DEVTOOLS_RESTART_QUIET_PERIOD=1s
```

| 플랫폼 | 해결책 | 성능 |
|--------|--------|------|
| Mac | :cached 옵션 | 중간 |
| Windows | :delegated 옵션 | 느림 |
| Linux | 옵션 불필요 | 빠름 |

**Best Practice**:
> 개발 환경은 Linux를 추천합니다. WSL2 사용 시 네이티브 Linux 성능을 얻을 수 있습니다.

</details>

<details>
<summary><strong>Q3: 매일 아침 이미지 Pull이 필요한가요?</strong></summary>

**A**: 필요하지 않습니다. 선택적으로 하세요.

**상세 설명**:
```bash
# 매일 Pull (권장하지 않음)
docker-compose pull  # 불필요한 시간 낭비

# 주간 Pull (권장)
# Makefile
.PHONY: weekly-update
weekly-update:
    git pull origin develop
    docker-compose pull
    docker-compose build --pull
    docker-compose up -d

# 사용
make weekly-update  # 월요일 아침에만 실행
```

**가이드라인**:
- **매일**: `make morning` (Pull 없이 시작)
- **주간**: `make weekly-update` (이미지 업데이트)
- **긴급**: `docker-compose pull <service>` (특정 서비스만)

**Best Practice**:
> CI/CD에서 이미지를 자동으로 빌드하고 태그를 관리하세요. 로컬에서는 안정된 버전만 사용합니다.

</details>

<details>
<summary><strong>Q4: 여러 프로젝트를 동시에 개발할 때 포트 충돌을 어떻게 해결하나요?</strong></summary>

**A**: 프로젝트별 포트 범위를 정의하세요.

**상세 설명**:
```bash
# 프로젝트별 포트 범위
# LK-Trade: 8080-8099
# Project-A: 8100-8119
# Project-B: 8120-8139

# .env.dev (LK-Trade)
USER_SERVICE_PORT=8081
ACCOUNT_SERVICE_PORT=8082
POSTGRES_PORT=5432

# .env.dev (Project-A)
USER_SERVICE_PORT=8101
ACCOUNT_SERVICE_PORT=8102
POSTGRES_PORT=5433  # 다른 포트

# docker-compose.dev.yml
services:
  user-service:
    ports:
      - "${USER_SERVICE_PORT}:8080"

  postgres:
    ports:
      - "${POSTGRES_PORT}:5432"
```

**Makefile로 프로젝트 전환**:
```makefile
.PHONY: switch-project
switch-project:
    @echo "현재 프로젝트를 중지합니다..."
    @docker-compose down
    @echo "프로젝트를 선택하세요:"
    @echo "  1) LK-Trade"
    @echo "  2) Project-A"
    @read -p "선택 (1-2): " choice; \
    case $$choice in \
        1) cd ~/projects/lk-trade && make morning ;; \
        2) cd ~/projects/project-a && make morning ;; \
    esac
```

**Best Practice**:
> 각 프로젝트의 포트를 문서화하고, 팀 전체가 동일한 포트 규칙을 따르세요.

</details>

<details>
<summary><strong>Q5: 백업은 얼마나 자주 해야 하나요?</strong></summary>

**A**: 데이터의 중요도에 따라 다릅니다.

**상세 설명**:

| 데이터 유형 | 백업 주기 | 보관 기간 | 방법 |
|------------|----------|----------|------|
| 개발 DB | 매일 | 7일 | 자동 |
| 테스트 데이터 | 주간 | 4주 | 자동 |
| 설정 파일 | Git 커밋 시 | 영구 | Git |
| 로그 | 선택적 | 3일 | 수동 |

**자동 백업 설정**:
```bash
# crontab -e
# 매일 오전 9시에 백업
0 9 * * * cd /path/to/lk-trade && ./scripts/auto-backup.sh

# 매주 일요일 자정에 전체 백업
0 0 * * 0 cd /path/to/lk-trade && ./scripts/full-backup.sh
```

**복구 테스트**:
```bash
# 정기적으로 복구 테스트 (월 1회)
$ ./scripts/restore-test.sh backup_20250930.sql
✅ 복구 성공! 백업 파일이 유효합니다.
```

**Best Practice**:
> 백업만 하지 말고, 복구 테스트도 정기적으로 하세요. 복구할 수 없는 백업은 의미가 없습니다.

</details>

---

## 📝 면접 질문

### 주니어 레벨

**Q1: Docker를 사용한 개발 환경에서 일일 루틴이 왜 중요한가요?**

**A**: 효율성, 일관성, 안정성을 위해 필수적입니다.

**상세 답변**:
일일 루틴이 중요한 세 가지 이유:

1. **시간 절약**: 자동화된 시작/종료로 하루 30분 이상 절약
2. **일관성**: 팀 전체가 동일한 환경에서 작업
3. **문제 예방**: 정기적인 정리로 디스크 부족, 충돌 방지

```bash
# 루틴 없이
$ docker-compose up -d
$ docker-compose logs -f
$ # 문제 발생 → 디버깅 → 30분 소요

# 루틴 적용
$ make morning
$ # 2분 만에 완벽한 환경 준비 완료
```

**핵심 포인트**:
- 자동화는 반복 작업을 제거한다
- 정리는 문제를 예방한다
- 문서화는 팀 협업을 돕는다

---

**Q2: 핫 리로드(Hot Reload)가 무엇이고, Docker 환경에서 어떻게 설정하나요?**

**A**: 코드 변경 시 자동 재시작하는 기능입니다.

**상세 답변**:
```yaml
# docker-compose.dev.yml
services:
  backend:
    volumes:
      - ./src:/app/src:cached  # 소스 코드 마운트
    environment:
      - NODE_ENV=development
    command: nodemon --watch src src/index.js
```

**작동 원리**:
1. 호스트의 `./src` 디렉토리를 컨테이너의 `/app/src`에 마운트
2. 파일 변경 감지 → nodemon/DevTools가 감지
3. 자동 재시작 → 변경사항 즉시 반영

**플랫폼별 차이**:
- **Linux**: 파일 감시 이벤트 자동 전달
- **Mac/Windows**: polling 모드 필요 (느림)

**핵심 포인트**:
- 개발 생산성 향상의 핵심
- 의존성 변경 시에는 재빌드 필요
- 플랫폼별 설정 차이 이해

---

### 중급 레벨

**Q3: Docker 환경에서 디스크 공간 관리 전략을 설명하세요.**

**A**: 정기적인 정리와 모니터링이 핵심입니다.

**상세 답변**:

**1. 모니터링**:
```bash
# 현재 사용량 확인
$ docker system df

TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          45        12        28.5GB    15.2GB (53%)
Containers      15        8         2.1GB     1.8GB (85%)
Local Volumes   10        3         18.3GB    10.1GB (55%)
Build Cache     120       0         35.7GB    35.7GB (100%)
```

**2. 정리 전략**:
```bash
# 일일 정리 (안전)
docker container prune -f  # 중지된 컨테이너
docker image prune -f      # dangling 이미지

# 주간 정리 (공격적)
docker system prune -af --volumes  # 모두 삭제

# 선택적 정리
docker image prune -a --filter "until=24h"  # 24시간 전 이미지
docker volume prune --filter "label!=keep"  # 라벨 없는 볼륨
```

**3. 자동화**:
```bash
# crontab
0 12 * * * docker container prune -f  # 매일 점심
0 0 * * 5 docker system prune -af     # 매주 금요일
```

| 타입 | 정리 주기 | 방법 | 영향 |
|------|----------|------|------|
| 컨테이너 | 매일 | prune | 낮음 |
| 이미지 | 주간 | prune -a | 중간 |
| 볼륨 | 수동 | prune | 높음 |
| 캐시 | 주간 | builder prune | 낮음 |

**핵심 포인트**:
- 빌드 캐시가 가장 많은 공간 차지
- 볼륨 정리는 신중하게 (데이터 손실 위험)
- 자동화로 관리 부담 제거

---

**Q4: 팀 환경에서 개발 환경 일관성을 유지하는 방법은?**

**A**: Makefile과 환경 변수 관리로 일관성을 보장합니다.

**상세 답변**:

**1. Makefile 표준화**:
```makefile
# 모든 팀원이 동일한 명령어 사용
.PHONY: morning start stop restart logs clean

morning:
    @git pull origin develop
    @docker-compose down
    @docker-compose up -d
    @make health-check
```

**2. 환경 변수 템플릿**:
```bash
# .env.example (Git에 포함)
DB_HOST=postgres
DB_PORT=5432
DB_NAME=lktrade_dev
DB_USER=lkuser
DB_PASSWORD=  # 각자 설정

# .env.dev (Git 제외, 개인 설정)
DB_PASSWORD=my_secret_password
```

**3. README 문서화**:
```markdown
## Quick Start

1. 환경 변수 설정
   cp .env.example .env.dev
   vi .env.dev  # DB_PASSWORD 입력

2. 시작
   make morning

3. 확인
   http://localhost:8081/health
```

**4. Git Hooks**:
```bash
# .git/hooks/post-merge
# Pull 후 자동 업데이트
docker-compose pull
docker-compose up -d
```

**핵심 포인트**:
- Makefile은 표준 인터페이스
- .env.example로 필요한 변수 명시
- 문서화는 신입 온보딩 시간 단축

---

**Q5: 프로덕션 배포 전 개발 환경에서 확인해야 할 체크리스트는?**

**A**: 다층 검증으로 프로덕션 사고를 예방합니다.

**상세 답변**:

**1. 기능 체크리스트**:
```bash
□ 모든 테스트 통과
  - Unit Tests
  - Integration Tests
  - E2E Tests

□ 로컬 환경에서 동작 확인
  - make morning
  - 수동 테스트

□ 설정 검증
  - .env.prod 변수 확인
  - Secret 값 검증
```

**2. 성능 체크리스트**:
```bash
□ 리소스 사용량 확인
  $ docker stats
  - CPU < 80%
  - Memory < 80%

□ 로그 레벨 확인
  - 개발: DEBUG
  - 프로덕션: INFO

□ 헬스체크 응답 시간
  - < 1초
```

**3. 보안 체크리스트**:
```bash
□ 이미지 스캔
  $ trivy image lk-trade/user-service:latest
  - HIGH/CRITICAL 없음

□ Secret 관리
  - 하드코딩된 비밀번호 없음
  - 환경 변수로 관리

□ 포트 노출 최소화
  - 필요한 포트만 expose
```

**4. 문서화 체크리스트**:
```bash
□ CHANGELOG 업데이트
□ API 문서 최신화
□ 배포 가이드 검토
□ 롤백 계획 수립
```

**자동화**:
```bash
# scripts/pre-deploy-check.sh
#!/bin/bash

echo "🔍 배포 전 검증 시작..."

# 1. 테스트
./gradlew test || exit 1

# 2. 보안 스캔
trivy image lk-trade/user-service:latest || exit 1

# 3. 리소스 체크
MEMORY=$(docker stats --no-stream --format "{{.MemPerc}}" user-service | cut -d'%' -f1)
if (( $(echo "$MEMORY > 80" | bc -l) )); then
    echo "❌ 메모리 사용량이 너무 높습니다: $MEMORY%"
    exit 1
fi

echo "✅ 모든 검증 통과! 배포 가능합니다."
```

**핵심 포인트**:
- 자동화된 체크리스트로 실수 방지
- 단계별 검증으로 문제 조기 발견
- 문서화로 팀 전체가 동일한 기준 적용

---

## 트러블슈팅: 일상적인 문제들

### 문제 1: 아침에 컨테이너가 시작 안됨

```bash
# 원인: 이전 컨테이너가 비정상 종료

# 해결
docker-compose down -v  # 볼륨 포함 완전 삭제
docker-compose up -d

# 또는
docker system prune -f
docker-compose up -d
```

### 문제 2: 핫 리로드가 작동 안함

```bash
# 원인: 파일 감시 설정 문제

# 해결 (Mac/Windows)
# docker-compose.yml
volumes:
  - ./src:/app/src:cached  # cached 옵션 추가

# nodemon.json
{
  "legacyWatch": true,
  "polling": true
}
```

### 문제 3: 디스크 공간 부족

```bash
# 진단
docker system df

# 해결
docker system prune -af --volumes  # 전체 정리 (주의!)

# 또는 선택적 정리
docker image prune -a     # 미사용 이미지
docker volume prune       # 미사용 볼륨
docker builder prune -a   # 빌드 캐시
```

---

## 다음 단계

### 23. 팀 협업
- 공통 개발 환경 구성
- Git을 통한 설정 공유
- 환경 변수 관리 전략

### 학습 자료

**생산성 도구**:
- [tmux 가이드](https://github.com/tmux/tmux/wiki)
- [lazydocker](https://github.com/jesseduffield/lazydocker)
- [ctop](https://github.com/bcicen/ctop)

**자동화**:
- [GitHub Actions](https://docs.github.com/en/actions)
- [Git Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)

---

**축하합니다! 🎉** 효율적인 일일 개발 루틴을 마스터했습니다!