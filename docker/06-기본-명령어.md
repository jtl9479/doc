# 6. Docker 기본 명령어 마스터 🎮

> **학습 목표**: Docker의 핵심 명령어를 완벽하게 이해하고 실무에서 자유자재로 활용할 수 있습니다

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐☆☆☆ (2개/5개)

---

## 📚 목차
- [실생활 비유로 이해하기](#-실생활-비유로-이해하기)
- [수치로 보는 효과](#-수치로-보는-효과)
- [4.1 이미지 명령어](#41-이미지-명령어)
- [4.2 컨테이너 명령어](#42-컨테이너-명령어)
- [4.3 컨테이너 상호작용](#43-컨테이너-상호작용)
- [4.4 시스템 관리 명령어](#44-시스템-관리-명령어)
- [4.5 실습: Hello World부터 웹서버까지](#45-실습-hello-world부터-웹서버까지)
- [주니어 시나리오](#-주니어-시나리오)
- [FAQ](#-faq)
- [면접 질문 리스트](#-면접-질문-리스트)
- [축하합니다](#-축하합니다)

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 스마트폰 앱 관리
```
Docker 명령어 = 스마트폰 앱 관리

docker pull     = 앱스토어에서 앱 다운로드
docker images   = 설치된 앱 목록 보기
docker run      = 앱 실행하기
docker ps       = 실행 중인 앱 확인
docker stop     = 앱 종료하기
docker rm       = 앱 삭제하기
docker logs     = 앱 사용 기록 확인

┌─────────────────────────┐
│   📱 스마트폰 화면        │
│   ┌─────────────────┐   │
│   │ 🎮 게임 (실행중) │   │
│   │ 📷 카메라       │   │
│   │ 💬 카카오톡     │   │
│   └─────────────────┘   │
└─────────────────────────┘
```

### 비유 2: 렌트카 서비스
```
이미지 명령어 = 렌트카 차량 관리

docker pull     = 차량을 렌트카 센터에 입고
docker images   = 보유 차량 목록
docker tag      = 차량에 번호판 부착
docker rmi      = 오래된 차량 폐차
docker push     = 본사에 차량 정보 전송

컨테이너 명령어 = 차량 대여/관리

docker run      = 고객에게 차량 대여
docker ps       = 현재 대여 중인 차량 확인
docker stop     = 차량 반납받기
docker restart  = 차량 정비 후 재대여
docker rm       = 대여 기록 삭제
```

### 비유 3: 음악 스트리밍 서비스
```
Docker 워크플로우 = Spotify 사용하기

1. docker search    = 노래 검색
2. docker pull      = 노래 다운로드 (오프라인 재생)
3. docker images    = 내 라이브러리
4. docker run       = 노래 재생
5. docker logs      = 재생 기록
6. docker stop      = 일시 정지
7. docker restart   = 다시 재생
8. docker stats     = 데이터 사용량 확인
```

### 비유 4: 아파트 관리
```
Docker 시스템 = 아파트 단지 관리

docker info         = 아파트 단지 전체 현황
docker system df    = 각 동별 주차장 사용률
docker system prune = 장기 미사용 차량 정리
docker inspect      = 특정 세대 상세 정보
docker stats        = 실시간 전기/수도 사용량

┌─────────────────────────┐
│     아파트 관리동        │
│   ┌───────────────┐     │
│   │ 101동: 85%    │     │
│   │ 102동: 92%    │     │
│   │ 103동: 67%    │     │
│   └───────────────┘     │
│   [정리 필요: 15대]     │
└─────────────────────────┘
```

### 비유 5: 편의점 재고 관리
```
Docker 명령어 = 편의점 POS 시스템

이미지 관리:
docker pull     = 본사에서 상품 입고
docker images   = 재고 목록
docker rmi      = 유통기한 지난 상품 폐기

컨테이너 관리:
docker run      = 진열대에 상품 배치
docker ps       = 진열 중인 상품 확인
docker exec     = 가격표 변경
docker logs     = 판매 기록
docker stats    = 실시간 매출 현황

시스템 관리:
docker system prune = 매장 대청소
```

### 🎯 종합 비교표
```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ Docker 명령어 │ 스마트폰     │ 렌트카       │ 편의점       │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ pull         │ 앱 다운로드  │ 차량 입고    │ 상품 입고    │
│ run          │ 앱 실행      │ 차량 대여    │ 상품 진열    │
│ ps           │ 실행중 앱    │ 대여중 차량  │ 진열 상품    │
│ stop         │ 앱 종료      │ 차량 반납    │ 상품 회수    │
│ logs         │ 사용 기록    │ 주행 기록    │ 판매 기록    │
│ stats        │ 배터리 사용량│ 연료 소비량  │ 매출 현황    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📊 수치로 보는 효과

| 지표 | 수동 관리 | Docker 명령어 | 개선율 |
|------|-----------|---------------|--------|
| 서버 배포 시간 | 4시간 | 5분 | **95%↓** |
| 환경 설정 시간 | 2시간 | 30초 | **99%↓** |
| 롤백 시간 | 30분 | 10초 | **97%↓** |
| 명령어 입력 | 50줄 | 1줄 | **98%↓** |
| 디스크 공간 절약 | 10GB | 2GB | **80%↓** |
| 학습 시간 | 1주일 | 3시간 | **95%↓** |

**실제 사례 - 스타트업 A사**:
- Docker 명령어 숙지 후 배포 시간: 2시간 → 3분
- 서버 장애 복구 시간: 45분 → 1분
- 신입 개발자 온보딩: 3일 → 2시간
- **연간 인건비 절감**: 약 5,000만원

---

## 4.1 이미지 명령어

### 🎯 이미지란?

**이미지는 컨테이너를 실행하기 위한 템플릿(설계도)입니다.**

```
이미지 → 컨테이너 관계:

붕어빵 틀 (이미지)  →  실제 붕어빵 (컨테이너)
설계도 (이미지)      →  건물 (컨테이너)
DVD (이미지)        →  영화 재생 (컨테이너)
```

### 📥 docker pull (이미지 다운로드)

#### 기본 사용법

```bash
# 최신 버전 다운로드
docker pull nginx
# 자동으로 nginx:latest 다운로드

# 특정 버전 다운로드
docker pull nginx:1.21.6

# 특정 플랫폼 다운로드
docker pull --platform linux/amd64 nginx

# 전체 이름으로 다운로드
docker pull docker.io/library/nginx:latest
```

**실행 과정:**
```bash
$ docker pull nginx:1.21.6

1.21.6: Pulling from library/nginx
a2abf6c4d29d: Pull complete          ← Layer 1 (80.4MB)
a9edb18cadd1: Pull complete          ← Layer 2 (61.1MB)
589b7251471a: Pull complete          ← Layer 3 (4.61KB)
186b1aaa4aa6: Pull complete          ← Layer 4 (1.4KB)
b4df32aa5a72: Pull complete          ← Layer 5 (1.2KB)
a0bcbecc962e: Pull complete          ← Layer 6 (1.2KB)
Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31
Status: Downloaded newer image for nginx:1.21.6
docker.io/library/nginx:1.21.6

총 다운로드: 141.5 MB
```

#### 고급 옵션

```bash
# 모든 태그 다운로드 (주의: 용량 큼)
docker pull --all-tags nginx

# 다운로드 진행 상황 숨기기
docker pull -q nginx

# 레지스트리 미러 사용
docker pull --registry-mirror=https://mirror.example.com nginx
```

**실전 팁:**
```bash
# 자주 사용하는 이미지 미리 다운로드 (스크립트)
#!/bin/bash
IMAGES=(
    "nginx:latest"
    "postgres:13"
    "redis:6"
    "node:16-alpine"
    "python:3.9-slim"
)

for img in "${IMAGES[@]}"; do
    echo "Pulling $img..."
    docker pull $img
done
```

### 📤 docker push (이미지 업로드)

#### 기본 사용법

```bash
# 1. 이미지에 태그 지정 (사용자명 포함)
docker tag myapp:latest username/myapp:latest
docker tag myapp:latest username/myapp:1.0.0

# 2. Docker Hub 로그인
docker login
Username: username
Password:
Login Succeeded

# 3. 이미지 업로드
docker push username/myapp:latest
docker push username/myapp:1.0.0

# 업로드 과정:
The push refers to repository [docker.io/username/myapp]
5f70bf18a086: Pushed           ← Layer 1
d0e8a8a3cb9f: Pushed           ← Layer 2
8cf24f538683: Pushed           ← Layer 3
latest: digest: sha256:abc123... size: 1234
1.0.0: digest: sha256:abc123... size: 1234
```

#### Private Registry에 push

```bash
# 1. Private Registry 주소 포함하여 태그
docker tag myapp registry.company.com:5000/myapp:latest

# 2. Private Registry 로그인
docker login registry.company.com:5000
Username: admin
Password:

# 3. 업로드
docker push registry.company.com:5000/myapp:latest
```

**레이어 재사용:**
```bash
# 같은 베이스 이미지를 사용하는 여러 이미지 push

$ docker push username/app1:latest
Layer already exists         ← 이미 있는 레이어는 스킵!
Layer already exists
abc123: Pushed              ← 변경된 레이어만 업로드

$ docker push username/app2:latest
Layer already exists         ← 베이스 레이어 재사용
Layer already exists
def456: Pushed              ← 새로운 레이어만 업로드

시간 절약: 80% 이상! ⚡
```

### 🏷️ docker tag (이미지 태그)

#### 기본 사용법

```bash
# 기본 형식
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]

# 예시
docker tag nginx:latest myregistry/nginx:v1.0
docker tag abc123 username/myapp:latest
docker tag myapp:latest myapp:1.0.0
docker tag myapp:latest myapp:stable
```

**태그 네이밍 전략:**
```bash
# 버전 기반
myapp:1.0.0          # Semantic Versioning
myapp:1.0
myapp:1

# 환경 기반
myapp:dev            # 개발
myapp:staging        # 스테이징
myapp:prod           # 운영

# Git 기반
myapp:commit-abc123  # Git commit SHA
myapp:branch-main    # Git branch

# 날짜 기반
myapp:2024-01-15     # 날짜
myapp:20240115-1230  # 날짜+시간

# 조합
myapp:1.0.0-prod
myapp:v1.0-alpine
```

**태그 전략 예시:**
```bash
# 릴리스 시 여러 태그 생성
docker tag myapp:latest myapp:1.2.3
docker tag myapp:latest myapp:1.2
docker tag myapp:latest myapp:1
docker tag myapp:latest myapp:stable

# 4개 태그가 같은 이미지를 가리킴!

docker images | grep myapp
myapp   1.2.3   abc123  ...
myapp   1.2     abc123  ...    ← 같은 IMAGE ID
myapp   1       abc123  ...    ← 같은 IMAGE ID
myapp   stable  abc123  ...    ← 같은 IMAGE ID
```

### 📋 docker images (이미지 목록)

#### 기본 사용법

```bash
# 모든 이미지 보기
docker images

REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
nginx         latest    605c77e624dd   2 weeks ago    141MB
postgres      13        a1b2c3d4e5f6   3 weeks ago    374MB
redis         6         b2c3d4e5f6a1   1 month ago    105MB
myapp         latest    c3d4e5f6a1b2   2 hours ago    250MB

# 또는
docker image ls
```

#### 고급 필터링

```bash
# 특정 이미지만 보기
docker images nginx

REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
nginx        latest    605c77e624dd   2 weeks ago    141MB
nginx        1.21.6    a1b2c3d4e5f6   3 months ago   141MB

# dangling 이미지 (태그 없는 이미지)
docker images -f "dangling=true"

REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
<none>       <none>    abc123def456   1 week ago     200MB

# 특정 시간 이전 이미지
docker images -f "before=nginx:latest"

# 특정 시간 이후 이미지
docker images -f "since=nginx:latest"

# 특정 라벨 가진 이미지
docker images -f "label=maintainer=nginx"
```

#### 출력 형식 지정

```bash
# 간략하게 보기 (IMAGE ID만)
docker images -q
605c77e624dd
a1b2c3d4e5f6
b2c3d4e5f6a1

# 커스텀 형식
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

REPOSITORY   TAG       SIZE
nginx        latest    141MB
postgres     13        374MB

# JSON 형식
docker images --format "{{json .}}"
{"Containers":"N/A","CreatedAt":"2024-01-15...","ID":"605c77e624dd",...}

# 디스크 사용량 포함
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
```

#### 이미지 상세 정보

```bash
# 이미지 히스토리 (각 레이어 확인)
docker history nginx:latest

IMAGE          CREATED BY                                      SIZE
605c77e624dd   CMD ["nginx" "-g" "daemon off;"]               0B
<missing>      STOPSIGNAL SIGQUIT                             0B
<missing>      EXPOSE 80                                       0B
<missing>      RUN /bin/sh -c set -x && addgroup...          61.1MB
<missing>      ENV NGINX_VERSION=1.21.6                       0B
<missing>      /bin/sh -c #(nop)  CMD ["/bin/bash"]           0B
<missing>      /bin/sh -c #(nop) ADD file:... in /            80.4MB

# 더 자세한 레이어 정보
docker history --no-trunc nginx:latest
```

### 🗑️ docker rmi (이미지 삭제)

#### 기본 사용법

```bash
# 이미지 ID로 삭제
docker rmi 605c77e624dd

# 이미지 이름으로 삭제
docker rmi nginx:latest

# 여러 이미지 삭제
docker rmi nginx:latest postgres:13 redis:6

# 강제 삭제 (컨테이너가 사용 중이어도)
docker rmi -f nginx:latest
```

#### 대량 삭제

```bash
# 모든 이미지 삭제
docker rmi $(docker images -q)

# dangling 이미지만 삭제 (추천)
docker image prune

WARNING! This will remove all dangling images.
Are you sure you want to continue? [y/N] y
Deleted Images:
deleted: sha256:abc123...
deleted: sha256:def456...
Total reclaimed space: 1.2GB

# 사용하지 않는 모든 이미지 삭제
docker image prune -a

WARNING! This will remove all images without at least one container associated to them.
Are you sure you want to continue? [y/N] y
Deleted Images:
untagged: nginx:latest
deleted: sha256:605c77...
Total reclaimed space: 15.5GB

# 확인 없이 삭제
docker image prune -a -f
```

**삭제 시 주의사항:**
```bash
# 이미지가 컨테이너에서 사용 중인 경우
$ docker rmi nginx:latest

Error response from daemon: conflict: unable to remove repository reference "nginx:latest"
(must force) - container abc123 is using its referenced image 605c77e624dd

# 해결 방법 1: 컨테이너 먼저 삭제
docker rm -f abc123
docker rmi nginx:latest

# 해결 방법 2: 강제 삭제 (권장하지 않음)
docker rmi -f nginx:latest
```

### 🔍 docker search (이미지 검색)

```bash
# Docker Hub에서 이미지 검색
docker search nginx

NAME                     DESCRIPTION                     STARS   OFFICIAL
nginx                    Official build of Nginx.        20000   [OK]
jwilder/nginx-proxy      Automated Nginx reverse...      2000
nginx/nginx-ingress      NGINX Ingress Controller...     500

# 공식 이미지만 검색
docker search --filter is-official=true nginx

# 최소 star 수로 필터
docker search --filter stars=1000 nginx

# 자동화된 빌드만
docker search --filter is-automated=true nginx

# 결과 개수 제한
docker search --limit 5 nginx
```

### 📦 docker save & load (이미지 백업/복원)

#### 이미지를 파일로 저장

```bash
# 단일 이미지 저장
docker save nginx:latest > nginx-latest.tar
docker save -o nginx-latest.tar nginx:latest

# 여러 이미지 저장
docker save -o images-backup.tar nginx:latest postgres:13 redis:6

# 압축하여 저장
docker save nginx:latest | gzip > nginx-latest.tar.gz

# 파일 크기 확인
ls -lh nginx-latest.tar
-rw-r--r-- 1 user user 141M Jan 15 10:00 nginx-latest.tar
```

#### 파일에서 이미지 로드

```bash
# tar 파일에서 로드
docker load < nginx-latest.tar
docker load -i nginx-latest.tar

Loaded image: nginx:latest

# 압축 파일에서 로드
gunzip -c nginx-latest.tar.gz | docker load

# 여러 이미지 로드
docker load -i images-backup.tar

Loaded image: nginx:latest
Loaded image: postgres:13
Loaded image: redis:6
```

**사용 사례:**
```bash
# 사례 1: 오프라인 환경 배포
# 온라인 서버에서:
docker pull nginx:latest
docker save nginx:latest > nginx.tar

# USB로 옮긴 후 오프라인 서버에서:
docker load < nginx.tar

# 사례 2: 이미지 백업
docker save $(docker images -q) > all-images-backup.tar

# 사례 3: 특정 버전 보관
docker save myapp:1.0.0 | gzip > myapp-1.0.0.tar.gz
```

---

## 4.2 컨테이너 명령어

### 🚀 docker run (컨테이너 생성 및 실행)

**가장 중요하고 자주 사용하는 명령어!**

#### 기본 사용법

```bash
# 기본 형식
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]

# 가장 간단한 실행
docker run hello-world

# 포그라운드에서 실행 (터미널 점유)
docker run nginx

# 백그라운드에서 실행 (detached mode)
docker run -d nginx
abc123def456...          ← 컨테이너 ID 반환

# 이름 지정
docker run -d --name my-nginx nginx
```

#### 주요 옵션 완전 가이드

**1. 실행 모드:**
```bash
-d, --detach              # 백그라운드 실행
-i, --interactive         # STDIN 열어놓기
-t, --tty                 # 가상 터미널 할당

# 조합
docker run -d nginx                    # 백그라운드 (서버용)
docker run -it ubuntu bash             # 대화형 (쉘 접속용)
docker run -dit ubuntu bash            # 백그라운드 + 대화형 준비
```

**2. 포트 매핑:**
```bash
-p, --publish HOST:CONTAINER          # 포트 매핑
-P, --publish-all                     # 모든 포트 자동 매핑

# 예시
docker run -d -p 8080:80 nginx        # 8080 → 80
docker run -d -p 3306:3306 mysql      # 3306 → 3306
docker run -d -p 127.0.0.1:8080:80 nginx  # 특정 IP에만
docker run -d -p 8080:80 -p 8443:443 nginx  # 여러 포트

# 동적 포트 할당
docker run -d -P nginx                # 호스트 랜덤 포트 → 80
docker ps
# 0.0.0.0:32768->80/tcp
```

**3. 환경 변수:**
```bash
-e, --env KEY=VALUE                   # 환경 변수 설정
--env-file FILE                       # 파일에서 환경 변수 읽기

# 예시
docker run -d \
  -e POSTGRES_PASSWORD=secret \
  -e POSTGRES_USER=admin \
  -e POSTGRES_DB=mydb \
  postgres:13

# .env 파일 사용
# .env 내용:
POSTGRES_PASSWORD=secret
POSTGRES_USER=admin
POSTGRES_DB=mydb

docker run -d --env-file .env postgres:13
```

**4. 볼륨 마운트:**
```bash
-v, --volume HOST:CONTAINER           # 볼륨 마운트
--mount type=TYPE,src=SRC,dst=DST     # 상세 마운트 (권장)

# Named Volume
docker run -d -v postgres-data:/var/lib/postgresql/data postgres:13

# Bind Mount
docker run -d -v /host/path:/container/path nginx

# Read-only
docker run -d -v /host/path:/container/path:ro nginx

# 새로운 문법 (더 명확함)
docker run -d \
  --mount type=volume,src=postgres-data,dst=/var/lib/postgresql/data \
  postgres:13

docker run -d \
  --mount type=bind,src=/host/path,dst=/container/path \
  nginx
```

**5. 네트워크:**
```bash
--network NETWORK                     # 네트워크 연결
--network-alias ALIAS                 # 네트워크 별칭

# 예시
docker run -d --network my-network nginx
docker run -d --network host nginx              # 호스트 네트워크 사용
docker run -d --network none nginx              # 네트워크 없음
docker run -d --network container:other nginx   # 다른 컨테이너와 공유
```

**6. 리소스 제한:**
```bash
--cpus NUMBER                         # CPU 제한
--memory SIZE                         # 메모리 제한
--memory-swap SIZE                    # 메모리+스왑
--pids-limit NUMBER                   # 프로세스 수 제한

# 예시
docker run -d \
  --cpus="1.5" \
  --memory="1g" \
  --memory-swap="2g" \
  --pids-limit=100 \
  nginx
```

**7. 재시작 정책:**
```bash
--restart POLICY                      # 재시작 정책

# 정책 종류
no              # 재시작 안 함 (기본값)
always          # 항상 재시작
unless-stopped  # 명시적으로 stop하지 않는 한
on-failure[:max-retries]  # 에러 시에만 (최대 재시도 횟수)

# 예시
docker run -d --restart=always nginx
docker run -d --restart=on-failure:3 myapp
docker run -d --restart=unless-stopped redis
```

**8. 기타 유용한 옵션:**
```bash
--name NAME                           # 컨테이너 이름
--hostname HOSTNAME                   # 호스트명
--rm                                  # 종료 시 자동 삭제
-w, --workdir PATH                    # 작업 디렉토리
-u, --user USER                       # 실행 사용자
--label KEY=VALUE                     # 레이블 추가

# 예시
docker run -d \
  --name web-server \
  --hostname web01 \
  --label env=production \
  --label version=1.0 \
  -w /app \
  -u nginx \
  nginx

# 임시 컨테이너 (테스트용)
docker run --rm -it ubuntu bash
# 종료 시 자동으로 삭제됨!
```

#### 실전 예시 모음

**웹 서버 (Nginx):**
```bash
docker run -d \
  --name web-server \
  --restart=always \
  -p 80:80 \
  -p 443:443 \
  -v /host/html:/usr/share/nginx/html:ro \
  -v /host/nginx.conf:/etc/nginx/nginx.conf:ro \
  nginx:latest
```

**데이터베이스 (PostgreSQL):**
```bash
docker run -d \
  --name postgres-db \
  --restart=unless-stopped \
  -p 5432:5432 \
  -e POSTGRES_PASSWORD=SecurePassword123 \
  -e POSTGRES_USER=admin \
  -e POSTGRES_DB=myapp_db \
  -v postgres-data:/var/lib/postgresql/data \
  --memory="2g" \
  --cpus="2" \
  postgres:13
```

**Redis 캐시:**
```bash
docker run -d \
  --name redis-cache \
  --restart=always \
  -p 6379:6379 \
  -v redis-data:/data \
  --memory="512m" \
  redis:6 redis-server --appendonly yes
```

**개발용 Node.js 앱:**
```bash
docker run -d \
  --name nodejs-dev \
  -p 3000:3000 \
  -v $(pwd):/app \
  -w /app \
  -e NODE_ENV=development \
  node:16 npm run dev
```

### 🎬 docker start / stop / restart (컨테이너 시작/중지/재시작)

#### docker start (시작)

```bash
# 중지된 컨테이너 시작
docker start CONTAINER

# 예시
docker start my-nginx
docker start abc123

# 여러 컨테이너 시작
docker start my-nginx my-postgres my-redis

# 출력 보면서 시작
docker start -a my-nginx        # attach
docker start -ai ubuntu bash    # attach + interactive
```

#### docker stop (정상 종료)

```bash
# 컨테이너 중지 (SIGTERM → 10초 → SIGKILL)
docker stop CONTAINER

# 예시
docker stop my-nginx
docker stop abc123

# 여러 컨테이너 중지
docker stop my-nginx my-postgres my-redis

# 타임아웃 변경 (기본 10초)
docker stop -t 30 my-nginx      # 30초 대기

# 모든 실행 중인 컨테이너 중지
docker stop $(docker ps -q)
```

#### docker restart (재시작)

```bash
# 컨테이너 재시작 (stop + start)
docker restart CONTAINER

# 예시
docker restart my-nginx

# 타임아웃 지정
docker restart -t 5 my-nginx

# 여러 컨테이너 재시작
docker restart my-nginx my-postgres

# 모든 컨테이너 재시작
docker restart $(docker ps -aq)
```

### 💀 docker kill (강제 종료)

```bash
# 즉시 종료 (SIGKILL)
docker kill CONTAINER

# 예시
docker kill my-nginx

# 특정 시그널 전송
docker kill -s SIGTERM my-nginx
docker kill -s SIGHUP nginx      # 설정 재로드
docker kill -s SIGUSR1 nginx     # 로그 재오픈
```

**stop vs kill:**
```
docker stop:
1. SIGTERM 전송 (정상 종료 요청)
2. 10초 대기
3. 응답 없으면 SIGKILL
→ 데이터 저장, 연결 종료 등 정리 시간 부여

docker kill:
1. SIGKILL 즉시 전송
→ 프로세스 즉시 종료 (정리 작업 없음)

권장: 항상 stop 사용, kill은 비상시에만!
```

### 🗑️ docker rm (컨테이너 삭제)

```bash
# 중지된 컨테이너 삭제
docker rm CONTAINER

# 예시
docker rm my-nginx
docker rm abc123

# 여러 컨테이너 삭제
docker rm my-nginx my-postgres my-redis

# 실행 중인 컨테이너 강제 삭제
docker rm -f my-nginx

# 볼륨도 함께 삭제
docker rm -v my-nginx

# 모든 중지된 컨테이너 삭제
docker rm $(docker ps -aq -f status=exited)

# 또는
docker container prune

WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y
Deleted Containers:
abc123def456...
def456ghi789...
Total reclaimed space: 1.2GB
```

### 📋 docker ps (컨테이너 목록)

```bash
# 실행 중인 컨테이너만
docker ps

CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
abc123         nginx     "/docker-entrypoint.…"   2 hours ago     Up 2 hours     0.0.0.0:80->80/tcp    web
def456         postgres  "docker-entrypoint.s…"   3 hours ago     Up 3 hours     5432/tcp              db

# 모든 컨테이너 (중지된 것 포함)
docker ps -a

# 최근 N개 컨테이너
docker ps -n 5          # 최근 5개

# 최신 컨테이너
docker ps -l

# 컨테이너 ID만
docker ps -q

# 파일 크기 포함
docker ps -s

CONTAINER ID   IMAGE     SIZE
abc123         nginx     2B (virtual 141MB)
```

#### 필터링

```bash
# 이름으로 필터
docker ps -f "name=nginx"

# 상태로 필터
docker ps -a -f "status=exited"
docker ps -a -f "status=running"
docker ps -a -f "status=paused"

# 종료 코드로 필터
docker ps -a -f "exited=0"          # 정상 종료
docker ps -a -f "exited=137"        # Kill됨

# 볼륨 마운트 여부
docker ps -f "volume=/data"

# 네트워크로 필터
docker ps -f "network=my-network"

# 레이블로 필터
docker ps -f "label=env=production"
```

#### 출력 형식

```bash
# 커스텀 형식
docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}"

ID          NAMES       STATUS
abc123      nginx       Up 2 hours
def456      postgres    Up 3 hours

# JSON 형식
docker ps --format "{{json .}}"

# 특정 컬럼만
docker ps --format "{{.Names}}: {{.Status}}"

nginx: Up 2 hours
postgres: Up 3 hours

# .Ports 포함
docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}"
```

### 🔄 docker create (컨테이너 생성만)

```bash
# run과 같지만 시작하지 않음
docker create nginx

abc123def456...

# 옵션도 run과 동일
docker create -p 8080:80 --name my-nginx nginx

# 나중에 시작
docker start my-nginx
```

**create vs run:**
```
docker create:
- 컨테이너 생성만
- 실행하지 않음
- 설정 검증용

docker run:
- 생성 + 시작
- 즉시 실행

사용 사례:
- 복잡한 설정 후 한 번에 시작
- docker-compose up 내부 동작
```

---

## 4.3 컨테이너 상호작용

### 💻 docker exec (컨테이너 내부 명령 실행)

**실행 중인 컨테이너에서 명령어를 실행합니다.**

#### 기본 사용법

```bash
# 기본 형식
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]

# 간단한 명령 실행
docker exec my-nginx ls /etc/nginx
docker exec my-nginx ps aux
docker exec my-nginx cat /etc/nginx/nginx.conf

# 출력 예시:
$ docker exec my-nginx ls -la /etc/nginx
total 40
drwxr-xr-x 3 root root 4096 Jan 15 10:00 .
drwxr-xr-x 1 root root 4096 Jan 15 10:00 ..
-rw-r--r-- 1 root root 1007 Jan 15 10:00 nginx.conf
...
```

#### 대화형 쉘 접속

```bash
# bash 쉘 접속 (가장 자주 사용!)
docker exec -it my-nginx bash

root@abc123:/# ls
bin  boot  dev  etc  home  lib  ...

root@abc123:/# pwd
/

root@abc123:/# whoami
root

root@abc123:/# exit
exit

# sh 쉘 (bash가 없는 경우)
docker exec -it alpine-container sh

# 특정 사용자로 실행
docker exec -it -u nginx my-nginx bash

# 특정 디렉토리에서 실행
docker exec -it -w /app my-app bash
```

#### 환경 변수 설정

```bash
# 환경 변수 포함
docker exec -it -e DEBUG=true my-app bash

# 여러 환경 변수
docker exec -it \
  -e DB_HOST=localhost \
  -e DB_PORT=5432 \
  my-app bash
```

#### 실전 활용 예시

**1. 데이터베이스 접속:**
```bash
# PostgreSQL
docker exec -it postgres-db psql -U postgres

postgres=# \l                    # 데이터베이스 목록
postgres=# \c mydb               # 데이터베이스 선택
postgres=# SELECT * FROM users;  # 쿼리 실행

# MySQL
docker exec -it mysql-db mysql -u root -p

mysql> SHOW DATABASES;
mysql> USE mydb;
mysql> SELECT * FROM users;

# Redis
docker exec -it redis-cache redis-cli

127.0.0.1:6379> KEYS *
127.0.0.1:6379> GET mykey
```

**2. 로그 확인:**
```bash
# Nginx 로그
docker exec my-nginx tail -f /var/log/nginx/access.log

# 애플리케이션 로그
docker exec my-app tail -f /var/log/app/application.log
```

**3. 파일 수정:**
```bash
# vim으로 설정 파일 수정
docker exec -it my-nginx vi /etc/nginx/nginx.conf

# sed로 자동 수정
docker exec my-nginx sed -i 's/80/8080/g' /etc/nginx/nginx.conf
```

**4. 디버깅:**
```bash
# 프로세스 확인
docker exec my-app ps aux

# 네트워크 확인
docker exec my-app netstat -tuln

# 디스크 사용량
docker exec my-app df -h

# 메모리 확인
docker exec my-app free -m

# curl 테스트
docker exec my-app curl http://localhost:8080/health
```

**5. 패키지 설치 (임시):**
```bash
# Debian/Ubuntu
docker exec my-nginx apt-get update
docker exec my-nginx apt-get install -y vim

# Alpine
docker exec alpine-container apk add --no-cache curl

# ⚠️ 주의: 컨테이너 재시작 시 설치한 패키지는 사라짐!
# 영구적으로 필요하면 Dockerfile에 추가
```

### 📎 docker attach (컨테이너 출력 연결)

```bash
# 컨테이너의 STDOUT/STDERR에 연결
docker attach CONTAINER

# 예시
docker attach my-nginx

# 분리하기 (detach)
# Ctrl+P, Ctrl+Q (컨테이너는 계속 실행됨)

# 종료하기
# Ctrl+C (컨테이너도 종료됨!)
```

**attach vs exec 비교:**
```
docker attach:
- 메인 프로세스(PID 1)에 연결
- Ctrl+C 하면 컨테이너 종료!
- 하나의 세션만 가능
- 주로 로그 보기용

docker exec:
- 새로운 프로세스 시작
- exit해도 컨테이너 유지
- 여러 세션 동시 가능
- 주로 작업 수행용

권장: exec 사용! attach는 위험함
```

### 📄 docker logs (로그 확인)

**컨테이너의 STDOUT/STDERR 로그를 확인합니다.**

#### 기본 사용법

```bash
# 전체 로그 보기
docker logs CONTAINER

# 예시
docker logs my-nginx

192.168.1.100 - - [15/Jan/2024:10:00:00 +0000] "GET / HTTP/1.1" 200 612
192.168.1.100 - - [15/Jan/2024:10:00:01 +0000] "GET /favicon.ico HTTP/1.1" 404 555
...
```

#### 고급 옵션

```bash
# 실시간 로그 스트리밍 (tail -f처럼)
docker logs -f my-nginx

# 최근 N줄만
docker logs --tail 100 my-nginx

# 특정 시간 이후 로그
docker logs --since 2024-01-15T10:00:00 my-nginx
docker logs --since 1h my-nginx          # 1시간 전부터
docker logs --since 30m my-nginx         # 30분 전부터

# 특정 시간 이전 로그
docker logs --until 2024-01-15T10:00:00 my-nginx

# 타임스탬프 포함
docker logs -t my-nginx

2024-01-15T10:00:00.123456789Z 192.168.1.100 - - [15/Jan...
```

#### 실전 활용

```bash
# 에러 로그만 보기 (grep 활용)
docker logs my-app 2>&1 | grep ERROR

# 특정 패턴 찾기
docker logs my-app | grep "404"
docker logs my-app | grep -i "exception"

# 로그 파일로 저장
docker logs my-app > app.log

# 최근 에러 확인
docker logs --tail 50 my-app | grep -i error

# 실시간 에러 모니터링
docker logs -f my-app 2>&1 | grep --line-buffered -i error
```

**로그 로테이션 설정:**
```bash
# docker run 시 로그 옵션 설정
docker run -d \
  --name my-app \
  --log-driver json-file \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  myapp:latest

# 로그 파일 최대 10MB, 최대 3개 유지
# 총 30MB로 제한
```

### 🔍 docker inspect (상세 정보 확인)

**컨테이너의 모든 설정과 상태를 JSON 형식으로 출력합니다.**

#### 기본 사용법

```bash
# 전체 정보 출력
docker inspect CONTAINER

# 예시
docker inspect my-nginx

[
    {
        "Id": "abc123def456...",
        "Created": "2024-01-15T10:00:00.000000000Z",
        "Path": "/docker-entrypoint.sh",
        "Args": ["nginx", "-g", "daemon off;"],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            ...
        },
        "Image": "sha256:605c77...",
        "NetworkSettings": {
            "IPAddress": "172.17.0.2",
            "Ports": {
                "80/tcp": [
                    {
                        "HostIp": "0.0.0.0",
                        "HostPort": "8080"
                    }
                ]
            }
        },
        ...
    }
]
```

#### 특정 정보만 추출

```bash
# IP 주소 확인
docker inspect -f '{{.NetworkSettings.IPAddress}}' my-nginx
172.17.0.2

# 포트 매핑 확인
docker inspect -f '{{.NetworkSettings.Ports}}' my-nginx
map[80/tcp:[{0.0.0.0 8080}]]

# 상태 확인
docker inspect -f '{{.State.Status}}' my-nginx
running

# 시작 시간
docker inspect -f '{{.State.StartedAt}}' my-nginx
2024-01-15T10:00:00.000000000Z

# 환경 변수
docker inspect -f '{{.Config.Env}}' my-nginx

# 볼륨 마운트
docker inspect -f '{{.Mounts}}' my-nginx

# 재시작 횟수
docker inspect -f '{{.RestartCount}}' my-nginx
```

#### 실전 활용 예시

**1. 네트워크 정보:**
```bash
# IP 주소
IP=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' my-nginx)
echo $IP

# 모든 네트워크
docker inspect -f '{{json .NetworkSettings.Networks}}' my-nginx | jq

# Gateway
docker inspect -f '{{.NetworkSettings.Gateway}}' my-nginx
```

**2. 볼륨 정보:**
```bash
# 마운트 정보
docker inspect -f '{{json .Mounts}}' my-nginx | jq

[
  {
    "Type": "volume",
    "Name": "my-volume",
    "Source": "/var/lib/docker/volumes/my-volume/_data",
    "Destination": "/data",
    "RW": true
  }
]
```

**3. 로그 설정:**
```bash
# 로그 드라이버
docker inspect -f '{{.HostConfig.LogConfig.Type}}' my-nginx
json-file

# 로그 경로
docker inspect -f '{{.LogPath}}' my-nginx
/var/lib/docker/containers/abc123.../abc123...-json.log
```

**4. 리소스 제한:**
```bash
# 메모리 제한
docker inspect -f '{{.HostConfig.Memory}}' my-nginx

# CPU 제한
docker inspect -f '{{.HostConfig.NanoCpus}}' my-nginx
```

**5. 스크립트에서 활용:**
```bash
#!/bin/bash
# 모든 컨테이너의 IP 출력
for container in $(docker ps -q); do
    NAME=$(docker inspect -f '{{.Name}}' $container | sed 's/\///')
    IP=$(docker inspect -f '{{.NetworkSettings.IPAddress}}' $container)
    echo "$NAME: $IP"
done

# 출력:
nginx: 172.17.0.2
postgres: 172.17.0.3
redis: 172.17.0.4
```

### 📁 docker cp (파일 복사)

```bash
# 호스트 → 컨테이너
docker cp /host/file.txt my-nginx:/etc/nginx/

# 컨테이너 → 호스트
docker cp my-nginx:/etc/nginx/nginx.conf ./nginx.conf

# 디렉토리 복사
docker cp /host/directory my-nginx:/app/

# 예시: 로그 파일 꺼내기
docker cp my-app:/var/log/app/error.log ./error.log

# 예시: 설정 파일 넣기
docker cp new-config.yml my-app:/app/config/config.yml
```

### 📊 docker top (프로세스 목록)

```bash
# 컨테이너 내부 프로세스 확인
docker top CONTAINER

# 예시
docker top my-nginx

UID    PID    PPID   C   STIME   TTY   TIME      CMD
root   1234   1200   0   10:00   ?     00:00:00  nginx: master
nginx  1235   1234   0   10:00   ?     00:00:05  nginx: worker
nginx  1236   1234   0   10:00   ?     00:00:05  nginx: worker

# 커스텀 형식
docker top my-nginx aux
docker top my-nginx -eo pid,comm
```

### 📈 docker stats (리소스 사용량)

```bash
# 모든 실행 중인 컨테이너
docker stats

CONTAINER ID   NAME       CPU %   MEM USAGE / LIMIT     NET I/O         BLOCK I/O
abc123         nginx      0.50%   10MB / 256MB         1.2kB / 2.4kB   0B / 0B
def456         postgres   15.30%  800MB / 4GB          10MB / 5MB      100MB / 50MB

# 특정 컨테이너만
docker stats my-nginx my-postgres

# 한 번만 출력 (실시간 업데이트 없음)
docker stats --no-stream

# 커스텀 형식
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
```

---

## 4.4 시스템 관리 명령어

### 💾 docker system df (디스크 사용량)

```bash
# 전체 디스크 사용량
docker system df

TYPE            TOTAL   ACTIVE   SIZE      RECLAIMABLE
Images          25      5        10.5GB    8.2GB (78%)
Containers      10      3        1.2GB     800MB (66%)
Local Volumes   8       2        5.3GB     4.1GB (77%)
Build Cache     0       0        0B        0B

# 상세 정보
docker system df -v

Images space usage:
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE      SHARED SIZE   UNIQUE SIZE
nginx        latest    605c77e624dd   2 weeks ago    141MB     80.4MB        60.6MB
postgres     13        a1b2c3d4e5f6   3 weeks ago    374MB     80.4MB        293.6MB

Containers space usage:
CONTAINER ID   IMAGE     SIZE
abc123         nginx     2B (virtual 141MB)

Local Volumes space usage:
VOLUME NAME      SIZE
my-volume        1.2GB
postgres-data    4.1GB
```

### 🧹 docker system prune (정리)

**사용하지 않는 Docker 리소스를 삭제합니다.**

```bash
# 기본 정리 (중지된 컨테이너, dangling 이미지, 사용 안 하는 네트워크)
docker system prune

WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache

Are you sure you want to continue? [y/N] y

Deleted Containers:
abc123def456
def456ghi789

Deleted Images:
untagged: myapp@sha256:abc123...
deleted: sha256:abc123...

Total reclaimed space: 5.2GB

# 확인 없이 실행
docker system prune -f

# 모든 이미지도 삭제 (사용 안 하는)
docker system prune -a

WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Total reclaimed space: 15.5GB

# 볼륨도 함께 삭제
docker system prune -a --volumes

WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all volumes not used by at least one container
  - all images without at least one container associated to them
  - all build cache

Total reclaimed space: 25.8GB

# 특정 기간 이전 것만 삭제
docker system prune --filter "until=24h"   # 24시간 이전
docker system prune --filter "until=168h"  # 1주일 이전
```

**개별 정리 명령어:**
```bash
# 컨테이너만 정리
docker container prune

# 이미지만 정리
docker image prune       # dangling만
docker image prune -a    # 사용 안 하는 모든 이미지

# 볼륨만 정리
docker volume prune

# 네트워크만 정리
docker network prune

# 빌드 캐시 정리
docker builder prune
```

### ℹ️ docker info (시스템 정보)

```bash
# 전체 시스템 정보
docker info

Client:
 Context:    default
 Debug Mode: false

Server:
 Containers: 10
  Running: 3
  Paused: 0
  Stopped: 7
 Images: 25
 Server Version: 24.0.7
 Storage Driver: overlay2
  Backing Filesystem: extfs
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 2
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
 Swarm: inactive
 Runtimes: runc io.containerd.runc.v2
 Default Runtime: runc
 Kernel Version: 5.15.133.1-microsoft-standard-WSL2
 Operating System: Docker Desktop
 OSType: linux
 Architecture: x86_64
 CPUs: 8
 Total Memory: 15.5GiB
 Docker Root Dir: /var/lib/docker
 Registry: https://index.docker.io/v1/
 Experimental: false
```

### 🔢 docker version (버전 정보)

```bash
# 버전 정보
docker version

Client:
 Cloud integration: v1.0.35+desktop.5
 Version:           24.0.7
 API version:       1.43
 Go version:        go1.20.10
 Git commit:        afdd53b
 Built:             Thu Oct 26 09:04:20 2023
 OS/Arch:           windows/amd64
 Context:           desktop-linux

Server: Docker Desktop 4.26.1 (131620)
 Engine:
  Version:          24.0.7
  API version:      1.43 (minimum version 1.12)
  Go version:       go1.20.10
  Git commit:       311b9ff
```

---

## 4.5 실습: Hello World부터 웹서버까지

### 🎓 실습 1: Hello World

```bash
# 1단계: Hello World 실행
docker run hello-world

# 2단계: 무슨 일이 일어났는지 확인
docker ps -a

# 3단계: 로그 확인
docker logs [CONTAINER_ID]

# 4단계: 정리
docker rm [CONTAINER_ID]
```

### 🎓 실습 2: 대화형 Ubuntu

```bash
# 1단계: Ubuntu 컨테이너 시작
docker run -it ubuntu bash

# 2단계: 컨테이너 내부에서 작업
root@abc123:/# ls
root@abc123:/# pwd
root@abc123:/# whoami
root@abc123:/# uname -a
root@abc123:/# cat /etc/os-release

# 3단계: 파일 생성
root@abc123:/# echo "Hello Docker" > /tmp/test.txt
root@abc123:/# cat /tmp/test.txt
Hello Docker

# 4단계: 종료 (Ctrl+D 또는 exit)
root@abc123:/# exit

# 5단계: 컨테이너 재시작
docker ps -a  # 컨테이너 ID 확인
docker start -ai [CONTAINER_ID]

# 6단계: 파일 확인 (그대로 있음!)
root@abc123:/# cat /tmp/test.txt
Hello Docker

# 7단계: 정리
exit
docker rm [CONTAINER_ID]
```

### 🎓 실습 3: Nginx 웹 서버

```bash
# 1단계: Nginx 시작
docker run -d -p 8080:80 --name web-server nginx

# 2단계: 상태 확인
docker ps

# 3단계: 브라우저로 접속
# http://localhost:8080
# "Welcome to nginx!" 페이지 확인

# 4단계: curl로 확인
curl http://localhost:8080

# 5단계: 로그 확인
docker logs web-server

# 6단계: HTML 파일 수정
docker exec web-server sh -c 'echo "<h1>Hello Docker!</h1>" > /usr/share/nginx/html/index.html'

# 7단계: 브라우저 새로고침
# "Hello Docker!" 확인

# 8단계: 실시간 로그 보기
docker logs -f web-server
# 브라우저 새로고침하면서 로그 확인 (Ctrl+C로 종료)

# 9단계: 정리
docker stop web-server
docker rm web-server
```

### 🎓 실습 4: 볼륨을 사용한 Nginx

```bash
# 1단계: HTML 파일 준비
mkdir -p ~/docker-practice/html
echo "<h1>My Website</h1><p>Powered by Docker</p>" > ~/docker-practice/html/index.html

# 2단계: 볼륨 마운트하여 Nginx 실행
docker run -d \
  -p 8080:80 \
  --name web-with-volume \
  -v ~/docker-practice/html:/usr/share/nginx/html:ro \
  nginx

# 3단계: 브라우저 확인
# http://localhost:8080

# 4단계: 호스트에서 파일 수정
echo "<h1>Updated!</h1>" > ~/docker-practice/html/index.html

# 5단계: 브라우저 새로고침
# 즉시 반영됨! (컨테이너 재시작 불필요)

# 6단계: 정리
docker stop web-with-volume
docker rm web-with-volume
```

### 🎓 실습 5: 간단한 Node.js 앱

```bash
# 1단계: 프로젝트 디렉토리 생성
mkdir -p ~/docker-practice/nodejs-app
cd ~/docker-practice/nodejs-app

# 2단계: server.js 파일 생성
cat > server.js << 'EOF'
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/html'});
  res.end('<h1>Hello from Node.js in Docker!</h1>');
});

server.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
EOF

# 3단계: Node.js 컨테이너 실행
docker run -d \
  -p 3000:3000 \
  -v $(pwd):/app \
  -w /app \
  --name nodejs-app \
  node:16-alpine \
  node server.js

# 4단계: 확인
curl http://localhost:3000

# 5단계: 로그 확인
docker logs nodejs-app
Server running on http://localhost:3000

# 6단계: 코드 수정
cat > server.js << 'EOF'
const http = require('http');

const server = http.createServer((req, res) => {
  res.writeHead(200, {'Content-Type': 'text/html'});
  res.end('<h1>Updated App!</h1><p>Docker is awesome!</p>');
});

server.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
EOF

# 7단계: 컨테이너 재시작
docker restart nodejs-app

# 8단계: 확인
curl http://localhost:3000

# 9단계: 정리
docker stop nodejs-app
docker rm nodejs-app
```

### 🎓 실습 6: PostgreSQL 데이터베이스

```bash
# 1단계: PostgreSQL 실행
docker run -d \
  --name my-postgres \
  -e POSTGRES_PASSWORD=mysecretpassword \
  -e POSTGRES_USER=myuser \
  -e POSTGRES_DB=mydb \
  -v postgres-data:/var/lib/postgresql/data \
  -p 5432:5432 \
  postgres:13

# 2단계: 데이터베이스 접속
docker exec -it my-postgres psql -U myuser -d mydb

# 3단계: 테이블 생성
mydb=# CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

# 4단계: 데이터 입력
mydb=# INSERT INTO users (name, email) VALUES
    ('Alice', 'alice@example.com'),
    ('Bob', 'bob@example.com');

# 5단계: 데이터 조회
mydb=# SELECT * FROM users;

 id | name  |       email
----+-------+--------------------
  1 | Alice | alice@example.com
  2 | Bob   | bob@example.com

# 6단계: 종료
mydb=# \q

# 7단계: 컨테이너 재시작 (데이터 보존 확인)
docker restart my-postgres

# 8단계: 다시 접속하여 데이터 확인
docker exec -it my-postgres psql -U myuser -d mydb -c "SELECT * FROM users;"

# 데이터가 그대로 있음! ✅

# 9단계: 정리 (볼륨은 유지)
docker stop my-postgres
docker rm my-postgres

# 볼륨 확인
docker volume ls | grep postgres-data

# 완전 삭제 (볼륨 포함)
docker volume rm postgres-data
```

---

## ✅ 섹션 요약

### 핵심 명령어 치트시트

```bash
# 이미지
docker pull IMAGE              # 다운로드
docker push IMAGE              # 업로드
docker images                  # 목록
docker rmi IMAGE               # 삭제
docker tag SOURCE TARGET       # 태그

# 컨테이너
docker run IMAGE               # 생성+시작
docker start CONTAINER         # 시작
docker stop CONTAINER          # 중지
docker restart CONTAINER       # 재시작
docker rm CONTAINER            # 삭제
docker ps                      # 목록

# 상호작용
docker exec -it CONTAINER bash # 쉘 접속
docker logs CONTAINER          # 로그
docker inspect CONTAINER       # 상세 정보
docker cp SRC DST              # 파일 복사
docker stats                   # 리소스 사용량

# 시스템
docker system df               # 디스크 사용량
docker system prune            # 정리
docker info                    # 시스템 정보
docker version                 # 버전
```

### 자주 사용하는 조합

```bash
# 개발용 컨테이너
docker run -it --rm \
  -v $(pwd):/app \
  -w /app \
  -p 3000:3000 \
  node:16 bash

# 운영용 웹 서버
docker run -d \
  --name production-web \
  --restart=unless-stopped \
  -p 80:80 \
  -v /data/html:/usr/share/nginx/html:ro \
  --memory="1g" \
  --cpus="2" \
  nginx:latest

# 데이터베이스
docker run -d \
  --name db \
  --restart=always \
  -p 5432:5432 \
  -e POSTGRES_PASSWORD=secret \
  -v db-data:/var/lib/postgresql/data \
  --memory="2g" \
  postgres:13
```

### 다음 섹션 예고

```
섹션 5: Docker 이미지 이해하기
- 5.1 이미지란 무엇인가?
- 5.2 이미지 레이어 시스템
- 5.3 이미지 저장소 구조
- 5.4 베이스 이미지 선택 가이드
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 실수로 모든 컨테이너를 삭제했어요!

**상황**: 첫 출근 3일차, 개발 서버의 모든 컨테이너를 정리하려다가 실수로 중요한 컨테이너까지 삭제했습니다.

```bash
# ❌ 주니어 개발자가 실행한 명령어
docker rm -f $(docker ps -aq)

# 결과: 모든 컨테이너 강제 삭제!
# 팀장님의 데이터베이스 컨테이너도 삭제됨...
```

**문제점**:
- 문제 1: `-f` 옵션으로 실행 중인 컨테이너도 강제 삭제
- 문제 2: 필터 없이 모든 컨테이너 (`-aq`) 선택
- 문제 3: 데이터 백업 없이 삭제
- 왜 이 문제가 발생하는가: 명령어의 영향 범위를 확인하지 않음

**해결책**:
```bash
# ✅ 올바른 방법 1: 먼저 확인하기
docker ps -a  # 전체 컨테이너 확인

# ✅ 올바른 방법 2: 중지된 컨테이너만 삭제
docker container prune

WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N]  # 확인 메시지!

# ✅ 올바른 방법 3: 특정 컨테이너만 삭제
docker ps -a -f "status=exited" -f "name=test-*"
docker rm $(docker ps -aq -f "status=exited" -f "name=test-*")

# ✅ 올바른 방법 4: 볼륨은 보존하면서 삭제
docker rm container-name  # -v 옵션 없이

# 예방책: 중요한 컨테이너에 라벨 추가
docker run -d \
  --label environment=production \
  --label protect=true \
  --name db-prod \
  postgres:13
```

**배운 점**:
- 💡 팁 1: 삭제 명령어는 항상 먼저 조회로 확인
- 💡 팁 2: 프로덕션 환경에서는 `-f` 옵션 사용 자제
- 💡 팁 3: 중요한 데이터는 Named Volume에 저장
- 💡 팁 4: `prune` 명령어 사용 시 확인 메시지 꼭 읽기

### 시나리오 2: 포트가 이미 사용 중이라는 에러

**상황**: Nginx 컨테이너를 실행하려는데 "port is already allocated" 에러가 발생합니다.

```bash
# ❌ 주니어 개발자의 시도
docker run -d -p 80:80 nginx

Error: Bind for 0.0.0.0:80 failed: port is already allocated
```

**문제점**:
- 문제 1: 80번 포트를 이미 다른 프로세스가 사용 중
- 문제 2: 포트 충돌 확인 없이 바로 실행
- 문제 3: 기존 컨테이너 중복 실행 가능성

**해결책**:
```bash
# ✅ 단계 1: 포트 사용 중인 프로세스 확인
# Windows
netstat -ano | findstr :80

# Linux/Mac
lsof -i :80
sudo netstat -tulpn | grep :80

# ✅ 단계 2: Docker 컨테이너가 사용 중인지 확인
docker ps --format "table {{.Names}}\t{{.Ports}}" | grep 80

# ✅ 단계 3-1: 기존 컨테이너가 있다면 중지
docker stop old-nginx
docker rm old-nginx

# ✅ 단계 3-2: 다른 포트 사용
docker run -d -p 8080:80 --name nginx nginx

# ✅ 단계 3-3: 컨테이너 이름 중복 확인
docker ps -a -f "name=nginx"

# ✅ 올바른 워크플로우
# 1. 기존 컨테이너 확인
docker ps -a -f "name=web-server"

# 2. 있다면 삭제
docker rm -f web-server

# 3. 새로 실행
docker run -d -p 8080:80 --name web-server nginx
```

**배운 점**:
- 💡 팁 1: 포트 충돌 시 `docker ps`로 먼저 확인
- 💡 팁 2: 개발 환경에서는 8080, 8081 등 비표준 포트 사용
- 💡 팁 3: 컨테이너 이름을 명확하게 지정하여 관리
- 💡 팁 4: `--rm` 옵션으로 테스트 후 자동 삭제

### 시나리오 3: 컨테이너는 실행되는데 접속이 안 돼요

**상황**: 웹 서버 컨테이너가 실행 중인데 브라우저에서 접속이 되지 않습니다.

```bash
# ❌ 주니어 개발자의 상황
docker run -d --name web nginx
docker ps

CONTAINER ID   IMAGE   STATUS
abc123         nginx   Up 2 minutes

# 브라우저에서 localhost:80 접속 → 연결 거부!
```

**문제점**:
- 문제 1: 포트 매핑을 하지 않음 (`-p` 옵션 누락)
- 문제 2: 컨테이너 내부 포트와 호스트 포트 혼동
- 문제 3: 방화벽이나 네트워크 문제 미확인

**해결책**:
```bash
# ✅ 단계 1: 포트 매핑 확인
docker ps --format "table {{.Names}}\t{{.Ports}}"

NAMES   PORTS
web     80/tcp  # ← 호스트 포트 매핑 없음!

# ✅ 단계 2: 올바르게 재시작
docker stop web
docker rm web
docker run -d -p 8080:80 --name web nginx

# ✅ 단계 3: 포트 매핑 재확인
docker ps

PORTS
0.0.0.0:8080->80/tcp  # ✅ 호스트 8080 → 컨테이너 80

# ✅ 단계 4: 컨테이너 로그 확인
docker logs web

# ✅ 단계 5: 컨테이너 내부에서 테스트
docker exec web curl http://localhost:80

# ✅ 단계 6: 호스트에서 테스트
curl http://localhost:8080

# ✅ 단계 7: 방화벽 확인 (Linux)
sudo ufw status
sudo firewall-cmd --list-all

# ✅ 디버깅 체크리스트
echo "1. 포트 매핑 확인"
docker port web

echo "2. 컨테이너 로그 확인"
docker logs web --tail 20

echo "3. 컨테이너 프로세스 확인"
docker exec web ps aux

echo "4. 네트워크 설정 확인"
docker inspect web | grep IPAddress
```

**배운 점**:
- 💡 팁 1: `-p` 옵션 없으면 외부 접속 불가
- 💡 팁 2: `docker ps`의 PORTS 컬럼 항상 확인
- 💡 팁 3: `docker logs`로 애플리케이션 에러 확인
- 💡 팁 4: `docker exec`로 컨테이너 내부 테스트

### 시나리오 4: 디스크 용량이 부족해요

**상황**: 개발 서버의 디스크 용량이 부족하다는 경고가 발생했습니다.

```bash
# ❌ 주니어 개발자의 상황
df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1       50G   48G   2G  96% /

# Docker가 용량을 너무 많이 차지하고 있음!
```

**문제점**:
- 문제 1: 사용하지 않는 이미지/컨테이너 방치
- 문제 2: dangling 이미지 누적
- 문제 3: 로그 파일 무제한 증가
- 문제 4: 불필요한 볼륨 미삭제

**해결책**:
```bash
# ✅ 단계 1: Docker 디스크 사용량 확인
docker system df

TYPE            TOTAL   ACTIVE   SIZE      RECLAIMABLE
Images          50      5        25GB      20GB (80%)  # ← 회수 가능!
Containers      30      3        5GB       4.5GB (90%)
Local Volumes   20      2        10GB      8GB (80%)
Build Cache     0       0        8GB       8GB (100%)

# ✅ 단계 2: 상세 정보 확인
docker system df -v

# ✅ 단계 3: 안전하게 정리 (dangling만)
docker image prune

Deleted Images:
Total reclaimed space: 8.2GB

# ✅ 단계 4: 중지된 컨테이너 삭제
docker container prune

Total reclaimed space: 4.5GB

# ✅ 단계 5: 사용하지 않는 볼륨 삭제
docker volume prune

Total reclaimed space: 8GB

# ✅ 단계 6: 네트워크 정리
docker network prune

# ✅ 단계 7: 전체 정리 (주의!)
docker system prune -a

WARNING! This will remove:
- all stopped containers
- all networks not used by at least one container
- all images without at least one container associated to them
- all build cache

Total reclaimed space: 20.7GB

# ✅ 예방책 1: 로그 크기 제한
docker run -d \
  --log-opt max-size=10m \
  --log-opt max-file=3 \
  nginx

# ✅ 예방책 2: 임시 컨테이너는 --rm 사용
docker run --rm -it ubuntu bash

# ✅ 예방책 3: 정기적인 정리 스크립트
cat > /etc/cron.weekly/docker-cleanup.sh << 'EOF'
#!/bin/bash
# 매주 일요일 새벽 3시 실행
docker system prune -f --filter "until=168h"
EOF
chmod +x /etc/cron.weekly/docker-cleanup.sh

# ✅ 예방책 4: 오래된 이미지만 삭제
docker image prune -a --filter "until=720h"  # 30일 이전
```

**배운 점**:
- 💡 팁 1: `docker system df`로 정기적으로 용량 모니터링
- 💡 팁 2: 개발 중에는 `--rm` 옵션 습관화
- 💡 팁 3: 로그 크기 제한 설정 필수
- 💡 팁 4: 주기적인 자동 정리 스크립트 작성

---

## ❓ FAQ

<details>
<summary><strong>Q1: docker run과 docker start의 차이가 뭔가요?</strong></summary>

**A**: `docker run`은 **새 컨테이너를 생성**하고 시작하는 반면, `docker start`는 **기존 컨테이너를 재시작**합니다.

**상세 설명**:
- `docker run`: 이미지 → 새 컨테이너 생성 → 시작
- `docker start`: 중지된 기존 컨테이너 → 시작

**예시**:
```bash
# 첫 실행 (run 사용)
docker run -d --name web nginx
# → 새 컨테이너 'web' 생성 및 시작

# 중지
docker stop web

# 재시작 (start 사용)
docker start web
# → 기존 컨테이너 'web' 재시작

# 만약 run을 다시 사용하면?
docker run -d --name web nginx
# → 에러! 'web'이라는 이름이 이미 존재
```

**실무 팁**:
💡 **처음 실행**: `docker run`
💡 **재시작**: `docker start`
💡 **설정 변경 필요**: 기존 컨테이너 삭제 후 새로 `docker run`

</details>

<details>
<summary><strong>Q2: 컨테이너를 삭제하면 데이터도 사라지나요?</strong></summary>

**A**: 컨테이너 내부에 저장된 데이터는 **삭제되지만**, Named Volume에 저장된 데이터는 **보존됩니다**.

**상세 설명**:
- 컨테이너 파일 시스템: 삭제 시 모두 사라짐
- Named Volume: 컨테이너 삭제 후에도 유지
- Bind Mount: 호스트 파일이므로 당연히 유지

**예시**:
```bash
# ❌ 데이터 사라지는 경우
docker run -d --name db postgres:13
# 컨테이너 내부에 데이터 저장
docker rm -f db
# → 데이터 모두 삭제됨!

# ✅ 데이터 보존하는 경우
docker run -d \
  --name db \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:13
# Named Volume에 데이터 저장

docker rm -f db
# → 컨테이너는 삭제되지만
docker volume ls
# postgres-data 볼륨은 그대로 유지!

# 동일한 볼륨으로 다시 생성하면 데이터 복구
docker run -d \
  --name db-new \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:13
# → 이전 데이터 그대로 사용 가능!
```

**실무 팁**:
💡 중요한 데이터는 **반드시 Named Volume** 사용
💡 `docker rm -v` 옵션 사용 시 볼륨도 함께 삭제되므로 주의

</details>

<details>
<summary><strong>Q3: docker exec과 docker attach의 차이는 무엇인가요?</strong></summary>

**A**: `docker exec`은 **새 프로세스를 실행**하고, `docker attach`는 **메인 프로세스에 연결**합니다.

**상세 설명**:
- `exec`: 새로운 bash 프로세스 시작, exit해도 컨테이너 유지
- `attach`: PID 1 프로세스에 연결, Ctrl+C 하면 컨테이너 종료!

**비교 예시**:
```bash
# docker exec (안전, 권장)
docker exec -it nginx bash
root@abc123:/# exit  # ← 컨테이너는 계속 실행됨

# docker attach (위험)
docker attach nginx
# Ctrl+C 누르면 → nginx 프로세스 종료 → 컨테이너 정지!

# 안전하게 detach하려면
# Ctrl+P, Ctrl+Q (순서대로 입력)
```

**실무 팁**:
💡 **일반적인 경우**: `docker exec -it` 사용
💡 **로그 실시간 확인**: `docker logs -f` 사용
💡 **attach 사용 금지**: 실수로 컨테이너 종료 위험

</details>

<details>
<summary><strong>Q4: 이미지와 컨테이너를 한꺼번에 삭제하는 방법이 있나요?</strong></summary>

**A**: `docker system prune`을 사용하면 사용하지 않는 모든 리소스를 한 번에 정리할 수 있습니다.

**상세 설명**:
```bash
# 기본 정리 (중지된 컨테이너, dangling 이미지, 사용 안 하는 네트워크)
docker system prune

# 모든 사용하지 않는 이미지까지 정리
docker system prune -a

# 볼륨까지 모두 정리
docker system prune -a --volumes

# 확인 없이 바로 실행
docker system prune -a -f

# 특정 기간 이전 것만 삭제
docker system prune -a --filter "until=24h"  # 24시간 이전
docker system prune -a --filter "until=168h"  # 1주일 이전
```

**실무 팁**:
💡 개발 환경: 주기적으로 `docker system prune -a` 실행
💡 프로덕션 환경: `--filter` 옵션으로 신중하게 삭제
💡 볼륨 삭제: `--volumes` 옵션 사용 시 **매우 주의**

</details>

<details>
<summary><strong>Q5: 실행 중인 컨테이너의 환경 변수를 변경할 수 있나요?</strong></summary>

**A**: **불가능합니다**. 환경 변수는 컨테이너 생성 시에만 설정 가능하며, 변경하려면 컨테이너를 재생성해야 합니다.

**상세 설명**:
```bash
# ❌ 불가능한 방법
docker exec my-app export NEW_VAR=value  # 효과 없음!

# ✅ 올바른 방법 1: 컨테이너 재생성
docker stop my-app
docker rm my-app
docker run -d \
  --name my-app \
  -e DATABASE_URL=new-value \
  -e API_KEY=new-key \
  myapp:latest

# ✅ 올바른 방법 2: 환경 변수 파일 사용
cat > .env << EOF
DATABASE_URL=postgres://localhost:5432/db
API_KEY=secret-key
DEBUG=true
EOF

docker run -d --name my-app --env-file .env myapp:latest

# ✅ 올바른 방법 3: 설정 파일 마운트
# 애플리케이션이 파일에서 설정 읽도록 변경
docker run -d \
  --name my-app \
  -v $(pwd)/config.yml:/app/config.yml \
  myapp:latest

# config.yml 파일만 수정 후 재시작
docker restart my-app
```

**실무 팁**:
💡 환경 변수가 자주 바뀌면 **설정 파일 마운트** 방식 사용
💡 `.env` 파일로 환경 변수 관리
💡 민감한 정보는 Docker Secrets 또는 환경 변수 관리 도구 사용

</details>

<details>
<summary><strong>Q6: docker logs로 로그를 보는데 너무 많아요. 어떻게 하나요?</strong></summary>

**A**: `--tail`, `--since`, `--until` 옵션을 활용하여 필요한 부분만 확인할 수 있습니다.

**상세 설명**:
```bash
# 최근 100줄만 보기
docker logs --tail 100 my-app

# 최근 10분간의 로그
docker logs --since 10m my-app

# 특정 시간 이후
docker logs --since "2024-01-15T10:00:00" my-app

# 특정 시간 범위
docker logs \
  --since "2024-01-15T09:00:00" \
  --until "2024-01-15T10:00:00" \
  my-app

# 실시간 로그 (최근 50줄부터)
docker logs -f --tail 50 my-app

# 타임스탬프 포함
docker logs -t --tail 100 my-app

# grep과 조합
docker logs my-app 2>&1 | grep ERROR
docker logs my-app 2>&1 | grep -i "exception"

# 로그를 파일로 저장
docker logs my-app > app.log
docker logs --since 1h my-app > last-hour.log

# 실시간 에러만 모니터링
docker logs -f my-app 2>&1 | grep --line-buffered -i error
```

**실무 팁**:
💡 로그가 많을 때: `--tail 100` 으로 최근 것만
💡 특정 에러 찾기: `grep` 활용
💡 로그 크기 제한: `--log-opt max-size=10m` 설정

</details>

<details>
<summary><strong>Q7: 컨테이너 간 통신은 어떻게 하나요?</strong></summary>

**A**: 동일한 Docker 네트워크에 연결하면 **컨테이너 이름으로 통신**할 수 있습니다.

**상세 설명**:
```bash
# ✅ 방법 1: 커스텀 네트워크 생성 (권장)
# 1. 네트워크 생성
docker network create my-network

# 2. 컨테이너들을 같은 네트워크에 연결
docker run -d \
  --name db \
  --network my-network \
  postgres:13

docker run -d \
  --name backend \
  --network my-network \
  -e DATABASE_URL=postgresql://db:5432/mydb \
  myapp:latest

# backend에서 'db'라는 이름으로 접근 가능!

# ✅ 방법 2: 기본 bridge 네트워크 (비권장)
docker run -d --name db postgres:13
docker run -d --name backend --link db myapp:latest
# --link는 deprecated되었으므로 사용 지양

# ✅ 방법 3: host 네트워크 사용
docker run -d --network host nginx
# localhost로 직접 통신

# ✅ 확인 방법
# 네트워크 내 컨테이너 확인
docker network inspect my-network

# 컨테이너 간 통신 테스트
docker exec backend ping db
docker exec backend curl http://db:5432
```

**예시 - 웹 + DB 구성**:
```bash
# 1. 네트워크 생성
docker network create app-network

# 2. PostgreSQL 실행
docker run -d \
  --name postgres-db \
  --network app-network \
  -e POSTGRES_PASSWORD=secret \
  postgres:13

# 3. Node.js 앱 실행
docker run -d \
  --name nodejs-backend \
  --network app-network \
  -e DB_HOST=postgres-db \
  -e DB_PORT=5432 \
  -p 3000:3000 \
  myapp:latest

# Node.js 앱에서 연결 코드:
# const client = new Client({
#   host: 'postgres-db',  // ← 컨테이너 이름!
#   port: 5432,
#   database: 'mydb'
# });
```

**실무 팁**:
💡 항상 **커스텀 네트워크** 생성 후 사용
💡 컨테이너 이름이 **DNS 이름**으로 자동 등록
💡 Docker Compose 사용하면 자동으로 네트워크 구성

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. docker run과 docker start의 차이를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- `docker run`: 이미지로부터 새 컨테이너를 생성하고 시작
- `docker start`: 중지된 기존 컨테이너를 재시작
- `docker run` = `docker create` + `docker start`

**예시 답변**
> "docker run은 이미지를 기반으로 새로운 컨테이너를 생성하고 시작하는 명령어입니다. 반면 docker start는 이미 생성되어 있지만 중지된 컨테이너를 다시 시작할 때 사용합니다. 예를 들어, 처음 nginx를 실행할 때는 'docker run nginx'를 사용하지만, 한 번 중지했다가 다시 실행할 때는 'docker start [컨테이너명]'을 사용합니다."

**꼬리 질문**
- Q: docker create는 언제 사용하나요?
- A: 컨테이너를 생성만 하고 시작하지 않을 때 사용합니다. 설정을 미리 준비해두고 나중에 start로 실행하는 경우입니다.

**실무 연관**
- 개발 환경에서 컨테이너를 자주 재시작할 때 start 사용
- CI/CD 파이프라인에서는 항상 run으로 새로 생성

</details>

<details>
<summary><strong>2. docker exec과 docker attach의 차이는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- `docker exec`: 실행 중인 컨테이너에서 새로운 프로세스 실행
- `docker attach`: 컨테이너의 메인 프로세스(PID 1)에 연결
- exec은 exit해도 안전, attach는 Ctrl+C 하면 컨테이너 종료

**예시 답변**
> "docker exec은 실행 중인 컨테이너 내부에서 새로운 명령어나 프로세스를 실행하는 명령어입니다. 주로 'docker exec -it container bash'처럼 쉘에 접속할 때 사용합니다. docker attach는 컨테이너의 메인 프로세스에 직접 연결하는 것으로, Ctrl+C를 누르면 메인 프로세스가 종료되어 컨테이너가 멈출 수 있어 위험합니다. 실무에서는 거의 항상 docker exec을 사용합니다."

**꼬리 질문**
- Q: attach를 안전하게 빠져나오는 방법은?
- A: Ctrl+P, Ctrl+Q를 순서대로 입력하면 컨테이너를 종료하지 않고 detach할 수 있습니다.

**실무 연관**
- 디버깅 시 docker exec으로 컨테이너 내부 진입
- 로그 확인은 docker logs 사용, attach는 사용 지양

</details>

<details>
<summary><strong>3. docker rm과 docker rmi의 차이를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- `docker rm`: 컨테이너 삭제
- `docker rmi`: 이미지 삭제
- 이미지를 삭제하려면 먼저 해당 이미지를 사용하는 컨테이너를 삭제해야 함

**예시 답변**
> "docker rm은 컨테이너를 삭제하는 명령어이고, docker rmi는 이미지를 삭제하는 명령어입니다. rm은 remove의 약자, rmi는 remove image의 약자입니다. 중요한 점은 이미지를 삭제하려면 해당 이미지로 만든 컨테이너를 먼저 삭제해야 한다는 것입니다. 또는 -f 옵션으로 강제 삭제할 수 있습니다."

**꼬리 질문**
- Q: 컨테이너를 삭제하면 데이터도 사라지나요?
- A: 컨테이너 내부 파일 시스템의 데이터는 사라지지만, Named Volume에 저장된 데이터는 유지됩니다.

**실무 연관**
- 디스크 공간 관리 시 불필요한 컨테이너와 이미지 정리
- docker system prune으로 한 번에 정리 가능

</details>

<details>
<summary><strong>4. docker ps와 docker ps -a의 차이는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- `docker ps`: 현재 **실행 중인** 컨테이너만 표시
- `docker ps -a`: **모든** 컨테이너 표시 (중지된 것 포함)
- `-a`는 --all의 약자

**예시 답변**
> "docker ps는 현재 실행 중인 컨테이너만 보여줍니다. docker ps -a는 중지된 컨테이너까지 모두 보여주는 옵션입니다. 실무에서 컨테이너가 시작되지 않는 문제를 디버깅할 때는 docker ps -a로 전체 컨테이너 상태를 확인하고, docker logs로 중지된 컨테이너의 로그를 확인합니다."

**꼬리 질문**
- Q: 중지된 컨테이너를 모두 삭제하는 방법은?
- A: docker container prune 또는 docker rm $(docker ps -aq -f status=exited)를 사용합니다.

**실무 연관**
- 문제 해결 시 -a 옵션으로 전체 상태 파악
- 정기적으로 중지된 컨테이너 정리 필요

</details>

<details>
<summary><strong>5. docker run의 -d 옵션은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- `-d`: detached mode, 백그라운드 실행
- 터미널을 점유하지 않고 컨테이너 실행
- 서버 애플리케이션은 주로 -d 옵션 사용

**예시 답변**
> "-d 옵션은 detached mode의 약자로, 컨테이너를 백그라운드에서 실행하는 옵션입니다. 이 옵션을 사용하면 터미널이 컨테이너에 묶이지 않고 바로 프롬프트로 돌아옵니다. 웹 서버나 데이터베이스처럼 계속 실행되어야 하는 서비스는 -d 옵션을 사용하고, 대화형 작업이 필요한 경우에는 -it 옵션을 사용합니다."

**꼬리 질문**
- Q: -d 옵션으로 실행한 컨테이너의 로그는 어떻게 보나요?
- A: docker logs 명령어를 사용하고, 실시간 로그는 docker logs -f를 사용합니다.

**실무 연관**
- 프로덕션 환경의 모든 서비스는 -d로 실행
- -it는 개발/디버깅용, -d는 운영용

</details>

<details>
<summary><strong>6. docker logs 명령어에 대해 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 컨테이너의 STDOUT/STDERR 출력 확인
- `-f` 옵션으로 실시간 로그 스트리밍
- `--tail`, `--since` 옵션으로 필터링 가능

**예시 답변**
> "docker logs는 컨테이너가 출력한 로그를 확인하는 명령어입니다. 컨테이너의 표준 출력(STDOUT)과 표준 에러(STDERR)를 보여줍니다. -f 옵션을 사용하면 실시간으로 로그를 볼 수 있고, --tail 100 옵션으로 최근 100줄만 볼 수도 있습니다. 애플리케이션 문제 해결 시 가장 먼저 확인하는 명령어입니다."

**꼬리 질문**
- Q: 로그가 너무 많을 때 특정 에러만 찾는 방법은?
- A: docker logs container | grep ERROR 처럼 grep과 조합하거나, --since 옵션으로 특정 시간 이후 로그만 확인합니다.

**실무 연관**
- 장애 대응 시 가장 먼저 사용하는 명령어
- 로그 크기 제한 설정으로 디스크 관리 필요

</details>

<details>
<summary><strong>7. docker system prune은 무엇을 삭제하나요?</strong></summary>

**모범 답안 포인트**
- 중지된 모든 컨테이너
- 사용하지 않는 네트워크
- dangling 이미지 (태그가 없는 이미지)
- `-a` 옵션: 사용하지 않는 모든 이미지까지

**예시 답변**
> "docker system prune은 사용하지 않는 Docker 리소스를 정리하는 명령어입니다. 기본적으로 중지된 컨테이너, 사용하지 않는 네트워크, dangling 이미지를 삭제합니다. -a 옵션을 추가하면 현재 컨테이너가 사용하지 않는 모든 이미지까지 삭제합니다. 디스크 공간이 부족할 때 유용하지만, 프로덕션 환경에서는 신중하게 사용해야 합니다."

**꼬리 질문**
- Q: 볼륨도 함께 삭제할 수 있나요?
- A: --volumes 옵션을 추가하면 사용하지 않는 볼륨도 삭제됩니다. 하지만 데이터 손실 위험이 있어 매우 주의해야 합니다.

**실무 연관**
- 개발 환경에서 주기적으로 실행
- CI/CD 서버에서 빌드 후 자동 정리

</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. docker run의 --restart 정책에 대해 설명하고, 각 정책의 차이를 비교해주세요.</strong></summary>

**모범 답안 포인트**
- `no`: 재시작 안 함 (기본값)
- `always`: 항상 재시작
- `unless-stopped`: 명시적으로 중지하지 않는 한 재시작
- `on-failure`: 에러 종료 시에만 재시작

**예시 답변**
> "Docker의 재시작 정책은 컨테이너가 종료되었을 때 자동으로 재시작할지를 결정합니다. 'no'는 기본값으로 재시작하지 않습니다. 'always'는 컨테이너가 어떤 이유로든 종료되면 항상 재시작하며, Docker 데몬 재시작 시에도 자동으로 시작됩니다. 'unless-stopped'는 always와 유사하지만, 사용자가 명시적으로 중지한 컨테이너는 Docker 재시작 시에도 시작하지 않습니다. 'on-failure'는 exit code가 0이 아닌 경우(에러)에만 재시작하며, 최대 재시도 횟수를 설정할 수 있습니다."

**실무 예시**
```bash
# 프로덕션 웹 서버 - always
docker run -d --restart=always nginx

# 개발 환경 - unless-stopped
docker run -d --restart=unless-stopped myapp:dev

# 배치 작업 - on-failure
docker run -d --restart=on-failure:3 batch-job
```

**꼬리 질문**
- Q: always와 unless-stopped의 실무적 차이는?
- A: 개발 중 컨테이너를 의도적으로 멈췄다면, Docker 재시작 시 자동으로 다시 시작되지 않도록 unless-stopped를 사용합니다. 프로덕션에서는 always를 사용하여 완전 자동화합니다.

**실무 연관**
- 프로덕션: always 또는 unless-stopped
- 배치 작업: on-failure:3
- 개발/테스트: no (기본값)

</details>

<details>
<summary><strong>2. docker inspect 명령어의 활용 방법과 실무에서 자주 사용하는 정보 추출 방법을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 컨테이너/이미지의 모든 메타데이터를 JSON 형식으로 출력
- `-f` 옵션으로 Go 템플릿 문법을 사용한 필터링
- 네트워크 IP, 포트 매핑, 환경 변수, 볼륨 등 확인 가능

**예시 답변**
> "docker inspect는 컨테이너나 이미지의 상세 정보를 JSON 형식으로 출력하는 명령어입니다. -f 옵션과 Go 템플릿 문법을 사용하면 필요한 정보만 추출할 수 있습니다. 실무에서는 주로 컨테이너 IP 주소, 포트 매핑, 환경 변수, 볼륨 마운트 정보를 확인할 때 사용합니다."

**실무 예시**
```bash
# IP 주소 확인
docker inspect -f '{{.NetworkSettings.IPAddress}}' web

# 포트 매핑 확인
docker inspect -f '{{.NetworkSettings.Ports}}' web

# 환경 변수 확인
docker inspect -f '{{.Config.Env}}' web

# 볼륨 마운트 확인
docker inspect -f '{{json .Mounts}}' web | jq

# 재시작 횟수 확인
docker inspect -f '{{.RestartCount}}' web

# 스크립트에서 활용
for container in $(docker ps -q); do
  echo "$(docker inspect -f '{{.Name}}' $container): \
        $(docker inspect -f '{{.NetworkSettings.IPAddress}}' $container)"
done
```

**꼬리 질문**
- Q: jq를 사용하는 이유는?
- A: JSON 데이터를 더 보기 좋게 포맷팅하고, 복잡한 필터링을 수행하기 위해 사용합니다.

**실무 연관**
- 네트워크 문제 디버깅 시 IP 확인
- 자동화 스크립트에서 컨테이너 정보 추출
- 설정 검증 및 문서화

</details>

<details>
<summary><strong>3. docker stats와 모니터링 도구 연계에 대해 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 실시간 리소스 사용량 모니터링 (CPU, 메모리, 네트워크, I/O)
- 스트림 모드와 스냅샷 모드
- 프로덕션에서는 Prometheus + Grafana 같은 전문 도구 사용

**예시 답변**
> "docker stats는 실행 중인 컨테이너의 CPU, 메모리, 네트워크, 디스크 I/O 사용량을 실시간으로 보여주는 명령어입니다. 기본적으로 실시간 스트림 모드로 동작하며, --no-stream 옵션으로 현재 상태만 출력할 수 있습니다. 개발 환경에서는 docker stats로 충분하지만, 프로덕션에서는 Prometheus로 메트릭을 수집하고 Grafana로 시각화하는 것이 일반적입니다."

**실무 예시**
```bash
# 실시간 모니터링
docker stats

# 한 번만 출력
docker stats --no-stream

# 특정 컨테이너만
docker stats web db redis

# 커스텀 포맷
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

# 스크립트로 임계값 모니터링
docker stats --no-stream --format "{{.Container}},{{.CPUPerc}}" | \
  awk -F, '$2+0 > 80 {print $1 " is using too much CPU: " $2}'
```

**꼬리 질문**
- Q: 메모리 사용량이 제한을 초과하면 어떻게 되나요?
- A: 컨테이너가 OOM Killed되어 종료됩니다. --memory 옵션으로 제한을 설정하고, --oom-kill-disable 옵션으로 OOM Kill을 방지할 수 있지만 권장하지 않습니다.

**실무 연관**
- 성능 문제 디버깅
- 리소스 제한 설정 검증
- Prometheus + cAdvisor 연계

</details>

<details>
<summary><strong>4. docker cp와 볼륨 마운트의 차이, 그리고 각각의 사용 사례를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- `docker cp`: 일회성 파일 복사
- 볼륨 마운트: 지속적인 동기화
- 사용 사례가 명확히 구분됨

**예시 답변**
> "docker cp는 호스트와 컨테이너 간에 파일을 일회성으로 복사하는 명령어입니다. 컨테이너가 실행 중이거나 중지된 상태에서도 사용할 수 있습니다. 반면 볼륨 마운트는 호스트의 디렉토리를 컨테이너에 연결하여 실시간으로 동기화합니다. docker cp는 로그 파일 추출, 설정 파일 임시 수정 등 일회성 작업에 사용하고, 볼륨 마운트는 소스 코드 개발, 데이터 지속성 보장 등 지속적인 동기화가 필요한 경우에 사용합니다."

**실무 예시**
```bash
# docker cp - 일회성 작업
# 1. 로그 파일 추출
docker cp web:/var/log/nginx/error.log ./error.log

# 2. 설정 파일 임시 수정
docker cp new-config.yml app:/app/config.yml
docker restart app

# 3. 빌드 산출물 추출
docker cp builder:/app/dist ./dist

# 볼륨 마운트 - 지속적 동기화
# 1. 개발 환경
docker run -d \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/config:/app/config \
  nodejs:dev

# 2. 데이터 지속성
docker run -d \
  -v postgres-data:/var/lib/postgresql/data \
  postgres:13

# 3. 로그 수집
docker run -d \
  -v /var/log/app:/app/logs \
  myapp
```

**꼬리 질문**
- Q: 실행 중인 컨테이너에 docker cp로 파일을 복사하면 자동으로 적용되나요?
- A: 파일 시스템에는 즉시 반영되지만, 애플리케이션이 파일을 다시 읽어야 적용됩니다. 필요시 docker restart 또는 특정 시그널을 전송해야 합니다.

**실무 연관**
- 개발: 볼륨 마운트로 실시간 코드 수정
- 운영: docker cp로 긴급 설정 변경
- 디버깅: docker cp로 로그 파일 추출

</details>

<details>
<summary><strong>5. Docker 이미지 레이어와 캐싱 메커니즘에 대해 설명하고, 이를 활용한 빌드 최적화 방법을 제시해주세요.</strong></summary>

**모범 답안 포인트**
- 이미지는 여러 레이어로 구성됨
- 각 Dockerfile 명령어가 새로운 레이어 생성
- 레이어 캐싱으로 빌드 속도 향상
- 변경이 적은 레이어를 먼저 배치

**예시 답변**
> "Docker 이미지는 여러 레이어가 쌓인 형태로 구성됩니다. Dockerfile의 각 명령어(RUN, COPY 등)가 새로운 레이어를 생성하며, 레이어는 읽기 전용으로 캐싱됩니다. 이전 빌드와 동일한 레이어는 캐시를 재사용하여 빌드 시간을 크게 단축할 수 있습니다. 최적화를 위해서는 변경 빈도가 낮은 레이어(OS 패키지, 의존성)를 먼저 배치하고, 자주 변경되는 소스 코드는 나중에 배치해야 합니다."

**실무 예시**
```dockerfile
# ❌ 비효율적인 Dockerfile
FROM node:16
WORKDIR /app
COPY . .                    # 소스 코드 전체 복사 (자주 변경됨)
RUN npm install             # 의존성 설치 (가끔 변경됨)
CMD ["npm", "start"]

# ✅ 최적화된 Dockerfile
FROM node:16
WORKDIR /app
COPY package*.json ./       # 의존성 정보만 먼저 복사
RUN npm install             # 의존성 설치 (캐시 활용 가능)
COPY . .                    # 소스 코드는 나중에 복사
CMD ["npm", "start"]

# 레이어 확인
docker history myapp:latest

# 멀티스테이지 빌드로 최적화
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM node:16-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/index.js"]
```

**꼬리 질문**
- Q: BuildKit을 사용하면 어떤 이점이 있나요?
- A: 병렬 빌드, 더 나은 캐싱, 빌드 시크릿 관리 등의 기능을 제공하여 빌드 성능과 보안이 향상됩니다.

**실무 연관**
- CI/CD 파이프라인 빌드 시간 단축
- 개발자 생산성 향상
- 이미지 크기 최적화

</details>

---

## 🎉 축하합니다!

**Docker 기본 명령어 마스터 완료!**

**이제 여러분은**:
✅ Docker의 모든 핵심 명령어를 이해하고 사용할 수 있습니다
✅ 이미지와 컨테이너를 자유자재로 관리할 수 있습니다
✅ 컨테이너 디버깅과 문제 해결을 할 수 있습니다
✅ 실무에서 Docker를 효율적으로 활용할 수 있습니다
✅ 면접에서 Docker 명령어 질문에 자신있게 답변할 수 있습니다

**다음 단계**:
- [ ] 다음 장: Dockerfile 작성 마스터
- [ ] 실전 프로젝트: 멀티 컨테이너 앱 배포
- [ ] 면접 질문 복습 및 실습

**💡 실무 팁 정리**:
```bash
# 매일 사용할 필수 명령어 TOP 10
1. docker ps -a              # 전체 컨테이너 확인
2. docker logs -f            # 실시간 로그 확인
3. docker exec -it bash      # 컨테이너 접속
4. docker run -d -p          # 서비스 시작
5. docker stop/start         # 컨테이너 제어
6. docker rm -f              # 컨테이너 삭제
7. docker images             # 이미지 목록
8. docker system df          # 디스크 사용량
9. docker system prune       # 리소스 정리
10. docker inspect           # 상세 정보 확인
```

**🎯 다음 학습 목표**:
- Dockerfile 작성법 마스터
- 멀티스테이지 빌드 활용
- Docker Compose로 멀티 컨테이너 관리
- 이미지 최적화 기법

---

**다음 장으로 이동**: [다음: 7장 Dockerfile 작성 →](07-dockerfile.md)

**이전 장으로 돌아가기**: [← 이전: 5장 Docker 아키텍처](05-architecture.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)

---

**명령어 마스터 완료! 이제 Docker를 자유자재로 다룰 수 있습니다!** 🎉

**다음 섹션에서 만나요!** 👋