# 18-2. 추상 클래스 Part 2: 기업 사례 및 주니어 개발자 시나리오

## 📚 기업 사례 (Company Case Studies)

실제 기업과 프레임워크에서 추상 클래스가 어떻게 활용되는지 살펴보겠습니다.

---

## 🏢 기업 사례 1: Spring Framework의 AbstractController

### 📖 개요
Spring Framework는 웹 애플리케이션 개발에서 가장 널리 사용되는 Java 프레임워크입니다. Spring MVC에서는 `AbstractController`라는 추상 클래스를 제공하여 컨트롤러의 공통 기능을 구현하고, 개발자가 필수적인 비즈니스 로직만 구현하도록 설계되어 있습니다.

### 💡 왜 추상 클래스를 사용했을까?
- **공통 기능 제공**: 모든 컨트롤러에서 필요한 요청 처리, 세션 관리, 캐시 제어 등의 공통 기능을 부모 클래스에서 구현
- **템플릿 메서드 패턴**: 요청 처리 흐름을 부모에서 정의하고, 실제 비즈니스 로직만 자식 클래스에서 구현
- **일관성 보장**: 모든 컨트롤러가 동일한 방식으로 요청을 처리하도록 강제

### 💻 실제 코드 구현

```java
// Spring Framework의 AbstractController 패턴을 단순화한 예제

import java.util.*;

/**
 * 추상 컨트롤러 - Spring의 AbstractController를 단순화한 버전
 */
public abstract class AbstractController {

    // 컨트롤러 설정
    private boolean supportsCaching = false;
    private int cacheSeconds = 0;
    private boolean requireSession = false;

    /**
     * HTTP 요청을 처리하는 메인 메서드 (Template Method)
     * 이 메서드는 final로 선언하여 하위 클래스에서 오버라이드할 수 없게 함
     */
    public final ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)
            throws Exception {

        System.out.println("\n========== 요청 처리 시작 ==========");

        // 1단계: 세션 체크
        if (requireSession && !checkSession(request)) {
            response.sendError(401, "세션이 필요합니다");
            return null;
        }

        // 2단계: 캐시 설정
        if (supportsCaching) {
            applyCacheControl(response);
        }

        // 3단계: 요청 전처리
        if (!preHandle(request, response)) {
            System.out.println("전처리에서 요청이 거부되었습니다");
            return null;
        }

        // 4단계: 실제 비즈니스 로직 실행 (추상 메서드 - 하위 클래스에서 구현)
        ModelAndView modelAndView = handleRequestInternal(request, response);

        // 5단계: 후처리
        postHandle(request, response, modelAndView);

        System.out.println("========== 요청 처리 완료 ==========\n");

        return modelAndView;
    }

    /**
     * 추상 메서드: 실제 비즈니스 로직을 처리하는 메서드
     * 하위 클래스에서 반드시 구현해야 함
     */
    protected abstract ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response
    ) throws Exception;

    /**
     * Hook 메서드: 요청 전처리 (필요시 하위 클래스에서 오버라이드)
     */
    protected boolean preHandle(HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        System.out.println("[전처리] 기본 전처리 로직 실행");
        return true; // true를 반환하면 계속 진행, false면 중단
    }

    /**
     * Hook 메서드: 요청 후처리 (필요시 하위 클래스에서 오버라이드)
     */
    protected void postHandle(HttpServletRequest request, HttpServletResponse response,
                            ModelAndView modelAndView) throws Exception {
        System.out.println("[후처리] 기본 후처리 로직 실행");
    }

    /**
     * 세션 체크
     */
    private boolean checkSession(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        if (session == null) {
            System.out.println("[세션 체크] 세션이 존재하지 않습니다");
            return false;
        }
        System.out.println("[세션 체크] 세션 ID: " + session.getId());
        return true;
    }

    /**
     * 캐시 제어 헤더 설정
     */
    private void applyCacheControl(HttpServletResponse response) {
        response.setHeader("Cache-Control", "max-age=" + cacheSeconds);
        System.out.println("[캐시 설정] 캐시 시간: " + cacheSeconds + "초");
    }

    // Setter 메서드들
    public void setSupportsCaching(boolean supportsCaching) {
        this.supportsCaching = supportsCaching;
    }

    public void setCacheSeconds(int cacheSeconds) {
        this.cacheSeconds = cacheSeconds;
    }

    public void setRequireSession(boolean requireSession) {
        this.requireSession = requireSession;
    }
}

/**
 * ModelAndView - 뷰 이름과 모델 데이터를 담는 클래스
 */
class ModelAndView {
    private String viewName;
    private Map<String, Object> model = new HashMap<>();

    public ModelAndView(String viewName) {
        this.viewName = viewName;
    }

    public void addObject(String key, Object value) {
        model.put(key, value);
    }

    public String getViewName() {
        return viewName;
    }

    public Map<String, Object> getModel() {
        return model;
    }
}

/**
 * HttpServletRequest 인터페이스 (단순화)
 */
interface HttpServletRequest {
    String getParameter(String name);
    HttpSession getSession(boolean create);
}

/**
 * HttpServletResponse 인터페이스 (단순화)
 */
interface HttpServletResponse {
    void setHeader(String name, String value);
    void sendError(int code, String message);
}

/**
 * HttpSession 인터페이스 (단순화)
 */
interface HttpSession {
    String getId();
    Object getAttribute(String name);
    void setAttribute(String name, Object value);
}

// ========== 실제 구현 예제 ==========

/**
 * 사용자 목록 컨트롤러
 */
class UserListController extends AbstractController {

    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request,
                                                HttpServletResponse response) throws Exception {
        System.out.println("[비즈니스 로직] 사용자 목록 조회 중...");

        // 데이터베이스에서 사용자 목록 조회 (시뮬레이션)
        List<String> users = Arrays.asList(
            "김철수 (admin@example.com)",
            "이영희 (user1@example.com)",
            "박민수 (user2@example.com)"
        );

        // ModelAndView 생성 및 데이터 추가
        ModelAndView mav = new ModelAndView("userList");
        mav.addObject("users", users);
        mav.addObject("totalCount", users.size());

        System.out.println("[비즈니스 로직] 사용자 " + users.size() + "명 조회 완료");

        return mav;
    }

    @Override
    protected boolean preHandle(HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        // 부모의 전처리 실행
        super.preHandle(request, response);

        // 추가 전처리 로직
        System.out.println("[UserListController 전처리] 사용자 권한 체크");
        return true;
    }
}

/**
 * 상품 상세 컨트롤러
 */
class ProductDetailController extends AbstractController {

    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request,
                                                HttpServletResponse response) throws Exception {
        System.out.println("[비즈니스 로직] 상품 상세 정보 조회 중...");

        // 요청 파라미터에서 상품 ID 가져오기
        String productId = request.getParameter("id");

        // 상품 정보 조회 (시뮬레이션)
        Map<String, Object> product = new HashMap<>();
        product.put("id", productId);
        product.put("name", "맥북 프로 16인치");
        product.put("price", 3500000);
        product.put("stock", 15);

        ModelAndView mav = new ModelAndView("productDetail");
        mav.addObject("product", product);

        System.out.println("[비즈니스 로직] 상품 조회 완료: " + product.get("name"));

        return mav;
    }

    @Override
    protected void postHandle(HttpServletRequest request, HttpServletResponse response,
                             ModelAndView modelAndView) throws Exception {
        // 부모의 후처리 실행
        super.postHandle(request, response, modelAndView);

        // 추가 후처리 로직
        System.out.println("[ProductDetailController 후처리] 조회 로그 기록");
    }
}

/**
 * 로그인 컨트롤러
 */
class LoginController extends AbstractController {

    @Override
    protected ModelAndView handleRequestInternal(HttpServletRequest request,
                                                HttpServletResponse response) throws Exception {
        System.out.println("[비즈니스 로직] 로그인 처리 중...");

        String username = request.getParameter("username");
        String password = request.getParameter("password");

        // 로그인 검증 (시뮬레이션)
        boolean loginSuccess = "admin".equals(username) && "1234".equals(password);

        ModelAndView mav = new ModelAndView(loginSuccess ? "home" : "login");

        if (loginSuccess) {
            // 세션에 사용자 정보 저장
            HttpSession session = request.getSession(true);
            session.setAttribute("user", username);
            mav.addObject("message", "로그인 성공!");
            System.out.println("[비즈니스 로직] 로그인 성공: " + username);
        } else {
            mav.addObject("error", "아이디 또는 비밀가 잘못되었습니다");
            System.out.println("[비즈니스 로직] 로그인 실패");
        }

        return mav;
    }
}

// ========== Mock 구현 ==========

/**
 * 테스트용 HttpServletRequest 구현
 */
class MockHttpServletRequest implements HttpServletRequest {
    private Map<String, String> parameters = new HashMap<>();
    private HttpSession session;

    public void setParameter(String name, String value) {
        parameters.put(name, value);
    }

    @Override
    public String getParameter(String name) {
        return parameters.get(name);
    }

    @Override
    public HttpSession getSession(boolean create) {
        if (session == null && create) {
            session = new MockHttpSession();
        }
        return session;
    }
}

/**
 * 테스트용 HttpServletResponse 구현
 */
class MockHttpServletResponse implements HttpServletResponse {
    private Map<String, String> headers = new HashMap<>();
    private int errorCode = 0;
    private String errorMessage = "";

    @Override
    public void setHeader(String name, String value) {
        headers.put(name, value);
    }

    @Override
    public void sendError(int code, String message) {
        this.errorCode = code;
        this.errorMessage = message;
        System.out.println("[응답 에러] 코드: " + code + ", 메시지: " + message);
    }

    public int getErrorCode() {
        return errorCode;
    }
}

/**
 * 테스트용 HttpSession 구현
 */
class MockHttpSession implements HttpSession {
    private String id = "SESSION-" + System.currentTimeMillis();
    private Map<String, Object> attributes = new HashMap<>();

    @Override
    public String getId() {
        return id;
    }

    @Override
    public Object getAttribute(String name) {
        return attributes.get(name);
    }

    @Override
    public void setAttribute(String name, Object value) {
        attributes.put(name, value);
    }
}
```

### 🧪 테스트 코드

```java
/**
 * Spring AbstractController 패턴 테스트
 */
public class SpringAbstractControllerTest {

    public static void main(String[] args) throws Exception {

        System.out.println("====================================");
        System.out.println("Spring AbstractController 패턴 테스트");
        System.out.println("====================================\n");

        // 테스트 1: 사용자 목록 컨트롤러 (캐싱 활성화)
        test1_UserListController();

        // 테스트 2: 상품 상세 컨트롤러 (캐싱 활성화, 파라미터 전달)
        test2_ProductDetailController();

        // 테스트 3: 로그인 컨트롤러 (세션 필수 아님)
        test3_LoginController();

        // 테스트 4: 세션이 필요한 컨트롤러 (세션 없이 접근 시도)
        test4_SessionRequiredController();
    }

    /**
     * 테스트 1: 사용자 목록 조회
     */
    static void test1_UserListController() throws Exception {
        System.out.println("=== 테스트 1: 사용자 목록 컨트롤러 ===");

        UserListController controller = new UserListController();
        controller.setSupportsCaching(true);
        controller.setCacheSeconds(300); // 5분 캐싱

        MockHttpServletRequest request = new MockHttpServletRequest();
        MockHttpServletResponse response = new MockHttpServletResponse();

        ModelAndView mav = controller.handleRequest(request, response);

        if (mav != null) {
            System.out.println("✓ 뷰 이름: " + mav.getViewName());
            System.out.println("✓ 모델 데이터: " + mav.getModel());
        }

        System.out.println();
    }

    /**
     * 테스트 2: 상품 상세 조회
     */
    static void test2_ProductDetailController() throws Exception {
        System.out.println("=== 테스트 2: 상품 상세 컨트롤러 ===");

        ProductDetailController controller = new ProductDetailController();
        controller.setSupportsCaching(true);
        controller.setCacheSeconds(600); // 10분 캐싱

        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setParameter("id", "12345");
        MockHttpServletResponse response = new MockHttpServletResponse();

        ModelAndView mav = controller.handleRequest(request, response);

        if (mav != null) {
            System.out.println("✓ 뷰 이름: " + mav.getViewName());
            System.out.println("✓ 상품 정보: " + mav.getModel().get("product"));
        }

        System.out.println();
    }

    /**
     * 테스트 3: 로그인 처리
     */
    static void test3_LoginController() throws Exception {
        System.out.println("=== 테스트 3: 로그인 컨트롤러 ===");

        LoginController controller = new LoginController();

        MockHttpServletRequest request = new MockHttpServletRequest();
        request.setParameter("username", "admin");
        request.setParameter("password", "1234");
        MockHttpServletResponse response = new MockHttpServletResponse();

        ModelAndView mav = controller.handleRequest(request, response);

        if (mav != null) {
            System.out.println("✓ 뷰 이름: " + mav.getViewName());
            System.out.println("✓ 메시지: " + mav.getModel().get("message"));
        }

        System.out.println();
    }

    /**
     * 테스트 4: 세션이 필요한 컨트롤러
     */
    static void test4_SessionRequiredController() throws Exception {
        System.out.println("=== 테스트 4: 세션 필수 컨트롤러 (세션 없음) ===");

        UserListController controller = new UserListController();
        controller.setRequireSession(true); // 세션 필수 설정

        MockHttpServletRequest request = new MockHttpServletRequest();
        // 세션을 생성하지 않음
        MockHttpServletResponse response = new MockHttpServletResponse();

        ModelAndView mav = controller.handleRequest(request, response);

        if (mav == null) {
            System.out.println("✓ 세션이 없어서 요청이 거부되었습니다");
            System.out.println("✓ 에러 코드: " + response.getErrorCode());
        }

        System.out.println();
    }
}
```

### 🎯 핵심 포인트

1. **템플릿 메서드 패턴의 완벽한 구현**
   - `handleRequest()` 메서드가 전체 요청 처리 흐름을 정의
   - 각 단계(세션 체크 → 캐시 설정 → 전처리 → 비즈니스 로직 → 후처리)가 명확하게 분리됨

2. **추상 메서드와 Hook 메서드의 조화**
   - `handleRequestInternal()`: 반드시 구현해야 하는 추상 메서드 (비즈니스 로직)
   - `preHandle()`, `postHandle()`: 선택적으로 오버라이드 가능한 Hook 메서드

3. **final 키워드의 전략적 사용**
   - `handleRequest()` 메서드를 final로 선언하여 전체 흐름이 변경되지 않도록 보장
   - 확장은 허용하되, 핵심 알고리즘은 보호

4. **실제 Spring Framework와의 유사성**
   - 실제 Spring의 `AbstractController`도 동일한 패턴을 사용
   - 공통 기능(캐싱, 세션, 전후처리)을 부모에서 처리
   - 비즈니스 로직만 개발자가 구현

---

## 🏢 기업 사례 2: Apache HttpClient의 AbstractHttpEntity

### 📖 개요
Apache HttpClient는 HTTP 통신을 위한 강력한 Java 라이브러리입니다. 이 라이브러리에서는 HTTP 메시지의 본문(body)을 표현하기 위해 `AbstractHttpEntity`라는 추상 클래스를 제공합니다. 파일, 문자열, 바이트 배열 등 다양한 형태의 데이터를 HTTP 엔티티로 변환할 때 이 추상 클래스를 상속받습니다.

### 💡 왜 추상 클래스를 사용했을까?
- **다양한 데이터 소스 지원**: 파일, 문자열, 스트림 등 다양한 형태의 데이터를 동일한 인터페이스로 처리
- **공통 속성 관리**: Content-Type, Content-Encoding 등 모든 엔티티에 공통적인 속성을 부모 클래스에서 관리
- **확장성**: 새로운 형태의 데이터 소스가 추가되어도 쉽게 확장 가능

### 💻 실제 코드 구현

```java
// Apache HttpClient의 AbstractHttpEntity 패턴을 단순화한 예제

import java.io.*;
import java.nio.charset.StandardCharsets;

/**
 * 추상 HTTP 엔티티 - HTTP 메시지 본문을 나타내는 추상 클래스
 */
public abstract class AbstractHttpEntity {

    // 공통 속성
    protected String contentType;      // Content-Type (예: "application/json")
    protected String contentEncoding;  // Content-Encoding (예: "gzip")
    protected boolean chunked;         // 청크 전송 여부

    /**
     * 추상 메서드: 엔티티의 내용을 InputStream으로 반환
     */
    public abstract InputStream getContent() throws IOException;

    /**
     * 추상 메서드: 엔티티의 크기를 반환 (-1이면 크기를 모름)
     */
    public abstract long getContentLength();

    /**
     * 추상 메서드: 엔티티의 내용을 OutputStream에 쓰기
     */
    public abstract void writeTo(OutputStream outStream) throws IOException;

    /**
     * 추상 메서드: 엔티티가 반복해서 읽을 수 있는지 여부
     */
    public abstract boolean isRepeatable();

    /**
     * 추상 메서드: 엔티티가 스트리밍인지 여부
     */
    public abstract boolean isStreaming();

    // ========== 공통 메서드 (모든 하위 클래스에서 사용) ==========

    /**
     * Content-Type 설정
     */
    public void setContentType(String contentType) {
        this.contentType = contentType;
    }

    /**
     * Content-Type 반환
     */
    public String getContentType() {
        return contentType;
    }

    /**
     * Content-Encoding 설정
     */
    public void setContentEncoding(String contentEncoding) {
        this.contentEncoding = contentEncoding;
    }

    /**
     * Content-Encoding 반환
     */
    public String getContentEncoding() {
        return contentEncoding;
    }

    /**
     * 청크 전송 여부 설정
     */
    public void setChunked(boolean chunked) {
        this.chunked = chunked;
    }

    /**
     * 청크 전송 여부 반환
     */
    public boolean isChunked() {
        return chunked;
    }

    /**
     * 엔티티 정보 출력
     */
    public void printInfo() {
        System.out.println("  Content-Type: " + (contentType != null ? contentType : "없음"));
        System.out.println("  Content-Encoding: " + (contentEncoding != null ? contentEncoding : "없음"));
        System.out.println("  Content-Length: " + getContentLength() + " bytes");
        System.out.println("  Chunked: " + chunked);
        System.out.println("  Repeatable: " + isRepeatable());
        System.out.println("  Streaming: " + isStreaming());
    }
}

// ========== 구체적인 엔티티 구현 ==========

/**
 * 문자열 엔티티 - 문자열 데이터를 HTTP 엔티티로 변환
 */
class StringEntity extends AbstractHttpEntity {

    private final byte[] content;

    public StringEntity(String string) {
        this(string, StandardCharsets.UTF_8.name());
    }

    public StringEntity(String string, String charset) {
        try {
            this.content = string.getBytes(charset);
            this.contentType = "text/plain; charset=" + charset;
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("지원하지 않는 인코딩: " + charset, e);
        }
    }

    @Override
    public InputStream getContent() throws IOException {
        return new ByteArrayInputStream(content);
    }

    @Override
    public long getContentLength() {
        return content.length;
    }

    @Override
    public void writeTo(OutputStream outStream) throws IOException {
        outStream.write(content);
        outStream.flush();
    }

    @Override
    public boolean isRepeatable() {
        return true; // 바이트 배열이므로 반복 읽기 가능
    }

    @Override
    public boolean isStreaming() {
        return false; // 메모리에 저장되어 있으므로 스트리밍 아님
    }
}

/**
 * 파일 엔티티 - 파일을 HTTP 엔티티로 변환
 */
class FileEntity extends AbstractHttpEntity {

    private final File file;

    public FileEntity(File file, String contentType) {
        if (!file.exists()) {
            throw new IllegalArgumentException("파일이 존재하지 않습니다: " + file.getPath());
        }
        this.file = file;
        this.contentType = contentType;
    }

    @Override
    public InputStream getContent() throws IOException {
        return new FileInputStream(file);
    }

    @Override
    public long getContentLength() {
        return file.length();
    }

    @Override
    public void writeTo(OutputStream outStream) throws IOException {
        try (FileInputStream inStream = new FileInputStream(file)) {
            byte[] buffer = new byte[8192];
            int bytesRead;
            while ((bytesRead = inStream.read(buffer)) != -1) {
                outStream.write(buffer, 0, bytesRead);
            }
            outStream.flush();
        }
    }

    @Override
    public boolean isRepeatable() {
        return true; // 파일이므로 반복 읽기 가능
    }

    @Override
    public boolean isStreaming() {
        return false; // 파일은 스트리밍으로 간주하지 않음
    }
}

/**
 * 바이트 배열 엔티티 - 바이트 배열을 HTTP 엔티티로 변환
 */
class ByteArrayEntity extends AbstractHttpEntity {

    private final byte[] content;
    private final int offset;
    private final int length;

    public ByteArrayEntity(byte[] bytes) {
        this(bytes, 0, bytes.length);
    }

    public ByteArrayEntity(byte[] bytes, int offset, int length) {
        if (bytes == null) {
            throw new IllegalArgumentException("바이트 배열이 null입니다");
        }
        this.content = bytes;
        this.offset = offset;
        this.length = length;
        this.contentType = "application/octet-stream";
    }

    @Override
    public InputStream getContent() throws IOException {
        return new ByteArrayInputStream(content, offset, length);
    }

    @Override
    public long getContentLength() {
        return length;
    }

    @Override
    public void writeTo(OutputStream outStream) throws IOException {
        outStream.write(content, offset, length);
        outStream.flush();
    }

    @Override
    public boolean isRepeatable() {
        return true; // 바이트 배열이므로 반복 읽기 가능
    }

    @Override
    public boolean isStreaming() {
        return false; // 메모리에 저장되어 있으므로 스트리밍 아님
    }
}

/**
 * 입력 스트림 엔티티 - InputStream을 HTTP 엔티티로 변환
 */
class InputStreamEntity extends AbstractHttpEntity {

    private final InputStream content;
    private final long contentLength;

    public InputStreamEntity(InputStream content, long contentLength) {
        if (content == null) {
            throw new IllegalArgumentException("InputStream이 null입니다");
        }
        this.content = content;
        this.contentLength = contentLength;
        this.contentType = "application/octet-stream";
    }

    @Override
    public InputStream getContent() throws IOException {
        return content;
    }

    @Override
    public long getContentLength() {
        return contentLength;
    }

    @Override
    public void writeTo(OutputStream outStream) throws IOException {
        byte[] buffer = new byte[8192];
        int bytesRead;

        if (contentLength < 0) {
            // 크기를 모를 때는 끝까지 읽기
            while ((bytesRead = content.read(buffer)) != -1) {
                outStream.write(buffer, 0, bytesRead);
            }
        } else {
            // 크기를 알 때는 정확히 그만큼만 읽기
            long remaining = contentLength;
            while (remaining > 0) {
                int toRead = (int) Math.min(buffer.length, remaining);
                bytesRead = content.read(buffer, 0, toRead);
                if (bytesRead == -1) {
                    break;
                }
                outStream.write(buffer, 0, bytesRead);
                remaining -= bytesRead;
            }
        }
        outStream.flush();
    }

    @Override
    public boolean isRepeatable() {
        return false; // 스트림은 한 번만 읽을 수 있음
    }

    @Override
    public boolean isStreaming() {
        return true; // 스트림이므로 스트리밍임
    }
}

/**
 * JSON 엔티티 - JSON 데이터를 HTTP 엔티티로 변환
 */
class JsonEntity extends StringEntity {

    public JsonEntity(String jsonString) {
        super(jsonString, "UTF-8");
        this.contentType = "application/json; charset=UTF-8";
    }
}

/**
 * XML 엔티티 - XML 데이터를 HTTP 엔티티로 변환
 */
class XmlEntity extends StringEntity {

    public XmlEntity(String xmlString) {
        super(xmlString, "UTF-8");
        this.contentType = "application/xml; charset=UTF-8";
    }
}
```

### 🧪 테스트 코드

```java
/**
 * Apache HttpEntity 패턴 테스트
 */
public class ApacheHttpEntityTest {

    public static void main(String[] args) throws IOException {

        System.out.println("========================================");
        System.out.println("Apache HttpEntity 패턴 테스트");
        System.out.println("========================================\n");

        // 테스트 1: 문자열 엔티티
        test1_StringEntity();

        // 테스트 2: JSON 엔티티
        test2_JsonEntity();

        // 테스트 3: 바이트 배열 엔티티
        test3_ByteArrayEntity();

        // 테스트 4: 파일 엔티티
        test4_FileEntity();

        // 테스트 5: 입력 스트림 엔티티
        test5_InputStreamEntity();

        // 테스트 6: 다형성 - 다양한 엔티티를 동일하게 처리
        test6_Polymorphism();
    }

    /**
     * 테스트 1: 문자열 엔티티
     */
    static void test1_StringEntity() throws IOException {
        System.out.println("=== 테스트 1: 문자열 엔티티 ===");

        StringEntity entity = new StringEntity("안녕하세요! HTTP 엔티티 테스트입니다.");

        System.out.println("엔티티 정보:");
        entity.printInfo();

        System.out.println("\n내용:");
        readAndPrint(entity);

        System.out.println();
    }

    /**
     * 테스트 2: JSON 엔티티
     */
    static void test2_JsonEntity() throws IOException {
        System.out.println("=== 테스트 2: JSON 엔티티 ===");

        String json = "{\n" +
                     "  \"name\": \"김철수\",\n" +
                     "  \"age\": 30,\n" +
                     "  \"email\": \"chulsoo@example.com\"\n" +
                     "}";

        JsonEntity entity = new JsonEntity(json);

        System.out.println("엔티티 정보:");
        entity.printInfo();

        System.out.println("\n내용:");
        readAndPrint(entity);

        System.out.println();
    }

    /**
     * 테스트 3: 바이트 배열 엔티티
     */
    static void test3_ByteArrayEntity() throws IOException {
        System.out.println("=== 테스트 3: 바이트 배열 엔티티 ===");

        byte[] data = "바이너리 데이터 예제".getBytes(StandardCharsets.UTF_8);
        ByteArrayEntity entity = new ByteArrayEntity(data);
        entity.setContentType("application/octet-stream");

        System.out.println("엔티티 정보:");
        entity.printInfo();

        System.out.println("\n내용:");
        readAndPrint(entity);

        System.out.println();
    }

    /**
     * 테스트 4: 파일 엔티티
     */
    static void test4_FileEntity() throws IOException {
        System.out.println("=== 테스트 4: 파일 엔티티 ===");

        // 임시 파일 생성
        File tempFile = File.createTempFile("test", ".txt");
        tempFile.deleteOnExit();

        try (FileWriter writer = new FileWriter(tempFile)) {
            writer.write("이것은 파일 엔티티 테스트입니다.\n");
            writer.write("파일에서 읽은 내용을 HTTP 본문으로 전송합니다.");
        }

        FileEntity entity = new FileEntity(tempFile, "text/plain");

        System.out.println("엔티티 정보:");
        entity.printInfo();

        System.out.println("\n내용:");
        readAndPrint(entity);

        System.out.println();
    }

    /**
     * 테스트 5: 입력 스트림 엔티티
     */
    static void test5_InputStreamEntity() throws IOException {
        System.out.println("=== 테스트 5: 입력 스트림 엔티티 ===");

        String data = "스트림으로부터 읽은 데이터";
        ByteArrayInputStream inputStream = new ByteArrayInputStream(
            data.getBytes(StandardCharsets.UTF_8)
        );

        InputStreamEntity entity = new InputStreamEntity(inputStream, data.length());
        entity.setContentType("text/plain");

        System.out.println("엔티티 정보:");
        entity.printInfo();

        System.out.println("\n내용:");
        // 주의: InputStreamEntity는 반복 읽기가 불가능하므로 한 번만 읽을 수 있음
        readAndPrint(entity);

        System.out.println();
    }

    /**
     * 테스트 6: 다형성 - 다양한 엔티티를 동일하게 처리
     */
    static void test6_Polymorphism() throws IOException {
        System.out.println("=== 테스트 6: 다형성 테스트 ===");
        System.out.println("다양한 종류의 엔티티를 동일한 방식으로 처리\n");

        // 다양한 타입의 엔티티를 배열에 저장
        AbstractHttpEntity[] entities = {
            new StringEntity("문자열 엔티티"),
            new JsonEntity("{\"message\": \"JSON 엔티티\"}"),
            new ByteArrayEntity("바이트 배열".getBytes(StandardCharsets.UTF_8))
        };

        // 모든 엔티티를 동일한 방식으로 처리
        for (int i = 0; i < entities.length; i++) {
            System.out.println("--- 엔티티 " + (i + 1) + " ---");
            sendHttpRequest(entities[i]);
            System.out.println();
        }
    }

    /**
     * HTTP 요청 전송 시뮬레이션
     * 모든 타입의 엔티티를 동일한 방식으로 처리 가능
     */
    static void sendHttpRequest(AbstractHttpEntity entity) throws IOException {
        System.out.println("[HTTP 요청 전송]");
        System.out.println("Content-Type: " + entity.getContentType());
        System.out.println("Content-Length: " + entity.getContentLength());
        System.out.println("본문:");

        // 엔티티의 내용을 표준 출력으로 전송
        entity.writeTo(System.out);
        System.out.println("\n[전송 완료]");
    }

    /**
     * 엔티티의 내용을 읽어서 출력
     */
    static void readAndPrint(AbstractHttpEntity entity) throws IOException {
        try (InputStream in = entity.getContent();
             BufferedReader reader = new BufferedReader(
                 new InputStreamReader(in, StandardCharsets.UTF_8))) {

            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println("  " + line);
            }
        }
    }
}
```

### 🎯 핵심 포인트

1. **공통 속성의 효율적 관리**
   - `contentType`, `contentEncoding`, `chunked` 등 모든 엔티티에 공통적인 속성을 부모 클래스에서 관리
   - 중복 코드를 제거하고 일관성 유지

2. **다양한 데이터 소스 통합**
   - 문자열, 파일, 바이트 배열, 스트림 등 서로 다른 데이터 소스를 동일한 인터페이스로 처리
   - 새로운 데이터 소스가 추가되어도 쉽게 확장 가능

3. **추상 메서드의 전략적 선택**
   - `getContent()`: 데이터를 읽는 방법은 각 엔티티마다 다름
   - `getContentLength()`: 크기를 계산하는 방법도 각 엔티티마다 다름
   - `isRepeatable()`, `isStreaming()`: 엔티티의 특성을 나타내는 메서드

4. **다형성을 통한 유연한 처리**
   - `sendHttpRequest()` 메서드는 `AbstractHttpEntity` 타입의 파라미터를 받아 모든 종류의 엔티티를 처리
   - 클라이언트 코드는 구체적인 엔티티 타입을 몰라도 됨

5. **실제 Apache HttpClient와의 유사성**
   - 실제 Apache HttpClient도 동일한 구조를 사용
   - `StringEntity`, `FileEntity`, `ByteArrayEntity`, `InputStreamEntity` 등이 실제로 존재

---

## 🏢 기업 사례 3: Android의 AsyncTask

### 📖 개요
Android 애플리케이션 개발에서 백그라운드 작업을 처리하기 위해 사용되었던 `AsyncTask`는 추상 클래스입니다. (현재는 Deprecated되었지만, 추상 클래스의 훌륭한 예제로 여전히 학습 가치가 있습니다.) UI 스레드를 블로킹하지 않고 백그라운드에서 작업을 수행한 후 결과를 UI에 반영할 때 사용됩니다.

### 💡 왜 추상 클래스를 사용했을까?
- **생명주기 관리**: 백그라운드 작업의 시작, 진행, 완료 단계를 명확하게 정의
- **스레드 관리 자동화**: 개발자는 비즈니스 로직만 구현하고, 스레드 생성/관리는 프레임워크가 담당
- **UI 업데이트 간소화**: 백그라운드 스레드에서 UI를 안전하게 업데이트할 수 있는 메커니즘 제공

### 💻 실제 코드 구현

```java
// Android의 AsyncTask 패턴을 단순화한 예제

import java.util.*;
import java.util.concurrent.*;

/**
 * 추상 AsyncTask - 백그라운드 작업을 처리하는 추상 클래스
 *
 * @param <Params> 작업 시작 시 전달되는 파라미터 타입
 * @param <Progress> 작업 진행 상황 타입
 * @param <Result> 작업 결과 타입
 */
public abstract class AsyncTask<Params, Progress, Result> {

    private static final ExecutorService THREAD_POOL = Executors.newFixedThreadPool(5);

    private volatile boolean cancelled = false;
    private Future<?> future;

    /**
     * 백그라운드 작업 실행 (메인 메서드)
     */
    @SafeVarargs
    public final AsyncTask<Params, Progress, Result> execute(Params... params) {

        // 1단계: UI 스레드에서 전처리
        onPreExecute();

        // 2단계: 백그라운드 스레드에서 작업 실행
        future = THREAD_POOL.submit(() -> {
            try {
                // 백그라운드 작업 수행
                Result result = doInBackground(params);

                // 취소되지 않았다면 결과 전달
                if (!cancelled) {
                    // UI 스레드로 돌아가서 후처리
                    runOnUiThread(() -> onPostExecute(result));
                }
            } catch (Exception e) {
                if (!cancelled) {
                    runOnUiThread(() -> onCancelled());
                }
            }
        });

        return this;
    }

    /**
     * 작업 취소
     */
    public final boolean cancel(boolean mayInterruptIfRunning) {
        cancelled = true;
        if (future != null) {
            return future.cancel(mayInterruptIfRunning);
        }
        return false;
    }

    /**
     * 작업이 취소되었는지 확인
     */
    public final boolean isCancelled() {
        return cancelled;
    }

    /**
     * 진행 상황 업데이트 (백그라운드 스레드에서 호출)
     */
    @SafeVarargs
    protected final void publishProgress(Progress... values) {
        if (!cancelled) {
            runOnUiThread(() -> onProgressUpdate(values));
        }
    }

    // ========== 하위 클래스에서 구현할 메서드 ==========

    /**
     * 추상 메서드: 백그라운드에서 실행될 작업 (필수 구현)
     * 백그라운드 스레드에서 실행됨
     */
    @SafeVarargs
    protected abstract Result doInBackground(Params... params);

    /**
     * Hook 메서드: 작업 시작 전 UI 스레드에서 호출 (선택적 구현)
     * 예: 프로그레스 바 표시
     */
    protected void onPreExecute() {
        // 기본 구현 없음 - 필요시 오버라이드
    }

    /**
     * Hook 메서드: 작업 완료 후 UI 스레드에서 호출 (선택적 구현)
     * 예: 결과를 UI에 표시
     */
    protected void onPostExecute(Result result) {
        // 기본 구현 없음 - 필요시 오버라이드
    }

    /**
     * Hook 메서드: 진행 상황 업데이트 시 UI 스레드에서 호출 (선택적 구현)
     * 예: 프로그레스 바 업데이트
     */
    @SafeVarargs
    protected void onProgressUpdate(Progress... values) {
        // 기본 구현 없음 - 필요시 오버라이드
    }

    /**
     * Hook 메서드: 작업 취소 시 UI 스레드에서 호출 (선택적 구현)
     */
    protected void onCancelled() {
        // 기본 구현 없음 - 필요시 오버라이드
    }

    // ========== UI 스레드 시뮬레이션 ==========

    /**
     * UI 스레드에서 실행 (실제 Android에서는 Handler 사용)
     */
    private void runOnUiThread(Runnable action) {
        // 실제 Android에서는 UI 스레드로 전환하지만,
        // 여기서는 단순히 바로 실행 (데모 목적)
        action.run();
    }

    /**
     * 스레드 풀 종료
     */
    public static void shutdownThreadPool() {
        THREAD_POOL.shutdown();
    }
}

// ========== 구체적인 AsyncTask 구현 예제 ==========

/**
 * 파일 다운로드 작업
 */
class DownloadFileTask extends AsyncTask<String, Integer, String> {

    @Override
    protected void onPreExecute() {
        System.out.println("[UI 스레드] 다운로드 시작 준비...");
        System.out.println("[UI 스레드] 프로그레스 바 표시\n");
    }

    @Override
    protected String doInBackground(String... urls) {
        String url = urls[0];
        System.out.println("[백그라운드] 파일 다운로드 시작: " + url);

        try {
            // 다운로드 시뮬레이션
            for (int i = 0; i <= 100; i += 10) {
                if (isCancelled()) {
                    System.out.println("[백그라운드] 다운로드 취소됨");
                    return null;
                }

                // 진행 상황 업데이트
                publishProgress(i);

                // 다운로드 시뮬레이션 (100ms 대기)
                Thread.sleep(100);
            }

            System.out.println("[백그라운드] 다운로드 완료\n");
            return "파일이 성공적으로 다운로드되었습니다: " + url;

        } catch (InterruptedException e) {
            return "다운로드 중 오류 발생";
        }
    }

    @Override
    protected void onProgressUpdate(Integer... values) {
        int progress = values[0];
        System.out.println("[UI 스레드] 다운로드 진행률: " + progress + "%");
    }

    @Override
    protected void onPostExecute(String result) {
        System.out.println("[UI 스레드] " + result);
        System.out.println("[UI 스레드] 프로그레스 바 숨김\n");
    }

    @Override
    protected void onCancelled() {
        System.out.println("[UI 스레드] 다운로드가 취소되었습니다");
        System.out.println("[UI 스레드] 프로그레스 바 숨김\n");
    }
}

/**
 * 데이터베이스 쿼리 작업
 */
class DatabaseQueryTask extends AsyncTask<String, Void, List<String>> {

    @Override
    protected void onPreExecute() {
        System.out.println("[UI 스레드] 데이터베이스 쿼리 시작...");
        System.out.println("[UI 스레드] 로딩 스피너 표시\n");
    }

    @Override
    protected List<String> doInBackground(String... queries) {
        String query = queries[0];
        System.out.println("[백그라운드] 쿼리 실행: " + query);

        try {
            // 데이터베이스 쿼리 시뮬레이션
            Thread.sleep(500);

            // 결과 생성
            List<String> results = Arrays.asList(
                "사용자 1: 김철수",
                "사용자 2: 이영희",
                "사용자 3: 박민수"
            );

            System.out.println("[백그라운드] 쿼리 완료: " + results.size() + "개 결과\n");
            return results;

        } catch (InterruptedException e) {
            return new ArrayList<>();
        }
    }

    @Override
    protected void onPostExecute(List<String> results) {
        System.out.println("[UI 스레드] 쿼리 결과를 UI에 표시:");
        for (String result : results) {
            System.out.println("  - " + result);
        }
        System.out.println("[UI 스레드] 로딩 스피너 숨김\n");
    }
}

/**
 * 이미지 처리 작업
 */
class ImageProcessingTask extends AsyncTask<String, String, String> {

    @Override
    protected void onPreExecute() {
        System.out.println("[UI 스레드] 이미지 처리 시작...\n");
    }

    @Override
    protected String doInBackground(String... imagePaths) {
        System.out.println("[백그라운드] 이미지 처리 작업 시작");

        try {
            for (int i = 0; i < imagePaths.length; i++) {
                if (isCancelled()) {
                    return "처리 취소됨";
                }

                String imagePath = imagePaths[i];

                // 이미지 처리 시뮬레이션
                publishProgress("처리 중: " + imagePath);
                Thread.sleep(300);
                publishProgress("완료: " + imagePath);
            }

            System.out.println("[백그라운드] 모든 이미지 처리 완료\n");
            return imagePaths.length + "개의 이미지가 처리되었습니다";

        } catch (InterruptedException e) {
            return "처리 중 오류 발생";
        }
    }

    @Override
    protected void onProgressUpdate(String... values) {
        String message = values[0];
        System.out.println("[UI 스레드] " + message);
    }

    @Override
    protected void onPostExecute(String result) {
        System.out.println("[UI 스레드] " + result);
        System.out.println("[UI 스레드] 완료 메시지 표시\n");
    }
}

/**
 * 네트워크 API 호출 작업
 */
class ApiCallTask extends AsyncTask<String, Void, String> {

    @Override
    protected void onPreExecute() {
        System.out.println("[UI 스레드] API 호출 준비...\n");
    }

    @Override
    protected String doInBackground(String... endpoints) {
        String endpoint = endpoints[0];
        System.out.println("[백그라운드] API 호출: " + endpoint);

        try {
            // API 호출 시뮬레이션
            Thread.sleep(800);

            // JSON 응답 시뮬레이션
            String jsonResponse = "{\n" +
                                "  \"status\": \"success\",\n" +
                                "  \"data\": {\n" +
                                "    \"message\": \"Hello from API\"\n" +
                                "  }\n" +
                                "}";

            System.out.println("[백그라운드] API 응답 수신\n");
            return jsonResponse;

        } catch (InterruptedException e) {
            return "{\"status\": \"error\"}";
        }
    }

    @Override
    protected void onPostExecute(String result) {
        System.out.println("[UI 스레드] API 응답:");
        System.out.println(result);
        System.out.println("[UI 스레드] UI 업데이트 완료\n");
    }
}
```

### 🧪 테스트 코드

```java
/**
 * Android AsyncTask 패턴 테스트
 */
public class AndroidAsyncTaskTest {

    public static void main(String[] args) throws InterruptedException {

        System.out.println("==========================================");
        System.out.println("Android AsyncTask 패턴 테스트");
        System.out.println("==========================================\n");

        // 테스트 1: 파일 다운로드
        test1_FileDownload();
        Thread.sleep(1500);

        // 테스트 2: 데이터베이스 쿼리
        test2_DatabaseQuery();
        Thread.sleep(1000);

        // 테스트 3: 이미지 처리
        test3_ImageProcessing();
        Thread.sleep(1500);

        // 테스트 4: API 호출
        test4_ApiCall();
        Thread.sleep(1200);

        // 테스트 5: 작업 취소
        test5_Cancellation();
        Thread.sleep(500);

        // 스레드 풀 종료
        AsyncTask.shutdownThreadPool();

        System.out.println("==========================================");
        System.out.println("모든 테스트 완료");
        System.out.println("==========================================");
    }

    /**
     * 테스트 1: 파일 다운로드
     */
    static void test1_FileDownload() {
        System.out.println("### 테스트 1: 파일 다운로드 ###\n");

        DownloadFileTask task = new DownloadFileTask();
        task.execute("https://example.com/largefile.zip");
    }

    /**
     * 테스트 2: 데이터베이스 쿼리
     */
    static void test2_DatabaseQuery() {
        System.out.println("### 테스트 2: 데이터베이스 쿼리 ###\n");

        DatabaseQueryTask task = new DatabaseQueryTask();
        task.execute("SELECT * FROM users WHERE active = true");
    }

    /**
     * 테스트 3: 이미지 처리
     */
    static void test3_ImageProcessing() {
        System.out.println("### 테스트 3: 이미지 처리 ###\n");

        ImageProcessingTask task = new ImageProcessingTask();
        task.execute("/images/photo1.jpg", "/images/photo2.jpg", "/images/photo3.jpg");
    }

    /**
     * 테스트 4: API 호출
     */
    static void test4_ApiCall() {
        System.out.println("### 테스트 4: API 호출 ###\n");

        ApiCallTask task = new ApiCallTask();
        task.execute("https://api.example.com/users");
    }

    /**
     * 테스트 5: 작업 취소
     */
    static void test5_Cancellation() throws InterruptedException {
        System.out.println("### 테스트 5: 작업 취소 ###\n");

        DownloadFileTask task = new DownloadFileTask();
        task.execute("https://example.com/verylargefile.zip");

        // 200ms 후 작업 취소
        Thread.sleep(200);
        System.out.println("\n[메인 스레드] 사용자가 취소 버튼을 클릭함");
        task.cancel(true);
    }
}
```

### 🎯 핵심 포인트

1. **생명주기 메서드의 명확한 분리**
   - `onPreExecute()`: UI 스레드에서 작업 시작 전 실행 (프로그레스 바 표시)
   - `doInBackground()`: 백그라운드 스레드에서 실제 작업 수행
   - `onProgressUpdate()`: UI 스레드에서 진행 상황 업데이트
   - `onPostExecute()`: UI 스레드에서 작업 완료 후 실행 (결과 표시)
   - `onCancelled()`: 작업 취소 시 실행

2. **추상 메서드와 Hook 메서드의 조합**
   - `doInBackground()`: 반드시 구현해야 하는 추상 메서드
   - 나머지 메서드들: 필요에 따라 선택적으로 오버라이드하는 Hook 메서드

3. **스레드 관리 자동화**
   - 개발자는 스레드 생성/관리를 신경 쓸 필요 없음
   - 프레임워크가 자동으로 백그라운드 스레드에서 작업을 실행하고 결과를 UI 스레드로 전달

4. **타입 파라미터를 통한 유연성**
   - `AsyncTask<Params, Progress, Result>`: 제네릭을 사용하여 다양한 타입 지원
   - 각 작업에 맞는 타입을 지정 가능

5. **실제 Android AsyncTask와의 유사성**
   - 실제 Android의 AsyncTask도 동일한 구조
   - 현재는 Deprecated되었지만, Kotlin Coroutines나 RxJava로 대체되기 전까지 널리 사용됨

---

## 👨‍💻 주니어 개발자 시나리오 (Junior Developer Scenarios)

실제 개발 현장에서 주니어 개발자들이 추상 클래스를 사용하면서 자주 겪는 실수와 해결 방법을 살펴보겠습니다.

---

## 🔍 시나리오 1: 추상 클래스를 인스턴스화하려는 시도

### ❌ 문제 상황

```java
/**
 * 결제 처리 추상 클래스
 */
abstract class PaymentProcessor {
    protected String merchantId;
    protected double amount;

    public PaymentProcessor(String merchantId) {
        this.merchantId = merchantId;
    }

    public abstract boolean processPayment(double amount);

    public void printReceipt() {
        System.out.println("영수증: " + amount + "원 결제 완료");
    }
}

/**
 * 주니어 개발자의 잘못된 코드
 */
class JuniorDeveloper1_Wrong {

    public void createPayment() {
        // 컴파일 에러! 추상 클래스는 인스턴스화할 수 없음
        // PaymentProcessor processor = new PaymentProcessor("MERCHANT123");
        //                                ^^^^^^^^^^^^^^^^
        // Error: PaymentProcessor is abstract; cannot be instantiated

        System.out.println("❌ 에러: 추상 클래스를 직접 인스턴스화할 수 없습니다!");
    }
}
```

### ✅ 올바른 해결 방법

```java
/**
 * 신용카드 결제 프로세서
 */
class CreditCardPaymentProcessor extends PaymentProcessor {
    private String cardNumber;

    public CreditCardPaymentProcessor(String merchantId, String cardNumber) {
        super(merchantId);
        this.cardNumber = cardNumber;
    }

    @Override
    public boolean processPayment(double amount) {
        this.amount = amount;
        System.out.println("[신용카드 결제] 카드 번호: " + maskCardNumber(cardNumber));
        System.out.println("[신용카드 결제] 금액: " + amount + "원");
        System.out.println("[신용카드 결제] 결제 승인됨");
        return true;
    }

    private String maskCardNumber(String cardNumber) {
        if (cardNumber.length() < 4) return "****";
        return "****-****-****-" + cardNumber.substring(cardNumber.length() - 4);
    }
}

/**
 * 계좌이체 결제 프로세서
 */
class BankTransferPaymentProcessor extends PaymentProcessor {
    private String accountNumber;

    public BankTransferPaymentProcessor(String merchantId, String accountNumber) {
        super(merchantId);
        this.accountNumber = accountNumber;
    }

    @Override
    public boolean processPayment(double amount) {
        this.amount = amount;
        System.out.println("[계좌이체] 계좌: " + accountNumber);
        System.out.println("[계좌이체] 금액: " + amount + "원");
        System.out.println("[계좌이체] 이체 완료");
        return true;
    }
}

/**
 * 올바른 사용 방법
 */
class JuniorDeveloper1_Correct {

    public void createPayment() {
        System.out.println("✅ 올바른 방법: 구체적인 하위 클래스를 인스턴스화\n");

        // 방법 1: 신용카드 결제
        PaymentProcessor creditCard = new CreditCardPaymentProcessor(
            "MERCHANT123",
            "1234567890123456"
        );
        creditCard.processPayment(50000);
        creditCard.printReceipt();

        System.out.println();

        // 방법 2: 계좌이체 결제
        PaymentProcessor bankTransfer = new BankTransferPaymentProcessor(
            "MERCHANT123",
            "110-123-456789"
        );
        bankTransfer.processPayment(30000);
        bankTransfer.printReceipt();
    }
}

/**
 * 시나리오 1 테스트
 */
class Scenario1Test {
    public static void main(String[] args) {
        System.out.println("========================================");
        System.out.println("시나리오 1: 추상 클래스 인스턴스화 실수");
        System.out.println("========================================\n");

        JuniorDeveloper1_Correct developer = new JuniorDeveloper1_Correct();
        developer.createPayment();

        System.out.println("\n💡 교훈:");
        System.out.println("   - 추상 클래스는 직접 인스턴스화할 수 없습니다");
        System.out.println("   - 반드시 구체적인 하위 클래스를 만들어서 사용해야 합니다");
        System.out.println("   - 추상 클래스는 '설계도' 역할만 합니다");
    }
}
```

### 📝 배운 점

- **추상 클래스는 불완전한 클래스**: 추상 메서드(구현이 없는 메서드)를 포함하므로 직접 객체를 만들 수 없음
- **반드시 상속 필요**: 구체적인 하위 클래스를 만들고, 모든 추상 메서드를 구현해야 함
- **다형성 활용**: `PaymentProcessor` 타입으로 선언하고, 구체적인 하위 클래스의 객체를 할당

---

## 🔍 시나리오 2: 추상 메서드 구현 누락

### ❌ 문제 상황

```java
/**
 * 알림 발송 추상 클래스
 */
abstract class NotificationSender {
    protected String recipient;
    protected String message;

    public NotificationSender(String recipient, String message) {
        this.recipient = recipient;
        this.message = message;
    }

    // 추상 메서드들
    public abstract void connect();
    public abstract void send();
    public abstract void disconnect();

    // 공통 메서드
    public final void sendNotification() {
        System.out.println("=== 알림 발송 시작 ===");
        connect();
        validateMessage();
        send();
        disconnect();
        System.out.println("=== 알림 발송 완료 ===\n");
    }

    private void validateMessage() {
        if (message == null || message.isEmpty()) {
            throw new IllegalArgumentException("메시지가 비어있습니다");
        }
        System.out.println("메시지 검증 완료");
    }
}

/**
 * 주니어 개발자의 잘못된 코드 - 추상 메서드를 구현하지 않음
 */
// 컴파일 에러 발생!
/*
class EmailNotificationSender_Wrong extends NotificationSender {
    private String emailServer;

    public EmailNotificationSender_Wrong(String recipient, String message, String emailServer) {
        super(recipient, message);
        this.emailServer = emailServer;
    }

    // connect()와 disconnect()는 구현했지만 send()를 구현하지 않음!
    @Override
    public void connect() {
        System.out.println("이메일 서버 연결: " + emailServer);
    }

    @Override
    public void disconnect() {
        System.out.println("이메일 서버 연결 해제");
    }

    // send() 메서드 구현을 깜빡함!
    // Error: EmailNotificationSender_Wrong is not abstract and does not override
    // abstract method send() in NotificationSender
}
*/
```

### ✅ 올바른 해결 방법

```java
/**
 * 이메일 알림 발송 - 모든 추상 메서드를 올바르게 구현
 */
class EmailNotificationSender extends NotificationSender {
    private String emailServer;

    public EmailNotificationSender(String recipient, String message, String emailServer) {
        super(recipient, message);
        this.emailServer = emailServer;
    }

    @Override
    public void connect() {
        System.out.println("[이메일] 서버 연결: " + emailServer);
    }

    @Override
    public void send() {
        // 이 메서드를 구현하지 않으면 컴파일 에러!
        System.out.println("[이메일] 수신자: " + recipient);
        System.out.println("[이메일] 내용: " + message);
        System.out.println("[이메일] 발송 완료");
    }

    @Override
    public void disconnect() {
        System.out.println("[이메일] 서버 연결 해제");
    }
}

/**
 * SMS 알림 발송
 */
class SmsNotificationSender extends NotificationSender {
    private String apiKey;

    public SmsNotificationSender(String recipient, String message, String apiKey) {
        super(recipient, message);
        this.apiKey = apiKey;
    }

    @Override
    public void connect() {
        System.out.println("[SMS] API 인증: " + apiKey);
    }

    @Override
    public void send() {
        System.out.println("[SMS] 수신 번호: " + recipient);
        System.out.println("[SMS] 내용: " + message);
        System.out.println("[SMS] 발송 완료");
    }

    @Override
    public void disconnect() {
        System.out.println("[SMS] API 연결 해제");
    }
}

/**
 * 푸시 알림 발송
 */
class PushNotificationSender extends NotificationSender {
    private String deviceToken;

    public PushNotificationSender(String recipient, String message, String deviceToken) {
        super(recipient, message);
        this.deviceToken = deviceToken;
    }

    @Override
    public void connect() {
        System.out.println("[푸시] 기기 연결: " + deviceToken);
    }

    @Override
    public void send() {
        System.out.println("[푸시] 수신자: " + recipient);
        System.out.println("[푸시] 내용: " + message);
        System.out.println("[푸시] 발송 완료");
    }

    @Override
    public void disconnect() {
        System.out.println("[푸시] 기기 연결 해제");
    }
}

/**
 * 시나리오 2 테스트
 */
class Scenario2Test {
    public static void main(String[] args) {
        System.out.println("==========================================");
        System.out.println("시나리오 2: 추상 메서드 구현 누락");
        System.out.println("==========================================\n");

        // 이메일 발송
        NotificationSender email = new EmailNotificationSender(
            "user@example.com",
            "회의가 10분 후에 시작됩니다",
            "smtp.gmail.com"
        );
        email.sendNotification();

        // SMS 발송
        NotificationSender sms = new SmsNotificationSender(
            "010-1234-5678",
            "인증번호: 123456",
            "SMS_API_KEY_12345"
        );
        sms.sendNotification();

        // 푸시 알림 발송
        NotificationSender push = new PushNotificationSender(
            "김철수",
            "새로운 메시지가 도착했습니다",
            "DEVICE_TOKEN_ABC123"
        );
        push.sendNotification();

        System.out.println("💡 교훈:");
        System.out.println("   - 추상 클래스를 상속받으면 모든 추상 메서드를 반드시 구현해야 합니다");
        System.out.println("   - 하나라도 구현하지 않으면 컴파일 에러가 발생합니다");
        System.out.println("   - IDE의 자동 완성 기능을 활용하면 누락을 방지할 수 있습니다");
    }
}
```

### 📝 배운 점

- **모든 추상 메서드 구현 필수**: 하나라도 빠뜨리면 컴파일 에러
- **컴파일러가 강제**: 추상 클래스를 상속받으면 반드시 모든 추상 메서드를 구현해야 컴파일됨
- **IDE 활용**: 현대 IDE는 자동으로 구현해야 할 메서드를 알려주고, 자동 완성 기능 제공

---

## 🔍 시나리오 3: 추상 클래스 vs 인터페이스 혼동

### ❌ 문제 상황

```java
/**
 * 주니어 개발자의 고민:
 * "로깅 기능을 만들어야 하는데, 추상 클래스를 써야 할까? 인터페이스를 써야 할까?"
 */

/**
 * 잘못된 선택 1: 인터페이스로 만들었는데 중복 코드가 많아짐
 */
interface Logger_Wrong {
    void log(String message);
    void logError(String message);
    void logWarning(String message);
    void logInfo(String message);
}

class FileLogger_Wrong implements Logger_Wrong {
    private String logFilePath;

    public FileLogger_Wrong(String logFilePath) {
        this.logFilePath = logFilePath;
    }

    @Override
    public void log(String message) {
        // 중복 코드: 타임스탬프 추가
        String timestamp = java.time.LocalDateTime.now().toString();
        writeToFile("[LOG] " + timestamp + " - " + message);
    }

    @Override
    public void logError(String message) {
        // 중복 코드: 타임스탬프 추가
        String timestamp = java.time.LocalDateTime.now().toString();
        writeToFile("[ERROR] " + timestamp + " - " + message);
    }

    @Override
    public void logWarning(String message) {
        // 중복 코드: 타임스탬프 추가
        String timestamp = java.time.LocalDateTime.now().toString();
        writeToFile("[WARNING] " + timestamp + " - " + message);
    }

    @Override
    public void logInfo(String message) {
        // 중복 코드: 타임스탬프 추가
        String timestamp = java.time.LocalDateTime.now().toString();
        writeToFile("[INFO] " + timestamp + " - " + message);
    }

    private void writeToFile(String message) {
        System.out.println("파일에 기록: " + logFilePath + " -> " + message);
    }
}

// 문제점: ConsoleLogger, DatabaseLogger 등을 만들 때마다
// 타임스탬프 추가 로직이 중복됨!
```

### ✅ 올바른 해결 방법

```java
/**
 * 올바른 선택: 추상 클래스 사용
 * 공통 기능(타임스탬프 추가)은 부모 클래스에서 구현
 */
abstract class Logger {
    protected String applicationName;

    public Logger(String applicationName) {
        this.applicationName = applicationName;
    }

    // 템플릿 메서드: 로그 기록의 전체 흐름을 정의
    public final void log(String level, String message) {
        String formattedMessage = formatMessage(level, message);
        writeLog(formattedMessage);
    }

    // 공통 메서드: 모든 로거에서 동일하게 사용
    private String formatMessage(String level, String message) {
        String timestamp = java.time.LocalDateTime.now().toString();
        return String.format("[%s] %s [%s] %s",
            applicationName, timestamp, level, message);
    }

    // 추상 메서드: 각 로거가 자신만의 방식으로 구현
    protected abstract void writeLog(String formattedMessage);

    // 편의 메서드들
    public void info(String message) {
        log("INFO", message);
    }

    public void warning(String message) {
        log("WARNING", message);
    }

    public void error(String message) {
        log("ERROR", message);
    }

    public void debug(String message) {
        log("DEBUG", message);
    }
}

/**
 * 파일 로거
 */
class FileLogger extends Logger {
    private String logFilePath;

    public FileLogger(String applicationName, String logFilePath) {
        super(applicationName);
        this.logFilePath = logFilePath;
    }

    @Override
    protected void writeLog(String formattedMessage) {
        // 파일에 기록하는 로직만 구현하면 됨
        System.out.println("→ 파일 기록: " + logFilePath);
        System.out.println("  " + formattedMessage);
    }
}

/**
 * 콘솔 로거
 */
class ConsoleLogger extends Logger {
    private boolean colorEnabled;

    public ConsoleLogger(String applicationName, boolean colorEnabled) {
        super(applicationName);
        this.colorEnabled = colorEnabled;
    }

    @Override
    protected void writeLog(String formattedMessage) {
        // 콘솔에 출력하는 로직만 구현하면 됨
        if (colorEnabled) {
            System.out.println("→ 콘솔 출력 (컬러 모드):");
        } else {
            System.out.println("→ 콘솔 출력:");
        }
        System.out.println("  " + formattedMessage);
    }
}

/**
 * 데이터베이스 로거
 */
class DatabaseLogger extends Logger {
    private String connectionString;

    public DatabaseLogger(String applicationName, String connectionString) {
        super(applicationName);
        this.connectionString = connectionString;
    }

    @Override
    protected void writeLog(String formattedMessage) {
        // 데이터베이스에 저장하는 로직만 구현하면 됨
        System.out.println("→ DB 저장: " + connectionString);
        System.out.println("  " + formattedMessage);
    }
}

/**
 * 시나리오 3 테스트
 */
class Scenario3Test {
    public static void main(String[] args) {
        System.out.println("================================================");
        System.out.println("시나리오 3: 추상 클래스 vs 인터페이스 혼동");
        System.out.println("================================================\n");

        // 파일 로거 사용
        System.out.println("### 파일 로거 ###");
        Logger fileLogger = new FileLogger("MyApp", "/var/log/myapp.log");
        fileLogger.info("애플리케이션 시작");
        fileLogger.error("데이터베이스 연결 실패");
        System.out.println();

        // 콘솔 로거 사용
        System.out.println("### 콘솔 로거 ###");
        Logger consoleLogger = new ConsoleLogger("MyApp", true);
        consoleLogger.warning("메모리 사용량이 80%를 초과했습니다");
        consoleLogger.debug("사용자 로그인: user@example.com");
        System.out.println();

        // 데이터베이스 로거 사용
        System.out.println("### 데이터베이스 로거 ###");
        Logger dbLogger = new DatabaseLogger("MyApp", "jdbc:mysql://localhost/logs");
        dbLogger.info("결제 처리 완료");
        System.out.println();

        System.out.println("💡 교훈:");
        System.out.println("   추상 클래스를 사용해야 하는 경우:");
        System.out.println("   ✓ 공통 필드가 있을 때 (applicationName)");
        System.out.println("   ✓ 공통 메서드 구현이 필요할 때 (formatMessage)");
        System.out.println("   ✓ 생성자 로직을 공유해야 할 때");
        System.out.println("   ✓ 코드 중복을 피하고 싶을 때");
        System.out.println();
        System.out.println("   인터페이스를 사용해야 하는 경우:");
        System.out.println("   ✓ 다중 상속이 필요할 때");
        System.out.println("   ✓ 서로 관련 없는 클래스들이 같은 동작을 해야 할 때");
        System.out.println("   ✓ '행위'만 정의하고 구현은 전혀 공유하지 않을 때");
    }
}
```

### 📝 배운 점

**추상 클래스를 선택해야 할 때:**
- 공통 필드(상태)를 가질 때
- 공통 메서드 구현을 공유해야 할 때
- 생성자 로직을 공유해야 할 때
- IS-A 관계 (상속 관계)가 명확할 때

**인터페이스를 선택해야 할 때:**
- 다중 상속이 필요할 때
- 서로 관련 없는 클래스들이 같은 동작을 해야 할 때
- 구현을 전혀 공유하지 않을 때
- CAN-DO 관계 (능력)를 나타낼 때

---

## 🔍 시나리오 4: final 메서드의 의미를 이해하지 못함

### ❌ 문제 상황

```java
/**
 * 게임 캐릭터 추상 클래스
 */
abstract class GameCharacter_Problem {
    protected String name;
    protected int hp;
    protected int maxHp;
    protected int level;

    public GameCharacter_Problem(String name, int maxHp, int level) {
        this.name = name;
        this.maxHp = maxHp;
        this.hp = maxHp;
        this.level = level;
    }

    // 추상 메서드
    public abstract void attack(GameCharacter_Problem target);
    public abstract void useSkill(GameCharacter_Problem target);

    // 일반 메서드 (final이 없음!)
    public void takeDamage(int damage) {
        hp -= damage;
        if (hp < 0) hp = 0;
        System.out.println(name + "이(가) " + damage + " 데미지를 받았습니다. (HP: " + hp + "/" + maxHp + ")");
    }
}

/**
 * 주니어 개발자의 잘못된 코드
 * 문제: takeDamage 메서드를 잘못 오버라이드하여 게임 밸런스가 깨짐
 */
class CheatingWarrior extends GameCharacter_Problem {

    public CheatingWarrior(String name) {
        super(name, 1000, 1);
    }

    @Override
    public void attack(GameCharacter_Problem target) {
        System.out.println(name + "의 일반 공격!");
        target.takeDamage(100);
    }

    @Override
    public void useSkill(GameCharacter_Problem target) {
        System.out.println(name + "의 강타!");
        target.takeDamage(200);
    }

    // 문제가 되는 코드: HP가 절대 줄어들지 않도록 오버라이드!
    @Override
    public void takeDamage(int damage) {
        System.out.println(name + "은(는) 무적입니다! 데미지를 받지 않습니다.");
        // HP를 줄이지 않음 - 게임 밸런스 파괴!
    }
}
```

### ✅ 올바른 해결 방법

```java
/**
 * 게임 캐릭터 추상 클래스 - final 키워드로 핵심 로직 보호
 */
abstract class GameCharacter {
    protected String name;
    protected int hp;
    protected int maxHp;
    protected int level;
    protected int defense;

    public GameCharacter(String name, int maxHp, int level, int defense) {
        this.name = name;
        this.maxHp = maxHp;
        this.hp = maxHp;
        this.level = level;
        this.defense = defense;
    }

    // 추상 메서드 - 하위 클래스에서 반드시 구현
    public abstract void attack(GameCharacter target);
    public abstract void useSkill(GameCharacter target);

    /**
     * final 메서드: 하위 클래스에서 오버라이드할 수 없음
     * 게임의 핵심 규칙을 보호
     */
    public final void takeDamage(int damage) {
        // 방어력 계산
        int actualDamage = calculateDamage(damage);

        hp -= actualDamage;
        if (hp < 0) hp = 0;

        System.out.println(name + "이(가) " + actualDamage + " 데미지를 받았습니다. (HP: " + hp + "/" + maxHp + ")");

        if (hp == 0) {
            onDeath();
        }
    }

    /**
     * 데미지 계산 - 하위 클래스에서 커스터마이즈 가능
     */
    protected int calculateDamage(int incomingDamage) {
        // 기본 방어력 계산
        int reducedDamage = incomingDamage - defense;
        return Math.max(reducedDamage, 1); // 최소 1의 데미지는 들어감
    }

    /**
     * 사망 처리 - 하위 클래스에서 커스터마이즈 가능
     */
    protected void onDeath() {
        System.out.println(name + "이(가) 쓰러졌습니다!");
    }

    /**
     * final 메서드: 회복 로직도 보호
     */
    public final void heal(int amount) {
        hp += amount;
        if (hp > maxHp) hp = maxHp;
        System.out.println(name + "이(가) " + amount + " HP를 회복했습니다. (HP: " + hp + "/" + maxHp + ")");
    }

    public boolean isAlive() {
        return hp > 0;
    }

    public String getName() {
        return name;
    }
}

/**
 * 전사 클래스
 */
class Warrior extends GameCharacter {

    public Warrior(String name) {
        super(name, 1000, 1, 50); // 높은 HP와 방어력
    }

    @Override
    public void attack(GameCharacter target) {
        System.out.println("[" + name + "] 검으로 베기!");
        target.takeDamage(120);
    }

    @Override
    public void useSkill(GameCharacter target) {
        System.out.println("[" + name + "] 강력한 일격!");
        target.takeDamage(250);
    }

    /**
     * 전사만의 특별한 방어력 계산
     */
    @Override
    protected int calculateDamage(int incomingDamage) {
        // 전사는 방어력이 2배로 적용됨
        int reducedDamage = incomingDamage - (defense * 2);
        return Math.max(reducedDamage, 1);
    }

    /**
     * 전사의 특별한 사망 효과
     */
    @Override
    protected void onDeath() {
        super.onDeath();
        System.out.println("→ 전사의 의지: 마지막 반격!");
    }

    // takeDamage()나 heal()은 final이므로 오버라이드 불가!
    // @Override
    // public void takeDamage(int damage) {  // 컴파일 에러!
    //     // Cannot override the final method from GameCharacter
    // }
}

/**
 * 마법사 클래스
 */
class Mage extends GameCharacter {

    public Mage(String name) {
        super(name, 600, 1, 20); // 낮은 HP와 방어력
    }

    @Override
    public void attack(GameCharacter target) {
        System.out.println("[" + name + "] 마법 미사일!");
        target.takeDamage(150);
    }

    @Override
    public void useSkill(GameCharacter target) {
        System.out.println("[" + name + "] 화염 폭풍!");
        target.takeDamage(300);
    }

    /**
     * 마법사만의 특별한 사망 효과
     */
    @Override
    protected void onDeath() {
        super.onDeath();
        System.out.println("→ 마법의 폭발: 주변에 피해를 입힘!");
    }
}

/**
 * 힐러 클래스
 */
class Healer extends GameCharacter {

    public Healer(String name) {
        super(name, 700, 1, 30);
    }

    @Override
    public void attack(GameCharacter target) {
        System.out.println("[" + name + "] 지팡이 타격!");
        target.takeDamage(80);
    }

    @Override
    public void useSkill(GameCharacter target) {
        System.out.println("[" + name + "] 치유의 빛!");
        target.heal(200); // final 메서드 사용
    }

    /**
     * 힐러의 특별한 방어 능력
     */
    @Override
    protected int calculateDamage(int incomingDamage) {
        // 힐러는 받는 데미지의 80%만 받음
        int reducedDamage = (int) ((incomingDamage - defense) * 0.8);
        return Math.max(reducedDamage, 1);
    }
}

/**
 * 시나리오 4 테스트
 */
class Scenario4Test {
    public static void main(String[] args) {
        System.out.println("==============================================");
        System.out.println("시나리오 4: final 메서드의 의미");
        System.out.println("==============================================\n");

        // 캐릭터 생성
        GameCharacter warrior = new Warrior("전사A");
        GameCharacter mage = new Mage("마법사B");
        GameCharacter healer = new Healer("힐러C");

        System.out.println("### 전투 시작 ###\n");

        // 턴 1: 마법사가 전사 공격
        System.out.println("--- 턴 1 ---");
        mage.attack(warrior);
        System.out.println();

        // 턴 2: 전사가 마법사 공격
        System.out.println("--- 턴 2 ---");
        warrior.attack(mage);
        System.out.println();

        // 턴 3: 힐러가 마법사 치료
        System.out.println("--- 턴 3 ---");
        healer.useSkill(mage);
        System.out.println();

        // 턴 4: 전사가 스킬로 마법사 공격
        System.out.println("--- 턴 4 ---");
        warrior.useSkill(mage);
        System.out.println();

        // 턴 5: 마법사가 스킬로 전사 공격
        System.out.println("--- 턴 5 ---");
        mage.useSkill(warrior);
        System.out.println();

        System.out.println("### 전투 종료 ###\n");

        // 생존자 확인
        System.out.println("생존 상황:");
        System.out.println("  " + warrior.getName() + ": " + (warrior.isAlive() ? "생존" : "사망"));
        System.out.println("  " + mage.getName() + ": " + (mage.isAlive() ? "생존" : "사망"));
        System.out.println("  " + healer.getName() + ": " + (healer.isAlive() ? "생존" : "사망"));

        System.out.println("\n💡 교훈:");
        System.out.println("   - final 메서드는 하위 클래스에서 오버라이드할 수 없습니다");
        System.out.println("   - 게임의 핵심 규칙(HP 감소, 회복)은 final로 보호해야 합니다");
        System.out.println("   - 대신 calculateDamage(), onDeath() 같은 Hook 메서드를 제공하여");
        System.out.println("     하위 클래스가 특정 부분만 커스터마이즈할 수 있도록 합니다");
        System.out.println("   - 이렇게 하면 게임 밸런스를 유지하면서도 다양한 캐릭터를 만들 수 있습니다");
    }
}
```

### 📝 배운 점

**final 메서드를 사용해야 하는 경우:**
- 핵심 비즈니스 로직을 보호해야 할 때
- 알고리즘의 전체 흐름을 변경하면 안 될 때
- 보안이나 무결성이 중요한 로직
- 템플릿 메서드 패턴에서 전체 흐름을 정의하는 메서드

**Hook 메서드 제공:**
- final 메서드 내부에서 호출되는 protected 메서드를 제공
- 하위 클래스가 세부 사항만 커스터마이즈 가능
- 전체 구조는 보호하면서 유연성도 확보

---

## 📚 정리

이번 Part 2에서는 다음을 학습했습니다:

### 🏢 기업 사례
1. **Spring Framework의 AbstractController**: 템플릿 메서드 패턴으로 웹 요청 처리
2. **Apache HttpClient의 AbstractHttpEntity**: 다양한 데이터 소스를 통합 처리
3. **Android의 AsyncTask**: 백그라운드 작업의 생명주기 관리

### 👨‍💻 주니어 개발자 시나리오
1. **시나리오 1**: 추상 클래스를 인스턴스화하려는 실수
2. **시나리오 2**: 추상 메서드 구현 누락
3. **시나리오 3**: 추상 클래스 vs 인터페이스 혼동
4. **시나리오 4**: final 메서드의 의미를 이해하지 못함

### 🎯 핵심 포인트
- 추상 클래스는 설계도이며, 직접 인스턴스화할 수 없음
- 모든 추상 메서드는 반드시 구현해야 함
- 공통 기능이 있으면 추상 클래스, 행위만 정의하면 인터페이스
- final 메서드로 핵심 로직을 보호하고, Hook 메서드로 유연성 제공
