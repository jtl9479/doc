# 📝 Chapter 22-3: 내부 클래스 (Inner Classes) Part 3

## 🎯 학습 목표
- 내부 클래스를 활용한 실전 프로젝트를 완성합니다
- Event Bus 시스템을 통해 Observer 패턴을 이해합니다
- 4가지 내부 클래스를 종합적으로 활용합니다
- FAQ와 면접 질문을 통해 내부 클래스 개념을 완전히 마스터합니다

---

## 🚀 실전 프로젝트: Event Bus System

### 프로젝트 개요
**프로젝트명**: SimpleEventBus - 이벤트 기반 메시징 시스템
**목표**: 컴포넌트 간 느슨한 결합(Loose Coupling)을 유지하면서 이벤트를 전달하는 시스템 구축
**기술 스택**: Inner Classes, Observer Pattern, Generic, Reflection

### 주요 기능
1. ✅ 이벤트 발행 (Publish)
2. ✅ 이벤트 구독 (Subscribe)
3. ✅ 우선순위 기반 처리
4. ✅ 비동기 이벤트 처리
5. ✅ 타입 안전성 보장

---

## 💻 전체 코드

```java
// 📁 EventBusSystem.java

import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ 이벤트 클래스들
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

abstract class Event {
    private final long timestamp;
    private final String source;

    public Event(String source) {
        this.timestamp = System.currentTimeMillis();
        this.source = source;
    }

    public long getTimestamp() { return timestamp; }
    public String getSource() { return source; }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{source='" + source + "'}";
    }
}

class UserRegisteredEvent extends Event {
    private final String username;
    private final String email;

    public UserRegisteredEvent(String source, String username, String email) {
        super(source);
        this.username = username;
        this.email = email;
    }

    public String getUsername() { return username; }
    public String getEmail() { return email; }

    @Override
    public String toString() {
        return "UserRegisteredEvent{username='" + username + "', email='" + email + "'}";
    }
}

class OrderPlacedEvent extends Event {
    private final String orderId;
    private final int amount;

    public OrderPlacedEvent(String source, String orderId, int amount) {
        super(source);
        this.orderId = orderId;
        this.amount = amount;
    }

    public String getOrderId() { return orderId; }
    public int getAmount() { return amount; }

    @Override
    public String toString() {
        return "OrderPlacedEvent{orderId='" + orderId + "', amount=" + amount + "}";
    }
}

class PaymentCompletedEvent extends Event {
    private final String paymentId;
    private final String method;

    public PaymentCompletedEvent(String source, String paymentId, String method) {
        super(source);
        this.paymentId = paymentId;
        this.method = method;
    }

    public String getPaymentId() { return paymentId; }
    public String getMethod() { return method; }

    @Override
    public String toString() {
        return "PaymentCompletedEvent{paymentId='" + paymentId + "', method='" + method + "'}";
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ EventBus 핵심 클래스
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class EventBus {

    // ✅ Static Nested Class: Subscription (구독 정보)
    private static class Subscription {
        final Object subscriber;
        final Method method;
        final Class<? extends Event> eventType;
        final int priority;

        Subscription(Object subscriber, Method method, Class<? extends Event> eventType, int priority) {
            this.subscriber = subscriber;
            this.method = method;
            this.eventType = eventType;
            this.priority = priority;
            method.setAccessible(true);
        }

        void invoke(Event event) {
            try {
                method.invoke(subscriber, event);
            } catch (Exception e) {
                System.err.println("⚠️ 이벤트 처리 오류: " + e.getMessage());
            }
        }
    }

    // 이벤트 타입별 구독자 목록
    private final Map<Class<? extends Event>, List<Subscription>> subscriptions = new ConcurrentHashMap<>();

    // 비동기 처리용 ExecutorService
    private final ExecutorService executorService = Executors.newFixedThreadPool(4);

    // ✅ Member Inner Class: EventPublisher (이벤트 발행자)
    public class EventPublisher {
        private final String publisherName;

        public EventPublisher(String publisherName) {
            this.publisherName = publisherName;
        }

        public void publish(Event event) {
            System.out.println("📤 [" + publisherName + "] 이벤트 발행: " + event);

            List<Subscription> subs = subscriptions.get(event.getClass());
            if (subs == null || subs.isEmpty()) {
                System.out.println("   (구독자 없음)");
                return;
            }

            // 우선순위 정렬
            List<Subscription> sortedSubs = new ArrayList<>(subs);
            sortedSubs.sort((s1, s2) -> Integer.compare(s2.priority, s1.priority));

            // 동기 처리
            for (Subscription sub : sortedSubs) {
                sub.invoke(event);
            }
        }

        public void publishAsync(Event event) {
            System.out.println("📤 [" + publisherName + "] 비동기 이벤트 발행: " + event);

            executorService.submit(() -> {
                try {
                    Thread.sleep(100);  // 네트워크 지연 시뮬레이션
                    publish(event);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
    }

    // 구독자 등록
    public void register(Object subscriber) {
        System.out.println("✅ 구독자 등록: " + subscriber.getClass().getSimpleName());

        for (Method method : subscriber.getClass().getDeclaredMethods()) {
            if (method.isAnnotationPresent(Subscribe.class)) {
                Class<?>[] paramTypes = method.getParameterTypes();

                if (paramTypes.length == 1 && Event.class.isAssignableFrom(paramTypes[0])) {
                    @SuppressWarnings("unchecked")
                    Class<? extends Event> eventType = (Class<? extends Event>) paramTypes[0];

                    Subscribe annotation = method.getAnnotation(Subscribe.class);
                    int priority = annotation.priority();

                    Subscription subscription = new Subscription(subscriber, method, eventType, priority);

                    subscriptions.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                               .add(subscription);

                    System.out.println("   - " + method.getName() + "() → " + eventType.getSimpleName() + " (우선순위: " + priority + ")");
                }
            }
        }
    }

    // Publisher 생성
    public EventPublisher createPublisher(String name) {
        return new EventPublisher(name);
    }

    // 종료
    public void shutdown() {
        executorService.shutdown();
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3️⃣ Subscribe Annotation
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Subscribe {
    int priority() default 0;  // 우선순위 (높을수록 먼저 실행)
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 4️⃣ 구독자 클래스들
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class EmailService {

    @Subscribe(priority = 100)  // 높은 우선순위
    public void onUserRegistered(UserRegisteredEvent event) {
        System.out.println("   📧 [EmailService] 환영 이메일 발송: " + event.getEmail());
    }

    @Subscribe
    public void onOrderPlaced(OrderPlacedEvent event) {
        System.out.println("   📧 [EmailService] 주문 확인 이메일 발송: " + event.getOrderId());
    }

    @Subscribe
    public void onPaymentCompleted(PaymentCompletedEvent event) {
        System.out.println("   📧 [EmailService] 결제 완료 이메일 발송: " + event.getPaymentId());
    }
}

class NotificationService {

    @Subscribe(priority = 50)
    public void onUserRegistered(UserRegisteredEvent event) {
        System.out.println("   🔔 [NotificationService] 푸시 알림: " + event.getUsername() + "님 가입 완료");
    }

    @Subscribe
    public void onPaymentCompleted(PaymentCompletedEvent event) {
        System.out.println("   🔔 [NotificationService] 결제 완료 알림");
    }
}

class AnalyticsService {

    @Subscribe(priority = 10)  // 낮은 우선순위 (마지막에 실행)
    public void onUserRegistered(UserRegisteredEvent event) {
        System.out.println("   📊 [AnalyticsService] 가입 통계 업데이트");
    }

    @Subscribe
    public void onOrderPlaced(OrderPlacedEvent event) {
        System.out.println("   📊 [AnalyticsService] 주문 통계 업데이트: " + event.getAmount() + "원");
    }

    @Subscribe
    public void onPaymentCompleted(PaymentCompletedEvent event) {
        System.out.println("   📊 [AnalyticsService] 매출 통계 업데이트");
    }
}

class InventoryService {

    @Subscribe(priority = 90)  // 높은 우선순위 (재고는 빨리 차감)
    public void onOrderPlaced(OrderPlacedEvent event) {
        System.out.println("   📦 [InventoryService] 재고 차감: 주문 " + event.getOrderId());
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5️⃣ 실행 및 테스트
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

public class EventBusSystem {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== Event Bus System - 실전 프로젝트 ===\n");

        EventBus eventBus = new EventBus();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 구독자 등록
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(60));
        System.out.println("1️⃣ 구독자 등록");
        System.out.println("=".repeat(60) + "\n");

        EmailService emailService = new EmailService();
        NotificationService notificationService = new NotificationService();
        AnalyticsService analyticsService = new AnalyticsService();
        InventoryService inventoryService = new InventoryService();

        eventBus.register(emailService);
        eventBus.register(notificationService);
        eventBus.register(analyticsService);
        eventBus.register(inventoryService);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Publisher 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        EventBus.EventPublisher userPublisher = eventBus.createPublisher("UserService");
        EventBus.EventPublisher orderPublisher = eventBus.createPublisher("OrderService");
        EventBus.EventPublisher paymentPublisher = eventBus.createPublisher("PaymentService");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Scenario 1: 사용자 가입
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("2️⃣ Scenario 1: 사용자 가입 (우선순위 확인)");
        System.out.println("=".repeat(60) + "\n");

        UserRegisteredEvent userEvent = new UserRegisteredEvent(
            "UserService",
            "김철수",
            "chulsoo@example.com"
        );
        userPublisher.publish(userEvent);

        System.out.println("\n💡 우선순위 순서:");
        System.out.println("   1. EmailService (100) - 가장 먼저");
        System.out.println("   2. NotificationService (50)");
        System.out.println("   3. AnalyticsService (10) - 가장 나중");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Scenario 2: 주문 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("3️⃣ Scenario 2: 주문 생성");
        System.out.println("=".repeat(60) + "\n");

        OrderPlacedEvent orderEvent = new OrderPlacedEvent(
            "OrderService",
            "ORDER-001",
            150000
        );
        orderPublisher.publish(orderEvent);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Scenario 3: 결제 완료
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("4️⃣ Scenario 3: 결제 완료");
        System.out.println("=".repeat(60) + "\n");

        PaymentCompletedEvent paymentEvent = new PaymentCompletedEvent(
            "PaymentService",
            "PAY-001",
            "카카오페이"
        );
        paymentPublisher.publish(paymentEvent);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Scenario 4: 비동기 이벤트
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("5️⃣ Scenario 4: 비동기 이벤트 발행");
        System.out.println("=".repeat(60) + "\n");

        System.out.println("비동기 이벤트 발행 시작...");
        orderPublisher.publishAsync(new OrderPlacedEvent("OrderService", "ORDER-002", 200000));
        System.out.println("메인 스레드는 계속 실행됩니다...\n");

        Thread.sleep(500);  // 비동기 처리 완료 대기

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 프로젝트 요약
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("=".repeat(60));
        System.out.println("\n🎯 Event Bus System 핵심 기능:");

        System.out.println("\n1️⃣ 내부 클래스 활용:");
        System.out.println("   - Static Nested Class (Subscription): 구독 정보 캡슐화");
        System.out.println("   - Member Inner Class (EventPublisher): EventBus 멤버 접근");

        System.out.println("\n2️⃣ 느슨한 결합 (Loose Coupling):");
        System.out.println("   - Publisher는 Subscriber를 직접 알 필요 없음");
        System.out.println("   - 새로운 Subscriber 추가 시 기존 코드 수정 불필요");

        System.out.println("\n3️⃣ 우선순위 처리:");
        System.out.println("   - @Subscribe(priority = N)로 실행 순서 제어");
        System.out.println("   - 중요한 작업 먼저 처리 (재고 차감, 이메일 발송 등)");

        System.out.println("\n4️⃣ 비동기 처리:");
        System.out.println("   - publishAsync()로 비동기 이벤트 발행");
        System.out.println("   - 메인 스레드 블로킹 방지");

        System.out.println("\n5️⃣ 타입 안전성:");
        System.out.println("   - Generic과 Reflection으로 타입 안전 보장");
        System.out.println("   - 잘못된 이벤트 타입 컴파일 에러");

        System.out.println("\n" + "=".repeat(60));
        System.out.println("\n🌟 실무 활용:");
        System.out.println("  - Guava EventBus");
        System.out.println("  - Spring ApplicationEventPublisher");
        System.out.println("  - Android EventBus (greenrobot)");
        System.out.println("  - RxJava Subject/Observable");

        eventBus.shutdown();
    }
}
```

**실행 결과:**
```
=== Event Bus System - 실전 프로젝트 ===

============================================================
1️⃣ 구독자 등록
============================================================

✅ 구독자 등록: EmailService
   - onUserRegistered() → UserRegisteredEvent (우선순위: 100)
   - onOrderPlaced() → OrderPlacedEvent (우선순위: 0)
   - onPaymentCompleted() → PaymentCompletedEvent (우선순위: 0)
✅ 구독자 등록: NotificationService
   - onUserRegistered() → UserRegisteredEvent (우선순위: 50)
   - onPaymentCompleted() → PaymentCompletedEvent (우선순위: 0)
✅ 구독자 등록: AnalyticsService
   - onUserRegistered() → UserRegisteredEvent (우선순위: 10)
   - onOrderPlaced() → OrderPlacedEvent (우선순위: 0)
   - onPaymentCompleted() → PaymentCompletedEvent (우선순위: 0)
✅ 구독자 등록: InventoryService
   - onOrderPlaced() → OrderPlacedEvent (우선순위: 90)

============================================================
2️⃣ Scenario 1: 사용자 가입 (우선순위 확인)
============================================================

📤 [UserService] 이벤트 발행: UserRegisteredEvent{username='김철수', email='chulsoo@example.com'}
   📧 [EmailService] 환영 이메일 발송: chulsoo@example.com
   🔔 [NotificationService] 푸시 알림: 김철수님 가입 완료
   📊 [AnalyticsService] 가입 통계 업데이트

💡 우선순위 순서:
   1. EmailService (100) - 가장 먼저
   2. NotificationService (50)
   3. AnalyticsService (10) - 가장 나중

============================================================
3️⃣ Scenario 2: 주문 생성
============================================================

📤 [OrderService] 이벤트 발행: OrderPlacedEvent{orderId='ORDER-001', amount=150000}
   📦 [InventoryService] 재고 차감: 주문 ORDER-001
   📧 [EmailService] 주문 확인 이메일 발송: ORDER-001
   📊 [AnalyticsService] 주문 통계 업데이트: 150000원

============================================================
4️⃣ Scenario 3: 결제 완료
============================================================

📤 [PaymentService] 이벤트 발행: PaymentCompletedEvent{paymentId='PAY-001', method='카카오페이'}
   📧 [EmailService] 결제 완료 이메일 발송: PAY-001
   🔔 [NotificationService] 결제 완료 알림
   📊 [AnalyticsService] 매출 통계 업데이트

============================================================
5️⃣ Scenario 4: 비동기 이벤트 발행
============================================================

비동기 이벤트 발행 시작...
📤 [OrderService] 비동기 이벤트 발행: OrderPlacedEvent{orderId='ORDER-002', amount=200000}
메인 스레드는 계속 실행됩니다...

📤 [OrderService] 이벤트 발행: OrderPlacedEvent{orderId='ORDER-002', amount=200000}
   📦 [InventoryService] 재고 차감: 주문 ORDER-002
   📧 [EmailService] 주문 확인 이메일 발송: ORDER-002
   📊 [AnalyticsService] 주문 통계 업데이트: 200000원

============================================================
============================================================

🎯 Event Bus System 핵심 기능:

1️⃣ 내부 클래스 활용:
   - Static Nested Class (Subscription): 구독 정보 캡슐화
   - Member Inner Class (EventPublisher): EventBus 멤버 접근

2️⃣ 느슨한 결합 (Loose Coupling):
   - Publisher는 Subscriber를 직접 알 필요 없음
   - 새로운 Subscriber 추가 시 기존 코드 수정 불필요

3️⃣ 우선순위 처리:
   - @Subscribe(priority = N)로 실행 순서 제어
   - 중요한 작업 먼저 처리 (재고 차감, 이메일 발송 등)

4️⃣ 비동기 처리:
   - publishAsync()로 비동기 이벤트 발행
   - 메인 스레드 블로킹 방지

5️⃣ 타입 안전성:
   - Generic과 Reflection으로 타입 안전 보장
   - 잘못된 이벤트 타입 컴파일 에러

============================================================

🌟 실무 활용:
  - Guava EventBus
  - Spring ApplicationEventPublisher
  - Android EventBus (greenrobot)
  - RxJava Subject/Observable
```

---

## ❓ FAQ - 자주 묻는 질문

### Q1. 내부 클래스는 언제 사용해야 하나요?

**A:** 다음 경우에 내부 클래스를 고려하세요.

✅ **사용해야 할 때:**
1. **강한 응집도**: 내부 클래스가 외부 클래스와 밀접하게 관련
   ```java
   class ArrayList {
       private class Itr implements Iterator {}  // ArrayList와 밀접
   }
   ```

2. **캡슐화**: 외부에 노출할 필요 없는 헬퍼 클래스
   ```java
   class LinkedList {
       private class Node {}  // 외부에서 사용 불필요
   }
   ```

3. **외부 멤버 접근**: 외부 클래스의 private 멤버 접근 필요
   ```java
   class Outer {
       private int value;
       class Inner {
           void access() { System.out.println(value); }  // 접근 가능
       }
   }
   ```

❌ **사용하지 말아야 할 때:**
- 내부 클래스가 외부 클래스와 독립적
- 다른 곳에서도 재사용 가능
- 논리적 연관성이 약함

---

### Q2. Member Inner Class와 Static Nested Class의 차이점은?

**A:**

| 구분 | Member Inner Class | Static Nested Class |
|-----|-------------------|---------------------|
| 외부 인스턴스 | 필요 O | 필요 X |
| 외부 멤버 접근 | 모든 멤버 | static만 |
| 생성 방법 | `outer.new Inner()` | `new Outer.Inner()` |
| 메모리 | 외부 참조 유지 | 외부 참조 없음 |
| 사용 시나리오 | Iterator, Entry | Builder, Utility |

**예시:**
```java
class Outer {
    private int instanceVar = 10;
    private static int staticVar = 20;

    // Member Inner Class
    class MemberInner {
        void access() {
            System.out.println(instanceVar);  // OK
            System.out.println(staticVar);    // OK
        }
    }

    // Static Nested Class
    static class StaticNested {
        void access() {
            // System.out.println(instanceVar);  // 컴파일 에러!
            System.out.println(staticVar);    // OK
        }
    }
}

// 사용
Outer outer = new Outer();
Outer.MemberInner inner1 = outer.new MemberInner();  // 외부 인스턴스 필요
Outer.StaticNested inner2 = new Outer.StaticNested();  // 외부 인스턴스 불필요
```

---

### Q3. 왜 익명 클래스에서 지역 변수는 final이어야 하나요?

**A:** 메모리 구조와 생명주기 차이 때문입니다.

**메모리 구조:**
- 지역 변수: 스택(Stack)에 저장
- 익명 클래스 인스턴스: 힙(Heap)에 저장

**문제 상황:**
```java
void method() {
    int count = 0;  // 스택에 저장

    Runnable r = new Runnable() {
        public void run() {
            System.out.println(count);  // count를 사용
        }
    };

    // method()가 종료되면 count는 스택에서 사라짐
    // 하지만 Runnable 인스턴스는 힙에 남아있음!
}
```

**Java의 해결책:**
1. 지역 변수를 `final`로 제한
2. 컴파일러가 변수 값을 **복사**하여 익명 클래스에 전달
3. 값이 변경되지 않으므로 원본과 복사본이 항상 일치

**우회 방법:**
```java
// 방법 1: 배열 사용
final int[] count = {0};
count[0]++;  // 배열 요소는 변경 가능

// 방법 2: Wrapper 클래스
class IntWrapper { int value; }
final IntWrapper wrapper = new IntWrapper();
wrapper.value++;  // 객체 필드는 변경 가능
```

---

### Q4. 내부 클래스는 외부 클래스의 어떤 멤버에 접근할 수 있나요?

**A:**

| 내부 클래스 종류 | 접근 가능 멤버 |
|--------------|-------------|
| Member Inner Class | 모든 멤버 (private 포함) |
| Static Nested Class | static 멤버만 |
| Local Inner Class | 외부 클래스 모든 멤버 + final/effectively final 지역 변수 |
| Anonymous Inner Class | 상황에 따라 다름 |

**예시:**
```java
class Outer {
    private int instanceField = 1;
    private static int staticField = 2;

    void method() {
        final int localVar = 3;

        // Local Inner Class
        class Local {
            void access() {
                System.out.println(instanceField);  // OK
                System.out.println(staticField);    // OK
                System.out.println(localVar);       // OK (final)
            }
        }
    }
}
```

---

### Q5. 내부 클래스의 메모리 누수 위험은?

**A:** Member Inner Class는 **외부 클래스 참조를 암묵적으로 유지**하므로 메모리 누수 위험이 있습니다.

**문제 상황:**
```java
class Activity {  // Android Activity (큰 객체)
    // ❌ 잘못된 코드
    class AsyncTask {  // Member Inner Class
        void doInBackground() {
            // 외부 Activity 참조를 암묵적으로 유지
            // Activity가 종료되어도 AsyncTask가 실행 중이면
            // Activity가 GC되지 않음 → 메모리 누수!
        }
    }
}
```

**해결 방법:**
```java
class Activity {
    // ✅ Static Nested Class 사용
    static class AsyncTask {  // 외부 참조 없음
        private WeakReference<Activity> activityRef;

        AsyncTask(Activity activity) {
            this.activityRef = new WeakReference<>(activity);
        }

        void doInBackground() {
            Activity activity = activityRef.get();
            if (activity != null) {
                // 안전하게 사용
            }
        }
    }
}
```

**원칙:**
- 외부 인스턴스가 필요 없으면 **항상 static으로 선언**
- 장기 실행 작업에는 Member Inner Class 사용 금지

---

### Q6. 내부 클래스에서 this 키워드는 어떻게 사용하나요?

**A:**

```java
class Outer {
    private String name = "Outer";

    class Inner {
        private String name = "Inner";

        void printNames() {
            System.out.println(this.name);         // "Inner" (내부 클래스)
            System.out.println(Inner.this.name);   // "Inner" (내부 클래스)
            System.out.println(Outer.this.name);   // "Outer" (외부 클래스)
        }
    }
}
```

**규칙:**
- `this`: 내부 클래스 자신
- `OuterClass.this`: 외부 클래스 인스턴스
- Static Nested Class에서는 `OuterClass.this` 사용 불가

---

### Q7. 내부 클래스를 상속할 수 있나요?

**A:** 가능하지만, **외부 클래스 인스턴스를 명시적으로 전달**해야 합니다.

```java
class Outer {
    class Inner {
        void display() {
            System.out.println("Inner");
        }
    }
}

// Member Inner Class 상속
class MyInner extends Outer.Inner {
    // ✅ 외부 인스턴스를 받는 생성자 필요
    MyInner(Outer outer) {
        outer.super();  // 외부 인스턴스로 super() 호출
    }

    @Override
    void display() {
        System.out.println("MyInner");
    }
}

// 사용
Outer outer = new Outer();
MyInner myInner = new MyInner(outer);
```

**Static Nested Class는 일반 클래스처럼 상속 가능:**
```java
static class StaticNested {}

class MyStatic extends Outer.StaticNested {}  // OK
```

---

## 🎤 면접 질문

### 주니어 레벨 (Junior Level)

#### Q1. 내부 클래스란 무엇이며, 왜 사용하나요?

**A:** 내부 클래스(Inner Class)는 **다른 클래스 안에 정의된 클래스**입니다.

**사용 이유:**
1. **논리적 그룹화**: 관련된 클래스를 한 곳에 모음
2. **캡슐화**: 외부에 불필요한 클래스 노출 방지
3. **외부 멤버 접근**: 외부 클래스의 private 멤버 접근 가능

**예시:**
```java
class ArrayList {
    private Object[] elements;

    // Iterator는 ArrayList 내부에서만 의미 있음
    private class Itr implements Iterator {
        public Object next() {
            return elements[...];  // 외부 private 멤버 접근
        }
    }
}
```

---

#### Q2. 내부 클래스의 종류를 설명하세요.

**A:**

1. **Member Inner Class** (멤버 내부 클래스)
   - 외부 클래스의 멤버로 정의
   - 외부 인스턴스 필요
   - 모든 멤버 접근 가능

2. **Static Nested Class** (정적 중첩 클래스)
   - static 키워드 사용
   - 외부 인스턴스 불필요
   - static 멤버만 접근

3. **Local Inner Class** (지역 내부 클래스)
   - 메서드 안에 정의
   - 메서드 내에서만 사용
   - final 지역 변수 접근 가능

4. **Anonymous Inner Class** (익명 내부 클래스)
   - 이름 없음
   - 선언과 동시에 인스턴스 생성
   - 일회성 사용

---

#### Q3. Member Inner Class와 Static Nested Class의 차이는?

**A:**

**Member Inner Class:**
- 외부 인스턴스 필요: `outer.new Inner()`
- 외부 모든 멤버 접근 가능
- 외부 참조 유지 → 메모리 사용량 증가

**Static Nested Class:**
- 외부 인스턴스 불필요: `new Outer.Inner()`
- 외부 static 멤버만 접근
- 외부 참조 없음 → 메모리 효율적

**선택 기준:**
- 외부 인스턴스 멤버 접근 필요 → Member Inner Class
- 논리적 그룹화만 필요 → Static Nested Class

---

#### Q4. 익명 클래스는 언제 사용하나요?

**A:** **일회성 구현이 필요할 때** 사용합니다.

**사용 사례:**
```java
// 1. 이벤트 핸들러
button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick() {
        System.out.println("클릭!");
    }
});

// 2. Comparator
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});

// 3. Runnable
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("실행!");
    }
}).start();
```

**Java 8 이후에는 Lambda로 대체 가능:**
```java
button.setOnClickListener(() -> System.out.println("클릭!"));
```

---

#### Q5. Local Inner Class의 특징은?

**A:**

**특징:**
- 메서드 안에 정의
- 메서드 내에서만 사용 가능
- 외부 클래스 멤버 + final 지역 변수 접근

**예시:**
```java
void method() {
    final int count = 10;

    class LocalInner {
        void print() {
            System.out.println(count);  // final 변수 접근 가능
        }
    }

    LocalInner local = new LocalInner();
    local.print();
}
```

**주의:**
- 지역 변수는 final 또는 effectively final이어야 함
- 메서드 밖에서는 사용 불가

---

#### Q6. 외부 클래스 참조는 어떻게 하나요?

**A:** `OuterClass.this`를 사용합니다.

```java
class Outer {
    private String name = "Outer";

    class Inner {
        private String name = "Inner";

        void printNames() {
            System.out.println(this.name);         // "Inner"
            System.out.println(Outer.this.name);   // "Outer"
        }
    }
}
```

---

#### Q7. 내부 클래스는 어떤 접근 제어자를 가질 수 있나요?

**A:**

**Member Inner Class:**
- public, protected, default, private 모두 가능

**Static Nested Class:**
- public, protected, default, private 모두 가능

**Local Inner Class:**
- 접근 제어자 사용 불가 (메서드 내부이므로)

**Anonymous Inner Class:**
- 접근 제어자 사용 불가 (이름이 없으므로)

```java
class Outer {
    private class PrivateInner {}      // OK
    public class PublicInner {}        // OK
    protected class ProtectedInner {}  // OK

    public static class PublicStatic {}  // OK
    private static class PrivateStatic {}  // OK

    void method() {
        // public class LocalInner {}  // 컴파일 에러!
        class LocalInner {}  // OK
    }
}
```

---

### 중급 레벨 (Intermediate Level)

#### Q8. 내부 클래스의 메모리 구조를 설명하세요.

**A:**

**Member Inner Class:**
```
Heap
├─ Outer Instance
│   └─ instanceField
└─ Inner Instance
    ├─ this$0 (외부 클래스 참조)  ← 암묵적으로 유지
    └─ innerField
```

컴파일러가 **자동으로 외부 클래스 참조(`this$0`)를 추가**합니다.

**Static Nested Class:**
```
Heap
├─ Outer Instance
│   └─ instanceField
└─ Nested Instance
    └─ nestedField (외부 참조 없음)
```

외부 클래스 참조가 **없으므로 메모리 효율적**입니다.

---

#### Q9. 내부 클래스로 인한 메모리 누수를 방지하는 방법은?

**A:**

**문제:**
```java
class Activity {
    // ❌ Member Inner Class → 외부 참조 유지
    class LongRunningTask extends AsyncTask {
        void doWork() {
            // Activity 종료 후에도 Task가 실행 중이면
            // Activity가 GC되지 않음 → 메모리 누수
        }
    }
}
```

**해결 방법:**

**1. Static Nested Class + WeakReference:**
```java
class Activity {
    static class LongRunningTask extends AsyncTask {
        private WeakReference<Activity> activityRef;

        LongRunningTask(Activity activity) {
            this.activityRef = new WeakReference<>(activity);
        }

        void doWork() {
            Activity activity = activityRef.get();
            if (activity != null && !activity.isFinishing()) {
                // 안전하게 사용
            }
        }
    }
}
```

**2. 외부 클래스로 분리:**
```java
// 완전히 독립적인 클래스
class LongRunningTask extends AsyncTask {
    // ...
}
```

---

#### Q10. 내부 클래스의 Synthetic Method란?

**A:** 컴파일러가 **자동으로 생성하는 메서드**입니다.

**발생 상황:**
```java
class Outer {
    private int value = 10;

    class Inner {
        void access() {
            System.out.println(value);  // private 멤버 접근
        }
    }
}
```

**컴파일러 생성 코드:**
```java
class Outer {
    private int value = 10;

    // 컴파일러가 자동 생성하는 Synthetic Method
    static int access$000(Outer outer) {
        return outer.value;
    }
}

class Outer$Inner {
    final Outer this$0;

    void access() {
        // private 멤버에 직접 접근 불가하므로 synthetic method 호출
        System.out.println(Outer.access$000(this$0));
    }
}
```

**문제점:**
- 리플렉션으로 호출 시 혼란 가능
- 약간의 성능 오버헤드

---

#### Q11. 내부 클래스와 Lambda의 차이는?

**A:**

| 구분 | Anonymous Inner Class | Lambda |
|-----|---------------------|--------|
| this | 익명 클래스 자신 | 외부 클래스 |
| 상태 | 필드 가질 수 있음 | 상태 없음 |
| 메서드 수 | 여러 개 구현 가능 | 1개만 (Functional Interface) |
| 직렬화 | 가능 | 권장 안 함 |
| 바이트코드 | 별도 .class 파일 | invokedynamic |

**예시:**
```java
// Anonymous Inner Class
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println(this);  // Runnable$1@...
    }
};

// Lambda
Runnable r2 = () -> {
    System.out.println(this);  // 외부 클래스 참조
};
```

---

#### Q12. Double Brace Initialization의 문제점은?

**A:** **익명 내부 클래스 + 인스턴스 초기화 블록**을 사용한 트릭입니다.

**코드:**
```java
// ❌ Double Brace Initialization
List<String> list = new ArrayList<String>() {{
    add("Item 1");
    add("Item 2");
    add("Item 3");
}};
```

**문제점:**
1. **익명 클래스 생성**: 불필요한 클래스 파일 생성
2. **외부 참조 유지**: 메모리 누수 위험
3. **직렬화 불가**: `Serializable` 문제
4. **가독성**: 일반 개발자에게 낯선 문법

**권장 방법:**
```java
// ✅ Java 9+ List.of()
List<String> list = List.of("Item 1", "Item 2", "Item 3");

// ✅ Arrays.asList()
List<String> list = new ArrayList<>(Arrays.asList("Item 1", "Item 2", "Item 3"));

// ✅ Stream
List<String> list = Stream.of("Item 1", "Item 2", "Item 3").collect(Collectors.toList());
```

---

## 🎓 전체 요약

### 4가지 내부 클래스

| 종류 | 외부 인스턴스 | 외부 멤버 접근 | 사용 사례 |
|-----|------------|-------------|---------|
| Member Inner | 필요 | 모든 멤버 | Iterator, Entry |
| Static Nested | 불필요 | static만 | Builder, Helper |
| Local Inner | 필요 | 모든 멤버 + final 지역변수 | 일회성 헬퍼 |
| Anonymous | 상황에 따라 | 상황에 따라 | Event Handler, Callback |

### 핵심 원칙
1. **외부 인스턴스가 필요 없으면 항상 static으로 선언**
2. **장기 실행 작업에는 Member Inner Class 사용 금지** (메모리 누수)
3. **지역 변수는 final 또는 effectively final**
4. **Java 8+ Lambda로 대체 가능한 경우 Lambda 사용**

---

**🎉 축하합니다! 내부 클래스 마스터를 완료했습니다!**

**다음 학습 주제:**
- Chapter 23: 예외 처리 (Exception Handling)
