# 29장 람다 표현식 - Part 3: 성능 최적화 & 고급 활용

## 📚 목차
1. [람다 성능 최적화](#성능-최적화)
2. [고급 활용 기법](#고급-활용-기법)
3. [실전 Best Practices](#실전-best-practices)
4. [자주 묻는 면접 질문 TOP 10](#면접-질문)
5. [종합 정리](#종합-정리)

---

## 🚀 성능 최적화

### 📊 람다 vs 익명 클래스 vs 메서드 참조 성능 비교

```java
package lambda.performance;

import java.util.*;
import java.util.function.Function;

/**
 * 람다 성능 비교
 */
public class LambdaPerformanceTest {
    private static final int ITERATIONS = 10_000_000;

    public static void main(String[] args) {
        System.out.println("=== 람다 vs 익명 클래스 vs 메서드 참조 성능 비교 ===\n");

        List<String> testData = Arrays.asList("a", "b", "c", "d", "e");

        // 1. 익명 클래스
        long start1 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = new Function<String, String>() {
                @Override
                public String apply(String s) {
                    return s.toUpperCase();
                }
            };
            function.apply("test");
        }
        long end1 = System.nanoTime();

        // 2. 람다
        long start2 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = s -> s.toUpperCase();
            function.apply("test");
        }
        long end2 = System.nanoTime();

        // 3. 메서드 참조
        long start3 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = String::toUpperCase;
            function.apply("test");
        }
        long end3 = System.nanoTime();

        // 4. 람다 재사용 (최적화)
        Function<String, String> reusableFunction = s -> s.toUpperCase();

        long start4 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            reusableFunction.apply("test");
        }
        long end4 = System.nanoTime();

        // 결과 출력
        System.out.println("1000만 번 실행 결과:");
        System.out.println("1. 익명 클래스: " + String.format("%.2f", (end1 - start1) / 1_000_000.0) + "ms");
        System.out.println("2. 람다: " + String.format("%.2f", (end2 - start2) / 1_000_000.0) + "ms");
        System.out.println("3. 메서드 참조: " + String.format("%.2f", (end3 - start3) / 1_000_000.0) + "ms");
        System.out.println("4. 람다 재사용: " + String.format("%.2f", (end4 - start4) / 1_000_000.0) + "ms");

        System.out.println("\n📊 결론:");
        System.out.println("- 람다 재사용이 가장 빠름");
        System.out.println("- 메서드 참조 ≈ 람다");
        System.out.println("- 익명 클래스가 가장 느림");
        System.out.println();

        // Stream 성능 비교
        System.out.println("=== Stream 처리 성능 ===\n");

        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 1_000_000; i++) {
            numbers.add(i);
        }

        // for문
        long startFor = System.nanoTime();
        int sumFor = 0;
        for (int n : numbers) {
            if (n % 2 == 0) {
                sumFor += n;
            }
        }
        long endFor = System.nanoTime();

        // Stream (람다)
        long startStream = System.nanoTime();
        int sumStream = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToInt(Integer::intValue)
            .sum();
        long endStream = System.nanoTime();

        // Parallel Stream
        long startParallel = System.nanoTime();
        int sumParallel = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .mapToInt(Integer::intValue)
            .sum();
        long endParallel = System.nanoTime();

        System.out.println("100만 개 짝수 합계:");
        System.out.println("for문: " + String.format("%.2f", (endFor - startFor) / 1_000_000.0) + "ms");
        System.out.println("Stream: " + String.format("%.2f", (endStream - startStream) / 1_000_000.0) + "ms");
        System.out.println("Parallel Stream: " + String.format("%.2f", (endParallel - startParallel) / 1_000_000.0) + "ms");

        System.out.println("\n📊 성능 팁:");
        System.out.println("✅ 람다는 매번 생성하지 말고 재사용");
        System.out.println("✅ 소량 데이터는 for문이 빠름");
        System.out.println("✅ 대량 데이터는 Parallel Stream 고려");
        System.out.println("✅ 메서드 참조 > 람다 > 익명 클래스");
    }
}
```

### 🎯 핵심 포인트

**1. 람다 재사용**:
```java
// ❌ 나쁜 예: 매번 람다 생성
for (int i = 0; i < 1000000; i++) {
    Function<String, String> f = s -> s.toUpperCase();  // 매번 생성!
    f.apply("test");
}

// ✅ 좋은 예: 한 번 생성하여 재사용
Function<String, String> f = s -> s.toUpperCase();  // 한 번만 생성
for (int i = 0; i < 1000000; i++) {
    f.apply("test");
}
```

**2. 메서드 참조 우선**:
```java
// 람다
list.stream().map(s -> s.toUpperCase())

// 메서드 참조 (더 빠르고 간결)
list.stream().map(String::toUpperCase)
```

---

### 📊 람다 메모리 사용

```java
package lambda.performance;

/**
 * 람다 메모리 분석
 */
public class LambdaMemoryTest {
    public static void main(String[] args) {
        System.out.println("=== 람다 메모리 사용 분석 ===\n");

        Runtime runtime = Runtime.getRuntime();

        // GC 실행
        System.gc();
        long beforeMemory = runtime.totalMemory() - runtime.freeMemory();

        // 1. 익명 클래스 100,000개 생성
        Runnable[] anonymousClasses = new Runnable[100000];
        for (int i = 0; i < 100000; i++) {
            final int index = i;
            anonymousClasses[i] = new Runnable() {
                @Override
                public void run() {
                    System.out.println("Run " + index);
                }
            };
        }

        System.gc();
        long afterAnonymous = runtime.totalMemory() - runtime.freeMemory();
        long anonymousMemory = afterAnonymous - beforeMemory;

        // 2. 람다 100,000개 생성
        Runnable[] lambdas = new Runnable[100000];
        for (int i = 0; i < 100000; i++) {
            final int index = i;
            lambdas[i] = () -> System.out.println("Run " + index);
        }

        System.gc();
        long afterLambda = runtime.totalMemory() - runtime.freeMemory();
        long lambdaMemory = afterLambda - afterAnonymous;

        System.out.println("메모리 사용량 (100,000개):");
        System.out.println("익명 클래스: " + String.format("%.2f", anonymousMemory / 1024.0 / 1024.0) + "MB");
        System.out.println("람다: " + String.format("%.2f", lambdaMemory / 1024.0 / 1024.0) + "MB");

        System.out.println("\n📊 람다가 메모리 효율적인 이유:");
        System.out.println("- invokedynamic 명령어 사용");
        System.out.println("- 컴파일 타임에 클래스 생성 안 함");
        System.out.println("- 런타임에 동적으로 연결");
    }
}
```

---

## 💎 고급 활용 기법

### 🔷 기법 1: 커링(Currying)과 부분 적용

```java
package lambda.advanced;

import java.util.function.Function;

/**
 * 커링 (Currying)
 */
public class CurryingDemo {
    public static void main(String[] args) {
        System.out.println("=== 커링 (Currying) ===\n");

        // 일반적인 방식: 모든 매개변수를 한 번에 전달
        int result1 = add(10, 20, 30);
        System.out.println("일반 방식: add(10, 20, 30) = " + result1);
        System.out.println();

        // 커링 방식: 매개변수를 하나씩 전달
        Function<Integer, Function<Integer, Function<Integer, Integer>>> curriedAdd =
            a -> b -> c -> a + b + c;

        // 단계적으로 적용
        Function<Integer, Function<Integer, Integer>> step1 = curriedAdd.apply(10);
        Function<Integer, Integer> step2 = step1.apply(20);
        int result2 = step2.apply(30);

        System.out.println("커링 방식:");
        System.out.println("step1 = curriedAdd.apply(10)");
        System.out.println("step2 = step1.apply(20)");
        System.out.println("result = step2.apply(30) = " + result2);
        System.out.println();

        // 부분 적용 (Partial Application)
        System.out.println("=== 부분 적용 ===\n");

        // 일부 매개변수만 고정
        Function<Integer, Function<Integer, Integer>> addTo10 = curriedAdd.apply(10);

        int result3 = addTo10.apply(5).apply(3);
        int result4 = addTo10.apply(2).apply(8);

        System.out.println("addTo10 = curriedAdd.apply(10)");
        System.out.println("addTo10.apply(5).apply(3) = " + result3);
        System.out.println("addTo10.apply(2).apply(8) = " + result4);
        System.out.println();

        // 실용 예시: 로거 설정
        System.out.println("=== 실용 예시: 로거 ===\n");

        // 로거 팩토리
        Function<String, Function<String, String>> loggerFactory =
            level -> message -> "[" + level + "] " + message;

        // 레벨별 로거 생성
        Function<String, String> infoLogger = loggerFactory.apply("INFO");
        Function<String, String> errorLogger = loggerFactory.apply("ERROR");

        System.out.println(infoLogger.apply("애플리케이션 시작"));
        System.out.println(infoLogger.apply("데이터 로드 완료"));
        System.out.println(errorLogger.apply("파일을 찾을 수 없음"));
        System.out.println();

        // 실용 예시: 할인 계산기
        System.out.println("=== 실용 예시: 할인 계산기 ===\n");

        // 할인율 → 원가 → 최종 가격
        Function<Double, Function<Integer, Integer>> discountCalculator =
            rate -> price -> (int) (price * (1 - rate));

        // 할인율별 계산기
        Function<Integer, Integer> discount10 = discountCalculator.apply(0.1);  // 10% 할인
        Function<Integer, Integer> discount20 = discountCalculator.apply(0.2);  // 20% 할인

        System.out.println("원가 10,000원:");
        System.out.println("  10% 할인: " + discount10.apply(10000) + "원");
        System.out.println("  20% 할인: " + discount20.apply(10000) + "원");
    }

    static int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

---

### 🔷 기법 2: 함수 합성 (Function Composition)

```java
package lambda.advanced;

import java.util.function.Function;

/**
 * 함수 합성
 */
public class FunctionCompositionDemo {
    public static void main(String[] args) {
        System.out.println("=== 함수 합성 (Function Composition) ===\n");

        // 기본 함수들
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, String> addExclamation = s -> s + "!!!";

        // andThen: f.andThen(g) = g(f(x))
        Function<String, String> process1 = trim
            .andThen(upperCase)
            .andThen(addExclamation);

        String result1 = process1.apply("  hello world  ");
        System.out.println("andThen 체인:");
        System.out.println("  입력: '  hello world  '");
        System.out.println("  출력: '" + result1 + "'");
        System.out.println("  → trim → upperCase → addExclamation");
        System.out.println();

        // compose: f.compose(g) = f(g(x))
        Function<String, String> process2 = addExclamation
            .compose(upperCase)
            .compose(trim);

        String result2 = process2.apply("  hello world  ");
        System.out.println("compose 체인:");
        System.out.println("  입력: '  hello world  '");
        System.out.println("  출력: '" + result2 + "'");
        System.out.println("  → trim → upperCase → addExclamation");
        System.out.println();

        // 실용 예시: 데이터 정제 파이프라인
        System.out.println("=== 실용 예시: 데이터 정제 파이프라인 ===\n");

        Function<String, String> removeSpecialChars = s -> s.replaceAll("[^a-zA-Z0-9\\s]", "");
        Function<String, String> normalizeSpaces = s -> s.replaceAll("\\s+", " ");
        Function<String, String> trimSpaces = String::trim;
        Function<String, String> toLowerCase = String::toLowerCase;

        Function<String, String> cleanupPipeline = trimSpaces
            .andThen(removeSpecialChars)
            .andThen(normalizeSpaces)
            .andThen(toLowerCase);

        String dirty = "  Hello!!!   @World###   123   ";
        String clean = cleanupPipeline.apply(dirty);

        System.out.println("원본: '" + dirty + "'");
        System.out.println("정제: '" + clean + "'");
        System.out.println();

        // 실용 예시: 가격 계산 파이프라인
        System.out.println("=== 실용 예시: 가격 계산 파이프라인 ===\n");

        Function<Integer, Integer> applyDiscount = price -> (int) (price * 0.9);  // 10% 할인
        Function<Integer, Integer> applyTax = price -> (int) (price * 1.1);       // 10% 세금
        Function<Integer, Integer> applyShipping = price -> price + 3000;         // 배송비

        Function<Integer, Integer> finalPrice = applyDiscount
            .andThen(applyTax)
            .andThen(applyShipping);

        int originalPrice = 10000;
        int calculated = finalPrice.apply(originalPrice);

        System.out.println("원가: " + originalPrice + "원");
        System.out.println("최종 가격: " + calculated + "원");
        System.out.println("→ 할인 10% → 세금 10% → 배송비 3,000원");
    }
}
```

---

### 🔷 기법 3: 메모이제이션 (Memoization)

```java
package lambda.advanced;

import java.util.*;
import java.util.function.Function;

/**
 * 메모이제이션 (Memoization)
 * 함수 호출 결과를 캐싱하여 성능 향상
 */
public class MemoizationDemo {
    public static void main(String[] args) {
        System.out.println("=== 메모이제이션 (Memoization) ===\n");

        // 시나리오 1: 피보나치 수열 (메모이제이션 없음)
        System.out.println("📍 메모이제이션 없음 (피보나치):");

        long start1 = System.nanoTime();
        int fib40 = fibonacci(40);
        long end1 = System.nanoTime();

        System.out.println("fibonacci(40) = " + fib40);
        System.out.println("소요 시간: " + String.format("%.2f", (end1 - start1) / 1_000_000.0) + "ms");
        System.out.println("→ 중복 계산 많음 (매우 느림)");
        System.out.println();

        // 시나리오 2: 피보나치 수열 (메모이제이션 적용)
        System.out.println("📍 메모이제이션 적용:");

        Function<Integer, Integer> memoizedFib = memoize(MemoizationDemo::fibonacci);

        long start2 = System.nanoTime();
        int memoFib40 = memoizedFib.apply(40);
        long end2 = System.nanoTime();

        System.out.println("memoizedFib(40) = " + memoFib40);
        System.out.println("소요 시간: " + String.format("%.2f", (end2 - start2) / 1_000_000.0) + "ms");
        System.out.println("→ 중복 계산 제거 (매우 빠름)");
        System.out.println();

        // 재호출 시 캐시 사용
        long start3 = System.nanoTime();
        memoizedFib.apply(40);  // 캐시된 결과 사용
        long end3 = System.nanoTime();

        System.out.println("재호출 시간: " + String.format("%.3f", (end3 - start3) / 1000.0) + "μs");
        System.out.println("→ 캐시에서 즉시 반환");
        System.out.println();

        // 실용 예시: DB 조회 캐싱
        System.out.println("=== 실용 예시: DB 조회 캐싱 ===\n");

        Function<String, User> findUser = userId -> {
            System.out.println("  [DB 조회] userId: " + userId);
            // 시뮬레이션: DB 조회는 느림
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return new User(userId, "User " + userId);
        };

        Function<String, User> cachedFindUser = memoize(findUser);

        System.out.println("첫 번째 조회:");
        long startDb1 = System.currentTimeMillis();
        User user1 = cachedFindUser.apply("USER001");
        long endDb1 = System.currentTimeMillis();
        System.out.println("  결과: " + user1);
        System.out.println("  소요 시간: " + (endDb1 - startDb1) + "ms");
        System.out.println();

        System.out.println("두 번째 조회 (같은 사용자):");
        long startDb2 = System.currentTimeMillis();
        User user2 = cachedFindUser.apply("USER001");
        long endDb2 = System.currentTimeMillis();
        System.out.println("  결과: " + user2);
        System.out.println("  소요 시간: " + (endDb2 - startDb2) + "ms");
        System.out.println("  → 캐시 사용, DB 조회 안 함");
    }

    /**
     * 피보나치 수열 (재귀)
     */
    static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    /**
     * 메모이제이션 래퍼
     */
    static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new HashMap<>();

        return input -> cache.computeIfAbsent(input, function);
    }

    /**
     * 사용자 클래스
     */
    static class User {
        String id;
        String name;

        User(String id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "User{id='" + id + "', name='" + name + "'}";
        }
    }
}
```

---

## 🎯 실전 Best Practices

### ✅ 1. 람다 가독성 향상

```java
package lambda.bestpractices;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * 람다 가독성 향상 기법
 */
public class ReadabilityDemo {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("노트북", 1500000, true),
            new Product("마우스", 30000, false),
            new Product("키보드", 80000, true),
            new Product("모니터", 500000, false)
        );

        System.out.println("=== 람다 가독성 향상 ===\n");

        // ❌ 나쁜 예: 복잡한 람다를 인라인으로
        List<Product> result1 = products.stream()
            .filter(p -> p.getPrice() > 50000 && p.isAvailable() && p.getName().length() > 3)
            .collect(Collectors.toList());

        // ✅ 좋은 예 1: Predicate로 추출
        Predicate<Product> isExpensive = p -> p.getPrice() > 50000;
        Predicate<Product> isAvailable = Product::isAvailable;
        Predicate<Product> hasLongName = p -> p.getName().length() > 3;

        List<Product> result2 = products.stream()
            .filter(isExpensive.and(isAvailable).and(hasLongName))
            .collect(Collectors.toList());

        System.out.println("Predicate 추출:");
        result2.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // ✅ 좋은 예 2: 명명된 메서드로 추출
        List<Product> result3 = products.stream()
            .filter(ReadabilityDemo::isPremiumProduct)
            .collect(Collectors.toList());

        System.out.println("메서드 추출:");
        result3.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // ✅ 좋은 예 3: 복잡한 로직은 별도 메서드로
        List<Product> result4 = products.stream()
            .map(ReadabilityDemo::applyDiscount)
            .collect(Collectors.toList());

        System.out.println("복잡한 변환 로직 추출:");
        result4.forEach(p -> System.out.println("  " + p));
    }

    /**
     * 프리미엄 상품 판별
     */
    static boolean isPremiumProduct(Product product) {
        return product.getPrice() > 50000
            && product.isAvailable()
            && product.getName().length() > 3;
    }

    /**
     * 할인 적용
     */
    static Product applyDiscount(Product product) {
        if (product.getPrice() > 100000) {
            return new Product(
                product.getName(),
                (int) (product.getPrice() * 0.9),  // 10% 할인
                product.isAvailable()
            );
        }
        return product;
    }

    static class Product {
        String name;
        int price;
        boolean available;

        Product(String name, int price, boolean available) {
            this.name = name;
            this.price = price;
            this.available = available;
        }

        String getName() { return name; }
        int getPrice() { return price; }
        boolean isAvailable() { return available; }

        @Override
        public String toString() {
            return name + " - " + String.format("%,d", price) + "원";
        }
    }
}
```

---

### ✅ 2. 람다 디버깅

```java
package lambda.bestpractices;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 람다 디버깅 기법
 */
public class DebuggingDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        System.out.println("=== 람다 디버깅 ===\n");

        // ❌ 디버깅 어려움
        List<Integer> result1 = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());

        // ✅ peek()으로 중간 값 확인
        System.out.println("peek()으로 디버깅:");
        List<Integer> result2 = numbers.stream()
            .peek(n -> System.out.println("  원본: " + n))
            .filter(n -> n % 2 == 0)
            .peek(n -> System.out.println("  필터 후: " + n))
            .map(n -> n * 2)
            .peek(n -> System.out.println("  변환 후: " + n))
            .collect(Collectors.toList());

        System.out.println("최종 결과: " + result2);
        System.out.println();

        // ✅ 로그 래퍼 사용
        System.out.println("로그 래퍼 사용:");
        List<Integer> result3 = numbers.stream()
            .filter(logFilter(n -> n % 2 == 0, "짝수 필터"))
            .map(logMap(n -> n * 2, "2배 변환"))
            .collect(Collectors.toList());

        System.out.println("최종 결과: " + result3);
    }

    /**
     * 필터 로깅 래퍼
     */
    static <T> java.util.function.Predicate<T> logFilter(
        java.util.function.Predicate<T> predicate,
        String description
    ) {
        return value -> {
            boolean result = predicate.test(value);
            System.out.println("  [" + description + "] " + value + " → " + result);
            return result;
        };
    }

    /**
     * 변환 로깅 래퍼
     */
    static <T, R> java.util.function.Function<T, R> logMap(
        java.util.function.Function<T, R> function,
        String description
    ) {
        return value -> {
            R result = function.apply(value);
            System.out.println("  [" + description + "] " + value + " → " + result);
            return result;
        };
    }
}
```

---

## 🎤 면접 질문

### ❓ Q1. 람다 표현식이란 무엇인가?

**답변**:
```
람다 표현식은 메서드를 하나의 식으로 표현한 익명 함수입니다.

특징:
1. 간결한 문법: (매개변수) -> { 실행문 }
2. 함수형 인터페이스에서만 사용 가능
3. 컴파일러가 타입 추론

예시:
// 익명 클래스
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello");
    }
};

// 람다
Runnable r2 = () -> System.out.println("Hello");

장점:
- 코드 간결성
- 가독성 향상
- 함수형 프로그래밍 지원
```

---

### ❓ Q2. 함수형 인터페이스란?

**답변**:
```
추상 메서드가 정확히 1개인 인터페이스입니다.

조건:
- 추상 메서드 1개 (필수)
- default 메서드 여러 개 가능
- static 메서드 여러 개 가능

@FunctionalInterface 애노테이션:
- 컴파일러가 함수형 인터페이스 검증
- 추상 메서드가 2개 이상이면 컴파일 에러

예시:
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // 추상 메서드 1개

    default void print() { }      // default 메서드 OK
    static void log() { }         // static 메서드 OK
}

주요 함수형 인터페이스 (java.util.function):
- Predicate<T>: T → boolean
- Function<T, R>: T → R
- Consumer<T>: T → void
- Supplier<T>: () → T
```

---

### ❓ Q3. 람다에서 외부 변수를 수정할 수 없는 이유는?

**답변**:
```
람다는 외부 변수를 캡처할 때 값을 복사하기 때문입니다.

effectively final 규칙:
- 람다에서 접근하는 외부 변수는 final이거나 사실상 final이어야 함
- 값이 변경되면 컴파일 에러

이유:
1. 멀티스레드 안전성
   - 람다가 다른 스레드에서 실행될 수 있음
   - 변수 변경 시 동기화 문제 발생

2. 시간적 분리
   - 람다는 나중에 실행될 수 있음
   - 변수가 이미 사라졌을 수 있음

3. 값 캡처
   - 람다는 변수의 복사본을 가짐
   - 원본 변경이 람다에 반영 안 됨

해결책:
- AtomicInteger 사용
- 배열 사용 (트릭)
- Stream의 reduce 사용 (권장)
```

---

### ❓ Q4. 메서드 참조의 종류는?

**답변**:
```
메서드 참조는 람다를 더 간결하게 표현하는 방법입니다.

4가지 종류:

1. 정적 메서드 참조
   ClassName::staticMethod
   예: Math::abs
   람다: x -> Math.abs(x)

2. 인스턴스 메서드 참조 (특정 객체)
   instance::instanceMethod
   예: str::length
   람다: () -> str.length()

3. 인스턴스 메서드 참조 (임의 객체)
   ClassName::instanceMethod
   예: String::toUpperCase
   람다: s -> s.toUpperCase()

4. 생성자 참조
   ClassName::new
   예: ArrayList::new
   람다: () -> new ArrayList<>()

메서드 참조 vs 람다:
- 메서드 참조가 더 간결하고 명확
- 단순 메서드 호출은 메서드 참조 사용 권장
```

---

### ❓ Q5. 람다와 익명 클래스의 차이는?

**답변**:
```
1. this 참조:
   익명 클래스: this는 익명 클래스 자체
   람다: this는 외부 클래스

2. 사용 가능 범위:
   익명 클래스: 모든 인터페이스/추상 클래스
   람다: 함수형 인터페이스만

3. 인스턴스 변수:
   익명 클래스: 인스턴스 변수 선언 가능
   람다: 불가

4. 컴파일:
   익명 클래스: .class 파일 생성 (OuterClass$1.class)
   람다: invokedynamic 사용, 별도 클래스 생성 안 함

5. 성능:
   람다가 익명 클래스보다 약간 빠름

6. 메모리:
   람다가 더 효율적

언제 사용?
- 함수형 인터페이스: 람다 (권장)
- 복잡한 로직, 여러 메서드: 익명 클래스
- 인스턴스 변수 필요: 익명 클래스
```

---

### ❓ Q6. Predicate, Function, Consumer의 차이는?

**답변**:
```
표준 함수형 인터페이스의 대표적인 3가지:

1. Predicate<T>
   - 시그니처: T → boolean
   - 메서드: boolean test(T t)
   - 용도: 조건 검사
   - 예시: x -> x > 10

2. Function<T, R>
   - 시그니처: T → R
   - 메서드: R apply(T t)
   - 용도: 변환
   - 예시: s -> s.length()

3. Consumer<T>
   - 시그니처: T → void
   - 메서드: void accept(T t)
   - 용도: 소비 (출력, 저장 등)
   - 예시: s -> System.out.println(s)

4. Supplier<T>
   - 시그니처: () → T
   - 메서드: T get()
   - 용도: 공급 (생성)
   - 예시: () -> new ArrayList<>()

활용:
list.stream()
    .filter(predicate)      // Predicate
    .map(function)          // Function
    .forEach(consumer);     // Consumer
```

---

### ❓ Q7. 람다에서 체크 예외를 어떻게 처리하나?

**답변**:
```
함수형 인터페이스는 체크 예외를 던지지 않으므로 별도 처리 필요

방법 1: try-catch로 감싸기
list.forEach(item -> {
    try {
        riskyOperation(item);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
});

방법 2: 래퍼 메서드 사용 (권장)
public static <T> Consumer<T> wrap(ThrowingConsumer<T> consumer) {
    return t -> {
        try {
            consumer.accept(t);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    };
}

@FunctionalInterface
interface ThrowingConsumer<T> {
    void accept(T t) throws Exception;
}

// 사용
list.forEach(wrap(item -> riskyOperation(item)));

방법 3: 커스텀 함수형 인터페이스
@FunctionalInterface
interface CheckedFunction<T, R> {
    R apply(T t) throws Exception;
}
```

---

### ❓ Q8. 람다 캡처링(Capturing)이란?

**답변**:
```
람다가 외부 변수를 사용하는 것을 캡처링이라고 합니다.

캡처 방식:
- 값 캡처: 외부 변수의 값을 복사
- 참조 캡처 없음 (C++와 다름)

제약 사항:
1. effectively final만 캡처 가능
2. 지역 변수만 캡처 (인스턴스 변수는 제외)

예시:
int x = 10;  // effectively final

Runnable r = () -> System.out.println(x);  // 캡처 OK

// x = 20;  // 컴파일 에러! effectively final 위반

이유:
- 람다가 다른 스레드에서 실행될 수 있음
- 변수가 스택에서 사라질 수 있음
- 값을 복사하여 힙에 저장

인스턴스 변수는?
- 캡처 제약 없음
- this를 통해 접근
- 객체가 살아있는 동안 유효
```

---

### ❓ Q9. 람다와 Stream API의 관계는?

**답변**:
```
Stream API는 람다를 적극 활용하는 대표적인 API입니다.

관계:
- Stream의 대부분 메서드가 함수형 인터페이스를 매개변수로 받음
- 람다 없이는 Stream API 사용이 불편함

주요 메서드와 람다:
1. filter(Predicate<T>)
   stream.filter(x -> x > 10)

2. map(Function<T, R>)
   stream.map(s -> s.toUpperCase())

3. forEach(Consumer<T>)
   stream.forEach(x -> System.out.println(x))

4. reduce(BinaryOperator<T>)
   stream.reduce((a, b) -> a + b)

5. sorted(Comparator<T>)
   stream.sorted((a, b) -> a.compareTo(b))

람다 없이 Stream 사용:
// 익명 클래스 (매우 장황)
stream.filter(new Predicate<Integer>() {
    public boolean test(Integer x) {
        return x > 10;
    }
});

람다가 Stream API를 간결하게 만듦
```

---

### ❓ Q10. 람다 성능 최적화 방법은?

**답변**:
```
1. 람다 재사용
   ❌ for (int i = 0; i < 1000; i++) {
       Function<String, String> f = s -> s.toUpperCase();
   }

   ✅ Function<String, String> f = s -> s.toUpperCase();
      for (int i = 0; i < 1000; i++) {
          f.apply(...);
      }

2. 메서드 참조 사용
   ❌ map(s -> s.toUpperCase())
   ✅ map(String::toUpperCase)

3. Primitive 특화 인터페이스 사용
   ❌ Function<Integer, Integer>  // 박싱/언박싱 발생
   ✅ IntUnaryOperator  // primitive 연산

4. Parallel Stream 고려 (대량 데이터)
   stream.parallelStream()
       .filter(...)
       .map(...)

5. 불필요한 객체 생성 피하기
   ❌ filter(x -> x.toString().equals("value"))
   ✅ filter(x -> "value".equals(x.toString()))

6. 중간 연산 최소화
   ❌ stream.filter(...).filter(...).filter(...)
   ✅ stream.filter(x -> 조건1 && 조건2 && 조건3)

성능 측정:
- 소량 데이터: for문이 빠를 수 있음
- 대량 데이터: Stream이 유리
- 항상 프로파일링 후 결정
```

---

## 🎓 종합 정리

### 📊 람다 체크리스트

```
✅ 간결성
   - 단순 메서드 호출은 메서드 참조 사용
   - 복잡한 로직은 별도 메서드로 추출

✅ 가독성
   - Predicate, Function 등을 변수로 추출
   - 의미 있는 이름 사용

✅ 성능
   - 람다 재사용
   - Primitive 특화 인터페이스 사용
   - 불필요한 객체 생성 피하기

✅ 예외 처리
   - 래퍼 메서드 사용
   - try-catch로 감싸기

✅ 디버깅
   - peek() 활용
   - 로그 래퍼 사용
```

---

### 💡 람다 사용 시나리오

```java
// 1. 컬렉션 정렬
list.sort((a, b) -> a.compareTo(b));
list.sort(Comparator.naturalOrder());

// 2. 필터링
list.stream()
    .filter(x -> x > 10)
    .collect(Collectors.toList());

// 3. 변환
list.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

// 4. 이벤트 핸들러
button.setOnAction(event -> handleClick());

// 5. 비동기 작업
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> process(data))
    .thenAccept(result -> display(result));

// 6. 조건 조합
Predicate<Product> filter =
    isExpensive.and(isAvailable).or(isOnSale);
```

---

## 🚀 다음 단계 학습

```
1. Stream API 심화
   - 중간 연산 vs 최종 연산
   - Parallel Stream
   - Collector 커스터마이징

2. Optional 활용
   - null 안전성
   - 함수형 프로그래밍

3. CompletableFuture
   - 비동기 프로그래밍
   - 콜백 체이닝

4. 함수형 프로그래밍
   - 불변성
   - 순수 함수
   - 고차 함수
```

---

## 🎉 시리즈 완료!

**Part 1**: 5가지 실생활 비유로 람다 이해
**Part 2**: 3개 기업 사례 + 4개 주니어 실수
**Part 3**: 성능 최적화 + 고급 기법 + 면접 질문

람다 표현식을 완벽하게 마스터했습니다! 🎊
