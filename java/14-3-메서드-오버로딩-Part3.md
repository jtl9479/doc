# Chapter 14-3: 메서드 오버로딩 (Method Overloading) - Part 3

## 목차
1. [실전 프로젝트](#실전-프로젝트)
2. [자주 묻는 질문 (FAQ)](#자주-묻는-질문-faq)
3. [면접 질문](#면접-질문)

---

## 실전 프로젝트

### 프로젝트: 그래픽 편집 도구 (Graphics Editor)

다양한 도형을 그리고 편집하는 그래픽 편집기를 메서드 오버로딩으로 구현합니다.

```java
// Shape.java
public class Shape {
    int x, y;
    String color;

    public Shape(int x, int y, String color) {
        this.x = x;
        this.y = y;
        this.color = color;
    }
}

// GraphicsEditor.java
public class GraphicsEditor {
    // 1. 원 그리기 - 중심점과 반지름
    public void draw(int x, int y, int radius) {
        System.out.println("원 그리기: 중심(" + x + "," + y + "), 반지름=" + radius);
    }

    // 2. 사각형 그리기 - 좌표와 너비, 높이
    public void draw(int x, int y, int width, int height) {
        System.out.println("사각형 그리기: 좌표(" + x + "," + y + "), 크기=" + width + "x" + height);
    }

    // 3. 선 그리기 - 시작점과 끝점
    public void draw(int x1, int y1, int x2, int y2, boolean isLine) {
        if (isLine) {
            System.out.println("선 그리기: (" + x1 + "," + y1 + ") → (" + x2 + "," + y2 + ")");
        }
    }

    // 4. 색상 지정 원 그리기
    public void draw(int x, int y, int radius, String color) {
        System.out.println(color + " 원 그리기: 중심(" + x + "," + y + "), 반지름=" + radius);
    }

    // 5. 색상 지정 사각형 그리기
    public void draw(int x, int y, int width, int height, String color) {
        System.out.println(color + " 사각형: 좌표(" + x + "," + y + "), 크기=" + width + "x" + height);
    }

    // 6. 도형 객체로 그리기
    public void draw(Shape shape) {
        System.out.println("도형 객체 그리기: 위치(" + shape.x + "," + shape.y + "), 색상=" + shape.color);
    }

    // 7. 여러 도형 동시 그리기
    public void draw(Shape[] shapes) {
        System.out.println("=== 다중 도형 그리기 (" + shapes.length + "개) ===");
        for (int i = 0; i < shapes.length; i++) {
            System.out.println((i+1) + ". 위치(" + shapes[i].x + "," + shapes[i].y + ")");
        }
    }

    // 8. 텍스트 그리기
    public void draw(String text, int x, int y) {
        System.out.println("텍스트 \"" + text + "\" 그리기: 위치(" + x + "," + y + ")");
    }

    // 9. 텍스트 그리기 (폰트 크기 포함)
    public void draw(String text, int x, int y, int fontSize) {
        System.out.println("텍스트 \"" + text + "\" 그리기: 위치(" + x + "," + y + "), 크기=" + fontSize);
    }

    // 10. 이미지 그리기
    public void draw(String imagePath, int x, int y, int width, int height) {
        System.out.println("이미지 \"" + imagePath + "\" 그리기: 위치(" + x + "," + y + "), 크기=" + width + "x" + height);
    }
}

// Main
public class GraphicsEditorTest {
    public static void main(String[] args) {
        GraphicsEditor editor = new GraphicsEditor();

        System.out.println("╔════════════════════════════════╗");
        System.out.println("║   그래픽 편집기 시스템         ║");
        System.out.println("╚════════════════════════════════╝\n");

        // 다양한 그리기 명령
        editor.draw(100, 100, 50);                          // 원
        editor.draw(200, 200, 100, 80);                     // 사각형
        editor.draw(0, 0, 300, 300, true);                  // 선
        editor.draw(150, 150, 30, "빨강");                  // 색상 원
        editor.draw(50, 50, 200, 150, "파랑");              // 색상 사각형
        editor.draw("Hello", 10, 10);                       // 텍스트
        editor.draw("Title", 50, 50, 24);                   // 텍스트 (크기)
        editor.draw("photo.jpg", 100, 100, 200, 150);       // 이미지

        Shape s1 = new Shape(10, 10, "녹색");
        editor.draw(s1);                                    // 도형 객체

        Shape[] shapes = {
            new Shape(10, 10, "빨강"),
            new Shape(50, 50, "파랑"),
            new Shape(100, 100, "초록")
        };
        editor.draw(shapes);                                // 다중 도형
    }
}
```

---

## 자주 묻는 질문 (FAQ)

### FAQ 1: 메서드 오버로딩은 언제 사용하나요?

**답변:**

**사용하는 경우:**
1. **같은 기능을 다양한 입력으로 처리할 때**
2. **선택적 매개변수를 제공할 때**
3. **타입별로 최적화된 처리가 필요할 때**

```java
// 좋은 예: println 오버로딩
System.out.println(10);           // int
System.out.println(10.5);         // double
System.out.println("text");       // String
System.out.println(true);         // boolean

// 좋은 예: String의 valueOf
String.valueOf(123);              // int → String
String.valueOf(12.34);            // double → String
String.valueOf(true);             // boolean → String
```

**사용하지 않는 경우:**
- 기능이 완전히 다른 경우 → 다른 메서드 이름 사용
- 매개변수가 너무 많은 경우 → 빌더 패턴 고려

---

### FAQ 2: 메서드 오버로딩과 오버라이딩의 차이는?

**답변:**

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
|------|----------------------|------------------------|
| 정의 | 같은 이름, 다른 매개변수 | 부모 메서드 재정의 |
| 위치 | 같은 클래스 | 상속 관계 |
| 매개변수 | 달라야 함 | 같아야 함 |
| 반환 타입 | 무관 | 같거나 하위 타입 |
| 시점 | 컴파일 타임 | 런타임 |

```java
// 오버로딩
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}

// 오버라이딩
class Animal {
    void sound() { System.out.println("동물 소리"); }
}
class Dog extends Animal {
    @Override
    void sound() { System.out.println("멍멍"); }
}
```

---

### FAQ 3: 가변 인자를 사용할 때 주의할 점은?

**답변:**

**규칙:**
1. 가변 인자는 **마지막 매개변수**로만 가능
2. 가변 인자는 **하나만** 사용 가능
3. 일반 메서드가 가변 인자보다 **우선순위** 높음

```java
// ✅ 올바른 사용
public void method(String name, int... numbers) { }

// ❌ 잘못된 사용
public void method(int... numbers, String name) { }  // 마지막이 아님
public void method(int... nums, String... strs) { }  // 2개 사용
```

**우선순위:**
```java
public class Test {
    void print(int a, int b) {
        System.out.println("일반");
    }

    void print(int... numbers) {
        System.out.println("가변인자");
    }
}

Test t = new Test();
t.print(1, 2);      // "일반" 출력 (일반 메서드 우선)
t.print(1, 2, 3);   // "가변인자" 출력
```

---

### FAQ 4: 자동 형변환이 오버로딩에 어떤 영향을 주나요?

**답변:**

**형변환 순서:**
```
byte/short/char → int → long → float → double
```

```java
public class TypeTest {
    void method(int value) {
        System.out.println("int");
    }

    void method(double value) {
        System.out.println("double");
    }
}

TypeTest t = new TypeTest();

byte b = 10;
t.method(b);      // "int" (byte → int)

short s = 10;
t.method(s);      // "int" (short → int)

long l = 10L;
t.method(l);      // "double" (long → double, int는 불가)

float f = 10.0f;
t.method(f);      // "double" (float → double)
```

**정확한 매칭을 원하면:**
```java
public class Precise {
    void method(byte value) { System.out.println("byte"); }
    void method(short value) { System.out.println("short"); }
    void method(int value) { System.out.println("int"); }
    void method(long value) { System.out.println("long"); }
    void method(float value) { System.out.println("float"); }
    void method(double value) { System.out.println("double"); }
}
```

---

### FAQ 5: 오버로딩된 메서드 중 어떤 것이 호출되는지 어떻게 알 수 있나요?

**답변:**

**컴파일러의 메서드 선택 규칙:**

1. **정확히 일치하는 메서드** 찾기
2. 없으면 **자동 형변환 가능한 메서드** 찾기
3. 여러 개면 **가장 작은 형변환** 선택
4. 그래도 없으면 **가변 인자** 메서드

```java
public class Selection {
    void m(int a) { System.out.println("int"); }
    void m(long a) { System.out.println("long"); }
    void m(Integer a) { System.out.println("Integer"); }
    void m(int... a) { System.out.println("varargs"); }
}

Selection s = new Selection();
s.m(10);           // int (정확히 일치)
s.m(10L);          // long (정확히 일치)
s.m((byte)10);     // int (byte → int)
s.m(Integer.valueOf(10));  // Integer (정확히 일치)
s.m(1, 2, 3);      // varargs (다른 매칭 없음)
```

---

### FAQ 6: 오버로딩으로 null을 전달하면?

**답변:**

**null은 어떤 참조 타입이든 가능** → 애매모호함 발생 가능

```java
public class NullTest {
    void method(String s) {
        System.out.println("String");
    }

    void method(Integer i) {
        System.out.println("Integer");
    }

    void method(Object o) {
        System.out.println("Object");
    }
}

NullTest t = new NullTest();
t.method(null);  // ❌ 컴파일 에러: 애매모호함
```

**해결 방법:**
```java
// 명시적 캐스팅
t.method((String)null);   // "String"
t.method((Integer)null);  // "Integer"
t.method((Object)null);   // "Object"
```

**더 나은 설계:**
```java
public class Better {
    void method(String s) {
        if (s == null) {
            System.out.println("null String");
            return;
        }
        System.out.println("String: " + s);
    }
}
```

---

### FAQ 7: 오버로딩이 너무 많으면 문제가 되나요?

**답변:**

**문제점:**
1. 코드 복잡도 증가
2. 유지보수 어려움
3. 잘못된 메서드 호출 가능성

**대안:**

**1. 빌더 패턴**
```java
// ❌ 오버로딩 많음
public User(String name) { }
public User(String name, int age) { }
public User(String name, int age, String email) { }
public User(String name, int age, String email, String phone) { }

// ✅ 빌더 패턴
public class User {
    private String name;
    private int age;
    private String email;
    private String phone;

    public static class Builder {
        private String name;
        private int age;
        private String email;
        private String phone;

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}

// 사용
User user = new User.Builder()
    .name("김철수")
    .age(25)
    .build();
```

**2. 매개변수 객체**
```java
class SearchOptions {
    String keyword;
    String category;
    String sortBy;
    int maxResults;
}

public void search(SearchOptions options) {
    // 단일 메서드로 처리
}
```

---

## 면접 질문

### 주니어 레벨 (1-7)

#### Q1. 메서드 오버로딩이란 무엇인가요?

**답변:**

메서드 오버로딩은 **같은 이름의 메서드를 매개변수의 타입, 개수, 순서를 다르게 하여 여러 개 정의하는 것**입니다.

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

**장점:**
- 같은 기능을 하나의 이름으로 통일
- 사용자 편의성 증대
- 코드 가독성 향상

---

#### Q2. 오버로딩과 오버라이딩의 차이는?

**답변:**

| 항목 | 오버로딩 | 오버라이딩 |
|------|---------|-----------|
| 정의 | 같은 이름, 다른 매개변수 | 부모 메서드 재정의 |
| 위치 | 같은 클래스 | 상속 관계 |
| 매개변수 | 달라야 함 | 같아야 함 |
| 시점 | 컴파일 타임 | 런타임 |

```java
// 오버로딩
class Math {
    int max(int a, int b) { return a > b ? a : b; }
    double max(double a, double b) { return a > b ? a : b; }
}

// 오버라이딩
class Animal {
    void sound() { System.out.println("동물"); }
}
class Dog extends Animal {
    @Override
    void sound() { System.out.println("멍멍"); }
}
```

---

#### Q3. 오버로딩 시 매개변수 이름만 다르게 하면 되나요?

**답변:**

**아니요. 매개변수 이름은 오버로딩 구분 기준이 아닙니다.**

```java
// ❌ 컴파일 에러
public void method(String name) { }
public void method(String email) { }  // 같은 (String)

// ✅ 정상
public void method(String name) { }
public void method(String name, int age) { }  // (String, int)
```

**오버로딩 구분 기준:**
- ✅ 매개변수 개수
- ✅ 매개변수 타입
- ✅ 매개변수 순서
- ❌ 매개변수 이름
- ❌ 반환 타입

---

#### Q4. 반환 타입만 다르게 해서 오버로딩할 수 있나요?

**답변:**

**불가능합니다.** 반환 타입은 오버로딩 구분 기준이 아닙니다.

```java
// ❌ 컴파일 에러
public int getValue() { return 0; }
public String getValue() { return "0"; }
```

**이유:**
```java
// 메서드 호출 시 어떤 것을 선택해야 할지 모호함
getValue();  // int? String?
```

**해결책:**
```java
public int getValueAsInt() { return 0; }
public String getValueAsString() { return "0"; }
```

---

#### Q5. 가변 인자(varargs)란 무엇이고 어떻게 사용하나요?

**답변:**

가변 인자는 **개수가 정해지지 않은 매개변수를 받을 수 있는 기능**입니다.

```java
public int sum(int... numbers) {
    int total = 0;
    for (int num : numbers) {
        total += num;
    }
    return total;
}

// 사용
sum(1, 2);
sum(1, 2, 3);
sum(1, 2, 3, 4, 5);
```

**규칙:**
- 마지막 매개변수로만 사용 가능
- 하나만 사용 가능

```java
// ✅ 올바른 사용
public void method(String name, int... scores) { }

// ❌ 잘못된 사용
public void method(int... scores, String name) { }  // 마지막 아님
public void method(int... a, int... b) { }  // 2개 사용
```

---

#### Q6. 오버로딩 시 자동 형변환은 어떻게 작동하나요?

**답변:**

**형변환 우선순위:**
```
byte/short/char → int → long → float → double
```

```java
public class Test {
    void method(int value) {
        System.out.println("int");
    }

    void method(double value) {
        System.out.println("double");
    }
}

Test t = new Test();
byte b = 10;
t.method(b);      // "int" (byte → int 자동 형변환)

long l = 10L;
t.method(l);      // "double" (long → double, int는 형변환 불가)
```

**정확한 매칭 원칙:**
1. 정확히 일치하는 타입 우선
2. 없으면 자동 형변환 가능한 타입
3. 가장 작은 형변환 선택

---

#### Q7. 오버로딩은 왜 사용하나요?

**답변:**

**사용 이유:**

1. **코드 일관성**
```java
// ❌ 오버로딩 없이
printInt(10);
printDouble(10.5);
printString("text");

// ✅ 오버로딩 사용
print(10);
print(10.5);
print("text");
```

2. **사용 편의성**
```java
// 다양한 입력 형태 지원
Arrays.asList(1, 2, 3);
Arrays.asList("a", "b", "c");
```

3. **점진적 기능 확장**
```java
// 기본 기능
public void send(String message) { }

// 수신자 지정
public void send(String message, String recipient) { }

// 예약 전송
public void send(String message, String recipient, String time) { }
```

---

### 중급 레벨 (8-12)

#### Q8. 오버로딩 해소(resolution)는 컴파일 타임에 일어나나요, 런타임에 일어나나요?

**답변:**

**컴파일 타임**에 일어납니다.

```java
public class Test {
    void method(Object obj) {
        System.out.println("Object");
    }

    void method(String str) {
        System.out.println("String");
    }
}

Test t = new Test();
Object obj = "Hello";
t.method(obj);  // "Object" 출력

// 컴파일 타임에 obj의 선언 타입(Object)을 보고 결정
// 런타임 타입(String)은 무시됨
```

**vs 오버라이딩 (런타임):**
```java
class Animal {
    void sound() { System.out.println("동물"); }
}
class Dog extends Animal {
    @Override
    void sound() { System.out.println("멍멍"); }
}

Animal a = new Dog();
a.sound();  // "멍멍" (런타임에 실제 객체 타입으로 결정)
```

---

#### Q9. 오버로딩된 메서드 간에 this()로 서로 호출할 수 있나요?

**답변:**

**생성자는 가능하지만, 일반 메서드는 불필요합니다.**

```java
// 생성자: this()로 다른 생성자 호출
public class User {
    String name;
    int age;

    public User(String name) {
        this(name, 0);  // 다른 생성자 호출
    }

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

// 일반 메서드: 그냥 호출
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return add(a, b) + c;  // 다른 오버로딩 메서드 호출
    }
}
```

---

#### Q10. 제네릭 메서드와 오버로딩을 함께 사용할 때 주의할 점은?

**답변:**

**타입 소거(Type Erasure)로 인한 충돌 주의**

```java
// ❌ 컴파일 에러
public class Generic {
    public void method(List<String> list) { }
    public void method(List<Integer> list) { }
    // 컴파일 후 둘 다 method(List)로 변환 → 충돌
}

// ✅ 해결책 1: 다른 메서드 이름
public void processStrings(List<String> list) { }
public void processIntegers(List<Integer> list) { }

// ✅ 해결책 2: 추가 매개변수
public void method(List<String> list, boolean dummy) { }
public void method(List<Integer> list, int dummy) { }
```

---

#### Q11. 오버로딩을 남용하면 어떤 문제가 발생하나요?

**답변:**

**문제점:**

1. **가독성 저하**
```java
// 너무 많은 오버로딩
public void create(...) { }  // 10개 이상의 오버로딩
```

2. **잘못된 메서드 호출**
```java
public void send(String to, String message) { }
public void send(String message, String from) { }
// send("message", "user") → 어떤 것?
```

3. **유지보수 어려움**

**대안:**

**빌더 패턴:**
```java
new EmailBuilder()
    .to("user@example.com")
    .subject("제목")
    .body("내용")
    .send();
```

**매개변수 객체:**
```java
class EmailRequest {
    String to;
    String subject;
    String body;
}

public void send(EmailRequest request) { }
```

---

#### Q12. 오버로딩 vs Optional 매개변수 - 어떤 것이 더 나은가요?

**답변:**

**Java는 Optional 매개변수를 직접 지원하지 않으므로 오버로딩 사용**

```java
// 오버로딩 (Java 방식)
public void send(String message) {
    send(message, null);
}

public void send(String message, String recipient) {
    // 구현
}

// Optional 사용 (Java 8+)
public void send(String message, Optional<String> recipient) {
    String to = recipient.orElse("default@email.com");
}

// 빌더 패턴 (가장 유연)
public class Email {
    private String message;
    private String recipient;

    public static class Builder {
        private String message;
        private String recipient = "default@email.com";

        public Builder message(String message) {
            this.message = message;
            return this;
        }

        public Builder recipient(String recipient) {
            this.recipient = recipient;
            return this;
        }

        public Email build() {
            return new Email(this);
        }
    }
}
```

**추천:**
- 매개변수 2-3개: 오버로딩
- 매개변수 4개 이상: 빌더 패턴

---

## 마무리

### 메서드 오버로딩 완전 정복

**핵심 개념:**
- ✅ 같은 이름, 다른 매개변수
- ✅ 타입, 개수, 순서로 구분
- ✅ 컴파일 타임에 결정
- ✅ 코드 일관성과 편의성 향상

**주의사항:**
- ❌ 매개변수 이름만 다르게 불가
- ❌ 반환 타입만 다르게 불가
- ⚠️ 자동 형변환 규칙 숙지
- ⚠️ 가변 인자 우선순위 이해

**실무 적용:**
- API 설계 시 유연성 제공
- 사용자 편의성 증대
- 하위 호환성 유지

다음 Chapter 15에서는 **상속(Inheritance)**을 다룹니다!
