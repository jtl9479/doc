# 36장: 프로파일 관리

**📚 학습 목표**
- Spring Boot 프로파일의 개념과 필요성을 이해합니다
- 프로파일 활성화 방법을 다양하게 익힙니다
- 프로파일별 설정 파일을 관리하는 방법을 습득합니다
- @Profile 어노테이션으로 조건부 빈을 등록합니다
- 실무 환경별 프로파일 전략을 수립합니다

**⏱️ 예상 학습 시간**: 3-4시간
**📊 난이도**: ⭐⭐⭐ (중급)

---

## 왜 프로파일 관리가 필요한가?

애플리케이션은 개발(dev), 스테이징(staging), 운영(prod) 등 다양한 환경에서 실행됩니다. 각 환경마다 데이터베이스 URL, 로그 레벨, API 엔드포인트 등 설정 값이 다릅니다.

**프로파일 없이 환경별 설정을 관리할 때 발생하는 문제**:
```java
// ❌ 하드코딩 또는 매번 수동 변경
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() {
        // 운영 배포 전에 매번 주석 변경 필요
        // return devDataSource();
        return prodDataSource(); // 실수로 dev 설정으로 배포하면 대참사!
    }
}
```

**프로파일을 사용하면**:
```yaml
# application-dev.yml (자동으로 개발 환경에서만 사용)
spring:
  datasource:
    url: jdbc:h2:mem:devdb

# application-prod.yml (자동으로 운영 환경에서만 사용)
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/proddb
```

**Spring Boot 프로파일의 핵심 가치**:
- ✅ **환경 분리**: 개발/스테이징/운영 설정을 명확히 분리
- ✅ **자동 적용**: 활성 프로파일에 따라 자동으로 설정 로드
- ✅ **안전성**: 환경별 실수 방지 (dev 설정으로 prod 배포 불가)
- ✅ **유연성**: 여러 프로파일을 동시 활성화 가능
- ✅ **조건부 빈**: 환경에 따라 다른 구현체 자동 주입

---

## 실생활 비유로 이해하는 프로파일

### 1. 자동차 주행 모드 (드라이브 모드 선택)

현대 자동차에는 **에코/스포츠/컴포트 모드**가 있습니다.

```java
// 🚗 자동차 주행 모드
class Car {
    void setDriveMode(String mode) {
        switch(mode) {
            case "ECO":    // 연비 우선, 출력 제한
            case "SPORT":  // 성능 우선, 연료 소비 증가
            case "COMFORT": // 균형 모드
        }
    }
}

// 🌱 Spring Boot 프로파일
@Profile("dev")    // 개발: 빠른 재시작, H2 인메모리 DB
@Profile("prod")   // 운영: 성능 최적화, 실제 DB
@Profile("test")   // 테스트: Mock 데이터
```

**비유 핵심**:
- 버튼 하나로 차량 전체 세팅이 변경되듯, 프로파일 하나로 앱 전체 설정 변경
- 각 모드는 독립적인 설정 세트를 가짐
- 운전자가 상황에 맞게 선택 (환경에 맞게 프로파일 선택)

---

### 2. 옷장 정리 (계절별 옷 관리)

옷장을 **봄/여름/가을/겨울**로 나눠서 관리합니다.

```yaml
# 👔 옷장 비유
wardrobe:
  spring: [가디건, 얇은 재킷]
  summer: [반팔, 반바지]
  winter: [패딩, 목도리]

# 🌱 Spring Boot 설정
---
# application-dev.yml
logging.level.root: DEBUG  # 개발: 모든 로그 출력
---
# application-prod.yml
logging.level.root: WARN   # 운영: 경고 이상만 출력
```

**비유 핵심**:
- 계절(환경)이 바뀌면 자동으로 필요한 옷(설정)을 꺼냄
- 겨울에 반팔을 입지 않듯, prod 환경에서 dev 설정을 쓰지 않음
- 같은 옷장(애플리케이션)이지만 내용물(설정)이 다름

---

### 3. 레스토랑 메뉴판 (시간대별 메뉴)

레스토랑은 **아침/점심/저녁**마다 다른 메뉴를 제공합니다.

```java
// 🍽️ 레스토랑 메뉴
@Component
class Restaurant {
    @TimeSlot("breakfast")
    Menu getBreakfastMenu() { return new Menu("토스트", "커피"); }

    @TimeSlot("dinner")
    Menu getDinnerMenu() { return new Menu("스테이크", "와인"); }
}

// 🌱 Spring Boot
@Configuration
class DataSourceConfig {
    @Bean
    @Profile("dev")
    DataSource h2DataSource() { /* 가벼운 H2 */ }

    @Bean
    @Profile("prod")
    DataSource mysqlDataSource() { /* 실제 MySQL */ }
}
```

**비유 핵심**:
- 시간대(프로파일)에 따라 자동으로 메뉴(빈) 제공
- 아침에 스테이크를 주문할 수 없듯, dev에서 prod 빈은 생성 안 됨
- 같은 주방(애플리케이션)에서 다른 음식(구현체) 제공

---

## 핵심 개념

### 초급: 프로파일 기본 사용

#### 1. 프로파일별 설정 파일

```
src/main/resources/
├── application.yml          # 공통 설정
├── application-dev.yml      # 개발 환경
├── application-staging.yml  # 스테이징 환경
└── application-prod.yml     # 운영 환경
```

```yaml
# application.yml (공통 설정)
spring:
  application:
    name: myapp

server:
  port: 8080

---
# application-dev.yml (개발 환경)
spring:
  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password:
  h2:
    console:
      enabled: true

logging:
  level:
    root: DEBUG
    com.myapp: TRACE

---
# application-prod.yml (운영 환경)
spring:
  datasource:
    url: jdbc:mysql://prod-db-server:3306/myapp
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20

logging:
  level:
    root: WARN
    com.myapp: INFO
```

#### 2. 프로파일 활성화 방법

```bash
# 방법 1: application.yml에서 기본 프로파일 지정
spring:
  profiles:
    active: dev

# 방법 2: 명령행 인수
java -jar myapp.jar --spring.profiles.active=prod

# 방법 3: 환경 변수
export SPRING_PROFILES_ACTIVE=prod
java -jar myapp.jar

# 방법 4: IDE 설정 (IntelliJ IDEA)
Run > Edit Configurations > Environment variables
SPRING_PROFILES_ACTIVE=dev

# 방법 5: 여러 프로파일 동시 활성화
java -jar myapp.jar --spring.profiles.active=prod,monitoring
```

#### 3. @Profile 어노테이션으로 조건부 빈 등록

```java
@Configuration
public class DataSourceConfig {

    // 개발 환경: H2 인메모리 DB
    @Bean
    @Profile("dev")
    public DataSource h2DataSource() {
        return DataSourceBuilder.create()
                .driverClassName("org.h2.Driver")
                .url("jdbc:h2:mem:devdb")
                .username("sa")
                .password("")
                .build();
    }

    // 운영 환경: MySQL
    @Bean
    @Profile("prod")
    public DataSource mysqlDataSource(
            @Value("${spring.datasource.url}") String url,
            @Value("${spring.datasource.username}") String username,
            @Value("${spring.datasource.password}") String password) {

        HikariConfig config = new HikariConfig();
        config.setJdbcUrl(url);
        config.setUsername(username);
        config.setPassword(password);
        config.setMaximumPoolSize(20);
        config.setMinimumIdle(5);

        return new HikariDataSource(config);
    }
}
```

```java
// 외부 API 클라이언트 - 환경별 다른 구현체
@Component
@Profile("dev")
public class MockPaymentClient implements PaymentClient {
    @Override
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("🧪 Mock Payment: {}", request);
        return PaymentResult.success("MOCK-" + UUID.randomUUID());
    }
}

@Component
@Profile("prod")
public class RealPaymentClient implements PaymentClient {

    @Value("${payment.api.url}")
    private String apiUrl;

    @Override
    public PaymentResult processPayment(PaymentRequest request) {
        log.info("💳 Real Payment Processing: {}", request);
        // 실제 PG사 API 호출
        return restTemplate.postForObject(
            apiUrl + "/payment",
            request,
            PaymentResult.class
        );
    }
}
```

---

### 중급: 고급 프로파일 전략

#### 1. 프로파일 표현식 (Profile Expressions)

```java
// NOT 연산자
@Component
@Profile("!prod")  // prod가 아닌 모든 환경에서 활성화
public class DevToolsConfig {
    // 개발 편의 기능 (운영에서는 비활성화)
}

// AND 연산자
@Component
@Profile("prod & monitoring")  // prod이면서 monitoring도 활성화된 경우
public class ProductionMonitoringConfig {
    @Bean
    public MeterRegistry prometheusMeterRegistry() {
        return new PrometheusMeterRegistry(PrometheusConfig.DEFAULT);
    }
}

// OR 연산자
@Component
@Profile("dev | test")  // dev 또는 test 환경
public class TestDataInitializer implements CommandLineRunner {
    @Override
    public void run(String... args) {
        log.info("🌱 Initializing test data...");
        // 테스트 데이터 생성
    }
}

// 복잡한 표현식
@Profile("(prod | staging) & monitoring")
public class AdvancedMonitoringConfig {
    // prod 또는 staging이면서 monitoring이 활성화된 경우
}
```

#### 2. 프로파일 그룹 (Profile Groups) - Spring Boot 2.4+

```yaml
# application.yml
spring:
  profiles:
    group:
      local: [dev, h2db, debug]
      production: [prod, mysql, monitoring, security]
      staging: [staging, mysql, monitoring]

# 사용법
# java -jar myapp.jar --spring.profiles.active=local
# → dev, h2db, debug 모두 활성화됨
```

```java
// 각 프로파일별 설정
@Configuration
@Profile("h2db")
public class H2DatabaseConfig {
    // H2 전용 설정
}

@Configuration
@Profile("mysql")
public class MySQLDatabaseConfig {
    // MySQL 전용 설정
}

@Configuration
@Profile("monitoring")
public class MonitoringConfig {
    // Prometheus, Grafana 설정
}

@Configuration
@Profile("security")
public class ProductionSecurityConfig {
    // 운영 보안 강화 설정
}
```

#### 3. 프로파일별 다중 문서 (Multi-Document)

```yaml
# application.yml (한 파일에 여러 프로파일 정의)

# 공통 설정
spring:
  application:
    name: myapp

---
# 개발 환경
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:h2:mem:devdb

logging:
  level:
    root: DEBUG

---
# 스테이징 환경
spring:
  config:
    activate:
      on-profile: staging

  datasource:
    url: jdbc:mysql://staging-db:3306/myapp
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}

logging:
  level:
    root: INFO

---
# 운영 환경
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: jdbc:mysql://prod-db-cluster:3306/myapp
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50

logging:
  level:
    root: WARN
```

#### 4. @ActiveProfiles를 이용한 테스트 프로파일

```java
// 테스트에서 프로파일 활성화
@SpringBootTest
@ActiveProfiles("test")
class OrderServiceTest {

    @Autowired
    private PaymentClient paymentClient;

    @Test
    void test_with_mock_payment() {
        // test 프로파일 활성화 시 MockPaymentClient 주입됨
        assertThat(paymentClient).isInstanceOf(MockPaymentClient.class);
    }
}

// 테스트 전용 설정
@TestConfiguration
@Profile("test")
public class TestConfig {

    @Bean
    public Clock fixedClock() {
        // 테스트에서 시간 고정
        return Clock.fixed(
            Instant.parse("2025-01-01T00:00:00Z"),
            ZoneId.of("Asia/Seoul")
        );
    }
}
```

---

### 고급: 실무 프로파일 설계 패턴

#### 1. 계층형 프로파일 전략

```yaml
# 기본 프로파일 계층 구조
# base (공통) → env (환경) → feature (기능)

spring:
  profiles:
    group:
      # 환경별 프로파일
      local: [base, dev, h2db, debug, mock-external-api]
      dev-server: [base, dev, mysql, debug]
      staging: [base, staging, mysql, monitoring]
      production: [base, prod, mysql, monitoring, security, cache]

      # 기능별 프로파일
      mock-external-api: []  # 외부 API Mock
      debug: []              # 디버깅 기능
      monitoring: []         # 모니터링
      security: []           # 보안 강화
      cache: []              # 캐시 활성화
```

```java
// base 프로파일 (항상 필요한 기본 설정)
@Configuration
@Profile("base")
public class BaseConfig {
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper()
                .registerModule(new JavaTimeModule())
                .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
    }
}

// 환경별 프로파일
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public CommandLineRunner devDataInitializer() {
        return args -> log.info("🌱 Dev environment ready");
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public CommandLineRunner prodStartupLogger() {
        return args -> log.warn("🚀 Production environment started");
    }
}

// 기능별 프로파일
@Configuration
@Profile("mock-external-api")
public class MockExternalApiConfig {
    @Bean
    public ExternalApiClient mockApiClient() {
        return new MockExternalApiClient();
    }
}

@Configuration
@Profile("cache")
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users", "products");
    }
}
```

#### 2. 환경 변수 우선순위 활용

```bash
# 우선순위 (높은 순서대로)
# 1. 명령행 인수 (--spring.profiles.active=prod)
# 2. 환경 변수 (SPRING_PROFILES_ACTIVE=prod)
# 3. application.yml (spring.profiles.active: dev)
# 4. @ActiveProfiles (테스트)

# Kubernetes ConfigMap 예제
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  SPRING_PROFILES_ACTIVE: "prod,monitoring,cache"

---
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: myapp
        image: myapp:1.0.0
        envFrom:
        - configMapRef:
            name: app-config
```

#### 3. 프로파일별 로깅 전략

```xml
<!-- logback-spring.xml -->
<configuration>
    <!-- 개발 환경: 콘솔 출력 + 상세 로그 -->
    <springProfile name="dev">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>

        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>

    <!-- 운영 환경: 파일 출력 + JSON 포맷 -->
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/var/log/myapp/application.log</file>
            <encoder class="net.logstash.logback.encoder.LogstashEncoder">
                <includeMdcKeyName>traceId</includeMdcKeyName>
                <includeMdcKeyName>userId</includeMdcKeyName>
            </encoder>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/var/log/myapp/application.%d{yyyy-MM-dd}.log</fileNamePattern>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
        </appender>

        <root level="WARN">
            <appender-ref ref="FILE"/>
        </root>

        <logger name="com.myapp" level="INFO"/>
    </springProfile>
</configuration>
```

#### 4. 동적 프로파일 확인 및 검증

```java
@Component
public class ProfileValidator implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private Environment environment;

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        String[] activeProfiles = environment.getActiveProfiles();

        log.info("========================================");
        log.info("🌱 Active Profiles: {}", Arrays.toString(activeProfiles));
        log.info("========================================");

        // 운영 환경 검증
        if (Arrays.asList(activeProfiles).contains("prod")) {
            validateProductionConfig();
        }
    }

    private void validateProductionConfig() {
        // 필수 설정 검증
        requireProperty("spring.datasource.url");
        requireProperty("spring.datasource.username");

        // 위험한 설정 체크
        if (environment.getProperty("spring.h2.console.enabled", Boolean.class, false)) {
            throw new IllegalStateException(
                "❌ H2 Console must be disabled in production!"
            );
        }

        log.info("✅ Production configuration validated");
    }

    private void requireProperty(String key) {
        if (!environment.containsProperty(key)) {
            throw new IllegalStateException(
                String.format("❌ Required property '%s' is missing!", key)
            );
        }
    }
}
```

```java
// 프로파일 기반 조건부 로직
@Service
public class EmailService {

    @Autowired
    private Environment environment;

    public void sendEmail(String to, String subject, String body) {
        if (environment.acceptsProfiles(Profiles.of("dev"))) {
            // 개발 환경: 실제 발송 안 함
            log.info("📧 [DEV] Email to {}: {}", to, subject);
            return;
        }

        if (environment.acceptsProfiles(Profiles.of("prod"))) {
            // 운영 환경: 실제 발송
            log.info("📧 [PROD] Sending email to {}", to);
            actualEmailSender.send(to, subject, body);
        }
    }
}
```

---

## 기본 실습

### 실습 1: 환경별 데이터베이스 설정

**목표**: dev/prod 환경별로 다른 데이터베이스를 사용하는 애플리케이션 구성

```yaml
# src/main/resources/application.yml
spring:
  application:
    name: profile-demo

server:
  port: 8080

---
# src/main/resources/application-dev.yml
spring:
  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password:
    driver-class-name: org.h2.Driver

  h2:
    console:
      enabled: true
      path: /h2-console

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        format_sql: true

logging:
  level:
    root: INFO
    com.example: DEBUG
    org.hibernate.SQL: DEBUG

---
# src/main/resources/application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-mysql-server:3306/myapp?useSSL=true
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

logging:
  level:
    root: WARN
    com.example: INFO
```

```java
// Entity
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // getters, setters
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
}

// Service
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public User createUser(String name, String email) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        return userRepository.save(user);
    }

    public List<User> findAll() {
        return userRepository.findAll();
    }
}

// 환경별 초기 데이터 설정
@Component
@Profile("dev")
@RequiredArgsConstructor
public class DevDataInitializer implements CommandLineRunner {

    private final UserService userService;

    @Override
    public void run(String... args) {
        log.info("🌱 Initializing dev data...");

        userService.createUser("홍길동", "hong@example.com");
        userService.createUser("김철수", "kim@example.com");
        userService.createUser("이영희", "lee@example.com");

        log.info("✅ Dev data initialized: {} users", userService.findAll().size());
    }
}

// 운영 환경 시작 로거
@Component
@Profile("prod")
public class ProductionStartupLogger implements ApplicationListener<ApplicationReadyEvent> {

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        log.warn("========================================");
        log.warn("🚀 Production application started");
        log.warn("========================================");
    }
}
```

**실행 방법**:
```bash
# 개발 환경 실행
./mvnw spring-boot:run -Dspring-boot.run.profiles=dev

# H2 Console 접속: http://localhost:8080/h2-console
# JDBC URL: jdbc:h2:mem:devdb

# 운영 환경 실행 (환경 변수 필요)
export DB_USERNAME=prod_user
export DB_PASSWORD=prod_password
./mvnw spring-boot:run -Dspring-boot.run.profiles=prod
```

**결과 확인**:
```bash
# dev 프로파일 활성화 시
# 2025-01-20 10:00:00.123 DEBUG - Hibernate: create table users (...)
# 2025-01-20 10:00:01.456 INFO  - 🌱 Initializing dev data...
# 2025-01-20 10:00:01.789 INFO  - ✅ Dev data initialized: 3 users

# prod 프로파일 활성화 시
# 2025-01-20 10:00:00.123 WARN  - 🚀 Production application started
```

---

### 실습 2: 외부 API 클라이언트 - Mock vs Real

**목표**: 개발 환경에서는 Mock API를 사용하고, 운영 환경에서는 실제 API를 호출

```java
// 공통 인터페이스
public interface WeatherApiClient {
    WeatherInfo getWeather(String city);
}

@Data
@AllArgsConstructor
public class WeatherInfo {
    private String city;
    private double temperature;
    private String condition;
}

// 개발 환경: Mock 구현체
@Component
@Profile("dev")
@Slf4j
public class MockWeatherApiClient implements WeatherApiClient {

    private final Random random = new Random();

    @Override
    public WeatherInfo getWeather(String city) {
        log.info("🧪 [MOCK] Getting weather for {}", city);

        // 랜덤 날씨 데이터 생성
        double temp = 15 + random.nextInt(20);
        String[] conditions = {"맑음", "흐림", "비", "눈"};
        String condition = conditions[random.nextInt(conditions.length)];

        return new WeatherInfo(city, temp, condition);
    }
}

// 운영 환경: 실제 API 구현체
@Component
@Profile("prod")
@Slf4j
public class RealWeatherApiClient implements WeatherApiClient {

    @Value("${weather.api.url}")
    private String apiUrl;

    @Value("${weather.api.key}")
    private String apiKey;

    private final RestTemplate restTemplate = new RestTemplate();

    @Override
    public WeatherInfo getWeather(String city) {
        log.info("🌐 [REAL] Calling external weather API for {}", city);

        String url = String.format("%s/weather?city=%s&apiKey=%s",
            apiUrl, city, apiKey);

        try {
            WeatherApiResponse response = restTemplate.getForObject(
                url, WeatherApiResponse.class);

            return new WeatherInfo(
                city,
                response.getMain().getTemp(),
                response.getWeather().get(0).getDescription()
            );
        } catch (Exception e) {
            log.error("Failed to call weather API", e);
            throw new RuntimeException("Weather API error", e);
        }
    }
}

// Controller
@RestController
@RequestMapping("/api/weather")
@RequiredArgsConstructor
public class WeatherController {

    private final WeatherApiClient weatherApiClient;
    private final Environment environment;

    @GetMapping("/{city}")
    public ResponseEntity<WeatherResponse> getWeather(@PathVariable String city) {
        String activeProfile = environment.getActiveProfiles()[0];

        WeatherInfo weather = weatherApiClient.getWeather(city);

        return ResponseEntity.ok(WeatherResponse.builder()
                .city(weather.getCity())
                .temperature(weather.getTemperature())
                .condition(weather.getCondition())
                .source(activeProfile.equals("dev") ? "MOCK" : "REAL")
                .build());
    }
}
```

```yaml
# application-prod.yml
weather:
  api:
    url: https://api.openweathermap.org/data/2.5
    key: ${WEATHER_API_KEY}
```

**테스트**:
```bash
# dev 환경
curl http://localhost:8080/api/weather/Seoul
# Response:
# {
#   "city": "Seoul",
#   "temperature": 23.5,
#   "condition": "맑음",
#   "source": "MOCK"
# }

# prod 환경
curl http://localhost:8080/api/weather/Seoul
# Response:
# {
#   "city": "Seoul",
#   "temperature": 18.2,
#   "condition": "Partly cloudy",
#   "source": "REAL"
# }
```

---

### 실습 3: 프로파일 그룹과 다중 프로파일 활용

**목표**: 프로파일 그룹을 사용하여 복잡한 환경 구성을 단순화

```yaml
# application.yml
spring:
  profiles:
    group:
      # 로컬 개발 환경
      local: [base, dev, h2, mock-api, debug]

      # 개발 서버 환경
      dev-server: [base, dev, mysql, mock-api, monitoring]

      # 스테이징 환경
      staging: [base, staging, mysql, real-api, monitoring]

      # 운영 환경
      production: [base, prod, mysql, real-api, monitoring, security, cache]

---
# base 프로파일 (공통 설정)
spring:
  config:
    activate:
      on-profile: base

# 공통 설정
  application:
    name: multi-profile-demo

---
# h2 프로파일
spring:
  config:
    activate:
      on-profile: h2

  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver

  h2:
    console:
      enabled: true

---
# mysql 프로파일
spring:
  config:
    activate:
      on-profile: mysql

  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:3306/${DB_NAME:myapp}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

---
# monitoring 프로파일
spring:
  config:
    activate:
      on-profile: monitoring

management:
  endpoints:
    web:
      exposure:
        include: health,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true

---
# cache 프로파일
spring:
  config:
    activate:
      on-profile: cache

  cache:
    type: caffeine
    caffeine:
      spec: maximumSize=1000,expireAfterWrite=10m

---
# security 프로파일
spring:
  config:
    activate:
      on-profile: security

  security:
    require-ssl: true
```

```java
// base 프로파일 설정
@Configuration
@Profile("base")
public class BaseConfig {
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper()
                .registerModule(new JavaTimeModule());
    }
}

// debug 프로파일 설정
@Configuration
@Profile("debug")
public class DebugConfig {
    @Bean
    public FilterRegistrationBean<RequestLoggingFilter> loggingFilter() {
        FilterRegistrationBean<RequestLoggingFilter> registration =
            new FilterRegistrationBean<>();
        registration.setFilter(new RequestLoggingFilter());
        registration.addUrlPatterns("/*");
        return registration;
    }
}

// cache 프로파일 설정
@Configuration
@Profile("cache")
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("users", "products");
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(Duration.ofMinutes(10)));
        return cacheManager;
    }
}

// security 프로파일 설정
@Configuration
@Profile("security")
public class ProductionSecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .requiresChannel(channel -> channel
                .anyRequest().requiresSecure()  // HTTPS 강제
            )
            .headers(headers -> headers
                .httpStrictTransportSecurity(hsts -> hsts
                    .maxAgeInSeconds(31536000)
                    .includeSubDomains(true)
                )
            );
        return http.build();
    }
}

// 프로파일 정보 API
@RestController
@RequestMapping("/api/info")
public class ProfileInfoController {

    @Autowired
    private Environment environment;

    @GetMapping("/profiles")
    public Map<String, Object> getActiveProfiles() {
        return Map.of(
            "activeProfiles", environment.getActiveProfiles(),
            "defaultProfiles", environment.getDefaultProfiles()
        );
    }
}
```

**실행 예제**:
```bash
# 로컬 개발
java -jar app.jar --spring.profiles.active=local
# 활성화: base, dev, h2, mock-api, debug

# 스테이징 서버
java -jar app.jar --spring.profiles.active=staging
# 활성화: base, staging, mysql, real-api, monitoring

# 운영 서버
java -jar app.jar --spring.profiles.active=production
# 활성화: base, prod, mysql, real-api, monitoring, security, cache
```

**프로파일 확인 API**:
```bash
curl http://localhost:8080/api/info/profiles

# local 환경 응답
{
  "activeProfiles": ["local", "base", "dev", "h2", "mock-api", "debug"],
  "defaultProfiles": ["default"]
}

# production 환경 응답
{
  "activeProfiles": ["production", "base", "prod", "mysql", "real-api", "monitoring", "security", "cache"],
  "defaultProfiles": ["default"]
}
```

---

## 주니어 개발자 시나리오: "개발 환경과 운영 환경 DB가 섞였어요!"

**상황**:
입사 2개월차 주니어 개발자가 실수로 **로컬 개발 중 운영 데이터베이스에 연결**하여 실제 고객 데이터를 조회했습니다.

```java
// ❌ 하드코딩된 설정 (위험!)
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() {
        // 개발 중 실수로 운영 DB URL 입력
        return DataSourceBuilder.create()
                .url("jdbc:mysql://prod-db.company.com:3306/production")
                .username("prod_user")
                .password("prod_password")
                .build();
    }
}
```

**문제점**:
- ❌ 로컬 개발 중 운영 DB에 접근
- ❌ 실수로 운영 데이터 수정/삭제 가능
- ❌ 환경별 설정 구분 없음
- ❌ 코드에 민감 정보 하드코딩

**시니어의 프로파일 기반 해결책**:

```yaml
# application.yml (공통 설정만)
spring:
  application:
    name: user-service

  profiles:
    active: dev  # 기본값은 항상 dev

---
# application-dev.yml (개발 환경)
spring:
  datasource:
    url: jdbc:h2:mem:devdb
    username: sa
    password:
    driver-class-name: org.h2.Driver

  h2:
    console:
      enabled: true

  jpa:
    hibernate:
      ddl-auto: create-drop  # 테이블 자동 생성/삭제
    show-sql: true

---
# application-prod.yml (운영 환경)
spring:
  datasource:
    # 환경 변수로만 설정 (코드에 노출 안 됨)
    url: ${PROD_DB_URL}
    username: ${PROD_DB_USERNAME}
    password: ${PROD_DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver

  jpa:
    hibernate:
      ddl-auto: validate  # 테이블 변경 불가
    show-sql: false
```

```java
// 안전한 DataSource 설정
@Configuration
public class DataSourceConfig {

    // 개발 환경: H2 (안전)
    @Bean
    @Profile("dev")
    public DataSource devDataSource() {
        log.info("🌱 [DEV] Using H2 in-memory database");
        return DataSourceBuilder.create()
                .driverClassName("org.h2.Driver")
                .url("jdbc:h2:mem:devdb")
                .username("sa")
                .password("")
                .build();
    }

    // 운영 환경: MySQL (환경 변수 필수)
    @Bean
    @Profile("prod")
    public DataSource prodDataSource(Environment env) {
        log.warn("🚀 [PROD] Connecting to production database");

        // 필수 환경 변수 검증
        String url = requireEnv(env, "PROD_DB_URL");
        String username = requireEnv(env, "PROD_DB_USERNAME");
        String password = requireEnv(env, "PROD_DB_PASSWORD");

        return DataSourceBuilder.create()
                .url(url)
                .username(username)
                .password(password)
                .build();
    }

    private String requireEnv(Environment env, String key) {
        String value = env.getProperty(key);
        if (value == null || value.isBlank()) {
            throw new IllegalStateException(
                String.format("❌ Required environment variable '%s' is not set!", key)
            );
        }
        return value;
    }
}

// 운영 환경 안전 장치
@Component
@Profile("prod")
public class ProductionSafetyGuard implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private Environment environment;

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        // 위험한 설정 체크
        checkDangerousSettings();

        log.warn("========================================");
        log.warn("⚠️  PRODUCTION ENVIRONMENT");
        log.warn("⚠️  Be careful with database operations!");
        log.warn("========================================");
    }

    private void checkDangerousSettings() {
        // H2 Console이 운영에서 활성화되면 에러
        if (environment.getProperty("spring.h2.console.enabled", Boolean.class, false)) {
            throw new IllegalStateException(
                "❌ H2 Console must be disabled in production!"
            );
        }

        // DDL auto가 create/create-drop이면 에러
        String ddlAuto = environment.getProperty("spring.jpa.hibernate.ddl-auto", "none");
        if (ddlAuto.equals("create") || ddlAuto.equals("create-drop")) {
            throw new IllegalStateException(
                "❌ DDL auto must be 'validate' or 'none' in production!"
            );
        }
    }
}
```

**안전한 실행 방법**:
```bash
# 로컬 개발 (기본값 dev)
./mvnw spring-boot:run
# → H2 인메모리 DB 사용, 안전

# 운영 배포 (환경 변수 필수)
export PROD_DB_URL=jdbc:mysql://prod-db.company.com:3306/production
export PROD_DB_USERNAME=prod_user
export PROD_DB_PASSWORD=secure_password
java -jar app.jar --spring.profiles.active=prod
# → 환경 변수 없으면 시작 실패 (안전)
```

**배운 교훈**:
1. ✅ **기본 프로파일은 항상 dev로 설정** → 실수로 prod 실행 방지
2. ✅ **운영 설정은 환경 변수로만 관리** → 코드에 민감 정보 노출 방지
3. ✅ **프로파일별로 완전히 다른 DataSource 사용** → 환경 격리
4. ✅ **운영 환경 시작 시 안전 장치 작동** → 위험한 설정 차단
5. ✅ **환경 변수 누락 시 즉시 실패** → 잘못된 설정으로 실행 방지

---

## 기업 사례

### 사례 1: Netflix - 수천 개의 마이크로서비스 프로파일 관리

**과제**:
Netflix는 **수천 개의 마이크로서비스**를 운영하며, 각 서비스가 dev/test/staging/prod 환경에서 실행됩니다. 환경별로 다른 설정을 안전하게 관리해야 했습니다.

**Netflix의 프로파일 전략**:

```yaml
# Netflix Archaius (동적 설정 관리) + Spring Cloud Config
spring:
  application:
    name: movie-recommendation-service

  profiles:
    group:
      dev: [base, dev, eureka-dev, mock-data]
      test: [base, test, eureka-test, test-data]
      prod: [base, prod, eureka-prod, chaos-monkey, monitoring]

  cloud:
    config:
      uri: http://config-server:8888
      profile: ${ENVIRONMENT:dev}
      label: main
```

```java
// 환경별 Eureka 설정
@Configuration
@Profile("eureka-dev")
public class EurekaDevConfig {
    @Bean
    public EurekaClientConfigBean eurekaClientConfig() {
        EurekaClientConfigBean config = new EurekaClientConfigBean();
        config.setServiceUrl(Map.of(
            "defaultZone", "http://eureka-dev:8761/eureka/"
        ));
        return config;
    }
}

@Configuration
@Profile("eureka-prod")
public class EurekaProdConfig {
    @Bean
    public EurekaClientConfigBean eurekaClientConfig() {
        EurekaClientConfigBean config = new EurekaClientConfigBean();
        // 운영: 3개의 Eureka 서버 클러스터
        config.setServiceUrl(Map.of(
            "defaultZone", "http://eureka-prod-1:8761/eureka/," +
                          "http://eureka-prod-2:8761/eureka/," +
                          "http://eureka-prod-3:8761/eureka/"
        ));
        return config;
    }
}

// Chaos Monkey (운영 환경에서만 활성화)
@Configuration
@Profile("chaos-monkey")
public class ChaosMonkeyConfig {
    // 무작위 장애 주입으로 서비스 복원력 테스트
}
```

**결과**:
- ✅ 수천 개 서비스의 환경별 설정 자동 관리
- ✅ 중앙 집중식 설정 서버 (Spring Cloud Config)
- ✅ 운영 환경에서만 Chaos Engineering 활성화
- ✅ 환경별 서비스 디스커버리 분리

---

### 사례 2: Airbnb - 글로벌 리전별 프로파일 관리

**과제**:
Airbnb는 **전 세계 여러 리전**(미국, 유럽, 아시아)에서 서비스를 운영하며, 각 리전마다 다른 데이터베이스, 결제 시스템, 법규를 준수해야 했습니다.

**Airbnb의 리전별 프로파일 전략**:

```yaml
spring:
  profiles:
    group:
      # 미국 운영 환경
      us-prod: [base, prod, region-us, payment-stripe, db-us-east]

      # 유럽 운영 환경 (GDPR 준수)
      eu-prod: [base, prod, region-eu, payment-adyen, db-eu-west, gdpr]

      # 아시아 운영 환경
      asia-prod: [base, prod, region-asia, payment-local, db-asia-pacific]
```

```java
// 리전별 결제 시스템
@Component
@Profile("payment-stripe")
public class StripePaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        log.info("💳 Processing payment via Stripe (US)");
        // Stripe API 호출
        return stripeClient.charge(request);
    }
}

@Component
@Profile("payment-adyen")
public class AdyenPaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        log.info("💳 Processing payment via Adyen (EU)");
        // Adyen API 호출 (유럽 현지 결제 지원)
        return adyenClient.charge(request);
    }
}

@Component
@Profile("payment-local")
public class LocalPaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        log.info("💳 Processing payment via local providers (Asia)");
        // Alipay, WeChat Pay 등 현지 결제 수단
        return localPaymentClient.charge(request);
    }
}

// GDPR 규정 준수 (유럽만)
@Configuration
@Profile("gdpr")
public class GdprConfig {

    @Bean
    public DataRetentionPolicy gdprRetentionPolicy() {
        // 개인정보 보관 기간 제한
        return new DataRetentionPolicy(Duration.ofDays(90));
    }

    @Bean
    public UserDataExporter gdprDataExporter() {
        // 사용자 데이터 내보내기 기능 (GDPR 요구사항)
        return new UserDataExporter();
    }
}

// 리전별 데이터베이스
@Configuration
@Profile("db-us-east")
public class UsEastDatabaseConfig {
    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
                .url("jdbc:mysql://us-east-1-db-cluster:3306/airbnb")
                .build();
    }
}

@Configuration
@Profile("db-eu-west")
public class EuWestDatabaseConfig {
    @Bean
    public DataSource dataSource() {
        return DataSourceBuilder.create()
                .url("jdbc:mysql://eu-west-1-db-cluster:3306/airbnb")
                .build();
    }
}
```

**배포 스크립트**:
```bash
# 미국 리전 배포
kubectl set env deployment/booking-service \
  SPRING_PROFILES_ACTIVE=us-prod \
  -n us-east-1

# 유럽 리전 배포 (GDPR 포함)
kubectl set env deployment/booking-service \
  SPRING_PROFILES_ACTIVE=eu-prod \
  -n eu-west-1

# 아시아 리전 배포
kubectl set env deployment/booking-service \
  SPRING_PROFILES_ACTIVE=asia-prod \
  -n asia-pacific-1
```

**결과**:
- ✅ 리전별로 완전히 다른 인프라/서비스 사용
- ✅ 법규 준수 (GDPR, 현지 결제 규정)
- ✅ 단일 코드베이스로 전 세계 서비스
- ✅ 프로파일 그룹으로 복잡한 설정 간소화

---

## FAQ

### Q1: 프로파일을 여러 개 동시에 활성화할 수 있나요?

**A**: 네, 가능합니다.

```bash
# 쉼표로 구분하여 여러 프로파일 활성화
java -jar app.jar --spring.profiles.active=prod,monitoring,cache

# 또는 환경 변수
export SPRING_PROFILES_ACTIVE=prod,monitoring,cache
```

```yaml
# application.yml
spring:
  profiles:
    active: dev,debug,mock-api
```

**활용 예시**:
```java
@Component
@Profile("prod")
public class ProdConfig { }

@Component
@Profile("monitoring")
public class MonitoringConfig { }

@Component
@Profile("cache")
public class CacheConfig { }

// prod,monitoring,cache 활성화 시
// → 세 가지 설정 모두 적용됨
```

---

### Q2: 프로파일 우선순위는 어떻게 되나요?

**A**: 설정 우선순위는 다음과 같습니다 (높은 순서대로):

```
1. 명령행 인수 (--spring.profiles.active=prod)
2. SPRING_PROFILES_ACTIVE 환경 변수
3. application.yml의 spring.profiles.active
4. @ActiveProfiles (테스트 전용)
5. 기본 프로파일 (default)
```

**예시**:
```yaml
# application.yml
spring:
  profiles:
    active: dev  # 우선순위 3
```

```bash
# 환경 변수가 우선 (우선순위 2)
export SPRING_PROFILES_ACTIVE=staging
java -jar app.jar  # → staging 적용

# 명령행 인수가 최우선 (우선순위 1)
java -jar app.jar --spring.profiles.active=prod  # → prod 적용
```

**파일 우선순위**:
```
application-{profile}.yml이 application.yml보다 우선

1. application-prod.yml (프로파일 전용)
2. application.yml (공통 설정)
```

---

### Q3: 프로파일 없이 항상 실행되는 설정은 어떻게 만드나요?

**A**: `@Profile` 어노테이션을 사용하지 않거나, `!` (NOT) 연산자를 사용합니다.

```java
// 방법 1: @Profile 어노테이션 없음 (항상 실행)
@Configuration
public class CommonConfig {
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }
}

// 방법 2: @Profile("!none") (항상 실행)
@Configuration
@Profile("!none")
public class AlwaysActiveConfig {
    // "none" 프로파일이 아닌 모든 경우 실행
}

// 방법 3: 여러 프로파일에 공통 적용
@Configuration
@Profile({"dev", "prod", "test"})
public class MultiProfileConfig {
    // dev, prod, test 모두에서 실행
}
```

**application.yml**:
```yaml
# 공통 설정 (프로파일 구분 없이 항상 적용)
spring:
  application:
    name: myapp

server:
  port: 8080

---
# 프로파일별 설정 (덮어쓰기)
spring:
  config:
    activate:
      on-profile: dev

server:
  port: 8081  # dev에서만 8081 포트 사용
```

---

### Q4: 테스트에서 프로파일을 어떻게 사용하나요?

**A**: `@ActiveProfiles` 어노테이션을 사용합니다.

```java
// 단일 프로파일
@SpringBootTest
@ActiveProfiles("test")
class UserServiceTest {
    // test 프로파일 활성화
}

// 여러 프로파일
@SpringBootTest
@ActiveProfiles({"test", "mock-api"})
class IntegrationTest {
    // test, mock-api 프로파일 모두 활성화
}

// 테스트 전용 설정
@TestConfiguration
@Profile("test")
public class TestConfig {

    @Bean
    public Clock fixedClock() {
        return Clock.fixed(
            Instant.parse("2025-01-01T00:00:00Z"),
            ZoneId.of("Asia/Seoul")
        );
    }

    @Bean
    public PaymentClient mockPaymentClient() {
        return new MockPaymentClient();
    }
}
```

```yaml
# src/test/resources/application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true

logging:
  level:
    root: INFO
    com.myapp: DEBUG
```

---

### Q5: 프로파일 활성화 여부를 코드에서 확인할 수 있나요?

**A**: `Environment`를 주입받아 확인할 수 있습니다.

```java
@Service
@RequiredArgsConstructor
public class EmailService {

    private final Environment environment;

    public void sendEmail(String to, String subject, String body) {
        // 방법 1: acceptsProfiles() 사용
        if (environment.acceptsProfiles(Profiles.of("dev"))) {
            log.info("📧 [DEV] Mock email to {}: {}", to, subject);
            return;
        }

        // 방법 2: getActiveProfiles() 사용
        String[] activeProfiles = environment.getActiveProfiles();
        boolean isProd = Arrays.asList(activeProfiles).contains("prod");

        if (isProd) {
            log.info("📧 [PROD] Sending real email to {}", to);
            actualEmailSender.send(to, subject, body);
        }
    }
}

// 표현식 사용
if (environment.acceptsProfiles(Profiles.of("prod & monitoring"))) {
    // prod이면서 monitoring도 활성화된 경우
}

if (environment.acceptsProfiles(Profiles.of("dev | test"))) {
    // dev 또는 test 환경
}
```

```java
// Startup 시 프로파일 출력
@Component
public class ProfileLogger implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private Environment environment;

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        log.info("========================================");
        log.info("Active Profiles: {}", Arrays.toString(environment.getActiveProfiles()));
        log.info("Default Profiles: {}", Arrays.toString(environment.getDefaultProfiles()));
        log.info("========================================");
    }
}
```

---

## 면접 질문

### 초급 질문

**Q1: Spring Boot 프로파일이 무엇이고, 왜 사용하나요?**

**A**: Spring Boot 프로파일은 **환경별로 다른 설정을 적용**하기 위한 메커니즘입니다.

**사용 이유**:
- 개발/스테이징/운영 환경마다 데이터베이스, API 엔드포인트, 로그 레벨 등이 다름
- 하드코딩 대신 프로파일로 환경을 자동 구분
- 실수로 dev 설정으로 prod 배포하는 것을 방지

**예시**:
```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:h2:mem:devdb  # 개발: 인메모리 DB

# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-server:3306/db  # 운영: 실제 DB
```

**활성화 방법**:
```bash
java -jar app.jar --spring.profiles.active=prod
```

---

**Q2: 프로파일을 활성화하는 방법 3가지를 말해보세요.**

**A**:

**1. application.yml에서 기본 프로파일 지정**:
```yaml
spring:
  profiles:
    active: dev
```

**2. 명령행 인수**:
```bash
java -jar app.jar --spring.profiles.active=prod
```

**3. 환경 변수**:
```bash
export SPRING_PROFILES_ACTIVE=prod
java -jar app.jar
```

**추가 방법**:
- IDE 설정 (IntelliJ IDEA Run Configuration)
- 테스트: `@ActiveProfiles("test")`
- 여러 프로파일: `--spring.profiles.active=prod,monitoring`

---

### 중급 질문

**Q3: @Profile 어노테이션의 동작 원리와 표현식 사용법을 설명해보세요.**

**A**: `@Profile`은 **조건부로 빈을 등록**하는 어노테이션입니다. 내부적으로 `@Conditional`을 사용하여 활성 프로파일을 확인합니다.

**기본 사용**:
```java
@Component
@Profile("dev")
public class DevConfig { }  // dev 프로파일에서만 빈 등록

@Component
@Profile("prod")
public class ProdConfig { }  // prod 프로파일에서만 빈 등록
```

**표현식**:
```java
// NOT 연산자
@Profile("!prod")  // prod가 아닌 모든 환경

// AND 연산자
@Profile("prod & monitoring")  // prod이면서 monitoring도 활성화

// OR 연산자
@Profile("dev | test")  // dev 또는 test

// 복잡한 표현식
@Profile("(prod | staging) & monitoring")
```

**동작 원리**:
```java
// Spring 내부 동작
public class ProfileCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String[] activeProfiles = context.getEnvironment().getActiveProfiles();
        String profileExpression = metadata.get("value");

        // 표현식 평가
        return Profiles.of(profileExpression).matches(activeProfiles);
    }
}
```

---

**Q4: 프로파일 그룹(Profile Groups)의 개념과 실무 활용 방법을 설명해보세요.**

**A**: 프로파일 그룹은 **여러 프로파일을 하나로 묶어서 관리**하는 Spring Boot 2.4+ 기능입니다.

**문제 상황**:
```bash
# 운영 환경 실행 시 매번 여러 프로파일 입력 필요
java -jar app.jar --spring.profiles.active=prod,mysql,monitoring,security,cache
# 👎 길고 실수하기 쉬움
```

**프로파일 그룹 활용**:
```yaml
spring:
  profiles:
    group:
      production: [prod, mysql, monitoring, security, cache]
      local: [dev, h2, debug, mock-api]
      staging: [staging, mysql, monitoring]
```

```bash
# 하나의 프로파일로 여러 설정 활성화
java -jar app.jar --spring.profiles.active=production
# 👍 간결하고 실수 방지
```

**실무 활용**:
```yaml
spring:
  profiles:
    group:
      # 계층형 구조
      base: [common, logging]

      # 환경별
      local: [base, dev, h2, mock-external]
      dev-server: [base, dev, mysql, real-external, monitoring]
      production: [base, prod, mysql-cluster, real-external, monitoring, security, cache]
```

**장점**:
- ✅ 복잡한 프로파일 조합을 단순화
- ✅ 환경별 표준 설정 정의
- ✅ 실수로 필수 프로파일 누락 방지
- ✅ 팀 전체가 동일한 환경 설정 사용

---

**Q5: 운영 환경 배포 시 프로파일 관련 안전 장치를 어떻게 구현하나요?**

**A**: 다음과 같은 다층 안전 장치를 구현합니다.

**1. 기본 프로파일을 dev로 고정**:
```yaml
# application.yml
spring:
  profiles:
    active: dev  # 실수로 프로파일 없이 실행 시 dev 적용
```

**2. 운영 환경 검증 로직**:
```java
@Component
@Profile("prod")
public class ProductionSafetyGuard implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private Environment environment;

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        validateProductionConfig();
    }

    private void validateProductionConfig() {
        // 위험한 설정 체크
        if (environment.getProperty("spring.h2.console.enabled", Boolean.class, false)) {
            throw new IllegalStateException("❌ H2 Console must be disabled in production!");
        }

        String ddlAuto = environment.getProperty("spring.jpa.hibernate.ddl-auto", "none");
        if (ddlAuto.equals("create") || ddlAuto.equals("create-drop")) {
            throw new IllegalStateException("❌ DDL auto must be 'validate' in production!");
        }

        // 필수 환경 변수 체크
        requireEnv("DB_PASSWORD");
        requireEnv("API_KEY");

        log.warn("✅ Production configuration validated");
    }

    private void requireEnv(String key) {
        if (!environment.containsProperty(key)) {
            throw new IllegalStateException(
                String.format("❌ Required property '%s' is missing!", key)
            );
        }
    }
}
```

**3. 민감 정보는 환경 변수로만**:
```yaml
# application-prod.yml
spring:
  datasource:
    url: ${PROD_DB_URL}  # 환경 변수 필수
    username: ${PROD_DB_USERNAME}
    password: ${PROD_DB_PASSWORD}
# 하드코딩 절대 금지!
```

**4. Kubernetes 배포 검증**:
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:1.0.0
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "production"  # 명시적으로 지정
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
```

**5. CI/CD 파이프라인 체크**:
```yaml
# .gitlab-ci.yml
deploy-prod:
  stage: deploy
  script:
    - |
      # 프로파일 체크
      if [ "$SPRING_PROFILES_ACTIVE" != "production" ]; then
        echo "❌ Invalid profile for production deployment!"
        exit 1
      fi
    - kubectl apply -f k8s/production/
  only:
    - main
```

**결과**:
- ✅ 잘못된 프로파일로 운영 배포 불가
- ✅ 필수 환경 변수 누락 시 시작 실패
- ✅ 위험한 설정 자동 차단
- ✅ 다층 안전 장치로 휴먼 에러 방지

---

## 마치며

프로파일 관리는 **Spring Boot 애플리케이션의 환경별 설정 분리**를 위한 핵심 기능입니다.

**핵심 요약**:
1. ✅ **환경 분리**: dev/staging/prod 설정을 명확히 구분
2. ✅ **조건부 빈**: @Profile로 환경별 다른 구현체 자동 주입
3. ✅ **프로파일 그룹**: 복잡한 설정 조합을 단순화
4. ✅ **안전 장치**: 운영 환경 검증으로 실수 방지
5. ✅ **유연성**: 여러 프로파일 동시 활성화 가능

**실무 팁**:
- 기본 프로파일은 항상 `dev`로 설정
- 운영 설정은 환경 변수로만 관리 (코드에 노출 금지)
- 프로파일 그룹으로 표준 환경 정의
- 운영 환경 시작 시 안전 검증 로직 필수

**다음 단계**:
- Spring Cloud Config로 중앙 집중식 설정 관리
- Kubernetes ConfigMap/Secret 연동
- 동적 프로파일 전환 (런타임 설정 변경)

**축하합니다! Spring Boot 전체 과정(29-36장)을 완료했습니다!** 🎉