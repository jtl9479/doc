# 04장: 연산자

> **"연산자는 프로그램의 계산기, 논리의 심판"**
> **학습 목표**: 이 장을 완료하면 Java의 모든 연산자를 활용하여 계산, 비교, 논리 판단을 수행할 수 있습니다.

**⏱️ 예상 학습 시간**: 2-5시간
**난이도**: ⭐⭐☆☆☆ (2/5)

---

## 📚 목차
- [이 장에서 배울 내용](#-이-장에서-배울-내용)
- [왜 연산자가 중요한가](#-왜-연산자가-중요한가)
- [실생활 비유로 이해하기](#-실생활-비유로-이해하기)
- [연산자란 무엇인가](#-연산자란-무엇인가)
- [실습 1: 산술 연산자](#-실습-1-산술-연산자-----)
- [실습 2: 비교 연산자](#-실습-2-비교-연산자------)
- [실습 3: 논리 연산자](#-실습-3-논리-연산자---)
- [실습 4: 대입 연산자](#-실습-4-대입-연산자-------)
- [실습 5: 증감 연산자](#-실습-5-증감-연산자---)
- [실습 6: 삼항 연산자](#-실습-6-삼항-연산자--)
- [실습 7: 연산자 우선순위](#-실습-7-연산자-우선순위)
- [실무에서 자주 쓰는 연산 패턴](#-실무에서-자주-쓰는-연산-패턴)
- [주니어 개발자 실무 시나리오](#-주니어-개발자-실무-시나리오)
- [흔한 실수와 해결 방법](#️-흔한-실수와-해결-방법)
- [실전 프로젝트: 간단한 계산기](#️-실전-프로젝트-간단한-계산기)
- [FAQ (자주 묻는 질문)](#-faq-자주-묻는-질문)
- [면접 질문 리스트](#-면접-질문-리스트)
- [핵심 내용 정리](#-핵심-내용-정리)
- [다음 단계](#-다음-단계)

---

## 📚 이 장에서 배울 내용

이 장을 완료하면 다음을 할 수 있습니다:

- ✅ 산술 연산자로 사칙연산 수행 (+, -, *, /, %)
- ✅ 비교 연산자로 값 비교 (==, !=, >, <)
- ✅ 논리 연산자로 조건 결합 (&&, ||, !)
- ✅ 대입 연산자로 값 할당 (=, +=, -=)
- ✅ 증감 연산자 활용 (++, --)
- ✅ 삼항 연산자로 간단한 조건 처리
- ✅ 연산자 우선순위 이해
- ✅ 실무에서 자주 쓰는 연산 패턴 적용

**난이도**: ⭐⭐ (쉬움)
**예상 학습 시간**:
- 빠른 훑어보기: 30분
- 기본 학습: 2-3시간
- 심화 학습 + 실습: 4-5시간

---

## 🎯 왜 연산자가 중요한가?

### 실무 배경

```
😰 신입 개발자 C씨의 실수

// 할인가 계산
int price = 10000;
int discount = 10;
int finalPrice = price - discount;  // ❌ 9,990원?!

선배: "10% 할인인데 왜 10원만 빼?"
C씨: "아... price * discount / 100 해야 하는구나..."

수정:
int finalPrice = price - (price * discount / 100);  // ✅ 9,000원

💡 올바른 연산자 사용 = 정확한 계산!
```

**실제 사례:**
- 📊 마켓컬리: **할인가 계산 로직** 오류로 손실 발생 (2019)
- 📊 게임 업계: **데미지 계산식** 오류로 밸런스 붕괴
- 📊 배달앱: **배달비 계산** 연산자 우선순위 실수로 고객 불만

### 📊 수치로 보는 효과

**올바른 연산자 사용의 임팩트**

| 지표 | 잘못된 연산자 사용 | 올바른 연산자 사용 | 개선율 |
|------|-------------------|-------------------|--------|
| 계산 정확도 | 75% | 100% | **33%↑** |
| 버그 발생률 | 15건/월 | 2건/월 | **87%↓** |
| 코드 가독성 | 낮음 (3/10) | 높음 (9/10) | **200%↑** |
| 개발 속도 | 느림 (디버깅 많음) | 빠름 (한 번에 완성) | **50%↑** |
| 유지보수 시간 | 4시간/기능 | 1시간/기능 | **75%↓** |

**실제 비즈니스 영향:**
- 💰 할인 계산 오류 → 월 500만원 손실 → 수정 후 0원
- ⏰ 버그 수정 시간 → 주 20시간 → 주 3시간 (85% 감소)
- 😊 고객 불만 → 월 50건 → 월 5건 (90% 감소)

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 산술 연산자 = 계산기

```
🧮 계산기 버튼

+  더하기       →  10 + 5 = 15
-  빼기         →  10 - 5 = 5
*  곱하기       →  10 * 5 = 50
/  나누기       →  10 / 5 = 2
%  나머지       →  10 % 3 = 1 (10을 3으로 나눈 나머지)

💡 %는 특별! 시계처럼 순환하는 수 계산에 유용
   예: 시간 (25시 → 1시), 요일, 페이지 순환
```

### 비유 2: 비교 연산자 = 저울

```
⚖️ 무게 비교하기

A(10kg)  ==  B(10kg)  →  true  (같다)
A(10kg)  !=  B(20kg)  →  true  (다르다)
A(10kg)  >   B(5kg)   →  true  (A가 더 무겁다)
A(10kg)  <   B(20kg)  →  true  (A가 더 가볍다)
A(10kg)  >=  B(10kg)  →  true  (같거나 무겁다)
A(10kg)  <=  B(20kg)  →  true  (같거나 가볍다)

💡 결과는 항상 true 또는 false!
```

### 비유 3: 논리 연산자 = 문지기

```
🚪 입장 조건 확인

&&  AND (그리고)
   - 나이 >= 19 && 신분증 있음  →  둘 다 만족해야 입장
   - 하나라도 false면 전체 false

||  OR (또는)
   - VIP 회원 || 초대권 있음  →  하나만 만족하면 입장
   - 하나라도 true면 전체 true

!   NOT (부정)
   - !블랙리스트  →  블랙리스트가 아니면 입장
   - true를 false로, false를 true로 뒤집기

💡 조건을 결합해서 복잡한 규칙 만들기!
```

### 비유 4: 증감 연산자 = 엘리베이터 층수 버튼

```
🛗 엘리베이터 층수 변경

현재 층: 5층

++  (올라가기)
   - ++floor  →  먼저 한 층 올라가고 표시 (6층 표시)
   - floor++  →  현재 층 표시하고 나서 올라가기 (5층 표시, 실제는 6층)

--  (내려가기)
   - --floor  →  먼저 한 층 내려가고 표시 (4층 표시)
   - floor--  →  현재 층 표시하고 나서 내려가기 (5층 표시, 실제는 4층)

실생활 비유:
- 전위(++i): 버튼 누르자마자 층수 변경 후 안내
- 후위(i++): 현재 층 안내 후 이동

💡 단독으로 쓸 때는 결과 동일!
```

### 비유 5: 삼항 연산자 = 자동판매기 재고 확인

```
🥤 자동판매기 음료 제공

조건 ? 참일 때 : 거짓일 때

재고 확인:
(재고 > 0) ? "음료 제공" : "품절"

                조건
                 ↓
        ┌────────┴────────┐
       true             false
        ↓                 ↓
    "음료 제공"       "품절"

실생활 예시:
- 카드 잔액 >= 가격 ? "결제 완료" : "잔액 부족"
- 나이 >= 19 ? "성인" : "미성년자"
- 날씨 == "비" ? "우산 챙기기" : "그냥 가기"

💡 간단한 if-else를 한 줄로!
```

### 🎯 종합 비교표

```
┌──────────────┬────────────┬──────────────┬──────────────┐
│ 연산자 종류  │ 실생활 비유 │ 주요 기능    │ 결과 타입    │
├──────────────┼────────────┼──────────────┼──────────────┤
│ 산술 (+,-,*) │ 계산기     │ 숫자 계산    │ 숫자         │
│ 비교 (==,>)  │ 저울       │ 크기 비교    │ boolean      │
│ 논리 (&&,||) │ 문지기     │ 조건 결합    │ boolean      │
│ 증감 (++,--)  │ 엘리베이터 │ 1씩 증감     │ 숫자         │
│ 삼항 (?:)    │ 자판기     │ 조건 선택    │ 선택된 값    │
└──────────────┴────────────┴──────────────┴──────────────┘
```

---

## 📖 연산자란 무엇인가?

### 연산자의 정의

```java
// 연산자 = 값을 계산하거나 비교하는 기호

int result = 10 + 5;  // + 는 연산자
boolean isAdult = age >= 19;  // >= 는 연산자

// 피연산자 = 연산의 대상
10 + 5
↑   ↑
피연산자들
```

### 연산자 분류

```
Java 연산자 종류

1. 산술 연산자      +, -, *, /, %
2. 비교 연산자      ==, !=, >, <, >=, <=
3. 논리 연산자      &&, ||, !
4. 대입 연산자      =, +=, -=, *=, /=, %=
5. 증감 연산자      ++, --
6. 삼항 연산자      ? :
7. 비트 연산자      &, |, ^, ~, <<, >>
8. 기타            instanceof, (타입)
```

---

## 💻 실습 1: 산술 연산자 (+, -, *, /, %)

### 기본 사칙연산

```java
public class ArithmeticOperators {
    public static void main(String[] args) {
        int a = 10;
        int b = 3;

        // 덧셈 (+)
        int sum = a + b;
        System.out.println("10 + 3 = " + sum);  // 13

        // 뺄셈 (-)
        int diff = a - b;
        System.out.println("10 - 3 = " + diff);  // 7

        // 곱셈 (*)
        int product = a * b;
        System.out.println("10 * 3 = " + product);  // 30

        // 나눗셈 (/) - 몫
        int quotient = a / b;
        System.out.println("10 / 3 = " + quotient);  // 3 (소수점 버림!)

        // 나머지 (%)
        int remainder = a % b;
        System.out.println("10 % 3 = " + remainder);  // 1

        // ⚠️ 정수끼리 나누면 정수!
        System.out.println(10 / 3);  // 3 (not 3.333...)

        // ✅ 실수 나눗셈
        double result = 10.0 / 3.0;
        System.out.println("10.0 / 3.0 = " + result);  // 3.333...

        // ✅ 또는 캐스팅
        double result2 = (double) 10 / 3;
        System.out.println("(double) 10 / 3 = " + result2);  // 3.333...
    }
}
```

**출력:**
```
10 + 3 = 13
10 - 3 = 7
10 * 3 = 30
10 / 3 = 3
10 % 3 = 1
3
10.0 / 3.0 = 3.3333333333333335
(double) 10 / 3 = 3.3333333333333335
```

### 나머지 연산자(%) 활용

```java
public class ModuloOperator {
    public static void main(String[] args) {
        // 1. 짝수/홀수 판별
        int num = 7;
        if (num % 2 == 0) {
            System.out.println(num + "은 짝수");
        } else {
            System.out.println(num + "은 홀수");  // ✅ 출력
        }

        // 2. 배수 판별
        int number = 15;
        if (number % 5 == 0) {
            System.out.println(number + "은 5의 배수");  // ✅ 출력
        }

        // 3. 시간 계산 (60분 = 1시간)
        int totalMinutes = 135;
        int hours = totalMinutes / 60;     // 2시간
        int minutes = totalMinutes % 60;   // 15분
        System.out.println(totalMinutes + "분 = " +
                          hours + "시간 " + minutes + "분");

        // 4. 자릿수 추출
        int num2 = 1234;
        int lastDigit = num2 % 10;  // 4 (마지막 자리)
        System.out.println("마지막 자리: " + lastDigit);

        // 5. 순환 인덱스 (페이지네이션)
        int currentPage = 5;
        int totalPages = 3;
        int displayPage = currentPage % totalPages;  // 2 (0, 1, 2 순환)
        System.out.println("표시 페이지: " + displayPage);
    }
}
```

**출력:**
```
7은 홀수
15은 5의 배수
135분 = 2시간 15분
마지막 자리: 4
표시 페이지: 2
```

### 음수와 연산

```java
public class NegativeOperations {
    public static void main(String[] args) {
        int a = -10;
        int b = 3;

        System.out.println("a = " + a + ", b = " + b);
        System.out.println("a + b = " + (a + b));  // -7
        System.out.println("a - b = " + (a - b));  // -13
        System.out.println("a * b = " + (a * b));  // -30
        System.out.println("a / b = " + (a / b));  // -3
        System.out.println("a % b = " + (a % b));  // -1 (주의!)

        // ⚠️ % 연산 시 부호는 왼쪽 피연산자를 따름
        System.out.println("10 % 3 = " + (10 % 3));    // 1
        System.out.println("-10 % 3 = " + (-10 % 3));  // -1
        System.out.println("10 % -3 = " + (10 % -3));  // 1
        System.out.println("-10 % -3 = " + (-10 % -3)); // -1
    }
}
```

---

## 💻 실습 2: 비교 연산자 (==, !=, >, <, >=, <=)

### 기본 비교 연산

```java
public class ComparisonOperators {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = 10;

        // == (같다)
        System.out.println("a == b: " + (a == b));  // false
        System.out.println("a == c: " + (a == c));  // true

        // != (다르다)
        System.out.println("a != b: " + (a != b));  // true
        System.out.println("a != c: " + (a != c));  // false

        // > (크다)
        System.out.println("a > b: " + (a > b));    // false
        System.out.println("b > a: " + (b > a));    // true

        // < (작다)
        System.out.println("a < b: " + (a < b));    // true

        // >= (크거나 같다)
        System.out.println("a >= c: " + (a >= c));  // true

        // <= (작거나 같다)
        System.out.println("a <= b: " + (a <= b));  // true

        // 실무 예시: 성인 판별
        int age = 25;
        boolean isAdult = age >= 19;
        System.out.println("성인인가? " + isAdult);  // true

        // 범위 체크
        int score = 85;
        boolean isPassed = score >= 60;
        boolean isExcellent = score >= 90;
        System.out.println("합격? " + isPassed);     // true
        System.out.println("우수? " + isExcellent);  // false
    }
}
```

### String 비교 주의사항 ⚠️

```java
public class StringComparison {
    public static void main(String[] args) {
        // ⚠️ String은 == 말고 equals() 사용!

        String str1 = "Hello";
        String str2 = "Hello";
        String str3 = new String("Hello");

        // == : 주소(참조) 비교
        System.out.println("str1 == str2: " + (str1 == str2));    // true (같은 객체)
        System.out.println("str1 == str3: " + (str1 == str3));    // false (다른 객체!)

        // equals() : 내용 비교 ✅
        System.out.println("str1.equals(str2): " + str1.equals(str2));  // true
        System.out.println("str1.equals(str3): " + str1.equals(str3));  // true ✅

        // 실무 예시
        String userId = "admin";
        String inputId = "admin";

        // ❌ 잘못된 방법
        if (userId == inputId) {  // 위험! 때로 false
            System.out.println("로그인 성공 (위험)");
        }

        // ✅ 올바른 방법
        if (userId.equals(inputId)) {
            System.out.println("로그인 성공 (안전)");
        }

        // ✅ null 안전 비교
        String name = null;
        // if (name.equals("홍길동")) { ... }  // ❌ NullPointerException!

        if ("홍길동".equals(name)) {  // ✅ 안전 (null이어도 false)
            System.out.println("이름 일치");
        }
    }
}
```

---

## 💻 실습 3: 논리 연산자 (&&, ||, !)

### AND 연산자 (&&)

```java
public class LogicalAND {
    public static void main(String[] args) {
        // && : 모두 true일 때만 true

        int age = 25;
        boolean hasLicense = true;

        // 렌터카 대여 조건: 만 21세 이상 + 면허증 보유
        boolean canRent = (age >= 21) && hasLicense;
        System.out.println("렌터카 대여 가능? " + canRent);  // true

        // 예시 2: 할인 조건
        int purchaseAmount = 100000;
        boolean isMember = true;

        // 할인: 10만원 이상 구매 + 회원
        boolean getDiscount = (purchaseAmount >= 100000) && isMember;
        System.out.println("할인 가능? " + getDiscount);  // true

        // 예시 3: 범위 체크
        int score = 85;
        boolean isB = (score >= 80) && (score < 90);
        System.out.println("B학점인가? " + isB);  // true

        // 진리표
        System.out.println("\n=== AND 진리표 ===");
        System.out.println("true  && true  = " + (true && true));    // true
        System.out.println("true  && false = " + (true && false));   // false
        System.out.println("false && true  = " + (false && true));   // false
        System.out.println("false && false = " + (false && false));  // false
    }
}
```

### OR 연산자 (||)

```java
public class LogicalOR {
    public static void main(String[] args) {
        // || : 하나라도 true이면 true

        boolean isWeekend = true;
        boolean isHoliday = false;

        // 쉬는 날: 주말 또는 공휴일
        boolean isDayOff = isWeekend || isHoliday;
        System.out.println("쉬는 날인가? " + isDayOff);  // true

        // 예시 2: 무료 배송 조건
        int orderAmount = 25000;
        boolean isPremiumMember = false;

        // 무료 배송: 3만원 이상 또는 프리미엄 회원
        boolean freeShipping = (orderAmount >= 30000) || isPremiumMember;
        System.out.println("무료 배송? " + freeShipping);  // false

        // 예시 3: 로그인 방법
        boolean hasPassword = true;
        boolean hasBiometric = false;

        // 로그인: 비밀번호 또는 생체인증
        boolean canLogin = hasPassword || hasBiometric;
        System.out.println("로그인 가능? " + canLogin);  // true

        // 진리표
        System.out.println("\n=== OR 진리표 ===");
        System.out.println("true  || true  = " + (true || true));    // true
        System.out.println("true  || false = " + (true || false));   // true
        System.out.println("false || true  = " + (false || true));   // true
        System.out.println("false || false = " + (false || false));  // false
    }
}
```

### NOT 연산자 (!)

```java
public class LogicalNOT {
    public static void main(String[] args) {
        // ! : true ↔ false 반전

        boolean isRaining = true;
        boolean isSunny = !isRaining;  // false
        System.out.println("비 오는 중? " + isRaining);  // true
        System.out.println("맑음? " + isSunny);         // false

        // 예시 2: 상태 반전
        boolean isLoggedIn = false;
        if (!isLoggedIn) {  // 로그인 안 되어 있으면
            System.out.println("로그인이 필요합니다.");
        }

        // 예시 3: 조건 부정
        int age = 15;
        boolean isAdult = age >= 19;
        boolean isMinor = !isAdult;  // 미성년자
        System.out.println("미성년자? " + isMinor);  // true

        // 진리표
        System.out.println("\n=== NOT 진리표 ===");
        System.out.println("!true  = " + !true);   // false
        System.out.println("!false = " + !false);  // true

        // 이중 부정
        boolean flag = true;
        System.out.println("!!true = " + !!flag);  // true (원래대로)
    }
}
```

### 복합 논리 연산

```java
public class ComplexLogic {
    public static void main(String[] args) {
        // 복잡한 조건 결합

        int age = 25;
        boolean hasTicket = true;
        boolean isVIP = false;

        // 입장 조건: (만 19세 이상 + 티켓 보유) 또는 VIP
        boolean canEnter = ((age >= 19) && hasTicket) || isVIP;
        System.out.println("입장 가능? " + canEnter);  // true

        // 예시 2: 할인 계산
        int purchaseAmount = 150000;
        boolean isMember = true;
        boolean hasEventCoupon = false;

        // 할인: (회원 + 10만원 이상) 또는 이벤트 쿠폰
        boolean getDiscount = (isMember && (purchaseAmount >= 100000))
                              || hasEventCoupon;
        System.out.println("할인 받음? " + getDiscount);  // true

        // 예시 3: 점수 범위 (80~89점)
        int score = 85;
        boolean isB = (score >= 80) && (score <= 89);
        System.out.println("B학점? " + isB);  // true

        // ⚠️ 단락 평가 (Short-circuit evaluation)
        boolean result1 = false && (10 / 0 == 0);  // false (두 번째 안 봄)
        System.out.println("단락 평가 1: " + result1);

        boolean result2 = true || (10 / 0 == 0);   // true (두 번째 안 봄)
        System.out.println("단락 평가 2: " + result2);

        // 💡 왼쪽이 false면 && 오른쪽 실행 안 함
        //    왼쪽이 true면 || 오른쪽 실행 안 함
    }
}
```

---

## 💻 실습 4: 대입 연산자 (=, +=, -=, *=, /=, %=)

### 기본 대입 연산자 (=)

```java
public class AssignmentOperator {
    public static void main(String[] args) {
        // = : 오른쪽 값을 왼쪽 변수에 할당

        int a = 10;      // 10을 a에 할당
        int b = 20;
        int c = a + b;   // a + b의 결과를 c에 할당

        System.out.println("a = " + a);  // 10
        System.out.println("c = " + c);  // 30

        // 여러 변수에 같은 값 할당
        int x, y, z;
        x = y = z = 100;  // 오른쪽부터 실행
        System.out.println("x=" + x + ", y=" + y + ", z=" + z);

        // ⚠️ 주의: == (비교)와 = (대입) 구분!
        int age = 25;
        // if (age = 19) { ... }  // ❌ 컴파일 에러!
        if (age == 19) {          // ✅ 비교 연산자
            System.out.println("19세입니다");
        }
    }
}
```

### 복합 대입 연산자 (+=, -=, *=, /=, %=)

```java
public class CompoundAssignment {
    public static void main(String[] args) {
        // 복합 대입 연산자 = 연산 + 대입

        int num = 10;

        // += (더하기 후 할당)
        num += 5;  // num = num + 5;
        System.out.println("num += 5 → " + num);  // 15

        // -= (빼기 후 할당)
        num -= 3;  // num = num - 3;
        System.out.println("num -= 3 → " + num);  // 12

        // *= (곱하기 후 할당)
        num *= 2;  // num = num * 2;
        System.out.println("num *= 2 → " + num);  // 24

        // /= (나누기 후 할당)
        num /= 4;  // num = num / 4;
        System.out.println("num /= 4 → " + num);  // 6

        // %= (나머지 후 할당)
        num %= 4;  // num = num % 4;
        System.out.println("num %= 4 → " + num);  // 2

        System.out.println("\n=== 실무 예시 ===");

        // 점수 누적
        int totalScore = 0;
        totalScore += 85;  // 1번 시험
        totalScore += 90;  // 2번 시험
        totalScore += 78;  // 3번 시험
        System.out.println("총점: " + totalScore);  // 253

        // 재고 차감
        int stock = 100;
        stock -= 15;  // 15개 판매
        stock -= 20;  // 20개 판매
        System.out.println("남은 재고: " + stock);  // 65

        // 가격 인상
        int price = 10000;
        price *= 1.1;  // 10% 인상 (실수 연산)
        System.out.println("인상 가격: " + price);  // 11000
    }
}
```

---

## 💻 실습 5: 증감 연산자 (++, --)

### 전위/후위 증감 연산자

```java
public class IncrementDecrement {
    public static void main(String[] args) {
        // ++ : 1 증가
        // -- : 1 감소

        int a = 10;
        a++;  // a = a + 1; 와 동일
        System.out.println("a++ → " + a);  // 11

        int b = 10;
        b--;  // b = b - 1; 와 동일
        System.out.println("b-- → " + b);  // 9

        System.out.println("\n=== 전위 vs 후위 ===");

        // 전위 증가 (++a): 먼저 증가, 나중에 사용
        int x = 10;
        int y = ++x;  // x를 먼저 11로 증가, 그 값을 y에 할당
        System.out.println("++x: x=" + x + ", y=" + y);  // x=11, y=11

        // 후위 증가 (a++): 먼저 사용, 나중에 증가
        int p = 10;
        int q = p++;  // p의 현재 값(10)을 q에 할당, 그 후 p를 11로 증가
        System.out.println("p++: p=" + p + ", q=" + q);  // p=11, q=10

        System.out.println("\n=== 전위 감소 vs 후위 감소 ===");

        // 전위 감소
        int m = 10;
        int n = --m;  // m을 먼저 9로 감소, 그 값을 n에 할당
        System.out.println("--m: m=" + m + ", n=" + n);  // m=9, n=9

        // 후위 감소
        int s = 10;
        int t = s--;  // s의 현재 값(10)을 t에 할당, 그 후 s를 9로 감소
        System.out.println("s--: s=" + s + ", t=" + t);  // s=9, t=10

        System.out.println("\n=== 실무 활용 ===");

        // 반복문 카운터 (다음 장에서 자세히)
        int count = 0;
        count++;  // 1 증가
        count++;  // 1 증가
        count++;  // 1 증가
        System.out.println("카운트: " + count);  // 3

        // 재고 차감
        int stock = 100;
        stock--;  // 1개 판매
        System.out.println("재고: " + stock);  // 99
    }
}
```

### 증감 연산자 주의사항

```java
public class IncrementCaution {
    public static void main(String[] args) {
        // ⚠️ 한 줄에 여러 번 사용 금지 (가독성 나쁨)

        int a = 10;
        // int b = a++ + ++a;  // ❌ 헷갈림! 피하세요

        // ✅ 명확하게 분리
        int c = 10;
        c++;
        int d = c + c;
        System.out.println("명확한 코드: " + d);

        // ⚠️ 배열 인덱스에 주의
        int[] arr = {10, 20, 30};
        int i = 0;
        System.out.println(arr[i++]);  // 10 출력, 그 후 i=1
        System.out.println(arr[i]);    // 20 출력

        // 💡 실무에서는 단독으로 사용 권장
        int counter = 0;
        counter++;  // ✅ 명확함
        System.out.println("Counter: " + counter);
    }
}
```

---

## 💻 실습 6: 삼항 연산자 (? :)

### 기본 사용법

```java
public class TernaryOperator {
    public static void main(String[] args) {
        // 삼항 연산자: 조건 ? 참일 때 값 : 거짓일 때 값

        int age = 25;
        String result = (age >= 19) ? "성인" : "미성년자";
        System.out.println(result);  // "성인"

        // if-else와 비교
        String result2;
        if (age >= 19) {
            result2 = "성인";
        } else {
            result2 = "미성년자";
        }
        System.out.println(result2);  // "성인" (같은 결과)

        // 예시 2: 최댓값 구하기
        int a = 10;
        int b = 20;
        int max = (a > b) ? a : b;
        System.out.println("최댓값: " + max);  // 20

        // 예시 3: 절댓값
        int num = -5;
        int abs = (num >= 0) ? num : -num;
        System.out.println("절댓값: " + abs);  // 5

        // 예시 4: 할인가 계산
        int price = 50000;
        boolean isMember = true;
        int finalPrice = isMember ? (price * 90 / 100) : price;
        System.out.println("최종 가격: " + finalPrice);  // 45000

        // 예시 5: 학점 판정
        int score = 85;
        String grade = (score >= 90) ? "A" :
                       (score >= 80) ? "B" :
                       (score >= 70) ? "C" : "F";
        System.out.println("학점: " + grade);  // "B"
    }
}
```

### 중첩 삼항 연산자 (비추천)

```java
public class NestedTernary {
    public static void main(String[] args) {
        int score = 85;

        // ❌ 중첩 삼항: 읽기 어려움
        String grade = (score >= 90) ? "A" :
                       (score >= 80) ? "B" :
                       (score >= 70) ? "C" :
                       (score >= 60) ? "D" : "F";

        System.out.println("학점: " + grade);  // "B"

        // ✅ if-else가 더 명확
        String grade2;
        if (score >= 90) {
            grade2 = "A";
        } else if (score >= 80) {
            grade2 = "B";
        } else if (score >= 70) {
            grade2 = "C";
        } else if (score >= 60) {
            grade2 = "D";
        } else {
            grade2 = "F";
        }

        System.out.println("학점 (if-else): " + grade2);

        // 💡 가이드: 삼항 연산자는 간단한 조건에만 사용
        //    복잡하면 if-else 사용!
    }
}
```

---

## 💻 실습 7: 연산자 우선순위

### 우선순위 표

```
우선순위 (높음 → 낮음)

1순위: ()               괄호
2순위: ++, --           증감 연산자
3순위: !, +, -          부호, 논리 NOT
4순위: *, /, %          곱셈, 나눗셈, 나머지
5순위: +, -             덧셈, 뺄셈
6순위: <, <=, >, >=     비교 연산자
7순위: ==, !=           같음, 다름
8순위: &&               논리 AND
9순위: ||               논리 OR
10순위: ? :             삼항 연산자
11순위: =, +=, -=, ...  대입 연산자

💡 기억법: 수학 → 비교 → 논리 → 대입
```

### 우선순위 예시

```java
public class OperatorPrecedence {
    public static void main(String[] args) {
        // 예시 1: 산술 우선순위
        int result1 = 10 + 5 * 2;  // * 먼저 → 10 + 10 = 20
        System.out.println("10 + 5 * 2 = " + result1);  // 20

        int result2 = (10 + 5) * 2;  // () 최우선 → 15 * 2 = 30
        System.out.println("(10 + 5) * 2 = " + result2);  // 30

        // 예시 2: 비교와 논리
        int age = 25;
        boolean result3 = age >= 19 && age < 65;
        // 실행 순서: (age >= 19) && (age < 65)
        System.out.println("성인이면서 노인 아님: " + result3);  // true

        // 예시 3: 복합 연산
        int a = 10;
        int b = 5;
        int c = 3;
        int result4 = a + b * c;  // b * c 먼저 → 10 + 15 = 25
        System.out.println("10 + 5 * 3 = " + result4);  // 25

        // 예시 4: 대입이 마지막
        int x = 10;
        int y = x += 5;  // x = x + 5 먼저, 그 결과를 y에
        System.out.println("x=" + x + ", y=" + y);  // x=15, y=15

        // 예시 5: 헷갈리면 괄호!
        boolean result5 = (age >= 19) && ((b > c) || (a < b));
        System.out.println("복잡한 조건: " + result5);

        // 💡 권장사항: 헷갈리면 무조건 괄호 사용!
        //    가독성이 우선순위보다 중요!

        System.out.println("\n=== 실수하기 쉬운 예시 ===");

        // ❌ 의도: (a + b) / 2
        int avg1 = a + b / 2;  // b / 2 먼저 → 10 + 2 = 12 (잘못!)
        System.out.println("잘못된 평균: " + avg1);

        // ✅ 올바른 방법
        int avg2 = (a + b) / 2;  // (10 + 5) / 2 = 7 (올바름!)
        System.out.println("올바른 평균: " + avg2);
    }
}
```

---

## 🏢 실무에서 자주 쓰는 연산 패턴

### 패턴 1: 할인가 계산

```java
public class DiscountPattern {
    public static void main(String[] args) {
        int originalPrice = 50000;
        int discountRate = 20;  // 20%

        // ✅ 방법 1: 할인액 계산 후 빼기
        int discountAmount = originalPrice * discountRate / 100;
        int finalPrice1 = originalPrice - discountAmount;
        System.out.println("할인액: " + discountAmount);    // 10000
        System.out.println("최종 가격: " + finalPrice1);    // 40000

        // ✅ 방법 2: 한 번에 계산
        int finalPrice2 = originalPrice * (100 - discountRate) / 100;
        System.out.println("최종 가격 (방법2): " + finalPrice2);  // 40000

        // ⚠️ 실수 예시
        int wrong = originalPrice - discountRate;  // ❌ 49980 (10%가 아님!)
        System.out.println("잘못된 계산: " + wrong);

        // 실무: 부가세 포함 가격
        int priceExVAT = 10000;  // 부가세 제외
        double vat = 0.1;        // 10%
        int priceIncVAT = (int) (priceExVAT * (1 + vat));
        System.out.println("부가세 포함 가격: " + priceIncVAT);  // 11000
    }
}
```

### 패턴 2: 범위 체크

```java
public class RangeCheck {
    public static void main(String[] args) {
        int age = 25;

        // 패턴 1: 특정 범위 안에 있는지
        boolean isAdult = (age >= 19) && (age < 65);
        System.out.println("성인(19-64세)? " + isAdult);  // true

        // 패턴 2: 특정 범위 밖에 있는지
        boolean isSpecialAge = (age < 7) || (age >= 65);
        System.out.println("어린이 또는 노인? " + isSpecialAge);  // false

        // 실무: 점수 등급 판정
        int score = 85;
        String grade = (score >= 90) ? "A" :
                       (score >= 80) ? "B" :
                       (score >= 70) ? "C" :
                       (score >= 60) ? "D" : "F";
        System.out.println("학점: " + grade);  // "B"

        // 실무: 입력 유효성 검사
        int input = 105;
        boolean isValid = (input >= 0) && (input <= 100);
        if (!isValid) {
            System.out.println("⚠️ 0-100 사이 값을 입력하세요!");
        }
    }
}
```

### 패턴 3: 값 제한 (Clamp)

```java
public class ClampPattern {
    public static void main(String[] args) {
        // 값을 특정 범위로 제한

        int score = 105;  // 범위 초과
        int minScore = 0;
        int maxScore = 100;

        // 방법 1: if-else
        if (score < minScore) {
            score = minScore;
        } else if (score > maxScore) {
            score = maxScore;
        }
        System.out.println("제한된 점수 (if): " + score);  // 100

        // 방법 2: 삼항 연산자 (복잡함)
        int score2 = 105;
        score2 = (score2 < minScore) ? minScore :
                 (score2 > maxScore) ? maxScore : score2;
        System.out.println("제한된 점수 (삼항): " + score2);  // 100

        // 방법 3: Math 클래스 (권장)
        int score3 = 105;
        score3 = Math.max(minScore, Math.min(score3, maxScore));
        System.out.println("제한된 점수 (Math): " + score3);  // 100

        // 실무: 볼륨 조절
        int volume = 150;
        volume = Math.max(0, Math.min(volume, 100));  // 0~100으로 제한
        System.out.println("볼륨: " + volume);  // 100
    }
}
```

### 패턴 4: 짝수/홀수, 배수 판별

```java
public class DivisibilityPattern {
    public static void main(String[] args) {
        // 짝수/홀수
        int num = 7;
        boolean isEven = (num % 2 == 0);
        boolean isOdd = (num % 2 != 0);  // 또는 (num % 2 == 1)
        System.out.println(num + "은 짝수? " + isEven);  // false
        System.out.println(num + "은 홀수? " + isOdd);   // true

        // 3의 배수
        int num2 = 15;
        boolean isDivisibleBy3 = (num2 % 3 == 0);
        System.out.println(num2 + "는 3의 배수? " + isDivisibleBy3);  // true

        // 윤년 판정 (복잡한 조건)
        int year = 2024;
        boolean isLeapYear = (year % 4 == 0 && year % 100 != 0)
                             || (year % 400 == 0);
        System.out.println(year + "년은 윤년? " + isLeapYear);  // true

        // 실무: 페이지 순환
        int currentIndex = 5;
        int totalItems = 3;
        int displayIndex = currentIndex % totalItems;  // 0, 1, 2 순환
        System.out.println("표시 인덱스: " + displayIndex);  // 2
    }
}
```

---

## 👨‍💻 주니어 개발자 실무 시나리오

### 시나리오 1: 정수 나눗셈 실수

```java
😰 상황: 평균 점수 계산 오류

// ❌ 신입 개발자 코드
int korean = 85;
int english = 90;
int math = 78;

int total = korean + english + math;  // 253
int average = total / 3;  // 84 (253/3 = 84.333... 버림!)
System.out.println("평균: " + average);  // 84점

문제:
- 소수점이 사라짐
- 84.3점이 84점으로 표시
- 학생/학부모 불만

// ✅ 올바른 코드
double average = (double) total / 3;  // 84.333...
System.out.println("평균: " + average);

// 또는 반올림
int roundedAvg = (int) Math.round((double) total / 3);
System.out.println("반올림 평균: " + roundedAvg);  // 84점

💡 교훈: 정수끼리 나누면 정수! 실수가 필요하면 캐스팅!
```

### 시나리오 2: 연산자 우선순위 혼동

```java
😰 상황: 할인가 계산 오류

int price = 10000;
int discountRate = 10;

// ❌ 의도: 10% 할인 (9000원)
int finalPrice = price - price * discountRate / 100;
System.out.println(finalPrice);  // 9000 (운 좋게 맞음)

// ⚠️ 하지만 이렇게 쓰면?
int wrong = price - price * 10 / 100;  // 맞음
int wrong2 = price - discountRate;     // ❌ 9990원!

코드 리뷰:
선배: "이거 할인율 변수 안 쓰고 있잖아?"
나: "앗, price * discountRate / 100 해야 하는데..."

// ✅ 올바른 코드 (명확하게!)
int discountAmount = (price * discountRate) / 100;
int finalPrice = price - discountAmount;
System.out.println("할인액: " + discountAmount);  // 1000
System.out.println("최종가: " + finalPrice);      // 9000

💡 교훈: 헷갈리면 괄호 사용! 가독성이 우선!
```

### 시나리오 3: String 비교 실수

```java
😰 상황: 로그인 기능 버그

String userId = "admin";
String inputId = getUserInput();  // "admin" 입력

// ❌ 신입 개발자 코드
if (userId == inputId) {  // 때로 false!
    System.out.println("로그인 성공");
} else {
    System.out.println("로그인 실패");
}

문제:
- 로컬 테스트: 작동함
- 서버 배포: 작동 안 함!
- == 는 주소 비교 (내용 아님!)

선배: "String은 equals() 써야지!"

// ✅ 올바른 코드
if (userId.equals(inputId)) {  // 내용 비교
    System.out.println("로그인 성공");
}

// ✅ null 안전 버전
if ("admin".equals(inputId)) {  // inputId가 null이어도 OK
    System.out.println("로그인 성공");
}

💡 교훈: String은 항상 equals() 사용!
```

### 시나리오 4: 증감 연산자 위치 혼동

```java
😰 상황: 배열 인덱스 처리 중 버그 발생

int[] scores = {85, 90, 78, 92, 88};
int index = 0;

// ❌ 신입 개발자 코드
System.out.println("첫 번째 점수: " + scores[index++]);  // 85
System.out.println("현재 인덱스: " + index);  // 1

// 의도: 인덱스 먼저 증가 후 사용
// 실제: 현재 인덱스 사용 후 증가

문제 상황:
int i = 0;
int total = scores[i++] + scores[i++] + scores[i++];
System.out.println("합계: " + total);  // 85 + 90 + 78 = 253
System.out.println("i = " + i);  // 3

// 디버깅 시 헷갈림!
// "어? i가 왜 3이지? 2여야 하는데..."

// ✅ 올바른 코드 (명확하게!)
int total = 0;
int i = 0;
total += scores[i];
i++;
total += scores[i];
i++;
total += scores[i];
i++;
System.out.println("합계: " + total);  // 253
System.out.println("i = " + i);  // 3

// 또는 for 문 사용 (더 좋음)
int total = 0;
for (int i = 0; i < 3; i++) {
    total += scores[i];
}
System.out.println("합계: " + total);

선배의 코드 리뷰:
"증감 연산자는 복잡한 표현식에서 쓰지 마.
 단독으로 쓰거나 for문에서만 써!"

// ✅ 권장 패턴
for (int i = 0; i < scores.length; i++) {  // ✅ OK
    System.out.println(scores[i]);
}

// ❌ 비권장
System.out.println(scores[i++] + scores[i++]);  // 헷갈림!

💡 교훈:
- 증감 연산자는 단독으로 사용하기
- 복잡한 표현식에서는 피하기
- 가독성이 성능보다 중요!
```

---

## ⚠️ 흔한 실수와 해결 방법

### 실수 1: / 와 % 헷갈림

```java
// ❌ 혼동
int a = 10 / 3;  // 몫: 3
int b = 10 % 3;  // 나머지: 1

// 💡 기억법
// / : 나누기의 결과 (몫)
// % : 나누고 남은 것 (나머지)

// 활용
int totalMinutes = 135;
int hours = totalMinutes / 60;   // 2시간 (몫)
int minutes = totalMinutes % 60; // 15분 (나머지)
System.out.println(hours + "시간 " + minutes + "분");
```

### 실수 2: ++/-- 위치 혼동

```java
// 전위 vs 후위
int x = 10;
int y = ++x;  // x 먼저 11, y = 11
System.out.println("x=" + x + ", y=" + y);  // x=11, y=11

int p = 10;
int q = p++;  // q = 10 먼저, p 나중에 11
System.out.println("p=" + p + ", q=" + q);  // p=11, q=10

// 💡 실수 방지: 가능하면 단독 사용
x++;  // ✅ 명확
int y = x;  // ✅ 명확
```

### 실수 3: && vs & 혼동

```java
// && : 논리 AND (단락 평가)
boolean result1 = false && (10 / 0 == 0);  // ✅ false (에러 안 남)

// & : 비트 AND (둘 다 평가)
// boolean result2 = false & (10 / 0 == 0);  // ❌ ArithmeticException!

// 💡 논리 연산은 &&, || 사용!
//    비트 연산은 &, | 사용!
```

### 실수 4: 삼항 연산자 과용

```java
// ❌ 읽기 어려움
String result = (score >= 90) ? "A" :
                (score >= 80) ? "B" :
                (score >= 70) ? "C" : "F";

// ✅ if-else가 더 명확
String result2;
if (score >= 90) result2 = "A";
else if (score >= 80) result2 = "B";
else if (score >= 70) result2 = "C";
else result2 = "F";

// 💡 간단한 조건만 삼항 연산자 사용!
```

### 실수 5: Overflow 무시

```java
// ❌ Overflow
int big = Integer.MAX_VALUE;
int result = big + 1;  // -2147483648 (음수!)
System.out.println(result);

// ✅ long 사용
long bigLong = Integer.MAX_VALUE;
long result2 = bigLong + 1;  // 2147483648
System.out.println(result2);

// 💡 큰 수 계산은 long 사용!
```

---

## 🛠️ 실전 프로젝트: 간단한 계산기

### 프로젝트 목표

```
사칙연산 계산기 만들기
- 두 숫자 입력
- 사칙연산 (+, -, *, /) 수행
- 몫과 나머지 계산
- 결과 출력
```

### 구현 코드

```java
import java.util.Scanner;

public class SimpleCalculator {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("=".repeat(50));
        System.out.println("           간단한 계산기");
        System.out.println("=".repeat(50));
        System.out.println();

        // 첫 번째 숫자 입력
        System.out.print("첫 번째 숫자를 입력하세요: ");
        int num1 = scanner.nextInt();

        // 두 번째 숫자 입력
        System.out.print("두 번째 숫자를 입력하세요: ");
        int num2 = scanner.nextInt();

        System.out.println();
        System.out.println("=== 계산 결과 ===");

        // 덧셈
        int sum = num1 + num2;
        System.out.println(num1 + " + " + num2 + " = " + sum);

        // 뺄셈
        int diff = num1 - num2;
        System.out.println(num1 + " - " + num2 + " = " + diff);

        // 곱셈
        int product = num1 * num2;
        System.out.println(num1 + " * " + num2 + " = " + product);

        // 나눗셈
        if (num2 != 0) {
            // 정수 나눗셈 (몫)
            int quotient = num1 / num2;
            System.out.println(num1 + " / " + num2 + " = " + quotient + " (몫)");

            // 실수 나눗셈
            double result = (double) num1 / num2;
            System.out.printf("%d / %d = %.2f (실수)\n", num1, num2, result);

            // 나머지
            int remainder = num1 % num2;
            System.out.println(num1 + " % " + num2 + " = " + remainder + " (나머지)");
        } else {
            System.out.println("⚠️ 0으로 나눌 수 없습니다!");
        }

        System.out.println();

        // 비교 연산
        System.out.println("=== 비교 결과 ===");
        System.out.println(num1 + " == " + num2 + " : " + (num1 == num2));
        System.out.println(num1 + " != " + num2 + " : " + (num1 != num2));
        System.out.println(num1 + " > " + num2 + "  : " + (num1 > num2));
        System.out.println(num1 + " < " + num2 + "  : " + (num1 < num2));
        System.out.println(num1 + " >= " + num2 + " : " + (num1 >= num2));
        System.out.println(num1 + " <= " + num2 + " : " + (num1 <= num2));

        // 큰 수 찾기
        int max = (num1 > num2) ? num1 : num2;
        int min = (num1 < num2) ? num1 : num2;
        System.out.println();
        System.out.println("최댓값: " + max);
        System.out.println("최솟값: " + min);

        // 짝수/홀수 판별
        System.out.println();
        System.out.println("=== 추가 정보 ===");
        String num1Type = (num1 % 2 == 0) ? "짝수" : "홀수";
        String num2Type = (num2 % 2 == 0) ? "짝수" : "홀수";
        System.out.println(num1 + "은 " + num1Type);
        System.out.println(num2 + "은 " + num2Type);

        // 절댓값
        int abs1 = (num1 >= 0) ? num1 : -num1;
        int abs2 = (num2 >= 0) ? num2 : -num2;
        System.out.println(num1 + "의 절댓값: " + abs1);
        System.out.println(num2 + "의 절댓값: " + abs2);

        System.out.println();
        System.out.println("=".repeat(50));
        System.out.println("           계산 완료!");
        System.out.println("=".repeat(50));

        scanner.close();
    }
}
```

### 실행 결과 예시

```
==================================================
           간단한 계산기
==================================================

첫 번째 숫자를 입력하세요: 15
두 번째 숫자를 입력하세요: 4

=== 계산 결과 ===
15 + 4 = 19
15 - 4 = 11
15 * 4 = 60
15 / 4 = 3 (몫)
15 / 4 = 3.75 (실수)
15 % 4 = 3 (나머지)

=== 비교 결과 ===
15 == 4 : false
15 != 4 : true
15 > 4  : true
15 < 4  : false
15 >= 4 : true
15 <= 4 : false

최댓값: 15
최솟값: 4

=== 추가 정보 ===
15은 홀수
4은 짝수
15의 절댓값: 15
4의 절댓값: 4

==================================================
           계산 완료!
==================================================
```

### 도전 과제

```
💪 스스로 추가해보기

1. 연산자 선택 기능
   - 사용자가 +, -, *, / 중 선택
   - switch문 사용 (다음 장)

2. 제곱 연산 추가
   - num1의 num2 제곱 계산
   - Math.pow() 사용

3. 평균 계산
   - 두 수의 평균 출력

4. 반복 계산
   - 계속 계산할지 물어보기
   - while문 사용 (다음 장)

5. 고급 계산
   - 제곱근, 삼각함수 등
   - Math 클래스 활용
```

---

## ❓ FAQ (자주 묻는 질문)

### Q1. / 연산자와 % 연산자의 차이는?

```
A: / 는 몫, % 는 나머지

예시:
10 / 3  →  3 (몫)
10 % 3  →  1 (나머지)

10 ÷ 3 = 3 ... 1
        ↑     ↑
        /     %

실무 활용:

/ (나눗셈):
- 평균 계산: total / count
- 단위 변환: 분 / 60 → 시간
- 배분: 전체 / 인원

% (나머지):
- 짝수/홀수: num % 2
- 배수 판별: num % 5 == 0
- 순환 인덱스: index % size
- 시간 계산: 분 % 60
```

### Q2. ++i와 i++의 차이는 무엇인가요?

```
A: 증가 시점이 다름!

++i (전위 증가):
- 먼저 증가, 나중에 사용
int i = 10;
int j = ++i;  // i를 11로 먼저 증가, j = 11
// i=11, j=11

i++ (후위 증가):
- 먼저 사용, 나중에 증가
int i = 10;
int j = i++;  // j = 10 먼저, i를 11로 증가
// i=11, j=10

실무에서는?
대부분 단독으로 사용:
i++;  // 이것만 써도 충분
++i;  // 결과 동일

차이가 나는 경우:
// 배열
arr[i++]  // arr[i] 사용 후 i 증가
arr[++i]  // i 증가 후 arr[i] 사용

💡 권장: 가능하면 단독 사용!
```

### Q3. == 와 equals()의 차이는?

```
A: == 는 주소 비교, equals()는 내용 비교

기본 타입 (int, double 등):
== 사용 ✅
int a = 10;
int b = 10;
a == b  // true (값 비교)

참조 타입 (String, Object):
equals() 사용 ✅
String s1 = "Hello";
String s2 = "Hello";
s1 == s2        // true (운 좋게...)
s1.equals(s2)   // true (안전!)

String s3 = new String("Hello");
s1 == s3        // false! (다른 객체)
s1.equals(s3)   // true ✅ (내용 같음)

실무 규칙:
- 기본 타입: == 사용
- String: equals() 사용
- 객체: equals() 사용

null 안전:
// ❌ 위험
if (name.equals("홍길동")) { ... }  // name이 null이면 에러!

// ✅ 안전
if ("홍길동".equals(name)) { ... }  // null이어도 false
```

### Q4. &&와 || 중 어느 것이 먼저 계산되나요?

```
A: && 가 || 보다 우선순위 높음

우선순위:
! (NOT) > && (AND) > || (OR)

예시:
boolean result = true || false && false;
// false && false 먼저 → false
// true || false → true

명확하게:
boolean result = true || (false && false);

복잡한 조건:
if (age >= 19 && hasLicense || isVIP) { ... }
// (age >= 19 && hasLicense) || isVIP

// 명확하게 괄호 사용 권장
if ((age >= 19 && hasLicense) || isVIP) { ... }

💡 팁: 헷갈리면 무조건 괄호!
```

### Q5. 삼항 연산자는 언제 사용하나요?

```
A: 간단한 if-else를 한 줄로!

✅ 좋은 사용:
// 1. 간단한 값 할당
String status = (age >= 19) ? "성인" : "미성년자";

// 2. 최댓값/최솟값
int max = (a > b) ? a : b;

// 3. 절댓값
int abs = (num >= 0) ? num : -num;

❌ 나쁜 사용:
// 중첩 삼항 (읽기 어려움)
String grade = (score >= 90) ? "A" :
               (score >= 80) ? "B" :
               (score >= 70) ? "C" : "F";

// → if-else로 쓰는 게 나음

가이드라인:
- 조건 1개: 삼항 연산자 OK
- 조건 2개 이상: if-else 사용
- 복잡한 로직: if-else 사용

실무:
// JSX (React)에서 자주 사용
<div>{isLoggedIn ? <Profile /> : <Login />}</div>
```

### Q6. 나눗셈 시 0으로 나누면 어떻게 되나요?

```
A: 정수는 에러, 실수는 무한대!

정수 나눗셈:
int a = 10 / 0;  // ❌ ArithmeticException 발생!

// 예외 처리 필요
try {
    int result = num / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다!");
}

// 또는 미리 체크
if (divisor != 0) {
    int result = num / divisor;
} else {
    System.out.println("0으로 나눌 수 없습니다!");
}

실수 나눗셈:
double a = 10.0 / 0.0;    // Infinity (무한대)
double b = -10.0 / 0.0;   // -Infinity
double c = 0.0 / 0.0;     // NaN (Not a Number)

System.out.println(a);  // Infinity
System.out.println(c);  // NaN

// 체크 방법
if (Double.isInfinite(a)) { ... }
if (Double.isNaN(c)) { ... }

실무 권장:
// 나누기 전에 항상 체크!
if (divisor != 0) {
    result = dividend / divisor;
}
```

### Q7. 복합 대입 연산자는 언제 사용하나요?

```
A: 자기 자신을 연산할 때!

기본 대입:
x = x + 5;  // 긴 표현
x += 5;     // 짧은 표현 ✅

모든 산술 연산자:
x = x + 5;   →  x += 5;
x = x - 3;   →  x -= 3;
x = x * 2;   →  x *= 2;
x = x / 4;   →  x /= 4;
x = x % 3;   →  x %= 3;

실무 활용:

1. 점수 누적
totalScore += score;  // 짧고 명확

2. 재고 차감
stock -= soldQuantity;

3. 가격 인상
price *= 1.1;  // 10% 인상

4. 카운터
count += 1;  // 또는 count++

주의사항:
// 복잡한 계산은 풀어쓰기
x *= 2 + 3;  // x = x * (2 + 3)
// 헷갈리면 풀어쓰기!
```

---

## 💼 면접 질문 리스트

**실무 면접에서 자주 나오는 연산자 관련 질문들을 정리했습니다.**

### 📘 주니어/신입 개발자용 (5-7개)

**Q1. Java의 주요 연산자 종류를 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
Java 연산자 분류:

1. 산술 연산자: +, -, *, /, %
   - 사칙연산 및 나머지 계산

2. 비교 연산자: ==, !=, >, <, >=, <=
   - 두 값을 비교하여 boolean 반환

3. 논리 연산자: &&, ||, !
   - 조건을 결합하거나 부정

4. 대입 연산자: =, +=, -=, *=, /=, %=
   - 값을 변수에 할당

5. 증감 연산자: ++, --
   - 1 증가/감소

6. 삼항 연산자: ? :
   - 조건에 따라 값 선택

7. 비트 연산자: &, |, ^, ~, <<, >>
   - 비트 단위 연산

실무에서 가장 많이 사용:
- 산술: +, -, *, /, %
- 비교: ==, !=, >, <
- 논리: &&, ||, !
- 대입: =, +=, -=
```

꼬리 질문:
- % 연산자는 언제 사용하나?
- 비트 연산자는 언제 쓰나?
</details>

**Q2. ++i와 i++의 차이점을 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
전위 증가 (++i):
- 먼저 증가, 나중에 사용
- i를 1 증가시킨 후 그 값을 반환

int i = 10;
int j = ++i;
// i = 11, j = 11

후위 증가 (i++):
- 먼저 사용, 나중에 증가
- 현재 i 값을 반환한 후 i를 1 증가

int i = 10;
int j = i++;
// i = 11, j = 10

단독 사용 시:
i++;  // 증가만
++i;  // 증가만
// → 결과 동일!

실무 권장:
- 가능하면 단독으로 사용
- 복잡한 표현식에서는 피하기
- 명확성이 우선

성능 차이:
- 기본 타입: 차이 없음
- 객체: 후위가 약간 느릴 수 있음 (임시 객체 생성)
```

꼬리 질문:
- for문에서는 어느 것을 쓰나?
- --i와 i--도 같은 원리인가?
</details>

**Q3. 정수끼리 나눗셈을 할 때 주의할 점은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
주의사항 1: 소수점 버림
int a = 10;
int b = 3;
int result = a / b;  // 3 (not 3.333...)

// 소수점 필요하면 double 변환
double result = (double) a / b;  // 3.333...

주의사항 2: 0으로 나누기
int result = 10 / 0;  // ArithmeticException 발생!

// 예외 처리 필요
if (b != 0) {
    int result = a / b;
} else {
    System.out.println("0으로 나눌 수 없습니다!");
}

주의사항 3: Overflow
int big = Integer.MAX_VALUE / 2;
int result = big * 3;  // Overflow!

실무 패턴:

평균 계산:
double avg = (double) total / count;  // 실수로

정수 나눗셈 유지:
int quotient = total / count;  // 몫만

반올림:
int rounded = (int) Math.round((double) total / count);
```

꼬리 질문:
- % 연산자는?
- 실수 나눗셈의 주의점은?
</details>

**Q4. == 연산자와 equals() 메서드의 차이는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
== 연산자:
- 기본 타입: 값 비교
- 참조 타입: 주소(참조) 비교

int a = 10;
int b = 10;
a == b  // true (값 비교)

String s1 = "Hello";
String s2 = new String("Hello");
s1 == s2  // false! (다른 객체)

equals() 메서드:
- 객체의 내용 비교
- String, Object 등에서 사용

s1.equals(s2)  // true (내용 비교)

실무 규칙:

기본 타입 (int, double, boolean):
→ == 사용

String:
→ equals() 사용 (필수!)

객체:
→ equals() 사용 (오버라이드 필요)

null 안전:
// ❌ 위험
if (name.equals("홍길동")) { ... }

// ✅ 안전
if ("홍길동".equals(name)) { ... }

실수 사례:
String userId = getUserInput();
if (userId == "admin") { ... }  // ❌ 버그!
if (userId.equals("admin")) { ... }  // ✅
```

꼬리 질문:
- String Pool은 무엇인가?
- equals()를 오버라이드하는 이유는?
</details>

**Q5. 논리 연산자 &&와 ||의 단락 평가란?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
단락 평가 (Short-circuit evaluation):
- 결과가 확정되면 나머지 평가 안 함

&& (AND):
- 왼쪽이 false면 오른쪽 평가 안 함
- false && ... → 무조건 false

boolean result = false && (10 / 0 == 0);
// 10 / 0 실행 안 됨! (에러 안 남)

|| (OR):
- 왼쪽이 true면 오른쪽 평가 안 함
- true || ... → 무조건 true

boolean result = true || (10 / 0 == 0);
// 10 / 0 실행 안 됨!

실무 활용:

null 체크:
if (user != null && user.getAge() > 19) { ... }
// user가 null이면 user.getAge() 안 호출 (안전!)

조건 순서:
// ✅ 빠른 조건 먼저
if (isSimpleCheck() || isComplexCheck()) { ... }

성능:
- 비용 낮은 조건 → 먼저
- 비용 높은 조건 → 나중

vs 비단락 평가:
& : 둘 다 평가 (비트 연산)
| : 둘 다 평가 (비트 연산)
```

꼬리 질문:
- & 와 && 의 차이는?
- 실무에서 주의할 점은?
</details>

**Q6. 삼항 연산자는 언제 사용하는 것이 좋은가요?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
삼항 연산자 = 조건 ? 참 : 거짓

✅ 좋은 사용:

1. 간단한 값 할당
String type = (age >= 19) ? "성인" : "미성년자";

2. 최댓값/최솟값
int max = (a > b) ? a : b;

3. 기본값 설정
int value = (input != null) ? input : 0;

❌ 나쁜 사용:

1. 중첩 삼항 (가독성 저하)
String grade = (score >= 90) ? "A" :
               (score >= 80) ? "B" : "C";
// → if-else 사용 권장

2. 복잡한 로직
result = (a > b && c < d) ? (x + y) : (x - y);
// → if-else가 더 명확

가이드라인:
- 조건 1개: 삼항 OK
- 조건 2개 이상: if-else
- 간단명료: 삼항 OK
- 복잡: if-else

vs if-else:

삼항:
String status = isActive ? "ON" : "OFF";

if-else:
String status;
if (isActive) {
    status = "ON";
} else {
    status = "OFF";
}

실무 선택:
- 짧고 명확하면: 삼항
- 복잡하거나 길면: if-else
```

</details>

**Q7. 나머지 연산자(%)의 실무 활용 사례는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
% 연산자 = 나눈 나머지

실무 활용:

1. 짝수/홀수 판별
if (num % 2 == 0) {
    System.out.println("짝수");
}

2. 배수 판별
if (num % 5 == 0) {
    System.out.println("5의 배수");
}

3. 시간 변환
int totalMinutes = 135;
int hours = totalMinutes / 60;   // 2
int minutes = totalMinutes % 60; // 15
// "2시간 15분"

4. 순환 인덱스
int index = currentPage % totalPages;
// 0, 1, 2, 0, 1, 2, ... 반복

5. 자릿수 추출
int num = 1234;
int lastDigit = num % 10;  // 4

6. 캐러셀/슬라이더
int displayIndex = (currentIndex % itemCount + itemCount) % itemCount;
// 음수도 처리

7. 윤년 판정
boolean isLeap = (year % 4 == 0 && year % 100 != 0)
                 || (year % 400 == 0);

8. 체크섬 계산
int checksum = (sum % 10);

주의사항:
- 음수 나머지는 음수
  -10 % 3 = -1 (not 2)
- 0으로 나누기 금지
  10 % 0 → ArithmeticException
```

</details>

---

### 📗 중급 개발자용 (3-5개)

**Q1. 연산자 우선순위를 설명하고 실무에서 어떻게 처리하나요?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
연산자 우선순위 (높음 → 낮음):

1. ()           괄호
2. ++, --       증감
3. *, /, %      곱셈, 나눗셈
4. +, -         덧셈, 뺄셈
5. <, <=, >, >= 비교
6. ==, !=       같음, 다름
7. &&           논리 AND
8. ||           논리 OR
9. ? :          삼항
10. =, +=, ...  대입

예시:
int result = 10 + 5 * 2;
// 5 * 2 먼저 → 10 + 10 = 20

boolean check = age >= 19 && score > 60 || isVIP;
// (age >= 19 && score > 60) || isVIP

실무 처리 방법:

1. 괄호 사용 (최우선!)
int avg = (a + b) / 2;  // 명확!

2. 줄 분리
boolean condition1 = (age >= 19);
boolean condition2 = (score > 60);
boolean result = condition1 && condition2;

3. 복잡한 식 피하기
// ❌ 복잡
int x = a + b * c / d - e % f;

// ✅ 명확
int temp1 = b * c;
int temp2 = temp1 / d;
int temp3 = e % f;
int x = a + temp2 - temp3;

코드 리뷰 관점:
- 우선순위 외우기보다 명확성 우선
- 다른 개발자가 이해하기 쉽게
- 괄호는 성능에 영향 없음

실수 사례:
int discount = price - price * rate / 100;
// 의도: price - (price * rate / 100)
// 실제: (price) - (price * rate / 100) → 맞음 (운)
```

꼬리 질문:
- && 와 || 중 어느 것이 먼저?
- 괄호가 성능에 영향을 주나?
</details>

**Q2. 비트 연산자와 논리 연산자의 차이와 실무 활용을 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
논리 연산자 (&&, ||, !):
- boolean 타입에 사용
- 단락 평가 (short-circuit)
- 조건문에 주로 사용

boolean result = (a > 10) && (b < 20);

비트 연산자 (&, |, ^, ~):
- 정수 타입에 사용
- 비트 단위 연산
- 모든 피연산자 평가

int result = 5 & 3;  // 0101 & 0011 = 0001 (1)

주요 비트 연산자:

& (AND):  둘 다 1이면 1
| (OR):   하나라도 1이면 1
^ (XOR):  다르면 1
~ (NOT):  비트 반전
<< :      왼쪽 시프트 (2배)
>> :      오른쪽 시프트 (/2)

실무 활용:

1. 플래그 관리
final int READ = 1;    // 0001
final int WRITE = 2;   // 0010
final int EXECUTE = 4; // 0100

int permission = READ | WRITE;  // 0011
boolean canRead = (permission & READ) != 0;

2. 성능 최적화
int doubled = num << 1;  // num * 2 (빠름)
int halved = num >> 1;   // num / 2 (빠름)

3. 색상 처리 (RGB)
int color = 0xFF5733;
int red = (color >> 16) & 0xFF;
int green = (color >> 8) & 0xFF;
int blue = color & 0xFF;

4. XOR 스왑
a = a ^ b;
b = a ^ b;  // b = a
a = a ^ b;  // a = b

5. 암호화
int encrypted = data ^ key;
int decrypted = encrypted ^ key;  // 원복

주의사항:
// 논리 연산 → &&, || 사용
if (a > 10 && b < 20) { ... }

// 비트 연산 → &, | 사용
int flags = FLAG1 | FLAG2;
```

꼬리 질문:
- Enum과 비트 플래그 비교는?
- unsigned right shift (>>>)는?
</details>

**Q3. 복합 대입 연산자의 내부 동작과 타입 캐스팅을 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
복합 대입 연산자 = 연산 + 대입 + 자동 캐스팅

기본 동작:
a += b  →  a = a + b

특별한 점: 자동 타입 캐스팅!

byte b = 10;
b = b + 1;   // ❌ 컴파일 에러! (int로 변환됨)
b = (byte) (b + 1);  // ✅ 명시적 캐스팅 필요

byte b = 10;
b += 1;  // ✅ 자동 캐스팅! (내부적으로 b = (byte)(b + 1))

내부 구현:
a += b  →  a = (a의 타입) (a + b)

예시:
byte a = 100;
a += 200;  // a = (byte)(a + 200)
// 300은 byte 범위 초과 → overflow

short s = 10;
s *= 1.5;  // s = (short)(s * 1.5)
// 15.0 → 15 (캐스팅)

장점:
1. 간결함
2. 자동 캐스팅
3. 타이핑 오류 방지

단점:
1. 명시적이지 않음
2. overflow 가능

실무 권장:

일반적인 경우:
count += 1;  // ✅ 간결
total += score;  // ✅ 명확

타입 변환 주의:
long big = Integer.MAX_VALUE;
big += 1;  // ✅ OK (long)

byte small = 100;
small += 200;  // ⚠️ overflow! (44)

복잡한 경우:
// 명시적으로
value = value + (int) (value * 0.1);
// 복합 대입
value += (int) (value * 0.1);  // 헷갈릴 수 있음
```

꼬리 질문:
- *= 와 = * 의 차이는?
- 성능 차이가 있나?
</details>

**Q4. Overflow/Underflow 감지와 처리 방법을 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
Overflow = 범위 초과
Underflow = 범위 미만

발생 시나리오:

int max = Integer.MAX_VALUE;  // 2,147,483,647
int overflow = max + 1;       // -2,147,483,648 (순환!)

감지 방법:

1. Math 클래스 (Java 8+)
try {
    int result = Math.addExact(a, b);  // Overflow 시 예외
    int result = Math.multiplyExact(a, b);
} catch (ArithmeticException e) {
    System.out.println("Overflow 발생!");
}

2. 수동 체크
// 덧셈 overflow 체크
if (a > 0 && b > 0 && a > Integer.MAX_VALUE - b) {
    // overflow 발생
}

// 곱셈 overflow 체크
if (a > Integer.MAX_VALUE / b) {
    // overflow 발생
}

3. long 사용
long result = (long) a + b;
if (result > Integer.MAX_VALUE) {
    // overflow 발생
}

실무 처리:

1. 적절한 타입 선택
// ❌ int (overflow 가능)
int seconds = 86400 * 365;

// ✅ long 사용
long seconds = 86400L * 365;

2. BigInteger 사용
import java.math.BigInteger;

BigInteger big1 = new BigInteger("999999999999999999");
BigInteger big2 = new BigInteger("999999999999999999");
BigInteger sum = big1.add(big2);  // overflow 없음

3. 범위 제한
int score = Math.min(input, 100);  // 최대 100
int value = Math.max(0, Math.min(input, 100));  // 0~100

4. 검증 로직
public int safeAdd(int a, int b) {
    try {
        return Math.addExact(a, b);
    } catch (ArithmeticException e) {
        return (a > 0) ? Integer.MAX_VALUE : Integer.MIN_VALUE;
    }
}

실무 사례:

게임:
int score = Integer.MAX_VALUE;
score += 100;  // overflow! 음수됨
// → Math.addExact() 또는 long 사용

금융:
// BigDecimal 필수
BigDecimal balance = new BigDecimal("999999999.99");

시간 계산:
long milliseconds = System.currentTimeMillis();
// int 사용 시 2038년 문제 (Y2038)
```

꼬리 질문:
- unsigned int는 Java에 있나?
- Long.MAX_VALUE도 넘으면?
</details>

**Q5. 실무에서 연산자 사용 시 성능 최적화 팁은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
성능 최적화 팁:

1. 비트 시프트 활용
// 느림
int doubled = num * 2;
int halved = num / 2;

// 빠름 (비트 시프트)
int doubled = num << 1;  // * 2
int halved = num >> 1;   // / 2
int quad = num << 2;     // * 4

⚠️ 주의: 가독성 vs 성능 트레이드오프
현대 JVM은 자동 최적화 → 필요할 때만 사용

2. 단락 평가 활용
// 빠른 체크 먼저
if (cheapCheck() && expensiveCheck()) { ... }

// ❌ 느린 체크 먼저
if (expensiveCheck() && cheapCheck()) { ... }

3. 불필요한 연산 피하기
// ❌ 반복문 안에서 계산
for (int i = 0; i < arr.length; i++) {
    int temp = a * b;  // 매번 계산!
}

// ✅ 밖으로 이동
int temp = a * b;
for (int i = 0; i < arr.length; i++) {
    // temp 사용
}

4. 증감 연산자 위치
// C++에서는 차이 있음
for (int i = 0; i < n; i++)   // vs
for (int i = 0; i < n; ++i)

// Java에서는 차이 없음 (컴파일러 최적화)

5. 나눗셈 피하기
// 느림
int result = num / 100 * 100;

// 빠름
int result = num - (num % 100);

6. 조건 순서
// 확률 높은 조건 먼저
if (mostLikely || lessLikely) { ... }

7. Math vs 직접 계산
// 빠름
int abs = (num >= 0) ? num : -num;

// 느림 (함수 호출 오버헤드)
int abs = Math.abs(num);

실무 가이드:

1. 측정 우선
// 최적화 전에 프로파일링!
long start = System.nanoTime();
// 코드
long end = System.nanoTime();

2. 가독성 우선
// ❌ 최적화 과잉
int x = (a << 3) - (a << 1);  // a * 6

// ✅ 명확함
int x = a * 6;  // JIT가 알아서 최적화

3. 병목 지점만
// 전체 10% 시간 차지하는 코드만 최적화
// 나머지는 가독성 우선

4. JVM 신뢰
// 현대 JVM은 매우 똑똑함
// 대부분 자동 최적화됨

실제 병목:
- 연산자 < I/O
- 연산자 < 네트워크
- 연산자 < 데이터베이스

→ 연산자 최적화는 마지막!
```

</details>

---

## 📊 핵심 내용 정리

### 연산자 요약표

| 분류 | 연산자 | 설명 | 예시 |
|------|--------|------|------|
| **산술** | `+` | 덧셈 | `10 + 5` → `15` |
| | `-` | 뺄셈 | `10 - 5` → `5` |
| | `*` | 곱셈 | `10 * 5` → `50` |
| | `/` | 나눗셈 (몫) | `10 / 3` → `3` |
| | `%` | 나머지 | `10 % 3` → `1` |
| **비교** | `==` | 같음 | `10 == 10` → `true` |
| | `!=` | 다름 | `10 != 5` → `true` |
| | `>` | 크다 | `10 > 5` → `true` |
| | `<` | 작다 | `10 < 5` → `false` |
| | `>=` | 크거나 같다 | `10 >= 10` → `true` |
| | `<=` | 작거나 같다 | `5 <= 10` → `true` |
| **논리** | `&&` | AND | `true && false` → `false` |
| | `\|\|` | OR | `true \|\| false` → `true` |
| | `!` | NOT | `!true` → `false` |
| **대입** | `=` | 할당 | `a = 10` |
| | `+=` | 더하기 후 할당 | `a += 5` |
| | `-=` | 빼기 후 할당 | `a -= 3` |
| **증감** | `++` | 1 증가 | `a++`, `++a` |
| | `--` | 1 감소 | `a--`, `--a` |
| **삼항** | `? :` | 조건 연산 | `(a > b) ? a : b` |

### 필수 암기 사항

```
1. 정수 / 정수 = 정수 (소수점 버림!)
2. String은 equals() 사용
3. 논리 연산자는 단락 평가
4. % 는 나머지 (짝수/홀수 판별)
5. ++i (먼저 증가) vs i++ (나중에 증가)
6. 0으로 나누면 ArithmeticException
7. 삼항 연산자는 간단한 조건에만
8. 헷갈리면 괄호 사용!
```

### 필수 체크리스트

- [ ] 산술 연산자 활용 가능 (+, -, *, /, %)
- [ ] 정수 나눗셈의 소수점 버림 이해
- [ ] 비교 연산자로 조건 작성 가능
- [ ] String은 equals() 사용
- [ ] 논리 연산자 결합 가능 (&&, ||, !)
- [ ] 복합 대입 연산자 활용 (+=, -=)
- [ ] 증감 연산자 전위/후위 구분
- [ ] 삼항 연산자 간단히 사용 가능
- [ ] 연산자 우선순위 이해 (괄호 활용)
- [ ] 0으로 나누기 예외 처리

---

## 🔗 관련 기술 스택

```
연산자 완료!
    ↓
┌───────┼───────┬───────┐
│       │       │       │
조건문  반복문  배열   메서드
if,    for,   []     함수
switch while
```

**다음 장과의 연결:**
- 05장 조건문: 비교 연산자와 논리 연산자 활용 (if, switch)
- 06장 반복문: 증감 연산자 활용 (for, while)
- 08장 메서드: 연산 결과 반환

---

## 🎯 다음 단계

**다음 장 예고:**
- 📘 05장: 조건문 (if, switch)
- if-else 문
- 중첩 if문
- switch 문
- 조건문 실전 활용

**지금 당장 해볼 것:**
1. ✅ 계산기 프로그램 직접 작성
2. ✅ 짝수/홀수 판별 10번 연습
3. ✅ 삼항 연산자로 최댓값 찾기
4. ✅ 연산자 우선순위 헷갈리는 식 5개 괄호로 명확하게
5. ✅ String 비교 == vs equals() 실험

---

## 📚 추가 학습 자료

### 📖 공식 문서
- [Oracle Java Tutorial - Operators](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html)
- [Java Language Specification - Operators](https://docs.oracle.com/javase/specs/jls/se17/html/jls-15.html)

### 🎥 추천 영상
- [Java 연산자 완벽 정리](https://youtube.com)
- [실무에서 자주 실수하는 연산자](https://youtube.com)

### 📝 연습 문제
- [프로그래머스 - 연산자 문제](https://programmers.co.kr/)
- [백준 - 사칙연산](https://www.acmicpc.net/)

---

---

## 🎉 축하합니다!

**04장 연산자 학습을 완료하셨습니다!**

### 이제 여러분은:

✅ **산술 연산자**를 활용하여 복잡한 계산을 수행할 수 있습니다
✅ **비교 연산자**로 값을 비교하고 조건을 만들 수 있습니다
✅ **논리 연산자**로 여러 조건을 결합할 수 있습니다
✅ **대입 연산자**로 효율적으로 값을 할당할 수 있습니다
✅ **증감 연산자**의 전위/후위 차이를 이해하고 사용할 수 있습니다
✅ **삼항 연산자**로 간단한 조건을 한 줄로 처리할 수 있습니다
✅ **연산자 우선순위**를 이해하고 올바른 계산 순서를 보장할 수 있습니다
✅ **실무 패턴**을 적용하여 현업에서 바로 사용할 수 있습니다

### 학습 완료 체크리스트

**기본 개념**
- [ ] 산술 연산자 (+, -, *, /, %) 모두 사용 가능
- [ ] 정수 나눗셈 시 소수점 버림 이해
- [ ] 나머지 연산자(%)로 짝수/홀수 판별 가능
- [ ] 비교 연산자로 조건 작성 가능
- [ ] String 비교 시 equals() 사용

**중급 개념**
- [ ] 논리 연산자(&&, ||, !) 결합 가능
- [ ] 단락 평가(short-circuit) 이해
- [ ] 복합 대입 연산자(+=, -=) 활용
- [ ] 증감 연산자 전위/후위 구분
- [ ] 삼항 연산자 적절히 사용

**고급 개념**
- [ ] 연산자 우선순위 이해 (괄호 활용)
- [ ] 0으로 나누기 예외 처리
- [ ] Overflow/Underflow 이해
- [ ] 비트 연산자 기본 개념 이해
- [ ] 실무 패턴 3가지 이상 활용 가능

**실전 활용**
- [ ] 할인가 계산 로직 작성 가능
- [ ] 범위 체크 로직 작성 가능
- [ ] 입력 유효성 검사 구현 가능
- [ ] 간단한 계산기 프로그램 작성 완료
- [ ] 주니어 개발자 실수 사례 이해

### 다음 단계

**복습 권장 사항**
- 🔄 실전 프로젝트(계산기)를 한 번 더 직접 작성해보기
- 🔄 면접 질문 답변을 소리내어 연습하기
- 🔄 FAQ 내용을 다시 한 번 읽어보기
- 🔄 주니어 시나리오의 실수를 스스로 고쳐보기

**추가 연습 과제**
1. ✏️ BMI 계산기 만들기 (체중 / 키^2)
2. ✏️ 환율 계산기 만들기
3. ✏️ 시간 변환 프로그램 (초 → 시:분:초)
4. ✏️ 윤년 판별 프로그램
5. ✏️ 성적 등급 계산 프로그램

**학습 성과**
- 📖 배운 개념: 8가지 연산자 타입
- 💻 작성한 코드: 30+ 예제
- 🎯 실무 패턴: 4가지
- 👨‍💻 시나리오: 4가지
- 💼 면접 질문: 12개 (주니어 7개 + 중급 5개)

---

**이제 다음 장으로 이동하세요!**

**다음 장 예고: 05장 조건문**
- if-else 문으로 프로그램 분기
- switch 문으로 다중 선택
- 중첩 조건문 활용
- 이번 장에서 배운 비교/논리 연산자가 핵심!

**연결 관계**
```
04장 연산자
    ↓
비교 연산자 (==, >, <)
논리 연산자 (&&, ||, !)
    ↓
05장 조건문 (if, switch)
    ↓
프로그램 흐름 제어!
```

---

**🎉 정말 수고하셨습니다!**
**연산자는 모든 프로그래밍의 기초입니다. 잘 익혀두면 평생 써먹습니다!**

---

[← 이전: 03장 변수와 자료형](03-변수와-자료형.md) | [📋 목차로](README.md) | [다음: 05장 조건문 →](05-조건문.md)
