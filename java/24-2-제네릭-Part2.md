# 24장 제네릭 Part 2 - 기업 사례 & 주니어 시나리오 💼

## 🏢 실제 기업 사례로 배우는 제네릭

---

## 사례 1: 네이버 - API Response Wrapper 패턴 🟢

### 배경
네이버 검색 API는 성공, 실패, 부분 성공 등 다양한 응답 타입을 반환해야 합니다. 모든 API가 일관된 응답 구조를 갖도록 제네릭 Response Wrapper를 설계했습니다.

### 문제 상황
```java
// ❌ 제네릭 없이: API마다 다른 Response 클래스
class SearchResponse {
    private boolean success;
    private List<SearchResult> data;
    private String errorMessage;
    // ... 수십 개의 API마다 비슷한 클래스 반복
}

class UserResponse {
    private boolean success;
    private User data;
    private String errorMessage;
    // 중복 코드!
}
```

### 해결 방법: 제네릭 Response Wrapper

```java
import java.time.LocalDateTime;
import java.util.*;

// 제네릭 API Response Wrapper
class ApiResponse<T> {
    private final boolean success;
    private final T data;
    private final String errorMessage;
    private final String errorCode;
    private final LocalDateTime timestamp;

    // Private 생성자 - Builder 패턴 사용
    private ApiResponse(boolean success, T data, String errorMessage, String errorCode) {
        this.success = success;
        this.data = data;
        this.errorMessage = errorMessage;
        this.errorCode = errorCode;
        this.timestamp = LocalDateTime.now();
    }

    // 성공 응답 생성
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null, null);
    }

    // 실패 응답 생성
    public static <T> ApiResponse<T> fail(String errorCode, String errorMessage) {
        return new ApiResponse<>(false, null, errorMessage, errorCode);
    }

    // 데이터 없는 성공 응답
    public static ApiResponse<Void> successNoContent() {
        return new ApiResponse<>(true, null, null, null);
    }

    // Getter들
    public boolean isSuccess() { return success; }
    public T getData() { return data; }
    public String getErrorMessage() { return errorMessage; }
    public String getErrorCode() { return errorCode; }
    public LocalDateTime getTimestamp() { return timestamp; }

    @Override
    public String toString() {
        if (success) {
            return "✅ 성공 [" + timestamp + "] - 데이터: " + data;
        } else {
            return "❌ 실패 [" + errorCode + "] - " + errorMessage;
        }
    }
}

// 도메인 모델들
class SearchResult {
    private String title;
    private String url;
    private int rank;

    public SearchResult(String title, String url, int rank) {
        this.title = title;
        this.url = url;
        this.rank = rank;
    }

    @Override
    public String toString() {
        return rank + ". " + title + " (" + url + ")";
    }
}

class User {
    private String userId;
    private String name;
    private String email;

    public User(String userId, String name, String email) {
        this.userId = userId;
        this.name = name;
        this.email = email;
    }

    @Override
    public String toString() {
        return name + " (" + email + ")";
    }
}

class BlogPost {
    private String title;
    private String author;
    private int likes;

    public BlogPost(String title, String author, int likes) {
        this.title = title;
        this.author = author;
        this.likes = likes;
    }

    @Override
    public String toString() {
        return title + " by " + author + " [❤️ " + likes + "]";
    }
}

// 네이버 API 서비스 시뮬레이션
class NaverApiService {

    // 검색 API - List<SearchResult> 반환
    public ApiResponse<List<SearchResult>> search(String keyword) {
        System.out.println("🔍 검색 API 호출: " + keyword);

        if (keyword == null || keyword.trim().isEmpty()) {
            return ApiResponse.fail("INVALID_PARAM", "검색어가 비어있습니다");
        }

        try {
            // 실제로는 외부 API 호출
            List<SearchResult> results = Arrays.asList(
                new SearchResult("네이버 " + keyword + " 공식 문서", "https://naver.com/1", 1),
                new SearchResult(keyword + " 완벽 가이드", "https://blog.naver.com/2", 2),
                new SearchResult(keyword + " 최신 트렌드", "https://news.naver.com/3", 3)
            );

            return ApiResponse.success(results);

        } catch (Exception e) {
            return ApiResponse.fail("SEARCH_ERROR", "검색 중 오류 발생: " + e.getMessage());
        }
    }

    // 사용자 정보 API - User 반환
    public ApiResponse<User> getUserInfo(String userId) {
        System.out.println("👤 사용자 정보 API 호출: " + userId);

        if (userId.equals("unknown")) {
            return ApiResponse.fail("USER_NOT_FOUND", "사용자를 찾을 수 없습니다");
        }

        User user = new User(userId, "김네이버", "naver@naver.com");
        return ApiResponse.success(user);
    }

    // 블로그 포스트 API - BlogPost 반환
    public ApiResponse<BlogPost> getBlogPost(int postId) {
        System.out.println("📝 블로그 포스트 API 호출: " + postId);

        if (postId <= 0) {
            return ApiResponse.fail("INVALID_POST_ID", "유효하지 않은 포스트 ID입니다");
        }

        BlogPost post = new BlogPost("제네릭 완벽 가이드", "네이버 개발자", 1523);
        return ApiResponse.success(post);
    }

    // 데이터 삭제 API - Void 반환
    public ApiResponse<Void> deletePost(int postId) {
        System.out.println("🗑️ 포스트 삭제 API 호출: " + postId);

        if (postId <= 0) {
            return ApiResponse.fail("INVALID_POST_ID", "유효하지 않은 포스트 ID입니다");
        }

        // 삭제 로직...
        return ApiResponse.successNoContent();
    }
}

// API 클라이언트
public class NaverApiExample {
    public static void main(String[] args) {
        NaverApiService api = new NaverApiService();

        System.out.println("=== 네이버 API Response Wrapper 패턴 ===\n");

        // 1. 검색 API - List<SearchResult>
        ApiResponse<List<SearchResult>> searchResponse = api.search("Java 제네릭");
        System.out.println(searchResponse);

        if (searchResponse.isSuccess()) {
            System.out.println("검색 결과:");
            for (SearchResult result : searchResponse.getData()) {
                System.out.println("   " + result);
            }
        }
        System.out.println();

        // 2. 사용자 정보 API - User
        ApiResponse<User> userResponse = api.getUserInfo("user123");
        System.out.println(userResponse);
        if (userResponse.isSuccess()) {
            System.out.println("사용자: " + userResponse.getData());
        }
        System.out.println();

        // 3. 블로그 포스트 API - BlogPost
        ApiResponse<BlogPost> postResponse = api.getBlogPost(100);
        System.out.println(postResponse);
        if (postResponse.isSuccess()) {
            System.out.println("포스트: " + postResponse.getData());
        }
        System.out.println();

        // 4. 실패 케이스 - 유효하지 않은 검색
        ApiResponse<List<SearchResult>> failedSearch = api.search("");
        System.out.println(failedSearch);
        System.out.println("에러 코드: " + failedSearch.getErrorCode());
        System.out.println();

        // 5. 실패 케이스 - 존재하지 않는 사용자
        ApiResponse<User> notFoundUser = api.getUserInfo("unknown");
        System.out.println(notFoundUser);
        System.out.println();

        // 6. Void 응답 - 삭제 API
        ApiResponse<Void> deleteResponse = api.deletePost(200);
        System.out.println(deleteResponse);
        System.out.println("삭제 성공 여부: " + deleteResponse.isSuccess());

        System.out.println("\n✅ 제네릭 Wrapper의 장점:");
        System.out.println("1. 일관된 API 응답 구조");
        System.out.println("2. 타입 안전성: 각 API가 반환하는 데이터 타입 명확");
        System.out.println("3. 코드 재사용: 하나의 클래스로 모든 API 커버");
        System.out.println("4. 에러 처리 통일: success, errorCode, errorMessage 표준화");
    }
}
```

### 실행 결과
```
=== 네이버 API Response Wrapper 패턴 ===

🔍 검색 API 호출: Java 제네릭
✅ 성공 [2025-10-10T...] - 데이터: [1. 네이버 Java 제네릭 공식 문서 (...), ...]
검색 결과:
   1. 네이버 Java 제네릭 공식 문서 (https://naver.com/1)
   2. Java 제네릭 완벽 가이드 (https://blog.naver.com/2)
   3. Java 제네릭 최신 트렌드 (https://news.naver.com/3)

👤 사용자 정보 API 호출: user123
✅ 성공 [2025-10-10T...] - 데이터: 김네이버 (naver@naver.com)
사용자: 김네이버 (naver@naver.com)

📝 블로그 포스트 API 호출: 100
✅ 성공 [2025-10-10T...] - 데이터: 제네릭 완벽 가이드 by 네이버 개발자 [❤️ 1523]
포스트: 제네릭 완벽 가이드 by 네이버 개발자 [❤️ 1523]

🔍 검색 API 호출:
❌ 실패 [INVALID_PARAM] - 검색어가 비어있습니다
에러 코드: INVALID_PARAM

👤 사용자 정보 API 호출: unknown
❌ 실패 [USER_NOT_FOUND] - 사용자를 찾을 수 없습니다

🗑️ 포스트 삭제 API 호출: 200
✅ 성공 [2025-10-10T...] - 데이터: null
삭제 성공 여부: true

✅ 제네릭 Wrapper의 장점:
1. 일관된 API 응답 구조
2. 타입 안전성: 각 API가 반환하는 데이터 타입 명확
3. 코드 재사용: 하나의 클래스로 모든 API 커버
4. 에러 처리 통일: success, errorCode, errorMessage 표준화
```

### 핵심 교훈
- **제네릭 정적 팩토리 메서드**: `ApiResponse.success(data)` 패턴
- **타입 추론**: `<T>` 명시 없이도 컴파일러가 자동 추론
- **Void 타입**: 데이터가 없는 성공 응답에 사용
- **실무 적용**: Spring RestController에서 ResponseEntity 대신 사용 가능

---

## 사례 2: 카카오 - 제네릭 DAO 패턴 💬

### 배경
카카오톡 서버는 사용자, 메시지, 채팅방 등 수십 개의 테이블을 관리합니다. 각 테이블마다 CRUD 코드를 중복 작성하는 대신, 제네릭 DAO(Data Access Object)를 구현했습니다.

### 문제 상황
```java
// ❌ 제네릭 없이: 각 엔티티마다 DAO 클래스 중복
class UserDao {
    public User findById(Long id) { /* JDBC 코드 */ }
    public void save(User user) { /* JDBC 코드 */ }
    public void delete(Long id) { /* JDBC 코드 */ }
}

class MessageDao {
    public Message findById(Long id) { /* 거의 동일한 JDBC 코드 */ }
    public void save(Message message) { /* 거의 동일한 JDBC 코드 */ }
    public void delete(Long id) { /* 거의 동일한 JDBC 코드 */ }
}
// ... 수십 개의 DAO 클래스 반복
```

### 해결 방법: 제네릭 Base DAO

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

// 모든 엔티티가 구현해야 하는 인터페이스
interface Entity {
    Long getId();
    void setId(Long id);
}

// 엔티티 클래스들
class KakaoUser implements Entity {
    private Long id;
    private String nickname;
    private String phoneNumber;

    public KakaoUser(Long id, String nickname, String phoneNumber) {
        this.id = id;
        this.nickname = nickname;
        this.phoneNumber = phoneNumber;
    }

    @Override public Long getId() { return id; }
    @Override public void setId(Long id) { this.id = id; }

    public String getNickname() { return nickname; }
    public String getPhoneNumber() { return phoneNumber; }

    @Override
    public String toString() {
        return "User[" + id + "] " + nickname + " (" + phoneNumber + ")";
    }
}

class ChatRoom implements Entity {
    private Long id;
    private String roomName;
    private int memberCount;

    public ChatRoom(Long id, String roomName, int memberCount) {
        this.id = id;
        this.roomName = roomName;
        this.memberCount = memberCount;
    }

    @Override public Long getId() { return id; }
    @Override public void setId(Long id) { this.id = id; }

    public String getRoomName() { return roomName; }
    public int getMemberCount() { return memberCount; }

    @Override
    public String toString() {
        return "Room[" + id + "] " + roomName + " (" + memberCount + "명)";
    }
}

class Message implements Entity {
    private Long id;
    private Long roomId;
    private String senderName;
    private String content;

    public Message(Long id, Long roomId, String senderName, String content) {
        this.id = id;
        this.roomId = roomId;
        this.senderName = senderName;
        this.content = content;
    }

    @Override public Long getId() { return id; }
    @Override public void setId(Long id) { this.id = id; }

    public Long getRoomId() { return roomId; }
    public String getSenderName() { return senderName; }
    public String getContent() { return content; }

    @Override
    public String toString() {
        return "Msg[" + id + "] " + senderName + ": " + content;
    }
}

// 제네릭 Base DAO - 모든 엔티티에 공통 적용
abstract class BaseDao<T extends Entity> {
    // 실제로는 DB 연결, 여기서는 메모리로 시뮬레이션
    protected final Map<Long, T> storage = new ConcurrentHashMap<>();
    private long nextId = 1L;

    protected abstract String getTableName();

    // Create
    public T save(T entity) {
        if (entity.getId() == null) {
            entity.setId(nextId++);
            System.out.println("💾 INSERT into " + getTableName() + ": " + entity);
        } else {
            System.out.println("🔄 UPDATE " + getTableName() + ": " + entity);
        }
        storage.put(entity.getId(), entity);
        return entity;
    }

    // Read
    public Optional<T> findById(Long id) {
        System.out.println("🔍 SELECT from " + getTableName() + " WHERE id=" + id);
        return Optional.ofNullable(storage.get(id));
    }

    // Read All
    public List<T> findAll() {
        System.out.println("📋 SELECT * from " + getTableName());
        return new ArrayList<>(storage.values());
    }

    // Delete
    public boolean delete(Long id) {
        System.out.println("🗑️ DELETE from " + getTableName() + " WHERE id=" + id);
        return storage.remove(id) != null;
    }

    // Count
    public int count() {
        return storage.size();
    }
}

// 구체적인 DAO 구현 - 제네릭 상속
class UserDao extends BaseDao<KakaoUser> {
    @Override
    protected String getTableName() {
        return "kakao_users";
    }

    // User 전용 쿼리 메서드
    public Optional<KakaoUser> findByPhoneNumber(String phoneNumber) {
        System.out.println("🔍 SELECT from " + getTableName() +
                         " WHERE phone_number='" + phoneNumber + "'");
        return storage.values().stream()
                     .filter(user -> user.getPhoneNumber().equals(phoneNumber))
                     .findFirst();
    }
}

class ChatRoomDao extends BaseDao<ChatRoom> {
    @Override
    protected String getTableName() {
        return "chat_rooms";
    }

    // ChatRoom 전용 쿼리 메서드
    public List<ChatRoom> findLargeRooms(int minMembers) {
        System.out.println("🔍 SELECT from " + getTableName() +
                         " WHERE member_count >= " + minMembers);
        return storage.values().stream()
                     .filter(room -> room.getMemberCount() >= minMembers)
                     .collect(Collectors.toList());
    }
}

class MessageDao extends BaseDao<Message> {
    @Override
    protected String getTableName() {
        return "messages";
    }

    // Message 전용 쿼리 메서드
    public List<Message> findByRoomId(Long roomId) {
        System.out.println("🔍 SELECT from " + getTableName() +
                         " WHERE room_id=" + roomId);
        return storage.values().stream()
                     .filter(msg -> msg.getRoomId().equals(roomId))
                     .collect(Collectors.toList());
    }
}

public class KakaoDaoExample {
    public static void main(String[] args) {
        System.out.println("=== 카카오 제네릭 DAO 패턴 ===\n");

        UserDao userDao = new UserDao();
        ChatRoomDao roomDao = new ChatRoomDao();
        MessageDao messageDao = new MessageDao();

        // 1. 사용자 저장
        System.out.println("--- 사용자 관리 ---");
        KakaoUser user1 = userDao.save(new KakaoUser(null, "김카카오", "010-1234-5678"));
        KakaoUser user2 = userDao.save(new KakaoUser(null, "이톡톡", "010-8765-4321"));
        System.out.println();

        // 2. 사용자 조회
        Optional<KakaoUser> foundUser = userDao.findById(1L);
        foundUser.ifPresent(user -> System.out.println("조회 결과: " + user));
        System.out.println();

        // 3. 전화번호로 검색 (UserDao 전용 메서드)
        Optional<KakaoUser> userByPhone = userDao.findByPhoneNumber("010-1234-5678");
        userByPhone.ifPresent(user -> System.out.println("전화번호 검색: " + user));
        System.out.println();

        // 4. 채팅방 저장
        System.out.println("--- 채팅방 관리 ---");
        ChatRoom room1 = roomDao.save(new ChatRoom(null, "자바 스터디", 12));
        ChatRoom room2 = roomDao.save(new ChatRoom(null, "점심 메뉴", 5));
        ChatRoom room3 = roomDao.save(new ChatRoom(null, "전사 공지", 150));
        System.out.println();

        // 5. 대규모 채팅방 검색 (ChatRoomDao 전용 메서드)
        List<ChatRoom> largeRooms = roomDao.findLargeRooms(10);
        System.out.println("10명 이상 채팅방:");
        largeRooms.forEach(room -> System.out.println("   " + room));
        System.out.println();

        // 6. 메시지 저장
        System.out.println("--- 메시지 관리 ---");
        messageDao.save(new Message(null, 1L, "김카카오", "안녕하세요!"));
        messageDao.save(new Message(null, 1L, "이톡톡", "반갑습니다!"));
        messageDao.save(new Message(null, 1L, "김카카오", "오늘 스터디 주제는 제네릭입니다."));
        System.out.println();

        // 7. 채팅방별 메시지 조회 (MessageDao 전용 메서드)
        List<Message> roomMessages = messageDao.findByRoomId(1L);
        System.out.println("채팅방 1번 메시지:");
        roomMessages.forEach(msg -> System.out.println("   " + msg));
        System.out.println();

        // 8. 전체 조회
        System.out.println("--- 전체 데이터 조회 ---");
        System.out.println("전체 사용자 수: " + userDao.count());
        System.out.println("전체 채팅방 수: " + roomDao.count());
        System.out.println("전체 메시지 수: " + messageDao.count());

        System.out.println("\n✅ 제네릭 DAO 패턴의 장점:");
        System.out.println("1. 코드 재사용: CRUD 로직을 BaseDao에 한 번만 구현");
        System.out.println("2. 타입 안전성: UserDao는 KakaoUser만, RoomDao는 ChatRoom만 처리");
        System.out.println("3. 확장성: 엔티티별 전용 메서드를 추가 가능");
        System.out.println("4. 유지보수: 공통 로직 수정 시 BaseDao만 변경");
    }
}
```

### 실행 결과
```
=== 카카오 제네릭 DAO 패턴 ===

--- 사용자 관리 ---
💾 INSERT into kakao_users: User[1] 김카카오 (010-1234-5678)
💾 INSERT into kakao_users: User[2] 이톡톡 (010-8765-4321)

🔍 SELECT from kakao_users WHERE id=1
조회 결과: User[1] 김카카오 (010-1234-5678)

🔍 SELECT from kakao_users WHERE phone_number='010-1234-5678'
전화번호 검색: User[1] 김카카오 (010-1234-5678)

--- 채팅방 관리 ---
💾 INSERT into chat_rooms: Room[1] 자바 스터디 (12명)
💾 INSERT into chat_rooms: Room[2] 점심 메뉴 (5명)
💾 INSERT into chat_rooms: Room[3] 전사 공지 (150명)

🔍 SELECT from chat_rooms WHERE member_count >= 10
10명 이상 채팅방:
   Room[1] 자바 스터디 (12명)
   Room[3] 전사 공지 (150명)

--- 메시지 관리 ---
💾 INSERT into messages: Msg[1] 김카카오: 안녕하세요!
💾 INSERT into messages: Msg[2] 이톡톡: 반갑습니다!
💾 INSERT into messages: Msg[3] 김카카오: 오늘 스터디 주제는 제네릭입니다.

🔍 SELECT from messages WHERE room_id=1
채팅방 1번 메시지:
   Msg[1] 김카카오: 안녕하세요!
   Msg[2] 이톡톡: 반갑습니다!
   Msg[3] 김카카오: 오늘 스터디 주제는 제네릭입니다.

--- 전체 데이터 조회 ---
전체 사용자 수: 2
전체 채팅방 수: 3
전체 메시지 수: 3

✅ 제네릭 DAO 패턴의 장점:
1. 코드 재사용: CRUD 로직을 BaseDao에 한 번만 구현
2. 타입 안전성: UserDao는 KakaoUser만, RoomDao는 ChatRoom만 처리
3. 확장성: 엔티티별 전용 메서드를 추가 가능
4. 유지보수: 공통 로직 수정 시 BaseDao만 변경
```

### 핵심 교훈
- **제네릭 상속**: `BaseDao<T extends Entity>` 상속으로 공통 로직 재사용
- **타입 바운드**: `T extends Entity` - 모든 엔티티가 getId/setId 보장
- **전용 메서드**: 각 DAO가 자체적인 쿼리 메서드 추가 가능
- **실무 적용**: Spring Data JPA의 JpaRepository가 이 패턴 사용

---

## 사례 3: 쿠팡 - 제네릭 캐시 시스템 📦

### 배경
쿠팡 상품 조회 API는 초당 수만 건의 요청을 처리합니다. DB 부하를 줄이기 위해 상품, 카테고리, 사용자 등 다양한 데이터를 캐싱하는 범용 캐시 시스템을 구현했습니다.

### 문제 상황
```java
// ❌ 제네릭 없이: 각 데이터 타입마다 캐시 클래스 중복
class ProductCache {
    private Map<String, Product> cache = new HashMap<>();
    // 캐시 로직...
}

class CategoryCache {
    private Map<String, Category> cache = new HashMap<>();
    // 동일한 캐시 로직 반복...
}
```

### 해결 방법: 제네릭 LRU 캐시

```java
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

// 캐시 엔트리 - 데이터 + 메타정보
class CacheEntry<V> {
    private final V value;
    private final LocalDateTime createdAt;
    private final Duration ttl; // Time To Live
    private int hitCount; // 조회 횟수

    public CacheEntry(V value, Duration ttl) {
        this.value = value;
        this.createdAt = LocalDateTime.now();
        this.ttl = ttl;
        this.hitCount = 0;
    }

    public V getValue() {
        hitCount++;
        return value;
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(createdAt.plus(ttl));
    }

    public int getHitCount() { return hitCount; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}

// 제네릭 LRU 캐시 (Least Recently Used)
class LRUCache<K, V> {
    private final int maxSize;
    private final Duration defaultTtl;
    private final Map<K, CacheEntry<V>> cache;
    private final LinkedHashMap<K, LocalDateTime> accessOrder; // LRU 추적

    // 통계
    private int hits = 0;
    private int misses = 0;

    public LRUCache(int maxSize, Duration defaultTtl) {
        this.maxSize = maxSize;
        this.defaultTtl = defaultTtl;
        this.cache = new ConcurrentHashMap<>();
        this.accessOrder = new LinkedHashMap<>(maxSize, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, LocalDateTime> eldest) {
                return size() > maxSize;
            }
        };
    }

    // 캐시 조회
    public Optional<V> get(K key) {
        CacheEntry<V> entry = cache.get(key);

        if (entry == null) {
            misses++;
            System.out.println("❌ CACHE MISS: " + key);
            return Optional.empty();
        }

        if (entry.isExpired()) {
            cache.remove(key);
            accessOrder.remove(key);
            misses++;
            System.out.println("⏰ CACHE EXPIRED: " + key);
            return Optional.empty();
        }

        hits++;
        accessOrder.put(key, LocalDateTime.now()); // LRU 업데이트
        System.out.println("✅ CACHE HIT: " + key + " (조회 " + entry.getHitCount() + "회)");
        return Optional.of(entry.getValue());
    }

    // 캐시 저장
    public void put(K key, V value) {
        put(key, value, defaultTtl);
    }

    public void put(K key, V value, Duration ttl) {
        if (cache.size() >= maxSize && !cache.containsKey(key)) {
            evictLRU(); // LRU 제거
        }

        cache.put(key, new CacheEntry<>(value, ttl));
        accessOrder.put(key, LocalDateTime.now());
        System.out.println("💾 CACHE PUT: " + key);
    }

    // LRU(가장 오래된 항목) 제거
    private void evictLRU() {
        if (accessOrder.isEmpty()) return;

        K lruKey = accessOrder.keySet().iterator().next();
        cache.remove(lruKey);
        accessOrder.remove(lruKey);
        System.out.println("🗑️ LRU EVICTION: " + lruKey);
    }

    // 캐시가 없으면 loader 함수로 로드 후 캐싱
    public V getOrLoad(K key, Function<K, V> loader) {
        return get(key).orElseGet(() -> {
            V value = loader.apply(key);
            if (value != null) {
                put(key, value);
            }
            return value;
        });
    }

    // 통계
    public void printStats() {
        System.out.println("\n📊 캐시 통계:");
        System.out.println("   크기: " + cache.size() + "/" + maxSize);
        System.out.println("   Hit: " + hits + ", Miss: " + misses);
        double hitRate = (hits + misses) == 0 ? 0 :
                        (double) hits / (hits + misses) * 100;
        System.out.println("   Hit Rate: " + String.format("%.1f%%", hitRate));
    }

    public void clear() {
        cache.clear();
        accessOrder.clear();
        System.out.println("🧹 캐시 전체 삭제");
    }
}

// 도메인 모델들
class Product {
    private String productId;
    private String name;
    private int price;

    public Product(String productId, String name, int price) {
        this.productId = productId;
        this.name = name;
        this.price = price;
    }

    @Override
    public String toString() {
        return name + " (" + String.format("%,d원", price) + ")";
    }
}

class Category {
    private String categoryId;
    private String name;

    public Category(String categoryId, String name) {
        this.categoryId = categoryId;
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// 쿠팡 상품 서비스 시뮬레이션
class CoupangProductService {
    private final LRUCache<String, Product> productCache;
    private final LRUCache<String, Category> categoryCache;

    public CoupangProductService() {
        this.productCache = new LRUCache<>(3, Duration.ofSeconds(10)); // 최대 3개, 10초 TTL
        this.categoryCache = new LRUCache<>(2, Duration.ofSeconds(15)); // 최대 2개, 15초 TTL
    }

    // DB에서 상품 조회 시뮬레이션
    private Product loadProductFromDB(String productId) {
        System.out.println("🔄 DB에서 상품 로드: " + productId);
        // 실제로는 DB 쿼리
        return new Product(productId, "상품-" + productId, 10000 + productId.hashCode() % 50000);
    }

    // DB에서 카테고리 조회 시뮬레이션
    private Category loadCategoryFromDB(String categoryId) {
        System.out.println("🔄 DB에서 카테고리 로드: " + categoryId);
        return new Category(categoryId, "카테고리-" + categoryId);
    }

    // 캐시를 활용한 상품 조회
    public Product getProduct(String productId) {
        return productCache.getOrLoad(productId, this::loadProductFromDB);
    }

    // 캐시를 활용한 카테고리 조회
    public Category getCategory(String categoryId) {
        return categoryCache.getOrLoad(categoryId, this::loadCategoryFromDB);
    }

    public void printAllStats() {
        System.out.println("\n=== 상품 캐시 ===");
        productCache.printStats();
        System.out.println("\n=== 카테고리 캐시 ===");
        categoryCache.printStats();
    }
}

public class CoupangCacheExample {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== 쿠팡 제네릭 캐시 시스템 ===\n");

        CoupangProductService service = new CoupangProductService();

        // 1. 상품 조회 - 첫 조회는 DB에서 로드
        System.out.println("--- 첫 번째 조회 ---");
        Product p1 = service.getProduct("PROD-001");
        System.out.println("결과: " + p1 + "\n");

        // 2. 동일 상품 재조회 - 캐시 히트
        System.out.println("--- 두 번째 조회 (캐시 히트) ---");
        Product p1Again = service.getProduct("PROD-001");
        System.out.println("결과: " + p1Again + "\n");

        // 3. 다른 상품들 조회
        System.out.println("--- 여러 상품 조회 ---");
        service.getProduct("PROD-002");
        service.getProduct("PROD-003");
        service.getProduct("PROD-001"); // 캐시 히트
        System.out.println();

        // 4. LRU 제거 테스트 - 캐시 크기 초과
        System.out.println("--- LRU 제거 테스트 (캐시 크기: 3) ---");
        service.getProduct("PROD-004"); // PROD-002가 LRU로 제거될 것
        service.getProduct("PROD-002"); // 다시 DB에서 로드
        System.out.println();

        // 5. 카테고리 캐시 테스트
        System.out.println("--- 카테고리 캐시 ---");
        service.getCategory("CAT-A");
        service.getCategory("CAT-B");
        service.getCategory("CAT-A"); // 캐시 히트
        System.out.println();

        // 6. TTL 만료 테스트
        System.out.println("--- TTL 만료 테스트 (10초 대기) ---");
        System.out.println("11초 후 재조회하면 캐시 만료...");
        Thread.sleep(11000); // 11초 대기
        service.getProduct("PROD-001"); // 만료되어 DB에서 재로드
        System.out.println();

        // 7. 통계 출력
        service.printAllStats();

        System.out.println("\n\n✅ 제네릭 캐시 시스템의 장점:");
        System.out.println("1. 범용성: 하나의 캐시로 Product, Category 등 모든 타입 처리");
        System.out.println("2. 타입 안전성: productCache는 Product만, categoryCache는 Category만");
        System.out.println("3. 성능 향상: DB 조회 대신 메모리 캐시로 빠른 응답");
        System.out.println("4. 메모리 관리: LRU + TTL로 메모리 효율적 사용");
    }
}
```

### 실행 결과
```
=== 쿠팡 제네릭 캐시 시스템 ===

--- 첫 번째 조회 ---
❌ CACHE MISS: PROD-001
🔄 DB에서 상품 로드: PROD-001
💾 CACHE PUT: PROD-001
결과: 상품-PROD-001 (35,297원)

--- 두 번째 조회 (캐시 히트) ---
✅ CACHE HIT: PROD-001 (조회 1회)
결과: 상품-PROD-001 (35,297원)

--- 여러 상품 조회 ---
❌ CACHE MISS: PROD-002
🔄 DB에서 상품 로드: PROD-002
💾 CACHE PUT: PROD-002
❌ CACHE MISS: PROD-003
🔄 DB에서 상품 로드: PROD-003
💾 CACHE PUT: PROD-003
✅ CACHE HIT: PROD-001 (조회 2회)

--- LRU 제거 테스트 (캐시 크기: 3) ---
🗑️ LRU EVICTION: PROD-002
💾 CACHE PUT: PROD-004
❌ CACHE MISS: PROD-002
🔄 DB에서 상품 로드: PROD-002
🗑️ LRU EVICTION: PROD-003
💾 CACHE PUT: PROD-002

--- 카테고리 캐시 ---
❌ CACHE MISS: CAT-A
🔄 DB에서 카테고리 로드: CAT-A
💾 CACHE PUT: CAT-A
❌ CACHE MISS: CAT-B
🔄 DB에서 카테고리 로드: CAT-B
💾 CACHE PUT: CAT-B
✅ CACHE HIT: CAT-A (조회 1회)

--- TTL 만료 테스트 (10초 대기) ---
11초 후 재조회하면 캐시 만료...
⏰ CACHE EXPIRED: PROD-001
🔄 DB에서 상품 로드: PROD-001
🗑️ LRU EVICTION: PROD-004
💾 CACHE PUT: PROD-001

=== 상품 캐시 ===

📊 캐시 통계:
   크기: 3/3
   Hit: 3, Miss: 7
   Hit Rate: 30.0%

=== 카테고리 캐시 ===

📊 캐시 통계:
   크기: 2/2
   Hit: 1, Miss: 2
   Hit Rate: 33.3%


✅ 제네릭 캐시 시스템의 장점:
1. 범용성: 하나의 캐시로 Product, Category 등 모든 타입 처리
2. 타입 안전성: productCache는 Product만, categoryCache는 Category만
3. 성능 향상: DB 조회 대신 메모리 캐시로 빠른 응답
4. 메모리 관리: LRU + TTL로 메모리 효율적 사용
```

### 핵심 교훈
- **복합 제네릭**: `CacheEntry<V>`, `LRUCache<K, V>` - 여러 타입 파라미터
- **Function 인터페이스**: `getOrLoad(K key, Function<K, V> loader)` - 함수형 프로그래밍
- **실무 패턴**: Redis, Caffeine 등 실제 캐시 라이브러리의 기본 원리
- **성능 최적화**: DB 부하 감소, 응답 속도 향상

---

## 🔰 주니어 개발자 흔한 실수 시나리오

---

## 실수 1: Raw Type 사용 ⚠️

### 문제 코드
```java
import java.util.*;

public class RawTypeError {
    public static void main(String[] args) {
        // ❌ Raw Type 사용 - 제네릭 타입 지정 안 함
        List products = new ArrayList();

        products.add("노트북");
        products.add(Integer.valueOf(1000000)); // 컴파일 OK - 문제 없음
        products.add(new Date()); // 컴파일 OK - 문제 없음

        // 런타임 에러 발생!
        for (Object obj : products) {
            String product = (String) obj; // ClassCastException!
            System.out.println(product.toUpperCase());
        }
    }
}
```

### 실행 결과
```
노트북
Exception in thread "main" java.lang.ClassCastException:
    java.lang.Integer cannot be cast to java.lang.String
```

### 올바른 코드
```java
import java.util.*;

public class RawTypeFixed {
    public static void main(String[] args) {
        // ✅ 제네릭 타입 명시
        List<String> products = new ArrayList<>();

        products.add("노트북");
        // products.add(1000000); // ❌ 컴파일 에러! 타입 안전성 보장
        // products.add(new Date()); // ❌ 컴파일 에러!

        // 타입 캐스팅 불필요
        for (String product : products) {
            System.out.println(product.toUpperCase());
        }
    }
}
```

### 교훈
- **Raw Type 절대 금지**: `List` 대신 `List<T>` 사용
- **컴파일 타임 체크**: 제네릭으로 런타임 에러 방지
- **IDE 경고 주의**: "unchecked" 경고는 무시하지 말 것

---

## 실수 2: 제네릭 배열 생성 시도 ⚠️

### 문제 코드
```java
public class GenericArrayError<T> {
    private T[] items;

    public GenericArrayError(int size) {
        // ❌ 컴파일 에러: Generic array creation
        // items = new T[size];

        // ⚠️ 경고 발생하는 우회 방법
        items = (T[]) new Object[size];
    }

    public void set(int index, T item) {
        items[index] = item;
    }

    public T get(int index) {
        return items[index];
    }

    public static void main(String[] args) {
        GenericArrayError<String> array = new GenericArrayError<>(3);
        array.set(0, "Hello");
        array.set(1, "World");

        // ⚠️ 런타임에 문제 발생 가능
        String[] strings = (String[]) array.items; // ClassCastException 가능!
    }
}
```

### 올바른 코드 - ArrayList 사용
```java
import java.util.*;

public class GenericArrayFixed<T> {
    private List<T> items; // ✅ ArrayList 사용

    public GenericArrayFixed() {
        items = new ArrayList<>();
    }

    public void add(T item) {
        items.add(item);
    }

    public T get(int index) {
        return items.get(index);
    }

    public int size() {
        return items.size();
    }

    public static void main(String[] args) {
        GenericArrayFixed<String> array = new GenericArrayFixed<>();
        array.add("Hello");
        array.add("World");

        System.out.println("크기: " + array.size());
        System.out.println("첫 번째: " + array.get(0));
    }
}
```

### 교훈
- **제네릭 배열 생성 불가**: 타입 소거로 인해 `new T[]` 불가능
- **ArrayList 사용 권장**: 제네릭 배열 대신 `List<T>` 사용
- **불가피한 경우**: `@SuppressWarnings("unchecked")` + 주석으로 경고 억제

---

## 실수 3: 와일드카드 오용 ⚠️

### 문제 코드
```java
import java.util.*;

public class WildcardError {
    // ❌ extends는 읽기 전용! 쓰기 불가
    public static void addNumber(List<? extends Number> numbers) {
        // numbers.add(10); // ❌ 컴파일 에러!
        // numbers.add(3.14); // ❌ 컴파일 에러!
        // List<Integer>, List<Double> 등 어떤 타입인지 모르므로 쓰기 불가

        Number num = numbers.get(0); // ✅ 읽기는 가능
    }

    // ❌ super는 쓰기 전용! 읽기 제한
    public static void printNumbers(List<? super Integer> numbers) {
        numbers.add(10); // ✅ 쓰기는 가능

        // Integer num = numbers.get(0); // ❌ 컴파일 에러!
        Object obj = numbers.get(0); // ⚠️ Object로만 읽을 수 있음
        System.out.println(obj);
    }

    public static void main(String[] args) {
        List<Integer> integers = Arrays.asList(1, 2, 3);
        addNumber(integers); // extends는 읽기만

        List<Number> numbers = new ArrayList<>();
        printNumbers(numbers); // super는 쓰기만
    }
}
```

### 올바른 코드 - PECS 원칙 적용
```java
import java.util.*;

public class WildcardFixed {

    // Producer (데이터 제공) - extends 사용
    public static double sumNumbers(List<? extends Number> numbers) {
        double sum = 0;
        for (Number num : numbers) { // ✅ 읽기 전용
            sum += num.doubleValue();
        }
        return sum;
    }

    // Consumer (데이터 소비) - super 사용
    public static void addIntegers(List<? super Integer> numbers) {
        numbers.add(10); // ✅ 쓰기 가능
        numbers.add(20);
        numbers.add(30);
    }

    public static void main(String[] args) {
        // Producer: 다양한 Number 타입에서 읽기
        List<Integer> integers = Arrays.asList(1, 2, 3);
        List<Double> doubles = Arrays.asList(1.5, 2.5, 3.5);

        System.out.println("Integer 합: " + sumNumbers(integers));
        System.out.println("Double 합: " + sumNumbers(doubles));

        // Consumer: Number 리스트에 Integer 쓰기
        List<Number> numbers = new ArrayList<>();
        addIntegers(numbers);
        System.out.println("추가된 숫자: " + numbers);
    }
}
```

### 실행 결과
```
Integer 합: 6.0
Double 합: 7.5
추가된 숫자: [10, 20, 30]
```

### 교훈
- **PECS 원칙**: Producer-Extends (읽기), Consumer-Super (쓰기)
- **extends**: 데이터를 "생산"하는 경우 (`List<? extends T>`)
- **super**: 데이터를 "소비"하는 경우 (`List<? super T>`)

---

## 실수 4: 타입 소거 이해 부족 ⚠️

### 문제 코드
```java
import java.util.*;

public class TypeErasureError<T> {
    private List<T> items = new ArrayList<>();

    // ❌ 런타임에 T의 타입을 알 수 없음
    public void addIfString(Object obj) {
        // if (obj instanceof T) { // ❌ 컴파일 에러: T는 런타임에 소거됨
        //     items.add((T) obj);
        // }

        // if (items instanceof List<String>) { // ❌ 컴파일 에러
        //     System.out.println("String 리스트");
        // }

        if (items instanceof List) { // ⚠️ Raw type만 체크 가능
            System.out.println("List인지만 확인 가능 (구체 타입은 모름)");
        }
    }

    // ❌ 제네릭 타입 정보를 런타임에 얻을 수 없음
    public void printType() {
        // System.out.println(T.class); // ❌ 컴파일 에러
        System.out.println(items.getClass()); // ArrayList (타입 파라미터 정보 없음)
    }

    public static void main(String[] args) {
        TypeErasureError<String> stringList = new TypeErasureError<>();
        TypeErasureError<Integer> intList = new TypeErasureError<>();

        // 런타임에는 둘 다 같은 클래스!
        System.out.println(stringList.getClass() == intList.getClass()); // true
    }
}
```

### 올바른 코드 - Class 객체 전달
```java
import java.util.*;

public class TypeErasureFixed<T> {
    private List<T> items = new ArrayList<>();
    private Class<T> type; // ✅ 타입 정보를 명시적으로 저장

    public TypeErasureFixed(Class<T> type) {
        this.type = type;
    }

    // ✅ Class 객체로 런타임 타입 체크
    public void addIfType(Object obj) {
        if (type.isInstance(obj)) {
            items.add(type.cast(obj));
            System.out.println("✅ 추가: " + obj + " (타입: " + type.getSimpleName() + ")");
        } else {
            System.out.println("❌ 타입 불일치: " + obj.getClass().getSimpleName() +
                             " (기대: " + type.getSimpleName() + ")");
        }
    }

    public void printType() {
        System.out.println("저장된 타입: " + type.getName());
    }

    public List<T> getItems() {
        return new ArrayList<>(items);
    }

    public static void main(String[] args) {
        // ✅ Class 객체를 생성자에 전달
        TypeErasureFixed<String> stringList = new TypeErasureFixed<>(String.class);
        stringList.printType();
        stringList.addIfType("Hello"); // 성공
        stringList.addIfType(123);      // 실패

        System.out.println();

        TypeErasureFixed<Integer> intList = new TypeErasureFixed<>(Integer.class);
        intList.printType();
        intList.addIfType(456);        // 성공
        intList.addIfType("World");    // 실패

        System.out.println("\n최종 결과:");
        System.out.println("String 리스트: " + stringList.getItems());
        System.out.println("Integer 리스트: " + intList.getItems());
    }
}
```

### 실행 결과
```
저장된 타입: java.lang.String
✅ 추가: Hello (타입: String)
❌ 타입 불일치: Integer (기대: String)

저장된 타입: java.lang.Integer
✅ 추가: 456 (타입: Integer)
❌ 타입 불일치: String (기대: Integer)

최종 결과:
String 리스트: [Hello]
Integer 리스트: [456]
```

### 교훈
- **타입 소거**: 제네릭 타입 정보는 런타임에 사라짐
- **Class 객체 전달**: `Class<T>` 를 생성자 파라미터로 받아 타입 정보 보존
- **instanceof 제한**: `obj instanceof T` 불가, `type.isInstance(obj)` 사용
- **실무 패턴**: Jackson, Gson 등 JSON 라이브러리가 이 방식 사용 (`TypeReference<T>`)

---

## 🎯 Part 2 핵심 요약

### 기업 사례 핵심 패턴
1. **API Response Wrapper** (네이버): 일관된 응답 구조, 타입 안전성
2. **Generic DAO** (카카오): CRUD 코드 재사용, 엔티티별 타입 보장
3. **Generic Cache** (쿠팡): 범용 캐시 시스템, LRU + TTL 구현

### 주니어 실수 방지 체크리스트
- ❌ Raw Type 사용 금지 → ✅ `List<T>` 명시
- ❌ 제네릭 배열 생성 금지 → ✅ `List<T>` 사용
- ❌ 와일드카드 오용 → ✅ PECS 원칙 (Producer-Extends, Consumer-Super)
- ❌ 타입 소거 무시 → ✅ `Class<T>` 객체 활용

### 실무 적용 포인트
- Spring Framework: `ResponseEntity<T>`, JpaRepository<T, ID>
- Functional Programming: `Function<T, R>`, `Supplier<T>`
- JSON 라이브러리: `TypeReference<T>`, `Gson.fromJson(json, Class<T>)`

다음 Part 3에서는 실전 프로젝트로 "범용 비즈니스 규칙 엔진"을 구현하고, 면접 질문을 다룹니다! 🚀
