# 49장: 성적 관리 시스템

> **학습 목표**: 통계 기능과 등급 시스템을 이해하고, 완전한 성적 관리 시스템을 구현할 수 있습니다.

**⏱️ 예상 학습 시간**: 6-8시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [핵심 개념](#핵심-개념)
- [기본 실습](#기본-실습)
- [실무 활용 사례](#실무-활용-사례)
- [주니어 시나리오](#주니어-시나리오)
- [실전 프로젝트](#실전-프로젝트)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)
- [다음 단계](#다음-단계)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경

**성적 관리는 교육 기관의 핵심 업무이며, 통계 분석과 자동화는 효율성을 크게 향상시킵니다.**

#### ❌ 수작업 성적 관리의 문제점

```
문제 1: 계산 오류
- 증상: 평균, 합계 계산 실수
- 영향: 학생 불만, 재계산 반복
- 비용: 재작업 시간 주당 5시간

문제 2: 등급 산정 불일치
- 증상: 교사마다 다른 등급 기준
- 영향: 공정성 문제, 민원 발생
- 비용: 분쟁 해결 비용 건당 $100

문제 3: 통계 분석 어려움
- 증상: 반평균, 과목별 분석 시간 소요
- 영향: 데이터 기반 의사결정 불가
- 비용: 보고서 작성 시간 주당 10시간
```

#### ✅ 자동화된 성적 관리 시스템을 구축하면

```
해결책 1: 자동 계산
- 방법: 프로그램이 자동으로 평균/합계 계산
- 효과: 계산 오류 0%
- 절감: 재작업 시간 100% 절감

해결책 2: 표준화된 등급 시스템
- 방법: 일관된 기준으로 자동 등급 산정
- 효과: 공정성 100% 보장
- 절감: 민원 처리 비용 90% 감소

해결책 3: 실시간 통계 분석
- 방법: 원클릭으로 모든 통계 생성
- 효과: 즉시 데이터 분석 가능
- 절감: 보고서 작성 시간 95% 단축
```

### 📊 수치로 보는 효과

| 지표 | 수작업 관리 | 시스템 관리 | 개선율 |
|------|------------|------------|--------|
| 성적 입력 시간 | 30분/반 | 5분/반 | **83%↓** |
| 계산 오류율 | 5% | 0% | **100%↓** |
| 통계 생성 시간 | 2시간 | 1분 | **98%↓** |
| 성적표 출력 시간 | 1시간 | 5분 | **92%↓** |
| 민원 발생률 | 10% | 1% | **90%↓** |
| 교사 만족도 | 50% | 92% | **84%↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 학교 성적표 (School Report Card)

```
종이 성적표 = 전통적 방식
- 교사가 수기로 작성
- 평균을 계산기로 계산
- 등급을 수동으로 판단
- 오류 발생 시 재작성
→ 시간 소요, 실수 가능성

자동 성적표 = 시스템 방식
- 점수만 입력
- 자동으로 평균 계산
- 등급 자동 산정
- 오류 없음
→ 빠르고 정확함

📊 성적 처리 프로세스
┌────────────────────────┐
│ 1. 점수 입력           │
│ 2. 자동 평균 계산      │
│ 3. 등급 자동 산정      │
│ 4. 석차 자동 계산      │
│ 5. 성적표 출력         │
└────────────────────────┘
```

**Java 코드로 표현:**
```java
// 전통적 방식
double avg = (kor + eng + math) / 3.0;
String grade;
if (avg >= 90) grade = "A";
else if (avg >= 80) grade = "B";
// ...

// 객체 지향 방식
Student student = new Student("김철수", kor, eng, math);
student.calculateAverage();  // 자동 계산
student.assignGrade();        // 자동 등급 산정
System.out.println(student.getGrade());
```

---

### 비유 2: 게임 랭킹 시스템 (Game Ranking)

```
온라인 게임 리더보드 = 성적 관리
- 점수 자동 집계
- 실시간 순위 업데이트
- 등급 자동 부여 (브론즈, 실버, 골드)
- 통계 대시보드

🎮 게임 랭킹 = 성적 순위
┌─────────────────────────┐
│ 1위: 김철수 (95점) - S등급│
│ 2위: 이영희 (92점) - A등급│
│ 3위: 박민수 (88점) - B등급│
└─────────────────────────┘

자동 랭킹 시스템의 장점:
- 실시간 업데이트
- 공정한 기준
- 투명한 등급 산정
```

---

### 비유 3: 직장 평가 시스템 (Employee Evaluation)

```
연말 인사 평가 = 성적 관리
- 여러 항목 점수 (업무, 태도, 협업)
- 가중 평균 계산
- 등급 산정 (S, A, B, C, D)
- 승진/보너스 연동

💼 인사 평가 프로세스
┌────────────────────────┐
│ 업무 능력: 90점 (40%)  │
│ 업무 태도: 85점 (30%)  │
│ 협업 능력: 95점 (30%)  │
│ ─────────────────────  │
│ 가중 평균: 90점        │
│ 등급: A (우수)         │
└────────────────────────┘
```

---

### 비유 4: 올림픽 메달 집계 (Olympic Medal Count)

```
올림픽 메달 순위 = 성적 석차
- 금메달 수 우선
- 은메달 수 비교
- 동메달 수 비교
- 자동 정렬 및 순위 부여

🏅 메달 집계 시스템
┌──────────────────────────┐
│ 국가  │ 금 │ 은 │ 동 │순위│
├──────────────────────────┤
│ 한국  │ 10 │ 8  │ 6  │ 1  │
│ 일본  │ 10 │ 7  │ 9  │ 2  │
│ 중국  │ 9  │ 10 │ 8  │ 3  │
└──────────────────────────┘

성적 관리도 동일한 원리:
- 총점 우선 비교
- 동점 시 과목별 비교
- 자동 석차 계산
```

---

### 비유 5: 자격증 점수 관리 (Certificate Score Tracking)

```
자격증 시험 결과 = 성적 관리
- 합격/불합격 자동 판정
- 등급 자동 부여
- 통계 분석 (합격률, 평균 점수)
- 재응시 이력 관리

📜 자격증 점수 시스템
┌────────────────────────┐
│ 점수: 85점             │
│ 합격선: 70점           │
│ 결과: 합격             │
│ 등급: 우수             │
│ 전체 평균: 72점        │
│ 합격률: 68%            │
└────────────────────────┘
```

---

### 🎯 종합 비교표

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ 성적 관리    │ 게임 랭킹    │ 인사 평가    │ 올림픽 집계  │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 점수 입력    │ 게임 결과    │ 평가 점수    │ 메달 수      │
│ 평균 계산    │ 총점 집계    │ 가중 평균    │ 메달 합계    │
│ 등급 산정    │ 티어 부여    │ 등급 결정    │ 순위 결정    │
│ 석차 계산    │ 순위 표시    │ 서열 정리    │ 랭킹 표시    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📖 핵심 개념

### 개념 설명 (3단계 깊이)

#### 1️⃣ 초보자 수준 설명

**성적 관리 시스템은 학생의 점수를 입력받아 평균, 등급, 석차를 자동으로 계산합니다.**

- **평균 계산**: 여러 과목 점수의 평균값
- **등급 산정**: 평균 점수에 따라 A, B, C, D, F 부여
- **석차 계산**: 전체 학생 중 순위 결정
- **통계 분석**: 최고점, 최저점, 반평균 등

```java
// 간단한 예제
Student student = new Student("김철수", 90, 85, 88);
double average = student.getAverage();     // 87.67
String grade = student.getGrade();         // "B"
int rank = gradeManager.calculateRank(student);  // 3위
```

#### 2️⃣ 중급자 수준 설명

**객체 지향 설계를 통해 Student, Subject, GradeCalculator를 분리하고, 전략 패턴으로 등급 기준을 교체 가능하게 만듭니다.**

주요 개념:
- **캡슐화**: 점수와 계산 로직을 클래스 내부로
- **상속**: AbstractStudent → RegularStudent, HonorStudent
- **다형성**: 다양한 등급 기준 (절대평가, 상대평가)
- **컬렉션 활용**: List, Map으로 다중 학생 관리

```java
// 중급 예제: 전략 패턴
interface GradingStrategy {
    String calculateGrade(double average);
}

class AbsoluteGrading implements GradingStrategy {
    @Override
    public String calculateGrade(double average) {
        if (average >= 90) return "A";
        if (average >= 80) return "B";
        // ...
        return "F";
    }
}

class RelativeGrading implements GradingStrategy {
    @Override
    public String calculateGrade(double average) {
        // 상위 10% → A
        // 상위 30% → B
        // ...
    }
}

student.setGradingStrategy(new AbsoluteGrading());
```

#### 3️⃣ 고급자 수준 설명

**제네릭을 활용한 타입 안전성 확보, Stream API로 통계 계산 최적화, 함수형 프로그래밍으로 가독성 향상**

내부 동작:
- **제네릭**: `GradeManager<T extends Student>`
- **Stream API**: 평균, 최고점 계산을 선언적으로
- **Optional**: null 안전 처리
- **Comparator**: 정렬 기준 커스터마이징

```java
// 고급 예제: Stream API + 함수형
public class GradeStatistics {
    private List<Student> students;

    // 평균 계산
    public double getClassAverage() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .average()
            .orElse(0.0);
    }

    // 최고점 학생
    public Optional<Student> getTopStudent() {
        return students.stream()
            .max(Comparator.comparingDouble(Student::getAverage));
    }

    // 과목별 평균
    public Map<String, Double> getSubjectAverages() {
        return students.stream()
            .flatMap(s -> s.getScores().entrySet().stream())
            .collect(Collectors.groupingBy(
                Map.Entry::getKey,
                Collectors.averagingInt(Map.Entry::getValue)
            ));
    }

    // 등급별 학생 수
    public Map<String, Long> countByGrade() {
        return students.stream()
            .collect(Collectors.groupingBy(
                Student::getGrade,
                Collectors.counting()
            ));
    }
}
```

---

### 주요 용어 정리

| 용어 | 영문 | 설명 | 예시 |
|------|------|------|------|
| 평균 | Average | 모든 점수의 합 ÷ 과목 수 | `(90+85+88)/3 = 87.67` |
| 등급 | Grade | 평균 점수에 따른 등급 | A, B, C, D, F |
| 석차 | Rank | 전체 학생 중 순위 | 1등, 2등, 3등 |
| 표준편차 | Standard Deviation | 점수의 분산 정도 | 낮을수록 고른 점수 |
| 백분위 | Percentile | 상위 몇 % | 상위 10% |
| 가중평균 | Weighted Average | 과목별 가중치 적용 평균 | 국어 40%, 영어 30%, 수학 30% |

---

### 기술 아키텍처

```
┌─────────────────────────────────────────────────┐
│           성적 관리 시스템 아키텍처             │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │        Presentation Layer               │   │
│  │  (Menu, Input/Output, ReportViewer)     │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Business Logic Layer             │   │
│  │  (GradeManager, GradeCalculator,        │   │
│  │   RankCalculator, Statistics)           │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Data Access Layer                │   │
│  │  (StudentRepository, FileManager)       │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Storage Layer                    │   │
│  │  (students.dat, reports/, statistics/)  │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘

데이터 흐름:
점수 입력 → 검증 → 평균 계산 → 등급 산정 → 석차 계산 → 저장
```

---

## 💻 기본 실습

### 📋 사전 체크리스트
```bash
# 1. Java 버전 확인
java -version

# 2. 프로젝트 디렉토리 생성
mkdir grade-management
cd grade-management
mkdir src
```

### 실습 1: Student 클래스 만들기
**난이도**: ⭐☆☆☆☆

#### 코드
```java
import java.io.Serializable;
import java.util.*;

public class Student implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String studentNumber;  // 학번
    private String name;
    private Map<String, Integer> scores;  // 과목별 점수

    // 계산된 값들
    private transient double average;
    private transient String grade;
    private transient int rank;

    public Student(String studentNumber, String name) {
        this.studentNumber = studentNumber;
        this.name = name;
        this.scores = new HashMap<>();
    }

    // 점수 추가
    public void addScore(String subject, int score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("점수는 0-100 사이여야 합니다.");
        }
        scores.put(subject, score);
    }

    // 평균 계산
    public double calculateAverage() {
        if (scores.isEmpty()) {
            return 0.0;
        }
        int sum = scores.values().stream()
            .mapToInt(Integer::intValue)
            .sum();
        this.average = (double) sum / scores.size();
        return this.average;
    }

    // 합계
    public int getTotalScore() {
        return scores.values().stream()
            .mapToInt(Integer::intValue)
            .sum();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getStudentNumber() { return studentNumber; }
    public String getName() { return name; }

    public Map<String, Integer> getScores() { return new HashMap<>(scores); }

    public double getAverage() { return average; }
    public void setAverage(double average) { this.average = average; }

    public String getGrade() { return grade; }
    public void setGrade(String grade) { this.grade = grade; }

    public int getRank() { return rank; }
    public void setRank(int rank) { this.rank = rank; }

    @Override
    public String toString() {
        return String.format("[%s] %s | 평균: %.2f | 등급: %s | 석차: %d",
            studentNumber, name, average, grade, rank);
    }
}
```

---

### 실습 2: 등급 계산기 구현
**난이도**: ⭐⭐⭐☆☆

#### 코드
```java
public class GradeCalculator {
    // 절대평가 기준
    public static String calculateAbsoluteGrade(double average) {
        if (average >= 90) return "A";
        if (average >= 80) return "B";
        if (average >= 70) return "C";
        if (average >= 60) return "D";
        return "F";
    }

    // 상대평가 기준 (4.5등급제)
    public static String calculateRelativeGrade(int rank, int totalStudents) {
        double percentile = (double) rank / totalStudents * 100;

        if (percentile <= 4) return "1등급";      // 상위 4%
        if (percentile <= 11) return "2등급";     // 상위 11%
        if (percentile <= 23) return "3등급";     // 상위 23%
        if (percentile <= 40) return "4등급";     // 상위 40%
        if (percentile <= 60) return "5등급";     // 상위 60%
        if (percentile <= 77) return "6등급";     // 상위 77%
        if (percentile <= 89) return "7등급";     // 상위 89%
        if (percentile <= 96) return "8등급";     // 상위 96%
        return "9등급";                           // 하위 4%
    }

    // 학점 변환 (4.5 만점)
    public static double convertToGPA(String grade) {
        switch (grade) {
            case "A": return 4.5;
            case "B": return 3.5;
            case "C": return 2.5;
            case "D": return 1.5;
            case "F": return 0.0;
            default: return 0.0;
        }
    }

    // Pass/Fail 판정
    public static boolean isPass(double average, double passingScore) {
        return average >= passingScore;
    }
}
```

---

### 실습 3: 통계 계산
**난이도**: ⭐⭐⭐⭐☆

#### 코드
```java
import java.util.*;
import java.util.stream.*;

public class Statistics {
    private List<Student> students;

    public Statistics(List<Student> students) {
        this.students = students;
    }

    // 반 평균
    public double getClassAverage() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .average()
            .orElse(0.0);
    }

    // 최고점
    public double getMaxScore() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .max()
            .orElse(0.0);
    }

    // 최저점
    public double getMinScore() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .min()
            .orElse(0.0);
    }

    // 최고점 학생
    public Optional<Student> getTopStudent() {
        return students.stream()
            .max(Comparator.comparingDouble(Student::getAverage));
    }

    // 최저점 학생
    public Optional<Student> getBottomStudent() {
        return students.stream()
            .min(Comparator.comparingDouble(Student::getAverage));
    }

    // 과목별 평균
    public Map<String, Double> getSubjectAverages() {
        return students.stream()
            .flatMap(s -> s.getScores().entrySet().stream())
            .collect(Collectors.groupingBy(
                Map.Entry::getKey,
                Collectors.averagingDouble(Map.Entry::getValue)
            ));
    }

    // 등급별 학생 수
    public Map<String, Long> countByGrade() {
        return students.stream()
            .collect(Collectors.groupingBy(
                Student::getGrade,
                Collectors.counting()
            ));
    }

    // 표준편차
    public double getStandardDeviation() {
        double mean = getClassAverage();
        double variance = students.stream()
            .mapToDouble(s -> Math.pow(s.getAverage() - mean, 2))
            .average()
            .orElse(0.0);
        return Math.sqrt(variance);
    }

    // 중앙값
    public double getMedian() {
        List<Double> sorted = students.stream()
            .map(Student::getAverage)
            .sorted()
            .collect(Collectors.toList());

        int size = sorted.size();
        if (size == 0) return 0.0;
        if (size % 2 == 0) {
            return (sorted.get(size/2 - 1) + sorted.get(size/2)) / 2.0;
        } else {
            return sorted.get(size/2);
        }
    }
}
```

---

### 좋은 예 vs 나쁜 예

#### ❌ 나쁜 예
```java
// 1. 정수 나눗셈으로 평균 계산
public double getAverage() {
    int sum = kor + eng + math;
    return sum / 3;  // 정수 나눗셈! 87.67 → 87
}

// 2. 하드코딩된 등급 기준
public String getGrade() {
    if (average >= 90) return "A";
    if (average >= 80) return "B";
    // 나중에 기준 변경 시 모든 코드 수정 필요
}

// 3. 경계값 처리 오류
public String getGrade(double avg) {
    if (avg > 90) return "A";  // 90점은 B가 됨!
    if (avg > 80) return "B";
    // ...
}
```

**문제점**:
- 문제 1: 소수점 손실로 부정확한 평균
- 문제 2: 유지보수 어려움
- 문제 3: 경계값에서 버그 발생

#### ✅ 좋은 예
```java
// 1. 실수 나눗셈
public double getAverage() {
    int sum = kor + eng + math;
    return (double) sum / 3;  // 87.67 정확히 계산
}

// 2. 설정 가능한 등급 기준
public class GradeConfig {
    private static final Map<String, Double> GRADE_THRESHOLDS = Map.of(
        "A", 90.0,
        "B", 80.0,
        "C", 70.0,
        "D", 60.0
    );

    public static String calculateGrade(double average) {
        for (Map.Entry<String, Double> entry : GRADE_THRESHOLDS.entrySet()) {
            if (average >= entry.getValue()) {
                return entry.getKey();
            }
        }
        return "F";
    }
}

// 3. 경계값 포함
public String getGrade(double avg) {
    if (avg >= 90) return "A";  // 90점 이상
    if (avg >= 80) return "B";
    // ...
}
```

**장점**:
- 장점 1: 정확한 계산
- 장점 2: 설정 변경 용이
- 장점 3: 경계값 정확히 처리

---

## 🏢 실무 활용 사례

### 실제 기업 활용 사례

#### 사례 1: 학원 - 성적 관리 시스템

```java
// 사용 목적: 학원 수강생 성적 관리 및 학부모 리포트
// 규모: 학생 300-500명
// 효과: 성적표 발급 시간 90% 단축

public class AcademyGradeSystem {
    private GradeManager gradeManager;

    // 주간 테스트 등록
    public void registerWeeklyTest(Student student, Map<String, Integer> scores) {
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            student.addScore(entry.getKey(), entry.getValue());
        }
        gradeManager.update(student);
    }

    // 학부모 리포트 생성
    public ParentReport generateParentReport(Student student) {
        ParentReport report = new ParentReport();
        report.setStudentName(student.getName());
        report.setCurrentAverage(student.getAverage());
        report.setClassRank(student.getRank());
        report.setImprovementTips(generateTips(student));

        return report;
    }

    // 성과
    // - 성적표 발급: 2시간 → 10분 (92% 단축)
    // - 학부모 상담 준비: 30분 → 5분 (83% 단축)
    // - 학생별 맞춤 조언 제공으로 만족도 80% 향상
}
```

#### 사례 2: 기업 교육 - 이수 관리

```java
// 사용 목적: 기업 내부 교육 과정 이수 관리
// 규모: 직원 1,000-5,000명
// 효과: 교육 이수율 추적 자동화, 보고서 생성 1분

public class CorporateTrainingSystem {
    private GradeManager gradeManager;

    // 교육 과정 이수 여부
    public boolean isCoursePassed(Employee employee, String courseName) {
        Student record = gradeManager.findByName(employee.getName());
        return record.getAverage() >= 70.0;  // 70점 이상 이수
    }

    // 부서별 이수율
    public Map<String, Double> getCompletionRateByDepartment() {
        return gradeManager.findAll().stream()
            .collect(Collectors.groupingBy(
                s -> s.getStudentNumber().substring(0, 2),  // 부서 코드
                Collectors.averagingDouble(s ->
                    s.getAverage() >= 70 ? 100.0 : 0.0
                )
            ));
    }

    // 재교육 대상자 추출
    public List<Employee> getRetrainingCandidates() {
        return gradeManager.findAll().stream()
            .filter(s -> s.getAverage() < 70)
            .map(s -> new Employee(s.getName()))
            .collect(Collectors.toList());
    }

    // 성과
    // - 이수율 추적: 수동 집계 → 실시간 자동
    // - 재교육 대상 선정: 1일 → 1분
    // - 교육 효과 분석: 정량적 데이터 기반 의사결정
}
```

#### 사례 3: 온라인 강의 플랫폼

```java
// 사용 목적: 온라인 강의 플랫폼의 수강생 평가
// 규모: 수강생 10,000-100,000명
// 효과: 자동 수료증 발급, 추천 강의 제공

public class OnlineCoursePlatform {
    private GradeManager gradeManager;

    // 자동 수료증 발급
    public Certificate issueCertificate(Student student) {
        if (student.getAverage() >= 80 && student.getRank() <= 100) {
            return new Certificate(
                student.getName(),
                "우수 수료",
                LocalDate.now()
            );
        } else if (student.getAverage() >= 60) {
            return new Certificate(
                student.getName(),
                "일반 수료",
                LocalDate.now()
            );
        }
        return null;  // 미이수
    }

    // 추천 강의 (약한 과목 보완)
    public List<Course> recommendCourses(Student student) {
        Map<String, Integer> scores = student.getScores();
        String weakestSubject = scores.entrySet().stream()
            .min(Map.Entry.comparingByValue())
            .map(Map.Entry::getKey)
            .orElse(null);

        return courseRepository.findBySubject(weakestSubject);
    }

    // 리더보드 (게이미피케이션)
    public List<Student> getLeaderboard(int limit) {
        return gradeManager.findAll().stream()
            .sorted(Comparator.comparingDouble(Student::getAverage).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }

    // 성과
    // - 수료증 발급: 수동 → 자동 (100% 자동화)
    // - 수강생 만족도: 75% → 92% (23% 향상)
    // - 재수강률: 30% 증가 (추천 강의 효과)
}
```

### 성능 비교

| 방법 | 성적 입력 | 통계 계산 | 성적표 생성 | 오류율 |
|------|----------|----------|------------|--------|
| 수작업 (엑셀) | 30분 | 2시간 | 1시간 | 5% |
| 간단한 프로그램 | 10분 | 5분 | 10분 | 1% |
| 완성된 시스템 | 5분 | 1분 | 1분 | 0% |
| **개선** | **83%↓** | **99%↓** | **98%↓** | **100%↓** |

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 평균 계산 시 정수 나눗셈 문제

**상황**: 평균을 계산했는데 소수점이 모두 사라짐

```java
// ❌ 주니어 개발자가 작성한 코드
public class Student {
    private int korean;
    private int english;
    private int math;

    public double getAverage() {
        int sum = korean + english + math;
        return sum / 3;  // 정수 나눗셈!
    }
}

// 테스트
Student student = new Student(88, 92, 85);
System.out.println(student.getAverage());
// 예상: 88.33
// 실제: 88.0 (소수점 손실!)
```

**문제점**:
- 문제 1: int / int는 int 반환 (정수 나눗셈)
- 문제 2: 88.33이 88로 잘림
- 왜 이 문제가 발생하는가: Java의 타입 규칙을 모름

**해결책**:
```java
// ✅ 올바른 코드
public double getAverage() {
    int sum = korean + english + math;
    return (double) sum / 3;  // 실수 나눗셈
}

// 또는 더 명확하게
public double getAverage() {
    double sum = (double) (korean + english + math);
    return sum / 3.0;
}

// 또는 Stream 사용
public double getAverage() {
    return Stream.of(korean, english, math)
        .mapToInt(Integer::intValue)
        .average()
        .orElse(0.0);
}

// 테스트
Student student = new Student(88, 92, 85);
System.out.println(student.getAverage());
// 출력: 88.33333333333333
```

**배운 점**:
- 💡 팁 1: 하나라도 double이면 결과도 double
- 💡 팁 2: 명시적 형변환 (double) 사용

---

### 시나리오 2: 등급 산정 로직 오류 (경계값)

**상황**: 90점이 B 등급이 되는 버그 발생

```java
// ❌ 잘못된 코드
public String getGrade(double average) {
    if (average > 90) return "A";  // 90점 제외!
    if (average > 80) return "B";
    if (average > 70) return "C";
    if (average > 60) return "D";
    return "F";
}

// 테스트
System.out.println(getGrade(90));  // "B" (잘못됨!)
System.out.println(getGrade(80));  // "C" (잘못됨!)
```

**문제점**:
- 문제 1: `>`를 사용해 경계값 제외
- 문제 2: 90점은 A여야 하는데 B가 됨
- 왜 이 문제가 발생하는가: 등호(>=) 사용 안 함

**해결책**:
```java
// ✅ 올바른 코드
public String getGrade(double average) {
    if (average >= 90) return "A";  // 90점 이상
    if (average >= 80) return "B";  // 80점 이상
    if (average >= 70) return "C";
    if (average >= 60) return "D";
    return "F";
}

// 테스트
System.out.println(getGrade(90));   // "A" (올바름)
System.out.println(getGrade(89.9)); // "B" (올바름)
System.out.println(getGrade(80));   // "B" (올바름)

// 경계값 테스트 (단위 테스트)
@Test
public void testGradeBoundary() {
    assertEquals("A", getGrade(90.0));
    assertEquals("B", getGrade(89.9));
    assertEquals("B", getGrade(80.0));
    assertEquals("C", getGrade(79.9));
}
```

**배운 점**:
- 💡 팁 1: 경계값은 항상 포함 (>=)
- 💡 팁 2: 경계값 테스트 케이스 작성 필수

---

### 시나리오 3: null 체크 누락

**상황**: 학생 데이터가 없을 때 NullPointerException 발생

```java
// ❌ 잘못된 코드
public double getClassAverage(List<Student> students) {
    int sum = 0;
    for (Student s : students) {  // students가 null이면?
        sum += s.getAverage();     // s가 null이면?
    }
    return (double) sum / students.size();
}

// 사용
List<Student> students = null;
double avg = getClassAverage(students);  // NullPointerException!
```

**문제점**:
- 문제 1: students가 null일 수 있음
- 문제 2: students 내부의 Student도 null일 수 있음
- 왜 이 문제가 발생하는가: null 검사를 하지 않음

**해결책**:
```java
// ✅ 올바른 코드 (방법 1: 전통적 방식)
public double getClassAverage(List<Student> students) {
    if (students == null || students.isEmpty()) {
        return 0.0;
    }

    int sum = 0;
    int count = 0;
    for (Student s : students) {
        if (s != null) {  // null 체크
            sum += s.getAverage();
            count++;
        }
    }

    return count == 0 ? 0.0 : (double) sum / count;
}

// ✅ 더 나은 방법 (방법 2: Stream + filter)
public double getClassAverage(List<Student> students) {
    if (students == null) {
        return 0.0;
    }

    return students.stream()
        .filter(Objects::nonNull)  // null 제거
        .mapToDouble(Student::getAverage)
        .average()
        .orElse(0.0);
}

// ✅ 최선의 방법 (방법 3: Optional 사용)
public OptionalDouble getClassAverage(List<Student> students) {
    if (students == null) {
        return OptionalDouble.empty();
    }

    return students.stream()
        .filter(Objects::nonNull)
        .mapToDouble(Student::getAverage)
        .average();
}

// 사용
OptionalDouble avg = getClassAverage(students);
if (avg.isPresent()) {
    System.out.println("반 평균: " + avg.getAsDouble());
} else {
    System.out.println("데이터가 없습니다.");
}
```

**배운 점**:
- 💡 팁 1: 컬렉션은 null 대신 빈 리스트 반환
- 💡 팁 2: Stream의 filter(Objects::nonNull)로 null 제거

---

### 시나리오 4: 불변성 위반 (Student 수정 가능)

**상황**: Student 객체를 외부에서 수정하여 데이터 정합성 깨짐

```java
// ❌ 잘못된 코드
public class Student {
    public String name;  // public 필드!
    public int korean;
    public int english;
    public int math;
}

// 사용
Student student = new Student();
student.name = "김철수";
student.korean = 90;

// 나중에 다른 코드에서...
student.korean = 0;  // 실수로 수정!
```

**문제점**:
- 문제 1: public 필드로 직접 접근 가능
- 문제 2: 검증 없이 임의 값 설정 가능
- 왜 이 문제가 발생하는가: 캡슐화 원칙 위반

**해결책**:
```java
// ✅ 올바른 코드 (불변 객체)
public class Student {
    private final String name;
    private final int korean;
    private final int english;
    private final int math;

    public Student(String name, int korean, int english, int math) {
        this.name = name;
        this.korean = validateScore(korean);
        this.english = validateScore(english);
        this.math = validateScore(math);
    }

    private int validateScore(int score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("점수는 0-100 사이여야 합니다.");
        }
        return score;
    }

    // Getter만 제공 (Setter 없음)
    public String getName() { return name; }
    public int getKorean() { return korean; }
    public int getEnglish() { return english; }
    public int getMath() { return math; }

    // 수정이 필요하면 새 객체 생성
    public Student withKorean(int newKorean) {
        return new Student(name, newKorean, english, math);
    }
}

// 사용
Student student = new Student("김철수", 90, 85, 88);
// student.korean = 0;  // 컴파일 에러!

// 수정 필요 시 새 객체
Student updated = student.withKorean(95);
```

**배운 점**:
- 💡 팁 1: private 필드 + public getter
- 💡 팁 2: 불변 객체는 Thread-safe

---

## 🛠️ 실전 프로젝트

### 프로젝트: 완전한 성적 관리 시스템

**난이도**: ⭐⭐⭐⭐☆
**예상 소요 시간**: 6-8시간
**학습 목표**: 통계 기능과 리포트 생성이 포함된 완전한 시스템 구현

### 요구사항 분석

#### 기능 요구사항
- [ ] 학생 등록 (학번, 이름)
- [ ] 과목별 점수 입력
- [ ] 자동 평균 계산
- [ ] 등급 자동 산정 (A-F)
- [ ] 석차 자동 계산
- [ ] 통계 기능 (반평균, 최고점, 최저점)
- [ ] 성적표 출력
- [ ] 파일 저장/불러오기

#### 기술 요구사항
- [ ] Stream API 활용
- [ ] Optional 사용
- [ ] 람다 표현식
- [ ] 제네릭 컬렉션

#### 비기능 요구사항
- [ ] 성능: 1,000명 처리 1초 이내
- [ ] 정확성: 계산 오류 0%
- [ ] 사용성: 직관적인 메뉴

### 프로젝트 구조
```
grade-management/
├── src/
│   ├── Student.java
│   ├── Subject.java
│   ├── GradeManager.java
│   ├── GradeCalculator.java
│   ├── RankCalculator.java
│   ├── Statistics.java
│   ├── ReportGenerator.java
│   ├── FileManager.java
│   └── Main.java
└── data/
    └── students.dat
```

### 전체 소스 코드

#### Student.java (완전한 버전)
```java
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.*;

public class Student implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String studentNumber;
    private String name;
    private Map<String, Integer> scores;
    private LocalDateTime createdAt;

    // 계산된 값 (transient: 직렬화 제외)
    private transient double average;
    private transient int totalScore;
    private transient String grade;
    private transient int rank;

    public Student(String studentNumber, String name) {
        this.studentNumber = studentNumber;
        this.name = name;
        this.scores = new HashMap<>();
        this.createdAt = LocalDateTime.now();
    }

    // 점수 추가/수정
    public void setScore(String subject, int score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException(
                "점수는 0-100 사이여야 합니다: " + score);
        }
        scores.put(subject, score);
    }

    // 평균 계산
    public void calculateAverage() {
        if (scores.isEmpty()) {
            this.average = 0.0;
            this.totalScore = 0;
            return;
        }

        this.totalScore = scores.values().stream()
            .mapToInt(Integer::intValue)
            .sum();

        this.average = (double) totalScore / scores.size();
    }

    // Getters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getStudentNumber() { return studentNumber; }
    public String getName() { return name; }
    public Map<String, Integer> getScores() { return new HashMap<>(scores); }
    public double getAverage() { return average; }
    public int getTotalScore() { return totalScore; }
    public String getGrade() { return grade; }
    public int getRank() { return rank; }
    public LocalDateTime getCreatedAt() { return createdAt; }

    // Setters (계산된 값)
    public void setGrade(String grade) { this.grade = grade; }
    public void setRank(int rank) { this.rank = rank; }

    @Override
    public String toString() {
        return String.format("[%s] %s | 평균: %.2f | 등급: %s | 석차: %d",
            studentNumber, name, average, grade, rank);
    }

    public String toDetailString() {
        StringBuilder sb = new StringBuilder();
        sb.append("┌───────────────────────────────────────┐\n");
        sb.append(String.format("│ 학번: %-32s│\n", studentNumber));
        sb.append(String.format("│ 이름: %-32s│\n", name));
        sb.append("├───────────────────────────────────────┤\n");
        scores.forEach((subject, score) ->
            sb.append(String.format("│ %s: %d점%-24s│\n",
                subject, score, ""))
        );
        sb.append("├───────────────────────────────────────┤\n");
        sb.append(String.format("│ 총점: %d점%-27s│\n", totalScore, ""));
        sb.append(String.format("│ 평균: %.2f점%-25s│\n", average, ""));
        sb.append(String.format("│ 등급: %s%-31s│\n", grade, ""));
        sb.append(String.format("│ 석차: %d등%-29s│\n", rank, ""));
        sb.append("└───────────────────────────────────────┘");
        return sb.toString();
    }
}
```

#### GradeManager.java
```java
import java.util.*;
import java.util.stream.Collectors;

public class GradeManager {
    private Map<Long, Student> students;
    private Long nextId;

    public GradeManager() {
        this.students = new HashMap<>();
        this.nextId = 1L;
    }

    public GradeManager(Map<Long, Student> students, Long nextId) {
        this.students = students;
        this.nextId = nextId;
    }

    // 학생 추가
    public Student addStudent(String studentNumber, String name) {
        // 중복 체크
        boolean exists = students.values().stream()
            .anyMatch(s -> s.getStudentNumber().equals(studentNumber));

        if (exists) {
            throw new IllegalArgumentException(
                "이미 등록된 학번입니다: " + studentNumber);
        }

        Student student = new Student(studentNumber, name);
        student.setId(nextId++);
        students.put(student.getId(), student);

        System.out.println("✓ 학생이 등록되었습니다: " + name);
        return student;
    }

    // 점수 입력
    public void inputScores(Long id, Map<String, Integer> scores) {
        Student student = students.get(id);
        if (student == null) {
            throw new IllegalArgumentException("학생을 찾을 수 없습니다: " + id);
        }

        scores.forEach(student::setScore);
        updateStudent(student);

        System.out.println("✓ 점수가 입력되었습니다: " + student.getName());
    }

    // 학생 정보 업데이트 (평균, 등급, 석차)
    private void updateStudent(Student student) {
        student.calculateAverage();
        student.setGrade(GradeCalculator.calculateAbsoluteGrade(
            student.getAverage()));
        recalculateAllRanks();
    }

    // 전체 학생 석차 재계산
    private void recalculateAllRanks() {
        List<Student> sorted = students.values().stream()
            .sorted(Comparator.comparingDouble(Student::getAverage).reversed())
            .collect(Collectors.toList());

        for (int i = 0; i < sorted.size(); i++) {
            sorted.get(i).setRank(i + 1);
        }
    }

    // 조회
    public Student findById(Long id) {
        return students.get(id);
    }

    public List<Student> findAll() {
        return new ArrayList<>(students.values());
    }

    public List<Student> findByName(String keyword) {
        return students.values().stream()
            .filter(s -> s.getName().contains(keyword))
            .collect(Collectors.toList());
    }

    // 삭제
    public boolean delete(Long id) {
        Student removed = students.remove(id);
        if (removed != null) {
            recalculateAllRanks();
            System.out.println("✓ 학생이 삭제되었습니다: " + removed.getName());
            return true;
        }
        return false;
    }

    // 통계
    public Statistics getStatistics() {
        return new Statistics(findAll());
    }

    // 데이터 접근
    public Map<Long, Student> getStudents() {
        return students;
    }

    public Long getNextId() {
        return nextId;
    }

    public int count() {
        return students.size();
    }
}
```

#### GradeCalculator.java (확장 버전)
```java
import java.util.*;

public class GradeCalculator {
    // 절대평가
    public static String calculateAbsoluteGrade(double average) {
        if (average >= 90) return "A";
        if (average >= 80) return "B";
        if (average >= 70) return "C";
        if (average >= 60) return "D";
        return "F";
    }

    // 상대평가 (9등급제)
    public static String calculateRelativeGrade(int rank, int totalStudents) {
        if (totalStudents == 0) return "N/A";

        double percentile = (double) rank / totalStudents * 100;

        if (percentile <= 4) return "1등급";
        if (percentile <= 11) return "2등급";
        if (percentile <= 23) return "3등급";
        if (percentile <= 40) return "4등급";
        if (percentile <= 60) return "5등급";
        if (percentile <= 77) return "6등급";
        if (percentile <= 89) return "7등급";
        if (percentile <= 96) return "8등급";
        return "9등급";
    }

    // 학점 변환 (4.5 만점)
    public static double convertToGPA(String grade) {
        switch (grade) {
            case "A": return 4.5;
            case "B": return 3.5;
            case "C": return 2.5;
            case "D": return 1.5;
            case "F": return 0.0;
            default: return 0.0;
        }
    }

    // 4.0 만점 학점
    public static double convertToGPA4_0(String grade) {
        switch (grade) {
            case "A": return 4.0;
            case "B": return 3.0;
            case "C": return 2.0;
            case "D": return 1.0;
            case "F": return 0.0;
            default: return 0.0;
        }
    }

    // Pass/Fail
    public static boolean isPass(double average, double passingScore) {
        return average >= passingScore;
    }

    // 등급 분포
    public static Map<String, Long> getGradeDistribution(List<Student> students) {
        return students.stream()
            .collect(Collectors.groupingBy(
                Student::getGrade,
                Collectors.counting()
            ));
    }
}
```

#### Statistics.java (완전한 버전)
```java
import java.util.*;
import java.util.stream.Collectors;

public class Statistics {
    private List<Student> students;

    public Statistics(List<Student> students) {
        this.students = students;
    }

    // 반 평균
    public double getClassAverage() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .average()
            .orElse(0.0);
    }

    // 최고점
    public double getMaxScore() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .max()
            .orElse(0.0);
    }

    // 최저점
    public double getMinScore() {
        return students.stream()
            .mapToDouble(Student::getAverage)
            .min()
            .orElse(0.0);
    }

    // 최고점 학생
    public Optional<Student> getTopStudent() {
        return students.stream()
            .max(Comparator.comparingDouble(Student::getAverage));
    }

    // 최저점 학생
    public Optional<Student> getBottomStudent() {
        return students.stream()
            .min(Comparator.comparingDouble(Student::getAverage));
    }

    // 과목별 평균
    public Map<String, Double> getSubjectAverages() {
        return students.stream()
            .flatMap(s -> s.getScores().entrySet().stream())
            .collect(Collectors.groupingBy(
                Map.Entry::getKey,
                Collectors.averagingDouble(Map.Entry::getValue)
            ));
    }

    // 등급별 학생 수
    public Map<String, Long> countByGrade() {
        return students.stream()
            .collect(Collectors.groupingBy(
                Student::getGrade,
                TreeMap::new,
                Collectors.counting()
            ));
    }

    // 표준편차
    public double getStandardDeviation() {
        double mean = getClassAverage();
        double variance = students.stream()
            .mapToDouble(s -> Math.pow(s.getAverage() - mean, 2))
            .average()
            .orElse(0.0);
        return Math.sqrt(variance);
    }

    // 중앙값
    public double getMedian() {
        List<Double> sorted = students.stream()
            .map(Student::getAverage)
            .sorted()
            .collect(Collectors.toList());

        int size = sorted.size();
        if (size == 0) return 0.0;

        if (size % 2 == 0) {
            return (sorted.get(size / 2 - 1) + sorted.get(size / 2)) / 2.0;
        } else {
            return sorted.get(size / 2);
        }
    }

    // 합격률 (60점 기준)
    public double getPassRate() {
        if (students.isEmpty()) return 0.0;

        long passCount = students.stream()
            .filter(s -> s.getAverage() >= 60)
            .count();

        return (double) passCount / students.size() * 100;
    }

    @Override
    public String toString() {
        return String.format("""
            ╔═══════════════ 통계 정보 ═══════════════╗
            ║ 총 학생 수: %d명
            ║ 반 평균: %.2f점
            ║ 최고점: %.2f점
            ║ 최저점: %.2f점
            ║ 중앙값: %.2f점
            ║ 표준편차: %.2f
            ║ 합격률: %.1f%%
            ║
            ║ [등급 분포]
            %s
            ║
            ║ [과목별 평균]
            %s
            ╚═══════════════════════════════════════╝
            """,
            students.size(),
            getClassAverage(),
            getMaxScore(),
            getMinScore(),
            getMedian(),
            getStandardDeviation(),
            getPassRate(),
            formatGradeDistribution(),
            formatSubjectAverages()
        );
    }

    private String formatGradeDistribution() {
        Map<String, Long> dist = countByGrade();
        StringBuilder sb = new StringBuilder();
        dist.forEach((grade, count) ->
            sb.append(String.format("║ %s: %d명\n", grade, count))
        );
        return sb.toString().trim();
    }

    private String formatSubjectAverages() {
        Map<String, Double> subjectAvg = getSubjectAverages();
        StringBuilder sb = new StringBuilder();
        subjectAvg.forEach((subject, avg) ->
            sb.append(String.format("║ %s: %.2f점\n", subject, avg))
        );
        return sb.toString().trim();
    }
}
```

#### ReportGenerator.java
```java
import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class ReportGenerator {
    private static final String REPORT_DIR = "reports";

    // 개인 성적표
    public static void generateIndividualReport(Student student, String filename) {
        createReportDirectory();

        try (PrintWriter writer = new PrintWriter(
                new FileWriter(REPORT_DIR + File.separator + filename))) {

            writer.println("═══════════════════════════════════════");
            writer.println("            개인 성적표");
            writer.println("═══════════════════════════════════════");
            writer.println();
            writer.println("학번: " + student.getStudentNumber());
            writer.println("이름: " + student.getName());
            writer.println();
            writer.println("───────────────────────────────────────");
            writer.println("과목별 점수:");
            writer.println("───────────────────────────────────────");

            student.getScores().forEach((subject, score) ->
                writer.printf("%-10s: %3d점\n", subject, score)
            );

            writer.println("───────────────────────────────────────");
            writer.printf("총점: %d점\n", student.getTotalScore());
            writer.printf("평균: %.2f점\n", student.getAverage());
            writer.printf("등급: %s\n", student.getGrade());
            writer.printf("석차: %d등\n", student.getRank());
            writer.println("═══════════════════════════════════════");
            writer.println();
            writer.println("발급일: " + LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));

            System.out.println("✓ 성적표가 생성되었습니다: " + filename);
        } catch (IOException e) {
            System.err.println("✗ 성적표 생성 실패: " + e.getMessage());
        }
    }

    // 전체 성적표
    public static void generateClassReport(List<Student> students, String filename) {
        createReportDirectory();

        try (PrintWriter writer = new PrintWriter(
                new FileWriter(REPORT_DIR + File.separator + filename))) {

            writer.println("═══════════════════════════════════════════════════════");
            writer.println("                    반 전체 성적표");
            writer.println("═══════════════════════════════════════════════════════");
            writer.println();

            writer.printf("%-5s %-10s %-10s %5s %5s %5s %5s\n",
                "석차", "학번", "이름", "총점", "평균", "등급", "");

            writer.println("───────────────────────────────────────────────────────");

            students.stream()
                .sorted(Comparator.comparingInt(Student::getRank))
                .forEach(s -> writer.printf("%2d등 %-10s %-10s %5d %5.2f %5s\n",
                    s.getRank(),
                    s.getStudentNumber(),
                    s.getName(),
                    s.getTotalScore(),
                    s.getAverage(),
                    s.getGrade()
                ));

            writer.println("═══════════════════════════════════════════════════════");

            Statistics stats = new Statistics(students);
            writer.println();
            writer.println("[통계 정보]");
            writer.printf("총 학생 수: %d명\n", students.size());
            writer.printf("반 평균: %.2f점\n", stats.getClassAverage());
            writer.printf("최고점: %.2f점\n", stats.getMaxScore());
            writer.printf("최저점: %.2f점\n", stats.getMinScore());
            writer.printf("합격률: %.1f%%\n", stats.getPassRate());

            writer.println();
            writer.println("발급일: " + LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));

            System.out.println("✓ 전체 성적표가 생성되었습니다: " + filename);
        } catch (IOException e) {
            System.err.println("✗ 성적표 생성 실패: " + e.getMessage());
        }
    }

    private static void createReportDirectory() {
        File dir = new File(REPORT_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }
}
```

#### FileManager.java
```java
import java.io.*;
import java.util.*;

public class FileManager {
    private static final String DATA_DIR = "data";
    private static final String FILE_NAME = "students.dat";
    private static final String FILE_PATH = DATA_DIR + File.separator + FILE_NAME;

    // 저장
    public static void save(GradeManager manager) {
        createDataDirectory();

        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(FILE_PATH))) {

            SaveData data = new SaveData(
                manager.getStudents(),
                manager.getNextId()
            );

            oos.writeObject(data);
            System.out.println("✓ 파일에 저장되었습니다: " + FILE_PATH);
        } catch (IOException e) {
            System.err.println("✗ 저장 실패: " + e.getMessage());
        }
    }

    // 로드
    public static GradeManager load() {
        File file = new File(FILE_PATH);

        if (!file.exists()) {
            System.out.println("저장된 파일이 없습니다. 새로 시작합니다.");
            return new GradeManager();
        }

        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(FILE_PATH))) {

            SaveData data = (SaveData) ois.readObject();
            System.out.println("✓ 파일을 불러왔습니다: " +
                             data.students.size() + "명의 학생");

            GradeManager manager = new GradeManager(data.students, data.nextId);

            // 계산된 값 복원
            manager.findAll().forEach(student -> {
                student.calculateAverage();
                student.setGrade(GradeCalculator.calculateAbsoluteGrade(
                    student.getAverage()));
            });

            return manager;
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("✗ 로드 실패: " + e.getMessage());
            return new GradeManager();
        }
    }

    private static void createDataDirectory() {
        File dir = new File(DATA_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }

    // 저장 데이터 래퍼
    private static class SaveData implements Serializable {
        private static final long serialVersionUID = 1L;
        Map<Long, Student> students;
        Long nextId;

        SaveData(Map<Long, Student> students, Long nextId) {
            this.students = students;
            this.nextId = nextId;
        }
    }
}
```

#### Main.java
```java
import java.util.*;

public class Main {
    private static GradeManager manager;
    private static Scanner scanner = new Scanner(System.in);
    private static boolean running = true;

    public static void main(String[] args) {
        System.out.println("╔═══════════════════════════════════════╗");
        System.out.println("║       성적 관리 시스템 v1.0          ║");
        System.out.println("╚═══════════════════════════════════════╝\n");

        manager = FileManager.load();

        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("\n프로그램을 종료합니다...");
            FileManager.save(manager);
        }));

        while (running) {
            showMenu();
            int choice = readInt("선택: ");
            System.out.println();

            handleMenuChoice(choice);
        }
    }

    private static void showMenu() {
        System.out.println("\n┌─────────────────────────────────────┐");
        System.out.println("│           메인 메뉴                 │");
        System.out.println("├─────────────────────────────────────┤");
        System.out.println("│ 1. 학생 등록                        │");
        System.out.println("│ 2. 점수 입력                        │");
        System.out.println("│ 3. 전체 학생 조회                   │");
        System.out.println("│ 4. 학생 검색                        │");
        System.out.println("│ 5. 통계 보기                        │");
        System.out.println("│ 6. 개인 성적표 생성                 │");
        System.out.println("│ 7. 전체 성적표 생성                 │");
        System.out.println("│ 8. 학생 삭제                        │");
        System.out.println("│ 9. 저장                             │");
        System.out.println("│ 0. 종료                             │");
        System.out.println("└─────────────────────────────────────┘");
        System.out.println("현재 학생 수: " + manager.count() + "명");
    }

    private static void handleMenuChoice(int choice) {
        switch (choice) {
            case 1: registerStudent(); break;
            case 2: inputScores(); break;
            case 3: listAllStudents(); break;
            case 4: searchStudent(); break;
            case 5: showStatistics(); break;
            case 6: generateIndividualReport(); break;
            case 7: generateClassReport(); break;
            case 8: deleteStudent(); break;
            case 9: FileManager.save(manager); break;
            case 0: exitProgram(); break;
            default: System.out.println("✗ 잘못된 선택입니다.");
        }
    }

    // 1. 학생 등록
    private static void registerStudent() {
        System.out.println("=== 학생 등록 ===");

        String studentNumber = readLine("학번: ");
        String name = readLine("이름: ");

        try {
            manager.addStudent(studentNumber, name);
        } catch (IllegalArgumentException e) {
            System.out.println("✗ 등록 실패: " + e.getMessage());
        }
    }

    // 2. 점수 입력
    private static void inputScores() {
        System.out.println("=== 점수 입력 ===");

        long id = readLong("학생 ID: ");
        Student student = manager.findById(id);

        if (student == null) {
            System.out.println("✗ 학생을 찾을 수 없습니다.");
            return;
        }

        System.out.println("학생: " + student.getName());
        System.out.println("과목 점수를 입력하세요 (종료: 빈 줄)");

        Map<String, Integer> scores = new HashMap<>();
        while (true) {
            String subject = readLine("과목명: ");
            if (subject.isEmpty()) break;

            int score = readInt("점수: ");
            scores.put(subject, score);
        }

        try {
            manager.inputScores(id, scores);
        } catch (IllegalArgumentException e) {
            System.out.println("✗ 입력 실패: " + e.getMessage());
        }
    }

    // 3. 전체 학생 조회
    private static void listAllStudents() {
        List<Student> students = manager.findAll();

        if (students.isEmpty()) {
            System.out.println("등록된 학생이 없습니다.");
            return;
        }

        System.out.println("=== 전체 학생 목록 (" + students.size() + "명) ===\n");

        students.stream()
            .sorted(Comparator.comparingInt(Student::getRank))
            .forEach(System.out::println);
    }

    // 4. 학생 검색
    private static void searchStudent() {
        System.out.println("=== 학생 검색 ===");

        String keyword = readLine("이름 검색: ");
        List<Student> results = manager.findByName(keyword);

        if (results.isEmpty()) {
            System.out.println("검색 결과가 없습니다.");
            return;
        }

        System.out.println("\n검색 결과: " + results.size() + "명\n");
        results.forEach(s -> System.out.println(s.toDetailString()));
    }

    // 5. 통계 보기
    private static void showStatistics() {
        if (manager.count() == 0) {
            System.out.println("등록된 학생이 없습니다.");
            return;
        }

        Statistics stats = manager.getStatistics();
        System.out.println(stats);

        // 최고점/최저점 학생
        stats.getTopStudent().ifPresent(s ->
            System.out.println("최고점 학생: " + s));
        stats.getBottomStudent().ifPresent(s ->
            System.out.println("최저점 학생: " + s));
    }

    // 6. 개인 성적표
    private static void generateIndividualReport() {
        System.out.println("=== 개인 성적표 생성 ===");

        long id = readLong("학생 ID: ");
        Student student = manager.findById(id);

        if (student == null) {
            System.out.println("✗ 학생을 찾을 수 없습니다.");
            return;
        }

        String filename = student.getStudentNumber() + "_성적표.txt";
        ReportGenerator.generateIndividualReport(student, filename);
    }

    // 7. 전체 성적표
    private static void generateClassReport() {
        if (manager.count() == 0) {
            System.out.println("✗ 등록된 학생이 없습니다.");
            return;
        }

        String filename = "전체_성적표.txt";
        ReportGenerator.generateClassReport(manager.findAll(), filename);
    }

    // 8. 학생 삭제
    private static void deleteStudent() {
        System.out.println("=== 학생 삭제 ===");

        long id = readLong("학생 ID: ");
        Student student = manager.findById(id);

        if (student == null) {
            System.out.println("✗ 학생을 찾을 수 없습니다.");
            return;
        }

        System.out.println(student.toDetailString());

        if (confirm("\n정말 삭제하시겠습니까?")) {
            manager.delete(id);
        } else {
            System.out.println("취소되었습니다.");
        }
    }

    // 0. 종료
    private static void exitProgram() {
        if (confirm("\n저장하고 종료하시겠습니까?")) {
            FileManager.save(manager);
        }
        running = false;
        System.out.println("\n프로그램을 종료합니다. 안녕히 가세요!");
    }

    // 입력 헬퍼
    private static String readLine(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine().trim();
    }

    private static int readInt(String prompt) {
        while (true) {
            try {
                System.out.print(prompt);
                return Integer.parseInt(scanner.nextLine().trim());
            } catch (NumberFormatException e) {
                System.out.println("✗ 숫자를 입력해주세요.");
            }
        }
    }

    private static long readLong(String prompt) {
        while (true) {
            try {
                System.out.print(prompt);
                return Long.parseLong(scanner.nextLine().trim());
            } catch (NumberFormatException e) {
                System.out.println("✗ 숫자를 입력해주세요.");
            }
        }
    }

    private static boolean confirm(String message) {
        String answer = readLine(message + " (y/n): ");
        return answer.equalsIgnoreCase("y") || answer.equalsIgnoreCase("yes");
    }
}
```

### 실행 결과 화면
```
╔═══════════════════════════════════════╗
║       성적 관리 시스템 v1.0          ║
╚═══════════════════════════════════════╝

저장된 파일이 없습니다. 새로 시작합니다.

┌─────────────────────────────────────┐
│           메인 메뉴                 │
├─────────────────────────────────────┤
│ 1. 학생 등록                        │
│ 2. 점수 입력                        │
│ 3. 전체 학생 조회                   │
│ 4. 학생 검색                        │
│ 5. 통계 보기                        │
│ 6. 개인 성적표 생성                 │
│ 7. 전체 성적표 생성                 │
│ 8. 학생 삭제                        │
│ 9. 저장                             │
│ 0. 종료                             │
└─────────────────────────────────────┘
현재 학생 수: 0명
선택: 1

=== 학생 등록 ===
학번: 2024001
이름: 김철수
✓ 학생이 등록되었습니다: 김철수

[메뉴 반복...]
선택: 2

=== 점수 입력 ===
학생 ID: 1
학생: 김철수
과목 점수를 입력하세요 (종료: 빈 줄)
과목명: 국어
점수: 90
과목명: 영어
점수: 85
과목명: 수학
점수: 92
과목명:
✓ 점수가 입력되었습니다: 김철수

[메뉴 반복...]
선택: 5

╔═══════════════ 통계 정보 ═══════════════╗
║ 총 학생 수: 3명
║ 반 평균: 85.33점
║ 최고점: 89.00점
║ 최저점: 80.67점
║ 중앙값: 86.67점
║ 표준편차: 3.69
║ 합격률: 100.0%
║
║ [등급 분포]
║ B: 3명
║
║ [과목별 평균]
║ 국어: 88.33점
║ 영어: 81.67점
║ 수학: 86.00점
╚═══════════════════════════════════════╝
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: 평균 계산 시 소수점 몇 자리까지 표시하나요?</strong></summary>

**A**: 보통 소수점 2자리까지 표시합니다.

**상세 설명**:
- 포인트 1: `String.format("%.2f", average)`로 2자리 제한
- 포인트 2: 내부 계산은 double 정밀도 유지
- 포인트 3: 출력 시에만 반올림

**예시**:
```java
public String getAverageFormatted() {
    return String.format("%.2f", average);  // 87.666666 → "87.67"
}

// DecimalFormat 사용
DecimalFormat df = new DecimalFormat("#.##");
String formatted = df.format(average);  // "87.67"
```

**실무 팁**:
💡 DB 저장은 double 그대로, 화면 출력만 포맷팅
</details>

<details>
<summary><strong>Q2: 상대평가와 절대평가의 차이는?</strong></summary>

**A**: 절대평가는 고정 기준, 상대평가는 상대적 순위로 평가합니다.

**상세 설명**:
- 포인트 1: 절대평가 - 90점 이상 A (모두 A 가능)
- 포인트 2: 상대평가 - 상위 10% A (1등만 A 가능)
- 포인트 3: 한국 수능은 상대평가 (9등급제)

**비교표**:
```
점수    | 절대평가  | 상대평가
--------|-----------|----------
95점    | A         | 석차에 따라
90점    | A         | 다름
85점    | B         | (상위 4% → 1등급)
80점    | B         | (상위 11% → 2등급)
```

**실무 팁**:
💡 공정성 논란 시 절대평가 선호
</details>

<details>
<summary><strong>Q3: 석차는 동점자를 어떻게 처리하나요?</strong></summary>

**A**: 여러 방식이 있으며, 프로젝트 요구사항에 따라 선택합니다.

**상세 설명**:
- 포인트 1: 공동 석차 (1등, 1등, 3등)
- 포인트 2: 등수 건너뛰기 (1등, 1등, 3등) → 가장 일반적
- 포인트 3: 과목별 비교 (국어 점수로 2차 정렬)

**구현 예시**:
```java
// 방법 1: 공동 석차
List<Student> sorted = students.stream()
    .sorted(Comparator.comparingDouble(Student::getAverage).reversed())
    .collect(Collectors.toList());

int rank = 1;
for (int i = 0; i < sorted.size(); i++) {
    if (i > 0 && sorted.get(i).getAverage() == sorted.get(i-1).getAverage()) {
        sorted.get(i).setRank(sorted.get(i-1).getRank());  // 동점은 같은 등수
    } else {
        sorted.get(i).setRank(rank);
    }
    rank++;
}

// 방법 2: 과목별 비교
Comparator<Student> comparator = Comparator
    .comparingDouble(Student::getAverage).reversed()
    .thenComparingInt(s -> -s.getScores().get("국어"))  // 2차: 국어 점수
    .thenComparingInt(s -> -s.getScores().get("영어"));  // 3차: 영어 점수
```

**실무 팁**:
💡 요구사항 명확히 확인 후 구현
</details>

<details>
<summary><strong>Q4: 표준편차는 무엇이며 왜 필요한가요?</strong></summary>

**A**: 점수의 분산 정도를 나타내며, 학습 수준 파악에 유용합니다.

**상세 설명**:
- 포인트 1: 표준편차가 작을수록 점수가 고름
- 포인트 2: 표준편차가 크면 학생 간 실력 차이 큼
- 포인트 3: 교육 정책 결정에 활용

**예시**:
```
반 A: 평균 80점, 표준편차 5
→ 대부분 75-85점 분포 (고른 수준)

반 B: 평균 80점, 표준편차 20
→ 50-100점까지 다양 (실력 차이 큼)

📊 표준편차 해석:
- 0-5: 매우 고름
- 5-10: 보통
- 10-20: 차이 있음
- 20+: 큰 차이
```

**계산 공식**:
```
표준편차 = √(분산)
분산 = Σ(점수 - 평균)² / 학생수
```

**실무 팁**:
💡 반 편성, 수준별 학습에 활용
</details>

<details>
<summary><strong>Q5: 가중평균은 어떻게 계산하나요?</strong></summary>

**A**: 과목별 중요도에 따라 가중치를 적용합니다.

**상세 설명**:
- 포인트 1: 주요 과목에 더 높은 가중치
- 포인트 2: 가중치 합은 1.0 (또는 100%)
- 포인트 3: 대학 입시, 채용 시 활용

**예시**:
```java
public double calculateWeightedAverage(Map<String, Double> weights) {
    double sum = 0.0;
    double weightSum = 0.0;

    for (Map.Entry<String, Integer> entry : scores.entrySet()) {
        String subject = entry.getKey();
        int score = entry.getValue();
        double weight = weights.getOrDefault(subject, 1.0);

        sum += score * weight;
        weightSum += weight;
    }

    return weightSum == 0 ? 0 : sum / weightSum;
}

// 사용 예시
Map<String, Double> weights = Map.of(
    "국어", 0.4,   // 40%
    "영어", 0.3,   // 30%
    "수학", 0.3    // 30%
);

double weighted = student.calculateWeightedAverage(weights);
// 국어 90점, 영어 80점, 수학 70점
// 가중평균 = (90*0.4 + 80*0.3 + 70*0.3) = 81점
```

**실무 팁**:
💡 입시 전형별 가중치 다르므로 주의
</details>

<details>
<summary><strong>Q6: 성적 데이터를 엑셀로 내보낼 수 있나요?</strong></summary>

**A**: CSV로 내보내거나 Apache POI 라이브러리로 직접 Excel 생성 가능합니다.

**상세 설명**:
- 포인트 1: CSV는 간단하지만 Excel 호환
- 포인트 2: Apache POI는 .xlsx 직접 생성
- 포인트 3: 차트, 수식도 추가 가능

**CSV 예시**:
```java
public void exportToCSV(String filename) {
    try (PrintWriter writer = new PrintWriter(filename)) {
        writer.println("학번,이름,국어,영어,수학,평균,등급,석차");

        manager.findAll().forEach(s -> {
            writer.printf("%s,%s,%d,%d,%d,%.2f,%s,%d\n",
                s.getStudentNumber(),
                s.getName(),
                s.getScores().get("국어"),
                s.getScores().get("영어"),
                s.getScores().get("수학"),
                s.getAverage(),
                s.getGrade(),
                s.getRank()
            );
        });
    }
}
```

**실무 팁**:
💡 CSV는 UTF-8 BOM으로 저장 (한글 깨짐 방지)
</details>

<details>
<summary><strong>Q7: 재시험이나 추가 시험은 어떻게 관리하나요?</strong></summary>

**A**: 시험 이력을 리스트로 관리하고, 최종 점수를 선택합니다.

**상세 설명**:
- 포인트 1: 각 시험을 Exam 객체로 저장
- 포인트 2: 최고점/최신점/평균점 중 선택
- 포인트 3: 이력 조회 가능

**구현 예시**:
```java
public class Student {
    private List<Exam> exams = new ArrayList<>();

    public void addExam(Exam exam) {
        exams.add(exam);
    }

    // 최고점 선택
    public int getBestScore(String subject) {
        return exams.stream()
            .filter(e -> e.getSubject().equals(subject))
            .mapToInt(Exam::getScore)
            .max()
            .orElse(0);
    }

    // 최신 점수 선택
    public int getLatestScore(String subject) {
        return exams.stream()
            .filter(e -> e.getSubject().equals(subject))
            .reduce((first, second) -> second)  // 마지막 요소
            .map(Exam::getScore)
            .orElse(0);
    }
}

class Exam {
    private String subject;
    private int score;
    private LocalDateTime examDate;

    // Constructor, getters...
}
```

**실무 팁**:
💡 정책에 따라 최고점 vs 최신점 선택
</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. 평균 계산 시 주의할 점은?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 정수 나눗셈 문제 (int / int = int)
- 포인트 2: 형변환 필요 ((double) sum / count)
- 포인트 3: 0으로 나누기 예외 처리
- 포인트 4: 소수점 정밀도 유지

**예시 답변**
> "평균 계산 시 가장 주의할 점은 정수 나눗셈입니다. Java에서 int / int는 int를 반환하므로 소수점이 버려집니다. 따라서 (double) sum / count처럼 하나 이상을 double로 형변환해야 합니다. 또한 학생 수가 0일 때 0으로 나누기 오류가 발생하므로 예외 처리가 필요합니다."

**코드 예시**:
```java
public double getAverage() {
    if (scores.isEmpty()) return 0.0;
    int sum = getTotalScore();
    return (double) sum / scores.size();  // 형변환 필수
}
```

**실무 연관**
- 금액 계산, 비율 계산 등 모든 곳에 적용
</details>

<details>
<summary><strong>2. 등급 산정 시 경계값 처리는?</strong></summary>

**모범 답안 포인트**
- 포인트 1: `>=` 사용 (이상/이하)
- 포인트 2: `>` 사용 시 경계값 제외
- 포인트 3: 단위 테스트로 검증
- 포인트 4: 명확한 기준 문서화

**예시 답변**
> "등급 산정 시 90점이 A인지 B인지 명확해야 합니다. 보통 '90점 이상 A'라고 하므로 `if (average >= 90)`로 작성합니다. `>`를 사용하면 90점이 B가 되는 버그가 발생합니다. 경계값(90, 80, 70, 60)에 대한 단위 테스트를 작성하여 검증합니다."

**코드 예시**:
```java
public String getGrade(double avg) {
    if (avg >= 90) return "A";  // 90점 이상
    if (avg >= 80) return "B";  // 80점 이상 90점 미만
    // ...
}

// 단위 테스트
@Test
public void testGradeBoundaries() {
    assertEquals("A", getGrade(90.0));   // 경계값
    assertEquals("B", getGrade(89.99));  // 경계값 바로 아래
}
```

**실무 연관**
- 모든 조건문에서 경계값 처리 중요
</details>

<details>
<summary><strong>3. 컬렉션 선택 기준은? (List vs Map)</strong></summary>

**모범 답안 포인트**
- 포인트 1: 순서 필요 → List
- 포인트 2: 빠른 조회 필요 → Map
- 포인트 3: 중복 허용 여부
- 포인트 4: 성능 고려

**예시 답변**
> "학생 목록은 List, 학생 ID로 조회는 Map을 사용합니다. List는 순서를 유지하고 순회에 적합하지만, ID로 조회 시 O(n)입니다. Map은 키로 O(1)에 조회하지만 순서가 없습니다. 실무에서는 Map<Long, Student>로 저장하고, 필요시 new ArrayList<>(map.values())로 변환합니다."

**성능 비교**:
```
데이터 1,000명:
List 조회: O(n) = 500번 평균
Map 조회: O(1) = 1번

결론: ID 조회가 빈번하면 Map 필수
```

**실무 연관**
- 데이터 액세스 패턴에 따라 자료구조 선택
</details>

<details>
<summary><strong>4. Stream API를 왜 사용하나요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 선언적 코드 (무엇을 할지 명시)
- 포인트 2: 함수형 프로그래밍
- 포인트 3: 가독성 향상
- 포인트 4: 병렬 처리 쉬움

**예시 답변**
> "Stream API는 코드를 더 읽기 쉽게 만듭니다. 'for 루프로 필터링하고 변환하고 수집'하는 대신 '.filter().map().collect()'로 의도를 명확히 표현합니다. 또한 .parallelStream()으로 쉽게 병렬 처리할 수 있어 대량 데이터 처리에 유리합니다."

**비교**:
```java
// 전통적 방식
List<String> result = new ArrayList<>();
for (Student s : students) {
    if (s.getAverage() >= 80) {
        result.add(s.getName());
    }
}

// Stream 방식
List<String> result = students.stream()
    .filter(s -> s.getAverage() >= 80)
    .map(Student::getName)
    .collect(Collectors.toList());
```

**실무 연관**
- 현대 Java 개발의 표준
</details>

<details>
<summary><strong>5. transient 키워드는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 직렬화에서 제외
- 포인트 2: 임시 계산 값에 사용
- 포인트 3: 복원 시 재계산 필요
- 포인트 4: 보안 민감 정보에도 사용

**예시 답변**
> "transient는 직렬화 시 해당 필드를 제외합니다. Student 클래스에서 average, grade, rank는 계산된 값이므로 저장할 필요가 없습니다. 파일에서 로드 후 calculateAverage()로 재계산하면 됩니다. 이렇게 하면 파일 크기가 줄고 데이터 일관성이 유지됩니다."

**코드 예시**:
```java
public class Student implements Serializable {
    private String name;
    private int korean;

    private transient double average;  // 직렬화 제외

    // 로드 후 재계산
    private void readObject(ObjectInputStream ois)
            throws IOException, ClassNotFoundException {
        ois.defaultReadObject();
        calculateAverage();  // 복원 후 계산
    }
}
```

**실무 연관**
- 캐시 데이터, 계산된 값 관리
</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. 전략 패턴을 등급 계산에 어떻게 적용하나요?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: GradingStrategy 인터페이스 정의
- 심화 포인트 2: 절대평가/상대평가 구현체
- 심화 포인트 3: 런타임에 전략 교체 가능
- 심화 포인트 4: 개방-폐쇄 원칙 준수

**예시 답변**
> "GradingStrategy 인터페이스를 정의하고, AbsoluteGrading과 RelativeGrading 구현체를 만듭니다. Student가 GradingStrategy를 주입받아 사용하면, 등급 기준을 쉽게 변경할 수 있습니다. 새로운 등급 기준이 추가되어도 기존 코드를 수정하지 않아도 됩니다."

**구현 예시**:
```java
interface GradingStrategy {
    String calculateGrade(double average, int rank, int total);
}

class AbsoluteGrading implements GradingStrategy {
    @Override
    public String calculateGrade(double average, int rank, int total) {
        if (average >= 90) return "A";
        // ...
    }
}

class RelativeGrading implements GradingStrategy {
    @Override
    public String calculateGrade(double average, int rank, int total) {
        double percentile = (double) rank / total * 100;
        if (percentile <= 10) return "A";
        // ...
    }
}

// 사용
Student student = new Student("김철수");
student.setGradingStrategy(new AbsoluteGrading());
// 또는
student.setGradingStrategy(new RelativeGrading());
```

**실무 연관**
- 정책 변경에 유연한 시스템 설계
</details>

<details>
<summary><strong>2. 제네릭을 활용한 타입 안전성 확보는?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: `GradeManager<T extends Student>`
- 심화 포인트 2: 컴파일 타임 타입 체크
- 심화 포인트 3: 형변환 불필요
- 심화 포인트 4: 재사용성 향상

**예시 답변**
> "제네릭을 사용하면 GradeManager가 Student뿐만 아니라 GraduateStudent, TransferStudent 등 다양한 타입을 처리할 수 있습니다. 타입 안전성이 보장되어 런타임 오류가 줄고, 코드 재사용성이 높아집니다."

**구현 예시**:
```java
public class GradeManager<T extends Student> {
    private Map<Long, T> students;

    public void add(T student) {
        students.put(student.getId(), student);
    }

    public T findById(Long id) {
        return students.get(id);  // 형변환 불필요
    }

    public List<T> findAll() {
        return new ArrayList<>(students.values());
    }
}

// 사용
GradeManager<RegularStudent> regularManager = new GradeManager<>();
GradeManager<HonorStudent> honorManager = new GradeManager<>();

// 컴파일 에러 방지
regularManager.add(new RegularStudent(...));  // OK
// regularManager.add(new HonorStudent(...));  // 컴파일 에러!
```

**실무 연관**
- 프레임워크 설계 시 필수
</details>

<details>
<summary><strong>3. 대량 데이터 통계 계산 최적화는?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: Stream의 병렬 처리
- 심화 포인트 2: 캐싱으로 재계산 방지
- 심화 포인트 3: 증분 계산 (Incremental Update)
- 심화 포인트 4: 인덱싱

**예시 답변**
> "10만 명 이상의 학생 데이터는 parallelStream()으로 병렬 처리합니다. 통계값은 LRU Cache에 저장하여 재계산을 방지하고, 학생 추가/수정 시 전체 재계산 대신 증분 업데이트합니다. 또한 과목별, 등급별 인덱스를 구축하여 조회 성능을 향상시킵니다."

**구현 예시**:
```java
public class CachedStatistics {
    private Map<String, Object> cache = new ConcurrentHashMap<>();
    private GradeManager manager;

    public double getClassAverage() {
        return (double) cache.computeIfAbsent("classAverage", k ->
            manager.findAll().parallelStream()
                .mapToDouble(Student::getAverage)
                .average()
                .orElse(0.0)
        );
    }

    // 학생 추가 시 캐시 무효화
    public void invalidateCache() {
        cache.clear();
    }

    // 증분 업데이트
    public void updateAverageIncremental(Student newStudent) {
        double oldAvg = (double) cache.getOrDefault("classAverage", 0.0);
        int count = manager.count();
        double newAvg = (oldAvg * (count - 1) + newStudent.getAverage()) / count;
        cache.put("classAverage", newAvg);
    }
}
```

**실무 연관**
- 빅데이터 분석 시스템
</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 평균 계산 | 점수 합계 / 과목 수 | `(double) sum / count` |
| 등급 산정 | 평균에 따라 A-F 부여 | `if (avg >= 90) "A"` |
| 석차 계산 | 평균 기준 정렬 후 순위 | `Comparator.comparingDouble()` |
| 통계 분석 | 최고/최저/평균/표준편차 | `Stream.mapToDouble()` |
| 상대평가 | 상대적 순위로 등급 | 백분위, 9등급제 |
| 성적표 생성 | 텍스트 파일 출력 | `PrintWriter` |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| `mapToDouble()` | Stream을 double로 변환 | `.mapToDouble(Student::getAverage)` |
| `average()` | 평균 계산 | `.average().orElse(0.0)` |
| `max()/min()` | 최대/최소값 | `.max(Comparator.comparing())` |
| `groupingBy()` | 그룹화 | `Collectors.groupingBy(Student::getGrade)` |
| `comparingDouble()` | double 비교자 | `Comparator.comparingDouble()` |
| `String.format()` | 문자열 포맷팅 | `String.format("%.2f", avg)` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 평균 계산은 double 사용
- [ ] 경계값 테스트 작성
- [ ] Stream API로 통계 계산
- [ ] 계산된 값은 transient
- [ ] 성적표는 파일로 저장

#### ❌ 하지 말아야 할 것
- [ ] 정수 나눗셈 금지
- [ ] 등급 기준 하드코딩 금지
- [ ] null 체크 누락 금지
- [ ] 경계값 처리 오류 금지
- [ ] 불변 객체 수정 금지

### 성능/보안 체크리스트

#### 성능
- [ ] 대량 데이터는 병렬 스트림
- [ ] 통계는 캐싱
- [ ] 석차는 정렬 1회만
- [ ] 인덱스 활용
- [ ] 증분 업데이트

#### 보안
- [ ] 성적 조회 권한 체크
- [ ] 개인 정보 암호화
- [ ] 파일 권한 설정
- [ ] 로그에 민감 정보 제외
- [ ] 백업 주기 설정

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Apache POI | Excel 파일 생성 | ⭐⭐⭐⭐ |
| JFreeChart | 차트 생성 | ⭐⭐⭐ |
| iText | PDF 생성 | ⭐⭐⭐⭐ |
| Spring Batch | 대량 데이터 처리 | ⭐⭐⭐⭐ |
| Thymeleaf | 웹 리포트 | ⭐⭐⭐⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: 50장 - 도서관 관리 시스템 (종합 프로젝트)

- **배울 내용 1**: 복합 엔티티 설계 (Book, Member, Loan)
- **배울 내용 2**: 대출/반납 비즈니스 로직
- **배울 내용 3**: 연체료 계산 및 통계
- **실전 프로젝트**: 800줄 이상의 종합 프로젝트

### 이 장과의 연결점
```
이번 장에서 배운 [통계 기능과 등급 시스템]
    ↓
다음 장에서 [복합 엔티티 관계와 비즈니스 로직]
    ↓
최종적으로 [실무 수준의 종합 관리 시스템]
```

### 준비하면 좋을 것들
```bash
# 날짜/시간 처리 복습
LocalDate, LocalDateTime, Period, Duration

# 연관 관계 이해
OneToMany, ManyToOne (JPA 개념)
```

---

## 🎉 축하합니다!

**이제 여러분은**:
✅ 통계 기능을 구현할 수 있습니다
✅ 등급 시스템을 자동화할 수 있습니다
✅ Stream API로 데이터를 분석할 수 있습니다
✅ 실무에서 사용 가능한 성적 관리 시스템을 만들 수 있습니다

**다음 단계**:
- [ ] 다음 장으로 진행 (도서관 관리 시스템)
- [ ] 차트 생성 기능 추가 (JFreeChart)
- [ ] 웹 버전으로 업그레이드 (Spring Boot)

---

**다음 장으로 이동**: [다음: 50장 도서관 관리 시스템 →](50-도서관-관리-시스템.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
