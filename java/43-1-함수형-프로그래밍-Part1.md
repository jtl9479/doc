# 43ì¥ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° - Part 1: ì‹¤ìƒí™œ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

## ğŸ“š ëª©ì°¨
1. [í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ë€?](#í•¨ìˆ˜í˜•-í”„ë¡œê·¸ë˜ë°ì´ë€)
2. [ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°](#ë¹„ìœ ë¡œ-ì´í•´í•˜ê¸°)
3. [í•µì‹¬ ê°œë…](#í•µì‹¬-ê°œë…)
4. [ì‹¤ì „ ì˜ˆì œ](#ì‹¤ì „-ì˜ˆì œ)

---

## ğŸ¯ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì´ë€?

### ëª…ë ¹í˜• vs ì„ ì–¸í˜•

```java
// ğŸ”´ ëª…ë ¹í˜• (Imperative) - "ì–´ë–»ê²Œ(How)"
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> result = new ArrayList<>();

for (String name : names) {
    if (name.length() > 3) {
        String upper = name.toUpperCase();
        result.add(upper);
    }
}

// ğŸŸ¢ ì„ ì–¸í˜• (Declarative) - "ë¬´ì—‡ì„(What)"
List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

**ì°¨ì´ì **:
- **ëª…ë ¹í˜•**: ìƒíƒœ ë³€ê²½, ë£¨í”„, ì¡°ê±´ë¬¸ â†’ "ì–´ë–»ê²Œ í• ì§€" ëª…ë ¹
- **ì„ ì–¸í˜•**: ë°ì´í„° ë³€í™˜, íŒŒì´í”„ë¼ì¸ â†’ "ë¬´ì—‡ì„ í• ì§€" ì„ ì–¸

---

## ğŸ“– ë¹„ìœ  1: ê³µì¥ ì¡°ë¦½ ë¼ì¸

**í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì€ ì»¨ë² ì´ì–´ ë²¨íŠ¸ì™€ ê°™ìŠµë‹ˆë‹¤.**

```java
// ğŸ­ ìë™ì°¨ ê³µì¥ ì¡°ë¦½ ë¼ì¸
class CarFactory {
    public List<Car> produceCars(List<Material> materials) {
        return materials.stream()
            .filter(this::isQualityMaterial)      // í’ˆì§ˆ ê²€ì‚¬ (í•„í„°)
            .map(this::assembleFrame)             // í”„ë ˆì„ ì¡°ë¦½ (ë³€í™˜)
            .map(this::paintCar)                  // ë„ìƒ‰ (ë³€í™˜)
            .map(this::installEngine)             // ì—”ì§„ ì¥ì°© (ë³€í™˜)
            .filter(this::passInspection)         // ìµœì¢… ê²€ì‚¬ (í•„í„°)
            .collect(Collectors.toList());        // ì¶œê³  (ìˆ˜ì§‘)
    }
}
```

**ë¹„ìœ  ì„¤ëª…**:
- **filter**: ë¶ˆëŸ‰í’ˆ ê±¸ëŸ¬ë‚´ê¸°
- **map**: ê° ë‹¨ê³„ì—ì„œ ë³€í™˜
- **collect**: ìµœì¢… ì œí’ˆ ìˆ˜ì§‘
- **íŒŒì´í”„ë¼ì¸**: ìˆœì°¨ì  ì²˜ë¦¬

---

## ğŸ“– ë¹„ìœ  2: ë ˆì‹œí”¼ ìš”ë¦¬

**ê° ë‹¨ê³„ê°€ ë…ë¦½ì ì´ê³  ìˆœìˆ˜í•©ë‹ˆë‹¤.**

```java
// ğŸ‘¨â€ğŸ³ ìš”ë¦¬ ë ˆì‹œí”¼
class CookingRecipe {
    // ìˆœìˆ˜ í•¨ìˆ˜ - ê°™ì€ ì¬ë£Œë©´ í•­ìƒ ê°™ì€ ê²°ê³¼
    public Dish cook(Ingredients ingredients) {
        return Optional.of(ingredients)
            .map(this::wash)           // 1ë‹¨ê³„: ì„¸ì²™
            .map(this::cut)            // 2ë‹¨ê³„: ì†ì§ˆ
            .map(this::season)         // 3ë‹¨ê³„: ì–‘ë…
            .map(this::cook)           // 4ë‹¨ê³„: ì¡°ë¦¬
            .map(this::plate)          // 5ë‹¨ê³„: í”Œë ˆì´íŒ…
            .orElseThrow(() -> new CookingException("ì‹¤íŒ¨"));
    }

    // ê° ë©”ì„œë“œëŠ” ì…ë ¥ì„ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆ ê²°ê³¼ë¥¼ ë°˜í™˜
    private Ingredients wash(Ingredients input) {
        return new Ingredients(input.getItems().stream()
            .map(Item::wash)
            .collect(Collectors.toList()));
    }
}
```

---

## ğŸ“– ë¹„ìœ  3: ìˆ˜í•™ í•¨ìˆ˜

**f(x) = y â†’ ê°™ì€ ì…ë ¥ì€ í•­ìƒ ê°™ì€ ì¶œë ¥**

```java
// ğŸ“ ìˆ˜í•™ì  í•¨ìˆ˜
class MathFunctions {
    // ìˆœìˆ˜ í•¨ìˆ˜ (Pure Function)
    public int add(int a, int b) {
        return a + b;  // í•­ìƒ ê°™ì€ ê²°ê³¼
    }

    // ë¹„ìˆœìˆ˜ í•¨ìˆ˜ (Impure Function)
    private int counter = 0;
    public int addWithSideEffect(int a, int b) {
        counter++;  // ì™¸ë¶€ ìƒíƒœ ë³€ê²½!
        return a + b + counter;  // ë§¤ë²ˆ ë‹¤ë¥¸ ê²°ê³¼
    }
}

// ì‚¬ìš©
MathFunctions math = new MathFunctions();
System.out.println(math.add(2, 3));  // í•­ìƒ 5
System.out.println(math.addWithSideEffect(2, 3));  // 6
System.out.println(math.addWithSideEffect(2, 3));  // 7 (ë‹¤ë¦„!)
```

---

## ğŸ”‘ í•µì‹¬ ê°œë…

### 1. ìˆœìˆ˜ í•¨ìˆ˜ (Pure Function)

**ê°™ì€ ì…ë ¥ â†’ ê°™ì€ ì¶œë ¥, ë¶€ì‘ìš© ì—†ìŒ**

```java
// âœ… ìˆœìˆ˜ í•¨ìˆ˜
class PureFunctions {
    // 1. ì…ë ¥ë§Œ ì‚¬ìš©
    public int multiply(int a, int b) {
        return a * b;
    }

    // 2. ì™¸ë¶€ ìƒíƒœ ì½ì§€ ì•ŠìŒ
    public String toUpperCase(String input) {
        return input.toUpperCase();
    }

    // 3. ë¶ˆë³€ ê°ì²´ ë°˜í™˜
    public List<Integer> doubleNumbers(List<Integer> numbers) {
        return numbers.stream()
            .map(n -> n * 2)
            .collect(Collectors.toList());
    }
}

// âŒ ë¹„ìˆœìˆ˜ í•¨ìˆ˜
class ImpureFunctions {
    private int total = 0;

    // ì™¸ë¶€ ìƒíƒœ ë³€ê²½
    public int add(int value) {
        total += value;  // ë¶€ì‘ìš©!
        return total;
    }

    // ì™¸ë¶€ ìƒíƒœ ì½ê¸°
    public int getTotal() {
        return total;
    }
}
```

**ìˆœìˆ˜ í•¨ìˆ˜ì˜ ì¥ì **:
- **í…ŒìŠ¤íŠ¸ ìš©ì´**: Mock ë¶ˆí•„ìš”
- **ì˜ˆì¸¡ ê°€ëŠ¥**: ê²°ê³¼ê°€ ëª…í™•
- **ë³‘ë ¬ ì²˜ë¦¬**: Thread-safe
- **ìºì‹± ê°€ëŠ¥**: ë©”ëª¨ì´ì œì´ì…˜

---

### 2. ë¶ˆë³€ì„± (Immutability)

**ë°ì´í„°ë¥¼ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œ ìƒì„±**

```java
// âŒ ê°€ë³€ ê°ì²´
class MutablePerson {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;  // ë³€ê²½!
    }

    public void setAge(int age) {
        this.age = age;  // ë³€ê²½!
    }
}

// âœ… ë¶ˆë³€ ê°ì²´
class ImmutablePerson {
    private final String name;
    private final int age;

    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // ë³€ê²½ì´ ì•„ë‹Œ ìƒˆ ê°ì²´ ë°˜í™˜
    public ImmutablePerson withName(String newName) {
        return new ImmutablePerson(newName, this.age);
    }

    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge);
    }
}

// ì‚¬ìš©
ImmutablePerson person = new ImmutablePerson("Alice", 30);
ImmutablePerson updated = person.withAge(31);  // ìƒˆ ê°ì²´
System.out.println(person.getAge());   // 30 (ì›ë³¸ ìœ ì§€)
System.out.println(updated.getAge());  // 31
```

---

### 3. ê³ ì°¨ í•¨ìˆ˜ (Higher-Order Function)

**í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê±°ë‚˜ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜**

```java
// ê³ ì°¨ í•¨ìˆ˜ ì˜ˆì œ
class HigherOrderFunctions {
    // 1. í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ê¸°
    public <T> List<T> filter(List<T> list, Predicate<T> condition) {
        return list.stream()
            .filter(condition)
            .collect(Collectors.toList());
    }

    // 2. í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸°
    public Function<Integer, Integer> createMultiplier(int factor) {
        return x -> x * factor;
    }

    // 3. í•¨ìˆ˜ ì¡°í•©
    public <T, R, V> Function<T, V> compose(
            Function<T, R> f1,
            Function<R, V> f2) {
        return f1.andThen(f2);
    }
}

// ì‚¬ìš©
HigherOrderFunctions hof = new HigherOrderFunctions();

// 1. í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ì „ë‹¬
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evens = hof.filter(numbers, n -> n % 2 == 0);
System.out.println(evens);  // [2, 4]

// 2. í•¨ìˆ˜ ìƒì„±
Function<Integer, Integer> triple = hof.createMultiplier(3);
System.out.println(triple.apply(5));  // 15

// 3. í•¨ìˆ˜ ì¡°í•©
Function<String, String> toUpper = String::toUpperCase;
Function<String, Integer> getLength = String::length;
Function<String, Integer> upperLength = hof.compose(toUpper, getLength);
System.out.println(upperLength.apply("hello"));  // 5
```

---

### 4. í•¨ìˆ˜ í•©ì„± (Function Composition)

**ì‘ì€ í•¨ìˆ˜ë“¤ì„ ì¡°í•©í•˜ì—¬ ë³µì¡í•œ ê¸°ëŠ¥ êµ¬í˜„**

```java
// í•¨ìˆ˜ í•©ì„± ì˜ˆì œ
class FunctionComposition {
    // ê¸°ë³¸ í•¨ìˆ˜ë“¤
    Function<String, String> trim = String::trim;
    Function<String, String> toUpper = String::toUpperCase;
    Function<String, String> addExclamation = s -> s + "!";

    // í•¨ìˆ˜ í•©ì„±
    public String processText(String text) {
        return trim
            .andThen(toUpper)
            .andThen(addExclamation)
            .apply(text);
    }

    // ë” ë³µì¡í•œ ì˜ˆì œ
    public Function<User, String> createUserProcessor() {
        Function<User, String> getName = User::getName;
        Function<String, String> validateName = name -> {
            if (name.length() < 2) {
                throw new IllegalArgumentException("ì´ë¦„ì´ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤");
            }
            return name;
        };
        Function<String, String> formatName = String::toUpperCase;

        return getName
            .andThen(validateName)
            .andThen(formatName);
    }
}

// ì‚¬ìš©
FunctionComposition fc = new FunctionComposition();
String result = fc.processText("  hello  ");
System.out.println(result);  // "HELLO!"
```

---

## ğŸ’¡ ì‹¤ì „ ì˜ˆì œ

### ì˜ˆì œ 1: ì‚¬ìš©ì ë°ì´í„° ì²˜ë¦¬

```java
// ğŸ”´ ëª…ë ¹í˜• ìŠ¤íƒ€ì¼
class ImperativeUserService {
    public List<String> getActiveUserEmails(List<User> users) {
        List<String> result = new ArrayList<>();

        for (User user : users) {
            if (user.isActive()) {
                String email = user.getEmail();
                if (email != null && !email.isEmpty()) {
                    result.add(email.toLowerCase());
                }
            }
        }

        return result;
    }
}

// ğŸŸ¢ í•¨ìˆ˜í˜• ìŠ¤íƒ€ì¼
class FunctionalUserService {
    public List<String> getActiveUserEmails(List<User> users) {
        return users.stream()
            .filter(User::isActive)
            .map(User::getEmail)
            .filter(Objects::nonNull)
            .filter(email -> !email.isEmpty())
            .map(String::toLowerCase)
            .collect(Collectors.toList());
    }
}
```

---

### ì˜ˆì œ 2: ì£¼ë¬¸ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸

```java
class OrderProcessor {
    // ê° ë‹¨ê³„ë¥¼ ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ì •ì˜
    private Order validateOrder(Order order) {
        if (order.getItems().isEmpty()) {
            throw new IllegalArgumentException("ì£¼ë¬¸ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤");
        }
        return order;
    }

    private Order calculateTotal(Order order) {
        BigDecimal total = order.getItems().stream()
            .map(Item::getPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        return order.withTotal(total);
    }

    private Order applyDiscount(Order order) {
        if (order.getTotal().compareTo(new BigDecimal("100000")) > 0) {
            BigDecimal discounted = order.getTotal().multiply(new BigDecimal("0.9"));
            return order.withTotal(discounted);
        }
        return order;
    }

    private Order addShippingFee(Order order) {
        BigDecimal fee = new BigDecimal("3000");
        return order.withTotal(order.getTotal().add(fee));
    }

    // í•¨ìˆ˜ ì¡°í•©ìœ¼ë¡œ ì „ì²´ í”„ë¡œì„¸ìŠ¤ êµ¬í˜„
    public Order process(Order order) {
        return Optional.of(order)
            .map(this::validateOrder)
            .map(this::calculateTotal)
            .map(this::applyDiscount)
            .map(this::addShippingFee)
            .orElseThrow(() -> new ProcessingException("ì²˜ë¦¬ ì‹¤íŒ¨"));
    }
}
```

---

### ì˜ˆì œ 3: ë°ì´í„° ë³€í™˜ íŒŒì´í”„ë¼ì¸

```java
class DataPipeline {
    // CSV ë°ì´í„°ë¥¼ ì½ì–´ í†µê³„ ìƒì„±
    public Statistics processCSV(String filePath) {
        try {
            return Files.lines(Paths.get(filePath))
                .skip(1)                              // í—¤ë” ì œì™¸
                .map(line -> line.split(","))         // ë¶„ë¦¬
                .filter(parts -> parts.length == 3)   // ìœ íš¨ì„± ê²€ì‚¬
                .map(this::parseRecord)               // íŒŒì‹±
                .filter(Optional::isPresent)          // ì„±ê³µí•œ ê²ƒë§Œ
                .map(Optional::get)
                .collect(Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateStatistics
                ));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Optional<Record> parseRecord(String[] parts) {
        try {
            return Optional.of(new Record(
                parts[0],
                Integer.parseInt(parts[1]),
                Double.parseDouble(parts[2])
            ));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }

    private Statistics calculateStatistics(List<Record> records) {
        DoubleSummaryStatistics stats = records.stream()
            .mapToDouble(Record::getValue)
            .summaryStatistics();

        return new Statistics(
            stats.getCount(),
            stats.getAverage(),
            stats.getMax(),
            stats.getMin()
        );
    }
}
```

---

## ğŸ“ í•µì‹¬ ìš”ì•½

### í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° 4ëŒ€ ì›ì¹™

1. **ìˆœìˆ˜ í•¨ìˆ˜**
   - ê°™ì€ ì…ë ¥ â†’ ê°™ì€ ì¶œë ¥
   - ë¶€ì‘ìš© ì—†ìŒ

2. **ë¶ˆë³€ì„±**
   - ë°ì´í„° ë³€ê²½ ê¸ˆì§€
   - ìƒˆ ê°ì²´ ìƒì„±

3. **ê³ ì°¨ í•¨ìˆ˜**
   - í•¨ìˆ˜ë¥¼ ê°’ì²˜ëŸ¼ ë‹¤ë£¸
   - í•¨ìˆ˜ë¥¼ ì¸ì/ë°˜í™˜

4. **í•¨ìˆ˜ í•©ì„±**
   - ì‘ì€ í•¨ìˆ˜ ì¡°í•©
   - íŒŒì´í”„ë¼ì¸ êµ¬ì„±

### ëª…ë ¹í˜• vs í•¨ìˆ˜í˜•

```java
// ëª…ë ¹í˜•: ì–´ë–»ê²Œ (How)
for, while, if, ë³€ìˆ˜ í• ë‹¹

// í•¨ìˆ˜í˜•: ë¬´ì—‡ì„ (What)
map, filter, reduce, compose
```

**ë‹¤ìŒ Part 2**: ê¸°ì—… ì‚¬ë¡€ & ì£¼ë‹ˆì–´ ì‹¤ìˆ˜
