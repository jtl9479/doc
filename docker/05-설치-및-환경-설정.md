# 5. Docker 설치 및 환경 설정 🚀

> **학습 목표**: Docker를 Windows/Mac/Linux 환경에 설치하고, 실무 환경에 맞게 최적화된 설정을 완료하여 즉시 프로젝트에 활용할 수 있는 상태로 만들기

**⏱️ 예상 학습 시간**: 1-2시간
**난이도**: ⭐⭐☆☆☆ (2개/5개)

---

## 📚 목차
- [왜 제대로 된 설치가 중요한가](#왜-제대로-된-설치가-중요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [Windows/Mac/Linux 설치](#windowsmaclinux-설치)
- [Docker Desktop 설정](#docker-desktop-설정)
- [설치 확인](#설치-확인)
- [기본 설정](#기본-설정)
- [주니어 시나리오](#주니어-시나리오)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)
- [축하합니다](#축하합니다)

---

## 🤔 왜 제대로 된 설치가 중요한가?

### 실무 배경

Docker를 단순히 설치만 하고 넘어가는 것과 제대로 설정하는 것은 엄청난 차이를 만듭니다. 실제 현업에서는 설치 단계에서의 작은 실수나 설정 누락이 수개월 후 심각한 문제로 돌아옵니다.

#### ❌ 잘못된 설치/설정으로 발생하는 문제

```
문제 1: 메모리 부족으로 빌드 실패
- 증상: docker build 시 "Killed" 에러 발생
- 영향: 개발 속도 50% 저하, 팀 전체 개발 중단
- 비용: 개발자 3명 x 2시간 x 시급 $50 = $300 손실

문제 2: 디스크 공간 부족
- 증상: 오래된 이미지/컨테이너가 쌓여 100GB+ 차지
- 영향: 노트북 저장공간 부족, 시스템 전체 느려짐
- 비용: SSD 교체 비용 $200 + 마이그레이션 시간 4시간

문제 3: 네트워크 충돌
- 증상: 회사 VPN과 Docker 네트워크 충돌
- 영향: 컨테이너 접속 불가, 외부 API 통신 안 됨
- 비용: 문제 해결까지 하루 소요
```

#### ✅ 제대로 설치/설정하면

```
해결책 1: 리소스 최적화
- 방법: CPU/메모리 적절히 할당, 로그 파일 크기 제한
- 효과: 빌드 실패 0%, 안정적인 개발 환경
- 절감: 개발 생산성 30% 향상

해결책 2: 자동 정리 설정
- 방법: 정기적인 prune, 이미지 보관 기간 설정
- 효과: 디스크 사용량 80% 감소 (100GB → 20GB)
- 절감: 불필요한 하드웨어 업그레이드 비용 $200

해결책 3: 네트워크 대역 분리
- 방법: Docker 네트워크 대역 변경
- 효과: VPN과 충돌 없이 안정적 운영
- 절감: 네트워크 문제 해결 시간 제로화
```

### 📊 수치로 보는 효과

| 지표 | 잘못된 설치 | 제대로 된 설치 | 개선율 |
|------|-------------|---------------|--------|
| 설치 시간 | 8시간 (삽질 포함) | 30분 | **93%↓** |
| 빌드 실패율 | 30% | 0% | **100%↓** |
| 디스크 사용량 | 100GB | 20GB | **80%↓** |
| 문제 해결 시간/월 | 8시간 | 30분 | **93%↓** |
| 개발 만족도 | 3/10 | 9/10 | **200%↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 새 아파트 입주 (전체 설치 프로세스)

```
Docker 설치 = 새 아파트 입주 과정

1. 입주 전 점검 (시스템 요구사항 확인)
   - 수도/전기/가스 연결 확인 = CPU 가상화, 메모리 확인
   - 방충망, 도배 상태 = OS 버전, 필수 기능 확인

2. 가구 배치 (리소스 할당)
   - 거실에 소파 배치 = CPU 코어 할당
   - 냉장고 크기 선택 = 메모리 용량 설정
   - 수납공간 확보 = 디스크 공간 할당

3. 생활 규칙 설정 (Docker 설정)
   - 쓰레기 버리는 요일 = 로그 파일 정리 주기
   - 택배 수령 장소 = 이미지 저장 위치
   - 방문객 출입 규칙 = 네트워크 포트 설정

┌─────────────────────────────────────┐
│     새 아파트 입주 = Docker 설치    │
│                                     │
│  입주 전 점검 → 가구 배치 → 규칙   │
│       ↓            ↓          ↓     │
│  시스템 확인    리소스 할당   설정  │
└─────────────────────────────────────┘
```

### 비유 2: 자동차 구매 및 설정 (운영체제별 설치)

```
Windows = 수입차 구매 (복잡하지만 편리한 옵션)
- WSL 2 활성화 = 수입 통관 절차
- Hyper-V 설정 = 고급 안전 옵션 설정
- Docker Desktop = 풀옵션 차량 (GUI 포함)

Mac = 국산차 구매 (간편한 설치)
- Intel Mac = 가솔린 차량 (전통적)
- Apple Silicon = 전기차 (새롭고 효율적)
- Rosetta 2 = 충전 어댑터 (호환성)

Linux = 중고차 구매 후 튜닝 (자유도 높음)
- apt-get install = 부품 직접 구매
- systemd = 자동차 시동 시스템
- docker 그룹 추가 = 자동차 열쇠 복사

┌──────────────┬──────────────┬──────────────┐
│   Windows    │     Mac      │    Linux     │
├──────────────┼──────────────┼──────────────┤
│ 복잡한 설치  │  간편 설치   │  직접 설치   │
│ GUI 풀옵션   │  세련된 UI   │  CLI 위주    │
│ WSL 2 필요   │  M1 최적화   │  완전 제어   │
└──────────────┴──────────────┴──────────────┘
```

### 비유 3: 회사 사무실 셋업 (리소스 설정)

```
Docker Desktop 리소스 설정 = 사무실 공간 배분

CPU 할당:
- 전체 8명 중 4명 Docker에 배정
- 나머지 4명은 호스트OS 업무 담당
- 너무 많이 배정하면 다른 부서 일 못 함
- 너무 적게 배정하면 Docker 팀 과부하

메모리 할당:
- 16GB 예산 중 8GB를 Docker 팀 책상 구매
- 나머지 8GB는 다른 팀 사무용품
- 적절한 배분 = 모든 팀 효율적 근무

디스크 공간:
- 60GB 창고 공간을 Docker 이미지 보관용
- 오래된 물건 정기적으로 버리기 (prune)
- 공간 부족하면 새 창고 빌려야 함 (비용↑)

┌──────────────────────────────────┐
│      회사 예산 = 시스템 리소스    │
│                                  │
│  인력(CPU) + 책상(RAM) + 창고(Disk)│
│     ↓          ↓           ↓     │
│  4 cores    8GB RAM     60GB     │
└──────────────────────────────────┘
```

### 비유 4: 음악 스트리밍 서비스 설정 (Docker Desktop UI)

```
Docker Desktop = Spotify 같은 음악 앱

대시보드:
- 재생 중인 곡 = 실행 중인 컨테이너
- 플레이리스트 = 저장된 이미지
- 다운로드한 곡 = 로컬 이미지
- 최근 재생 = 최근 사용 컨테이너

Settings 메뉴:
- 음질 설정 = 리소스 할당
- 저장 공간 관리 = 디스크 설정
- 네트워크 설정 = 스트리밍 품질
- 자동 실행 = 로그인 시 시작

┌─────────────────────────────────┐
│    Docker Desktop Dashboard     │
├─────────────────────────────────┤
│ 🎵 재생 중 (3)  = 컨테이너 3개 │
│ 📀 앨범 (23)    = 이미지 23개   │
│ 💾 저장 공간    = 볼륨 8개      │
│ ⚙️ 설정         = Settings      │
└─────────────────────────────────┘
```

### 비유 5: 배달 앱 설정 (네트워크 및 프록시)

```
Docker 네트워크 = 배달의민족 배달 구역

네트워크 대역 설정:
- 172.80.0.0/16 = 강남구 전체
- 각 컨테이너 = 개별 음식점
- 포트 매핑 = 음식점 전화번호

프록시 설정:
- 회사 프록시 = 아파트 경비실
- 모든 배달은 경비실 거쳐야 함
- 허가된 주소만 배달 가능

VPN 충돌:
- 회사 VPN = 아파트 단지 내부 도로
- Docker 네트워크 = 음식점 배달 경로
- 도로가 겹치면 배달 불가 (충돌!)
- 해결: 다른 도로 사용 (네트워크 대역 변경)

┌────────────────────────────────────┐
│   네트워크 = 배달 구역 + 경로      │
│                                    │
│  음식점(컨테이너) → 경비실(프록시) │
│         ↓                          │
│     고객(사용자)                   │
└────────────────────────────────────┘
```

### 🎯 종합 비교표

```
┌─────────────┬──────────────┬──────────────┬──────────────┐
│ Docker 요소 │  아파트 입주 │  사무실 셋업 │   배달 앱    │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ 설치        │ 입주 준비    │ 사무실 계약  │ 앱 다운로드  │
│ CPU 할당    │ 방 개수      │ 직원 수      │ 배달원 수    │
│ 메모리      │ 냉장고 크기  │ 책상 크기    │ 배달 가방    │
│ 디스크      │ 창고 공간    │ 서류 보관함  │ 창고         │
│ 네트워크    │ 인터넷 회선  │ 사내 전화망  │ 배달 경로    │
│ 설정        │ 생활 규칙    │ 업무 규정    │ 앱 설정      │
└─────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 💻 Windows/Mac/Linux 설치

### 🪟 Windows 설치

#### 시스템 요구사항 확인

```
┌─────────────────┬──────────────────────┬─────────────────────┬──────────────────────┐
│   운영체제      │   최소 요구사항       │   권장 사양          │   필수 기능          │
├─────────────────┼──────────────────────┼─────────────────────┼──────────────────────┤
│ Windows         │ Windows 10 64-bit    │ Windows 11          │ WSL 2               │
│                 │ Home/Pro/Enterprise  │ Pro/Enterprise      │ Hyper-V (Pro 이상)  │
│                 │ Build 19041+         │                     │ Virtualization 활성화│
│                 │ 4GB RAM              │ 8GB+ RAM            │                      │
└─────────────────┴──────────────────────┴─────────────────────┴──────────────────────┘
```

#### 방법 1: Docker Desktop (권장 - GUI 포함)

**Step 1: 시스템 준비**

```powershell
# 1. Windows 버전 확인
winver
# Windows 10 Build 19041 이상 또는 Windows 11

# 2. WSL 2 설치 확인
wsl --list --verbose

# WSL 2가 없다면 설치
wsl --install

# 재부팅 필요!

# 3. 가상화 활성화 확인
# 작업 관리자 → 성능 → CPU → 가상화: 사용
# 비활성화되어 있다면 BIOS에서 활성화 필요
```

**BIOS에서 가상화 활성화하기:**
```
1. PC 재시작 → BIOS 진입 (보통 F2, F10, Del 키)
2. 설정 찾기:
   - Intel: "Intel VT-x" 또는 "Virtualization Technology"
   - AMD: "AMD-V" 또는 "SVM Mode"
3. Enabled로 변경
4. 저장 후 재시작
```

**Step 2: Docker Desktop 다운로드**

```
1. 공식 사이트 접속
   https://www.docker.com/products/docker-desktop

2. "Download for Windows" 클릭

3. 파일 다운로드
   Docker Desktop Installer.exe (약 500MB)
```

**Step 3: 설치**

```
1. Docker Desktop Installer.exe 실행
   (관리자 권한 필요)

2. 설치 옵션 선택
   ✅ Use WSL 2 instead of Hyper-V (권장)
   ✅ Add shortcut to desktop

3. "Install" 클릭

4. 설치 완료 후 재부팅

5. Docker Desktop 실행
   - 시작 메뉴 → Docker Desktop
   - 로딩 시간: 1~2분
```

**Step 4: 초기 설정**

```
1. Docker Desktop 실행 후
   "Skip tutorial" 또는 튜토리얼 진행

2. 작업 표시줄 확인
   우측 하단에 고래 아이콘 표시
   ├─ 초록색: 정상 실행 중 ✅
   └─ 빨간색: 에러 발생 ❌

3. 터미널 열기 (PowerShell 또는 CMD)
   Windows 키 + R → cmd → Enter
```

**Step 5: 확인**

```powershell
# Docker 버전 확인
docker --version
Docker version 24.0.7, build afdd53b

docker compose version
Docker Compose version v2.23.0

# 정상 출력되면 설치 완료! ✅
```

#### Windows 설치 중 자주 발생하는 문제

**문제 1: "WSL 2 installation is incomplete"**
```powershell
# 해결 방법:
# 1. WSL 2 Linux 커널 업데이트 패키지 설치
# https://aka.ms/wsl2kernel 에서 다운로드

# 2. 설치 후 WSL 2를 기본으로 설정
wsl --set-default-version 2

# 3. Ubuntu 설치 (선택사항)
wsl --install -d Ubuntu

# 4. Docker Desktop 재시작
```

**문제 2: "Hardware assisted virtualization and data execution protection must be enabled"**
```
해결 방법:
1. BIOS 진입 (PC 재시작 → F2/F10/Del)
2. Intel VT-x / AMD-V 활성화
3. Intel VT-d / AMD IOMMU 활성화 (있다면)
4. 저장 후 재시작
```

**문제 3: Hyper-V 관련 에러**
```powershell
# Hyper-V 활성화 (Windows Pro/Enterprise)
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All

# 재부팅 후 Docker Desktop 실행
```

---

### 🍎 macOS 설치

#### 방법 1: Docker Desktop (권장)

**Step 1: 시스템 확인**

```bash
# macOS 버전 확인
sw_vers
ProductName:    macOS
ProductVersion: 13.0
BuildVersion:   22A380

# CPU 아키텍처 확인
uname -m
x86_64      # Intel Mac
arm64       # Apple Silicon (M1/M2/M3)
```

**Step 2: Docker Desktop 다운로드**

```
1. 공식 사이트 접속
   https://www.docker.com/products/docker-desktop

2. CPU에 맞는 버전 선택
   - Intel Chip: "Download for Mac (Intel)"
   - Apple Silicon: "Download for Mac (Apple Silicon)"

3. Docker.dmg 다운로드 (약 500MB)
```

**Step 3: 설치**

```
1. Docker.dmg 더블클릭

2. Docker.app을 Applications 폴더로 드래그

3. Applications → Docker 실행

4. 권한 요청 승인
   "Docker Desktop needs privileged access"
   → 비밀번호 입력

5. 초기 설정
   ✅ Use recommended settings (권장)
   □ Send usage statistics (선택)

6. "Accept" 클릭
```

**Step 4: 확인**

```bash
# 터미널 열기 (⌘ + Space → Terminal)

# Docker 버전 확인
docker --version
Docker version 24.0.7, build afdd53b

docker compose version
Docker Compose version v2.23.0

# Hello World 실행
docker run hello-world

# 출력 예시:
Hello from Docker!
This message shows that your installation appears to be working correctly.

# 정상 출력되면 설치 완료! ✅
```

#### macOS 설치 중 자주 발생하는 문제

**문제 1: "Docker Desktop requires macOS 10.15 or later"**
```bash
# 해결 방법:
# macOS 업데이트 필요
# System Preferences → Software Update

# 또는 구버전 Docker 설치 (권장하지 않음)
```

**문제 2: Rosetta 2 필요 (Apple Silicon)**
```bash
# Rosetta 2 설치
softwareupdate --install-rosetta

# Docker Desktop 재시작
```

**문제 3: 네트워크 연결 안 됨**
```bash
# DNS 설정 확인
cat /etc/resolv.conf

# Docker Desktop 재시작
# 메뉴바 고래 아이콘 → Restart
```

---

### 🐧 Linux 설치

#### Ubuntu/Debian 설치

**Step 1: 기존 Docker 제거 (있다면)**

```bash
# 구버전 제거
sudo apt-get remove docker docker-engine docker.io containerd runc

# 완전 제거 (설정 파일 포함)
sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
sudo rm -rf /var/lib/docker
sudo rm -rf /var/lib/containerd
```

**Step 2: Docker 저장소 설정**

```bash
# 1. 필수 패키지 설치
sudo apt-get update
sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release

# 2. Docker의 공식 GPG 키 추가
sudo mkdir -m 0755 -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | \
    sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg

# 3. 저장소 설정
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

**Step 3: Docker Engine 설치**

```bash
# 1. 패키지 인덱스 업데이트
sudo apt-get update

# 2. Docker Engine, containerd, Docker Compose 설치
sudo apt-get install \
    docker-ce \
    docker-ce-cli \
    containerd.io \
    docker-buildx-plugin \
    docker-compose-plugin

# 3. 설치 확인
sudo docker --version
Docker version 24.0.7, build afdd53b

# 4. Hello World 테스트
sudo docker run hello-world
```

**Step 4: 현재 사용자를 docker 그룹에 추가 (선택사항)**

```bash
# docker 그룹에 사용자 추가
sudo usermod -aG docker $USER

# 그룹 변경 적용 (로그아웃/로그인 대신)
newgrp docker

# 이제 sudo 없이 사용 가능
docker ps

# ⚠️ 보안 주의사항:
# docker 그룹 = root 권한과 동일
# 보안이 중요한 환경에서는 항상 sudo 사용 권장
```

**Step 5: Docker 서비스 자동 시작 설정**

```bash
# 부팅 시 자동 시작 활성화
sudo systemctl enable docker.service
sudo systemctl enable containerd.service

# 현재 상태 확인
sudo systemctl status docker

# 출력 예시:
● docker.service - Docker Application Container Engine
   Loaded: loaded (/lib/systemd/system/docker.service; enabled)
   Active: active (running) since Mon 2024-01-15 10:00:00 KST
```

#### CentOS/RHEL 설치

```bash
# 1. 구버전 제거
sudo yum remove docker \
    docker-client \
    docker-client-latest \
    docker-common \
    docker-latest \
    docker-latest-logrotate \
    docker-logrotate \
    docker-engine

# 2. 저장소 추가
sudo yum install -y yum-utils
sudo yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo

# 3. Docker 설치
sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin

# 4. Docker 시작
sudo systemctl start docker
sudo systemctl enable docker

# 5. 확인
sudo docker run hello-world
```

#### Linux 설치 중 자주 발생하는 문제

**문제 1: "Cannot connect to the Docker daemon"**
```bash
# Docker 서비스 시작
sudo systemctl start docker

# 부팅 시 자동 시작
sudo systemctl enable docker

# 상태 확인
sudo systemctl status docker
```

**문제 2: 권한 거부 (Permission denied)**
```bash
# docker 그룹에 사용자 추가
sudo usermod -aG docker $USER

# 로그아웃 후 재로그인
# 또는
newgrp docker

# 확인
docker ps
```

**문제 3: iptables 호환성 문제**
```bash
# iptables-legacy 사용 (Ubuntu 20.04+)
sudo update-alternatives --set iptables /usr/sbin/iptables-legacy
sudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy

# Docker 재시작
sudo systemctl restart docker
```

---

## ⚙️ Docker Desktop 설정

### 🖥️ Docker Desktop 인터페이스

#### 메인 대시보드

```
┌─────────────────────────────────────────────────────────┐
│  Docker Desktop                              [_][□][X]  │
├─────────────────────────────────────────────────────────┤
│  📊 Dashboard                                           │
│  🐳 Containers (5 running)                             │
│  🏗️  Images (23 total)                                 │
│  💾 Volumes (8 total)                                  │
│  🌐 Networks (4 total)                                 │
│  ⚙️  Settings                                          │
│  📚 Learning Center                                    │
└─────────────────────────────────────────────────────────┘
```

### ⚙️ Settings (설정) 메뉴

#### General (일반 설정)

**Windows:**
```
Settings → General

✅ Start Docker Desktop when you log in
   로그인 시 Docker Desktop 자동 시작

✅ Use the WSL 2 based engine (권장)
   WSL 2 엔진 사용 (빠르고 안정적)

□ Send usage statistics
   사용 통계 전송 (선택)

□ Show weekly tips
   주간 팁 표시 (선택)

□ Open Docker Dashboard at startup
   시작 시 대시보드 열기 (선택)

□ Use Docker Compose V2
   Docker Compose V2 사용 (자동 활성화)
```

**macOS:**
```
Settings → General

✅ Start Docker Desktop when you log in
   로그인 시 자동 시작

□ Automatically check for updates
   자동 업데이트 확인 (권장)

✅ Include VM in Time Machine backups
   Time Machine 백업에 포함

□ Use Virtualization framework
   가상화 프레임워크 사용 (Apple Silicon 권장)

□ Use Rosetta for x86/amd64 emulation
   Rosetta로 x86 에뮬레이션 (M1/M2)
```

#### Resources (리소스 설정) - 가장 중요!

**CPU 할당:**
```
Settings → Resources → Advanced

CPUs: [====|====|====|====]  4 CPUs
      ←──────────────────→
      1                    8

권장 설정:
- 개발용: 전체 CPU의 50% (4코어 → 2코어)
- 운영용: 전체 CPU의 75% (8코어 → 6코어)

⚠️ 너무 많이 할당하면 호스트가 느려짐!
⚠️ 너무 적게 할당하면 빌드가 느려짐!
```

**메모리 할당:**
```
Memory: [============]  6 GB
        ←──────────────→
        2 GB        16 GB

권장 설정:
- 16GB 시스템: 6~8GB 할당
- 32GB 시스템: 12~16GB 할당
- 8GB 시스템: 4GB 할당 (최소)

계산 방법:
전체 메모리 - 호스트용 4GB = Docker용

예시:
16GB - 4GB = 12GB (Docker에 할당 가능)
하지만 여유를 위해 8GB 정도 할당 권장
```

**스왑 할당:**
```
Swap: [====]  2 GB
      ←────────→
      512 MB  4 GB

권장 설정:
- 메모리의 50% 정도
- 6GB 메모리 → 3GB 스왑
- 8GB 메모리 → 4GB 스왑

⚠️ 스왑 사용 시 성능 저하!
⚠️ 스왑 많이 사용되면 메모리 증설 고려
```

**디스크 이미지 크기:**
```
Disk image size: [========]  60 GB
                 ←──────────────→
                 20 GB      200 GB

권장 설정:
- 개발용: 60~100GB
- 운영용: 100~200GB

⚠️ 동적으로 증가하지만 최대값 설정
⚠️ 줄이려면 완전 초기화 필요 (Troubleshoot → Clean/Purge data)
```

**실제 설정 예시:**

```
시나리오 1: 개발 노트북 (16GB RAM, 8 CPU)
├─ CPU: 4 cores (50%)
├─ Memory: 6 GB (약 40%)
├─ Swap: 2 GB
└─ Disk: 60 GB

시나리오 2: 고성능 워크스테이션 (32GB RAM, 16 CPU)
├─ CPU: 8 cores (50%)
├─ Memory: 16 GB (50%)
├─ Swap: 4 GB
└─ Disk: 100 GB

시나리오 3: 가벼운 사용 (8GB RAM, 4 CPU)
├─ CPU: 2 cores (50%)
├─ Memory: 4 GB (50%)
├─ Swap: 2 GB
└─ Disk: 40 GB
```

#### File Sharing (파일 공유)

**Windows:**
```
Settings → Resources → File Sharing

공유할 드라이브 선택:
✅ C:\
□ D:\
□ E:\

추가 경로:
C:\Users\YourName\Projects
C:\workspace

⚠️ WSL 2 사용 시 자동으로 설정됨
```

**macOS:**
```
Settings → Resources → File Sharing

기본 공유 경로:
✅ /Users
✅ /Volumes
✅ /private
✅ /tmp

추가 경로 추가:
+ Add directory
  → ~/Projects
  → /opt/data
```

#### Docker Engine (고급 설정)

```json
{
  "builder": {
    "gc": {
      "defaultKeepStorage": "20GB",
      "enabled": true
    }
  },
  "experimental": false,
  "features": {
    "buildkit": true
  },
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "storage-driver": "overlay2",
  "default-address-pools": [
    {
      "base": "172.80.0.0/16",
      "size": 24
    }
  ]
}
```

**주요 설정 설명:**

```
log-driver: "json-file"
→ 로그를 JSON 파일로 저장 (기본값)

log-opts:
  max-size: "10m"     # 로그 파일 최대 크기
  max-file: "3"       # 로그 파일 최대 개수
→ 로그 파일 총 30MB (10MB x 3)

storage-driver: "overlay2"
→ 파일 시스템 드라이버 (성능 최고)

default-address-pools:
→ 컨테이너 네트워크 IP 범위
→ 172.80.0.0/16 = 65,536개 IP

buildkit: true
→ 향상된 빌드 시스템 사용
```

#### Kubernetes (선택사항)

```
Settings → Kubernetes

□ Enable Kubernetes
  로컬 Kubernetes 클러스터 실행

⚠️ 주의:
- 메모리 추가 4GB 필요
- 개발/학습 목적으로만 사용
- 운영 환경에는 별도 클러스터 권장
```

---

## ✅ 설치 확인

### ✅ 기본 동작 확인

#### 1단계: 버전 확인

```bash
# Docker Engine 버전
docker --version
Docker version 24.0.7, build afdd53b

# Docker Compose 버전
docker compose version
Docker Compose version v2.23.0-desktop.1

# 상세 정보
docker version

Client:
 Cloud integration: v1.0.35+desktop.5
 Version:           24.0.7
 API version:       1.43
 Go version:        go1.20.10
 Git commit:        afdd53b
 Built:             Thu Oct 26 09:04:20 2023
 OS/Arch:           windows/amd64
 Context:           desktop-linux

Server: Docker Desktop 4.26.1 (131620)
 Engine:
  Version:          24.0.7
  API version:      1.43 (minimum version 1.12)
  Go version:       go1.20.10
  Git commit:       311b9ff
  Built:            Thu Oct 26 09:08:02 2023
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.6.25
  GitCommit:        d8f198a4ed8892c764191ef7b3b06d8a2eeb5c7f
 runc:
  Version:          1.1.10
  GitCommit:        v1.1.10-0-g18a0cb0
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```

#### 2단계: 시스템 정보 확인

```bash
# Docker 시스템 정보
docker info

Client:
 Context:    desktop-linux
 Debug Mode: false

Server:
 Containers: 5          # 실행 중인 컨테이너
  Running: 3
  Paused: 0
  Stopped: 2
 Images: 23             # 로컬 이미지
 Server Version: 24.0.7
 Storage Driver: overlay2    # 파일 시스템 드라이버
  Backing Filesystem: extfs
  Supports d_type: true
  Using metacopy: false
  Native Overlay Diff: true
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 2
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: d8f198a4ed8892c764191ef7b3b06d8a2eeb5c7f
 runc version: v1.1.10-0-g18a0cb0
 init version: de40ad0
 Security Options:
  seccomp
   Profile: builtin
  cgroupns
 Kernel Version: 5.15.133.1-microsoft-standard-WSL2
 Operating System: Docker Desktop
 OSType: linux
 Architecture: x86_64
 CPUs: 8
 Total Memory: 15.5GiB
 Name: docker-desktop
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 HTTP Proxy: http.docker.internal:3128
 HTTPS Proxy: http.docker.internal:3128
 No Proxy: hubproxy.docker.internal
 Registry: https://index.docker.io/v1/
 Experimental: false
 Insecure Registries:
  hubproxy.docker.internal:5555
  127.0.0.0/8
 Live Restore Enabled: false
```

#### 3단계: Hello World 실행

```bash
# Hello World 컨테이너 실행
docker run hello-world

# 출력:
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
c1ec31eb5944: Pull complete
Digest: sha256:4bd78111b6914a99dbc560e6a20eab57ff6655aea4a80c50b0c5491968cbc2e6
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 1. The Docker client contacted the Docker daemon.
 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
 3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
 4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

# ✅ 이 메시지가 나오면 설치 성공!
```

#### 4단계: 실제 애플리케이션 테스트

```bash
# Nginx 웹 서버 실행
docker run -d -p 8080:80 --name test-nginx nginx

# 출력:
Unable to find image 'nginx:latest' locally
latest: Pulling from library/nginx
a2abf6c4d29d: Pull complete
a9edb18cadd1: Pull complete
589b7251471a: Pull complete
186b1aaa4aa6: Pull complete
b4df32aa5a72: Pull complete
a0bcbecc962e: Pull complete
Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31
Status: Downloaded newer image for nginx:latest
abc123def456...

# 컨테이너 상태 확인
docker ps

CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
abc123def456   nginx     "/docker-entrypoint.…"   5 seconds ago   Up 4 seconds   0.0.0.0:8080->80/tcp   test-nginx

# 브라우저에서 확인
# http://localhost:8080
# "Welcome to nginx!" 페이지가 나오면 성공! ✅

# 또는 curl로 확인
curl http://localhost:8080

<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...

# 정리
docker stop test-nginx
docker rm test-nginx
```

### 🔍 설치 검증 체크리스트

```bash
# 1. Docker 명령어 사용 가능
docker --version                    # ✅

# 2. Docker Compose 사용 가능
docker compose version              # ✅

# 3. 이미지 pull 가능
docker pull alpine                  # ✅

# 4. 컨테이너 실행 가능
docker run -d --name test alpine sleep 60   # ✅

# 5. 컨테이너 목록 확인
docker ps                           # ✅

# 6. 컨테이너 내부 명령 실행
docker exec test echo "Hello"       # ✅

# 7. 컨테이너 중지 및 삭제
docker stop test && docker rm test  # ✅

# 8. 이미지 삭제
docker rmi alpine                   # ✅

# 모든 항목이 정상 작동하면 설치 완료! 🎉
```

---

## 🔧 기본 설정

### 📁 Docker 데이터 저장 위치

#### 기본 저장 위치

```
Windows (WSL 2):
\\wsl$\docker-desktop-data\version-pack-data\community\docker

Linux:
/var/lib/docker/

macOS:
~/Library/Containers/com.docker.docker/Data/vms/0/
```

#### 저장소 위치 변경 (Linux)

```bash
# 1. Docker 중지
sudo systemctl stop docker

# 2. 기존 데이터 백업 (선택사항)
sudo cp -a /var/lib/docker /var/lib/docker.backup

# 3. 새 저장소 생성
sudo mkdir -p /new/path/docker

# 4. 데이터 이동
sudo rsync -aP /var/lib/docker/ /new/path/docker/

# 5. daemon.json 설정
sudo nano /etc/docker/daemon.json

{
  "data-root": "/new/path/docker"
}

# 6. Docker 재시작
sudo systemctl start docker

# 7. 확인
docker info | grep "Docker Root Dir"
Docker Root Dir: /new/path/docker
```

#### 저장소 위치 변경 (Windows WSL 2)

```powershell
# 1. Docker Desktop 완전 종료
# 작업 표시줄 → 고래 아이콘 우클릭 → Quit Docker Desktop

# 2. WSL 종료
wsl --shutdown

# 3. WSL 디스크 이미지 Export
wsl --export docker-desktop-data D:\docker-wsl-data\docker-desktop-data.tar

# 4. 기존 인스턴스 제거
wsl --unregister docker-desktop-data

# 5. 새 위치에 Import
wsl --import docker-desktop-data D:\docker-wsl-data D:\docker-wsl-data\docker-desktop-data.tar --version 2

# 6. Docker Desktop 시작
```

### 🌐 Docker Hub 로그인

```bash
# 로그인
docker login

Username: your-username
Password:
Login Succeeded

# 로그인 정보는 다음에 저장됨:
# Windows: %USERPROFILE%\.docker\config.json
# Linux/Mac: ~/.docker/config.json

# 로그아웃
docker logout

# 특정 레지스트리 로그인
docker login registry.example.com
```

### 🔧 프록시 설정

#### Docker Desktop (Windows/Mac)

```
Settings → Resources → Proxies

Manual proxy configuration:
Web Server (HTTP): http://proxy.company.com:8080
Secure Web Server (HTTPS): https://proxy.company.com:8080
Bypass for these hosts: localhost,127.0.0.1
```

#### Docker Engine (Linux)

```bash
# 1. 설정 디렉토리 생성
sudo mkdir -p /etc/systemd/system/docker.service.d

# 2. 프록시 설정 파일 생성
sudo nano /etc/systemd/system/docker.service.d/http-proxy.conf

[Service]
Environment="HTTP_PROXY=http://proxy.company.com:8080"
Environment="HTTPS_PROXY=https://proxy.company.com:8080"
Environment="NO_PROXY=localhost,127.0.0.1,docker-registry.local"

# 3. systemd 데몬 재로드
sudo systemctl daemon-reload

# 4. Docker 재시작
sudo systemctl restart docker

# 5. 확인
sudo systemctl show --property=Environment docker
```

### 🔐 보안 설정

#### 1. User Namespace 활성화 (Linux)

```bash
# /etc/docker/daemon.json
{
  "userns-remap": "default"
}

# Docker 재시작
sudo systemctl restart docker

# 효과:
# - 컨테이너 root = 호스트 일반 사용자
# - 보안 강화
```

#### 2. TLS 인증서 설정 (원격 접속)

```bash
# 1. CA 키 생성
openssl genrsa -aes256 -out ca-key.pem 4096

# 2. CA 인증서 생성
openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem

# 3. 서버 키 생성
openssl genrsa -out server-key.pem 4096

# 4. CSR 생성
openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server.csr

# 5. 서버 인증서 생성
openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out server-cert.pem

# 6. daemon.json 설정
{
  "tlsverify": true,
  "tlscacert": "/path/to/ca.pem",
  "tlscert": "/path/to/server-cert.pem",
  "tlskey": "/path/to/server-key.pem",
  "hosts": ["tcp://0.0.0.0:2376", "unix:///var/run/docker.sock"]
}
```

### 📊 로깅 설정

```json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3",
    "labels": "production_status",
    "env": "os,customer"
  }
}
```

**로그 드라이버 종류:**
```
json-file: 기본, JSON 형식
syslog: syslog로 전송
journald: systemd journal
gelf: Graylog
fluentd: Fluentd로 전송
awslogs: AWS CloudWatch
splunk: Splunk로 전송
```

### 🎯 성능 최적화 설정

```json
{
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ],
  "exec-opts": ["native.cgroupdriver=systemd"],
  "live-restore": true,
  "default-ulimits": {
    "nofile": {
      "Name": "nofile",
      "Hard": 64000,
      "Soft": 64000
    }
  },
  "max-concurrent-downloads": 10,
  "max-concurrent-uploads": 5
}
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 메모리 부족으로 빌드 실패

**상황**: 주니어 개발자가 Docker Desktop을 기본 설정(2GB RAM)으로 사용하다가 Spring Boot 애플리케이션 빌드 시 실패

```bash
# ❌ 빌드 실행
docker build -t myapp .

# 에러 메시지:
Step 5/10 : RUN ./mvnw package
 ---> Running in abc123def456
Killed
ERROR: Service 'app' failed to build
```

**문제점**:
- 기본 메모리 할당(2GB)이 부족
- Maven 빌드는 최소 4GB 권장
- 빌드 중 Java 컴파일러가 많은 메모리 사용

**해결책**:
```bash
# ✅ Docker Desktop 메모리 증가

# 1. Docker Desktop → Settings → Resources
# 2. Memory 슬라이더를 6GB로 변경
# 3. Apply & Restart

# 또는 daemon.json 설정 (Linux)
{
  "default-ulimits": {
    "memlock": {
      "Hard": 6442450944,
      "Name": "memlock",
      "Soft": 6442450944
    }
  }
}

# 4. 다시 빌드
docker build -t myapp .

# 성공!
Successfully built abc123def456
Successfully tagged myapp:latest
```

**배운 점**:
- 💡 Java 애플리케이션은 최소 4-6GB 메모리 할당
- 💡 빌드 실패 시 메모리 모니터링 (`docker stats`)
- 💡 시스템 전체 메모리의 50% 이하로 할당 권장

---

### 시나리오 2: 디스크 공간 부족

**상황**: 며칠간 개발하다가 "no space left on device" 에러 발생

```bash
# ❌ 이미지 pull 시도
docker pull postgres:15

# 에러 메시지:
Error response from daemon: write /var/lib/docker/overlay2/xxx: no space left on device
```

**문제점**:
- 오래된 이미지가 쌓임 (50GB+)
- 중지된 컨테이너가 디스크 차지
- 사용하지 않는 볼륨 방치

**해결책**:
```bash
# ✅ 1. 현재 상태 확인
docker system df

TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          47        5         15.2GB    12.5GB (82%)
Containers      28        3         8.3GB     8.1GB (97%)
Local Volumes   12        2         4.5GB     4.2GB (93%)
Build Cache     156       0         22.1GB    22.1GB (100%)

# ✅ 2. 사용하지 않는 것만 정리
docker system prune

# 확인 메시지
WARNING! This will remove:
  - all stopped containers
  - all networks not used by at least one container
  - all dangling images
  - all dangling build cache

Are you sure you want to continue? [y/N] y

Deleted Containers:
abc123...
def456...

Deleted Images:
sha256:xxx...

Total reclaimed space: 18.5GB

# ✅ 3. 전체 정리 (주의!)
docker system prune -a --volumes

# 15GB 확보!
```

**배운 점**:
- 💡 주 1회 `docker system prune` 실행 습관
- 💡 사용하지 않는 이미지는 즉시 삭제 (`docker rmi`)
- 💡 개발 완료 후 컨테이너 정리 (`docker rm`)

---

### 시나리오 3: 회사 VPN과 네트워크 충돌

**상황**: 회사에서 VPN 연결 시 컨테이너가 외부 API 호출 실패

```bash
# ❌ 컨테이너 실행
docker run -it --rm alpine wget https://api.github.com

# 에러 메시지:
wget: can't connect to remote host (192.168.65.1): Connection refused
```

**문제점**:
- 회사 VPN 네트워크: 192.168.0.0/16
- Docker 기본 네트워크: 192.168.65.0/24
- IP 대역 충돌로 라우팅 실패

**해결책**:
```bash
# ✅ 1. Docker Desktop → Settings → Docker Engine
# daemon.json 수정

{
  "default-address-pools": [
    {
      "base": "172.80.0.0/16",
      "size": 24
    }
  ]
}

# ✅ 2. Apply & Restart

# ✅ 3. 네트워크 확인
docker network inspect bridge

"IPAM": {
  "Config": [
    {
      "Subnet": "172.80.0.0/24",
      "Gateway": "172.80.0.1"
    }
  ]
}

# ✅ 4. 다시 테스트
docker run -it --rm alpine wget https://api.github.com

# 성공!
Connecting to api.github.com (140.82.121.6:443)
saving to 'index.html'
```

**배운 점**:
- 💡 회사 VPN 사용 시 Docker 네트워크 대역 변경 필수
- 💡 172.x.x.x 대역 사용 권장 (충돌 가능성 낮음)
- 💡 네트워크 문제는 `docker network inspect`로 디버깅

---

### 시나리오 4: WSL 2 설치 누락 (Windows)

**상황**: Windows에서 Docker Desktop 설치 후 실행 안 됨

```powershell
# ❌ Docker Desktop 실행 시도
# 팝업 메시지:
WSL 2 installation is incomplete.
The WSL 2 Linux kernel is now installed using a separate MSI update package.
Please click the link and follow the instructions to install the kernel update:
https://aka.ms/wsl2kernel
```

**문제점**:
- WSL 2 커널 업데이트 미설치
- Windows 기능 활성화 누락

**해결책**:
```powershell
# ✅ 1. WSL 확인
wsl --list --verbose

# 출력이 없거나 에러 발생

# ✅ 2. WSL 설치
wsl --install

# ✅ 3. WSL 2를 기본으로 설정
wsl --set-default-version 2

# ✅ 4. Ubuntu 설치 (권장)
wsl --install -d Ubuntu

# ✅ 5. 시스템 재부팅

# ✅ 6. Docker Desktop 다시 실행

# 성공!
Docker Desktop is starting...
```

**배운 점**:
- 💡 Windows에서 Docker = WSL 2 필수
- 💡 설치 전 시스템 요구사항 체크리스트 확인
- 💡 재부팅 필수 (WSL 커널 로드)

---

## ❓ FAQ

<details>
<summary><strong>Q1: Docker Desktop이 느려요. 어떻게 최적화하나요?</strong></summary>

**A**: Docker Desktop 성능 최적화는 리소스 할당, 파일 시스템, 불필요한 데이터 정리로 해결할 수 있습니다.

**상세 설명**:
- **리소스 부족**: CPU/메모리 할당 늘리기
- **디스크 I/O**: WSL 2 사용 (Windows), Virtualization.framework (Mac M1)
- **오래된 데이터**: 정기적인 `docker system prune`

**예시**:
```bash
# 1. 리소스 할당 확인
docker info | grep -i "CPUs\|Total Memory"

# 2. 사용하지 않는 것 정리
docker system prune -a

# 3. BuildKit 활성화 (빌드 속도 향상)
# Settings → Docker Engine
{
  "features": {
    "buildkit": true
  }
}

# 4. 파일 공유 최소화
# Settings → Resources → File Sharing
# 필요한 디렉토리만 추가
```

**실무 팁**:
💡 시스템 메모리의 50%까지만 할당 (호스트 OS도 필요!)
💡 SSD 사용 시 디스크 I/O 10배 빠름
💡 불필요한 컨테이너는 즉시 삭제

</details>

<details>
<summary><strong>Q2: "permission denied" 에러가 계속 발생해요 (Linux)</strong></summary>

**A**: Docker 소켓에 대한 권한이 없어서 발생하며, docker 그룹에 사용자를 추가하면 해결됩니다.

**상세 설명**:
- **원인**: Docker 소켓(/var/run/docker.sock)은 root 권한 필요
- **해결**: 사용자를 docker 그룹에 추가
- **주의**: docker 그룹 = root 권한과 동일 (보안 고려)

**예시**:
```bash
# ❌ 에러 발생
docker ps
Got permission denied while trying to connect to the Docker daemon socket

# ✅ 해결 방법 1: docker 그룹 추가 (권장)
sudo usermod -aG docker $USER

# 로그아웃 후 재로그인 또는
newgrp docker

# 확인
docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

# ✅ 해결 방법 2: sudo 사용 (보안 환경)
sudo docker ps
```

**실무 팁**:
💡 개발 환경: docker 그룹 추가 (편의성)
💡 운영 환경: 항상 sudo 사용 (보안)
💡 서버 환경: 전용 docker 계정 생성 권장

</details>

<details>
<summary><strong>Q3: Docker Desktop과 Docker Engine의 차이는 무엇인가요?</strong></summary>

**A**: Docker Desktop은 GUI와 편의 기능이 포함된 패키지이고, Docker Engine은 핵심 컨테이너 실행 엔진입니다.

**상세 설명**:
- **Docker Engine**: 컨테이너 실행 핵심 엔진 (CLI만)
- **Docker Desktop**: Engine + GUI + 개발 도구 + WSL 2 통합
- **라이선스**: Desktop은 대기업 유료, Engine은 오픈소스 무료

**비교표**:

| 구분 | Docker Desktop | Docker Engine |
|------|----------------|---------------|
| GUI | ✅ 대시보드 제공 | ❌ CLI만 |
| 운영체제 | Windows, Mac | Linux만 |
| WSL 2 통합 | ✅ 자동 설정 | ❌ 수동 설정 |
| Kubernetes | ✅ 내장 | ❌ 별도 설치 |
| 라이선스 | 대기업 유료 | 완전 무료 |
| 용도 | 개발 환경 | 서버/운영 환경 |

**실무 팁**:
💡 개발자 노트북: Docker Desktop 권장
💡 Linux 서버: Docker Engine만 설치
💡 대기업: 라이선스 확인 필수

</details>

<details>
<summary><strong>Q4: 컨테이너가 재부팅 후 사라져요. 어떻게 보존하나요?</strong></summary>

**A**: 컨테이너는 기본적으로 재부팅 시 중지되며, `--restart` 옵션으로 자동 재시작할 수 있습니다.

**상세 설명**:
- **기본 동작**: 컨테이너는 재부팅 시 중지 상태
- **자동 시작**: `--restart` 플래그 사용
- **데이터 보존**: 볼륨 사용 필수

**예시**:
```bash
# ❌ 기본 실행 (재부팅 시 중지)
docker run -d --name myapp nginx

# 재부팅 후
docker ps
# 아무것도 없음

# ✅ 자동 재시작 설정
docker run -d --name myapp --restart unless-stopped nginx

# 또는 기존 컨테이너 업데이트
docker update --restart unless-stopped myapp

# 재부팅 후에도 자동 시작!
docker ps
CONTAINER ID   IMAGE     COMMAND                  STATUS
abc123def456   nginx     "/docker-entrypoint.…"   Up 2 minutes

# restart 정책 옵션:
# - no: 재시작 안 함 (기본값)
# - on-failure: 에러로 종료 시만 재시작
# - always: 항상 재시작
# - unless-stopped: 수동 중지 전까지 재시작
```

**실무 팁**:
💡 개발 환경: `unless-stopped` (수동 제어 가능)
💡 운영 환경: `always` (무중단 운영)
💡 데이터는 반드시 볼륨에 저장 (`-v` 옵션)

</details>

<details>
<summary><strong>Q5: 이미지 다운로드가 너무 느려요. 가속화 방법은?</strong></summary>

**A**: Docker Hub 미러 레지스트리를 설정하거나, 한국 리전의 프라이빗 레지스트리를 사용하면 빨라집니다.

**상세 설명**:
- **원인**: Docker Hub 서버가 해외(미국)에 위치
- **해결 1**: 미러 레지스트리 사용 (캐시)
- **해결 2**: 회사 내부 레지스트리 구축

**예시**:
```bash
# ✅ 1. Docker Desktop 미러 설정
# Settings → Docker Engine

{
  "registry-mirrors": [
    "https://mirror.gcr.io",
    "https://registry.docker-cn.com"
  ]
}

# Apply & Restart

# ✅ 2. 병렬 다운로드 증가
{
  "max-concurrent-downloads": 10,
  "max-concurrent-uploads": 5
}

# ✅ 3. 다운로드 속도 테스트
time docker pull nginx:latest

# Before: 2분 30초
# After:  45초 (3배 빠름!)

# ✅ 4. 회사 프라이빗 레지스트리 사용
docker pull registry.company.com/nginx:latest
# 같은 네트워크라 10배 빠름!
```

**실무 팁**:
💡 회사에서는 내부 레지스트리 구축 (Harbor, GitLab Registry)
💡 자주 쓰는 이미지는 미리 pull 해두기
💡 멀티스테이지 빌드로 이미지 크기 줄이기

</details>

<details>
<summary><strong>Q6: M1/M2 Mac에서 일부 이미지가 안 돌아가요</strong></summary>

**A**: ARM 아키텍처(M1/M2)와 x86 이미지 호환성 문제로, Rosetta 2를 활성화하거나 ARM 전용 이미지를 사용해야 합니다.

**상세 설명**:
- **M1/M2**: ARM64 아키텍처
- **기존 이미지**: x86_64 아키텍처
- **해결**: Rosetta 2 에뮬레이션 또는 ARM 이미지

**예시**:
```bash
# ❌ x86 이미지 실행 시 에러
docker run -it mysql:5.7
WARNING: The requested image's platform (linux/amd64) does not match the detected host platform (linux/arm64/v8)

# ✅ 해결 방법 1: Rosetta 2 활성화
# Docker Desktop → Settings → General
# ☑ Use Rosetta for x86/amd64 emulation on Apple Silicon

# ✅ 해결 방법 2: ARM 이미지 사용
docker run -it mysql:8.0
# MySQL 8.0은 ARM 지원!

# ✅ 해결 방법 3: 플랫폼 명시
docker run --platform linux/amd64 -it mysql:5.7
# 느리지만 작동함

# ✅ 해결 방법 4: 멀티 아키텍처 이미지 확인
docker manifest inspect nginx:latest

# 지원 플랫폼 확인
"platform": {
  "architecture": "amd64",
  "os": "linux"
},
"platform": {
  "architecture": "arm64",
  "os": "linux"
}
```

**실무 팁**:
💡 최신 이미지는 대부분 ARM 지원 (nginx, node, python 등)
💡 오래된 이미지는 Rosetta 2 사용
💡 빌드 시 `--platform` 옵션으로 명시

</details>

<details>
<summary><strong>Q7: 컨테이너 로그가 너무 많이 쌓여요. 자동 정리 방법은?</strong></summary>

**A**: daemon.json에서 로그 파일 크기와 개수를 제한하면 자동으로 로테이션됩니다.

**상세 설명**:
- **기본 설정**: 로그 무제한 저장 (디스크 가득 참!)
- **해결**: 로그 파일 크기/개수 제한
- **권장**: 10MB x 3개 = 30MB 제한

**예시**:
```bash
# ❌ 로그 확인 (수십 GB!)
docker inspect myapp | grep LogPath
"LogPath": "/var/lib/docker/containers/xxx/xxx-json.log"

ls -lh /var/lib/docker/containers/xxx/
-rw-r----- 1 root root 15G Jan 15 10:00 xxx-json.log

# ✅ 로그 크기 제한 설정
# Docker Desktop → Settings → Docker Engine

{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}

# Apply & Restart

# ✅ 새 컨테이너 실행
docker run -d --name myapp nginx

# 로그 확인
docker inspect myapp | grep -A 5 LogConfig

"LogConfig": {
  "Type": "json-file",
  "Config": {
    "max-size": "10m",
    "max-file": "3"
  }
}

# ✅ 기존 컨테이너는 재생성 필요
docker rm -f myapp
docker run -d --name myapp nginx

# 이제 최대 30MB만 차지!
```

**실무 팁**:
💡 운영 환경: 로그는 외부 시스템으로 전송 (ELK, Splunk)
💡 개발 환경: max-size=10m, max-file=3 권장
💡 디버깅 시: `docker logs -f --tail 100`

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용 (5-7개)

<details>
<summary><strong>1. Docker 설치 시 가상화가 왜 필요한가요?</strong></summary>

**모범 답안 포인트**
- Docker는 컨테이너를 실행하기 위해 Linux 커널 기능 필요
- Windows/Mac은 Linux가 아니므로 가상화로 Linux 환경 생성
- WSL 2(Windows), Hypervisor.framework(Mac) 사용
- 가상화 없이는 컨테이너 격리 및 리소스 관리 불가능

**예시 답변**
> "Docker는 Linux 커널의 네임스페이스와 cgroups 기능을 사용하여 컨테이너를 격리하고 리소스를 관리합니다. Windows와 Mac은 Linux가 아니기 때문에, 가상화 기술을 통해 경량 Linux VM을 실행해야 합니다. Windows는 WSL 2를, Mac은 Hypervisor.framework를 사용하여 이를 구현합니다. 가상화를 활성화하지 않으면 Docker Engine이 실행될 Linux 환경 자체가 없어 컨테이너를 실행할 수 없습니다."

**꼬리 질문**
- Q: Linux에서는 가상화가 필요 없나요?
- A: 네, Linux는 이미 필요한 커널 기능이 있어 Docker Engine을 직접 설치하면 됩니다.

**실무 연관**
- BIOS에서 가상화 활성화는 Docker 설치 첫 단계
- 가상화 미활성화 시 "Hardware assisted virtualization must be enabled" 에러 발생

</details>

<details>
<summary><strong>2. Docker Desktop과 Docker Engine의 차이를 설명해주세요</strong></summary>

**모범 답안 포인트**
- Docker Engine: 컨테이너 실행 핵심 엔진 (오픈소스, 무료)
- Docker Desktop: Engine + GUI + 개발 도구 + 플랫폼 통합
- Desktop은 Windows/Mac 전용, Engine은 Linux만
- Desktop은 대기업 유료 라이선스, Engine은 완전 무료

**예시 답변**
> "Docker Engine은 컨테이너를 실행하는 핵심 엔진으로 CLI만 제공하며 Linux에서만 작동합니다. 반면 Docker Desktop은 Engine에 GUI 대시보드, WSL 2 통합, Kubernetes 지원 등 개발 편의 기능을 추가한 패키지로 Windows와 Mac에서 사용합니다. 라이선스 측면에서 Engine은 완전 무료이지만, Desktop은 250명 이상 대기업이나 매출 1천만 달러 이상 기업은 유료 구독이 필요합니다. 실무에서는 개발자 노트북에 Desktop을, 서버에는 Engine을 설치합니다."

**꼬리 질문**
- Q: 대기업에서 무료로 사용할 방법은?
- A: Linux 서버에 Docker Engine만 설치하거나, Podman 같은 대체 도구 사용

**실무 연관**
- 스타트업: Docker Desktop 무료 사용 가능
- 대기업: 라이선스 확인 후 구독 또는 Engine으로 전환

</details>

<details>
<summary><strong>3. Docker에 메모리를 너무 많이 할당하면 어떤 문제가 생기나요?</strong></summary>

**모범 답안 포인트**
- 호스트 OS용 메모리 부족으로 시스템 전체 느려짐
- 다른 애플리케이션(IDE, 브라우저 등) 실행 불가
- 메모리 스왑 발생으로 성능 급격히 저하
- 권장: 전체 메모리의 50% 이하 할당

**예시 답변**
> "Docker에 메모리를 과도하게 할당하면 호스트 운영체제가 사용할 메모리가 부족해져 시스템 전체가 느려집니다. 예를 들어 16GB 시스템에 12GB를 Docker에 할당하면, IDE나 브라우저를 실행할 때 메모리가 부족해 스왑 메모리를 사용하게 되고, 이는 SSD보다 수백 배 느려 개발 생산성이 급격히 떨어집니다. 일반적으로 전체 메모리의 50% 이하를 Docker에 할당하고, 호스트 OS용으로 최소 4GB는 남겨두는 것이 좋습니다."

**꼬리 질문**
- Q: 메모리 부족 시 어떤 증상이 나타나나요?
- A: 빌드 중 "Killed" 에러, 시스템 프리징, 느린 응답 속도

**실무 연관**
- 16GB 노트북: Docker 6~8GB 할당
- 32GB 워크스테이션: Docker 12~16GB 할당

</details>

<details>
<summary><strong>4. WSL 2와 Hyper-V의 차이는 무엇인가요? (Windows)</strong></summary>

**모범 답안 포인트**
- WSL 2: Windows 10/11의 경량 Linux 서브시스템
- Hyper-V: Windows의 전체 가상화 플랫폼
- WSL 2가 더 빠르고 리소스 효율적
- WSL 2는 Home Edition에서도 작동 (Hyper-V는 Pro 이상)

**예시 답변**
> "WSL 2는 Windows 10/11에서 Linux 커널을 직접 실행하는 경량 서브시스템으로, Docker가 빠르고 효율적으로 작동합니다. 반면 Hyper-V는 완전한 가상화 플랫폼으로 더 무겁고 리소스를 많이 사용합니다. WSL 2는 부팅 속도가 2초 이내로 빠르며, 파일 시스템 성능도 Hyper-V보다 10배 빠릅니다. 또한 WSL 2는 Windows 10 Home에서도 작동하지만, Hyper-V는 Pro나 Enterprise 에디션이 필요합니다. 따라서 Docker Desktop은 WSL 2를 권장합니다."

**꼬리 질문**
- Q: 기존에 Hyper-V를 쓰고 있다면?
- A: Docker Desktop 설정에서 WSL 2로 전환 가능 (재설치 불필요)

**실무 연관**
- 최신 Docker Desktop은 WSL 2를 기본으로 사용
- Hyper-V는 레거시, WSL 2 마이그레이션 권장

</details>

<details>
<summary><strong>5. docker system prune 명령어는 무엇을 삭제하나요?</strong></summary>

**모범 답안 포인트**
- 중지된 모든 컨테이너
- 사용하지 않는 네트워크
- 댕글링 이미지 (태그 없는 이미지)
- 댕글링 빌드 캐시
- `-a` 옵션: 사용하지 않는 모든 이미지
- `--volumes` 옵션: 사용하지 않는 볼륨

**예시 답변**
> "docker system prune은 사용하지 않는 Docker 리소스를 정리하는 명령어로, 기본적으로 중지된 컨테이너, 사용하지 않는 네트워크, 태그가 없는 댕글링 이미지와 빌드 캐시를 삭제합니다. `-a` 플래그를 추가하면 실행 중인 컨테이너가 사용하지 않는 모든 이미지까지 삭제하고, `--volumes` 플래그를 추가하면 연결되지 않은 볼륨까지 삭제합니다. 이 명령어를 주기적으로 실행하면 디스크 공간을 크게 절약할 수 있어, 보통 주 1회 실행을 권장합니다."

**꼬리 질문**
- Q: 실행 중인 컨테이너의 이미지도 삭제되나요?
- A: 아니요, 사용 중인 이미지는 절대 삭제되지 않습니다.

**실무 연관**
- 개발자 노트북에서 디스크 공간 확보 시 주로 사용
- CI/CD 서버에서 빌드 후 자동 정리 스크립트로 활용

</details>

<details>
<summary><strong>6. Docker 네트워크 충돌을 어떻게 해결하나요?</strong></summary>

**모범 답안 포인트**
- 회사 VPN과 Docker 네트워크 IP 대역 겹침
- daemon.json에서 default-address-pools 변경
- 172.x.x.x 대역 사용 권장 (충돌 가능성 낮음)
- 변경 후 Docker 재시작 필요

**예시 답변**
> "Docker 네트워크 충돌은 주로 회사 VPN이나 사내 네트워크와 Docker의 기본 IP 대역(172.17.0.0/16)이 겹칠 때 발생합니다. 해결 방법은 daemon.json 파일에서 default-address-pools를 충돌하지 않는 대역으로 변경하는 것입니다. 예를 들어 172.80.0.0/16 같은 대역을 사용하면 대부분의 회사 네트워크와 충돌하지 않습니다. 설정 후 Docker를 재시작하면 새로운 네트워크 대역이 적용되어 컨테이너가 외부 API와 정상적으로 통신할 수 있습니다."

**꼬리 질문**
- Q: 기존 컨테이너는 어떻게 되나요?
- A: 재생성해야 새 네트워크 대역을 사용합니다.

**실무 연관**
- 대기업/금융권에서 VPN 사용 시 자주 발생
- 네트워크 팀과 협의하여 충돌하지 않는 대역 선정

</details>

<details>
<summary><strong>7. 로그 파일이 디스크를 가득 채웠을 때 어떻게 해결하나요?</strong></summary>

**모범 답안 포인트**
- 기본 설정은 로그 무제한 저장
- daemon.json에서 log-opts로 크기 제한
- max-size: 파일당 최대 크기
- max-file: 로테이션 파일 개수
- 기존 컨테이너는 재생성 필요

**예시 답변**
> "Docker는 기본적으로 컨테이너 로그를 무제한으로 저장하여 디스크를 가득 채울 수 있습니다. 해결 방법은 daemon.json에서 log-opts를 설정하는 것으로, max-size를 10m, max-file을 3으로 설정하면 각 컨테이너당 최대 30MB만 사용합니다. 이 설정은 새로 생성되는 컨테이너에만 적용되므로, 기존 컨테이너는 삭제 후 재생성해야 합니다. 운영 환경에서는 로그를 외부 시스템(ELK, CloudWatch)으로 전송하는 것이 더 좋습니다."

**꼬리 질문**
- Q: 이미 쌓인 로그는 어떻게 삭제하나요?
- A: `truncate -s 0 <로그파일>` 또는 컨테이너 재생성

**실무 연관**
- 로그 폭탄으로 인한 디스크 100% 장애 사례 다수
- 사전 예방이 필수 (로그 크기 제한 + 모니터링)

</details>

---

### 📗 중급 개발자용 (3-5개)

<details>
<summary><strong>1. Docker의 스토리지 드라이버 종류와 overlay2를 권장하는 이유는?</strong></summary>

**모범 답안 포인트**
- 스토리지 드라이버: 이미지 레이어를 관리하는 방식
- 종류: overlay2, aufs, devicemapper, btrfs, zfs
- overlay2가 성능과 안정성 최고 (Linux 4.0+)
- CoW(Copy-on-Write) 방식으로 공간 절약

**예시 답변**
> "Docker 스토리지 드라이버는 이미지 레이어를 파일 시스템에 저장하고 관리하는 방식을 결정합니다. 주요 종류로는 overlay2, aufs, devicemapper 등이 있으며, overlay2가 현재 표준으로 권장됩니다. 그 이유는 첫째, Linux 커널 4.0 이상에서 네이티브로 지원되어 성능이 가장 빠르고, 둘째, 메모리 사용량이 적으며, 셋째, inode 사용량이 적어 대규모 컨테이너 환경에 적합하기 때문입니다. overlay2는 CoW 방식으로 동일한 레이어를 공유하여 디스크 공간도 절약합니다."

**실무 예시**:
```bash
# 스토리지 드라이버 확인
docker info | grep "Storage Driver"
Storage Driver: overlay2

# overlay2 설정 (daemon.json)
{
  "storage-driver": "overlay2",
  "storage-opts": [
    "overlay2.override_kernel_check=true"
  ]
}
```

**꼬리 질문**
- Q: devicemapper는 왜 deprecated 되었나요?
- A: 성능이 느리고 설정이 복잡하며, 메타데이터 관리 오버헤드가 크기 때문입니다.

**실무 연관**
- 프로덕션 환경에서 overlay2 사용 필수
- CentOS 7 이하는 devicemapper가 기본이라 변경 필요

</details>

<details>
<summary><strong>2. Live Restore 기능은 무엇이며 언제 사용하나요?</strong></summary>

**모범 답안 포인트**
- Live Restore: Docker 데몬 재시작 시 컨테이너 유지
- 기본값: false (데몬 재시작 시 컨테이너도 중지)
- 활성화 시: 데몬만 재시작, 컨테이너는 계속 실행
- 무중단 업데이트에 유용

**예시 답변**
> "Live Restore는 Docker 데몬을 재시작할 때 실행 중인 컨테이너를 중지하지 않고 유지하는 기능입니다. 기본적으로 Docker 데몬을 재시작하면 모든 컨테이너가 중지되지만, Live Restore를 활성화하면 데몬만 재시작되고 컨테이너는 계속 실행됩니다. 이는 Docker Engine 업데이트나 설정 변경 시 서비스 중단 없이 작업할 수 있어 운영 환경에서 유용합니다. 다만 네트워크나 볼륨 관련 기능은 데몬 재시작 후 일부 제한될 수 있어 주의가 필요합니다."

**실무 예시**:
```bash
# daemon.json 설정
{
  "live-restore": true
}

# Docker 재시작
sudo systemctl restart docker

# 컨테이너 확인
docker ps
# 여전히 실행 중!

# 실제 성과:
# Before: 데몬 재시작 시 서비스 중단 5분
# After: 중단 없음 (0초 다운타임)
```

**꼬리 질문**
- Q: Swarm 모드에서도 작동하나요?
- A: 아니요, Swarm 모드에서는 Live Restore를 지원하지 않습니다.

**실무 연관**
- 24/7 운영 서비스에서 필수 설정
- Blue-Green 배포 없이 Docker 업데이트 가능

</details>

<details>
<summary><strong>3. Docker의 ulimits 설정은 무엇이며 왜 조정해야 하나요?</strong></summary>

**모범 답안 포인트**
- ulimits: 프로세스당 리소스 제한 (파일 디스크립터 등)
- 기본값이 낮아 고성능 앱에서 부족
- nofile: 동시 열 수 있는 파일 수 (소켓 포함)
- 웹 서버, 데이터베이스는 높은 값 필요

**예시 답변**
> "ulimits는 컨테이너 내 프로세스가 사용할 수 있는 리소스 한계를 설정하는 것으로, 대표적으로 nofile(파일 디스크립터 수)이 있습니다. 기본값은 1024로 설정되어 있어, 많은 동시 연결을 처리하는 웹 서버나 데이터베이스에서는 부족합니다. 예를 들어 Nginx가 10,000개의 동시 연결을 처리하려면 최소 10,000개의 파일 디스크립터가 필요한데, 기본값으로는 'Too many open files' 에러가 발생합니다. 따라서 고성능 애플리케이션에서는 nofile을 64000 정도로 증가시켜야 합니다."

**실무 예시**:
```bash
# daemon.json 전역 설정
{
  "default-ulimits": {
    "nofile": {
      "Name": "nofile",
      "Hard": 64000,
      "Soft": 64000
    }
  }
}

# 또는 컨테이너별 설정
docker run -d --ulimit nofile=64000:64000 nginx

# 확인
docker exec myapp sh -c 'ulimit -n'
64000

# 실제 성과:
# Before: 1000 동시 연결에서 에러
# After: 10,000 동시 연결 정상 처리
```

**꼬리 질문**
- Q: Hard와 Soft의 차이는?
- A: Soft는 기본값, Hard는 최대값으로 프로세스가 Soft를 Hard까지 증가시킬 수 있습니다.

**실무 연관**
- 고트래픽 API 서버, Redis, MySQL에서 필수 설정
- 모니터링으로 파일 디스크립터 사용률 추적

</details>

<details>
<summary><strong>4. Docker의 User Namespace Remapping은 어떤 보안 이점이 있나요?</strong></summary>

**모범 답안 포인트**
- 컨테이너 내 root를 호스트의 일반 사용자로 매핑
- 컨테이너 탈출 시 권한 획득 방지
- /etc/subuid, /etc/subgid 사용
- 일부 기능 제약 (볼륨 권한 등)

**예시 답변**
> "User Namespace Remapping은 컨테이너 내부의 root 사용자(UID 0)를 호스트의 일반 사용자(예: UID 100000)로 매핑하여 보안을 강화하는 기능입니다. 컨테이너 내에서는 root 권한으로 작동하지만, 호스트에서는 권한이 없는 일반 사용자로 실행되어, 만약 컨테이너 탈출 공격이 성공하더라도 호스트 시스템을 장악할 수 없습니다. 이는 금융권이나 보안이 중요한 환경에서 필수적인 설정이며, /etc/subuid와 /etc/subgid 파일로 UID/GID 범위를 관리합니다. 다만 호스트 볼륨 권한 설정이 복잡해지는 단점이 있습니다."

**실무 예시**:
```bash
# daemon.json 설정
{
  "userns-remap": "default"
}

# Docker 재시작
sudo systemctl restart docker

# 확인
docker run -it --rm alpine id
uid=0(root) gid=0(root)  # 컨테이너 내부

# 호스트에서 확인
ps aux | grep nginx
100000   12345  ... nginx  # 호스트에서는 UID 100000

# 보안 이점:
# Before: 컨테이너 탈출 시 호스트 root 권한
# After: 컨테이너 탈출해도 일반 사용자 권한만
```

**꼬리 질문**
- Q: 기존 볼륨은 어떻게 되나요?
- A: 권한 재설정 필요 (`chown -R 100000:100000`)

**실무 연관**
- PCI-DSS, ISO 27001 등 보안 인증 시 필수
- 컨테이너 탈출 취약점(CVE) 대응

</details>

<details>
<summary><strong>5. BuildKit을 활성화하면 어떤 이점이 있나요?</strong></summary>

**모범 답안 포인트**
- 차세대 빌드 엔진 (Docker 18.09+)
- 병렬 빌드로 속도 향상
- 빌드 캐시 최적화
- 보안 강화 (secrets, SSH)
- Dockerfile 문법 확장

**예시 답변**
> "BuildKit은 Docker의 차세대 빌드 엔진으로, 기존 빌드보다 여러 이점이 있습니다. 첫째, 의존성이 없는 레이어를 병렬로 빌드하여 속도가 2-3배 빠릅니다. 둘째, 빌드 캐시를 더 효율적으로 사용해 불필요한 재빌드를 줄입니다. 셋째, 빌드 시 민감한 정보를 안전하게 전달하는 --secret 기능을 지원합니다. 넷째, 멀티스테이지 빌드에서 불필요한 스테이지를 건너뛰어 리소스를 절약합니다. 실제로 대규모 Dockerfile 빌드 시 10분이 걸리던 것이 3분으로 단축된 사례가 많습니다."

**실무 예시**:
```bash
# BuildKit 활성화 (daemon.json)
{
  "features": {
    "buildkit": true
  }
}

# 또는 환경변수로
DOCKER_BUILDKIT=1 docker build -t myapp .

# BuildKit 전용 기능 사용
# Dockerfile
FROM node:18 AS build
RUN --mount=type=secret,id=npm_token \
    npm config set //registry.npmjs.org/:_authToken=$(cat /run/secrets/npm_token) && \
    npm install

# 빌드
docker build --secret id=npm_token,src=.npmrc -t myapp .

# 성능 비교:
# Before: 10분 (순차 빌드)
# After: 3분 (병렬 빌드) - 70% 단축!
```

**꼬리 질문**
- Q: 기존 Dockerfile과 호환되나요?
- A: 네, 100% 호환되며 추가 기능도 사용 가능합니다.

**실무 연관**
- CI/CD 파이프라인에서 빌드 시간 단축
- 보안 토큰 관리 (npmrc, Maven settings 등)

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 시스템 요구사항 | Docker 실행을 위한 최소 하드웨어/소프트웨어 | 가상화, WSL 2, 메모리 |
| Docker Desktop | GUI와 개발 도구가 포함된 Windows/Mac용 패키지 | 대시보드, Settings, 리소스 할당 |
| Docker Engine | Linux용 컨테이너 실행 핵심 엔진 | CLI, systemd, daemon.json |
| 리소스 할당 | CPU/메모리/디스크 할당으로 성능 최적화 | 50% 규칙, 스왑, 오버커밋 |
| 네트워크 설정 | IP 대역 설정으로 VPN 충돌 방지 | default-address-pools, 172.x.x.x |
| 로그 관리 | 로그 파일 크기 제한으로 디스크 절약 | max-size, max-file, 로테이션 |
| 보안 설정 | User Namespace, TLS로 보안 강화 | userns-remap, 권한 분리 |

### 필수 명령어/설정 정리

| 명령어/설정 | 용도 | 예시 |
|-------------|------|------|
| `docker --version` | Docker 버전 확인 | `Docker version 24.0.7` |
| `docker info` | 시스템 정보 확인 | 컨테이너 수, 이미지 수, 스토리지 드라이버 |
| `docker run hello-world` | 설치 확인 | 기본 동작 테스트 |
| `docker system prune` | 디스크 정리 | 사용하지 않는 리소스 삭제 |
| `daemon.json` | Docker Engine 설정 | 로그, 네트워크, 스토리지 설정 |
| `wsl --install` | WSL 2 설치 (Windows) | Docker Desktop 사전 요구사항 |
| `sudo usermod -aG docker` | 권한 설정 (Linux) | sudo 없이 docker 사용 |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 리소스는 시스템의 50% 이하로 할당
- [ ] 로그 파일 크기 제한 설정 (10MB x 3개)
- [ ] 주 1회 `docker system prune` 실행
- [ ] 프로덕션은 Linux + Docker Engine 사용
- [ ] 회사 VPN 사용 시 네트워크 대역 변경
- [ ] 컨테이너에 `--restart unless-stopped` 설정
- [ ] BuildKit 활성화로 빌드 속도 향상

#### ❌ 하지 말아야 할 것
- [ ] 시스템 메모리의 80% 이상 Docker에 할당
- [ ] 로그 크기 제한 없이 운영
- [ ] 오래된 이미지/컨테이너 방치
- [ ] Windows Home에서 Hyper-V 사용 시도
- [ ] docker 그룹 권한 무분별하게 부여
- [ ] 프로덕션에서 Docker Desktop 사용
- [ ] 기본 네트워크 대역으로 VPN과 충돌

### 성능/보안 체크리스트

#### 성능
- [ ] overlay2 스토리지 드라이버 사용
- [ ] BuildKit 활성화
- [ ] 병렬 다운로드 수 증가 (max-concurrent-downloads: 10)
- [ ] 불필요한 파일 공유 경로 제거
- [ ] SSD에 Docker 데이터 저장
- [ ] Live Restore 활성화 (운영 환경)

#### 보안
- [ ] User Namespace Remapping 설정
- [ ] TLS 인증서로 원격 접속 보호
- [ ] 로그에 민감 정보 노출 방지
- [ ] 프록시 설정으로 외부 접근 제한
- [ ] 정기적인 Docker Engine 업데이트
- [ ] docker 그룹 권한 최소화

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Docker Compose | 멀티 컨테이너 관리 도구 | ⭐⭐⭐ 필수 |
| Kubernetes | 컨테이너 오케스트레이션 | ⭐⭐ 중급 이후 |
| WSL 2 | Windows의 Linux 서브시스템 | ⭐⭐⭐ Windows 사용자 필수 |
| Nginx | 리버스 프록시 및 로드 밸런서 | ⭐⭐⭐ 실무 필수 |
| CI/CD | 자동 빌드/배포 파이프라인 | ⭐⭐ 중급 |
| Harbor | 프라이빗 레지스트리 | ⭐⭐ 기업 환경 |

---

## 🚀 다음 단계

### 다음 장 미리보기: 06장 - Docker 기본 명령어

- **배울 내용 1**: 이미지 관리 (pull, push, build, tag, rmi)
- **배울 내용 2**: 컨테이너 생명주기 (run, start, stop, restart, rm)
- **배울 내용 3**: 실시간 모니터링 (logs, stats, inspect, exec)
- **실전 프로젝트**: CLI만으로 완전한 웹 서버 구축

### 이 장과의 연결점
```
05장: Docker 설치 및 환경 설정
    ↓
06장: 명령어로 컨테이너 조작
    ↓
07장: Dockerfile로 이미지 빌드
    ↓
최종: 완전한 애플리케이션 배포
```

### 준비하면 좋을 것들
```bash
# 다음 장 실습을 위한 준비

# 1. 자주 쓰는 이미지 미리 다운로드
docker pull nginx:latest
docker pull node:18-alpine
docker pull postgres:15

# 2. Hello World 실행해보기
docker run hello-world

# 3. 기본 명령어 연습
docker ps
docker images
docker --help
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Docker 공식 설치 가이드](https://docs.docker.com/get-docker/)
- [Docker Desktop 문서](https://docs.docker.com/desktop/)
- [daemon.json 레퍼런스](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file)

### 추천 블로그/아티클
- [WSL 2 최고의 설정 방법 (한글)](https://www.44bits.io/ko/post/wsl2-install-and-basic-usage)
- [Docker 리소스 최적화 가이드](https://blog.docker.com/2020/03/docker-performance-optimization/)

### 영상 강의
- [Docker 설치부터 배포까지 (생활코딩)](https://www.youtube.com/watch?v=Bhzz9E3xuXY)
- [Docker Desktop 완벽 가이드](https://www.youtube.com/watch?v=gAkwW2tuIqE)

### 트러블슈팅 자료
- [Docker 공식 트러블슈팅](https://docs.docker.com/desktop/troubleshoot/overview/)
- [WSL 2 이슈 해결 모음](https://github.com/microsoft/WSL/issues)

---

## 🎉 축하합니다!

**학습 완료 후 이제 여러분은**:
✅ Windows/Mac/Linux에서 Docker를 설치할 수 있습니다
✅ 리소스를 최적으로 할당하여 성능을 높일 수 있습니다
✅ 네트워크 충돌, 디스크 부족 등 실무 문제를 해결할 수 있습니다
✅ 보안 설정으로 안전한 Docker 환경을 구축할 수 있습니다
✅ 면접에서 Docker 설치 관련 질문에 자신 있게 답변할 수 있습니다

**다음 단계**:
- [ ] 06장 "Docker 기본 명령어"로 진행
- [ ] 설치 환경 점검 체크리스트 완료
- [ ] 주니어 시나리오 복습하여 실수 예방

**체크리스트**:
- [ ] Docker 버전 확인 완료 (`docker --version`)
- [ ] Hello World 실행 성공
- [ ] 리소스 할당 최적화 완료
- [ ] 로그 크기 제한 설정
- [ ] 네트워크 충돌 확인 및 해결
- [ ] 면접 질문 5개 이상 복습

---

**다음 장으로 이동**: [다음: 06장 Docker 기본 명령어 →](06-기본-명령어.md)

**이전 장으로 돌아가기**: [← 이전: 04장 Docker 아키텍처](04-아키텍처.md)

**목차로 돌아가기**: [📚 전체 목차](../README.md)
