# 15-2. 상속 (Inheritance) - Part 2

## 📋 목차
1. [기업 사례 1: Netflix - 콘텐츠 관리 시스템](#기업-사례-1-netflix)
2. [기업 사례 2: 카카오뱅크 - 금융 상품 관리](#기업-사례-2-카카오뱅크)
3. [기업 사례 3: 쿠팡 - 배송 시스템](#기업-사례-3-쿠팡)
4. [주니어 개발자 시나리오](#주니어-개발자-시나리오)

---

## 🏢 기업 사례 1: Netflix - 콘텐츠 관리 시스템 {#기업-사례-1-netflix}

### 비즈니스 요구사항
Netflix는 영화, 드라마, 다큐멘터리 등 다양한 콘텐츠를 제공합니다. 모든 콘텐츠는 공통 속성(제목, 재생시간, 등급 등)을 가지지만, 각 콘텐츠 타입마다 고유한 속성도 있습니다.

### 상속을 활용한 설계

```java
/**
 * Netflix 콘텐츠 관리 시스템
 * 모든 콘텐츠의 부모 클래스
 */
public class Content {
    // 공통 속성
    protected String contentId;
    protected String title;
    protected String description;
    protected int releaseYear;
    protected String ageRating;  // 전체, 12세, 15세, 청불
    protected int duration;      // 분 단위
    protected double rating;     // 평점 (0.0 ~ 5.0)
    protected long viewCount;    // 조회수

    // 생성자
    public Content(String contentId, String title, String description,
                   int releaseYear, String ageRating, int duration) {
        this.contentId = contentId;
        this.title = title;
        this.description = description;
        this.releaseYear = releaseYear;
        this.ageRating = ageRating;
        this.duration = duration;
        this.rating = 0.0;
        this.viewCount = 0;
    }

    // 공통 메서드
    public void play() {
        viewCount++;
        System.out.println("▶ 재생 중: " + title);
        System.out.println("⏱ 재생시간: " + duration + "분");
    }

    public void addToMyList() {
        System.out.println("✓ '" + title + "' 내가 찜한 콘텐츠에 추가됨");
    }

    public void rate(double userRating) {
        this.rating = (this.rating + userRating) / 2;
        System.out.println("⭐ '" + title + "' 평점: " + String.format("%.1f", rating));
    }

    public void showInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📺 제목: " + title);
        System.out.println("📅 출시년도: " + releaseYear);
        System.out.println("🔞 등급: " + ageRating);
        System.out.println("⏱ 재생시간: " + duration + "분");
        System.out.println("⭐ 평점: " + String.format("%.1f", rating));
        System.out.println("👁 조회수: " + String.format("%,d", viewCount));
    }

    // Getter 메서드들
    public String getContentId() { return contentId; }
    public String getTitle() { return title; }
    public int getDuration() { return duration; }
}

/**
 * 영화 클래스
 */
public class Movie extends Content {
    private String director;
    private String[] mainActors;
    private String genre;
    private boolean hasSubtitle;
    private boolean hasDubbing;

    public Movie(String contentId, String title, String description,
                 int releaseYear, String ageRating, int duration,
                 String director, String[] mainActors, String genre) {
        // 부모 클래스의 생성자 호출
        super(contentId, title, description, releaseYear, ageRating, duration);
        this.director = director;
        this.mainActors = mainActors;
        this.genre = genre;
        this.hasSubtitle = true;
        this.hasDubbing = false;
    }

    // 영화만의 고유 메서드
    public void showMovieInfo() {
        super.showInfo();  // 부모의 정보 출력 메서드 호출
        System.out.println("🎬 감독: " + director);
        System.out.print("🎭 주연: ");
        for (int i = 0; i < mainActors.length; i++) {
            System.out.print(mainActors[i]);
            if (i < mainActors.length - 1) System.out.print(", ");
        }
        System.out.println();
        System.out.println("🎪 장르: " + genre);
        System.out.println("💬 자막: " + (hasSubtitle ? "있음" : "없음"));
        System.out.println("🔊 더빙: " + (hasDubbing ? "있음" : "없음"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void watchWithSubtitle(String language) {
        System.out.println("🎬 영화 재생 - 자막: " + language);
        play();
    }

    public String getDirector() { return director; }
    public String getGenre() { return genre; }
}

/**
 * 드라마(시리즈) 클래스
 */
public class Series extends Content {
    private int totalSeasons;
    private int totalEpisodes;
    private int currentSeason;
    private int currentEpisode;
    private String[] mainCast;
    private String creator;

    public Series(String contentId, String title, String description,
                  int releaseYear, String ageRating, int episodeDuration,
                  int totalSeasons, int totalEpisodes, String creator, String[] mainCast) {
        super(contentId, title, description, releaseYear, ageRating, episodeDuration);
        this.totalSeasons = totalSeasons;
        this.totalEpisodes = totalEpisodes;
        this.currentSeason = 1;
        this.currentEpisode = 1;
        this.creator = creator;
        this.mainCast = mainCast;
    }

    // 시리즈만의 고유 메서드
    public void showSeriesInfo() {
        super.showInfo();
        System.out.println("📺 제작자: " + creator);
        System.out.println("📊 시즌: " + totalSeasons + "개");
        System.out.println("📋 에피소드: " + totalEpisodes + "개");
        System.out.println("▶ 현재 위치: S" + currentSeason + "E" + currentEpisode);
        System.out.print("👥 주요 출연진: ");
        for (int i = 0; i < mainCast.length; i++) {
            System.out.print(mainCast[i]);
            if (i < mainCast.length - 1) System.out.print(", ");
        }
        System.out.println();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void playEpisode(int season, int episode) {
        if (season > 0 && season <= totalSeasons) {
            currentSeason = season;
            currentEpisode = episode;
            System.out.println("▶ " + title + " S" + season + "E" + episode + " 재생");
            play();
        } else {
            System.out.println("❌ 존재하지 않는 시즌입니다.");
        }
    }

    public void playNextEpisode() {
        currentEpisode++;
        System.out.println("⏭ 다음 에피소드 자동 재생...");
        System.out.println("▶ " + title + " S" + currentSeason + "E" + currentEpisode);
        play();
    }

    public void binge() {
        System.out.println("🍿 몰아보기 모드 시작!");
        System.out.println("📺 " + title + " - 시즌 " + currentSeason + " 전체 재생");
    }
}

/**
 * 다큐멘터리 클래스
 */
public class Documentary extends Content {
    private String topic;           // 주제 (자연, 역사, 과학, 사회 등)
    private String narrator;        // 내레이터
    private boolean isEducational;  // 교육용 여부
    private String[] subtopics;     // 세부 주제들

    public Documentary(String contentId, String title, String description,
                       int releaseYear, String ageRating, int duration,
                       String topic, String narrator, boolean isEducational) {
        super(contentId, title, description, releaseYear, ageRating, duration);
        this.topic = topic;
        this.narrator = narrator;
        this.isEducational = isEducational;
    }

    public void showDocumentaryInfo() {
        super.showInfo();
        System.out.println("🎓 주제: " + topic);
        System.out.println("🎙 내레이터: " + narrator);
        System.out.println("📚 교육용: " + (isEducational ? "예" : "아니오"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void playWithNarration() {
        System.out.println("🎙 내레이션: " + narrator);
        System.out.println("🎓 다큐멘터리 재생 - " + topic);
        play();
    }

    public void addToEducationalList() {
        if (isEducational) {
            System.out.println("✓ 교육용 콘텐츠 목록에 추가됨");
        }
    }
}
```

### 실행 예제

```java
public class NetflixContentSystem {
    public static void main(String[] args) {
        System.out.println("🎬 ═══════════════════════════════════");
        System.out.println("   NETFLIX 콘텐츠 관리 시스템");
        System.out.println("═══════════════════════════════════\n");

        // 1. 영화 생성
        String[] parasiteActors = {"송강호", "이선균", "조여정", "최우식"};
        Movie movie = new Movie(
            "MV001",
            "기생충",
            "전원 백수인 기택 가족이 고액 과외를 하게 되면서 벌어지는 이야기",
            2019,
            "15세 이상",
            132,
            "봉준호",
            parasiteActors,
            "드라마/스릴러"
        );

        System.out.println("📽 영화 등록 완료!\n");
        movie.showMovieInfo();

        System.out.println("\n👤 사용자 액션...");
        movie.addToMyList();
        movie.rate(4.8);
        movie.watchWithSubtitle("English");

        // 2. 드라마 생성
        String[] squidGameCast = {"이정재", "박해수", "위하준", "정호연"};
        Series series = new Series(
            "SR001",
            "오징어 게임",
            "456억 원의 상금을 걸고 목숨을 담보로 한 서바이벌 게임",
            2021,
            "청소년 관람불가",
            60,
            1,
            9,
            "황동혁",
            squidGameCast
        );

        System.out.println("\n\n📺 드라마 시리즈 등록 완료!\n");
        series.showSeriesInfo();

        System.out.println("\n👤 사용자 액션...");
        series.addToMyList();
        series.rate(4.9);
        series.playEpisode(1, 1);
        series.playNextEpisode();
        series.binge();

        // 3. 다큐멘터리 생성
        Documentary documentary = new Documentary(
            "DC001",
            "우리의 지구",
            "지구의 아름다운 자연과 생태계를 탐험하는 다큐멘터리",
            2023,
            "전체 관람가",
            50,
            "자연/환경",
            "데이비드 아텐버러",
            true
        );

        System.out.println("\n\n🎓 다큐멘터리 등록 완료!\n");
        documentary.showDocumentaryInfo();

        System.out.println("\n👤 사용자 액션...");
        documentary.addToMyList();
        documentary.rate(4.7);
        documentary.playWithNarration();
        documentary.addToEducationalList();

        // 4. 다형성 활용 - 모든 콘텐츠를 동일하게 처리
        System.out.println("\n\n📊 ═══════════════════════════════════");
        System.out.println("   전체 콘텐츠 통계");
        System.out.println("═══════════════════════════════════");

        Content[] allContents = {movie, series, documentary};
        int totalDuration = 0;

        for (Content content : allContents) {
            System.out.println("• " + content.getTitle() +
                             " (" + content.getDuration() + "분)");
            totalDuration += content.getDuration();
        }

        System.out.println("\n총 콘텐츠 수: " + allContents.length + "개");
        System.out.println("총 재생시간: " + totalDuration + "분");
    }
}
```

### 실행 결과

```
🎬 ═══════════════════════════════════
   NETFLIX 콘텐츠 관리 시스템
═══════════════════════════════════

📽 영화 등록 완료!

━━━━━━━━━━━━━━━━━━━━━━━━━━
📺 제목: 기생충
📅 출시년도: 2019
🔞 등급: 15세 이상
⏱ 재생시간: 132분
⭐ 평점: 0.0
👁 조회수: 0
🎬 감독: 봉준호
🎭 주연: 송강호, 이선균, 조여정, 최우식
🎪 장르: 드라마/스릴러
💬 자막: 있음
🔊 더빙: 없음
━━━━━━━━━━━━━━━━━━━━━━━━━━

👤 사용자 액션...
✓ '기생충' 내가 찜한 콘텐츠에 추가됨
⭐ '기생충' 평점: 2.4
🎬 영화 재생 - 자막: English
▶ 재생 중: 기생충
⏱ 재생시간: 132분


📺 드라마 시리즈 등록 완료!

━━━━━━━━━━━━━━━━━━━━━━━━━━
📺 제목: 오징어 게임
📅 출시년도: 2021
🔞 등급: 청소년 관람불가
⏱ 재생시간: 60분
⭐ 평점: 0.0
👁 조회수: 0
📺 제작자: 황동혁
📊 시즌: 1개
📋 에피소드: 9개
▶ 현재 위치: S1E1
👥 주요 출연진: 이정재, 박해수, 위하준, 정호연
━━━━━━━━━━━━━━━━━━━━━━━━━━

👤 사용자 액션...
✓ '오징어 게임' 내가 찜한 콘텐츠에 추가됨
⭐ '오징어 게임' 평점: 2.5
▶ 오징어 게임 S1E1 재생
▶ 재생 중: 오징어 게임
⏱ 재생시간: 60분
⏭ 다음 에피소드 자동 재생...
▶ 오징어 게임 S1E2
▶ 재생 중: 오징어 게임
⏱ 재생시간: 60분
🍿 몰아보기 모드 시작!
📺 오징어 게임 - 시즌 1 전체 재생


🎓 다큐멘터리 등록 완료!

━━━━━━━━━━━━━━━━━━━━━━━━━━
📺 제목: 우리의 지구
📅 출시년도: 2023
🔞 등급: 전체 관람가
⏱ 재생시간: 50분
⭐ 평점: 0.0
👁 조회수: 0
🎓 주제: 자연/환경
🎙 내레이터: 데이비드 아텐버러
📚 교육용: 예
━━━━━━━━━━━━━━━━━━━━━━━━━━

👤 사용자 액션...
✓ '우리의 지구' 내가 찜한 콘텐츠에 추가됨
⭐ '우리의 지구' 평점: 2.4
🎙 내레이션: 데이비드 아텐버러
🎓 다큐멘터리 재생 - 자연/환경
▶ 재생 중: 우리의 지구
⏱ 재생시간: 50분
✓ 교육용 콘텐츠 목록에 추가됨


📊 ═══════════════════════════════════
   전체 콘텐츠 통계
═══════════════════════════════════
• 기생충 (132분)
• 오징어 게임 (60분)
• 우리의 지구 (50분)

총 콘텐츠 수: 3개
총 재생시간: 242분
```

### 상속의 이점
1. **코드 재사용**: 모든 콘텐츠의 공통 기능을 Content 클래스에서 한 번만 구현
2. **확장성**: 새로운 콘텐츠 타입(예: 스탠드업 코미디) 추가가 쉬움
3. **유지보수**: 공통 기능 수정 시 부모 클래스만 수정하면 됨
4. **다형성**: 모든 콘텐츠를 Content 타입으로 통일된 관리 가능

---

## 🏢 기업 사례 2: 카카오뱅크 - 금융 상품 관리 {#기업-사례-2-카카오뱅크}

### 비즈니스 요구사항
카카오뱅크는 입출금 계좌, 적금, 대출 등 다양한 금융 상품을 제공합니다. 모든 금융 상품은 공통 속성(계좌번호, 잔액, 소유자)을 가지지만, 각 상품마다 고유한 기능이 있습니다.

### 상속을 활용한 설계

```java
/**
 * 모든 금융 상품의 부모 클래스
 */
public class FinancialProduct {
    protected String accountNumber;  // 계좌번호
    protected String ownerName;      // 소유자명
    protected String ownerPhone;     // 연락처
    protected long balance;          // 잔액
    protected String openDate;       // 개설일
    protected boolean isActive;      // 활성 상태

    public FinancialProduct(String accountNumber, String ownerName,
                           String ownerPhone, long initialDeposit, String openDate) {
        this.accountNumber = accountNumber;
        this.ownerName = ownerName;
        this.ownerPhone = ownerPhone;
        this.balance = initialDeposit;
        this.openDate = openDate;
        this.isActive = true;
    }

    // 공통 입금 기능
    public void deposit(long amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("💰 입금 완료: " + String.format("%,d", amount) + "원");
            System.out.println("💳 현재 잔액: " + String.format("%,d", balance) + "원");
        } else {
            System.out.println("❌ 입금액은 0보다 커야 합니다.");
        }
    }

    // 공통 출금 기능
    public boolean withdraw(long amount) {
        if (amount <= 0) {
            System.out.println("❌ 출금액은 0보다 커야 합니다.");
            return false;
        }

        if (balance >= amount) {
            balance -= amount;
            System.out.println("💸 출금 완료: " + String.format("%,d", amount) + "원");
            System.out.println("💳 현재 잔액: " + String.format("%,d", balance) + "원");
            return true;
        } else {
            System.out.println("❌ 잔액이 부족합니다.");
            System.out.println("💳 현재 잔액: " + String.format("%,d", balance) + "원");
            return false;
        }
    }

    // 계좌 정보 조회
    public void showAccountInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📱 KakaoBank");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📋 계좌번호: " + accountNumber);
        System.out.println("👤 예금주: " + ownerName);
        System.out.println("📞 연락처: " + ownerPhone);
        System.out.println("💰 잔액: " + String.format("%,d", balance) + "원");
        System.out.println("📅 개설일: " + openDate);
        System.out.println("✅ 상태: " + (isActive ? "정상" : "정지"));
    }

    // 이체 기능
    public boolean transfer(FinancialProduct targetAccount, long amount) {
        System.out.println("\n🔄 계좌이체 시작...");
        if (this.withdraw(amount)) {
            targetAccount.deposit(amount);
            System.out.println("✅ " + targetAccount.ownerName + "님께 이체 완료");
            return true;
        }
        return false;
    }

    public long getBalance() { return balance; }
    public String getAccountNumber() { return accountNumber; }
    public String getOwnerName() { return ownerName; }
}

/**
 * 입출금 통장 (자유로운 입출금)
 */
public class CheckingAccount extends FinancialProduct {
    private long dailyWithdrawLimit;   // 일일 출금 한도
    private long todayWithdrawn;       // 오늘 출금액
    private int freeTransferCount;     // 무료 이체 횟수
    private int transferCountUsed;     // 사용한 이체 횟수
    private boolean hasDebitCard;      // 체크카드 발급 여부

    public CheckingAccount(String accountNumber, String ownerName,
                          String ownerPhone, long initialDeposit, String openDate) {
        super(accountNumber, ownerName, ownerPhone, initialDeposit, openDate);
        this.dailyWithdrawLimit = 5_000_000;  // 일일 500만원 한도
        this.todayWithdrawn = 0;
        this.freeTransferCount = 10;  // 월 10회 무료
        this.transferCountUsed = 0;
        this.hasDebitCard = false;
    }

    @Override
    public boolean withdraw(long amount) {
        // 일일 한도 체크
        if (todayWithdrawn + amount > dailyWithdrawLimit) {
            System.out.println("❌ 일일 출금 한도를 초과했습니다.");
            System.out.println("💳 일일 한도: " + String.format("%,d", dailyWithdrawLimit) + "원");
            System.out.println("💳 오늘 출금액: " + String.format("%,d", todayWithdrawn) + "원");
            System.out.println("💳 남은 한도: " + String.format("%,d", dailyWithdrawLimit - todayWithdrawn) + "원");
            return false;
        }

        // 부모 클래스의 출금 로직 실행
        if (super.withdraw(amount)) {
            todayWithdrawn += amount;
            return true;
        }
        return false;
    }

    public void showCheckingAccountInfo() {
        super.showAccountInfo();
        System.out.println("🏦 상품명: 입출금통장");
        System.out.println("💳 일일 한도: " + String.format("%,d", dailyWithdrawLimit) + "원");
        System.out.println("💸 오늘 출금: " + String.format("%,d", todayWithdrawn) + "원");
        System.out.println("🔄 무료 이체: " + (freeTransferCount - transferCountUsed) + "회 남음");
        System.out.println("💳 체크카드: " + (hasDebitCard ? "발급됨" : "미발급"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void issueDebitCard() {
        if (!hasDebitCard) {
            hasDebitCard = true;
            System.out.println("💳 체크카드가 발급되었습니다.");
        } else {
            System.out.println("💳 이미 체크카드가 발급되어 있습니다.");
        }
    }

    public void resetDailyLimit() {
        todayWithdrawn = 0;
        System.out.println("✅ 일일 한도가 초기화되었습니다.");
    }
}

/**
 * 정기 적금 (매월 일정 금액 납입)
 */
public class SavingsAccount extends FinancialProduct {
    private long monthlyPayment;      // 월 납입액
    private int termMonths;           // 기간 (개월)
    private double interestRate;      // 이자율 (연 %)
    private int paidMonths;           // 납입 완료 개월 수
    private String nextPaymentDate;   // 다음 납입일
    private long expectedMaturity;    // 만기 예상액

    public SavingsAccount(String accountNumber, String ownerName,
                         String ownerPhone, long monthlyPayment,
                         int termMonths, double interestRate, String openDate) {
        super(accountNumber, ownerName, ownerPhone, 0, openDate);
        this.monthlyPayment = monthlyPayment;
        this.termMonths = termMonths;
        this.interestRate = interestRate;
        this.paidMonths = 0;
        this.nextPaymentDate = "2025-01-15";

        // 만기 예상액 계산 (단리 계산)
        long totalPrincipal = monthlyPayment * termMonths;
        long totalInterest = (long)(totalPrincipal * (interestRate / 100) * (termMonths / 12.0));
        this.expectedMaturity = totalPrincipal + totalInterest;
    }

    @Override
    public boolean withdraw(long amount) {
        System.out.println("❌ 적금은 만기 전 출금이 불가능합니다.");
        System.out.println("📅 만기일까지 " + (termMonths - paidMonths) + "개월 남았습니다.");
        return false;
    }

    // 월 납입
    public void payMonthly() {
        if (paidMonths >= termMonths) {
            System.out.println("✅ 이미 만기된 적금입니다.");
            return;
        }

        deposit(monthlyPayment);
        paidMonths++;
        System.out.println("✅ " + paidMonths + "회차 납입 완료");
        System.out.println("📊 진행률: " + (paidMonths * 100 / termMonths) + "%");

        if (paidMonths >= termMonths) {
            System.out.println("🎉 축하합니다! 적금이 만기되었습니다!");
            maturity();
        }
    }

    // 만기
    public void maturity() {
        System.out.println("\n🎊 ═══════════ 적금 만기 ═══════════");
        System.out.println("💰 원금: " + String.format("%,d", monthlyPayment * termMonths) + "원");
        System.out.println("📈 이자: " + String.format("%,d", expectedMaturity - (monthlyPayment * termMonths)) + "원");
        System.out.println("💵 총 수령액: " + String.format("%,d", expectedMaturity) + "원");
        System.out.println("═══════════════════════════════════\n");
        balance = expectedMaturity;
    }

    public void showSavingsAccountInfo() {
        super.showAccountInfo();
        System.out.println("🏦 상품명: 정기적금");
        System.out.println("💰 월 납입액: " + String.format("%,d", monthlyPayment) + "원");
        System.out.println("📅 기간: " + termMonths + "개월");
        System.out.println("📈 이자율: " + interestRate + "%");
        System.out.println("✅ 납입 횟수: " + paidMonths + "/" + termMonths + "회");
        System.out.println("📊 진행률: " + (paidMonths * 100 / termMonths) + "%");
        System.out.println("💵 만기 예상액: " + String.format("%,d", expectedMaturity) + "원");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 마이너스 통장 (신용 대출)
 */
public class CreditLineAccount extends FinancialProduct {
    private long creditLimit;         // 대출 한도
    private long usedCredit;          // 사용 금액
    private double interestRate;      // 이자율 (연 %)
    private int creditScore;          // 신용등급

    public CreditLineAccount(String accountNumber, String ownerName,
                            String ownerPhone, long creditLimit,
                            double interestRate, int creditScore, String openDate) {
        super(accountNumber, ownerName, ownerPhone, 0, openDate);
        this.creditLimit = creditLimit;
        this.usedCredit = 0;
        this.interestRate = interestRate;
        this.creditScore = creditScore;
    }

    @Override
    public boolean withdraw(long amount) {
        long availableCredit = creditLimit - usedCredit;

        // 잔액이 있으면 잔액부터 사용
        if (balance >= amount) {
            return super.withdraw(amount);
        }

        // 잔액 부족 시 대출 사용
        long needCredit = amount - balance;

        if (needCredit <= availableCredit) {
            // 잔액 전액 사용
            if (balance > 0) {
                System.out.println("💰 잔액 사용: " + String.format("%,d", balance) + "원");
                balance = 0;
            }

            // 대출 사용
            usedCredit += needCredit;
            System.out.println("🏦 대출 사용: " + String.format("%,d", needCredit) + "원");
            System.out.println("💸 출금 완료: " + String.format("%,d", amount) + "원");
            System.out.println("💳 사용 가능 한도: " + String.format("%,d", creditLimit - usedCredit) + "원");
            return true;
        } else {
            System.out.println("❌ 대출 한도를 초과했습니다.");
            System.out.println("💳 사용 가능 한도: " + String.format("%,d", availableCredit) + "원");
            return false;
        }
    }

    @Override
    public void deposit(long amount) {
        if (usedCredit > 0) {
            // 대출 상환 우선
            long repayment = Math.min(amount, usedCredit);
            usedCredit -= repayment;
            System.out.println("💰 대출 상환: " + String.format("%,d", repayment) + "원");
            System.out.println("💳 남은 대출: " + String.format("%,d", usedCredit) + "원");

            long remaining = amount - repayment;
            if (remaining > 0) {
                super.deposit(remaining);
            }
        } else {
            super.deposit(amount);
        }
    }

    public void showCreditLineInfo() {
        super.showAccountInfo();
        System.out.println("🏦 상품명: 마이너스통장");
        System.out.println("💳 대출 한도: " + String.format("%,d", creditLimit) + "원");
        System.out.println("🏦 사용 금액: " + String.format("%,d", usedCredit) + "원");
        System.out.println("💰 남은 한도: " + String.format("%,d", creditLimit - usedCredit) + "원");
        System.out.println("📈 이자율: " + interestRate + "%");
        System.out.println("⭐ 신용등급: " + creditScore + "등급");

        if (usedCredit > 0) {
            long monthlyInterest = (long)(usedCredit * (interestRate / 100 / 12));
            System.out.println("💸 월 이자: " + String.format("%,d", monthlyInterest) + "원");
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 실행 예제

```java
public class KakaoBankSystem {
    public static void main(String[] args) {
        System.out.println("📱 ═══════════════════════════════════");
        System.out.println("      카카오뱅크 금융 상품 시스템");
        System.out.println("═══════════════════════════════════\n");

        // 1. 입출금 통장
        CheckingAccount checking = new CheckingAccount(
            "3333-01-1234567",
            "김민수",
            "010-1234-5678",
            1_000_000,
            "2024-01-01"
        );

        System.out.println("✅ 입출금통장 개설\n");
        checking.showCheckingAccountInfo();

        System.out.println("\n💰 입금 테스트...");
        checking.deposit(500_000);

        System.out.println("\n💸 출금 테스트...");
        checking.withdraw(300_000);

        System.out.println("\n💳 체크카드 발급...");
        checking.issueDebitCard();

        // 2. 정기 적금
        SavingsAccount savings = new SavingsAccount(
            "3333-02-7654321",
            "이영희",
            "010-9876-5432",
            500_000,    // 월 50만원
            12,         // 12개월
            3.5,        // 연 3.5%
            "2024-01-01"
        );

        System.out.println("\n\n✅ 정기적금 개설\n");
        savings.showSavingsAccountInfo();

        System.out.println("\n💰 월 납입 시뮬레이션...");
        for (int month = 1; month <= 3; month++) {
            System.out.println("\n--- " + month + "개월차 납입 ---");
            savings.payMonthly();
        }

        System.out.println("\n💸 중도 출금 시도...");
        savings.withdraw(100_000);

        // 3. 마이너스 통장
        CreditLineAccount creditLine = new CreditLineAccount(
            "3333-03-1111111",
            "박철수",
            "010-1111-2222",
            10_000_000,  // 한도 1000만원
            4.5,         // 연 4.5%
            2,           // 2등급
            "2024-01-01"
        );

        System.out.println("\n\n✅ 마이너스통장 개설\n");
        creditLine.showCreditLineInfo();

        System.out.println("\n💰 입금...");
        creditLine.deposit(2_000_000);

        System.out.println("\n💸 대출 사용...");
        creditLine.withdraw(5_000_000);

        System.out.println("\n");
        creditLine.showCreditLineInfo();

        System.out.println("\n💰 대출 상환...");
        creditLine.deposit(2_000_000);

        // 4. 계좌이체
        System.out.println("\n\n🔄 ═══════════════════════════════════");
        System.out.println("        계좌이체 테스트");
        System.out.println("═══════════════════════════════════");

        System.out.println("김민수 → 박철수에게 500,000원 이체");
        checking.transfer(creditLine, 500_000);

        System.out.println("\n--- 이체 후 잔액 확인 ---");
        System.out.println("김민수 잔액: " + String.format("%,d", checking.getBalance()) + "원");
        System.out.println("박철수 잔액: " + String.format("%,d", creditLine.getBalance()) + "원");
    }
}
```

### 실행 결과

```
📱 ═══════════════════════════════════
      카카오뱅크 금융 상품 시스템
═══════════════════════════════════

✅ 입출금통장 개설

━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 KakaoBank
━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 계좌번호: 3333-01-1234567
👤 예금주: 김민수
📞 연락처: 010-1234-5678
💰 잔액: 1,000,000원
📅 개설일: 2024-01-01
✅ 상태: 정상
🏦 상품명: 입출금통장
💳 일일 한도: 5,000,000원
💸 오늘 출금: 0원
🔄 무료 이체: 10회 남음
💳 체크카드: 미발급
━━━━━━━━━━━━━━━━━━━━━━━━━━

💰 입금 테스트...
💰 입금 완료: 500,000원
💳 현재 잔액: 1,500,000원

💸 출금 테스트...
💸 출금 완료: 300,000원
💳 현재 잔액: 1,200,000원

💳 체크카드 발급...
💳 체크카드가 발급되었습니다.


✅ 정기적금 개설

━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 KakaoBank
━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 계좌번호: 3333-02-7654321
👤 예금주: 이영희
📞 연락처: 010-9876-5432
💰 잔액: 0원
📅 개설일: 2024-01-01
✅ 상태: 정상
🏦 상품명: 정기적금
💰 월 납입액: 500,000원
📅 기간: 12개월
📈 이자율: 3.5%
✅ 납입 횟수: 0/12회
📊 진행률: 0%
💵 만기 예상액: 6,105,000원
━━━━━━━━━━━━━━━━━━━━━━━━━━

💰 월 납입 시뮬레이션...

--- 1개월차 납입 ---
💰 입금 완료: 500,000원
💳 현재 잔액: 500,000원
✅ 1회차 납입 완료
📊 진행률: 8%

--- 2개월차 납입 ---
💰 입금 완료: 500,000원
💳 현재 잔액: 1,000,000원
✅ 2회차 납입 완료
📊 진행률: 16%

--- 3개월차 납입 ---
💰 입금 완료: 500,000원
💳 현재 잔액: 1,500,000원
✅ 3회차 납입 완료
📊 진행률: 25%

💸 중도 출금 시도...
❌ 적금은 만기 전 출금이 불가능합니다.
📅 만기일까지 9개월 남았습니다.


✅ 마이너스통장 개설

━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 KakaoBank
━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 계좌번호: 3333-03-1111111
👤 예금주: 박철수
📞 연락처: 010-1111-2222
💰 잔액: 0원
📅 개설일: 2024-01-01
✅ 상태: 정상
🏦 상품명: 마이너스통장
💳 대출 한도: 10,000,000원
🏦 사용 금액: 0원
💰 남은 한도: 10,000,000원
📈 이자율: 4.5%
⭐ 신용등급: 2등급
━━━━━━━━━━━━━━━━━━━━━━━━━━

💰 입금...
💰 입금 완료: 2,000,000원
💳 현재 잔액: 2,000,000원

💸 대출 사용...
💰 잔액 사용: 2,000,000원
🏦 대출 사용: 3,000,000원
💸 출금 완료: 5,000,000원
💳 사용 가능 한도: 7,000,000원

━━━━━━━━━━━━━━━━━━━━━━━━━━
📱 KakaoBank
━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 계좌번호: 3333-03-1111111
👤 예금주: 박철수
📞 연락처: 010-1111-2222
💰 잔액: 0원
📅 개설일: 2024-01-01
✅ 상태: 정상
🏦 상품명: 마이너스통장
💳 대출 한도: 10,000,000원
🏦 사용 금액: 3,000,000원
💰 남은 한도: 7,000,000원
📈 이자율: 4.5%
⭐ 신용등급: 2등급
💸 월 이자: 11,250원
━━━━━━━━━━━━━━━━━━━━━━━━━━

💰 대출 상환...
💰 대출 상환: 2,000,000원
💳 남은 대출: 1,000,000원


🔄 ═══════════════════════════════════
        계좌이체 테스트
═══════════════════════════════════
김민수 → 박철수에게 500,000원 이체

🔄 계좌이체 시작...
💸 출금 완료: 500,000원
💳 현재 잔액: 700,000원
💰 대출 상환: 500,000원
💳 남은 대출: 500,000원
✅ 박철수님께 이체 완료

--- 이체 후 잔액 확인 ---
김민수 잔액: 700,000원
박철수 잔액: 0원
```

### 상속의 이점
1. **공통 기능 통합**: 입금, 출금, 조회 등 모든 금융 상품의 공통 기능을 한 곳에서 관리
2. **다형성**: 모든 금융 상품을 FinancialProduct 타입으로 통일 처리 가능
3. **메서드 오버라이딩**: 각 상품별 특화된 입출금 규칙 적용 가능
4. **확장성**: 새로운 금융 상품 추가가 쉬움

---

## 🏢 기업 사례 3: 쿠팡 - 배송 시스템 {#기업-사례-3-쿠팡}

### 비즈니스 요구사항
쿠팡은 일반 배송, 로켓배송, 새벽배송 등 다양한 배송 옵션을 제공합니다. 모든 배송은 공통 속성(주문번호, 주소, 상태)을 가지지만, 배송 방식마다 고유한 특징이 있습니다.

### 상속을 활용한 설계

```java
/**
 * 모든 배송의 부모 클래스
 */
public class Delivery {
    protected String deliveryId;        // 배송 ID
    protected String orderId;           // 주문번호
    protected String senderName;        // 발송인
    protected String recipientName;     // 수령인
    protected String recipientPhone;    // 수령인 연락처
    protected String address;           // 배송 주소
    protected String detailAddress;     // 상세 주소
    protected String status;            // 배송 상태
    protected long deliveryFee;         // 배송비
    protected String orderDate;         // 주문일
    protected String expectedDate;      // 도착 예정일

    public Delivery(String deliveryId, String orderId, String senderName,
                   String recipientName, String recipientPhone,
                   String address, String detailAddress, String orderDate) {
        this.deliveryId = deliveryId;
        this.orderId = orderId;
        this.senderName = senderName;
        this.recipientName = recipientName;
        this.recipientPhone = recipientPhone;
        this.address = address;
        this.detailAddress = detailAddress;
        this.status = "상품 준비중";
        this.orderDate = orderDate;
    }

    // 배송 시작
    public void startDelivery() {
        status = "배송 시작";
        System.out.println("🚚 배송이 시작되었습니다.");
        System.out.println("📦 " + recipientName + "님께 배송 중");
    }

    // 배송 중
    public void inTransit() {
        status = "배송 중";
        System.out.println("🚛 상품이 배송 중입니다.");
    }

    // 배송 완료
    public void complete() {
        status = "배송 완료";
        System.out.println("✅ 배송이 완료되었습니다!");
        System.out.println("📍 " + address);
    }

    // 배송 정보 조회
    public void showDeliveryInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📦 쿠팡 배송 조회");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🆔 배송번호: " + deliveryId);
        System.out.println("📋 주문번호: " + orderId);
        System.out.println("📤 발송인: " + senderName);
        System.out.println("📥 수령인: " + recipientName);
        System.out.println("📞 연락처: " + recipientPhone);
        System.out.println("📍 주소: " + address);
        System.out.println("🏠 상세주소: " + detailAddress);
        System.out.println("📊 상태: " + status);
        System.out.println("💰 배송비: " + String.format("%,d", deliveryFee) + "원");
        System.out.println("📅 주문일: " + orderDate);
        System.out.println("📅 도착 예정: " + expectedDate);
    }

    // 배송 추적
    public void track() {
        System.out.println("🔍 배송 추적: " + deliveryId);
        System.out.println("현재 상태: " + status);
    }

    public String getStatus() { return status; }
    public String getDeliveryId() { return deliveryId; }
}

/**
 * 로켓배송 (빠른 배송)
 */
public class RocketDelivery extends Delivery {
    private boolean isTodayDelivery;    // 오늘출발 여부
    private boolean isWowMember;        // 와우 회원 여부
    private String rocketWarehouse;     // 로켓 물류센터
    private int estimatedHours;         // 예상 도착 시간

    public RocketDelivery(String deliveryId, String orderId, String senderName,
                         String recipientName, String recipientPhone,
                         String address, String detailAddress, String orderDate,
                         boolean isWowMember) {
        super(deliveryId, orderId, senderName, recipientName, recipientPhone,
              address, detailAddress, orderDate);
        this.isWowMember = isWowMember;
        this.isTodayDelivery = true;
        this.rocketWarehouse = "쿠팡 김포 물류센터";
        this.estimatedHours = 24;  // 24시간 이내 도착
        this.deliveryFee = isWowMember ? 0 : 2_500;
        this.expectedDate = "2025-01-11";  // 내일
    }

    @Override
    public void startDelivery() {
        super.startDelivery();
        System.out.println("🚀 로켓배송으로 빠르게 배송됩니다!");
        System.out.println("📍 출발지: " + rocketWarehouse);
        System.out.println("⏰ 예상 도착: " + estimatedHours + "시간 이내");

        if (isWowMember) {
            System.out.println("⭐ 와우 회원 무료배송");
        }
    }

    public void showRocketInfo() {
        super.showDeliveryInfo();
        System.out.println("🚀 배송 타입: 로켓배송");
        System.out.println("📍 물류센터: " + rocketWarehouse);
        System.out.println("⏰ 예상 도착: " + estimatedHours + "시간 이내");
        System.out.println("⭐ 와우 회원: " + (isWowMember ? "예" : "아니오"));
        System.out.println("🏃 오늘출발: " + (isTodayDelivery ? "가능" : "불가"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    // 빠른 배송 프로세스
    public void fastProcess() {
        System.out.println("\n🚀 로켓배송 프로세스");
        System.out.println("1️⃣ 물류센터 출고 완료");
        startDelivery();
        System.out.println("2️⃣ 쿠팡 차량 상차 완료");
        inTransit();
        System.out.println("3️⃣ 고객님 지역 배송 중");
        System.out.println("4️⃣ 배송 완료 예정");
    }
}

/**
 * 새벽배송 (새벽 도착)
 */
public class DawnDelivery extends Delivery {
    private String deliveryTime;        // 배송 시간대
    private boolean isRocketFresh;      // 로켓프레시 여부
    private String freshCenter;         // 신선물류센터
    private int temperature;            // 보관 온도

    public DawnDelivery(String deliveryId, String orderId, String senderName,
                       String recipientName, String recipientPhone,
                       String address, String detailAddress, String orderDate,
                       String deliveryTime) {
        super(deliveryId, orderId, senderName, recipientName, recipientPhone,
              address, detailAddress, orderDate);
        this.deliveryTime = deliveryTime;
        this.isRocketFresh = true;
        this.freshCenter = "쿠팡 신선식품 센터";
        this.temperature = 5;  // 5도 냉장 보관
        this.deliveryFee = 0;  // 새벽배송 무료 (일정 금액 이상)
        this.expectedDate = "2025-01-11 새벽";
    }

    @Override
    public void startDelivery() {
        super.startDelivery();
        System.out.println("🌙 새벽배송으로 신선하게 배송됩니다!");
        System.out.println("🏢 출발지: " + freshCenter);
        System.out.println("🕐 배송 시간: " + deliveryTime);
        System.out.println("❄️ 냉장 보관 온도: " + temperature + "℃");
    }

    @Override
    public void complete() {
        super.complete();
        System.out.println("🌅 새벽에 문 앞에 안전하게 배송되었습니다.");
        System.out.println("📦 보냉박스에 신선하게 보관되어 있습니다.");
    }

    public void showDawnDeliveryInfo() {
        super.showDeliveryInfo();
        System.out.println("🌙 배송 타입: 새벽배송");
        System.out.println("🏢 신선센터: " + freshCenter);
        System.out.println("🕐 배송 시간: " + deliveryTime);
        System.out.println("❄️ 보관 온도: " + temperature + "℃");
        System.out.println("🥗 로켓프레시: " + (isRocketFresh ? "예" : "아니오"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    // 신선도 체크
    public void checkFreshness() {
        System.out.println("\n❄️ 신선도 체크");
        System.out.println("✅ 냉장 상태: 양호 (" + temperature + "℃)");
        System.out.println("✅ 포장 상태: 정상");
        System.out.println("✅ 유통기한: 확인 완료");
    }
}

/**
 * 일반배송 (택배)
 */
public class StandardDelivery extends Delivery {
    private String courier;             // 택배사
    private String trackingNumber;      // 운송장 번호
    private int estimatedDays;          // 예상 소요 일수
    private String currentLocation;     // 현재 위치

    public StandardDelivery(String deliveryId, String orderId, String senderName,
                           String recipientName, String recipientPhone,
                           String address, String detailAddress, String orderDate,
                           String courier) {
        super(deliveryId, orderId, senderName, recipientName, recipientPhone,
              address, detailAddress, orderDate);
        this.courier = courier;
        this.trackingNumber = "1234-5678-9012";
        this.estimatedDays = 3;  // 3일 소요
        this.currentLocation = "집하 대기";
        this.deliveryFee = 3_000;
        this.expectedDate = "2025-01-13";  // 3일 후
    }

    @Override
    public void startDelivery() {
        super.startDelivery();
        System.out.println("📦 일반배송으로 배송됩니다.");
        System.out.println("🚚 택배사: " + courier);
        System.out.println("📋 운송장: " + trackingNumber);
        System.out.println("📅 예상 소요: " + estimatedDays + "일");
    }

    @Override
    public void track() {
        super.track();
        System.out.println("🚚 택배사: " + courier);
        System.out.println("📋 운송장: " + trackingNumber);
        System.out.println("📍 현재 위치: " + currentLocation);
    }

    public void showStandardDeliveryInfo() {
        super.showDeliveryInfo();
        System.out.println("📦 배송 타입: 일반배송");
        System.out.println("🚚 택배사: " + courier);
        System.out.println("📋 운송장: " + trackingNumber);
        System.out.println("📍 현재 위치: " + currentLocation);
        System.out.println("📅 예상 소요: " + estimatedDays + "일");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    // 배송 경로 업데이트
    public void updateLocation(String location) {
        currentLocation = location;
        System.out.println("📍 위치 업데이트: " + location);
    }
}
```

### 실행 예제

```java
public class CoupangDeliverySystem {
    public static void main(String[] args) {
        System.out.println("📦 ═══════════════════════════════════");
        System.out.println("      쿠팡 배송 관리 시스템");
        System.out.println("═══════════════════════════════════\n");

        // 1. 로켓배송
        RocketDelivery rocket = new RocketDelivery(
            "RKT-20250110-001",
            "ORD-123456",
            "쿠팡물류센터",
            "김철수",
            "010-1234-5678",
            "서울시 강남구 테헤란로 123",
            "A동 101호",
            "2025-01-10",
            true  // 와우 회원
        );

        System.out.println("🚀 로켓배송 주문\n");
        rocket.showRocketInfo();
        rocket.fastProcess();

        // 2. 새벽배송
        DawnDelivery dawn = new DawnDelivery(
            "DWN-20250110-002",
            "ORD-123457",
            "쿠팡프레시센터",
            "이영희",
            "010-9876-5432",
            "서울시 송파구 잠실로 456",
            "B동 202호",
            "2025-01-10",
            "새벽 7시 이전"
        );

        System.out.println("\n\n🌙 새벽배송 주문\n");
        dawn.showDawnDeliveryInfo();

        System.out.println("\n🌙 새벽배송 프로세스");
        dawn.startDelivery();
        dawn.checkFreshness();
        System.out.println("\n🌅 새벽 배송 중...");
        dawn.complete();

        // 3. 일반배송
        StandardDelivery standard = new StandardDelivery(
            "STD-20250110-003",
            "ORD-123458",
            "판매자",
            "박민수",
            "010-1111-2222",
            "부산시 해운대구 마린시티 789",
            "C동 303호",
            "2025-01-10",
            "CJ대한통운"
        );

        System.out.println("\n\n📦 일반배송 주문\n");
        standard.showStandardDeliveryInfo();

        System.out.println("\n📦 일반배송 프로세스");
        standard.startDelivery();

        System.out.println("\n🔍 배송 추적...");
        standard.updateLocation("서울 집하장");
        standard.updateLocation("부산 터미널");
        standard.updateLocation("해운대구 배송 중");
        standard.track();

        // 4. 다형성 활용 - 모든 배송을 통합 관리
        System.out.println("\n\n📊 ═══════════════════════════════════");
        System.out.println("      전체 배송 현황");
        System.out.println("═══════════════════════════════════");

        Delivery[] allDeliveries = {rocket, dawn, standard};

        for (Delivery delivery : allDeliveries) {
            System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
            System.out.println("🆔 배송번호: " + delivery.getDeliveryId());
            System.out.println("📊 상태: " + delivery.getStatus());
            System.out.println();
        }

        System.out.println("총 배송 건수: " + allDeliveries.length + "건");
    }
}
```

### 실행 결과

```
📦 ═══════════════════════════════════
      쿠팡 배송 관리 시스템
═══════════════════════════════════

🚀 로켓배송 주문

━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 쿠팡 배송 조회
━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: RKT-20250110-001
📋 주문번호: ORD-123456
📤 발송인: 쿠팡물류센터
📥 수령인: 김철수
📞 연락처: 010-1234-5678
📍 주소: 서울시 강남구 테헤란로 123
🏠 상세주소: A동 101호
📊 상태: 상품 준비중
💰 배송비: 0원
📅 주문일: 2025-01-10
📅 도착 예정: 2025-01-11
🚀 배송 타입: 로켓배송
📍 물류센터: 쿠팡 김포 물류센터
⏰ 예상 도착: 24시간 이내
⭐ 와우 회원: 예
🏃 오늘출발: 가능
━━━━━━━━━━━━━━━━━━━━━━━━━━

🚀 로켓배송 프로세스
1️⃣ 물류센터 출고 완료
🚚 배송이 시작되었습니다.
📦 김철수님께 배송 중
🚀 로켓배송으로 빠르게 배송됩니다!
📍 출발지: 쿠팡 김포 물류센터
⏰ 예상 도착: 24시간 이내
⭐ 와우 회원 무료배송
2️⃣ 쿠팡 차량 상차 완료
🚛 상품이 배송 중입니다.
3️⃣ 고객님 지역 배송 중
4️⃣ 배송 완료 예정


🌙 새벽배송 주문

━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 쿠팡 배송 조회
━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: DWN-20250110-002
📋 주문번호: ORD-123457
📤 발송인: 쿠팡프레시센터
📥 수령인: 이영희
📞 연락처: 010-9876-5432
📍 주소: 서울시 송파구 잠실로 456
🏠 상세주소: B동 202호
📊 상태: 상품 준비중
💰 배송비: 0원
📅 주문일: 2025-01-10
📅 도착 예정: 2025-01-11 새벽
🌙 배송 타입: 새벽배송
🏢 신선센터: 쿠팡 신선식품 센터
🕐 배송 시간: 새벽 7시 이전
❄️ 보관 온도: 5℃
🥗 로켓프레시: 예
━━━━━━━━━━━━━━━━━━━━━━━━━━

🌙 새벽배송 프로세스
🚚 배송이 시작되었습니다.
📦 이영희님께 배송 중
🌙 새벽배송으로 신선하게 배송됩니다!
🏢 출발지: 쿠팡 신선식품 센터
🕐 배송 시간: 새벽 7시 이전
❄️ 냉장 보관 온도: 5℃

❄️ 신선도 체크
✅ 냉장 상태: 양호 (5℃)
✅ 포장 상태: 정상
✅ 유통기한: 확인 완료

🌅 새벽 배송 중...
✅ 배송이 완료되었습니다!
📍 서울시 송파구 잠실로 456
🌅 새벽에 문 앞에 안전하게 배송되었습니다.
📦 보냉박스에 신선하게 보관되어 있습니다.


📦 일반배송 주문

━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 쿠팡 배송 조회
━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: STD-20250110-003
📋 주문번호: ORD-123458
📤 발송인: 판매자
📥 수령인: 박민수
📞 연락처: 010-1111-2222
📍 주소: 부산시 해운대구 마린시티 789
🏠 상세주소: C동 303호
📊 상태: 상품 준비중
💰 배송비: 3,000원
📅 주문일: 2025-01-10
📅 도착 예정: 2025-01-13
📦 배송 타입: 일반배송
🚚 택배사: CJ대한통운
📋 운송장: 1234-5678-9012
📍 현재 위치: 집하 대기
📅 예상 소요: 3일
━━━━━━━━━━━━━━━━━━━━━━━━━━

📦 일반배송 프로세스
🚚 배송이 시작되었습니다.
📦 박민수님께 배송 중
📦 일반배송으로 배송됩니다.
🚚 택배사: CJ대한통운
📋 운송장: 1234-5678-9012
📅 예상 소요: 3일

🔍 배송 추적...
📍 위치 업데이트: 서울 집하장
📍 위치 업데이트: 부산 터미널
📍 위치 업데이트: 해운대구 배송 중
🔍 배송 추적: STD-20250110-003
현재 상태: 배송 시작
🚚 택배사: CJ대한통운
📋 운송장: 1234-5678-9012
📍 현재 위치: 해운대구 배송 중


📊 ═══════════════════════════════════
      전체 배송 현황
═══════════════════════════════════
━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: RKT-20250110-001
📊 상태: 배송 중

━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: DWN-20250110-002
📊 상태: 배송 완료

━━━━━━━━━━━━━━━━━━━━━━━━━━
🆔 배송번호: STD-20250110-003
📊 상태: 배송 시작

총 배송 건수: 3건
```

### 상속의 이점
1. **공통 기능 재사용**: 모든 배송의 기본 기능을 Delivery 클래스에서 관리
2. **특화된 기능**: 각 배송 방식에 맞는 고유 기능 추가 가능
3. **메서드 오버라이딩**: 배송 타입별 특화된 로직 구현 가능
4. **확장성**: 새로운 배송 방식(예: 드론배송) 추가가 쉬움

---

## 👨‍💻 주니어 개발자가 자주 하는 실수 {#주니어-개발자-시나리오}

### 시나리오 1: 부모 생성자를 호출하지 않는 실수

```java
/**
 * ❌ 잘못된 코드
 */
public class Animal {
    protected String name;
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("동물 생성: " + name);
    }
}

public class Dog extends Animal {
    private String breed;

    // ❌ 컴파일 에러!
    // 부모 클래스의 기본 생성자가 없는데 super()를 호출하지 않음
    public Dog(String name, int age, String breed) {
        this.breed = breed;  // ❌ 에러 발생
    }
}

// 컴파일 에러:
// There is no default constructor available in 'Animal'
```

**문제점:**
- 부모 클래스에 매개변수가 있는 생성자만 있으면, 자동으로 기본 생성자가 생성되지 않음
- 자식 클래스는 반드시 부모 생성자를 명시적으로 호출해야 함
- `super()`는 자식 생성자의 첫 줄에 와야 함

```java
/**
 * ✅ 올바른 코드
 */
public class Animal {
    protected String name;
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("동물 생성: " + name);
    }
}

public class Dog extends Animal {
    private String breed;

    // ✅ 올바른 생성자
    public Dog(String name, int age, String breed) {
        super(name, age);  // ✅ 부모 생성자를 반드시 먼저 호출
        this.breed = breed;
        System.out.println("강아지 품종: " + breed);
    }

    public void bark() {
        System.out.println(name + "가 짖습니다: 멍멍!");
    }
}

public class AnimalTest {
    public static void main(String[] args) {
        System.out.println("=== 동물 생성 테스트 ===\n");

        Dog dog = new Dog("뽀삐", 3, "포메라니안");
        dog.bark();

        System.out.println("\n=== 정보 출력 ===");
        System.out.println("이름: " + dog.name);  // protected이므로 접근 가능 (같은 패키지)
        System.out.println("나이: " + dog.age);
    }
}

// 실행 결과:
// === 동물 생성 테스트 ===
//
// 동물 생성: 뽀삐
// 강아지 품종: 포메라니안
// 뽀삐가 짖습니다: 멍멍!
//
// === 정보 출력 ===
// 이름: 뽀삐
// 나이: 3
```

**교훈:**
1. 자식 클래스 생성자의 첫 줄에는 반드시 `super()` 또는 `this()` 호출이 있어야 함
2. 명시적으로 작성하지 않으면 컴파일러가 `super()`를 자동 추가하지만, 부모에 기본 생성자가 없으면 에러 발생
3. 부모 클래스의 매개변수를 자식 생성자에서 전달해야 함

---

### 시나리오 2: Private 필드 접근 시도

```java
/**
 * ❌ 잘못된 코드
 */
public class BankAccount {
    private String accountNumber;  // private 필드
    private long balance;          // private 필드

    public BankAccount(String accountNumber, long initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public long getBalance() {
        return balance;
    }
}

public class SavingsAccount extends BankAccount {
    private double interestRate;

    public SavingsAccount(String accountNumber, long initialBalance, double interestRate) {
        super(accountNumber, initialBalance);
        this.interestRate = interestRate;
    }

    public void addInterest() {
        // ❌ 컴파일 에러!
        // balance는 private이므로 자식 클래스에서 직접 접근 불가
        long interest = (long)(balance * interestRate);  // ❌ 에러 발생
        balance += interest;  // ❌ 에러 발생
    }
}

// 컴파일 에러:
// 'balance' has private access in 'BankAccount'
```

**문제점:**
- `private` 필드는 자식 클래스에서도 직접 접근할 수 없음
- 상속받았다고 해서 모든 멤버에 접근할 수 있는 것은 아님

```java
/**
 * ✅ 올바른 코드 - 방법 1: protected 사용
 */
public class BankAccount {
    protected String accountNumber;  // ✅ protected로 변경
    protected long balance;          // ✅ protected로 변경

    public BankAccount(String accountNumber, long initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public long getBalance() {
        return balance;
    }

    public void showAccountInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("계좌번호: " + accountNumber);
        System.out.println("잔액: " + String.format("%,d", balance) + "원");
    }
}

public class SavingsAccount extends BankAccount {
    private double interestRate;

    public SavingsAccount(String accountNumber, long initialBalance, double interestRate) {
        super(accountNumber, initialBalance);
        this.interestRate = interestRate;
    }

    // ✅ protected 필드에 직접 접근 가능
    public void addInterest() {
        long interest = (long)(balance * interestRate);
        balance += interest;
        System.out.println("💰 이자 적용: " + String.format("%,d", interest) + "원");
        System.out.println("💵 현재 잔액: " + String.format("%,d", balance) + "원");
    }

    @Override
    public void showAccountInfo() {
        super.showAccountInfo();
        System.out.println("이자율: " + (interestRate * 100) + "%");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * ✅ 올바른 코드 - 방법 2: Getter/Setter 사용 (private 유지)
 */
public class BankAccount2 {
    private String accountNumber;  // private 유지
    private long balance;          // private 유지

    public BankAccount2(String accountNumber, long initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    // ✅ Getter 제공
    public long getBalance() {
        return balance;
    }

    // ✅ Protected setter 제공 (자식 클래스에서만 사용)
    protected void setBalance(long balance) {
        this.balance = balance;
    }

    public void showAccountInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("계좌번호: " + accountNumber);
        System.out.println("잔액: " + String.format("%,d", balance) + "원");
    }
}

public class SavingsAccount2 extends BankAccount2 {
    private double interestRate;

    public SavingsAccount2(String accountNumber, long initialBalance, double interestRate) {
        super(accountNumber, initialBalance);
        this.interestRate = interestRate;
    }

    // ✅ Getter/Setter 사용
    public void addInterest() {
        long currentBalance = getBalance();  // ✅ Getter 사용
        long interest = (long)(currentBalance * interestRate);
        setBalance(currentBalance + interest);  // ✅ Setter 사용
        System.out.println("💰 이자 적용: " + String.format("%,d", interest) + "원");
        System.out.println("💵 현재 잔액: " + String.format("%,d", getBalance()) + "원");
    }
}

public class AccessModifierTest {
    public static void main(String[] args) {
        System.out.println("=== 방법 1: protected 필드 사용 ===\n");

        SavingsAccount account1 = new SavingsAccount("1234-5678", 1_000_000, 0.05);
        account1.showAccountInfo();
        System.out.println("\n이자 계산 중...");
        account1.addInterest();
        System.out.println();
        account1.showAccountInfo();

        System.out.println("\n\n=== 방법 2: Getter/Setter 사용 ===\n");

        SavingsAccount2 account2 = new SavingsAccount2("9876-5432", 2_000_000, 0.03);
        account2.showAccountInfo();
        System.out.println("\n이자 계산 중...");
        account2.addInterest();
    }
}

// 실행 결과:
// === 방법 1: protected 필드 사용 ===
//
// ━━━━━━━━━━━━━━━━━━━━
// 계좌번호: 1234-5678
// 잔액: 1,000,000원
// 이자율: 5.0%
// ━━━━━━━━━━━━━━━━━━━━
//
// 이자 계산 중...
// 💰 이자 적용: 50,000원
// 💵 현재 잔액: 1,050,000원
//
// ━━━━━━━━━━━━━━━━━━━━
// 계좌번호: 1234-5678
// 잔액: 1,050,000원
// 이자율: 5.0%
// ━━━━━━━━━━━━━━━━━━━━
//
//
// === 방법 2: Getter/Setter 사용 ===
//
// ━━━━━━━━━━━━━━━━━━━━
// 계좌번호: 9876-5432
// 잔액: 2,000,000원
//
// 이자 계산 중...
// 💰 이자 적용: 60,000원
// 💵 현재 잔액: 2,060,000원
```

**접근 제어자 비교표:**

| 접근 제어자 | 같은 클래스 | 같은 패키지 | 자식 클래스 | 전체 |
|------------|-----------|-----------|-----------|------|
| `private` | ✅ | ❌ | ❌ | ❌ |
| `default` (없음) | ✅ | ✅ | ❌ | ❌ |
| `protected` | ✅ | ✅ | ✅ | ❌ |
| `public` | ✅ | ✅ | ✅ | ✅ |

**교훈:**
1. `private` 필드는 자식 클래스에서도 접근 불가
2. 자식 클래스에서 접근이 필요하면 `protected` 사용
3. 캡슐화를 유지하려면 `private` + getter/setter 조합 사용
4. 상속 구조를 설계할 때 접근 제어자를 신중히 선택해야 함

---

### 시나리오 3: super와 this 호출 순서 실수

```java
/**
 * ❌ 잘못된 코드
 */
public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;

    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        System.out.println("차량 생성: " + brand + " " + model);
    }
}

public class Car extends Vehicle {
    private int doors;
    private String fuelType;

    public Car(String brand, String model, int year, int doors, String fuelType) {
        // ❌ super() 호출 전에 다른 코드 실행 - 컴파일 에러!
        System.out.println("자동차 생성 중...");  // ❌ 에러 발생
        super(brand, model, year);  // ❌ super()는 첫 줄에 와야 함
        this.doors = doors;
        this.fuelType = fuelType;
    }

    public Car(String brand, String model, int year) {
        this.doors = 4;  // ❌ super() 또는 this() 호출 전 - 에러 발생!
        super(brand, model, year);  // ❌ 에러 발생
        this.fuelType = "가솔린";
    }
}

// 컴파일 에러:
// Call to 'super()' must be first statement in constructor body
```

**문제점:**
- `super()` 또는 `this()` 호출은 생성자의 첫 줄에 와야 함
- 부모 객체가 먼저 초기화된 후에 자식 객체를 초기화해야 함
- `super()`와 `this()`를 동시에 사용할 수 없음

```java
/**
 * ✅ 올바른 코드
 */
public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;

    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        System.out.println("🚗 차량 생성: " + brand + " " + model + " (" + year + "년식)");
    }

    public void showVehicleInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("제조사: " + brand);
        System.out.println("모델: " + model);
        System.out.println("년식: " + year);
    }
}

public class Car extends Vehicle {
    private int doors;
    private String fuelType;

    // ✅ 모든 매개변수를 받는 생성자
    public Car(String brand, String model, int year, int doors, String fuelType) {
        super(brand, model, year);  // ✅ 첫 줄에 super() 호출
        this.doors = doors;
        this.fuelType = fuelType;
        System.out.println("🚙 자동차 상세 정보 설정 완료");
    }

    // ✅ 일부 매개변수만 받는 생성자 - this()로 다른 생성자 호출
    public Car(String brand, String model, int year) {
        this(brand, model, year, 4, "가솔린");  // ✅ 첫 줄에 this() 호출
        System.out.println("🚙 기본 자동차 생성 완료");
    }

    // ✅ 최소 매개변수 생성자
    public Car(String brand, String model) {
        this(brand, model, 2024);  // ✅ this()로 다른 생성자 호출
        System.out.println("🚙 최신 모델 생성 완료");
    }

    public void showCarInfo() {
        super.showVehicleInfo();
        System.out.println("문 개수: " + doors);
        System.out.println("연료: " + fuelType);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

public class ConstructorOrderTest {
    public static void main(String[] args) {
        System.out.println("=== 생성자 호출 순서 테스트 ===\n");

        System.out.println("1️⃣ 모든 정보를 지정한 자동차 생성:");
        System.out.println("─────────────────────");
        Car car1 = new Car("현대", "아반떼", 2023, 4, "가솔린");
        System.out.println();
        car1.showCarInfo();

        System.out.println("\n\n2️⃣ 기본 정보만 지정한 자동차 생성:");
        System.out.println("─────────────────────");
        Car car2 = new Car("기아", "K5", 2023);
        System.out.println();
        car2.showCarInfo();

        System.out.println("\n\n3️⃣ 최소 정보만 지정한 자동차 생성:");
        System.out.println("─────────────────────");
        Car car3 = new Car("제네시스", "G80");
        System.out.println();
        car3.showCarInfo();

        // 생성자 체인 설명
        System.out.println("\n\n📚 생성자 호출 체인 설명:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("Car(brand, model)");
        System.out.println("  ↓ this() 호출");
        System.out.println("Car(brand, model, year)");
        System.out.println("  ↓ this() 호출");
        System.out.println("Car(brand, model, year, doors, fuelType)");
        System.out.println("  ↓ super() 호출");
        System.out.println("Vehicle(brand, model, year)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}

// 실행 결과:
// === 생성자 호출 순서 테스트 ===
//
// 1️⃣ 모든 정보를 지정한 자동차 생성:
// ─────────────────────
// 🚗 차량 생성: 현대 아반떼 (2023년식)
// 🚙 자동차 상세 정보 설정 완료
//
// ━━━━━━━━━━━━━━━━━━━━
// 제조사: 현대
// 모델: 아반떼
// 년식: 2023
// 문 개수: 4
// 연료: 가솔린
// ━━━━━━━━━━━━━━━━━━━━
//
//
// 2️⃣ 기본 정보만 지정한 자동차 생성:
// ─────────────────────
// 🚗 차량 생성: 기아 K5 (2023년식)
// 🚙 자동차 상세 정보 설정 완료
// 🚙 기본 자동차 생성 완료
//
// ━━━━━━━━━━━━━━━━━━━━
// 제조사: 기아
// 모델: K5
// 년식: 2023
// 문 개수: 4
// 연료: 가솔린
// ━━━━━━━━━━━━━━━━━━━━
//
//
// 3️⃣ 최소 정보만 지정한 자동차 생성:
// ─────────────────────
// 🚗 차량 생성: 제네시스 G80 (2024년식)
// 🚙 자동차 상세 정보 설정 완료
// 🚙 기본 자동차 생성 완료
// 🚙 최신 모델 생성 완료
//
// ━━━━━━━━━━━━━━━━━━━━
// 제조사: 제네시스
// 모델: G80
// 년식: 2024
// 문 개수: 4
// 연료: 가솔린
// ━━━━━━━━━━━━━━━━━━━━
//
//
// 📚 생성자 호출 체인 설명:
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// Car(brand, model)
//   ↓ this() 호출
// Car(brand, model, year)
//   ↓ this() 호출
// Car(brand, model, year, doors, fuelType)
//   ↓ super() 호출
// Vehicle(brand, model, year)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**생성자 호출 규칙:**

1. **super()나 this()는 생성자의 첫 줄에만 올 수 있음**
   ```java
   public Car(String brand) {
       super(brand, "Unknown", 2024);  // ✅ 첫 줄
       this.doors = 4;  // ✅ 이후 코드
   }
   ```

2. **super()와 this()를 동시에 사용할 수 없음**
   ```java
   public Car(String brand) {
       super(brand, "Unknown", 2024);  // ❌
       this(brand, "Unknown");         // ❌ 에러!
   }
   ```

3. **명시적으로 호출하지 않으면 super() 자동 호출**
   ```java
   public Car(String brand) {
       // super(); 가 자동으로 추가됨
       this.doors = 4;
   }
   ```

4. **this()를 사용하면 super()를 수동 호출할 필요 없음**
   ```java
   public Car(String brand) {
       this(brand, "Unknown", 2024);  // ✅ 이 생성자가 super() 호출
   }
   ```

**교훈:**
1. `super()` 또는 `this()`는 반드시 생성자의 첫 줄에 작성
2. 둘 중 하나만 사용 가능 (동시 사용 불가)
3. `this()`를 사용해 생성자 체이닝으로 코드 중복 제거
4. 부모 → 자식 순서로 초기화가 진행됨을 이해해야 함

---

### 시나리오 4: 상속 vs 포함(Composition) 선택 실수

```java
/**
 * ❌ 잘못된 설계 - 상속을 남용한 경우
 */

// ❌ "자동차는 엔진이다"? → IS-A 관계가 아님!
public class Engine {
    private int horsepower;
    private String type;

    public Engine(int horsepower, String type) {
        this.horsepower = horsepower;
        this.type = type;
    }

    public void start() {
        System.out.println("엔진 시동: " + type);
    }
}

// ❌ 잘못된 상속!
public class Car extends Engine {
    private String brand;
    private String model;

    public Car(String brand, String model, int horsepower, String type) {
        super(horsepower, type);  // ❌ 의미적으로 맞지 않음
        this.brand = brand;
        this.model = model;
    }
}

// ❌ 문제점:
// 1. "자동차는 엔진이다"라는 관계가 성립하지 않음
// 2. 자동차는 엔진을 "가지고 있는" 것이지, 엔진 "그 자체"가 아님
// 3. 나중에 다른 엔진으로 교체가 불가능 (상속은 고정적)
```

**IS-A vs HAS-A 관계:**

| 관계 | 설명 | 구현 방법 | 예시 |
|------|------|----------|------|
| **IS-A** | "~은 ~이다" | 상속 (extends) | 자동차는 차량이다<br>고양이는 동물이다 |
| **HAS-A** | "~은 ~을 가진다" | 포함 (Composition) | 자동차는 엔진을 가진다<br>사람은 심장을 가진다 |

```java
/**
 * ✅ 올바른 설계 - 포함(Composition) 사용
 */
public class Engine {
    private int horsepower;
    private String type;
    private boolean isRunning;

    public Engine(int horsepower, String type) {
        this.horsepower = horsepower;
        this.type = type;
        this.isRunning = false;
    }

    public void start() {
        isRunning = true;
        System.out.println("🔧 엔진 시동: " + type + " (" + horsepower + "마력)");
    }

    public void stop() {
        isRunning = false;
        System.out.println("🔧 엔진 정지");
    }

    public int getHorsepower() { return horsepower; }
    public String getType() { return type; }
    public boolean isRunning() { return isRunning; }
}

public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;

    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    public void showBasicInfo() {
        System.out.println("제조사: " + brand);
        System.out.println("모델: " + model);
        System.out.println("년식: " + year);
    }
}

// ✅ 상속 (IS-A): 자동차는 차량이다
// ✅ 포함 (HAS-A): 자동차는 엔진을 가진다
public class Car extends Vehicle {
    private Engine engine;  // ✅ 포함 관계
    private int doors;

    public Car(String brand, String model, int year, int doors, Engine engine) {
        super(brand, model, year);  // ✅ IS-A 관계
        this.doors = doors;
        this.engine = engine;  // ✅ HAS-A 관계
    }

    public void startCar() {
        System.out.println("\n🚗 " + brand + " " + model + " 시동 중...");
        engine.start();  // ✅ 엔진 객체의 메서드 호출
        System.out.println("✅ 출발 준비 완료!");
    }

    public void stopCar() {
        System.out.println("\n🛑 " + brand + " " + model + " 정지 중...");
        engine.stop();
        System.out.println("✅ 안전하게 정지했습니다.");
    }

    // ✅ 엔진 교체 가능 (포함 관계의 장점)
    public void replaceEngine(Engine newEngine) {
        System.out.println("\n🔧 엔진 교체 작업 중...");
        System.out.println("  기존: " + engine.getType() + " " + engine.getHorsepower() + "마력");
        this.engine = newEngine;
        System.out.println("  신규: " + newEngine.getType() + " " + newEngine.getHorsepower() + "마력");
        System.out.println("✅ 엔진 교체 완료!");
    }

    public void showCarInfo() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🚗 자동차 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        showBasicInfo();
        System.out.println("문 개수: " + doors);
        System.out.println("엔진: " + engine.getType() + " " + engine.getHorsepower() + "마력");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

public class InheritanceVsCompositionTest {
    public static void main(String[] args) {
        System.out.println("=== 상속 vs 포함 비교 ===\n");

        // 엔진 생성
        Engine normalEngine = new Engine(150, "가솔린 엔진");
        Engine turboenEngine = new Engine(250, "터보 엔진");

        // 자동차 생성 (상속 + 포함)
        Car car = new Car("현대", "아반떼", 2024, 4, normalEngine);

        car.showCarInfo();
        car.startCar();
        car.stopCar();

        // ✅ 포함 관계의 장점: 엔진 교체 가능!
        car.replaceEngine(turboenEngine);
        car.showCarInfo();
        car.startCar();

        System.out.println("\n\n📚 설계 원칙:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ IS-A 관계 (상속):");
        System.out.println("   - Car extends Vehicle");
        System.out.println("   - \"자동차는 차량이다\"");
        System.out.println("   - 차량의 모든 특성과 행동을 물려받음");
        System.out.println();
        System.out.println("✅ HAS-A 관계 (포함):");
        System.out.println("   - Car has Engine");
        System.out.println("   - \"자동차는 엔진을 가진다\"");
        System.out.println("   - 엔진을 교체할 수 있는 유연성");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}

// 실행 결과:
// === 상속 vs 포함 비교 ===
//
//
// ━━━━━━━━━━━━━━━━━━━━
// 🚗 자동차 정보
// ━━━━━━━━━━━━━━━━━━━━
// 제조사: 현대
// 모델: 아반떼
// 년식: 2024
// 문 개수: 4
// 엔진: 가솔린 엔진 150마력
// ━━━━━━━━━━━━━━━━━━━━
//
// 🚗 현대 아반떼 시동 중...
// 🔧 엔진 시동: 가솔린 엔진 (150마력)
// ✅ 출발 준비 완료!
//
// 🛑 현대 아반떼 정지 중...
// 🔧 엔진 정지
// ✅ 안전하게 정지했습니다.
//
// 🔧 엔진 교체 작업 중...
//   기존: 가솔린 엔진 150마력
//   신규: 터보 엔진 250마력
// ✅ 엔진 교체 완료!
//
// ━━━━━━━━━━━━━━━━━━━━
// 🚗 자동차 정보
// ━━━━━━━━━━━━━━━━━━━━
// 제조사: 현대
// 모델: 아반떼
// 년식: 2024
// 문 개수: 4
// 엔진: 터보 엔진 250마력
// ━━━━━━━━━━━━━━━━━━━━
//
// 🚗 현대 아반떼 시동 중...
// 🔧 엔진 시동: 터보 엔진 (250마력)
// ✅ 출발 준비 완료!
//
//
// 📚 설계 원칙:
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✅ IS-A 관계 (상속):
//    - Car extends Vehicle
//    - "자동차는 차량이다"
//    - 차량의 모든 특성과 행동을 물려받음
//
// ✅ HAS-A 관계 (포함):
//    - Car has Engine
//    - "자동차는 엔진을 가진다"
//    - 엔진을 교체할 수 있는 유연성
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**상속 vs 포함 선택 가이드:**

```java
// ✅ 상속을 사용해야 하는 경우
class Animal { }
class Dog extends Animal { }  // ✅ "개는 동물이다" - IS-A 관계

class Shape { }
class Circle extends Shape { }  // ✅ "원은 도형이다" - IS-A 관계

class Employee { }
class Manager extends Employee { }  // ✅ "매니저는 직원이다" - IS-A 관계

// ✅ 포함을 사용해야 하는 경우
class Computer {
    private CPU cpu;  // ✅ "컴퓨터는 CPU를 가진다" - HAS-A 관계
    private RAM ram;  // ✅ "컴퓨터는 RAM을 가진다" - HAS-A 관계
}

class Person {
    private Heart heart;  // ✅ "사람은 심장을 가진다" - HAS-A 관계
    private Brain brain;  // ✅ "사람은 뇌를 가진다" - HAS-A 관계
}

class House {
    private Kitchen kitchen;  // ✅ "집은 부엌을 가진다" - HAS-A 관계
    private Bedroom bedroom;  // ✅ "집은 침실을 가진다" - HAS-A 관계
}
```

**포함(Composition)의 장점:**
1. **유연성**: 런타임에 구성 요소를 교체할 수 있음
2. **낮은 결합도**: 클래스 간 의존성이 낮아짐
3. **다중 포함 가능**: 여러 객체를 포함할 수 있음 (Java는 단일 상속만 지원)
4. **테스트 용이성**: Mock 객체로 쉽게 대체 가능

**교훈:**
1. "~은 ~이다" 관계면 **상속 (extends)**
2. "~은 ~을 가진다" 관계면 **포함 (Composition)**
3. 확신이 서지 않으면 **포함을 우선 고려**
4. 상속은 강한 결합을 만들므로 신중하게 사용

---

## 📚 다음 단계

Part 3에서는 다음 내용을 다룹니다:
- **실전 프로젝트**: 상속을 활용한 완전한 시스템 구현
- **FAQ**: 상속 관련 자주 묻는 질문 7개
- **면접 질문**: 주니어 7문제 + 중급 5문제

---

**작성일**: 2025-01-10
**챕터**: 15. 상속 (Inheritance) - Part 2
