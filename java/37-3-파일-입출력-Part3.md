# 37ì¥ íŒŒì¼ ì…ì¶œë ¥ - Part 3: ë©´ì ‘ ì§ˆë¬¸

> **í•™ìŠµ ëª©í‘œ**: íŒŒì¼ ì…ì¶œë ¥ ë©´ì ‘ ì§ˆë¬¸ì— ì™„ë²½í•˜ê²Œ ëŒ€ë¹„í•œë‹¤

**â±ï¸ ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 2-3ì‹œê°„
**ë‚œì´ë„**: â­â­â­â­â˜† (4/5)

---

## ğŸ“š ëª©ì°¨
- [ì£¼ë‹ˆì–´/ì‹ ì… ê°œë°œììš© ë©´ì ‘ ì§ˆë¬¸](#ì£¼ë‹ˆì–´ì‹ ì…-ê°œë°œììš©-ë©´ì ‘-ì§ˆë¬¸)
- [ì¤‘ê¸‰ ê°œë°œììš© ë©´ì ‘ ì§ˆë¬¸](#ì¤‘ê¸‰-ê°œë°œììš©-ë©´ì ‘-ì§ˆë¬¸)
- [í•µì‹¬ ì •ë¦¬](#í•µì‹¬-ì •ë¦¬)

---

## ğŸ’¼ ì£¼ë‹ˆì–´/ì‹ ì… ê°œë°œììš© ë©´ì ‘ ì§ˆë¬¸

### ğŸ“˜ 1. InputStreamê³¼ Readerì˜ ì°¨ì´ëŠ” ë¬´ì—‡ì¸ê°€ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- InputStream/OutputStream: ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ (byte ë‹¨ìœ„)
- Reader/Writer: ë¬¸ì ìŠ¤íŠ¸ë¦¼ (char ë‹¨ìœ„)
- ìš©ë„ì— ë”°ë¼ ì„ íƒ: í…ìŠ¤íŠ¸ vs ë°”ì´ë„ˆë¦¬

**ì˜ˆì‹œ ë‹µë³€**
> "InputStreamê³¼ OutputStreamì€ ë°”ì´íŠ¸ ê¸°ë°˜ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ, ì´ë¯¸ì§€ë‚˜ ë™ì˜ìƒ ê°™ì€ ë°”ì´ë„ˆë¦¬ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ë°˜ë©´ Readerì™€ WriterëŠ” ë¬¸ì ê¸°ë°˜ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ, í…ìŠ¤íŠ¸ íŒŒì¼ì„ ì½ê³  ì“¸ ë•Œ ì‚¬ìš©í•˜ë©° ì¸ì½”ë”© ì²˜ë¦¬ë¥¼ ìë™ìœ¼ë¡œ í•´ì¤ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë¡œê·¸ íŒŒì¼ì„ ì½ì„ ë•ŒëŠ” FileReaderë¥¼, ì´ë¯¸ì§€ë¥¼ ë³µì‚¬í•  ë•ŒëŠ” FileInputStreamì„ ì‚¬ìš©í•©ë‹ˆë‹¤."

**ì½”ë“œ ì˜ˆì‹œ**
```java
// InputStream: ë°”ì´ë„ˆë¦¬ íŒŒì¼ (ì´ë¯¸ì§€)
try (FileInputStream fis = new FileInputStream("image.jpg");
     FileOutputStream fos = new FileOutputStream("copy.jpg")) {
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = fis.read(buffer)) != -1) {
        fos.write(buffer, 0, bytesRead);
    }
}

// Reader: í…ìŠ¤íŠ¸ íŒŒì¼
try (FileReader fr = new FileReader("text.txt");
     BufferedReader br = new BufferedReader(fr)) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
}
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: í…ìŠ¤íŠ¸ íŒŒì¼ì„ InputStreamìœ¼ë¡œ ì½ìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?
- A: ê°€ëŠ¥í•˜ì§€ë§Œ ì¸ì½”ë”© ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•œê¸€ ê°™ì€ ë©€í‹°ë°”ì´íŠ¸ ë¬¸ìê°€ ê¹¨ì§ˆ ìˆ˜ ìˆì–´ Reader ì‚¬ìš©ì„ ê¶Œì¥í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ë¡œê·¸ íŒŒì¼ ë¶„ì„: BufferedReader ì‚¬ìš©
- íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ: InputStream/OutputStream ì‚¬ìš©
- CSV íŒŒì¼ ì²˜ë¦¬: BufferedReaderë¡œ í•œ ì¤„ì”© ì½ê¸°

---

### ğŸ“˜ 2. BufferedReaderë¥¼ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- ë‚´ë¶€ ë²„í¼ ì‚¬ìš©ìœ¼ë¡œ ì„±ëŠ¥ í–¥ìƒ (100ë°° ë¹ ë¦„)
- ì‹œìŠ¤í…œ ì½œ íšŸìˆ˜ ê°ì†Œ
- readLine() í¸ì˜ ê¸°ëŠ¥ ì œê³µ

**ì˜ˆì‹œ ë‹µë³€**
> "BufferedReaderëŠ” ë‚´ë¶€ì— ë²„í¼(ê¸°ë³¸ 8KB)ë¥¼ ê°€ì§€ê³  ìˆì–´ì„œ ë””ìŠ¤í¬ I/O íšŸìˆ˜ë¥¼ ëŒ€í­ ì¤„ì—¬ì¤ë‹ˆë‹¤. FileReaderë§Œ ì‚¬ìš©í•˜ë©´ í•œ ê¸€ì ì½ì„ ë•Œë§ˆë‹¤ ë””ìŠ¤í¬ì— ì ‘ê·¼í•˜ì§€ë§Œ, BufferedReaderëŠ” í•œ ë²ˆì— 8KBë¥¼ ì½ì–´ì„œ ë²„í¼ì— ì €ì¥í•œ í›„ í•„ìš”í•  ë•Œë§ˆë‹¤ ë²„í¼ì—ì„œ ê°€ì ¸ì˜µë‹ˆë‹¤. ê·¸ë˜ì„œ ì„±ëŠ¥ì´ ì•½ 100ë°° ë¹ ë¦…ë‹ˆë‹¤. ë˜í•œ readLine() ë©”ì„œë“œë¡œ í•œ ì¤„ì”© ì½ì„ ìˆ˜ ìˆì–´ í¸ë¦¬í•©ë‹ˆë‹¤."

**ì„±ëŠ¥ ë¹„êµ ì½”ë“œ**
```java
// ì„±ëŠ¥ ì¸¡ì •
Path file = Paths.get("large.txt");
Files.writeString(file, "A".repeat(1_000_000));  // 1MB íŒŒì¼

// âŒ FileReader (ëŠë¦¼)
long start1 = System.nanoTime();
try (FileReader fr = new FileReader(file.toFile())) {
    while (fr.read() != -1) {}
}
long time1 = System.nanoTime() - start1;
System.out.println("FileReader: " + time1 / 1_000_000 + "ms");
// ì•½ 3000ms

// âœ… BufferedReader (ë¹ ë¦„)
long start2 = System.nanoTime();
try (BufferedReader br = Files.newBufferedReader(file)) {
    while (br.readLine() != null) {}
}
long time2 = System.nanoTime() - start2;
System.out.println("BufferedReader: " + time2 / 1_000_000 + "ms");
// ì•½ 30ms (100ë°° ë¹ ë¦„!)
```

**ì„±ëŠ¥ ì°¨ì´ í‘œ**
| ë°©ë²• | 1MB íŒŒì¼ | ë””ìŠ¤í¬ I/O íšŸìˆ˜ | ì²˜ë¦¬ ì‹œê°„ |
|------|----------|----------------|-----------|
| FileReader | read() 1,000,000íšŒ | 1,000,000ë²ˆ | 3000ms |
| BufferedReader | readLine() 10,000íšŒ | ì•½ 128ë²ˆ | 30ms |

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: ë²„í¼ í¬ê¸°ë¥¼ ëŠ˜ë¦¬ë©´ ë” ë¹ ë¥¼ê¹Œìš”?
- A: ì¼ì • í¬ê¸°(ì•½ 64KB) ì´ìƒì—ì„œëŠ” íš¨ê³¼ê°€ ë¯¸ë¯¸í•©ë‹ˆë‹¤. ì˜¤íˆë ¤ ë©”ëª¨ë¦¬ ë‚­ë¹„ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ëŒ€ìš©ëŸ‰ ë¡œê·¸ íŒŒì¼ ë¶„ì„ ì‹œ í•„ìˆ˜
- CSV íŒŒì¼ íŒŒì‹±
- ì„¤ì • íŒŒì¼ ì½ê¸°

---

### ğŸ“˜ 3. try-with-resourcesê°€ í•„ìš”í•œ ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- ìë™ìœ¼ë¡œ close() í˜¸ì¶œ
- ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€
- ì˜ˆì™¸ ë°œìƒ ì‹œì—ë„ close() ë³´ì¥

**ì˜ˆì‹œ ë‹µë³€**
> "try-with-resourcesëŠ” Java 7ì—ì„œ ë„ì…ëœ ê¸°ëŠ¥ìœ¼ë¡œ, íŒŒì¼ì´ë‚˜ ë„¤íŠ¸ì›Œí¬ ê°™ì€ ë¦¬ì†ŒìŠ¤ë¥¼ ìë™ìœ¼ë¡œ ë‹«ì•„ì¤ë‹ˆë‹¤. ê³¼ê±°ì—ëŠ” finally ë¸”ë¡ì—ì„œ ìˆ˜ë™ìœ¼ë¡œ close()ë¥¼ í˜¸ì¶œí•´ì•¼ í–ˆëŠ”ë°, ì´ ê³¼ì •ì—ì„œ ì‹¤ìˆ˜ë¡œ ëˆ„ë½í•˜ê±°ë‚˜ ì˜ˆì™¸ ì²˜ë¦¬ê°€ ë³µì¡í•´ì§€ëŠ” ë¬¸ì œê°€ ìˆì—ˆìŠµë‹ˆë‹¤. try-with-resourcesë¥¼ ì‚¬ìš©í•˜ë©´ try ë¸”ë¡ì´ ëë‚  ë•Œ ìë™ìœ¼ë¡œ close()ê°€ í˜¸ì¶œë˜ë¯€ë¡œ íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜ë‚˜ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

**ì½”ë“œ ë¹„êµ**
```java
// âŒ ìˆ˜ë™ close (ìœ„í—˜í•˜ê³  ë³µì¡!)
FileReader fr = null;
try {
    fr = new FileReader("file.txt");
    // ... ì²˜ë¦¬
    fr.close();  // ì˜ˆì™¸ ë°œìƒ ì‹œ ë¯¸í˜¸ì¶œ!
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fr != null) {
        try {
            fr.close();
        } catch (IOException e) {
            // ì¤‘ì²©ëœ ì˜ˆì™¸ ì²˜ë¦¬...
        }
    }
}

// âœ… try-with-resources (ì•ˆì „í•˜ê³  ê°„ê²°!)
try (FileReader fr = new FileReader("file.txt")) {
    // ... ì²˜ë¦¬
    // ìë™ìœ¼ë¡œ close() í˜¸ì¶œ!
} catch (IOException e) {
    e.printStackTrace();
}

// âœ… ì—¬ëŸ¬ ë¦¬ì†ŒìŠ¤ë„ ê°€ëŠ¥
try (FileReader fr = new FileReader("in.txt");
     BufferedReader br = new BufferedReader(fr);
     FileWriter fw = new FileWriter("out.txt")) {
    // ëª¨ë‘ ìë™ close!
}
```

**ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë¬¸ì œ**
```
ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°œìƒ ì‹œ:
1. íŒŒì¼ í•¸ë“¤ ê³ ê°ˆ
   - OSëŠ” í”„ë¡œì„¸ìŠ¤ë‹¹ ì—´ ìˆ˜ ìˆëŠ” íŒŒì¼ ìˆ˜ ì œí•œ (ë³´í†µ 1024ê°œ)
   - ì œí•œ ì´ˆê³¼ ì‹œ: "Too many open files" ì—ëŸ¬

2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
   - ë²„í¼ê°€ í•´ì œë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€
   - ê²°êµ­ OutOfMemoryError ë°œìƒ

3. íŒŒì¼ ì ê¹€
   - Windowsì—ì„œ íŒŒì¼ì´ ì ê²¨ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ ì ‘ê·¼ ë¶ˆê°€
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: close()ê°€ ë‘ ë²ˆ í˜¸ì¶œë˜ë©´ ë¬¸ì œê°€ ë˜ë‚˜ìš”?
- A: ëŒ€ë¶€ë¶„ì˜ êµ¬í˜„ì—ì„œëŠ” ì•ˆì „í•˜ì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ í•œ ë²ˆë§Œ í˜¸ì¶œë˜ë„ë¡ ì„¤ê³„í•´ì•¼ í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ëª¨ë“  íŒŒì¼ I/O ì‘ì—…
- ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° (Connection, Statement)
- ë„¤íŠ¸ì›Œí¬ ì†Œì¼“

---

### ğŸ“˜ 4. Java 7ì˜ NIO.2ê°€ ë¬´ì—‡ì´ê³ , ì™œ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- Java 7ì—ì„œ ë„ì…ëœ í˜„ëŒ€ì  íŒŒì¼ I/O API
- Path, Files í´ë˜ìŠ¤ ì œê³µ
- ì„±ëŠ¥ í–¥ìƒ ë° í¸ì˜ì„± ì¦ëŒ€

**ì˜ˆì‹œ ë‹µë³€**
> "NIO.2ëŠ” Java 7ì—ì„œ ë„ì…ëœ ìƒˆë¡œìš´ íŒŒì¼ I/O APIë¡œ, java.nio.file íŒ¨í‚¤ì§€ì— í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê¸°ì¡´ java.io.Fileì˜ ë¬¸ì œì ì¸ ëŠë¦° ì„±ëŠ¥, ë¶ˆëª…í™•í•œ ì—ëŸ¬ ì²˜ë¦¬, ë©”íƒ€ë°ì´í„° ì ‘ê·¼ ì œí•œ ë“±ì„ í•´ê²°í–ˆìŠµë‹ˆë‹¤. Pathë¡œ íŒŒì¼ ê²½ë¡œë¥¼ í‘œí˜„í•˜ê³ , Files í´ë˜ìŠ¤ë¡œ íŒŒì¼ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ”ë°, ì½”ë“œê°€ í›¨ì”¬ ê°„ê²°í•˜ê³  ì„±ëŠ¥ë„ 10ë°° ì´ìƒ ë¹ ë¦…ë‹ˆë‹¤. ë˜í•œ Files.walk()ë¡œ ë””ë ‰í† ë¦¬ ìˆœíšŒ, WatchServiceë¡œ íŒŒì¼ ë³€ê²½ ê°ì§€ ë“± ê°•ë ¥í•œ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤."

**ì½”ë“œ ë¹„êµ**
```java
// âŒ êµ¬ì‹ (java.io.File) - ë³µì¡í•˜ê³  ëŠë¦¼
File file = new File("data.txt");
if (!file.exists()) {
    file.createNewFile();
}

FileReader fr = new FileReader(file);
BufferedReader br = new BufferedReader(fr);
List<String> lines = new ArrayList<>();
String line;
while ((line = br.readLine()) != null) {
    lines.add(line);
}
br.close();
fr.close();

// âœ… í˜„ëŒ€ì  (java.nio.file) - ê°„ê²°í•˜ê³  ë¹ ë¦„
Path path = Paths.get("data.txt");
if (!Files.exists(path)) {
    Files.createFile(path);
}
List<String> lines = Files.readAllLines(path);
```

**NIO.2ì˜ ì£¼ìš” ê¸°ëŠ¥**
```java
// 1. íŒŒì¼ ë³µì‚¬ (í•œ ì¤„!)
Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);

// 2. ë””ë ‰í† ë¦¬ ì¬ê·€ íƒìƒ‰
try (Stream<Path> paths = Files.walk(Paths.get("logs"))) {
    paths.filter(p -> p.toString().endsWith(".log"))
         .forEach(System.out::println);
}

// 3. íŒŒì¼ ì“°ê¸° (í•œ ì¤„!)
Files.writeString(Paths.get("output.txt"), "Hello, NIO!");

// 4. íŒŒì¼ ì†ì„± ì½ê¸°
BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
System.out.println("í¬ê¸°: " + attrs.size());
System.out.println("ìƒì„±ì¼: " + attrs.creationTime());
```

**ì„±ëŠ¥ ë¹„êµ**
| ì‘ì—… | java.io.File | java.nio.file.Files | ì„±ëŠ¥ í–¥ìƒ |
|------|--------------|---------------------|-----------|
| íŒŒì¼ ë³µì‚¬ | ì§ì ‘ êµ¬í˜„ (50ì¤„) | Files.copy() (1ì¤„) | 15ë°° ë¹ ë¦„ |
| ë””ë ‰í† ë¦¬ ìˆœíšŒ | ì¬ê·€ êµ¬í˜„ | Files.walk() | 10ë°° ë¹ ë¦„ |
| íŒŒì¼ ì½ê¸° | BufferedReader | Files.readAllLines() | 5ë°° ë¹ ë¦„ |

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: ì–¸ì œ java.io.Fileì„ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜ìš”?
- A: ë ˆê±°ì‹œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€ì˜ í˜¸í™˜ì„± ë•Œë¬¸ì—ë§Œ ì‚¬ìš©í•˜ê³ , ì‹ ê·œ ì½”ë“œëŠ” ë¬´ì¡°ê±´ Pathì™€ Filesë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ë¡œê·¸ íŒŒì¼ ë¶„ì„ ì‹œìŠ¤í…œ
- ë°±ì—… ì‹œìŠ¤í…œ (íŒŒì¼ ë³µì‚¬)
- íŒŒì¼ ì—…ë¡œë“œ/ë‹¤ìš´ë¡œë“œ ì„œë¹„ìŠ¤

---

### ğŸ“˜ 5. íŒŒì¼ ì¸ì½”ë”© ë¬¸ì œë¥¼ ì–´ë–»ê²Œ í•´ê²°í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- Windows ê¸°ë³¸: MS949, Linux ê¸°ë³¸: UTF-8
- ëª…ì‹œì ìœ¼ë¡œ UTF-8 ì§€ì •
- StandardCharsets ì‚¬ìš©

**ì˜ˆì‹œ ë‹µë³€**
> "íŒŒì¼ ì¸ì½”ë”© ë¬¸ì œëŠ” í”Œë«í¼ë§ˆë‹¤ ê¸°ë³¸ ì¸ì½”ë”©ì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ë°œìƒí•©ë‹ˆë‹¤. WindowsëŠ” MS949(EUC-KR í™•ì¥)ë¥¼, Linuxì™€ Macì€ UTF-8ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•´ì„œ í•œê¸€ì´ ê¹¨ì§€ëŠ” í˜„ìƒì´ ë°œìƒí•©ë‹ˆë‹¤. í•´ê²° ë°©ë²•ì€ Files.writeString()ê³¼ Files.readString() ì‚¬ìš© ì‹œ StandardCharsets.UTF_8ì„ ëª…ì‹œí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ëª¨ë“  í”Œë«í¼ì—ì„œ ë™ì¼í•˜ê²Œ ë™ì‘í•©ë‹ˆë‹¤."

**ë¬¸ì œ ìƒí™©ê³¼ í•´ê²°**
```java
// âŒ ì¸ì½”ë”© ë¯¸ì§€ì • (í”Œë«í¼ ì˜ì¡´)
FileWriter writer = new FileWriter("korean.txt");
writer.write("í•œê¸€ í…ŒìŠ¤íŠ¸");
writer.close();
// Windows: MS949ë¡œ ì €ì¥
// Linux: UTF-8ë¡œ ì €ì¥
// â†’ Linuxì—ì„œ ë§Œë“  íŒŒì¼ì„ Windowsì—ì„œ ì½ìœ¼ë©´ ê¹¨ì§!

// âœ… UTF-8 ëª…ì‹œ (ëª¨ë“  í”Œë«í¼ ë™ì¼)
Files.writeString(
    Paths.get("korean.txt"),
    "í•œê¸€ í…ŒìŠ¤íŠ¸",
    StandardCharsets.UTF_8
);

// ì½ê¸°ë„ ë™ì¼
String content = Files.readString(
    Paths.get("korean.txt"),
    StandardCharsets.UTF_8
);
System.out.println(content);  // í•œê¸€ ì •ìƒ ì¶œë ¥

// âœ… BufferedReaderì—ë„ ì¸ì½”ë”© ì§€ì •
try (BufferedReader br = Files.newBufferedReader(
        Paths.get("korean.txt"),
        StandardCharsets.UTF_8)) {
    String line = br.readLine();
    System.out.println(line);
}
```

**ì¸ì½”ë”©ë³„ í•œê¸€ ì²˜ë¦¬**
```
"í•œê¸€" â†’ ë°”ì´íŠ¸ ë³€í™˜:

UTF-8:
- í•œ: 0xED 0x95 0x9C (3ë°”ì´íŠ¸)
- ê¸€: 0xEA 0xB8 0x80 (3ë°”ì´íŠ¸)
- ì´ 6ë°”ì´íŠ¸

MS949 (EUC-KR):
- í•œ: 0xC7 0xD1 (2ë°”ì´íŠ¸)
- ê¸€: 0xB1 0xDB (2ë°”ì´íŠ¸)
- ì´ 4ë°”ì´íŠ¸

â†’ ë°”ì´íŠ¸ ìˆ˜ê°€ ë‹¬ë¼ì„œ ì˜ëª» ì½ìœ¼ë©´ ê¹¨ì§!
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: UTF-8ê³¼ UTF-16ì˜ ì°¨ì´ëŠ”?
- A: UTF-8ì€ ê°€ë³€ ê¸¸ì´ (1-4ë°”ì´íŠ¸), UTF-16ì€ ê³ ì •/ê°€ë³€ (2 ë˜ëŠ” 4ë°”ì´íŠ¸). ì˜ì–´ê°€ ë§ìœ¼ë©´ UTF-8ì´ íš¨ìœ¨ì ì…ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- CSV íŒŒì¼ ì²˜ë¦¬ (ì—‘ì…€ í˜¸í™˜ì„±)
- ë¡œê·¸ íŒŒì¼ (ì„œë²„ ê°„ ë¡œê·¸ ì „ì†¡)
- ì„¤ì • íŒŒì¼ (properties, yaml)

---

### ğŸ“˜ 6. ëŒ€ìš©ëŸ‰ íŒŒì¼ì„ ì²˜ë¦¬í•  ë•Œ ì£¼ì˜í•  ì ì€ ë¬´ì—‡ì¸ê°€ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- readAllLines()ëŠ” ì „ì²´ë¥¼ ë©”ëª¨ë¦¬ì— ë¡œë“œ (OutOfMemoryError)
- Files.lines()ë¡œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
- 100MB ì´ìƒì€ ë¬´ì¡°ê±´ ìŠ¤íŠ¸ë¦¼

**ì˜ˆì‹œ ë‹µë³€**
> "ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ì‹œ ê°€ì¥ ì£¼ì˜í•  ì ì€ ë©”ëª¨ë¦¬ ê´€ë¦¬ì…ë‹ˆë‹¤. Files.readAllLines()ëŠ” íŒŒì¼ ì „ì²´ë¥¼ ë©”ëª¨ë¦¬ì— ë¡œë“œí•˜ê¸° ë•Œë¬¸ì— 1GB íŒŒì¼ì´ë©´ 1GB ë©”ëª¨ë¦¬ê°€ í•„ìš”í•´ì„œ OutOfMemoryErrorê°€ ë°œìƒí•©ë‹ˆë‹¤. ëŒ€ì‹  Files.lines()ë¥¼ ì‚¬ìš©í•˜ë©´ ìŠ¤íŠ¸ë¦¼ ë°©ì‹ìœ¼ë¡œ í•œ ì¤„ì”© ì½ì–´ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ íŒŒì¼ í¬ê¸°ì™€ ë¬´ê´€í•˜ê²Œ ì•½ 50MB ë©”ëª¨ë¦¬ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” 100MB ì´ìƒ íŒŒì¼ì€ ë¬´ì¡°ê±´ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ë¥¼ í•´ì•¼ í•©ë‹ˆë‹¤."

**ì½”ë“œ ë¹„êµ**
```java
// âŒ ì˜ëª»ëœ ë°©ë²• - OutOfMemoryError!
Path bigFile = Paths.get("access.log");  // 1GB
List<String> lines = Files.readAllLines(bigFile);
// 1GB íŒŒì¼ â†’ 1GB ë©”ëª¨ë¦¬ ì‚¬ìš© â†’ OutOfMemoryError!

for (String line : lines) {
    if (line.contains("ERROR")) {
        System.out.println(line);
    }
}

// âœ… ì˜¬ë°”ë¥¸ ë°©ë²• - ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
try (Stream<String> lines = Files.lines(bigFile)) {
    lines.filter(line -> line.contains("ERROR"))
         .forEach(System.out::println);
    // 1GB íŒŒì¼ì´ì–´ë„ ë©”ëª¨ë¦¬ 50MBë§Œ ì‚¬ìš©!
}

// âœ… ëŒ€ì•ˆ: BufferedReader ì‚¬ìš©
try (BufferedReader reader = Files.newBufferedReader(bigFile)) {
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.contains("ERROR")) {
            System.out.println(line);
        }
    }
}
```

**ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë¹„êµ**
| íŒŒì¼ í¬ê¸° | readAllLines() | Files.lines() | ë©”ëª¨ë¦¬ ì ˆê° |
|-----------|----------------|---------------|-------------|
| 100MB | 100MB | 50MB | 50% |
| 1GB | OutOfMemoryError | 50MB | 95%+ |
| 10GB | OutOfMemoryError | 50MB | 99%+ |

**ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ì˜ˆì‹œ**
```java
// ì‹¤ë¬´ ì˜ˆì‹œ: 10GB ë¡œê·¸ íŒŒì¼ì—ì„œ ì—ëŸ¬ë§Œ ì¶”ì¶œ
try (Stream<String> lines = Files.lines(Paths.get("huge.log"));
     BufferedWriter writer = Files.newBufferedWriter(Paths.get("errors.log"))) {

    lines.filter(line -> line.contains("ERROR"))
         .forEach(line -> {
             try {
                 writer.write(line);
                 writer.newLine();
             } catch (IOException e) {
                 e.printStackTrace();
             }
         });
}
// 10GB íŒŒì¼ë„ ë©”ëª¨ë¦¬ 100MBë¡œ ì²˜ë¦¬!
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: parallelStream()ì„ ì‚¬ìš©í•˜ë©´ ë” ë¹ ë¥¼ê¹Œìš”?
- A: CPU ì§‘ì•½ì  ì‘ì—…ì—ëŠ” ë„ì›€ì´ ë˜ì§€ë§Œ, íŒŒì¼ I/OëŠ” ë””ìŠ¤í¬ ì†ë„ê°€ ë³‘ëª©ì´ë¼ íš¨ê³¼ê°€ ì œí•œì ì…ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ëŒ€ìš©ëŸ‰ ë¡œê·¸ ë¶„ì„ (ìˆ˜ GB~TB)
- CSV ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬
- ì›¹ í¬ë¡¤ë§ ê²°ê³¼ íŒŒì¼ íŒŒì‹±

---

### ğŸ“˜ 7. close()ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ì–´ë–¤ ë¬¸ì œê°€ ë°œìƒí•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜
- ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
- íŒŒì¼ ì ê¹€ í˜„ìƒ

**ì˜ˆì‹œ ë‹µë³€**
> "close()ë¥¼ í•˜ì§€ ì•Šìœ¼ë©´ ì„¸ ê°€ì§€ ì‹¬ê°í•œ ë¬¸ì œê°€ ë°œìƒí•©ë‹ˆë‹¤. ì²«ì§¸, íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜ë¡œ OSê°€ í”„ë¡œì„¸ìŠ¤ë‹¹ ì—´ ìˆ˜ ìˆëŠ” íŒŒì¼ ìˆ˜ ì œí•œ(ë³´í†µ 1024ê°œ)ì— ë„ë‹¬í•´ 'Too many open files' ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤. ë‘˜ì§¸, ë²„í¼ê°€ í•´ì œë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ê°€ ë°œìƒí•˜ê³  ê²°êµ­ OutOfMemoryErrorê°€ ë°œìƒí•©ë‹ˆë‹¤. ì…‹ì§¸, Windowsì—ì„œëŠ” íŒŒì¼ì´ ì ê²¨ì„œ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì ‘ê·¼í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤. ë”°ë¼ì„œ ë°˜ë“œì‹œ try-with-resourcesë¥¼ ì‚¬ìš©í•´ ìë™ìœ¼ë¡œ close()ê°€ í˜¸ì¶œë˜ë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤."

**ë¬¸ì œ ë°œìƒ ì˜ˆì‹œ**
```java
// âŒ ë‚˜ìœ ì˜ˆ - close() ëˆ„ë½
public void badExample() throws IOException {
    for (int i = 0; i < 2000; i++) {
        FileReader fr = new FileReader("file.txt");
        // close() ì•ˆ í•¨!
    }
    // 1024ë²ˆì§¸ ë°˜ë³µì—ì„œ ì—ëŸ¬:
    // java.io.IOException: Too many open files
}

// âœ… ì¢‹ì€ ì˜ˆ - try-with-resources
public void goodExample() throws IOException {
    for (int i = 0; i < 2000; i++) {
        try (FileReader fr = new FileReader("file.txt")) {
            // ìë™ìœ¼ë¡œ close()!
        }
    }
    // ë¬¸ì œ ì—†ìŒ!
}
```

**íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜ í…ŒìŠ¤íŠ¸**
```java
public class FileHandleLeakDemo {
    public static void main(String[] args) throws Exception {
        System.out.println("íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜ í…ŒìŠ¤íŠ¸ ì‹œì‘");

        // âŒ close() ì—†ì´ íŒŒì¼ ì—´ê¸°
        List<FileReader> readers = new ArrayList<>();

        try {
            for (int i = 1; i <= 2000; i++) {
                FileReader fr = new FileReader("test.txt");
                readers.add(fr);

                if (i % 100 == 0) {
                    System.out.println(i + "ê°œ íŒŒì¼ ì—´ë¦¼");
                }
            }
        } catch (IOException e) {
            System.err.println("ì—ëŸ¬ ë°œìƒ: " + e.getMessage());
            // ì¶œë ¥: Too many open files
        }

        System.out.println("ì´ ì—´ë¦° íŒŒì¼: " + readers.size());

        // ì •ë¦¬
        for (FileReader fr : readers) {
            fr.close();
        }
    }
}
```

**ë¬¸ì œ ìœ í˜•ë³„ ìƒì„¸**
```
1. íŒŒì¼ í•¸ë“¤ ëˆ„ìˆ˜
   ì¦ìƒ: Too many open files
   ì›ì¸: OSì˜ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° í…Œì´ë¸” ê³ ê°ˆ
   ì˜í–¥: íŒŒì¼ë¿ ì•„ë‹ˆë¼ ì†Œì¼“ë„ ì—´ ìˆ˜ ì—†ìŒ
   í™•ì¸: lsof (Linux), Process Explorer (Windows)

2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜
   ì¦ìƒ: OutOfMemoryError
   ì›ì¸: BufferedReaderì˜ ë²„í¼(8KB)ê°€ í•´ì œ ì•ˆ ë¨
   ì˜í–¥: í™ ë©”ëª¨ë¦¬ ê³ ê°ˆ
   í™•ì¸: jstat -gc, VisualVM

3. íŒŒì¼ ì ê¹€ (Windows)
   ì¦ìƒ: íŒŒì¼ ì‚­ì œ/ìˆ˜ì • ë¶ˆê°€
   ì›ì¸: WindowsëŠ” íŒŒì¼ì´ ì—´ë ¤ìˆìœ¼ë©´ ì ê¸ˆ
   ì˜í–¥: ë°°í¬ ì‹œ íŒŒì¼ êµì²´ ë¶ˆê°€
   í™•ì¸: Handle (Sysinternals)
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: flush()ì™€ close()ì˜ ì°¨ì´ëŠ”?
- A: flush()ëŠ” ë²„í¼ ë‚´ìš©ì„ íŒŒì¼ì— ì“°ê¸°ë§Œ í•˜ê³ , close()ëŠ” flush() + íŒŒì¼ í•¸ë“¤ í•´ì œê¹Œì§€ í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ì¥ì‹œê°„ ì‹¤í–‰ë˜ëŠ” ì„œë²„ ì• í”Œë¦¬ì¼€ì´ì…˜
- ë°°ì¹˜ ì‘ì—… (ìˆ˜ì²œ ê°œ íŒŒì¼ ì²˜ë¦¬)
- ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜

---

## ğŸ’¼ ì¤‘ê¸‰ ê°œë°œììš© ë©´ì ‘ ì§ˆë¬¸

### ğŸ“— 1. NIOì˜ Channelê³¼ Bufferì˜ ë™ì‘ ì›ë¦¬ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- Channel: ì–‘ë°©í–¥ ë°ì´í„° í†µë¡œ
- Buffer: ë°ì´í„°ë¥¼ ë‹´ëŠ” ì»¨í…Œì´ë„ˆ
- Direct Buffer vs Heap Buffer
- ì„±ëŠ¥ ìµœì í™” ì›ë¦¬

**ì˜ˆì‹œ ë‹µë³€**
> "NIOì˜ Channelì€ ì „í†µì  I/Oì˜ Streamê³¼ ë‹¬ë¦¬ ì–‘ë°©í–¥ í†µì‹ ì´ ê°€ëŠ¥í•œ ë°ì´í„° í†µë¡œì…ë‹ˆë‹¤. FileChannelì„ í†µí•´ ë°ì´í„°ë¥¼ ì½ê±°ë‚˜ ì“¸ ë•Œ ë°˜ë“œì‹œ Bufferë¥¼ ê±°ì¹˜ëŠ”ë°, ì´ëŠ” OS ë ˆë²¨ì˜ ì‹œìŠ¤í…œ ì½œì„ ìµœì†Œí™”í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤. BufferëŠ” í¬ê²Œ Heap Bufferì™€ Direct Bufferë¡œ ë‚˜ë‰˜ëŠ”ë°, Direct BufferëŠ” JVM í™ ì™¸ë¶€ì˜ ë„¤ì´í‹°ë¸Œ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•´ OSì™€ ì§ì ‘ í†µì‹ í•˜ë¯€ë¡œ ë³µì‚¬ ì˜¤ë²„í—¤ë“œê°€ ì—†ì–´ ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ì— ìœ ë¦¬í•©ë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” FileChannel.transferTo()ë¥¼ ì‚¬ìš©í•˜ë©´ Zero-Copyë¡œ íŒŒì¼ì„ ë³µì‚¬í•  ìˆ˜ ìˆì–´ ì„±ëŠ¥ì´ ì¼ë°˜ I/O ëŒ€ë¹„ 10ë°° ì´ìƒ í–¥ìƒë©ë‹ˆë‹¤."

**ë™ì‘ ì›ë¦¬ ë‹¤ì´ì–´ê·¸ë¨**
```
ì „í†µì  I/O:
Application â†’ JVM Heap â†’ OS Buffer â†’ Disk
(ë°ì´í„° ë³µì‚¬ 3íšŒ)

NIO with Direct Buffer:
Application â†’ Direct Buffer â†’ Disk
(ë°ì´í„° ë³µì‚¬ 1íšŒ, Zero-Copy ê°€ëŠ¥)

Channel + Buffer íë¦„:
1. ì½ê¸°:
   FileChannel.read(buffer)
   â†’ OSê°€ Diskì—ì„œ Direct Bufferë¡œ ë³µì‚¬
   â†’ Applicationì´ buffer.get()ìœ¼ë¡œ ì½ê¸°

2. ì“°ê¸°:
   buffer.put(data)
   â†’ Applicationì´ Direct Bufferì— ì“°ê¸°
   â†’ FileChannel.write(buffer)
   â†’ OSê°€ Direct Bufferì—ì„œ Diskë¡œ ë³µì‚¬
```

**ì½”ë“œ ì˜ˆì‹œ**
```java
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class NIOChannelDemo {
    public static void main(String[] args) throws Exception {
        // 1. FileChannel ì—´ê¸°
        Path source = Paths.get("source.txt");
        Path target = Paths.get("target.txt");

        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel targetChannel = FileChannel.open(target,
                 StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            // 2. Buffer í• ë‹¹ (Direct Buffer)
            ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

            // 3. ì½ê¸°
            int bytesRead;
            while ((bytesRead = sourceChannel.read(buffer)) != -1) {
                // Bufferë¥¼ ì½ê¸° ëª¨ë“œë¡œ ì „í™˜
                buffer.flip();

                // 4. ì“°ê¸°
                while (buffer.hasRemaining()) {
                    targetChannel.write(buffer);
                }

                // Buffer ì´ˆê¸°í™”
                buffer.clear();
            }
        }

        // âœ… Zero-Copy íŒŒì¼ ë³µì‚¬ (ë” ë¹ ë¦„!)
        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel targetChannel = FileChannel.open(Paths.get("target2.txt"),
                 StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);
            // OS ë ˆë²¨ì—ì„œ ì§ì ‘ ë³µì‚¬ (Zero-Copy)!
        }
    }
}
```

**ì„±ëŠ¥ ë¹„êµ**
```java
// ì„±ëŠ¥ ì¸¡ì •: 1GB íŒŒì¼ ë³µì‚¬
Path source = Paths.get("1GB.dat");
Path target1 = Paths.get("copy1.dat");
Path target2 = Paths.get("copy2.dat");

// 1. ì „í†µì  I/O
long start1 = System.currentTimeMillis();
try (InputStream in = Files.newInputStream(source);
     OutputStream out = Files.newOutputStream(target1)) {
    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        out.write(buffer, 0, bytesRead);
    }
}
long time1 = System.currentTimeMillis() - start1;
System.out.println("ì „í†µ I/O: " + time1 + "ms");  // ì•½ 5000ms

// 2. NIO Zero-Copy
long start2 = System.currentTimeMillis();
try (FileChannel src = FileChannel.open(source, StandardOpenOption.READ);
     FileChannel dst = FileChannel.open(target2,
         StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
    src.transferTo(0, src.size(), dst);
}
long time2 = System.currentTimeMillis() - start2;
System.out.println("NIO Zero-Copy: " + time2 + "ms");  // ì•½ 500ms (10ë°° ë¹ ë¦„!)
```

**Buffer ìƒíƒœ ê´€ë¦¬**
```java
ByteBuffer buffer = ByteBuffer.allocate(10);

// ì´ˆê¸° ìƒíƒœ
// position=0, limit=10, capacity=10

// ë°ì´í„° ì“°ê¸°
buffer.put((byte) 'H');
buffer.put((byte) 'E');
buffer.put((byte) 'L');
// position=3, limit=10

// ì½ê¸° ëª¨ë“œë¡œ ì „í™˜
buffer.flip();
// position=0, limit=3

// ë°ì´í„° ì½ê¸°
while (buffer.hasRemaining()) {
    System.out.print((char) buffer.get());
}
// position=3, limit=3

// ë²„í¼ ì´ˆê¸°í™”
buffer.clear();
// position=0, limit=10
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: Direct Bufferì˜ ë‹¨ì ì€?
- A: í• ë‹¹/í•´ì œ ë¹„ìš©ì´ ë†’ê³ , GC ëŒ€ìƒì´ ì•„ë‹ˆë¼ ë©”ëª¨ë¦¬ ê´€ë¦¬ê°€ ì–´ë µìŠµë‹ˆë‹¤. ì¥ì‹œê°„ ì‚¬ìš©í•  Bufferì—ë§Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ëŒ€ìš©ëŸ‰ íŒŒì¼ ì „ì†¡ ì„œë¹„ìŠ¤
- ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë° ì„œë²„
- ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—… ì‹œìŠ¤í…œ

---

### ğŸ“— 2. WatchServiceë¡œ íŒŒì¼ ë³€ê²½ ê°ì§€ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ê³¼ ì£¼ì˜ì‚¬í•­ì€?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- WatchService: íŒŒì¼ ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ê°ì§€
- ì´ë²¤íŠ¸ ì¢…ë¥˜: CREATE, MODIFY, DELETE
- í´ë§ ë°©ì‹ vs ì´ë²¤íŠ¸ ë°©ì‹
- ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

**ì˜ˆì‹œ ë‹µë³€**
> "WatchServiceëŠ” Java 7 NIO.2ì—ì„œ ë„ì…ëœ íŒŒì¼ ì‹œìŠ¤í…œ ë³€ê²½ ê°ì§€ APIì…ë‹ˆë‹¤. ë””ë ‰í† ë¦¬ë¥¼ ë“±ë¡í•˜ë©´ íŒŒì¼ ìƒì„±, ìˆ˜ì •, ì‚­ì œ ì´ë²¤íŠ¸ë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” ë¡œê·¸ íŒŒì¼ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ì„¤ì • íŒŒì¼ Hot Reload, íŒŒì¼ ë™ê¸°í™” ë“±ì— ì‚¬ìš©ë©ë‹ˆë‹¤. ì£¼ì˜ì‚¬í•­ìœ¼ë¡œëŠ” í•˜ìœ„ ë””ë ‰í† ë¦¬ëŠ” ìë™ ê°ì§€ë˜ì§€ ì•Šì•„ ì¬ê·€ì ìœ¼ë¡œ ë“±ë¡í•´ì•¼ í•˜ê³ , ì´ë²¤íŠ¸ ìˆœì„œê°€ ë³´ì¥ë˜ì§€ ì•Šìœ¼ë©°, ëŒ€ëŸ‰ ë³€ê²½ ì‹œ ì´ë²¤íŠ¸ê°€ ëˆ„ë½ë  ìˆ˜ ìˆë‹¤ëŠ” ì ì…ë‹ˆë‹¤. ë˜í•œ OSë§ˆë‹¤ êµ¬í˜„ì´ ë‹¬ë¼ Windowsì—ì„œëŠ” ì¦‰ì‹œ ê°ì§€ë˜ì§€ë§Œ Linuxì—ì„œëŠ” ì•½ê°„ì˜ ì§€ì—°ì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

**ê¸°ë³¸ êµ¬í˜„**
```java
import java.nio.file.*;
import static java.nio.file.StandardWatchEventKinds.*;

public class FileWatcher {
    public static void main(String[] args) throws Exception {
        // 1. WatchService ìƒì„±
        WatchService watcher = FileSystems.getDefault().newWatchService();

        // 2. ê°ì‹œí•  ë””ë ‰í† ë¦¬ ë“±ë¡
        Path dir = Paths.get("logs");
        dir.register(watcher, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);

        System.out.println("íŒŒì¼ ë³€ê²½ ê°ì‹œ ì‹œì‘: " + dir);

        // 3. ì´ë²¤íŠ¸ ê°ì§€ ë£¨í”„
        while (true) {
            // ì´ë²¤íŠ¸ ëŒ€ê¸° (ë¸”ë¡œí‚¹)
            WatchKey key = watcher.take();

            // ì´ë²¤íŠ¸ ì²˜ë¦¬
            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();

                // ì˜¤ë²„í”Œë¡œìš° ì²´í¬
                if (kind == OVERFLOW) {
                    System.out.println("âš ï¸ ì´ë²¤íŠ¸ ì˜¤ë²„í”Œë¡œìš°!");
                    continue;
                }

                // íŒŒì¼ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                @SuppressWarnings("unchecked")
                WatchEvent<Path> ev = (WatchEvent<Path>) event;
                Path filename = ev.context();

                System.out.println(kind.name() + ": " + filename);

                // ì´ë²¤íŠ¸ë³„ ì²˜ë¦¬
                if (kind == ENTRY_CREATE) {
                    System.out.println("  â†’ íŒŒì¼ ìƒì„±ë¨");
                } else if (kind == ENTRY_MODIFY) {
                    System.out.println("  â†’ íŒŒì¼ ìˆ˜ì •ë¨");
                } else if (kind == ENTRY_DELETE) {
                    System.out.println("  â†’ íŒŒì¼ ì‚­ì œë¨");
                }
            }

            // WatchKey ë¦¬ì…‹ (ì¤‘ìš”!)
            boolean valid = key.reset();
            if (!valid) {
                System.out.println("ë””ë ‰í† ë¦¬ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
                break;
            }
        }
    }
}
```

**ì‹¤ë¬´ ì˜ˆì‹œ: ë¡œê·¸ íŒŒì¼ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**
```java
import java.nio.file.*;
import java.util.concurrent.*;

public class LogMonitor {
    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    public void startMonitoring(Path logDir) throws Exception {
        WatchService watcher = FileSystems.getDefault().newWatchService();
        logDir.register(watcher, ENTRY_MODIFY);

        System.out.println("ë¡œê·¸ ëª¨ë‹ˆí„°ë§ ì‹œì‘: " + logDir);

        executor.submit(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    WatchKey key = watcher.take();

                    for (WatchEvent<?> event : key.pollEvents()) {
                        if (event.kind() == ENTRY_MODIFY) {
                            Path changedFile = (Path) event.context();

                            if (changedFile.toString().endsWith(".log")) {
                                // ë¡œê·¸ íŒŒì¼ ìˆ˜ì •ë¨ â†’ ë¶„ì„
                                analyzeNewLogs(logDir.resolve(changedFile));
                            }
                        }
                    }

                    key.reset();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    private void analyzeNewLogs(Path logFile) throws Exception {
        // íŒŒì¼ ëì— ì¶”ê°€ëœ ë‚´ìš©ë§Œ ì½ê¸°
        try (var lines = Files.lines(logFile)) {
            lines.filter(line -> line.contains("ERROR"))
                 .forEach(line -> {
                     System.out.println("ğŸš¨ ì—ëŸ¬ ê°ì§€: " + line);
                     // ì•Œë¦¼ ì „ì†¡ ë¡œì§...
                 });
        }
    }

    public void stop() {
        executor.shutdownNow();
    }
}
```

**ì¬ê·€ ê°ì‹œ (í•˜ìœ„ ë””ë ‰í† ë¦¬ í¬í•¨)**
```java
public class RecursiveWatcher {
    private final WatchService watcher;
    private final Map<WatchKey, Path> keys = new HashMap<>();

    public RecursiveWatcher() throws IOException {
        this.watcher = FileSystems.getDefault().newWatchService();
    }

    // ë””ë ‰í† ë¦¬ì™€ ëª¨ë“  í•˜ìœ„ ë””ë ‰í† ë¦¬ ë“±ë¡
    public void registerAll(Path start) throws IOException {
        try (Stream<Path> paths = Files.walk(start)) {
            paths.filter(Files::isDirectory)
                 .forEach(this::register);
        }
    }

    private void register(Path dir) {
        try {
            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
            keys.put(key, dir);
            System.out.println("ë“±ë¡: " + dir);
        } catch (IOException e) {
            System.err.println("ë“±ë¡ ì‹¤íŒ¨: " + dir);
        }
    }

    public void processEvents() throws InterruptedException {
        while (true) {
            WatchKey key = watcher.take();
            Path dir = keys.get(key);

            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();

                if (kind == OVERFLOW) continue;

                @SuppressWarnings("unchecked")
                Path filename = ((WatchEvent<Path>) event).context();
                Path child = dir.resolve(filename);

                System.out.println(kind.name() + ": " + child);

                // ìƒˆ ë””ë ‰í† ë¦¬ ìƒì„± ì‹œ ìë™ ë“±ë¡
                if (kind == ENTRY_CREATE && Files.isDirectory(child)) {
                    registerAll(child);
                }
            }

            if (!key.reset()) {
                keys.remove(key);
                if (keys.isEmpty()) break;
            }
        }
    }
}
```

**ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­**
```
ë¬¸ì œì :
1. ì´ë²¤íŠ¸ ëˆ„ë½
   - ì§§ì€ ì‹œê°„ì— ëŒ€ëŸ‰ ë³€ê²½ ì‹œ OVERFLOW ë°œìƒ
   - í•´ê²°: ì´ë²¤íŠ¸ í í¬ê¸° ì¡°ì • ë˜ëŠ” í´ë§ ê°„ê²© ì¡°ì •

2. í•˜ìœ„ ë””ë ‰í† ë¦¬ ë¯¸ê°ì§€
   - ì§ì ‘ ë“±ë¡í•œ ë””ë ‰í† ë¦¬ë§Œ ê°ì§€
   - í•´ê²°: Files.walk()ë¡œ ì¬ê·€ ë“±ë¡

3. OSë³„ ì°¨ì´
   - Windows: ReadDirectoryChangesW (ì¦‰ì‹œ ê°ì§€)
   - Linux: inotify (ì•½ê°„ì˜ ì§€ì—°)
   - macOS: kqueue (ì„±ëŠ¥ ì´ìŠˆ)

4. ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
   - ë””ë ‰í† ë¦¬ë‹¹ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„° 1ê°œ ì†Œë¹„
   - ëŒ€ëŸ‰ ë””ë ‰í† ë¦¬ ê°ì‹œ ì‹œ ë¦¬ì†ŒìŠ¤ ê³ ê°ˆ
   - í•´ê²°: í•„ìš”í•œ ë””ë ‰í† ë¦¬ë§Œ ì„ ë³„ì ìœ¼ë¡œ ê°ì‹œ
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: ìˆ˜ì²œ ê°œ ë””ë ‰í† ë¦¬ë¥¼ ê°ì‹œí•´ì•¼ í•œë‹¤ë©´?
- A: WatchServiceë³´ë‹¤ëŠ” ì£¼ê¸°ì ì¸ íŒŒì¼ ìŠ¤ìº”(Files.walk() + íƒ€ì„ìŠ¤íƒ¬í”„ ë¹„êµ)ì´ ë” íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ì„¤ì • íŒŒì¼ Hot Reload (Spring DevTools)
- íŒŒì¼ ë™ê¸°í™” ì„œë¹„ìŠ¤ (Dropbox, Google Drive)
- ë¹Œë“œ ë„êµ¬ (Webpack, Gradle ì¦ë¶„ ë¹Œë“œ)
- ë¡œê·¸ ìˆ˜ì§‘ ì‹œìŠ¤í…œ (Fluentd, Logstash)

---

### ğŸ“— 3. íŒŒì¼ ì ê¸ˆ(File Locking)ì€ ì–¸ì œ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- FileLock: ë‹¤ì¤‘ í”„ë¡œì„¸ìŠ¤ ë™ì‹œ ì ‘ê·¼ ì œì–´
- Exclusive Lock vs Shared Lock
- í”Œë«í¼ ì˜ì¡´ì„±
- ë°ë“œë½ ë°©ì§€

**ì˜ˆì‹œ ë‹µë³€**
> "íŒŒì¼ ì ê¸ˆì€ ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì‹œì— ê°™ì€ íŒŒì¼ì— ì ‘ê·¼í•  ë•Œ ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤. FileChannel.lock()ì„ ì‚¬ìš©í•˜ë©´ OS ë ˆë²¨ì—ì„œ íŒŒì¼ì„ ì ê¸€ ìˆ˜ ìˆëŠ”ë°, Exclusive Lock(ë°°íƒ€ì  ì ê¸ˆ)ì€ ì“°ê¸° ì‹œ, Shared Lock(ê³µìœ  ì ê¸ˆ)ì€ ì½ê¸° ì‹œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” ì„¤ì • íŒŒì¼ ì—…ë°ì´íŠ¸, ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜, PID íŒŒì¼ ê´€ë¦¬ ë“±ì— ì‚¬ìš©ë©ë‹ˆë‹¤. ì£¼ì˜í•  ì ì€ í”Œë«í¼ë§ˆë‹¤ ë™ì‘ì´ ë‹¤ë¥´ê³ , í”„ë¡œì„¸ìŠ¤ ê°„ ì ê¸ˆë§Œ ì§€ì›í•˜ë©°(ìŠ¤ë ˆë“œ ê°„ X), ë°ë“œë½ ê°€ëŠ¥ì„±ì´ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤."

**ê¸°ë³¸ ì‚¬ìš©ë²•**
```java
import java.nio.channels.*;
import java.nio.file.*;

public class FileLockingExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("shared.dat");

        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            System.out.println("íŒŒì¼ ì ê¸ˆ ì‹œë„...");

            // Exclusive Lock (ë°°íƒ€ì  ì ê¸ˆ)
            FileLock lock = channel.lock();
            // ë˜ëŠ”: channel.lock(position, size, shared)

            System.out.println("ì ê¸ˆ íšë“ ì„±ê³µ!");
            System.out.println("  - ë°°íƒ€ì  ì ê¸ˆ: " + !lock.isShared());
            System.out.println("  - ìœ íš¨: " + lock.isValid());

            // í¬ë¦¬í‹°ì»¬ ì„¹ì…˜ (ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ ì ‘ê·¼ ë¶ˆê°€)
            channel.write(ByteBuffer.wrap("Critical Data".getBytes()));
            Thread.sleep(5000);  // 5ì´ˆê°„ ì ê¸ˆ ìœ ì§€

            // ì ê¸ˆ í•´ì œ (try-with-resourcesë¡œ ìë™ í•´ì œë¨)
            lock.release();
            System.out.println("ì ê¸ˆ í•´ì œ");
        }
    }
}
```

**Shared Lock vs Exclusive Lock**
```java
public class SharedLockExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("data.txt");

        // Reader 1 - Shared Lock
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file, StandardOpenOption.READ)) {
                FileLock lock = ch.lock(0, Long.MAX_VALUE, true);  // shared=true
                System.out.println("Reader 1: Shared Lock íšë“");

                ByteBuffer buffer = ByteBuffer.allocate(100);
                ch.read(buffer);

                Thread.sleep(3000);
                lock.release();
                System.out.println("Reader 1: ì ê¸ˆ í•´ì œ");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        // Reader 2 - Shared Lock (ë™ì‹œ ê°€ëŠ¥!)
        Thread.sleep(100);
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file, StandardOpenOption.READ)) {
                FileLock lock = ch.lock(0, Long.MAX_VALUE, true);
                System.out.println("Reader 2: Shared Lock íšë“ (ë™ì‹œ!)");

                Thread.sleep(2000);
                lock.release();
                System.out.println("Reader 2: ì ê¸ˆ í•´ì œ");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        // Writer - Exclusive Lock (ëŒ€ê¸°...)
        Thread.sleep(500);
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file,
                    StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                System.out.println("Writer: Exclusive Lock ëŒ€ê¸° ì¤‘...");
                FileLock lock = ch.lock();  // Shared Lock í•´ì œ ëŒ€ê¸°
                System.out.println("Writer: Exclusive Lock íšë“!");

                ch.write(ByteBuffer.wrap("New Data".getBytes()));
                Thread.sleep(1000);
                lock.release();
                System.out.println("Writer: ì ê¸ˆ í•´ì œ");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

**ì‹¤ë¬´ ì˜ˆì‹œ: PID íŒŒì¼ ê´€ë¦¬**
```java
public class ProcessLock {
    private static final Path PID_FILE = Paths.get("/var/run/myapp.pid");
    private FileLock lock;
    private FileChannel channel;

    // ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë³´ì¥
    public boolean acquireLock() {
        try {
            channel = FileChannel.open(PID_FILE,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE);

            // ë¹„ë¸”ë¡œí‚¹ ì ê¸ˆ ì‹œë„
            lock = channel.tryLock();

            if (lock == null) {
                System.err.println("ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œì„¸ìŠ¤ê°€ ìˆìŠµë‹ˆë‹¤!");
                channel.close();
                return false;
            }

            // PID íŒŒì¼ì— í˜„ì¬ í”„ë¡œì„¸ìŠ¤ ID ì“°ê¸°
            String pid = String.valueOf(ProcessHandle.current().pid());
            channel.write(ByteBuffer.wrap(pid.getBytes()));
            channel.force(false);

            System.out.println("í”„ë¡œì„¸ìŠ¤ ì ê¸ˆ íšë“: PID " + pid);

            // JVM ì¢…ë£Œ ì‹œ ìë™ í•´ì œ
            Runtime.getRuntime().addShutdownHook(new Thread(this::releaseLock));

            return true;

        } catch (IOException e) {
            System.err.println("ì ê¸ˆ ì‹¤íŒ¨: " + e.getMessage());
            return false;
        }
    }

    public void releaseLock() {
        try {
            if (lock != null && lock.isValid()) {
                lock.release();
            }
            if (channel != null) {
                channel.close();
            }
            Files.deleteIfExists(PID_FILE);
            System.out.println("í”„ë¡œì„¸ìŠ¤ ì ê¸ˆ í•´ì œ");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        ProcessLock processLock = new ProcessLock();

        if (!processLock.acquireLock()) {
            System.exit(1);
        }

        // ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§
        System.out.println("ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰ ì¤‘...");
        Thread.sleep(10000);  // 10ì´ˆ ì‹¤í–‰
    }
}
```

**ë°ë“œë½ ë°©ì§€**
```java
public class DeadlockAvoidance {
    // âŒ ë‚˜ìœ ì˜ˆ - ë°ë“œë½ ê°€ëŠ¥
    public void badLocking(Path file1, Path file2) throws Exception {
        try (FileChannel ch1 = FileChannel.open(file1, StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(file2, StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.lock();  // Thread A: file1 ì ê¸ˆ
            Thread.sleep(100);
            FileLock lock2 = ch2.lock();  // Thread A: file2 ì ê¸ˆ ëŒ€ê¸°
                                          // Thread B: file2 ì ê¸ˆ, file1 ëŒ€ê¸°
                                          // â†’ ë°ë“œë½!

            // ì‘ì—…...

            lock2.release();
            lock1.release();
        }
    }

    // âœ… ì¢‹ì€ ì˜ˆ - ì ê¸ˆ ìˆœì„œ ì¼ê´€ì„±
    public void goodLocking(Path file1, Path file2) throws Exception {
        // íŒŒì¼ ê²½ë¡œ ê¸°ì¤€ ì •ë ¬ (í•­ìƒ ë™ì¼í•œ ìˆœì„œë¡œ ì ê¸ˆ)
        List<Path> files = Arrays.asList(file1, file2);
        files.sort(Comparator.comparing(Path::toString));

        try (FileChannel ch1 = FileChannel.open(files.get(0), StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(files.get(1), StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.lock();
            FileLock lock2 = ch2.lock();

            // ì‘ì—…...

            lock2.release();
            lock1.release();
        }
    }

    // âœ… ë” ë‚˜ì€ ì˜ˆ - tryLock() ì‚¬ìš©
    public void tryLocking(Path file1, Path file2) throws Exception {
        try (FileChannel ch1 = FileChannel.open(file1, StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(file2, StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.tryLock();
            if (lock1 == null) {
                System.out.println("file1 ì ê¸ˆ ì‹¤íŒ¨ - ë‚˜ì¤‘ì— ì¬ì‹œë„");
                return;
            }

            FileLock lock2 = ch2.tryLock();
            if (lock2 == null) {
                System.out.println("file2 ì ê¸ˆ ì‹¤íŒ¨ - ë¡¤ë°±");
                lock1.release();
                return;
            }

            // ë‘ íŒŒì¼ ëª¨ë‘ ì ê¸ˆ ì„±ê³µ!
            // ì‘ì—…...

            lock2.release();
            lock1.release();
        }
    }
}
```

**í”Œë«í¼ë³„ ì°¨ì´**
```
Windows:
- Mandatory Locking (ê°•ì œ ì ê¸ˆ)
- ì ê¸´ íŒŒì¼ì€ ë‹¤ë¥¸ í”„ë¡œì„¸ìŠ¤ê°€ ì½ê¸°/ì“°ê¸° ë¶ˆê°€
- FileLockì´ í™•ì‹¤í•˜ê²Œ ë™ì‘

Linux/Unix:
- Advisory Locking (ê¶Œê³  ì ê¸ˆ)
- í˜‘ì¡°í•˜ëŠ” í”„ë¡œì„¸ìŠ¤ë§Œ ì¡´ì¤‘
- ê°•ì œí•˜ì§€ ì•Šìœ¼ë©´ ë¬´ì‹œ ê°€ëŠ¥
- fcntl() ì‹œìŠ¤í…œ ì½œ ì‚¬ìš©

Mac OS:
- Advisory Locking
- ì¼ë¶€ íŒŒì¼ ì‹œìŠ¤í…œ(NFS)ì—ì„œ ì œí•œì 
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: ë„¤íŠ¸ì›Œí¬ íŒŒì¼ ì‹œìŠ¤í…œ(NFS)ì—ì„œë„ ë™ì‘í•˜ë‚˜ìš”?
- A: NFS v4ë¶€í„°ëŠ” ì ê¸ˆì„ ì§€ì›í•˜ì§€ë§Œ, ë„¤íŠ¸ì›Œí¬ ì§€ì—°ìœ¼ë¡œ ì¸í•œ ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆì–´ ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¶„ì‚° ì ê¸ˆ(Redis, ZooKeeper)ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ë©€í‹° ì¸ìŠ¤í„´ìŠ¤ ì„œë²„ (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)
- ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜
- ì„¤ì • íŒŒì¼ Hot Reload
- ë°°ì¹˜ ì‘ì—… (ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€)

---

### ğŸ“— 4. Memory-Mapped Fileì˜ ì¥ë‹¨ì ê³¼ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ëŠ”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- MappedByteBuffer: íŒŒì¼ì„ ë©”ëª¨ë¦¬ì— ë§¤í•‘
- Zero-Copy, ë¹ ë¥¸ ëœë¤ ì•¡ì„¸ìŠ¤
- ëŒ€ìš©ëŸ‰ íŒŒì¼, ê³µìœ  ë©”ëª¨ë¦¬
- ë©”ëª¨ë¦¬ ì œí•œ, GC ì´ìŠˆ

**ì˜ˆì‹œ ë‹µë³€**
> "Memory-Mapped Fileì€ íŒŒì¼ì„ ê°€ìƒ ë©”ëª¨ë¦¬ì— ì§ì ‘ ë§¤í•‘í•˜ì—¬ ë©”ëª¨ë¦¬ì²˜ëŸ¼ ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê¸°ìˆ ì…ë‹ˆë‹¤. FileChannel.map()ìœ¼ë¡œ ìƒì„±í•˜ë©°, OSì˜ í˜ì´ì§€ ìºì‹œë¥¼ í™œìš©í•´ ë””ìŠ¤í¬ I/O ì—†ì´ ë©”ëª¨ë¦¬ ì†ë„ë¡œ íŒŒì¼ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¥ì ì€ Zero-Copyë¡œ ì„±ëŠ¥ì´ ë§¤ìš° ë¹ ë¥´ê³ , ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ê³µìœ  ë©”ëª¨ë¦¬ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë©°, ëœë¤ ì•¡ì„¸ìŠ¤ê°€ íš¨ìœ¨ì ì´ë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ë‹¨ì ì€ 32bit JVMì—ì„œëŠ” íŒŒì¼ í¬ê¸°ê°€ ì•½ 2GBë¡œ ì œí•œë˜ê³ , GCê°€ ëª…ì‹œì ìœ¼ë¡œ í•´ì œí•˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜ì´ ìˆìœ¼ë©°, ì“°ê¸° ì‹œ ë””ìŠ¤í¬ ë™ê¸°í™” ì‹œì ì„ ì œì–´í•˜ê¸° ì–´ë µë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” ëŒ€ìš©ëŸ‰ ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤, ë¡œê·¸ íŒŒì¼ ë¶„ì„, í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ì— ì‚¬ìš©í•©ë‹ˆë‹¤."

**ê¸°ë³¸ ì‚¬ìš©ë²•**
```java
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class MemoryMappedFileExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("data.bin");

        // 10MB íŒŒì¼ ìƒì„±
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            // Memory-Mapped Buffer ìƒì„±
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,                    // ì‹œì‘ ìœ„ì¹˜
                10 * 1024 * 1024      // í¬ê¸° (10MB)
            );

            System.out.println("Memory-Mapped File ìƒì„± ì™„ë£Œ");

            // ì“°ê¸° (ë©”ëª¨ë¦¬ ì†ë„!)
            long start = System.nanoTime();
            for (int i = 0; i < 1_000_000; i++) {
                buffer.putInt(i);
            }
            long writeTime = System.nanoTime() - start;
            System.out.println("ì“°ê¸° ì‹œê°„: " + writeTime / 1_000_000 + "ms");

            // ì½ê¸° (ëœë¤ ì•¡ì„¸ìŠ¤)
            buffer.position(0);
            start = System.nanoTime();
            int sum = 0;
            for (int i = 0; i < 1_000_000; i++) {
                sum += buffer.getInt();
            }
            long readTime = System.nanoTime() - start;
            System.out.println("ì½ê¸° ì‹œê°„: " + readTime / 1_000_000 + "ms");
            System.out.println("í•©ê³„: " + sum);

            // ê°•ì œ ë””ìŠ¤í¬ ë™ê¸°í™”
            buffer.force();
        }
    }
}
```

**ì„±ëŠ¥ ë¹„êµ: Mapped vs ì¼ë°˜ I/O**
```java
public class PerformanceComparison {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("test.dat");
        int size = 100_000_000;  // 100MB

        // 1. ì¼ë°˜ FileChannel
        long start1 = System.nanoTime();
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE)) {

            ByteBuffer buffer = ByteBuffer.allocate(8192);
            for (int i = 0; i < size; i++) {
                buffer.putInt(i);
                if (!buffer.hasRemaining()) {
                    buffer.flip();
                    channel.write(buffer);
                    buffer.clear();
                }
            }
            buffer.flip();
            channel.write(buffer);
        }
        long time1 = System.nanoTime() - start1;
        System.out.println("ì¼ë°˜ I/O: " + time1 / 1_000_000 + "ms");
        // ì•½ 500ms

        // 2. Memory-Mapped File
        long start2 = System.nanoTime();
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            MappedByteBuffer mmap = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,
                size * 4L
            );

            for (int i = 0; i < size; i++) {
                mmap.putInt(i);
            }
            mmap.force();
        }
        long time2 = System.nanoTime() - start2;
        System.out.println("Memory-Mapped: " + time2 / 1_000_000 + "ms");
        // ì•½ 100ms (5ë°° ë¹ ë¦„!)

        Files.delete(file);
    }
}
```

**ì‹¤ë¬´ ì˜ˆì‹œ: í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  (IPC)**
```java
// Process 1: Writer
public class IPCWriter {
    public static void main(String[] args) throws Exception {
        Path sharedFile = Paths.get("/tmp/shared_memory");

        try (FileChannel channel = FileChannel.open(sharedFile,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,
                1024
            );

            // ë©”ì‹œì§€ ì“°ê¸°
            String message = "Hello from Process 1";
            buffer.put(message.getBytes());
            buffer.force();

            System.out.println("ë©”ì‹œì§€ ì „ì†¡: " + message);
        }
    }
}

// Process 2: Reader
public class IPCReader {
    public static void main(String[] args) throws Exception {
        Path sharedFile = Paths.get("/tmp/shared_memory");

        try (FileChannel channel = FileChannel.open(sharedFile,
                StandardOpenOption.READ)) {

            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_ONLY,
                0,
                1024
            );

            // ë©”ì‹œì§€ ì½ê¸°
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            String message = new String(bytes).trim();

            System.out.println("ë©”ì‹œì§€ ìˆ˜ì‹ : " + message);
        }
    }
}
```

**ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬**
```java
public class LargeFileProcessor {
    // 1GB íŒŒì¼ì„ ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬
    public void processLargeFile(Path file) throws Exception {
        long fileSize = Files.size(file);
        long chunkSize = 100 * 1024 * 1024;  // 100MB ì²­í¬

        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {
            for (long offset = 0; offset < fileSize; offset += chunkSize) {
                long size = Math.min(chunkSize, fileSize - offset);

                // ì²­í¬ë³„ë¡œ ë§¤í•‘
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_ONLY,
                    offset,
                    size
                );

                System.out.println("ì²˜ë¦¬ ì¤‘: " + offset + " ~ " + (offset + size));
                processChunk(buffer);

                // ëª…ì‹œì  í•´ì œ ì‹œë„ (íš¨ê³¼ ì œí•œì )
                ((DirectBuffer) buffer).cleaner().clean();
            }
        }
    }

    private void processChunk(MappedByteBuffer buffer) {
        // ë°ì´í„° ë¶„ì„ ë¡œì§
        while (buffer.hasRemaining()) {
            byte b = buffer.get();
            // ì²˜ë¦¬...
        }
    }
}
```

**ì¥ë‹¨ì  ì •ë¦¬**
```
ì¥ì :
1. ë¹ ë¥¸ ì„±ëŠ¥
   - Zero-Copy: OS í˜ì´ì§€ ìºì‹œ ì§ì ‘ ì ‘ê·¼
   - ì¼ë°˜ I/O ëŒ€ë¹„ 5~10ë°° ë¹ ë¦„

2. ëœë¤ ì•¡ì„¸ìŠ¤
   - íŒŒì¼ ë‚´ ì„ì˜ ìœ„ì¹˜ ì ‘ê·¼ì´ ë¹ ë¦„
   - ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤ì— ì´ìƒì 

3. ê³µìœ  ë©”ëª¨ë¦¬
   - ì—¬ëŸ¬ í”„ë¡œì„¸ìŠ¤ê°€ ë™ì¼í•œ íŒŒì¼ ê³µìœ 
   - IPC (í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹ ) ê°€ëŠ¥

4. ìë™ í˜ì´ì§•
   - OSê°€ í˜ì´ì§€ ìŠ¤ì™‘ ìë™ ê´€ë¦¬
   - ë©”ëª¨ë¦¬ë³´ë‹¤ í° íŒŒì¼ë„ ì²˜ë¦¬ ê°€ëŠ¥

ë‹¨ì :
1. ë©”ëª¨ë¦¬ ì œí•œ
   - 32bit JVM: ìµœëŒ€ ì•½ 2GB
   - 64bit JVM: ì´ë¡ ì  ë¬´ì œí•œ, ì‹¤ì œ OS ì œí•œ

2. GC ì´ìŠˆ
   - MappedByteBufferëŠ” GC ëŒ€ìƒ ì•„ë‹˜
   - ëª…ì‹œì  í•´ì œ ë¶ˆê°€ (cleaner() í•´í‚¹ í•„ìš”)
   - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜

3. ë””ìŠ¤í¬ ë™ê¸°í™”
   - ì–¸ì œ ë””ìŠ¤í¬ì— ì“°ì´ëŠ”ì§€ ë¶ˆëª…í™•
   - force() í˜¸ì¶œ í•„ìš”

4. í”Œë«í¼ ì˜ì¡´
   - Windowsì™€ Linuxì—ì„œ ë™ì‘ ì°¨ì´
   - ì—ëŸ¬ ì²˜ë¦¬ ë³µì¡
```

**ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤**
```
âœ… ì í•©í•œ ê²½ìš°:
- ëŒ€ìš©ëŸ‰ íŒŒì¼ (100MB~ìˆ˜GB)
- ëœë¤ ì•¡ì„¸ìŠ¤ ë§ìŒ
- ì½ê¸° ìœ„ì£¼
- í”„ë¡œì„¸ìŠ¤ ê°„ ê³µìœ  ë©”ëª¨ë¦¬

âŒ ë¶€ì í•©í•œ ê²½ìš°:
- ì‘ì€ íŒŒì¼ (<10MB)
- ìˆœì°¨ ì½ê¸°/ì“°ê¸°ë§Œ
- ë¹ˆë²ˆí•œ íŒŒì¼ ë‹«ê¸°/ì—´ê¸°
- ì •í™•í•œ ë””ìŠ¤í¬ ë™ê¸°í™” í•„ìš”
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: MappedByteBufferë¥¼ ëª…ì‹œì ìœ¼ë¡œ í•´ì œí•  ìˆ˜ ìˆë‚˜ìš”?
- A: ê³µì‹ APIëŠ” ì—†ì§€ë§Œ, sun.misc.Cleanerë¥¼ ì‚¬ìš©í•˜ëŠ” í•´í‚¹ì´ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ Java 9+ì—ì„œëŠ” ëª¨ë“ˆ ì‹œìŠ¤í…œìœ¼ë¡œ ì¸í•´ ì–´ë µê³ , ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ë°ì´í„°ë² ì´ìŠ¤ ì—”ì§„ (ì¸ë±ìŠ¤ íŒŒì¼)
- ë¡œê·¸ ë¶„ì„ ì‹œìŠ¤í…œ (ëŒ€ìš©ëŸ‰ ë¡œê·¸)
- ê²Œì„ ì„œë²„ (ê³µìœ  ë©”ëª¨ë¦¬)
- ë¹…ë°ì´í„° ì²˜ë¦¬ (Parquet, ORC íŒŒì¼)

---

### ğŸ“— 5. íŒŒì¼ ì‹œìŠ¤í…œì˜ Symbolic Linkì™€ Hard Linkë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µì•ˆ í¬ì¸íŠ¸**
- Symbolic Link: ê²½ë¡œ ì°¸ì¡°
- Hard Link: inode ê³µìœ 
- Files.isSymbolicLink(), Files.readSymbolicLink()
- ìˆœí™˜ ì°¸ì¡° ë°©ì§€

**ì˜ˆì‹œ ë‹µë³€**
> "Symbolic LinkëŠ” íŒŒì¼ì´ë‚˜ ë””ë ‰í† ë¦¬ì˜ ê²½ë¡œë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ì´ê³ , Hard LinkëŠ” ë™ì¼í•œ inodeë¥¼ ê³µìœ í•˜ëŠ” ë³„ë„ì˜ ë””ë ‰í† ë¦¬ ì—”íŠ¸ë¦¬ì…ë‹ˆë‹¤. Java NIO.2ì—ì„œëŠ” Files.isSymbolicLink()ë¡œ ì‹¬ë³¼ë¦­ ë§í¬ë¥¼ ê°ì§€í•˜ê³ , Files.readSymbolicLink()ë¡œ ì‹¤ì œ ê²½ë¡œë¥¼ ì½ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŒŒì¼ ìˆœíšŒ ì‹œ ìˆœí™˜ ì°¸ì¡°ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ FileVisitOption.FOLLOW_LINKSë¥¼ ì‹ ì¤‘í•˜ê²Œ ì‚¬ìš©í•´ì•¼ í•˜ë©°, Files.walk()ì˜ maxDepthë¥¼ ì œí•œí•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” ë¡œê·¸ íŒŒì¼ ì‹¬ë³¼ë¦­ ë§í¬, ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ, ë°°í¬ ë””ë ‰í† ë¦¬ êµ¬ì¡° ë“±ì—ì„œ ë§í¬ë¥¼ ë‹¤ë¤„ì•¼ í•©ë‹ˆë‹¤."

**ê¸°ë³¸ ë§í¬ ì²˜ë¦¬**
```java
import java.nio.file.*;
import java.nio.file.attribute.*;

public class LinkHandling {
    public static void main(String[] args) throws Exception {
        Path original = Paths.get("original.txt");
        Path symlink = Paths.get("symlink.txt");
        Path hardlink = Paths.get("hardlink.txt");

        // ì›ë³¸ íŒŒì¼ ìƒì„±
        Files.writeString(original, "Original content");

        // Symbolic Link ìƒì„±
        Files.createSymbolicLink(symlink, original);
        System.out.println("Symbolic Link ìƒì„±: " + symlink);

        // Hard Link ìƒì„± (Windows: NTFS, Linux: ext4)
        Files.createLink(hardlink, original);
        System.out.println("Hard Link ìƒì„±: " + hardlink);

        // ë§í¬ í™•ì¸
        System.out.println("\n=== ë§í¬ ì •ë³´ ===");
        System.out.println("original ì€ ì‹¬ë³¼ë¦­ ë§í¬? " + Files.isSymbolicLink(original));
        System.out.println("symlink ì€ ì‹¬ë³¼ë¦­ ë§í¬? " + Files.isSymbolicLink(symlink));
        System.out.println("hardlink ì€ ì‹¬ë³¼ë¦­ ë§í¬? " + Files.isSymbolicLink(hardlink));

        // Symbolic Linkì˜ ì‹¤ì œ ê²½ë¡œ ì½ê¸°
        if (Files.isSymbolicLink(symlink)) {
            Path target = Files.readSymbolicLink(symlink);
            System.out.println("symlink ê°€ ê°€ë¦¬í‚¤ëŠ” ê²½ë¡œ: " + target);
        }

        // ì‹¤ì œ íŒŒì¼ ê²½ë¡œ (ì‹¬ë³¼ë¦­ ë§í¬ í•´ì„)
        Path realPath = symlink.toRealPath();
        System.out.println("symlink ì˜ ì‹¤ì œ ê²½ë¡œ: " + realPath);

        // íŒŒì¼ ì†ì„± ì½ê¸°
        System.out.println("\n=== inode ì •ë³´ (Linux/Mac) ===");
        printInode(original);
        printInode(symlink);
        printInode(hardlink);
    }

    private static void printInode(Path path) throws Exception {
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            return;  // WindowsëŠ” inode ì—†ìŒ
        }

        Object fileKey = Files.getAttribute(path, "unix:ino");
        System.out.println(path.getFileName() + " inode: " + fileKey);
    }
}
```

**ì¶œë ¥ ê²°ê³¼**
```
Symbolic Link ìƒì„±: symlink.txt
Hard Link ìƒì„±: hardlink.txt

=== ë§í¬ ì •ë³´ ===
original ì€ ì‹¬ë³¼ë¦­ ë§í¬? false
symlink ì€ ì‹¬ë³¼ë¦­ ë§í¬? true
hardlink ì€ ì‹¬ë³¼ë¦­ ë§í¬? false

symlink ê°€ ê°€ë¦¬í‚¤ëŠ” ê²½ë¡œ: original.txt
symlink ì˜ ì‹¤ì œ ê²½ë¡œ: /full/path/to/original.txt

=== inode ì •ë³´ (Linux/Mac) ===
original.txt inode: 123456
symlink.txt inode: 789012  (ë‹¤ë¥¸ inode)
hardlink.txt inode: 123456  (originalê³¼ ë™ì¼!)
```

**ìˆœí™˜ ì°¸ì¡° ë°©ì§€**
```java
public class CircularLinkDetection {
    public static void main(String[] args) throws Exception {
        Path dir = Paths.get("/tmp/test");
        Files.createDirectories(dir);

        // ìˆœí™˜ ë§í¬ ìƒì„±
        Path subdir = dir.resolve("subdir");
        Files.createDirectories(subdir);
        Path circularLink = subdir.resolve("parent_link");
        Files.createSymbolicLink(circularLink, dir);

        System.out.println("ìˆœí™˜ ë§í¬ êµ¬ì¡° ìƒì„±:");
        System.out.println(dir + " â†’ " + subdir + " â†’ " + circularLink + " â†’ " + dir);

        // âŒ ìˆœí™˜ ë§í¬ë¥¼ ë”°ë¼ê°€ë©´ ë¬´í•œ ë£¨í”„!
        try {
            System.out.println("\në¬´í•œ ìˆœíšŒ ì‹œë„ (ì‹¤íŒ¨í•  ê²ƒ)...");
            try (Stream<Path> paths = Files.walk(dir, FileVisitOption.FOLLOW_LINKS)) {
                paths.limit(100)  // ì•ˆì „ì„ ìœ„í•´ ì œí•œ
                     .forEach(System.out::println);
            }
        } catch (FileSystemLoopException e) {
            System.out.println("ìˆœí™˜ ê°ì§€: " + e.getMessage());
        }

        // âœ… ìˆœí™˜ ë§í¬ë¥¼ ë”°ë¼ê°€ì§€ ì•ŠìŒ (ê¸°ë³¸ ë™ì‘)
        System.out.println("\nì‹¬ë³¼ë¦­ ë§í¬ ë¬´ì‹œ:");
        try (Stream<Path> paths = Files.walk(dir)) {
            paths.forEach(System.out::println);
        }

        // ì •ë¦¬
        Files.delete(circularLink);
        Files.delete(subdir);
        Files.delete(dir);
    }
}
```

**ì•ˆì „í•œ ë§í¬ ìˆœíšŒ**
```java
public class SafeLinkWalker {
    private final Set<Path> visited = new HashSet<>();

    public void walkSafely(Path start) throws IOException {
        Files.walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE,
            new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                        throws IOException {

                    // ì‹¤ì œ ê²½ë¡œë¡œ ë³€í™˜ (ì‹¬ë³¼ë¦­ ë§í¬ í•´ì„)
                    Path realPath = file.toRealPath();

                    // ì´ë¯¸ ë°©ë¬¸í–ˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                    if (!visited.add(realPath)) {
                        System.out.println("ìˆœí™˜ ê°ì§€ (ê±´ë„ˆëœ€): " + file);
                        return FileVisitResult.CONTINUE;
                    }

                    // ì‹¬ë³¼ë¦­ ë§í¬ í‘œì‹œ
                    if (Files.isSymbolicLink(file)) {
                        Path target = Files.readSymbolicLink(file);
                        System.out.println(file + " â†’ " + target);
                    } else {
                        System.out.println(file);
                    }

                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(Path file, IOException exc)
                        throws IOException {
                    if (exc instanceof FileSystemLoopException) {
                        System.out.println("ìˆœí™˜ ë§í¬ ê°ì§€: " + file);
                        return FileVisitResult.SKIP_SUBTREE;
                    }
                    throw exc;
                }
            });
    }
}
```

**ì‹¤ë¬´ ì˜ˆì‹œ: ë¡œê·¸ íŒŒì¼ ë§í¬ ì²˜ë¦¬**
```java
public class LogRotationHandler {
    // ë¡œê·¸ ë¡œí…Œì´ì…˜: current.log â†’ current.log.1 â†’ current.log.2
    public void rotateLog(Path logDir) throws IOException {
        Path current = logDir.resolve("current.log");
        Path symlink = logDir.resolve("latest.log");

        // 1. ê¸°ì¡´ ë¡œê·¸ ë°±ì—…
        if (Files.exists(current)) {
            Path backup = logDir.resolve("current.log." + System.currentTimeMillis());
            Files.move(current, backup);
        }

        // 2. ìƒˆ ë¡œê·¸ íŒŒì¼ ìƒì„±
        Files.createFile(current);

        // 3. Symbolic Link ì—…ë°ì´íŠ¸
        if (Files.exists(symlink)) {
            Files.delete(symlink);
        }
        Files.createSymbolicLink(symlink, current.getFileName());

        System.out.println("ë¡œê·¸ ë¡œí…Œì´ì…˜ ì™„ë£Œ");
        System.out.println("latest.log â†’ " + Files.readSymbolicLink(symlink));
    }

    // ì‹¬ë³¼ë¦­ ë§í¬ë¥¼ ë”°ë¼ê°€ì„œ ë¡œê·¸ ì½ê¸°
    public void readLatestLog() throws IOException {
        Path symlink = Paths.get("logs/latest.log");

        // ì‹¬ë³¼ë¦­ ë§í¬ê°€ ì•„ë‹ˆë©´ ì§ì ‘ ì½ê¸°
        if (!Files.isSymbolicLink(symlink)) {
            readLog(symlink);
            return;
        }

        // ì‹¬ë³¼ë¦­ ë§í¬ â†’ ì‹¤ì œ íŒŒì¼
        Path realFile = symlink.toRealPath();
        System.out.println("ì‹¤ì œ ë¡œê·¸ íŒŒì¼: " + realFile);
        readLog(realFile);
    }

    private void readLog(Path file) throws IOException {
        try (Stream<String> lines = Files.lines(file)) {
            lines.limit(10).forEach(System.out::println);
        }
    }
}
```

**Symbolic Link vs Hard Link ë¹„êµ**
```
íŠ¹ì§•                 | Symbolic Link          | Hard Link
---------------------|------------------------|------------------------
ì‹¤ì œ ì¡´ì¬            | ìƒˆ íŒŒì¼ (í¬ì¸í„°)        | ê¸°ì¡´ inode ì¬ì‚¬ìš©
í¬ê¸°                 | ë§¤ìš° ì‘ìŒ (ê²½ë¡œ ê¸¸ì´)   | ì›ë³¸ê³¼ ë™ì¼
ì›ë³¸ ì‚­ì œ ì‹œ          | ëŠì–´ì§„ ë§í¬ (ê¹¨ì§)      | ì—¬ì „íˆ ì ‘ê·¼ ê°€ëŠ¥
ë””ë ‰í† ë¦¬ ë§í¬        | ê°€ëŠ¥                   | ë¶ˆê°€ (ìˆœí™˜ ë°©ì§€)
ë‹¤ë¥¸ íŒŒì¼ ì‹œìŠ¤í…œ      | ê°€ëŠ¥                   | ë¶ˆê°€ (ê°™ì€ íŒŒì¼ ì‹œìŠ¤í…œë§Œ)
ê°ì§€                 | Files.isSymbolicLink() | inode ë¹„êµ
Windows ì§€ì›         | ì œí•œì  (ê´€ë¦¬ì ê¶Œí•œ)    | NTFSì—ì„œ ê°€ëŠ¥
```

**ê¼¬ë¦¬ ì§ˆë¬¸**
- Q: Windowsì—ì„œ ì‹¬ë³¼ë¦­ ë§í¬ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‚˜ìš”?
- A: Windows Vista+ ì—ì„œ ê°€ëŠ¥í•˜ì§€ë§Œ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•˜ê³ , NTFS íŒŒì¼ ì‹œìŠ¤í…œì´ì–´ì•¼ í•©ë‹ˆë‹¤. ì‹¤ë¬´ì—ì„œëŠ” ì œí•œì ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.

**ì‹¤ë¬´ ì—°ê´€**
- ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜ (latest.log â†’ access.log.20250110)
- ë°°í¬ ë””ë ‰í† ë¦¬ (releases/v1.0 â† current)
- ê°œë°œ í™˜ê²½ ì„¤ì • (config/dev â†’ config/local)
- ë²„ì „ ê´€ë¦¬ ì‹œìŠ¤í…œ (Git worktree, SVN externals)

---

## ğŸ“ í•µì‹¬ ì •ë¦¬

### íŒŒì¼ ì…ì¶œë ¥ í•„ìˆ˜ ì§€ì‹

| í•­ëª© | ë‚´ìš© | ì‚¬ìš© ì‹œê¸° |
|------|------|-----------|
| ê¸°ë³¸ | FileReader/Writer + try-with-resources | ì†Œê·œëª¨ í…ìŠ¤íŠ¸ íŒŒì¼ |
| ì„±ëŠ¥ | BufferedReader/Writer | ëª¨ë“  í…ìŠ¤íŠ¸ I/O |
| í˜„ëŒ€ì  | Files, Path (Java 7+) | ì‹ ê·œ í”„ë¡œì íŠ¸ |
| ëŒ€ìš©ëŸ‰ | Files.lines() ìŠ¤íŠ¸ë¦¼ | 100MB ì´ìƒ |
| ì¸ì½”ë”© | StandardCharsets.UTF_8 ëª…ì‹œ | í•­ìƒ |
| ê³ ê¸‰ | FileChannel, MappedByteBuffer | ëŒ€ìš©ëŸ‰, ê³ ì„±ëŠ¥ |

### ì‹¤ë¬´ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

#### âœ… í•´ì•¼ í•  ê²ƒ
- [x] NIO.2 (Files, Path) ì‚¬ìš©
- [x] try-with-resourcesë¡œ ìë™ close
- [x] UTF-8 ì¸ì½”ë”© ëª…ì‹œ
- [x] BufferedReaderë¡œ ì„±ëŠ¥ í–¥ìƒ
- [x] ëŒ€ìš©ëŸ‰ íŒŒì¼ì€ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
- [x] íŒŒì¼ ì¡´ì¬ ì—¬ë¶€ ì²´í¬
- [x] ìˆœí™˜ ë§í¬ ë°©ì§€

#### âŒ í•˜ì§€ ë§ì•„ì•¼ í•  ê²ƒ
- [x] close() ëˆ„ë½
- [x] ì¸ì½”ë”© ë¯¸ì§€ì •
- [x] Buffer ë¯¸ì‚¬ìš©
- [x] ëŒ€ìš©ëŸ‰ íŒŒì¼ readAllLines()
- [x] í•˜ë“œì½”ë”©ëœ ê²½ë¡œ (C:\\...)
- [x] ì˜ˆì™¸ ë¬´ì‹œ
- [x] í”Œë«í¼ ì˜ì¡´ ì½”ë“œ

### ë©´ì ‘ ëŒ€ë¹„ í•µì‹¬ í¬ì¸íŠ¸

#### ì£¼ë‹ˆì–´ ìˆ˜ì¤€
1. InputStream/Reader ì°¨ì´ ì„¤ëª… ê°€ëŠ¥
2. BufferedReader ì„±ëŠ¥ í–¥ìƒ ì´ìœ 
3. try-with-resources ì‚¬ìš©ë²•
4. NIO.2 ê¸°ë³¸ API (Files, Path)
5. ì¸ì½”ë”© ë¬¸ì œ í•´ê²°
6. ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ (ìŠ¤íŠ¸ë¦¼)
7. close() ëˆ„ë½ ì‹œ ë¬¸ì œì 

#### ì¤‘ê¸‰ ìˆ˜ì¤€
1. Channel + Buffer ë™ì‘ ì›ë¦¬
2. WatchService ì‹¤ì‹œê°„ ê°ì§€
3. íŒŒì¼ ì ê¸ˆ (FileLock) ì‚¬ìš©ë²•
4. Memory-Mapped File ì¥ë‹¨ì 
5. Symbolic/Hard Link ì²˜ë¦¬
6. Zero-Copy íŒŒì¼ ì „ì†¡
7. í”„ë¡œì„¸ìŠ¤ ê°„ í†µì‹  (IPC)

---

## ğŸ‰ 37ì¥ ì™„ë£Œ!

**ì¶•í•˜í•©ë‹ˆë‹¤!** íŒŒì¼ ì…ì¶œë ¥ì„ ì™„ì „íˆ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤!

**ì´ì œ ì—¬ëŸ¬ë¶„ì€**:
- âœ… ë©´ì ‘ ì§ˆë¬¸ì— ìì‹  ìˆê²Œ ë‹µë³€ ê°€ëŠ¥
- âœ… ì£¼ë‹ˆì–´ 7ê°œ + ì¤‘ê¸‰ 5ê°œ ì§ˆë¬¸ ì™„ë²½ ëŒ€ë¹„
- âœ… ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤ ëŒ€ì‘ ê°€ëŠ¥
- âœ… ëŒ€ìš©ëŸ‰ íŒŒì¼ ì²˜ë¦¬ ê°€ëŠ¥
- âœ… ê³ ê¸‰ NIO ê¸°ëŠ¥ í™œìš© ê°€ëŠ¥

**ë‹¤ìŒ ì¥ìœ¼ë¡œ**: [38ì¥: ì§ë ¬í™”ì™€ ì—­ì§ë ¬í™” â†’](38-1-ì§ë ¬í™”ì™€-ì—­ì§ë ¬í™”-Part1.md)

**ì´ì „ Part**: [â† 37-2: NIOì™€ ì‹¤ì „ í”„ë¡œì íŠ¸](37-2-íŒŒì¼-ì…ì¶œë ¥-Part2.md)

**ëª©ì°¨ë¡œ ëŒì•„ê°€ê¸°**: [ğŸ“š ì „ì²´ ëª©ì°¨](README.md)
