# 2. Docker 아키텍처와 내부 동작 원리

> **학습 목표**: Docker의 내부 동작 원리를 이해하고 컨테이너 기술의 핵심 개념을 실무에 적용할 수 있습니다

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐☆☆ (3개/5개)

---

## 📚 목차
1. [왜 이 지식이 필요한가](#왜-이-지식이-필요한가)
2. [실생활 비유로 이해하기](#실생활-비유로-이해하기)
3. [수치로 보는 효과](#수치로-보는-효과)
4. [컨테이너 vs 가상머신 (VM) 상세 비교](#컨테이너-vs-가상머신-vm-상세-비교)
5. [Docker 아키텍처 구조](#docker-아키텍처-구조)
6. [이미지 레이어와 파일 시스템](#이미지-레이어와-파일-시스템)
7. [격리 기술과 생명주기](#격리-기술과-생명주기)
8. [주니어 시나리오](#주니어-시나리오)
9. [FAQ](#faq)
10. [면접 질문 리스트](#면접-질문-리스트)
11. [핵심 정리](#핵심-정리)
12. [다음 단계](#다음-단계)
13. [축하합니다](#축하합니다)

---

## 🤔 왜 이 지식이 필요한가?

### 실무 배경

**컨테이너 기술을 이해하지 못하면 발생하는 문제**

#### ❌ 이 지식을 모르면 발생하는 문제

```
문제 1: 컨테이너가 왜 빠른지 모르고 사용
- 증상: VM과 컨테이너를 혼동하여 잘못된 선택
- 영향: 리소스 낭비 및 성능 저하
- 비용: 불필요한 인프라 비용 지출

문제 2: 이미지 레이어 구조를 모르고 Dockerfile 작성
- 증상: 빌드 시간이 매번 10분 이상 소요
- 영향: 개발자의 생산성 저하
- 비용: 팀 전체의 개발 시간 낭비

문제 3: 격리 기술을 이해하지 못한 보안 설정
- 증상: 컨테이너 보안 취약점 노출
- 영향: 데이터 유출 및 시스템 침해
- 비용: 보안 사고 대응 비용 및 신뢰 손실
```

#### ✅ 이 지식을 사용하면

```
해결책 1: 컨테이너와 VM의 차이를 정확히 이해
- 방법: 네임스페이스와 cgroups의 원리 학습
- 효과: 적재적소에 맞는 기술 선택
- 절감: 인프라 비용 40-60% 절감

해결책 2: 레이어 캐싱을 활용한 Dockerfile 최적화
- 방법: 레이어 구조와 Copy-on-Write 이해
- 효과: 빌드 시간 10분 → 30초로 단축
- 절감: 개발자 대기 시간 95% 감소

해결책 3: 격리 기술을 이해한 안전한 컨테이너 운영
- 방법: 네임스페이스, cgroups, 리소스 제한 적용
- 효과: 보안 강화 및 리소스 효율성 증대
- 절감: 보안 사고 위험 80% 감소
```

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 아파트 vs 단독 주택 (컨테이너 vs VM)

```
가상머신 (VM) = 단독 주택
┌─────────────────────────┐
│     단독 주택 (VM)      │
│  - 자체 수도 시스템     │
│  - 자체 전기 시스템     │
│  - 자체 난방 시스템     │
│  → 완전 독립적          │
│  → 비용 많이 듦         │
└─────────────────────────┘

컨테이너 = 아파트
┌─────────────────────────┐
│     아파트 (Container)  │
│  - 공동 수도/전기 공유  │
│  - 각 세대는 독립 공간  │
│  - 빠른 입주/퇴거       │
│  → 효율적이고 경제적    │
└─────────────────────────┘
```

### 비유 2: 레고 블록 (이미지 레이어)

```
Docker 이미지 = 레고 블록 쌓기

┌─────────────────┐
│  Layer 5: 앱    │  ← 최종 조립품
├─────────────────┤
│  Layer 4: 패키지│  ← 부품 추가
├─────────────────┤
│  Layer 3: 환경  │  ← 색상 블록
├─────────────────┤
│  Layer 2: 업데이트│ ← 기본 블록
├─────────────────┤
│  Layer 1: 베이스│  ← 기본 판
└─────────────────┘

- 한 번 만든 블록은 재사용 가능
- 위에만 새 블록 추가 가능
- 아래 블록은 변경 불가
```

### 비유 3: 공유 오피스 (네임스페이스)

```
호스트 시스템 = 공유 오피스 건물

┌─────────────────────────────┐
│     공유 오피스 건물        │
│  ┌─────┐ ┌─────┐ ┌─────┐  │
│  │회사A│ │회사B│ │회사C│  │
│  │독립 │ │독립 │ │독립 │  │
│  │공간 │ │공간 │ │공간 │  │
│  └─────┘ └─────┘ └─────┘  │
│                             │
│  공동 시설: 엘리베이터,     │
│  로비, 전기, 인터넷         │
└─────────────────────────────┘

- 각 회사는 서로 못 봄 (격리)
- 공동 자원은 효율적 사용
- 빠른 입주/퇴실 가능
```

### 비유 4: 음식 배달 시스템 (Copy-on-Write)

```
원본 메뉴 = 읽기 전용 이미지 레이어

┌─────────────────────┐
│   원본 메뉴판       │
│  - 모든 고객이 봄   │
│  - 수정 불가        │
└─────────────────────┘
         ↓
    고객이 주문
         ↓
┌─────────────────────┐
│   주문서 (복사)     │  ← 컨테이너 레이어
│  - 개인화된 내용    │
│  - 수정 가능        │
└─────────────────────┘

- 원본은 그대로 유지
- 변경이 필요할 때만 복사
- 효율적인 공간 사용
```

### 비유 5: 택배 상자 (컨테이너 생명주기)

```
Created (생성) = 상자 준비
  - 주소 라벨 부착 완료
  - 내용물 포장 완료
  ↓

Running (실행) = 배송 중
  - 트럭에 실어 이동
  - 실시간 위치 추적
  ↓

Paused (일시정지) = 휴게소 정차
  - 트럭은 멈춤
  - 내용물은 그대로
  ↓

Stopped (중지) = 배송 완료
  - 목적지 도착
  - 엔진 정지
  ↓

Removed (삭제) = 상자 폐기
  - 완전히 처리
  - 복구 불가
```

---

## 📊 수치로 보는 효과

**Docker 컨테이너 도입 전후 비교**

| 지표 | VM 사용 (Before) | 컨테이너 (After) | 개선율 |
|------|------------------|------------------|--------|
| 시작 시간 | 1-5분 | 1-3초 | **99%↓** |
| 이미지 크기 | 1-20GB | 50-500MB | **95%↓** |
| 메모리 사용량 | 2-8GB/인스턴스 | 50-500MB/컨테이너 | **90%↓** |
| 서버당 밀도 | 10-20개 VM | 100-1000개 컨테이너 | **50배↑** |
| 빌드 시간 (캐싱 적용) | 매번 10분 | 30초 | **95%↓** |
| 인프라 비용 | $10,000/월 | $3,000/월 | **70%↓** |
| 배포 시간 | 30분 | 1분 | **97%↓** |
| 개발 환경 설정 | 8시간 | 5분 | **98%↓** |

---

## 컨테이너 vs 가상머신 (VM) 상세 비교

### 실생활 비유로 이해하기

**아파트 vs 단독 주택**:

**가상머신 (VM)** = 단독 주택
```
각 집마다:
- 자체 수도 시스템 (독립된 OS)
- 자체 전기 시스템 (독립된 커널)
- 자체 난방 시스템 (독립된 리소스)
→ 완전히 독립적이지만, 비용이 많이 듭니다
```

**컨테이너** = 아파트
```
공동 인프라 공유:
- 공동 수도/전기 (호스트 OS 공유)
- 각 세대는 독립적인 공간 (프로세스 격리)
- 빠른 입주/퇴거 (빠른 시작/종료)
→ 효율적이고 경제적입니다
```

### 기술적 비교

#### 가상머신 (VM) 아키텍처

```
┌─────────────────────────────────────────┐
│         애플리케이션 A (Node.js)         │
├─────────────────────────────────────────┤
│         Guest OS (Ubuntu)               │
│         - 커널                          │
│         - 시스템 라이브러리              │
│         - 바이너리/라이브러리            │
├─────────────────────────────────────────┤
│         하이퍼바이저 (VirtualBox)        │
├─────────────────────────────────────────┤
│         Host OS (Windows)               │
├─────────────────────────────────────────┤
│         물리적 서버 (하드웨어)           │
└─────────────────────────────────────────┘

VM 특징:
- 각 VM마다 완전한 OS 포함 (수 GB)
- 부팅 시간: 수십 초 ~ 수 분
- 하드웨어 가상화 (CPU, RAM, Disk 모두 가상화)
- 강력한 격리 (완전히 독립된 환경)
```

#### Docker 컨테이너 아키텍처

```
┌─────────────────────────────────────────┐
│    컨테이너 A     │    컨테이너 B      │
│   (Node.js App)   │   (Python App)     │
├───────────────────┴────────────────────┤
│         Docker Engine                   │
├─────────────────────────────────────────┤
│         Host OS (Linux Kernel)          │
├─────────────────────────────────────────┤
│         물리적 서버 (하드웨어)           │
└─────────────────────────────────────────┘

컨테이너 특징:
- OS 커널 공유 (수십 MB ~ 수백 MB)
- 시작 시간: 수 초 이내
- 프로세스 레벨 가상화
- 경량 격리 (네임스페이스 + cgroups)
```

### 상세 비교표

```
┌────────────────────┬──────────────────┬──────────────────┐
│   비교 항목        │   가상머신 (VM)   │   Docker 컨테이너 │
├────────────────────┼──────────────────┼──────────────────┤
│ OS                 │ 각 VM마다 완전한  │ 호스트 OS 커널   │
│                    │ Guest OS 필요    │ 공유             │
├────────────────────┼──────────────────┼──────────────────┤
│ 크기               │ GB 단위          │ MB 단위          │
│                    │ (1~20GB)         │ (50~500MB)       │
├────────────────────┼──────────────────┼──────────────────┤
│ 시작 시간          │ 분 단위          │ 초 단위          │
│                    │ (30초~5분)       │ (1~3초)          │
├────────────────────┼──────────────────┼──────────────────┤
│ 성능               │ 하이퍼바이저     │ 네이티브에       │
│                    │ 오버헤드 있음    │ 가까움           │
├────────────────────┼──────────────────┼──────────────────┤
│ 격리 수준          │ 매우 강력        │ 강력             │
│                    │ (하드웨어 레벨)  │ (프로세스 레벨)  │
├────────────────────┼──────────────────┼──────────────────┤
│ 이식성             │ 하이퍼바이저에   │ 매우 높음        │
│                    │ 의존적           │ (OS 독립적)      │
├────────────────────┼──────────────────┼──────────────────┤
│ 리소스 효율성      │ 낮음             │ 높음             │
│                    │ (중복 OS)        │ (OS 공유)        │
├────────────────────┼──────────────────┼──────────────────┤
│ 밀도               │ 서버당 수십 개   │ 서버당 수백~     │
│                    │                  │ 수천 개          │
├────────────────────┼──────────────────┼──────────────────┤
│ 보안               │ 매우 강력        │ 강력             │
│                    │ (완전 격리)      │ (공유 커널)      │
├────────────────────┼──────────────────┼──────────────────┤
│ 사용 사례          │ - 다른 OS 필요   │ - 마이크로서비스 │
│                    │ - 강력한 격리    │ - 빠른 배포      │
│                    │ - 레거시 앱      │ - CI/CD          │
└────────────────────┴──────────────────┴──────────────────┘
```

### 실제 비교 예제

#### 메모리 사용량 비교

```bash
# 가상머신 3개 실행
VM 1: Ubuntu 20.04 (2GB RAM)
VM 2: Ubuntu 20.04 (2GB RAM)
VM 3: Ubuntu 20.04 (2GB RAM)
총 메모리 사용량: 6GB

# Docker 컨테이너 3개 실행
Container 1: Ubuntu 기반 Node.js (200MB)
Container 2: Ubuntu 기반 Python (150MB)
Container 3: Ubuntu 기반 Java (300MB)
총 메모리 사용량: 650MB
```

#### 시작 시간 비교

```bash
# 가상머신
$ time VBoxManage startvm "Ubuntu-VM" --type headless
real    1m23.456s

# Docker 컨테이너
$ time docker run -d nginx
real    0m2.123s
```

### 언제 무엇을 사용해야 하나?

**가상머신을 사용해야 할 때**:
- ✅ 다른 OS가 필요할 때 (Windows에서 Linux, Mac에서 Windows)
- ✅ 매우 강력한 격리가 필요할 때 (보안 중요)
- ✅ GUI가 필요한 데스크톱 애플리케이션
- ✅ 레거시 애플리케이션 (OS 전체 필요)
- ✅ 커널 레벨 테스트

**Docker 컨테이너를 사용해야 할 때**:
- ✅ 마이크로서비스 아키텍처
- ✅ 빠른 배포와 스케일링
- ✅ CI/CD 파이프라인
- ✅ 개발 환경 표준화
- ✅ 클라우드 네이티브 애플리케이션

**함께 사용하는 경우**:
```
Windows/Mac 개발 환경:
┌─────────────────────────────────────┐
│         Docker Desktop              │
│  ┌───────────────────────────────┐  │
│  │     Linux VM (경량)           │  │
│  │  ┌─────────┬─────────┬──────┐ │  │
│  │  │Container│Container│Cont..│ │  │
│  │  │  (App)  │  (DB)   │(Cache)│  │
│  │  └─────────┴─────────┴──────┘ │  │
│  └───────────────────────────────┘  │
└─────────────────────────────────────┘

→ VM 안에서 컨테이너를 실행
→ 개발자는 컨테이너만 관리
```

---

## Docker 아키텍처 구조

### 전체 아키텍처 개요

```
┌─────────────────────────────────────────────────────────────┐
│                        Docker Host                          │
│                                                             │
│  ┌──────────────────┐         ┌──────────────────────┐    │
│  │  Docker Client   │─────────│   Docker Daemon      │    │
│  │                  │  REST   │   (dockerd)          │    │
│  │  $ docker run    │  API    │                      │    │
│  │  $ docker build  │         │  ┌────────────────┐  │    │
│  │  $ docker pull   │         │  │  containerd    │  │    │
│  └──────────────────┘         │  │                │  │    │
│                                │  │  ┌──────────┐  │  │    │
│                                │  │  │   runc   │  │  │    │
│                                │  │  └──────────┘  │  │    │
│                                │  └────────────────┘  │    │
│                                │                      │    │
│                                │  Containers:         │    │
│                                │  ┌─────┐ ┌─────┐    │    │
│                                │  │ C 1 │ │ C 2 │    │    │
│                                │  └─────┘ └─────┘    │    │
│                                └──────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                                      │
                                      │ HTTPS
                                      ↓
                          ┌────────────────────┐
                          │  Docker Registry   │
                          │   (Docker Hub)     │
                          │                    │
                          │  ┌──────────────┐  │
                          │  │   Images     │  │
                          │  └──────────────┘  │
                          └────────────────────┘
```

### Docker Client

**역할**: 사용자 인터페이스

```bash
# Docker CLI 명령어들
$ docker run nginx           # 컨테이너 실행
$ docker build -t myapp .    # 이미지 빌드
$ docker ps                  # 실행 중인 컨테이너 확인
$ docker images              # 이미지 목록
$ docker logs container_id   # 로그 확인
```

**동작 방식**:
```
사용자 입력: $ docker run nginx
      ↓
1. CLI가 명령어 파싱
2. REST API 요청 생성
   POST /containers/create
   POST /containers/{id}/start
      ↓
3. Docker Daemon으로 전송
   (기본: /var/run/docker.sock)
      ↓
4. 결과 수신 및 출력
```

**원격 Docker 호스트 제어**:
```bash
# 로컬 Docker Daemon
$ docker ps

# 원격 Docker Daemon 제어
$ docker -H tcp://192.168.1.100:2376 ps

# 환경 변수로 설정
$ export DOCKER_HOST=tcp://192.168.1.100:2376
$ docker ps
```

### Docker Daemon (dockerd)

**역할**: Docker의 핵심 서비스

```
Docker Daemon의 주요 기능:
┌─────────────────────────────────────┐
│        Docker Daemon (dockerd)      │
├─────────────────────────────────────┤
│ 1. API 요청 수신 및 처리            │
│ 2. 이미지 관리                      │
│    - 빌드, 다운로드, 삭제           │
│ 3. 컨테이너 생명주기 관리           │
│    - 생성, 시작, 중지, 삭제         │
│ 4. 네트워크 관리                    │
│    - 브리지, 오버레이 등            │
│ 5. 볼륨 관리                        │
│    - 데이터 영속성                  │
│ 6. 레지스트리 통신                  │
│    - push, pull                     │
└─────────────────────────────────────┘
```

**Docker Daemon 구성 요소**:

```
dockerd
  ├── API Server (REST API 제공)
  ├── Image Manager (이미지 관리)
  ├── Container Manager (컨테이너 관리)
  ├── Network Manager (네트워크 관리)
  ├── Volume Manager (볼륨 관리)
  └── containerd (저수준 컨테이너 런타임)
        └── runc (OCI 런타임 - 실제 컨테이너 실행)
```

**Daemon 설정 파일**:

```json
// /etc/docker/daemon.json (Linux)
// C:\ProgramData\docker\config\daemon.json (Windows)

{
  "log-level": "info",
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  },
  "storage-driver": "overlay2",
  "registry-mirrors": [
    "https://mirror.gcr.io"
  ],
  "insecure-registries": [
    "192.168.1.100:5000"
  ],
  "default-address-pools": [
    {
      "base": "172.17.0.0/16",
      "size": 24
    }
  ]
}
```

### containerd

**역할**: 고수준 컨테이너 런타임

```
containerd의 책임:
┌─────────────────────────────────────┐
│          containerd                 │
├─────────────────────────────────────┤
│ - 이미지 전송 및 저장               │
│ - 컨테이너 실행 및 감독             │
│ - 저수준 스토리지                   │
│ - 네트워크 인터페이스 관리          │
└─────────────────────────────────────┘
```

**containerd 명령어**:
```bash
# containerd 직접 사용 (고급)
$ ctr images pull docker.io/library/nginx:latest
$ ctr run --rm docker.io/library/nginx:latest nginx-container
```

### runc

**역할**: OCI (Open Container Initiative) 런타임

```
runc의 역할:
┌─────────────────────────────────────┐
│              runc                   │
├─────────────────────────────────────┤
│ - 리눅스 커널 기능 활용             │
│   • 네임스페이스 생성               │
│   • cgroups 설정                    │
│   • 파일시스템 마운트               │
│ - 컨테이너 프로세스 실행            │
│ - OCI 사양 준수                     │
└─────────────────────────────────────┘
```

**runc 직접 사용 예제**:
```bash
# OCI 번들 준비
$ mkdir -p mycontainer/rootfs
$ docker export $(docker create busybox) | tar -C mycontainer/rootfs -xvf -
$ cd mycontainer
$ runc spec

# 컨테이너 실행
$ runc run mycontainer
```

### Docker Registry

**역할**: 이미지 저장소

```
┌─────────────────────────────────────┐
│        Docker Registry              │
├─────────────────────────────────────┤
│                                     │
│  Public Registry:                   │
│  - Docker Hub (hub.docker.com)      │
│  - GitHub Container Registry        │
│  - Quay.io                          │
│                                     │
│  Private Registry:                  │
│  - Docker Registry (오픈소스)       │
│  - Harbor                           │
│  - AWS ECR, GCP GCR, Azure ACR      │
│                                     │
└─────────────────────────────────────┘
```

**이미지 저장 구조**:
```
Registry
  └── Repository: nginx
        ├── Tag: latest → Manifest (SHA256: abc123...)
        ├── Tag: 1.21   → Manifest (SHA256: def456...)
        └── Tag: alpine → Manifest (SHA256: ghi789...)

Manifest (이미지 메타데이터):
  - Config: 이미지 설정 (환경변수, 실행 명령 등)
  - Layers:
      Layer 1 (SHA256: layer1...)
      Layer 2 (SHA256: layer2...)
      Layer 3 (SHA256: layer3...)
```

**레지스트리 통신 흐름**:
```
1. docker pull nginx:latest

2. Docker Daemon → Registry
   GET /v2/library/nginx/manifests/latest

3. Registry → Docker Daemon
   Manifest 반환 (레이어 목록)

4. Docker Daemon → Registry (각 레이어마다)
   GET /v2/library/nginx/blobs/sha256:abc123...
   GET /v2/library/nginx/blobs/sha256:def456...

5. 레이어 다운로드 및 로컬 저장
   /var/lib/docker/overlay2/
```

### 전체 흐름: docker run 명령어 실행 과정

```
$ docker run -d -p 80:80 nginx
      │
      ↓
┌─────────────────────────────────────────────────────────┐
│ 1. Docker Client (CLI)                                  │
│    - 명령어 파싱: run, -d, -p 80:80, nginx             │
│    - API 요청 생성                                      │
└─────────────────────────────────────────────────────────┘
      │ REST API 호출
      ↓
┌─────────────────────────────────────────────────────────┐
│ 2. Docker Daemon (dockerd)                              │
│    - 로컬에 nginx 이미지 있나? → 없음                  │
│    - Registry에서 이미지 다운로드 필요                 │
└─────────────────────────────────────────────────────────┘
      │ HTTPS
      ↓
┌─────────────────────────────────────────────────────────┐
│ 3. Docker Registry (Docker Hub)                         │
│    - nginx:latest 이미지 검색                          │
│    - Manifest 전송                                      │
│    - 레이어 다운로드 (Layer 1, 2, 3...)                │
└─────────────────────────────────────────────────────────┘
      │ 이미지 레이어
      ↓
┌─────────────────────────────────────────────────────────┐
│ 4. Image Manager (dockerd 내부)                         │
│    - 레이어 저장: /var/lib/docker/overlay2/            │
│    - 이미지 메타데이터 저장                             │
└─────────────────────────────────────────────────────────┘
      │
      ↓
┌─────────────────────────────────────────────────────────┐
│ 5. Container Manager (dockerd 내부)                     │
│    - 컨테이너 생성 요청                                 │
│    - 네트워크 설정 (포트 80:80)                        │
│    - 볼륨 설정 (필요 시)                               │
└─────────────────────────────────────────────────────────┘
      │ containerd API
      ↓
┌─────────────────────────────────────────────────────────┐
│ 6. containerd                                           │
│    - 이미지 스냅샷 생성                                 │
│    - 컨테이너 번들 준비                                 │
│    - runc 호출                                          │
└─────────────────────────────────────────────────────────┘
      │ OCI Runtime API
      ↓
┌─────────────────────────────────────────────────────────┐
│ 7. runc                                                 │
│    - 네임스페이스 생성 (PID, NET, MNT, UTS, IPC)       │
│    - cgroups 설정 (CPU, 메모리 제한)                   │
│    - 루트 파일시스템 마운트                             │
│    - 컨테이너 프로세스 실행 (nginx)                    │
└─────────────────────────────────────────────────────────┘
      │
      ↓
┌─────────────────────────────────────────────────────────┐
│ 8. 컨테이너 실행 중                                     │
│    ┌───────────────────────────────────────┐           │
│    │  Container (nginx)                    │           │
│    │  - PID: 1 (nginx master process)     │           │
│    │  - Port: 80 (mapped to host 80)      │           │
│    │  - Network: bridge                    │           │
│    └───────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────┘
      │
      ↓
┌─────────────────────────────────────────────────────────┐
│ 9. Docker Client                                        │
│    - 컨테이너 ID 반환: a1b2c3d4e5f6                    │
│    - 사용자에게 출력                                    │
└─────────────────────────────────────────────────────────┘
```

---

## 이미지 레이어와 파일 시스템

### 이미지 레이어 구조

**실생활 비유**: 레고 블록

```
베이스 이미지 = 레고 기본 판
      ↓
각 명령어 = 레고 블록 추가
      ↓
최종 이미지 = 완성된 레고 작품
```

**Docker 이미지 레이어 구조**:

```
┌─────────────────────────────────────┐
│      컨테이너 레이어 (읽기/쓰기)     │  ← 실행 중 변경사항
├─────────────────────────────────────┤
│   Layer 5: COPY app.jar /app/       │  ← 애플리케이션 코드
├─────────────────────────────────────┤
│   Layer 4: RUN apt-get install...   │  ← 추가 패키지
├─────────────────────────────────────┤
│   Layer 3: ENV JAVA_HOME=...        │  ← 환경 변수
├─────────────────────────────────────┤
│   Layer 2: RUN apt-get update       │  ← 패키지 업데이트
├─────────────────────────────────────┤
│   Layer 1: FROM ubuntu:20.04        │  ← 베이스 이미지
└─────────────────────────────────────┘
        ↑
    읽기 전용 레이어들
```

**실제 Dockerfile과 레이어 매핑**:

```dockerfile
# Dockerfile
FROM ubuntu:20.04                    # → Layer 1
RUN apt-get update                   # → Layer 2
RUN apt-get install -y openjdk-11    # → Layer 3
COPY app.jar /app/                   # → Layer 4
CMD ["java", "-jar", "/app/app.jar"] # → Layer 5 (메타데이터만, 실제 레이어 X)
```

**각 레이어 확인**:

```bash
# 이미지 히스토리 확인
$ docker history myapp:latest

IMAGE          CREATED         CREATED BY                                      SIZE
a1b2c3d4e5f6   2 minutes ago   CMD ["java" "-jar" "/app/app.jar"]             0B
b2c3d4e5f6a1   2 minutes ago   COPY app.jar /app/                             50MB
c3d4e5f6a1b2   3 minutes ago   RUN apt-get install -y openjdk-11              200MB
d4e5f6a1b2c3   5 minutes ago   RUN apt-get update                             30MB
e5f6a1b2c3d4   2 days ago      FROM ubuntu:20.04                              72.8MB

# 레이어 상세 정보
$ docker inspect myapp:latest

"RootFS": {
    "Type": "layers",
    "Layers": [
        "sha256:e5f6a1b2c3d4...",  # Layer 1: Ubuntu base
        "sha256:d4e5f6a1b2c3...",  # Layer 2: apt-get update
        "sha256:c3d4e5f6a1b2...",  # Layer 3: openjdk install
        "sha256:b2c3d4e5f6a1..."   # Layer 4: app.jar copy
    ]
}
```

### 레이어 재사용

**이미지 A와 이미지 B가 같은 베이스 사용**:

```
이미지 A (Node.js 앱):
┌─────────────────────┐
│ Layer 3: app.js     │  5MB
├─────────────────────┤
│ Layer 2: npm install│  100MB
├─────────────────────┤
│ Layer 1: node:18    │  200MB  ← 공유
└─────────────────────┘

이미지 B (Express 앱):
┌─────────────────────┐
│ Layer 3: server.js  │  10MB
├─────────────────────┤
│ Layer 2: npm install│  150MB
├─────────────────────┤
│ Layer 1: node:18    │  200MB  ← 공유 (같은 레이어!)
└─────────────────────┘

총 저장 공간: 200 + 100 + 5 + 150 + 10 = 465MB
(Layer 1은 한 번만 저장됨!)
```

**레이어 캐싱의 이점**:

```bash
# 첫 번째 빌드
$ docker build -t myapp:v1 .
[1/4] FROM docker.io/library/node:18     # 다운로드 (200MB)
[2/4] COPY package.json .                 # 복사
[3/4] RUN npm install                     # 설치 (100MB, 2분 소요)
[4/4] COPY . .                            # 애플리케이션 복사

# 코드만 수정 후 재빌드
$ docker build -t myapp:v2 .
[1/4] FROM docker.io/library/node:18     # 캐시 사용 ✅
[2/4] COPY package.json .                 # 캐시 사용 ✅
[3/4] RUN npm install                     # 캐시 사용 ✅ (2분 절약!)
[4/4] COPY . .                            # 새로 복사 (변경됨)

→ 빌드 시간: 2분 → 5초
```

### Copy-on-Write (CoW) 전략

**개념**: "필요할 때만 복사"

```
초기 상태 (컨테이너 시작):
┌─────────────────────────────────────┐
│  Container Layer (읽기/쓰기)        │  비어있음
├─────────────────────────────────────┤
│  Image Layers (읽기 전용)           │
│  - /app/app.jar                     │
│  - /usr/bin/java                    │
│  - /etc/nginx/nginx.conf            │
└─────────────────────────────────────┘

파일 읽기:
1. /etc/nginx/nginx.conf 읽기 요청
2. 하위 레이어에서 찾음
3. 그대로 반환 (복사 없음)

파일 수정:
1. /etc/nginx/nginx.conf 수정 요청
2. 해당 파일을 컨테이너 레이어로 복사 (Copy-up)
3. 복사본을 수정
4. 이후 요청은 복사본 사용

┌─────────────────────────────────────┐
│  Container Layer (읽기/쓰기)        │
│  - /etc/nginx/nginx.conf (수정됨)   │  ← 새로 복사됨
├─────────────────────────────────────┤
│  Image Layers (읽기 전용)           │
│  - /etc/nginx/nginx.conf (원본)     │  ← 그대로 유지
└─────────────────────────────────────┘
```

**CoW 동작 확인**:

```bash
# 컨테이너 시작
$ docker run -it --name test ubuntu bash

# 컨테이너 내부에서 파일 수정
container$ echo "Hello" > /tmp/test.txt
container$ apt-get update && apt-get install -y vim

# 호스트에서 컨테이너 차이 확인
$ docker diff test

C /tmp
A /tmp/test.txt
C /var
C /var/lib
C /var/lib/apt
A /var/lib/apt/lists/...
A /usr/bin/vim

# C = Changed, A = Added, D = Deleted
```

### Union File System (OverlayFS)

**개념**: 여러 레이어를 하나로 합쳐서 보여주기

```
사용자 관점 (Merged View):
/
├── bin/
├── etc/
│   └── nginx/
│       └── nginx.conf  (수정된 버전)
├── usr/
└── app/
    └── app.jar

실제 저장 구조:
┌──────────────────────────────────────┐
│  Upper Dir (읽기/쓰기)               │
│  /var/lib/docker/overlay2/abc123/    │
│  - /etc/nginx/nginx.conf (수정됨)    │
└──────────────────────────────────────┘
              ↓ 통합 (Union)
┌──────────────────────────────────────┐
│  Lower Dirs (읽기 전용)              │
│  Layer 3: /app/app.jar               │
│  Layer 2: /usr/bin/java              │
│  Layer 1: /bin, /etc, /usr ...       │
└──────────────────────────────────────┘
              ↓
┌──────────────────────────────────────┐
│  Merged Dir (사용자가 보는 뷰)        │
│  모든 레이어가 합쳐진 완전한 파일시스템│
└──────────────────────────────────────┘
```

**OverlayFS 구조**:

```bash
# 실제 OverlayFS 마운트 확인
$ docker inspect container_id | grep -A 10 "GraphDriver"

"GraphDriver": {
    "Data": {
        "LowerDir": "/var/lib/docker/overlay2/l/ABC123:
                     /var/lib/docker/overlay2/l/DEF456:
                     /var/lib/docker/overlay2/l/GHI789",
        "MergedDir": "/var/lib/docker/overlay2/merged",
        "UpperDir": "/var/lib/docker/overlay2/upper",
        "WorkDir": "/var/lib/docker/overlay2/work"
    }
}
```

**디렉토리 역할**:
- **LowerDir**: 읽기 전용 이미지 레이어들 (여러 개)
- **UpperDir**: 읽기/쓰기 컨테이너 레이어 (1개)
- **MergedDir**: 모든 레이어가 합쳐진 뷰 (사용자가 보는 것)
- **WorkDir**: OverlayFS 내부 작업 디렉토리

**파일 검색 순서**:

```
파일 읽기 요청: /etc/nginx/nginx.conf

1. UpperDir 확인
   → 있으면 반환 (수정된 버전)

2. LowerDir 확인 (위에서 아래로)
   Layer 3 → Layer 2 → Layer 1
   → 있으면 반환 (원본)

3. 없으면 "파일 없음" 오류
```

### 레이어 최적화 전략

**나쁜 예 (레이어 많음)**:

```dockerfile
FROM ubuntu:20.04

RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y wget
RUN apt-get install -y vim
RUN apt-get install -y git

# 5개의 레이어 생성!
```

**좋은 예 (레이어 최소화)**:

```dockerfile
FROM ubuntu:20.04

RUN apt-get update && \
    apt-get install -y \
        curl \
        wget \
        vim \
        git && \
    rm -rf /var/lib/apt/lists/*

# 1개의 레이어만 생성!
```

**빌드 캐시 활용**:

```dockerfile
# 나쁜 예: 코드 변경 시 매번 npm install
FROM node:18
COPY . /app
WORKDIR /app
RUN npm install  # 코드 변경 시마다 재실행
CMD ["node", "index.js"]

# 좋은 예: package.json만 변경 시에만 npm install
FROM node:18
WORKDIR /app
COPY package*.json ./
RUN npm install  # package.json 변경 시에만 재실행
COPY . .
CMD ["node", "index.js"]
```

---

## 격리 기술과 생명주기

### 네임스페이스 (Namespace)

**개념**: 프로세스가 보는 "세계"를 분리

```
호스트 시스템:
┌───────────────────────────────────────┐
│         전체 시스템 뷰                 │
│  - 모든 프로세스 (PID 1~1000)         │
│  - 모든 네트워크 인터페이스            │
│  - 전체 파일시스템                    │
└───────────────────────────────────────┘

컨테이너 A (격리됨):
┌───────────────────────────────────────┐
│     컨테이너 A의 뷰                    │
│  - 자신의 프로세스만 (PID 1~10)       │
│  - 자신의 네트워크만 (eth0)           │
│  - 자신의 파일시스템만                │
└───────────────────────────────────────┘

컨테이너 B (격리됨):
┌───────────────────────────────────────┐
│     컨테이너 B의 뷰                    │
│  - 자신의 프로세스만 (PID 1~15)       │
│  - 자신의 네트워크만 (eth0)           │
│  - 자신의 파일시스템만                │
└───────────────────────────────────────┘
```

**리눅스 네임스페이스 종류**:

```
┌──────────────────┬──────────────────────────────────────┐
│  네임스페이스    │           격리 내용                   │
├──────────────────┼──────────────────────────────────────┤
│  PID             │  프로세스 ID                         │
│  (Process ID)    │  - 각 컨테이너는 독립적인 PID 1 보유  │
│                  │  - 다른 컨테이너의 프로세스 안 보임   │
├──────────────────┼──────────────────────────────────────┤
│  NET             │  네트워크                            │
│  (Network)       │  - 독립적인 네트워크 스택             │
│                  │  - 자체 IP 주소, 포트, 라우팅 테이블  │
├──────────────────┼──────────────────────────────────────┤
│  MNT             │  파일시스템 마운트                    │
│  (Mount)         │  - 독립적인 파일시스템 뷰             │
│                  │  - 다른 컨테이너의 파일 안 보임       │
├──────────────────┼──────────────────────────────────────┤
│  UTS             │  호스트명, 도메인명                   │
│  (Unix Timesharing)│ - 각 컨테이너는 자체 호스트명 보유   │
├──────────────────┼──────────────────────────────────────┤
│  IPC             │  프로세스 간 통신                     │
│  (Inter-Process  │  - 공유 메모리, 세마포어, 메시지 큐   │
│  Communication)  │  - 컨테이너 간 IPC 격리              │
├──────────────────┼──────────────────────────────────────┤
│  USER            │  사용자 및 그룹 ID                    │
│  (User)          │  - 컨테이너 내부 root ≠ 호스트 root  │
│                  │  - UID/GID 매핑                      │
├──────────────────┼──────────────────────────────────────┤
│  CGROUP          │  cgroup 계층 구조                     │
│  (Control Group) │  - 리소스 제한 격리                  │
└──────────────────┴──────────────────────────────────────┘
```

**PID 네임스페이스 예제**:

```bash
# 호스트에서 프로세스 확인
$ ps aux
USER   PID  COMMAND
root   1    /sbin/init
root   100  /usr/bin/dockerd
root   200  containerd
...
root   1234 nginx: master

# 컨테이너 내부에서 프로세스 확인
$ docker exec container_id ps aux
USER   PID  COMMAND
root   1    nginx: master      # 컨테이너 내부에서는 PID 1
root   7    nginx: worker
```

**실제로는**:
```
호스트 관점:
  PID 1234 = nginx (컨테이너 A)

컨테이너 A 관점:
  PID 1 = nginx (자기 자신)

→ 같은 프로세스, 다른 PID!
```

**네임스페이스 격리 확인**:

```bash
# 네임스페이스 확인
$ docker inspect container_id | grep Pid
"Pid": 12345

$ ls -la /proc/12345/ns/
lrwxrwxrwx 1 root root 0 net -> net:[4026532258]
lrwxrwxrwx 1 root root 0 pid -> pid:[4026532259]
lrwxrwxrwx 1 root root 0 mnt -> mnt:[4026532260]
lrwxrwxrwx 1 root root 0 uts -> uts:[4026532261]
lrwxrwxrwx 1 root root 0 ipc -> ipc:[4026532262]

# 호스트와 다른 네임스페이스 번호 = 격리됨!
```

### 컨트롤 그룹 (cgroups)

**개념**: 리소스 사용량 제한 및 모니터링

```
리소스 제한 없이:
┌────────────────────────────────────────┐
│         호스트 (8 CPU, 16GB RAM)        │
├────────────────────────────────────────┤
│  Container A: 사용량 제한 없음          │
│  → CPU 100% 사용 (8 코어 모두)         │
│  → 메모리 12GB 사용                    │
│  → 다른 컨테이너 영향 받음! ❌          │
└────────────────────────────────────────┘

cgroups로 제한:
┌────────────────────────────────────────┐
│         호스트 (8 CPU, 16GB RAM)        │
├────────────────────────────────────────┤
│  Container A: CPU 2코어, 메모리 2GB     │
│  → 최대 2 CPU만 사용 가능 ✅            │
│  → 최대 2GB만 사용 가능 ✅              │
│  → 다른 컨테이너 보호됨 ✅              │
└────────────────────────────────────────┘
```

**cgroups 제어 항목**:

```
┌──────────────────┬──────────────────────────────────────┐
│  cgroup 타입     │           제한 내용                   │
├──────────────────┼──────────────────────────────────────┤
│  cpu             │  CPU 사용 시간 제한                  │
│                  │  - cpu.shares (상대적 가중치)         │
│                  │  - cpu.cfs_quota_us (절대적 제한)    │
├──────────────────┼──────────────────────────────────────┤
│  cpuset          │  특정 CPU 코어 할당                  │
│                  │  - 코어 0,1만 사용하도록 제한         │
├──────────────────┼──────────────────────────────────────┤
│  memory          │  메모리 사용량 제한                  │
│                  │  - 최대 메모리                       │
│                  │  - 스왑 메모리                       │
│                  │  - OOM 동작 설정                     │
├──────────────────┼──────────────────────────────────────┤
│  blkio           │  블록 I/O (디스크) 제한               │
│                  │  - 읽기/쓰기 속도 제한               │
│                  │  - IOPS 제한                         │
├──────────────────┼──────────────────────────────────────┤
│  net_cls         │  네트워크 대역폭 제한                 │
│  net_prio        │  - 트래픽 우선순위                   │
├──────────────────┼──────────────────────────────────────┤
│  devices         │  장치 접근 제어                      │
│                  │  - /dev/ 장치 접근 허용/거부         │
└──────────────────┴──────────────────────────────────────┘
```

**리소스 제한 예제**:

```bash
# CPU 제한 (2 코어)
$ docker run -d --cpus="2.0" nginx

# 메모리 제한 (512MB)
$ docker run -d --memory="512m" nginx

# CPU와 메모리 동시 제한
$ docker run -d \
    --cpus="1.5" \
    --memory="1g" \
    --memory-swap="2g" \
    nginx

# 특정 CPU 코어 할당
$ docker run -d --cpuset-cpus="0,1" nginx

# 블록 I/O 제한 (읽기 속도)
$ docker run -d \
    --device-read-bps /dev/sda:10mb \
    nginx
```

**cgroup 확인**:

```bash
# 컨테이너 PID 확인
$ docker inspect --format '{{.State.Pid}}' container_id
12345

# cgroup 설정 확인
$ cat /sys/fs/cgroup/cpu/docker/container_id/cpu.cfs_quota_us
200000  # 2 CPU (100000 = 1 CPU)

$ cat /sys/fs/cgroup/memory/docker/container_id/memory.limit_in_bytes
1073741824  # 1GB
```

**리소스 사용량 모니터링**:

```bash
# 실시간 모니터링
$ docker stats

CONTAINER ID   NAME      CPU %   MEM USAGE / LIMIT   MEM %   NET I/O
a1b2c3d4e5f6   nginx     0.50%   50MiB / 512MiB      9.77%   1.2kB / 0B
```

### 컨테이너 생명주기

**전체 생명주기 다이어그램**:

```
                    docker create
                          ↓
┌──────────────────────────────────────────────────┐
│                   Created                        │
│  - 컨테이너 구성 완료                             │
│  - 파일시스템 준비됨                              │
│  - 프로세스 시작 안됨                             │
└──────────────────────────────────────────────────┘
                    docker start
                          ↓
┌──────────────────────────────────────────────────┐
│                   Running                        │
│  - 프로세스 실행 중                               │
│  - 리소스 사용 중                                │
└──────────────────────────────────────────────────┘
         ↓                           ↑
    docker pause              docker unpause
         ↓                           ↑
┌──────────────────────────────────────────────────┐
│                   Paused                         │
│  - 프로세스 일시정지 (SIGSTOP)                    │
│  - 메모리 유지, CPU 사용 안함                     │
└──────────────────────────────────────────────────┘
                    docker stop
                 or docker kill
                          ↓
┌──────────────────────────────────────────────────┐
│                   Stopped                        │
│  - 프로세스 종료됨                                │
│  - 파일시스템 유지됨                              │
│  - 재시작 가능                                   │
└──────────────────────────────────────────────────┘
                    docker rm
                          ↓
┌──────────────────────────────────────────────────┐
│                   Removed                        │
│  - 컨테이너 완전 삭제                             │
│  - 파일시스템 삭제됨                              │
│  - 복구 불가능                                   │
└──────────────────────────────────────────────────┘
```

**각 상태 상세 설명**:

#### 1. Created (생성됨)

```bash
# 컨테이너 생성 (시작 안함)
$ docker create --name my-nginx nginx

# 상태 확인
$ docker ps -a
CONTAINER ID   STATUS    NAMES
a1b2c3d4e5f6   Created   my-nginx

# 내부적으로 일어나는 일:
# - 이미지에서 컨테이너 레이어 생성
# - 네트워크 설정 준비
# - 볼륨 마운트 준비
# - 메타데이터 저장
# ❌ 프로세스 시작 안됨!
```

#### 2. Running (실행 중)

```bash
# 컨테이너 시작
$ docker start my-nginx

# 또는 생성과 동시에 시작
$ docker run -d --name my-nginx nginx

# 상태 확인
$ docker ps
CONTAINER ID   STATUS         NAMES
a1b2c3d4e5f6   Up 10 seconds  my-nginx

# 내부적으로 일어나는 일:
# - runc가 컨테이너 프로세스 시작
# - 네임스페이스 생성 및 격리
# - cgroups 적용
# - 네트워크 연결
# - CMD/ENTRYPOINT 실행
```

#### 3. Paused (일시정지)

```bash
# 컨테이너 일시정지
$ docker pause my-nginx

# 상태 확인
$ docker ps
CONTAINER ID   STATUS                  NAMES
a1b2c3d4e5f6   Up 1 minute (Paused)    my-nginx

# 내부적으로 일어나는 일:
# - 모든 프로세스에 SIGSTOP 시그널 전송
# - CPU 스케줄링에서 제외
# - 메모리는 그대로 유지
# - 네트워크 연결 유지 (응답 안함)

# 재개
$ docker unpause my-nginx
```

**Pause vs Stop 비교**:

```
Pause:
- 메모리 유지 ✅
- 빠른 재개 ✅ (밀리초)
- 리소스 점유 (메모리)

Stop:
- 메모리 해제 ✅
- 느린 재시작 (수 초)
- 리소스 완전 해제
```

#### 4. Stopped (중지됨)

```bash
# 정상 종료 (SIGTERM → 10초 대기 → SIGKILL)
$ docker stop my-nginx

# 강제 종료 (SIGKILL)
$ docker kill my-nginx

# 상태 확인
$ docker ps -a
CONTAINER ID   STATUS                     NAMES
a1b2c3d4e5f6   Exited (0) 5 seconds ago   my-nginx

# 내부적으로 일어나는 일 (stop):
# 1. 컨테이너 메인 프로세스에 SIGTERM 전송
# 2. 10초 대기 (Graceful Shutdown)
# 3. 여전히 실행 중이면 SIGKILL 전송
# 4. 프로세스 종료
# 5. 네트워크 연결 해제
# 6. 컨테이너 레이어는 유지 (재시작 가능)
```

**Exit Code 확인**:

```bash
$ docker ps -a
CONTAINER ID   STATUS                   NAMES
a1b2c3d4e5f6   Exited (0) 1 min ago     my-nginx  # 정상 종료
b2c3d4e5f6a1   Exited (137) 2 min ago   my-app    # SIGKILL (강제 종료)
c3d4e5f6a1b2   Exited (1) 3 min ago     my-db     # 애플리케이션 오류

# Exit Code 의미:
# 0   : 정상 종료
# 1   : 애플리케이션 오류
# 137 : SIGKILL (128 + 9)
# 143 : SIGTERM (128 + 15)
```

#### 5. Removed (삭제됨)

```bash
# 컨테이너 삭제 (중지된 컨테이너만 가능)
$ docker rm my-nginx

# 실행 중인 컨테이너 강제 삭제
$ docker rm -f my-nginx

# 내부적으로 일어나는 일:
# - 컨테이너 레이어 삭제
# - 네트워크 설정 삭제
# - 메타데이터 삭제
# - 볼륨은 유지 (명시적으로 삭제하지 않는 한)
```

**자동 삭제 옵션**:

```bash
# 종료 시 자동 삭제
$ docker run --rm nginx

# 컨테이너 종료 → 자동으로 삭제됨
```

### 생명주기 관리 명령어

```bash
# 생성 및 시작
$ docker run -d --name app nginx        # 생성 + 시작
$ docker create --name app nginx        # 생성만
$ docker start app                      # 시작

# 중지 및 재시작
$ docker stop app                       # 정상 종료
$ docker kill app                       # 강제 종료
$ docker restart app                    # 재시작

# 일시정지
$ docker pause app                      # 일시정지
$ docker unpause app                    # 재개

# 삭제
$ docker rm app                         # 삭제
$ docker rm -f app                      # 강제 삭제

# 상태 확인
$ docker ps                             # 실행 중인 컨테이너
$ docker ps -a                          # 모든 컨테이너
$ docker inspect app                    # 상세 정보
$ docker logs app                       # 로그 확인
$ docker top app                        # 프로세스 확인
$ docker stats app                      # 리소스 사용량
```

### 재시작 정책

```bash
# 재시작 정책 설정
$ docker run -d --restart=no nginx          # 재시작 안함 (기본값)
$ docker run -d --restart=on-failure nginx  # 실패 시에만 재시작
$ docker run -d --restart=always nginx      # 항상 재시작
$ docker run -d --restart=unless-stopped nginx  # 명시적 중지 제외하고 재시작
```

**재시작 정책 비교**:

```
┌─────────────────┬──────────┬──────────┬──────────┬──────────┐
│                 │    no    │on-failure│  always  │  unless- │
│                 │          │          │          │ stopped  │
├─────────────────┼──────────┼──────────┼──────────┼──────────┤
│ 애플리케이션    │    X     │    O     │    O     │    O     │
│ 오류 시         │          │          │          │          │
├─────────────────┼──────────┼──────────┼──────────┼──────────┤
│ Docker          │    X     │    X     │    O     │    O     │
│ 재시작 시       │          │          │          │          │
├─────────────────┼──────────┼──────────┼──────────┼──────────┤
│ docker stop     │    X     │    X     │    O     │    X     │
│ 실행 후         │          │          │          │          │
│ Docker 재시작   │          │          │          │          │
└─────────────────┴──────────┴──────────┴──────────┴──────────┘
```

**실전 예제**:

```bash
# 프로덕션 데이터베이스 (항상 재시작)
$ docker run -d \
    --name postgres \
    --restart=always \
    -e POSTGRES_PASSWORD=secret \
    postgres:15

# 개발 환경 (재시작 안함)
$ docker run -d \
    --name dev-app \
    --restart=no \
    myapp:dev

# 배치 작업 (실패 시에만 재시작, 최대 3회)
$ docker run -d \
    --name batch-job \
    --restart=on-failure:3 \
    batch-processor
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: "Dockerfile이 매번 너무 오래 걸려요"

**상황**: 주니어 개발자가 Dockerfile을 작성했는데 매번 빌드할 때마다 10분씩 걸립니다.

```dockerfile
# ❌ 주니어 개발자가 작성한 코드
FROM node:18

COPY . /app
WORKDIR /app

RUN npm install
RUN npm run build

CMD ["npm", "start"]
```

**문제점**:
- 문제 1: 소스 코드가 변경될 때마다 npm install이 다시 실행됨
- 문제 2: 레이어 캐싱을 전혀 활용하지 못함
- 문제 3: package.json이 변경되지 않아도 매번 의존성 재설치
- 왜 이 문제가 발생하는가: Docker의 레이어 캐싱 메커니즘을 이해하지 못함

**해결책**:
```dockerfile
# ✅ 올바른 코드
FROM node:18

WORKDIR /app

# 1. package.json과 package-lock.json만 먼저 복사
COPY package*.json ./

# 2. 의존성 설치 (이 레이어는 package.json이 변경될 때만 재빌드)
RUN npm install

# 3. 소스 코드 복사 (자주 변경됨)
COPY . .

# 4. 빌드
RUN npm run build

CMD ["npm", "start"]

# 설명
# 1. package.json이 변경되지 않으면 npm install 레이어 캐시 사용
# 2. 소스 코드만 변경되면 COPY . . 이후만 재빌드
# 3. 빌드 시간: 10분 → 30초로 단축
```

**배운 점**:
- 💡 자주 변경되지 않는 것을 먼저 COPY
- 💡 각 RUN 명령은 새 레이어를 생성
- 💡 레이어 캐싱으로 빌드 시간 95% 단축 가능

---

### 시나리오 2: "컨테이너가 갑자기 멈췄어요!"

**상황**: 프로덕션에서 컨테이너가 자꾸 종료되고, 로그에 "Killed" 메시지만 보입니다.

```bash
# ❌ 메모리 제한 없이 실행한 컨테이너
$ docker run -d myapp

# 로그 확인
$ docker logs container_id
Application started...
Loading data...
Processing...
Killed
```

**문제점**:
- 문제 1: 메모리 제한을 설정하지 않음
- 문제 2: 애플리케이션이 메모리를 과도하게 사용
- 문제 3: OOM Killer가 컨테이너 프로세스를 강제 종료
- 왜 이 문제가 발생하는가: cgroups를 이해하지 못하고 리소스 제한 없이 실행

**해결책**:
```bash
# ✅ 올바른 방법: 메모리 제한 설정
$ docker run -d \
    --name myapp \
    --memory="512m" \
    --memory-swap="1g" \
    --cpus="1.0" \
    myapp

# 리소스 사용량 모니터링
$ docker stats myapp

CONTAINER   CPU %   MEM USAGE / LIMIT   MEM %
myapp       25%     400MB / 512MB       78%

# 메모리 사용량 초과 시 경고 설정
$ docker run -d \
    --name myapp \
    --memory="512m" \
    --memory-reservation="256m" \
    --oom-kill-disable=false \
    myapp
```

**배운 점**:
- 💡 항상 메모리와 CPU 제한 설정
- 💡 docker stats로 실시간 모니터링
- 💡 메모리 사용량이 지속적으로 증가하면 메모리 누수 의심

---

### 시나리오 3: "여러 컨테이너가 서로 통신이 안 돼요"

**상황**: 웹 서버와 데이터베이스를 각각 컨테이너로 실행했는데 연결이 안 됩니다.

```bash
# ❌ 네트워크 설정 없이 실행
$ docker run -d --name db postgres
$ docker run -d --name web -p 80:80 myapp

# 웹 앱 로그
$ docker logs web
Error: Cannot connect to database at localhost:5432
```

**문제점**:
- 문제 1: 각 컨테이너가 독립된 네트워크 네임스페이스에 있음
- 문제 2: localhost는 컨테이너 내부만 가리킴
- 문제 3: 컨테이너 간 통신을 위한 네트워크 설정 누락
- 왜 이 문제가 발생하는가: 네트워크 네임스페이스 격리를 이해하지 못함

**해결책**:
```bash
# ✅ 올바른 방법: 사용자 정의 네트워크 생성
# 1. 네트워크 생성
$ docker network create myapp-network

# 2. 데이터베이스를 네트워크에 연결하여 실행
$ docker run -d \
    --name db \
    --network myapp-network \
    -e POSTGRES_PASSWORD=secret \
    postgres

# 3. 웹 앱도 같은 네트워크에 연결
$ docker run -d \
    --name web \
    --network myapp-network \
    -p 80:80 \
    -e DB_HOST=db \
    -e DB_PORT=5432 \
    myapp

# 4. 연결 테스트
$ docker exec web ping db
PING db (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: icmp_seq=0 ttl=64 time=0.123 ms

# 애플리케이션에서는 'db'라는 호스트명으로 접근
# const client = new Client({
#   host: 'db',  // 컨테이너 이름으로 자동 DNS 해석
#   port: 5432,
# });
```

**배운 점**:
- 💡 컨테이너 간 통신에는 사용자 정의 네트워크 사용
- 💡 같은 네트워크의 컨테이너는 이름으로 통신 가능
- 💡 localhost는 컨테이너 내부만 가리킴

---

### 시나리오 4: "컨테이너를 삭제했는데 데이터가 다 날아갔어요!"

**상황**: 테스트를 위해 컨테이너를 삭제했다가 중요한 데이터베이스 데이터를 모두 잃었습니다.

```bash
# ❌ 볼륨 없이 데이터베이스 실행
$ docker run -d --name db postgres

# 데이터 입력
$ docker exec -it db psql -U postgres
postgres=# CREATE TABLE users (...);
postgres=# INSERT INTO users VALUES (...);

# 컨테이너 삭제
$ docker rm -f db

# 데이터 완전 손실! 😱
```

**문제점**:
- 문제 1: 컨테이너 레이어에 데이터 저장
- 문제 2: 컨테이너 삭제 시 데이터도 함께 삭제됨
- 문제 3: 볼륨을 사용하지 않음
- 왜 이 문제가 발생하는가: 컨테이너의 임시성과 볼륨의 영속성을 이해하지 못함

**해결책**:
```bash
# ✅ 올바른 방법: 볼륨 사용
# 1. 볼륨 생성
$ docker volume create db-data

# 2. 볼륨을 마운트하여 데이터베이스 실행
$ docker run -d \
    --name db \
    -v db-data:/var/lib/postgresql/data \
    -e POSTGRES_PASSWORD=secret \
    postgres

# 3. 데이터 입력
$ docker exec -it db psql -U postgres
postgres=# CREATE TABLE users (...);
postgres=# INSERT INTO users VALUES (...);

# 4. 컨테이너 삭제해도 데이터는 볼륨에 보존됨
$ docker rm -f db

# 5. 같은 볼륨으로 새 컨테이너 시작
$ docker run -d \
    --name db-new \
    -v db-data:/var/lib/postgresql/data \
    -e POSTGRES_PASSWORD=secret \
    postgres

# 6. 데이터가 그대로 남아있음! ✅
$ docker exec -it db-new psql -U postgres
postgres=# SELECT * FROM users;
(모든 데이터 보존됨)

# 볼륨 확인
$ docker volume ls
DRIVER    VOLUME NAME
local     db-data

$ docker volume inspect db-data
[
    {
        "Name": "db-data",
        "Mountpoint": "/var/lib/docker/volumes/db-data/_data"
    }
]
```

**배운 점**:
- 💡 데이터는 항상 볼륨에 저장
- 💡 컨테이너는 언제든 삭제될 수 있는 임시 객체
- 💡 볼륨은 컨테이너와 독립적으로 존재

---

## ❓ FAQ

<details>
<summary><strong>Q1: 컨테이너와 VM의 가장 큰 차이점은 무엇인가요?</strong></summary>

**A**: VM은 독립적인 OS를 포함하지만, 컨테이너는 호스트 OS의 커널을 공유합니다.

**상세 설명**:
- VM: 하이퍼바이저 위에 완전한 Guest OS를 실행 (무겁고 느림)
- 컨테이너: 호스트 커널을 공유하고 프로세스 레벨에서만 격리 (가볍고 빠름)
- VM은 분 단위 시작, 컨테이너는 초 단위 시작
- VM은 GB 단위 크기, 컨테이너는 MB 단위 크기

**예시**:
```bash
# VM 시작 (VirtualBox)
$ time VBoxManage startvm "Ubuntu-VM"
real    1m23s  # 1분 23초

# 컨테이너 시작
$ time docker run nginx
real    0m2s   # 2초
```

**실무 팁**:
💡 마이크로서비스에는 컨테이너, 다른 OS가 필요하면 VM을 사용하세요.

</details>

<details>
<summary><strong>Q2: Dockerfile의 각 명령어가 레이어를 만드나요?</strong></summary>

**A**: RUN, COPY, ADD 명령어만 새로운 레이어를 생성합니다.

**상세 설명**:
- 레이어 생성: FROM, RUN, COPY, ADD
- 메타데이터만 변경: CMD, ENTRYPOINT, ENV, EXPOSE, LABEL, WORKDIR
- 레이어가 많을수록 이미지가 커지고 빌드가 느려짐
- RUN 명령어는 &&로 체이닝하여 하나의 레이어로 통합 권장

**예시**:
```dockerfile
# ❌ 나쁜 예: 5개의 레이어 생성
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y wget
RUN apt-get install -y vim
RUN rm -rf /var/lib/apt/lists/*

# ✅ 좋은 예: 1개의 레이어만 생성
RUN apt-get update && \
    apt-get install -y curl wget vim && \
    rm -rf /var/lib/apt/lists/*
```

**실무 팁**:
💡 docker history 명령어로 각 레이어의 크기를 확인할 수 있습니다.

</details>

<details>
<summary><strong>Q3: 컨테이너가 Killed 되는 이유는 무엇인가요?</strong></summary>

**A**: 대부분 메모리 부족으로 인한 OOM Killer의 개입입니다.

**상세 설명**:
- OOM (Out Of Memory) Killer: 메모리 부족 시 프로세스를 강제 종료
- 메모리 제한을 설정하지 않으면 호스트 전체 메모리를 사용할 수 있음
- Exit code 137 = SIGKILL (OOM Killer에 의한 강제 종료)

**예시**:
```bash
# 문제 확인
$ docker inspect container_id | grep OOMKilled
"OOMKilled": true

$ docker ps -a
CONTAINER ID   STATUS
abc123         Exited (137) 2 minutes ago   # 137 = OOM

# 해결: 메모리 제한 설정
$ docker run -d --memory="512m" --name myapp myapp
```

**실무 팁**:
💡 프로덕션에서는 항상 메모리 제한을 설정하고 모니터링하세요.

</details>

<details>
<summary><strong>Q4: 이미지 레이어는 어디에 저장되나요?</strong></summary>

**A**: Linux는 /var/lib/docker/, Windows는 C:\ProgramData\Docker\에 저장됩니다.

**상세 설명**:
- Linux: /var/lib/docker/overlay2/ (OverlayFS 사용)
- Windows: C:\ProgramData\Docker\windowsfilter\
- Mac: Docker Desktop의 VM 내부 (/var/lib/docker/)
- 각 레이어는 SHA256 해시로 식별됨

**예시**:
```bash
# Linux에서 확인
$ sudo ls /var/lib/docker/overlay2/
abc123def456/
def456ghi789/
...

# 이미지 레이어 확인
$ docker inspect nginx:latest | grep "Layers" -A 10
"Layers": [
    "sha256:abc123...",
    "sha256:def456...",
    "sha256:ghi789..."
]
```

**실무 팁**:
💡 디스크 공간이 부족하면 docker system prune으로 사용하지 않는 레이어를 삭제하세요.

</details>

<details>
<summary><strong>Q5: pause와 stop의 차이는 무엇인가요?</strong></summary>

**A**: pause는 메모리를 유지하고 CPU만 중단, stop은 프로세스를 완전히 종료합니다.

**상세 설명**:
- **pause**: 프로세스에 SIGSTOP 전송, 메모리는 그대로, CPU 스케줄링에서만 제외
- **stop**: 프로세스에 SIGTERM 전송 → 10초 대기 → SIGKILL, 메모리 해제
- pause는 밀리초 단위로 재개 가능
- stop은 수 초 단위로 재시작 필요

**예시**:
```bash
# Pause/Unpause (매우 빠름)
$ time docker pause myapp
real    0m0.05s

$ time docker unpause myapp
real    0m0.03s

# Stop/Start (느림)
$ time docker stop myapp
real    0m10.5s  # graceful shutdown 대기

$ time docker start myapp
real    0m2.3s   # 프로세스 재시작
```

**실무 팁**:
💡 디버깅이나 점검 시 pause를 사용하면 빠르게 재개할 수 있습니다.

</details>

<details>
<summary><strong>Q6: 네임스페이스가 정확히 무엇을 격리하나요?</strong></summary>

**A**: PID, 네트워크, 파일시스템, 호스트명, IPC, 사용자 등을 격리합니다.

**상세 설명**:
- **PID 네임스페이스**: 각 컨테이너는 독립적인 PID 1을 가짐
- **NET 네임스페이스**: 독립적인 네트워크 스택 (IP, 포트, 라우팅)
- **MNT 네임스페이스**: 독립적인 파일시스템 뷰
- **UTS 네임스페이스**: 독립적인 호스트명과 도메인명
- **IPC 네임스페이스**: 공유 메모리, 세마포어, 메시지 큐 격리
- **USER 네임스페이스**: UID/GID 매핑

**예시**:
```bash
# 컨테이너 내부에서 ps
$ docker exec myapp ps aux
USER   PID  COMMAND
root   1    nginx   # 컨테이너 내부에서는 PID 1

# 호스트에서 같은 프로세스 확인
$ ps aux | grep nginx
root   12345  nginx  # 호스트에서는 PID 12345

# 같은 프로세스, 다른 PID!
```

**실무 팁**:
💡 보안을 위해 USER 네임스페이스를 활성화하여 컨테이너 내부 root가 호스트 root가 아니도록 설정하세요.

</details>

<details>
<summary><strong>Q7: Copy-on-Write는 정확히 언제 발생하나요?</strong></summary>

**A**: 컨테이너가 읽기 전용 이미지 레이어의 파일을 수정하려고 할 때 발생합니다.

**상세 설명**:
- **읽기 작업**: 레이어에서 바로 읽음 (복사 없음)
- **쓰기 작업**: 해당 파일을 컨테이너 레이어로 복사한 후 수정 (Copy-up)
- **삭제 작업**: whiteout 파일 생성 (실제 삭제는 안 함)
- 처음 수정 시에만 복사, 이후는 복사본 수정

**예시**:
```bash
# 컨테이너 시작 (초기 상태)
$ docker run -it --name test ubuntu bash

# 읽기: 복사 없음
container$ cat /etc/hosts
127.0.0.1   localhost

# 쓰기: Copy-on-Write 발생
container$ echo "test" >> /etc/hosts

# 호스트에서 변경 확인
$ docker diff test
C /etc
C /etc/hosts  # Changed

# 컨테이너 레이어 크기 확인
$ docker ps -s
CONTAINER   SIZE
test        12B (virtual 72.8MB)
            ↑ 컨테이너 레이어 크기 (수정된 파일만)
```

**실무 팁**:
💡 대용량 파일을 컨테이너에서 수정하면 Copy-up으로 인해 성능이 저하될 수 있으니 볼륨을 사용하세요.

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용 (7개)

<details>
<summary><strong>1. 컨테이너와 가상머신(VM)의 차이점을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- VM은 하이퍼바이저 위에 완전한 Guest OS를 실행
- 컨테이너는 호스트 OS의 커널을 공유하고 프로세스 레벨에서만 격리
- VM은 무겁고 느리지만 강력한 격리, 컨테이너는 가볍고 빠르지만 커널 공유
- 시작 시간: VM은 분 단위, 컨테이너는 초 단위

**예시 답변**
> "가상머신은 하이퍼바이저 위에서 완전한 운영체제를 실행하기 때문에 무겁고 시작하는 데 1~5분 정도 걸립니다. 반면 Docker 컨테이너는 호스트 운영체제의 커널을 공유하고 네임스페이스와 cgroups로 프로세스만 격리하기 때문에 훨씬 가볍고 1~3초 안에 시작할 수 있습니다. 예를 들어 VM은 GB 단위의 크기이지만 컨테이너는 MB 단위입니다."

**꼬리 질문**
- Q: 그렇다면 컨테이너가 VM보다 항상 좋은가요?
- A: 아닙니다. 다른 OS가 필요하거나 매우 강력한 격리가 필요한 경우에는 VM이 적합합니다. 컨테이너는 같은 OS에서 여러 애플리케이션을 격리하는 데 적합합니다.

**실무 연관**
- 마이크로서비스 아키텍처에서는 컨테이너 사용
- 레거시 시스템이나 다른 OS가 필요한 경우 VM 사용
- AWS ECS, Kubernetes 등은 컨테이너 기반

</details>

<details>
<summary><strong>2. Docker 이미지의 레이어 구조에 대해 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 이미지는 여러 읽기 전용 레이어로 구성
- Dockerfile의 각 RUN, COPY, ADD 명령이 새 레이어 생성
- 레이어는 재사용 가능하여 저장 공간과 빌드 시간 절약
- 컨테이너 실행 시 읽기/쓰기 레이어가 최상단에 추가됨

**예시 답변**
> "Docker 이미지는 여러 개의 읽기 전용 레이어가 쌓인 구조입니다. Dockerfile의 FROM 명령부터 시작해서 각 RUN, COPY, ADD 명령이 실행될 때마다 새로운 레이어가 생성됩니다. 예를 들어 ubuntu 베이스 이미지 위에 apt-get update 레이어, 패키지 설치 레이어, 애플리케이션 파일 복사 레이어가 차례로 쌓입니다. 이 레이어들은 재사용되기 때문에 여러 이미지가 같은 베이스를 사용하면 저장 공간을 절약할 수 있습니다."

**꼬리 질문**
- Q: 레이어 캐싱은 어떻게 활용하나요?
- A: 자주 변경되지 않는 명령을 Dockerfile 앞쪽에 배치합니다. 예를 들어 package.json 복사와 npm install을 소스 코드 복사보다 먼저 하면, 소스만 변경될 때 의존성 설치를 건너뛸 수 있습니다.

**실무 연관**
- Dockerfile 작성 시 레이어 순서 최적화로 빌드 시간 단축
- 불필요한 레이어 생성을 피하기 위해 RUN 명령 체이닝 (&&)
- .dockerignore로 불필요한 파일 제외

</details>

<details>
<summary><strong>3. Docker의 네임스페이스와 cgroups는 무엇이며 어떤 역할을 하나요?</strong></summary>

**모범 답안 포인트**
- 네임스페이스: 프로세스가 보는 "세계"를 격리 (PID, NET, MNT, UTS, IPC, USER)
- cgroups: 리소스 사용량 제한 및 모니터링 (CPU, 메모리, I/O)
- 네임스페이스로 격리, cgroups로 리소스 제어
- 두 기술이 합쳐져 컨테이너 격리 실현

**예시 답변**
> "네임스페이스는 컨테이너가 보는 시스템 자원을 격리하는 기술입니다. 예를 들어 PID 네임스페이스로 각 컨테이너는 독립적인 프로세스 목록을 보고, 네트워크 네임스페이스로 독립적인 네트워크 스택을 가집니다. cgroups는 컨테이너가 사용할 수 있는 리소스를 제한하는 기술입니다. CPU를 2코어로 제한하거나 메모리를 512MB로 제한할 수 있습니다. 이 두 기술이 합쳐져서 안전하고 효율적인 컨테이너 격리가 가능해집니다."

**꼬리 질문**
- Q: 리소스 제한을 하지 않으면 어떤 문제가 생기나요?
- A: 한 컨테이너가 호스트의 모든 메모리나 CPU를 사용해서 다른 컨테이너나 호스트 시스템에 영향을 줄 수 있습니다. OOM Killer가 프로세스를 강제 종료할 수도 있습니다.

**실무 연관**
- 프로덕션에서는 반드시 메모리와 CPU 제한 설정
- Kubernetes의 requests/limits도 cgroups 기반
- 모니터링 도구로 리소스 사용량 추적

</details>

<details>
<summary><strong>4. Copy-on-Write(CoW) 전략이 무엇인지 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 읽기 전용 레이어의 파일을 수정할 때만 복사
- 읽기 작업은 복사 없이 바로 수행 (효율적)
- 쓰기 작업 시 파일을 컨테이너 레이어로 복사 후 수정 (Copy-up)
- 메모리와 저장 공간 절약

**예시 답변**
> "Copy-on-Write는 '필요할 때만 복사'하는 전략입니다. 컨테이너가 시작되면 이미지의 읽기 전용 레이어를 그대로 사용합니다. 파일을 읽기만 할 때는 복사 없이 바로 읽습니다. 하지만 파일을 수정하려고 하면 그때 해당 파일을 컨테이너 레이어로 복사한 후 수정합니다. 이렇게 하면 여러 컨테이너가 같은 이미지를 공유하면서도 각자 독립적으로 동작할 수 있고, 메모리와 디스크 공간도 절약됩니다."

**꼬리 질문**
- Q: 대용량 파일을 컨테이너에서 수정하면 어떻게 되나요?
- A: Copy-up으로 인해 전체 파일이 컨테이너 레이어로 복사되므로 성능이 저하됩니다. 이런 경우 볼륨을 사용하는 것이 좋습니다.

**실무 연관**
- 데이터베이스 데이터는 반드시 볼륨에 저장
- 로그 파일도 볼륨 사용 권장
- docker diff로 변경 사항 확인 가능

</details>

<details>
<summary><strong>5. Docker 컨테이너의 생명주기(Created, Running, Paused, Stopped, Removed)를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- Created: 컨테이너 생성되었지만 프로세스는 시작 안됨
- Running: 프로세스 실행 중
- Paused: 프로세스 일시정지 (메모리 유지)
- Stopped: 프로세스 종료 (메모리 해제)
- Removed: 컨테이너 완전 삭제

**예시 답변**
> "Docker 컨테이너는 5가지 상태를 가집니다. Created는 docker create로 컨테이너를 생성했지만 아직 시작하지 않은 상태입니다. Running은 docker start나 docker run으로 프로세스가 실행 중인 상태입니다. Paused는 docker pause로 일시정지한 상태로 메모리는 그대로 있지만 CPU는 사용하지 않습니다. Stopped는 docker stop으로 프로세스가 종료된 상태이고, Removed는 docker rm으로 완전히 삭제된 상태입니다."

**꼬리 질문**
- Q: Paused와 Stopped의 차이는 무엇인가요?
- A: Paused는 메모리를 유지하고 빠르게 재개할 수 있지만, Stopped는 메모리가 해제되고 재시작에 시간이 걸립니다.

**실무 연관**
- 프로덕션에서는 --restart 정책 설정
- 컨테이너 상태 모니터링 필수
- docker ps -a로 모든 컨테이너 상태 확인

</details>

<details>
<summary><strong>6. Docker Daemon, containerd, runc의 역할을 각각 설명해주세요.</strong></summary>

**모범 답안 포인트**
- Docker Daemon (dockerd): API 제공, 이미지/컨테이너/네트워크 관리
- containerd: 고수준 컨테이너 런타임, 이미지 전송 및 저장
- runc: 저수준 런타임, 실제 컨테이너 프로세스 실행

**예시 답변**
> "Docker는 세 가지 주요 컴포넌트로 구성됩니다. Docker Daemon은 REST API를 제공하고 이미지, 컨테이너, 네트워크, 볼륨을 관리하는 핵심 서비스입니다. containerd는 이미지를 다운로드하고 저장하며 컨테이너 생명주기를 관리하는 고수준 런타임입니다. runc는 OCI 표준을 따르는 저수준 런타임으로 실제로 네임스페이스와 cgroups를 설정하고 컨테이너 프로세스를 실행합니다. docker run을 실행하면 dockerd가 containerd를 호출하고, containerd가 runc를 호출해서 최종적으로 컨테이너가 실행됩니다."

**꼬리 질문**
- Q: 왜 이렇게 여러 단계로 나뉘어 있나요?
- A: 모듈화를 통해 각 컴포넌트를 독립적으로 개발하고 테스트할 수 있고, Kubernetes 같은 다른 시스템도 containerd를 직접 사용할 수 있습니다.

**실무 연관**
- Kubernetes는 dockerd를 거치지 않고 containerd를 직접 사용
- 문제 발생 시 각 컴포넌트의 로그 확인 필요
- ctr, crictl 같은 저수준 도구 활용

</details>

<details>
<summary><strong>7. 컨테이너 간 통신은 어떻게 이루어지나요?</strong></summary>

**모범 답안 포인트**
- 기본적으로 각 컨테이너는 독립된 네트워크 네임스페이스에 있음
- 사용자 정의 네트워크를 생성하여 연결
- 같은 네트워크의 컨테이너는 이름으로 통신 가능 (DNS)
- 브리지, 호스트, 오버레이 등 다양한 네트워크 드라이버

**예시 답변**
> "기본적으로 각 컨테이너는 독립된 네트워크 네임스페이스에 있어서 서로 통신할 수 없습니다. 컨테이너 간 통신을 위해서는 사용자 정의 네트워크를 생성하고 컨테이너들을 같은 네트워크에 연결해야 합니다. 같은 네트워크에 있는 컨테이너들은 컨테이너 이름으로 서로를 찾을 수 있습니다. 예를 들어 'web'과 'db' 컨테이너가 같은 네트워크에 있으면 web 컨테이너에서 'db:5432'로 데이터베이스에 접근할 수 있습니다."

**꼬리 질문**
- Q: localhost로는 왜 접근이 안 되나요?
- A: 각 컨테이너의 localhost는 자기 자신만 가리킵니다. 네트워크 네임스페이스가 격리되어 있기 때문입니다.

**실무 연관**
- Docker Compose에서 자동으로 네트워크 생성
- 마이크로서비스 간 통신에 필수
- 서비스 디스커버리와 로드 밸런싱

</details>

---

### 📗 중급 개발자용 (5개)

<details>
<summary><strong>1. Union File System(OverlayFS)의 동작 원리를 상세히 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 여러 레이어를 하나의 파일시스템으로 통합하는 기술
- LowerDir (읽기 전용), UpperDir (읽기/쓰기), MergedDir (통합 뷰), WorkDir (작업 공간)
- 파일 검색 순서: Upper → Lower (위에서 아래로)
- whiteout 파일로 삭제 표현

**예시 답변**
> "OverlayFS는 여러 레이어를 하나로 합쳐서 보여주는 Union File System입니다. LowerDir은 읽기 전용 이미지 레이어들이고, UpperDir은 읽기/쓰기가 가능한 컨테이너 레이어입니다. 사용자는 MergedDir을 통해 모든 레이어가 합쳐진 완전한 파일시스템을 봅니다. 파일을 찾을 때는 먼저 UpperDir을 확인하고, 없으면 LowerDir을 위에서 아래로 순차적으로 확인합니다. 파일을 삭제하면 실제로 삭제되지 않고 UpperDir에 whiteout 파일이 생성되어 해당 파일이 보이지 않게 됩니다."

**실무 예시**
```bash
# OverlayFS 마운트 정보 확인
$ docker inspect container_id | grep -A 10 "GraphDriver"
"LowerDir": "/var/lib/docker/overlay2/l/ABC:../l/DEF",
"UpperDir": "/var/lib/docker/overlay2/xyz/diff",
"MergedDir": "/var/lib/docker/overlay2/xyz/merged",
"WorkDir": "/var/lib/docker/overlay2/xyz/work"
```

**꼬리 질문**
- Q: AUFS, Btrfs 등 다른 스토리지 드라이버와의 차이는?
- A: OverlayFS가 성능이 더 좋고 커널에 기본 포함되어 있어 가장 널리 사용됩니다. AUFS는 레거시이고, Btrfs는 스냅샷 기능은 좋지만 성능이 떨어집니다.

**실무 연관**
- 스토리지 드라이버 선택은 성능에 큰 영향
- 프로덕션 환경에서는 overlay2 권장
- /var/lib/docker 디스크 모니터링 필수

</details>

<details>
<summary><strong>2. Docker의 네트워크 모드(bridge, host, none, overlay)의 차이와 사용 사례를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- bridge: 기본 모드, docker0 브리지 통해 NAT
- host: 호스트 네트워크 직접 사용, 최고 성능
- none: 네트워크 없음, 완전 격리
- overlay: 멀티 호스트 통신, Swarm/Kubernetes에서 사용

**예시 답변**
> "Docker는 4가지 주요 네트워크 모드를 제공합니다. bridge는 기본 모드로 docker0 브리지를 통해 NAT를 수행하며 포트 매핑이 필요합니다. host 모드는 컨테이너가 호스트의 네트워크를 직접 사용해서 최고의 성능을 내지만 포트 충돌에 주의해야 합니다. none 모드는 네트워크가 완전히 격리되어 특수한 보안 요구사항이 있을 때 사용합니다. overlay 네트워크는 여러 호스트에 걸쳐 컨테이너를 연결할 수 있어 Docker Swarm이나 Kubernetes에서 사용됩니다."

**실무 예시**
```bash
# Bridge (기본)
$ docker run -d -p 8080:80 nginx
# 호스트:8080 → 컨테이너:80

# Host (고성능 필요 시)
$ docker run -d --network host nginx
# 호스트 네트워크 직접 사용

# Overlay (멀티 호스트)
$ docker network create -d overlay my-overlay
$ docker service create --network my-overlay myapp
```

**꼬리 질문**
- Q: 언제 host 모드를 사용하나요?
- A: 고성능이 필요하고 포트 충돌 걱정이 없는 경우, 예를 들어 모니터링 에이전트나 네트워크 스캐닝 도구 등에서 사용합니다.

**실무 연관**
- 마이크로서비스는 사용자 정의 bridge 네트워크
- 고성능 필요 시 host 모드
- Kubernetes는 CNI 플러그인 사용

</details>

<details>
<summary><strong>3. 이미지 빌드 최적화 전략을 5가지 이상 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 멀티 스테이지 빌드로 최종 이미지 크기 축소
- 레이어 캐싱 활용 (자주 변경되지 않는 것 먼저)
- .dockerignore로 불필요한 파일 제외
- RUN 명령 체이닝으로 레이어 수 감소
- 경량 베이스 이미지 사용 (alpine)
- 의존성 설치와 소스 복사 분리

**예시 답변**
> "이미지 빌드를 최적화하는 주요 전략은 다음과 같습니다. 첫째, 멀티 스테이지 빌드를 사용해서 빌드 도구를 최종 이미지에서 제외합니다. 둘째, package.json을 먼저 복사하고 npm install 한 후 소스 코드를 복사해서 레이어 캐싱을 최대한 활용합니다. 셋째, .dockerignore로 node_modules, .git 등 불필요한 파일을 제외합니다. 넷째, 여러 RUN 명령을 &&로 체이닝해서 레이어 수를 줄입니다. 다섯째, alpine 같은 경량 베이스 이미지를 사용합니다."

**실무 예시**
```dockerfile
# 멀티 스테이지 빌드
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/index.js"]

# 결과: 1GB → 100MB
```

**꼬리 질문**
- Q: BuildKit을 사용하면 어떤 이점이 있나요?
- A: 병렬 빌드, 빌드 캐시 마운트, 시크릿 마운트 등 고급 기능을 사용할 수 있고 빌드 속도가 더 빠릅니다.

**실무 연관**
- CI/CD 파이프라인에서 빌드 시간 단축 중요
- 이미지 크기 축소로 배포 속도 향상
- 보안 스캔 시간도 단축

</details>

<details>
<summary><strong>4. 컨테이너 보안을 강화하기 위한 방법을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 최소 권한 원칙 (non-root 사용자)
- 읽기 전용 파일시스템
- Capability 제한
- Seccomp, AppArmor, SELinux 프로파일
- 신뢰할 수 있는 이미지 사용 및 스캔
- 네트워크 격리 및 리소스 제한

**예시 답변**
> "컨테이너 보안을 강화하는 방법은 여러 가지가 있습니다. 첫째, 컨테이너를 root가 아닌 일반 사용자로 실행합니다. 둘째, --read-only로 파일시스템을 읽기 전용으로 설정합니다. 셋째, --cap-drop ALL로 모든 capability를 제거하고 필요한 것만 추가합니다. 넷째, Seccomp 프로파일로 시스템 콜을 제한합니다. 다섯째, 신뢰할 수 있는 레지스트리의 이미지만 사용하고 Trivy 같은 도구로 취약점을 스캔합니다. 마지막으로 네트워크를 격리하고 메모리와 CPU를 제한합니다."

**실무 예시**
```bash
# 보안 강화된 컨테이너 실행
$ docker run -d \
    --user 1000:1000 \
    --read-only \
    --tmpfs /tmp \
    --cap-drop ALL \
    --cap-add NET_BIND_SERVICE \
    --security-opt=no-new-privileges \
    --security-opt seccomp=default.json \
    --memory="512m" \
    --cpus="1.0" \
    --network isolated-network \
    myapp
```

**꼬리 질문**
- Q: USER 네임스페이스를 사용하면 어떤 이점이 있나요?
- A: 컨테이너 내부의 root 사용자가 호스트에서는 일반 사용자로 매핑되어 권한 상승 공격을 방어할 수 있습니다.

**실무 연관**
- 프로덕션 환경에서는 보안 정책 필수
- Kubernetes의 Pod Security Standards
- 정기적인 이미지 스캔 및 업데이트

</details>

<details>
<summary><strong>5. Docker의 스토리지 볼륨 타입(volume, bind mount, tmpfs)의 차이와 사용 사례를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- volume: Docker가 관리, 가장 권장되는 방법
- bind mount: 호스트 파일시스템 직접 마운트
- tmpfs: 메모리에만 저장, 휘발성
- 각각의 장단점과 사용 사례

**예시 답변**
> "Docker는 3가지 스토리지 타입을 제공합니다. volume은 Docker가 관리하는 영역(/var/lib/docker/volumes/)에 저장되며 데이터 영속성이 필요한 경우 가장 권장됩니다. 백업과 마이그레이션이 쉽고 Linux와 Windows 모두에서 잘 동작합니다. bind mount는 호스트의 특정 경로를 직접 마운트하는 방식으로 개발 환경에서 코드를 실시간으로 반영할 때 유용하지만 호스트 경로에 의존적입니다. tmpfs는 메모리에만 저장되어 매우 빠르지만 휘발성이므로 임시 파일이나 민감한 정보를 저장할 때 사용합니다."

**실무 예시**
```bash
# Volume (프로덕션 DB)
$ docker run -d \
    -v db-data:/var/lib/postgresql/data \
    postgres

# Bind mount (개발 환경)
$ docker run -d \
    -v $(pwd)/src:/app/src \
    -v $(pwd)/package.json:/app/package.json \
    node-dev

# tmpfs (임시 파일)
$ docker run -d \
    --tmpfs /tmp:rw,size=100m,mode=1777 \
    myapp
```

**꼬리 질문**
- Q: 볼륨을 사용하는 것이 bind mount보다 왜 더 좋나요?
- A: Docker가 관리하므로 백업과 마이그레이션이 쉽고, 플랫폼 독립적이며, 성능도 더 좋습니다. 또한 볼륨 드라이버를 통해 원격 스토리지나 클라우드 스토리지를 사용할 수 있습니다.

**실무 연관**
- 데이터베이스 데이터는 항상 volume 사용
- 로그 수집은 bind mount나 volume
- 민감한 정보는 tmpfs 또는 secret
- Kubernetes의 PersistentVolume과 유사

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 컨테이너 vs VM | VM은 Guest OS 포함, 컨테이너는 커널 공유 | 격리, 성능, 효율성 |
| 이미지 레이어 | 읽기 전용 레이어의 스택 구조 | 재사용, 캐싱, 최적화 |
| 네임스페이스 | 프로세스가 보는 시스템 자원 격리 | PID, NET, MNT, UTS, IPC, USER |
| cgroups | 리소스 사용량 제한 및 모니터링 | CPU, 메모리, I/O 제한 |
| Copy-on-Write | 필요할 때만 복사하는 전략 | 효율성, 공간 절약 |
| OverlayFS | 여러 레이어를 하나로 통합 | LowerDir, UpperDir, MergedDir |
| 생명주기 | Created → Running → Paused/Stopped → Removed | 상태 관리 |
| Docker 아키텍처 | Client → Daemon → containerd → runc | 모듈화, 표준화 |

### 필수 명령어 정리

| 명령어 | 용도 | 예시 |
|--------|------|------|
| docker run | 컨테이너 생성 및 시작 | `docker run -d -p 80:80 nginx` |
| docker ps | 컨테이너 목록 확인 | `docker ps -a` |
| docker stats | 리소스 사용량 모니터링 | `docker stats container_id` |
| docker history | 이미지 레이어 확인 | `docker history nginx` |
| docker inspect | 상세 정보 확인 | `docker inspect container_id` |
| docker diff | 파일시스템 변경 확인 | `docker diff container_id` |
| docker network | 네트워크 관리 | `docker network create mynet` |
| docker volume | 볼륨 관리 | `docker volume create mydata` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 항상 메모리와 CPU 제한 설정
- [ ] 레이어 캐싱을 고려한 Dockerfile 작성
- [ ] 데이터는 볼륨에 저장
- [ ] 사용자 정의 네트워크로 컨테이너 연결
- [ ] 멀티 스테이지 빌드로 이미지 크기 최소화
- [ ] .dockerignore로 불필요한 파일 제외
- [ ] non-root 사용자로 컨테이너 실행
- [ ] 신뢰할 수 있는 베이스 이미지 사용

#### ❌ 하지 말아야 할 것
- [ ] 리소스 제한 없이 컨테이너 실행
- [ ] 컨테이너 내부에 중요 데이터 저장
- [ ] root 사용자로 실행
- [ ] latest 태그만 사용
- [ ] 불필요한 레이어 과다 생성
- [ ] 빌드 도구를 최종 이미지에 포함
- [ ] 민감한 정보를 이미지에 포함
- [ ] 기본 bridge 네트워크 사용

### 성능/보안 체크리스트

#### 성능
- [ ] 이미지 크기 최소화 (alpine 사용)
- [ ] 레이어 캐싱 최적화
- [ ] 멀티 스테이지 빌드 적용
- [ ] 불필요한 파일 제외 (.dockerignore)
- [ ] 적절한 리소스 제한 설정
- [ ] 볼륨 사용으로 I/O 최적화

#### 보안
- [ ] non-root 사용자 실행
- [ ] 읽기 전용 파일시스템
- [ ] Capability 최소화
- [ ] 네트워크 격리
- [ ] 이미지 취약점 스캔
- [ ] 최신 베이스 이미지 사용
- [ ] Seccomp/AppArmor 프로파일 적용
- [ ] 민감한 정보는 secret 사용

---

## 🔗 관련 기술

**Docker와 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Docker Compose | 다중 컨테이너 정의 및 실행 | ⭐⭐⭐ |
| Kubernetes | 컨테이너 오케스트레이션 | ⭐⭐⭐ |
| Docker Swarm | Docker 네이티브 오케스트레이션 | ⭐⭐ |
| CI/CD (Jenkins, GitLab CI) | 자동화된 빌드 및 배포 | ⭐⭐⭐ |
| 모니터링 (Prometheus, Grafana) | 컨테이너 메트릭 수집 | ⭐⭐⭐ |
| 로깅 (ELK Stack, Fluentd) | 로그 수집 및 분석 | ⭐⭐ |
| 레지스트리 (Harbor, Nexus) | 프라이빗 이미지 저장소 | ⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: 3장 - Docker 설치 및 환경 설정
- **배울 내용 1**: Windows, Mac, Linux에서 Docker 설치
- **배울 내용 2**: Docker Desktop 설정 및 최적화
- **배울 내용 3**: 개발 환경 구성 및 트러블슈팅
- **실전 프로젝트**: 완벽한 Docker 개발 환경 구축

### 이 장과의 연결점
```
이번 장에서 배운 [아키텍처와 동작 원리]
    ↓
다음 장에서 [실제 설치 및 환경 구성]
    ↓
최종적으로 [실무에서 바로 사용 가능한 개발 환경]
```

### 준비하면 좋을 것들
```bash
# 시스템 요구사항 확인
# Windows: WSL 2 활성화
# Mac: macOS 10.15 이상
# Linux: 커널 3.10 이상

# 다음 장 실습을 위한 준비
- 관리자 권한 확인
- 디스크 여유 공간 10GB 이상
- 인터넷 연결 확인
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Docker Architecture Overview](https://docs.docker.com/get-started/overview/#docker-architecture)
- [Docker Storage Driver](https://docs.docker.com/storage/storagedriver/)
- [Docker Networking](https://docs.docker.com/network/)

### 리눅스 커널 기술
- [Linux Namespaces](https://man7.org/linux/man-pages/man7/namespaces.7.html)
- [Control Groups (cgroups)](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)
- [OverlayFS](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt)

### 컨테이너 런타임
- [containerd](https://containerd.io/)
- [runc](https://github.com/opencontainers/runc)
- [OCI Specification](https://github.com/opencontainers/runtime-spec)

### 추천 블로그/아티클
- [Understanding Docker Internals](https://medium.com/@nagarwal/understanding-docker-internals-part-1-67cd6d93dc9f)
- [Docker 네트워킹 심화](https://www.44bits.io/ko/post/container-network-3-docker-network)
- [컨테이너 보안 베스트 프랙티스](https://sysdig.com/blog/dockerfile-best-practices/)

### 영상 강의
- [Docker Deep Dive - Nigel Poulton](https://www.pluralsight.com/courses/docker-deep-dive-update)
- [Docker 마스터 클래스 (한글)](https://www.inflearn.com/course/docker-mastery)

---

## 🎉 축하합니다!

**이제 여러분은**:
✅ Docker의 내부 동작 원리를 깊이 이해할 수 있습니다
✅ 컨테이너와 VM의 차이를 명확히 설명할 수 있습니다
✅ 이미지 레이어 구조와 최적화 방법을 알고 있습니다
✅ 네임스페이스와 cgroups로 격리가 어떻게 이루어지는지 이해합니다
✅ Dockerfile을 효율적으로 작성할 수 있습니다
✅ 컨테이너 생명주기를 관리할 수 있습니다
✅ Docker 아키텍처의 각 컴포넌트 역할을 알고 있습니다
✅ 면접에서 Docker 관련 질문에 자신 있게 답변할 수 있습니다

**다음 단계**:
- [ ] 다음 장 (3장: Docker 설치 및 환경 설정)으로 진행
- [ ] 이 장의 핵심 개념 복습 및 노트 정리
- [ ] 면접 질문 답변 연습
- [ ] 실무에서 Dockerfile 작성 시 최적화 기법 적용

---

**다음 장으로 이동**: [다음: 3장 Docker 설치 및 환경 설정 →](03-설치-및-환경-설정.md)

**이전 장으로 돌아가기**: [← 이전: 1장 Docker 소개](01-소개.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)