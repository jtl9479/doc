# 44장 모듈 시스템 (Java 9) - Part 3: 성능 최적화 & 면접 질문

## 📚 목차
1. [성능 최적화](#성능-최적화)
2. [jlink를 활용한 커스텀 런타임](#jlink를-활용한-커스텀-런타임)
3. [면접 질문](#면접-질문)

---

## ⚡ 성능 최적화

### 1. 모듈 시스템의 성능 이점

```java
// Before Java 9 - 모든 JDK 로드
java -jar myapp.jar
// → rt.jar 전체 로드 (63MB)

// After Java 9 - 필요한 모듈만
java --module-path mods --module com.myapp
// → 필요한 모듈만 로드 (훨씬 작음)
```

**성능 향상**:
- 시작 시간 30-50% 단축
- 메모리 사용량 20-40% 감소
- 더 작은 배포 크기

---

### 2. jlink로 최적화된 런타임 생성

```bash
# 1. 컴파일
javac -d mods/com.myapp \
      src/com.myapp/module-info.java \
      src/com.myapp/com/myapp/*.java

# 2. JAR 생성
jar --create \
    --file=mods/com.myapp.jar \
    -C mods/com.myapp .

# 3. jlink로 커스텀 런타임 생성
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules com.myapp \
      --output myapp-runtime \
      --strip-debug \
      --compress=2 \
      --no-header-files \
      --no-man-pages

# 결과:
# myapp-runtime/ (30-50MB, JDK 전체는 150MB+)
```

---

### 3. 크기 비교

```bash
# 전통적 방식
JRE + myapp.jar = 150MB + 10MB = 160MB

# jlink 방식
myapp-runtime = 35MB (78% 감소!)
```

---

## 🚀 jlink를 활용한 커스텀 런타임

### 예제 1: 최소 런타임

```bash
# Hello World 애플리케이션
# module-info.java
module hello.world {
    // java.base는 자동 포함
}

# HelloWorld.java
package hello;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

# 컴파일 & 패키징
javac -d mods/hello.world \
      src/hello.world/module-info.java \
      src/hello.world/hello/HelloWorld.java

jar --create \
    --file=mods/hello.world.jar \
    --main-class=hello.HelloWorld \
    -C mods/hello.world .

# jlink로 최소 런타임 생성
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules hello.world \
      --launcher hello=hello.world/hello.HelloWorld \
      --output hello-runtime \
      --strip-debug \
      --compress=2

# 실행
./hello-runtime/bin/hello
# 크기: 약 30MB (JDK 전체: 150MB)
```

---

### 예제 2: 웹 애플리케이션 런타임

```bash
# 필요한 모듈만 포함
jlink --module-path $JAVA_HOME/jmods:mods:libs \
      --add-modules com.myapp.web \
      --add-modules java.sql \
      --add-modules java.logging \
      --add-modules jdk.httpserver \
      --launcher myapp=com.myapp.web/com.myapp.Main \
      --output myapp-runtime \
      --strip-debug \
      --compress=2 \
      --no-header-files \
      --no-man-pages

# Docker 이미지로 패키징
FROM alpine:latest
COPY myapp-runtime /opt/myapp
CMD ["/opt/myapp/bin/myapp"]

# 결과: 약 60MB Docker 이미지
# (일반 JDK 기반: 200MB+)
```

---

### 예제 3: 다중 플랫폼 빌드

```bash
# Linux 런타임
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules com.myapp \
      --output myapp-linux \
      --compress=2

# Windows 런타임
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules com.myapp \
      --output myapp-windows \
      --compress=2

# macOS 런타임
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules com.myapp \
      --output myapp-macos \
      --compress=2
```

---

## 💡 면접 질문

### Q1. Java 모듈 시스템의 핵심 개념은?

**답변**:
```
Java 모듈 시스템 (JPMS - Java Platform Module System)의 핵심:

1. 강력한 캡슐화
   - exports 하지 않은 패키지는 완전히 숨김
   - 리플렉션으로도 접근 불가 (opens 제외)

2. 명확한 의존성
   - requires로 명시적 선언
   - 순환 의존성 감지

3. 모듈 그래프
   - 컴파일 타임에 의존성 체크
   - 누락된 모듈 사전 감지

4. 더 나은 성능
   - 필요한 모듈만 로드
   - 작은 런타임 이미지
```

---

### Q2. module-info.java의 주요 키워드는?

**답변**:
```java
module com.example.myapp {
    // 1. exports - 패키지 공개
    exports com.example.api;
    exports com.example.util to com.example.service;

    // 2. requires - 모듈 의존
    requires java.sql;
    requires transitive java.logging;

    // 3. opens - 리플렉션 허용
    opens com.example.model to com.fasterxml.jackson.databind;

    // 4. provides/uses - 서비스
    provides java.sql.Driver with com.mysql.jdbc.Driver;
    uses java.sql.Driver;
}
```

**키워드 설명**:
- **exports**: 다른 모듈에서 import 가능
- **requires**: 다른 모듈 의존
- **requires transitive**: 전이 의존성
- **opens**: 리플렉션 접근 허용
- **provides/uses**: ServiceLoader 패턴

---

### Q3. exports와 opens의 차이는?

**답변**:
```java
module com.myapp {
    // exports - 일반 접근만
    exports com.myapp.api;

    // opens - 리플렉션도 허용
    opens com.myapp.model;
}

// 다른 모듈에서
// exports
import com.myapp.api.Service;  // ✅ 가능
Service service = new Service();  // ✅ 가능

// opens
import com.myapp.model.User;  // ❌ 불가능 (exports 안 함)

// 하지만 리플렉션은 가능
Class<?> clazz = Class.forName("com.myapp.model.User");  // ✅ 가능
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);  // ✅ 가능 (opens 했으므로)
```

**사용 시기**:
- **exports**: 공개 API
- **opens**: JPA, Jackson 등 리플렉션 라이브러리 사용 시

---

### Q4. requires와 requires transitive의 차이는?

**답변**:
```java
// Module A
module com.myapp.core {
    exports com.myapp.core.model;  // User 클래스
}

// Module B
module com.myapp.service {
    requires transitive com.myapp.core;  // transitive!
    exports com.myapp.service.api;
}

// UserService.java
public class UserService {
    public User getUser() { ... }  // User를 public API로 노출
}

// Module C
module com.myapp.web {
    requires com.myapp.service;
    // com.myapp.core를 requires 안 해도 됨!
    // transitive로 자동 전달
}

// WebController.java
import com.myapp.core.model.User;  // ✅ 가능
import com.myapp.service.api.UserService;  // ✅ 가능
```

**transitive 사용 조건**:
- public API에 다른 모듈의 타입이 노출될 때

---

### Q5. 모듈 시스템의 장단점은?

**답변**:

**장점**:
```
✅ 강력한 캡슐화 - 내부 구현 완전히 숨김
✅ 명확한 의존성 - 그래프로 시각화 가능
✅ 더 나은 성능 - 필요한 것만 로드
✅ 작은 런타임 - jlink로 최적화
✅ 안정적인 API - 공개 API 명시적 선언
```

**단점**:
```
❌ 학습 곡선 - 새로운 개념
❌ 마이그레이션 비용 - 레거시 코드 수정 필요
❌ 라이브러리 호환성 - 모듈화 안 된 라이브러리
❌ 복잡성 증가 - 작은 프로젝트에는 과함
```

---

### Q6. Automatic Module이란?

**답변**:
```
Automatic Module은 module-info.java 없는 일반 JAR를
모듈 시스템에서 사용할 수 있게 해주는 호환성 기능입니다.

특징:
1. JAR 파일명이 모듈명이 됨
   gson-2.8.jar → 모듈명: gson

2. 모든 패키지가 자동으로 exports됨

3. 모든 다른 모듈을 reads할 수 있음

4. 위험성:
   - 명확한 캡슐화 없음
   - 의존성이 불명확
```

```java
// Automatic Module 사용
module com.myapp {
    requires gson;  // Automatic Module
    requires guava;
}

// 권장: 모듈화된 라이브러리 사용
module com.myapp {
    requires com.google.gson;  // Named Module
}
```

---

### Q7. jlink의 장점은?

**답변**:
```bash
# 전통적 배포
JRE + myapp.jar = 150MB + 10MB = 160MB
시작 시간: 2초
메모리: 200MB

# jlink 배포
myapp-runtime = 35MB (78% 감소!)
시작 시간: 0.8초 (60% 단축)
메모리: 120MB (40% 감소)
```

**장점**:
1. **작은 크기** - 필요한 모듈만 포함
2. **빠른 시작** - 적은 클래스 로드
3. **낮은 메모리** - 최적화된 런타임
4. **플랫폼 독립** - 각 OS용 런타임 생성
5. **보안** - 불필요한 모듈 제거

---

## 🎯 실전 가이드

### 모듈 설계 패턴

```java
// 패턴 1: API-Implementation 분리
module com.myapp.api {
    exports com.myapp.api;
}

module com.myapp.impl {
    requires com.myapp.api;
    exports com.myapp.impl;
    provides com.myapp.api.Service
        with com.myapp.impl.ServiceImpl;
}

// 패턴 2: Core-Service-Web
module com.myapp.core {
    exports com.myapp.core.model;
    exports com.myapp.core.exception;
}

module com.myapp.service {
    requires transitive com.myapp.core;
    exports com.myapp.service.api;
}

module com.myapp.web {
    requires com.myapp.service;
    opens com.myapp.web.controller to spring.core;
}
```

---

### Maven 설정

```xml
<!-- pom.xml -->
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
                <release>17</release>
            </configuration>
        </plugin>

        <!-- jlink 플러그인 -->
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-jlink-plugin</artifactId>
            <version>3.1.0</version>
            <extensions>true</extensions>
            <configuration>
                <launcher>myapp=com.myapp/com.myapp.Main</launcher>
                <compress>2</compress>
                <noHeaderFiles>true</noHeaderFiles>
                <noManPages>true</noManPages>
                <stripDebug>true</stripDebug>
            </configuration>
        </plugin>
    </plugins>
</build>
```

---

### Gradle 설정

```gradle
// build.gradle
plugins {
    id 'java'
    id 'application'
}

java {
    modularity.inferModulePath = true
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

application {
    mainModule = 'com.myapp'
    mainClass = 'com.myapp.Main'
}

// jlink 태스크
task jlink(type: Exec) {
    commandLine 'jlink',
        '--module-path', "$buildDir/libs:$java.home/jmods",
        '--add-modules', 'com.myapp',
        '--output', "$buildDir/jlink/myapp-runtime",
        '--strip-debug',
        '--compress=2',
        '--no-header-files',
        '--no-man-pages'
}
```

---

## 🎓 최종 정리

### 모듈 시스템 핵심

```
1. module-info.java - 모듈 선언
2. exports - 패키지 공개
3. requires - 모듈 의존
4. 강력한 캡슐화
5. jlink - 최적화된 런타임
```

### 마이그레이션 순서

```
1. 의존성 분석 (jdeps)
2. Bottom-Up 모듈화
3. 순환 의존성 제거
4. 테스트 & 검증
5. jlink 배포
```

### 실무 적용 시기

```
✅ 적용 권장:
- 대규모 프로젝트
- 마이크로서비스
- 명확한 계층 구조
- 배포 크기가 중요한 경우

❌ 적용 보류:
- 소규모 프로젝트
- 레거시 의존성 많음
- 빠른 프로토타입
```

**축하합니다! 모듈 시스템을 마스터했습니다!** 🎉
