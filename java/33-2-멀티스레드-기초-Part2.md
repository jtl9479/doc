# 33장 멀티스레드 기초 - Part 2: 동기화 & 실수

## 🔒 동기화 (Synchronization)

### 문제: 경쟁 상태 (Race Condition)
```java
class Counter {
    private int count = 0;

    public void increment() {
        count++;  // 스레드 안전하지 않음!
    }
}

// 여러 스레드가 동시에 increment() 호출
// → 예상: 10000, 실제: 9856 (값 손실!)
```

### 해결: synchronized
```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;  // 한 번에 한 스레드만!
    }
}
```

---

## 🚨 주니어 실수

### ❌ 실수 1: start() 대신 run() 호출
```java
// ❌ 별도 스레드가 아님!
thread.run();  // 현재 스레드에서 실행

// ✅ 별도 스레드 생성
thread.start();
```

### ❌ 실수 2: 동기화 누락
```java
// ❌ 여러 스레드가 동시 접근 가능
private int count = 0;
public void increment() {
    count++;
}

// ✅ synchronized 사용
public synchronized void increment() {
    count++;
}
```

### ❌ 실수 3: 데드락 (Deadlock)
```java
// ❌ 데드락 발생 가능
synchronized(lock1) {
    synchronized(lock2) {
        // 작업
    }
}

// 다른 스레드
synchronized(lock2) {
    synchronized(lock1) {
        // 작업
    }
}
// → 서로 대기 (데드락!)

// ✅ 잠금 순서 일치
synchronized(lock1) {
    synchronized(lock2) {
        // 두 스레드 모두 같은 순서
    }
}
```

### ❌ 실수 4: sleep vs wait 혼동
```java
// sleep: 지정 시간 대기 (락 유지)
Thread.sleep(1000);

// wait: 다른 스레드가 notify할 때까지 (락 해제)
synchronized(obj) {
    obj.wait();
}
```

---

## 💡 Best Practices

```java
// ✅ ExecutorService 사용 (권장)
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> {
    // 작업
});
executor.shutdown();

// ❌ Thread 직접 생성 (구식)
new Thread(() -> {
    // 작업
}).start();
```

**다음 Part 3**: 면접 질문
