# 섹션 36: 치트시트 및 빠른 참조

## Docker 명령어 치트시트

### 기본 명령어

```bash
# Docker 버전 확인
docker --version
docker version
docker info

# 도움말
docker --help
docker <command> --help
```

### 이미지 관리

```bash
# 이미지 검색
docker search nginx

# 이미지 다운로드
docker pull nginx:alpine
docker pull nginx:1.21

# 이미지 목록
docker images
docker image ls

# 이미지 상세 정보
docker inspect nginx:alpine
docker history nginx:alpine

# 이미지 삭제
docker rmi nginx:alpine
docker image rm nginx:alpine

# 사용하지 않는 이미지 삭제
docker image prune
docker image prune -a

# 이미지 태그
docker tag nginx:alpine myregistry.com/nginx:v1

# 이미지 저장/불러오기
docker save nginx:alpine -o nginx.tar
docker load -i nginx.tar
```

### 컨테이너 관리

```bash
# 컨테이너 실행
docker run nginx
docker run -d nginx                    # 백그라운드
docker run -d --name web nginx         # 이름 지정
docker run -d -p 8080:80 nginx        # 포트 매핑
docker run -d -v $(pwd):/app nginx    # 볼륨 마운트
docker run -d -e KEY=VALUE nginx      # 환경 변수

# 컨테이너 목록
docker ps                 # 실행 중
docker ps -a              # 모든 컨테이너
docker ps -q              # ID만 출력

# 컨테이너 시작/중지/재시작
docker start <container>
docker stop <container>
docker restart <container>
docker pause <container>
docker unpause <container>

# 컨테이너 삭제
docker rm <container>
docker rm -f <container>     # 강제 삭제

# 모든 중지된 컨테이너 삭제
docker container prune

# 컨테이너 로그
docker logs <container>
docker logs -f <container>           # 실시간
docker logs --tail 100 <container>   # 마지막 100줄
docker logs --since 10m <container>  # 최근 10분

# 컨테이너 내부 접속
docker exec -it <container> /bin/bash
docker exec -it <container> sh

# 컨테이너 → 호스트 파일 복사
docker cp <container>:/path/to/file ./local

# 호스트 → 컨테이너 파일 복사
docker cp ./local <container>:/path/to/file

# 컨테이너 리소스 사용량
docker stats
docker stats <container>

# 컨테이너 상세 정보
docker inspect <container>
docker top <container>
```

### 빌드 관리

```bash
# 이미지 빌드
docker build -t myapp:v1 .
docker build -f Dockerfile.prod -t myapp:v1 .
docker build --no-cache -t myapp:v1 .

# 빌드 인자
docker build --build-arg VERSION=1.0 -t myapp:v1 .

# BuildKit 사용
DOCKER_BUILDKIT=1 docker build -t myapp:v1 .
```

### 네트워크 관리

```bash
# 네트워크 목록
docker network ls

# 네트워크 생성
docker network create mynetwork
docker network create --driver bridge mynetwork

# 네트워크 상세 정보
docker network inspect mynetwork

# 컨테이너를 네트워크에 연결
docker network connect mynetwork <container>
docker network disconnect mynetwork <container>

# 네트워크 삭제
docker network rm mynetwork
docker network prune
```

### 볼륨 관리

```bash
# 볼륨 목록
docker volume ls

# 볼륨 생성
docker volume create myvolume

# 볼륨 상세 정보
docker volume inspect myvolume

# 볼륨 삭제
docker volume rm myvolume
docker volume prune

# 볼륨 사용
docker run -v myvolume:/data nginx
```

### Docker Compose

```bash
# 서비스 시작
docker-compose up
docker-compose up -d              # 백그라운드
docker-compose up --build         # 이미지 재빌드

# 서비스 중지
docker-compose stop
docker-compose down               # 컨테이너 삭제
docker-compose down -v            # 볼륨도 삭제

# 서비스 목록
docker-compose ps

# 로그
docker-compose logs
docker-compose logs -f
docker-compose logs <service>

# 특정 서비스 재시작
docker-compose restart <service>

# 스케일링
docker-compose up -d --scale web=3

# 설정 확인
docker-compose config
```

### Docker Swarm

```bash
# Swarm 초기화
docker swarm init
docker swarm init --advertise-addr <ip>

# 노드 추가
docker swarm join --token <token> <ip>:2377

# 노드 목록
docker node ls

# 서비스 생성
docker service create --name web --replicas 3 -p 80:80 nginx

# 서비스 목록
docker service ls

# 서비스 상세 정보
docker service ps web
docker service inspect web

# 서비스 스케일
docker service scale web=5

# 서비스 업데이트
docker service update --image nginx:1.21 web

# 서비스 삭제
docker service rm web

# Stack 배포
docker stack deploy -c docker-compose.yml mystack

# Stack 목록
docker stack ls
docker stack services mystack
docker stack ps mystack

# Stack 삭제
docker stack rm mystack
```

### Kubernetes (kubectl)

```bash
# 클러스터 정보
kubectl cluster-info
kubectl get nodes

# Pod 관리
kubectl get pods
kubectl get pods -o wide
kubectl describe pod <pod>
kubectl logs <pod>
kubectl logs -f <pod>
kubectl exec -it <pod> -- /bin/bash

# Deployment 관리
kubectl create deployment nginx --image=nginx
kubectl get deployments
kubectl scale deployment nginx --replicas=3
kubectl delete deployment nginx

# Service 관리
kubectl expose deployment nginx --port=80 --type=NodePort
kubectl get services
kubectl delete service nginx

# YAML 적용
kubectl apply -f deployment.yaml
kubectl delete -f deployment.yaml

# 리소스 조회
kubectl get all
kubectl get all -n <namespace>

# 네임스페이스
kubectl get namespaces
kubectl create namespace <name>
kubectl config set-context --current --namespace=<name>

# ConfigMap & Secret
kubectl create configmap <name> --from-literal=key=value
kubectl create secret generic <name> --from-literal=password=secret
kubectl get configmaps
kubectl get secrets

# 리소스 사용량
kubectl top nodes
kubectl top pods
```

---

## Dockerfile 치트시트

### 기본 명령어

```dockerfile
# 베이스 이미지
FROM ubuntu:22.04
FROM node:18-alpine AS builder

# 작업 디렉토리
WORKDIR /app

# 파일 복사
COPY package.json .
COPY . .
COPY --from=builder /app/dist ./dist

# 명령 실행
RUN apt-get update && apt-get install -y curl
RUN npm install

# 환경 변수
ENV NODE_ENV=production
ENV PATH="/app/bin:${PATH}"

# 포트 노출
EXPOSE 8080

# 볼륨
VOLUME /data

# 사용자
USER appuser

# 헬스체크
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost:8080/health || exit 1

# 실행 명령 (하나만)
CMD ["node", "server.js"]
ENTRYPOINT ["docker-entrypoint.sh"]
CMD ["nginx", "-g", "daemon off;"]

# 레이블
LABEL version="1.0"
LABEL description="My Application"

# 빌드 인자
ARG VERSION=latest
ARG BUILD_DATE
```

### 멀티 스테이지 빌드

```dockerfile
# Stage 1: Build
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
CMD ["node", "dist/main.js"]
```

---

## docker-compose.yml 치트시트

```yaml
version: '3.8'

services:
  # 웹 서비스
  web:
    image: nginx:alpine
    # 또는 빌드
    build:
      context: .
      dockerfile: Dockerfile
      args:
        VERSION: 1.0
    container_name: my-web
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html
      - web-data:/var/log/nginx
    environment:
      - NODE_ENV=production
      - DEBUG=false
    env_file:
      - .env
    networks:
      - frontend
    depends_on:
      - db
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost"]
      interval: 30s
      timeout: 3s
      retries: 3
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

  # 데이터베이스
  db:
    image: postgres:16
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    networks:
      - backend

volumes:
  web-data:
  db-data:

networks:
  frontend:
  backend:
```

---

## 자주 쓰는 패턴

### 1. 개발 환경 설정

```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      target: development
    volumes:
      - .:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
    command: npm run dev
```

### 2. 테스트 환경

```yaml
version: '3.8'

services:
  test:
    build: .
    volumes:
      - .:/app
    command: npm test
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: test_db
```

### 3. 프로덕션 환경

```yaml
version: '3.8'

services:
  app:
    image: myregistry.com/myapp:${VERSION}
    restart: always
    environment:
      - NODE_ENV=production
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
```

---

## 환경 변수

```bash
# .env 파일
VERSION=1.0.0
REGISTRY=myregistry.com
DB_PASSWORD=secret

# docker-compose.yml에서 사용
services:
  app:
    image: ${REGISTRY}/myapp:${VERSION}
    environment:
      - DB_PASSWORD=${DB_PASSWORD}
```

---

## 리소스 정리

```bash
# 모두 중지 및 삭제
docker-compose down

# 컨테이너, 네트워크, 이미지, 볼륨 모두 삭제
docker system prune -a --volumes

# 사용하지 않는 것만 삭제
docker container prune
docker image prune
docker volume prune
docker network prune

# 디스크 사용량 확인
docker system df
```

---

## 디버깅

```bash
# 컨테이너 로그
docker logs -f <container>

# 컨테이너 내부 접속
docker exec -it <container> sh

# 컨테이너 상세 정보
docker inspect <container>

# 네트워크 연결 테스트
docker run --rm -it nicolaka/netshoot
# 내부에서: nslookup, ping, curl 등 사용

# 프로세스 확인
docker top <container>

# 파일 시스템 변경 확인
docker diff <container>
```

---

## 성능 모니터링

```bash
# 실시간 리소스 사용량
docker stats

# 특정 컨테이너
docker stats <container>

# JSON 형식
docker stats --format "{{json .}}"

# 한 번만 출력
docker stats --no-stream
```

---

## 보안

```bash
# 이미지 스캔
trivy image myapp:latest
docker scan myapp:latest

# 컨테이너 보안 설정
docker run --read-only \
  --security-opt=no-new-privileges \
  --cap-drop=ALL \
  myapp

# Secret 사용
echo "password" | docker secret create db_password -
docker service create --secret db_password myapp
```

---

## 유용한 플래그

```bash
# 자주 쓰는 플래그
-d, --detach              # 백그라운드 실행
-i, --interactive         # 표준 입력 유지
-t, --tty                 # 가상 터미널 할당
-p, --publish             # 포트 매핑
-v, --volume              # 볼륨 마운트
-e, --env                 # 환경 변수
--name                    # 이름 지정
--rm                      # 종료 시 자동 삭제
-f, --force               # 강제 실행
--no-cache                # 캐시 사용 안 함
-q, --quiet               # 최소 출력
```

---

이 치트시트를 인쇄하거나 즐겨찾기에 추가하여 언제든지 참조하세요! 📋