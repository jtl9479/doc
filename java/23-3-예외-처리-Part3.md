# 23-3. 예외 처리 Part 3 🛡️

## 📋 목차
1. [실전 프로젝트: 복원력 있는 주문 처리 시스템](#실전-프로젝트)
2. [FAQ 7선](#faq)
3. [면접 질문 12선](#면접-질문)

---

## 🚀 실전 프로젝트: 복원력 있는 주문 처리 시스템

### 프로젝트 개요
이커머스 플랫폼에서 사용하는 **장애에 강한 주문 처리 시스템**을 구현합니다.

**핵심 기능:**
- ✅ 커스텀 예외 계층 구조
- ✅ 트랜잭션 롤백 및 보상 처리
- ✅ 재시도 메커니즘 (Exponential Backoff)
- ✅ Circuit Breaker 패턴
- ✅ 예외 로깅 및 모니터링
- ✅ 우아한 성능 저하 (Graceful Degradation)

---

### 1️⃣ 커스텀 예외 계층 구조

```java
// 📁 exceptions/OrderException.java
/**
 * 주문 처리 관련 최상위 예외
 */
public abstract class OrderException extends RuntimeException {
    private final String errorCode;
    private final long timestamp;

    public OrderException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.timestamp = System.currentTimeMillis();
    }

    public OrderException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.timestamp = System.currentTimeMillis();
    }

    public String getErrorCode() {
        return errorCode;
    }

    public long getTimestamp() {
        return timestamp;
    }

    /**
     * 재시도 가능 여부 판단
     */
    public abstract boolean isRetryable();

    /**
     * 심각도 수준
     */
    public abstract SeverityLevel getSeverity();
}

enum SeverityLevel {
    LOW,      // 로그만 남김
    MEDIUM,   // 알림 발송
    HIGH,     // 즉시 대응 필요
    CRITICAL  // 서비스 중단 가능성
}
```

```java
// 📁 exceptions/PaymentException.java
/**
 * 결제 관련 예외
 */
public class PaymentException extends OrderException {
    private final String paymentId;

    public PaymentException(String paymentId, String message) {
        super("PAYMENT_ERROR", message);
        this.paymentId = paymentId;
    }

    public PaymentException(String paymentId, String message, Throwable cause) {
        super("PAYMENT_ERROR", message, cause);
        this.paymentId = paymentId;
    }

    public String getPaymentId() {
        return paymentId;
    }

    @Override
    public boolean isRetryable() {
        return true; // 결제는 재시도 가능
    }

    @Override
    public SeverityLevel getSeverity() {
        return SeverityLevel.HIGH; // 결제 실패는 높은 우선순위
    }
}

/**
 * 카드 한도 초과 예외
 */
public class CardLimitExceededException extends PaymentException {
    private final int currentLimit;
    private final int requestedAmount;

    public CardLimitExceededException(String paymentId, int currentLimit, int requestedAmount) {
        super(paymentId, String.format(
            "카드 한도 초과: 현재 한도 %,d원, 요청 금액 %,d원",
            currentLimit, requestedAmount
        ));
        this.currentLimit = currentLimit;
        this.requestedAmount = requestedAmount;
    }

    @Override
    public boolean isRetryable() {
        return false; // 한도 초과는 재시도 불가
    }
}
```

```java
// 📁 exceptions/InventoryException.java
/**
 * 재고 관련 예외
 */
public class InventoryException extends OrderException {
    private final String productId;

    public InventoryException(String productId, String message) {
        super("INVENTORY_ERROR", message);
        this.productId = productId;
    }

    public String getProductId() {
        return productId;
    }

    @Override
    public boolean isRetryable() {
        return true; // 재고는 변동 가능하므로 재시도 가능
    }

    @Override
    public SeverityLevel getSeverity() {
        return SeverityLevel.MEDIUM;
    }
}

/**
 * 재고 부족 예외
 */
public class OutOfStockException extends InventoryException {
    private final int availableStock;
    private final int requestedQuantity;

    public OutOfStockException(String productId, int availableStock, int requestedQuantity) {
        super(productId, String.format(
            "재고 부족: 상품ID %s, 현재 재고 %d개, 요청 수량 %d개",
            productId, availableStock, requestedQuantity
        ));
        this.availableStock = availableStock;
        this.requestedQuantity = requestedQuantity;
    }

    public int getAvailableStock() {
        return availableStock;
    }

    public int getRequestedQuantity() {
        return requestedQuantity;
    }
}
```

```java
// 📁 exceptions/NetworkException.java
/**
 * 네트워크 관련 예외 (외부 API 호출 실패 등)
 */
public class NetworkException extends OrderException {
    private final String endpoint;

    public NetworkException(String endpoint, String message, Throwable cause) {
        super("NETWORK_ERROR", message, cause);
        this.endpoint = endpoint;
    }

    public String getEndpoint() {
        return endpoint;
    }

    @Override
    public boolean isRetryable() {
        return true; // 네트워크 오류는 일시적일 수 있음
    }

    @Override
    public SeverityLevel getSeverity() {
        return SeverityLevel.MEDIUM;
    }
}
```

---

### 2️⃣ 재시도 메커니즘 (Retry with Exponential Backoff)

```java
// 📁 retry/RetryPolicy.java
/**
 * 재시도 정책 설정
 */
public class RetryPolicy {
    private final int maxAttempts;
    private final long initialDelayMs;
    private final double backoffMultiplier;
    private final long maxDelayMs;

    public RetryPolicy(int maxAttempts, long initialDelayMs,
                       double backoffMultiplier, long maxDelayMs) {
        this.maxAttempts = maxAttempts;
        this.initialDelayMs = initialDelayMs;
        this.backoffMultiplier = backoffMultiplier;
        this.maxDelayMs = maxDelayMs;
    }

    /**
     * 기본 정책: 최대 3회, 초기 지연 100ms, 2배씩 증가
     */
    public static RetryPolicy defaultPolicy() {
        return new RetryPolicy(3, 100, 2.0, 5000);
    }

    /**
     * 공격적인 재시도: 최대 5회, 빠른 재시도
     */
    public static RetryPolicy aggressive() {
        return new RetryPolicy(5, 50, 1.5, 2000);
    }

    /**
     * n번째 재시도의 대기 시간 계산
     */
    public long getDelayMs(int attemptNumber) {
        long delay = (long) (initialDelayMs * Math.pow(backoffMultiplier, attemptNumber - 1));
        return Math.min(delay, maxDelayMs);
    }

    public int getMaxAttempts() {
        return maxAttempts;
    }
}
```

```java
// 📁 retry/RetryExecutor.java
/**
 * 재시도 로직을 실행하는 유틸리티
 */
public class RetryExecutor {

    @FunctionalInterface
    public interface RetryableTask<T> {
        T execute() throws Exception;
    }

    /**
     * 재시도 가능한 작업 실행
     */
    public static <T> T executeWithRetry(
        RetryableTask<T> task,
        RetryPolicy policy,
        String operationName
    ) throws Exception {

        Exception lastException = null;

        for (int attempt = 1; attempt <= policy.getMaxAttempts(); attempt++) {
            try {
                System.out.printf("[재시도 %d/%d] %s 실행 중...%n",
                    attempt, policy.getMaxAttempts(), operationName);

                T result = task.execute();

                if (attempt > 1) {
                    System.out.printf("✅ %s 성공 (시도 횟수: %d)%n",
                        operationName, attempt);
                }

                return result;

            } catch (Exception e) {
                lastException = e;

                // OrderException이고 재시도 불가능한 경우 즉시 예외 발생
                if (e instanceof OrderException) {
                    OrderException orderEx = (OrderException) e;
                    if (!orderEx.isRetryable()) {
                        System.out.printf("❌ %s: 재시도 불가능한 예외 - %s%n",
                            operationName, e.getMessage());
                        throw e;
                    }
                }

                // 마지막 시도였다면 예외 발생
                if (attempt == policy.getMaxAttempts()) {
                    System.out.printf("❌ %s: 최대 재시도 횟수 초과%n", operationName);
                    throw e;
                }

                // 대기 시간 계산 및 대기
                long delayMs = policy.getDelayMs(attempt);
                System.out.printf("⏳ %dms 후 재시도... (에러: %s)%n",
                    delayMs, e.getMessage());

                try {
                    Thread.sleep(delayMs);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("재시도 중 인터럽트 발생", ie);
                }
            }
        }

        throw lastException; // 이 코드는 실행되지 않지만 컴파일러를 위해 필요
    }
}
```

---

### 3️⃣ Circuit Breaker 패턴

```java
// 📁 circuitbreaker/CircuitBreakerState.java
/**
 * Circuit Breaker의 상태
 */
enum CircuitBreakerState {
    CLOSED,      // 정상 작동 (요청 허용)
    OPEN,        // 차단 상태 (요청 거부)
    HALF_OPEN    // 반쯤 열림 (테스트 요청 허용)
}
```

```java
// 📁 circuitbreaker/CircuitBreaker.java
/**
 * Circuit Breaker 구현
 *
 * 동작 원리:
 * 1. CLOSED: 정상 동작, 실패 카운트
 * 2. OPEN: 임계값 초과 시 차단, 모든 요청 즉시 거부
 * 3. HALF_OPEN: 일정 시간 후 테스트 요청 허용
 * 4. 성공 시 CLOSED로 복귀, 실패 시 다시 OPEN
 */
public class CircuitBreaker {
    private final String name;
    private final int failureThreshold;      // 실패 임계값
    private final long openDurationMs;       // OPEN 상태 유지 시간
    private final int halfOpenMaxAttempts;   // HALF_OPEN에서 테스트 시도 횟수

    private CircuitBreakerState state;
    private int failureCount;
    private int successCount;
    private long lastFailureTime;

    public CircuitBreaker(String name, int failureThreshold,
                          long openDurationMs, int halfOpenMaxAttempts) {
        this.name = name;
        this.failureThreshold = failureThreshold;
        this.openDurationMs = openDurationMs;
        this.halfOpenMaxAttempts = halfOpenMaxAttempts;
        this.state = CircuitBreakerState.CLOSED;
        this.failureCount = 0;
        this.successCount = 0;
    }

    /**
     * Circuit Breaker를 통해 작업 실행
     */
    public <T> T execute(RetryExecutor.RetryableTask<T> task, String operationName)
        throws Exception {

        // OPEN 상태 확인
        if (state == CircuitBreakerState.OPEN) {
            // OPEN 지속 시간이 지났는지 확인
            if (System.currentTimeMillis() - lastFailureTime >= openDurationMs) {
                System.out.printf("🔄 [%s] OPEN → HALF_OPEN (테스트 시작)%n", name);
                state = CircuitBreakerState.HALF_OPEN;
                successCount = 0;
            } else {
                throw new CircuitBreakerOpenException(name,
                    "Circuit Breaker가 OPEN 상태입니다: " + operationName);
            }
        }

        try {
            T result = task.execute();
            onSuccess();
            return result;

        } catch (Exception e) {
            onFailure();
            throw e;
        }
    }

    /**
     * 성공 처리
     */
    private void onSuccess() {
        failureCount = 0;

        if (state == CircuitBreakerState.HALF_OPEN) {
            successCount++;
            if (successCount >= halfOpenMaxAttempts) {
                System.out.printf("✅ [%s] HALF_OPEN → CLOSED (복구 완료)%n", name);
                state = CircuitBreakerState.CLOSED;
                successCount = 0;
            }
        }
    }

    /**
     * 실패 처리
     */
    private void onFailure() {
        lastFailureTime = System.currentTimeMillis();
        failureCount++;

        if (state == CircuitBreakerState.HALF_OPEN) {
            System.out.printf("❌ [%s] HALF_OPEN → OPEN (테스트 실패)%n", name);
            state = CircuitBreakerState.OPEN;
            failureCount = 0;
            successCount = 0;

        } else if (state == CircuitBreakerState.CLOSED
                   && failureCount >= failureThreshold) {
            System.out.printf("⚠️ [%s] CLOSED → OPEN (실패 %d회 초과)%n",
                name, failureThreshold);
            state = CircuitBreakerState.OPEN;
        }
    }

    public CircuitBreakerState getState() {
        return state;
    }

    public int getFailureCount() {
        return failureCount;
    }
}

/**
 * Circuit Breaker가 OPEN 상태일 때 발생하는 예외
 */
class CircuitBreakerOpenException extends OrderException {
    public CircuitBreakerOpenException(String circuitBreakerName, String message) {
        super("CIRCUIT_BREAKER_OPEN", message);
    }

    @Override
    public boolean isRetryable() {
        return false; // Circuit Breaker OPEN 상태에서는 재시도 불가
    }

    @Override
    public SeverityLevel getSeverity() {
        return SeverityLevel.HIGH;
    }
}
```

---

### 4️⃣ 트랜잭션 관리 및 보상 처리

```java
// 📁 transaction/TransactionManager.java
/**
 * 트랜잭션 관리자
 *
 * 주문 처리는 여러 단계로 구성:
 * 1. 재고 차감
 * 2. 결제 처리
 * 3. 배송 정보 생성
 *
 * 중간에 실패 시 이전 단계를 롤백해야 함 (보상 트랜잭션)
 */
public class TransactionManager {

    /**
     * 보상 가능한 작업
     */
    public interface CompensatableAction {
        void execute() throws Exception;
        void compensate() throws Exception; // 롤백 로직
        String getName();
    }

    /**
     * 트랜잭션 실행
     */
    public static void executeTransaction(List<CompensatableAction> actions)
        throws Exception {

        List<CompensatableAction> executedActions = new ArrayList<>();

        try {
            // 순차적으로 모든 액션 실행
            for (CompensatableAction action : actions) {
                System.out.printf("🔹 [트랜잭션] %s 실행...%n", action.getName());
                action.execute();
                executedActions.add(action);
                System.out.printf("✅ [트랜잭션] %s 완료%n", action.getName());
            }

            System.out.println("✅ [트랜잭션] 전체 트랜잭션 성공!");

        } catch (Exception e) {
            System.err.printf("❌ [트랜잭션] 실패: %s%n", e.getMessage());
            System.err.println("🔙 [트랜잭션] 롤백 시작...");

            // 역순으로 보상 트랜잭션 실행
            Collections.reverse(executedActions);

            for (CompensatableAction action : executedActions) {
                try {
                    System.out.printf("↩️  [롤백] %s 롤백 중...%n", action.getName());
                    action.compensate();
                    System.out.printf("✅ [롤백] %s 롤백 완료%n", action.getName());

                } catch (Exception compensationEx) {
                    // 보상 트랜잭션 실패 시 심각한 문제 - 로그 남기고 계속 진행
                    System.err.printf("⚠️ [롤백 실패] %s: %s%n",
                        action.getName(), compensationEx.getMessage());
                }
            }

            System.err.println("🔙 [트랜잭션] 롤백 완료");
            throw e; // 원래 예외를 다시 던짐
        }
    }
}
```

---

### 5️⃣ 주문 처리 시스템 통합

```java
// 📁 model/Order.java
/**
 * 주문 정보
 */
public class Order {
    private final String orderId;
    private final String userId;
    private final String productId;
    private final int quantity;
    private final int totalAmount;
    private OrderStatus status;

    public Order(String orderId, String userId, String productId,
                 int quantity, int totalAmount) {
        this.orderId = orderId;
        this.userId = userId;
        this.productId = productId;
        this.quantity = quantity;
        this.totalAmount = totalAmount;
        this.status = OrderStatus.PENDING;
    }

    // Getters and setters
    public String getOrderId() { return orderId; }
    public String getUserId() { return userId; }
    public String getProductId() { return productId; }
    public int getQuantity() { return quantity; }
    public int getTotalAmount() { return totalAmount; }
    public OrderStatus getStatus() { return status; }
    public void setStatus(OrderStatus status) { this.status = status; }
}

enum OrderStatus {
    PENDING,          // 대기 중
    PROCESSING,       // 처리 중
    PAYMENT_FAILED,   // 결제 실패
    INVENTORY_FAILED, // 재고 부족
    COMPLETED,        // 완료
    CANCELLED         // 취소됨
}
```

```java
// 📁 service/InventoryService.java
/**
 * 재고 관리 서비스
 */
public class InventoryService {
    private final Map<String, Integer> inventory = new HashMap<>();

    public InventoryService() {
        // 초기 재고 설정
        inventory.put("PROD-001", 10);
        inventory.put("PROD-002", 5);
        inventory.put("PROD-003", 0); // 품절
    }

    /**
     * 재고 차감
     */
    public void decreaseStock(String productId, int quantity)
        throws OutOfStockException {

        int currentStock = inventory.getOrDefault(productId, 0);

        if (currentStock < quantity) {
            throw new OutOfStockException(productId, currentStock, quantity);
        }

        inventory.put(productId, currentStock - quantity);
        System.out.printf("📦 재고 차감: %s (%d → %d)%n",
            productId, currentStock, currentStock - quantity);
    }

    /**
     * 재고 복구 (보상 트랜잭션)
     */
    public void increaseStock(String productId, int quantity) {
        int currentStock = inventory.getOrDefault(productId, 0);
        inventory.put(productId, currentStock + quantity);
        System.out.printf("↩️  재고 복구: %s (%d → %d)%n",
            productId, currentStock, currentStock + quantity);
    }

    public int getStock(String productId) {
        return inventory.getOrDefault(productId, 0);
    }
}
```

```java
// 📁 service/PaymentService.java
/**
 * 결제 서비스 (외부 API 호출 시뮬레이션)
 */
public class PaymentService {
    private final Map<String, Integer> userBalances = new HashMap<>();
    private final Map<String, String> processedPayments = new HashMap<>();
    private final CircuitBreaker circuitBreaker;
    private int callCount = 0; // 네트워크 오류 시뮬레이션용

    public PaymentService(CircuitBreaker circuitBreaker) {
        this.circuitBreaker = circuitBreaker;
        // 초기 잔액 설정
        userBalances.put("USER-001", 100000);
        userBalances.put("USER-002", 50000);
        userBalances.put("USER-003", 10000);
    }

    /**
     * 결제 처리
     */
    public String processPayment(String userId, int amount, String orderId)
        throws Exception {

        return circuitBreaker.execute(() -> {
            // 네트워크 오류 시뮬레이션 (처음 2번 실패)
            callCount++;
            if (callCount <= 2) {
                throw new NetworkException(
                    "https://payment-gateway.example.com/charge",
                    "결제 게이트웨이 연결 실패",
                    new IOException("Connection timeout")
                );
            }

            int balance = userBalances.getOrDefault(userId, 0);

            if (balance < amount) {
                throw new CardLimitExceededException(
                    "PAY-" + orderId, balance, amount
                );
            }

            userBalances.put(userId, balance - amount);
            String paymentId = "PAY-" + System.currentTimeMillis();
            processedPayments.put(paymentId, orderId);

            System.out.printf("💳 결제 완료: %s (잔액 %,d → %,d)%n",
                paymentId, balance, balance - amount);

            return paymentId;

        }, "결제 처리");
    }

    /**
     * 결제 취소 (보상 트랜잭션)
     */
    public void refundPayment(String paymentId, String userId, int amount) {
        int balance = userBalances.getOrDefault(userId, 0);
        userBalances.put(userId, balance + amount);
        processedPayments.remove(paymentId);

        System.out.printf("↩️  결제 환불: %s (잔액 %,d → %,d)%n",
            paymentId, balance, balance + amount);
    }
}
```

```java
// 📁 service/OrderService.java
/**
 * 주문 처리 서비스 (통합)
 */
public class OrderService {
    private final InventoryService inventoryService;
    private final PaymentService paymentService;
    private final RetryPolicy retryPolicy;

    public OrderService(InventoryService inventoryService,
                        PaymentService paymentService,
                        RetryPolicy retryPolicy) {
        this.inventoryService = inventoryService;
        this.paymentService = paymentService;
        this.retryPolicy = retryPolicy;
    }

    /**
     * 주문 처리 (트랜잭션)
     */
    public void processOrder(Order order) throws Exception {
        System.out.printf("%n========== 주문 처리 시작: %s ==========%n",
            order.getOrderId());

        order.setStatus(OrderStatus.PROCESSING);

        // 보상 트랜잭션을 위한 변수
        final String[] paymentId = {null};

        List<TransactionManager.CompensatableAction> actions = List.of(
            // 액션 1: 재고 차감
            new TransactionManager.CompensatableAction() {
                @Override
                public void execute() throws Exception {
                    RetryExecutor.executeWithRetry(
                        () -> {
                            inventoryService.decreaseStock(
                                order.getProductId(),
                                order.getQuantity()
                            );
                            return null;
                        },
                        retryPolicy,
                        "재고 차감"
                    );
                }

                @Override
                public void compensate() {
                    inventoryService.increaseStock(
                        order.getProductId(),
                        order.getQuantity()
                    );
                }

                @Override
                public String getName() {
                    return "재고 차감";
                }
            },

            // 액션 2: 결제 처리
            new TransactionManager.CompensatableAction() {
                @Override
                public void execute() throws Exception {
                    paymentId[0] = RetryExecutor.executeWithRetry(
                        () -> paymentService.processPayment(
                            order.getUserId(),
                            order.getTotalAmount(),
                            order.getOrderId()
                        ),
                        retryPolicy,
                        "결제 처리"
                    );
                }

                @Override
                public void compensate() {
                    if (paymentId[0] != null) {
                        paymentService.refundPayment(
                            paymentId[0],
                            order.getUserId(),
                            order.getTotalAmount()
                        );
                    }
                }

                @Override
                public String getName() {
                    return "결제 처리";
                }
            },

            // 액션 3: 배송 정보 생성
            new TransactionManager.CompensatableAction() {
                @Override
                public void execute() {
                    System.out.printf("🚚 배송 정보 생성: %s%n", order.getOrderId());
                }

                @Override
                public void compensate() {
                    System.out.printf("↩️  배송 정보 취소: %s%n", order.getOrderId());
                }

                @Override
                public String getName() {
                    return "배송 정보 생성";
                }
            }
        );

        try {
            TransactionManager.executeTransaction(actions);
            order.setStatus(OrderStatus.COMPLETED);
            System.out.printf("========== 주문 완료: %s ==========%n%n",
                order.getOrderId());

        } catch (Exception e) {
            // 예외 타입에 따라 상태 설정
            if (e instanceof PaymentException) {
                order.setStatus(OrderStatus.PAYMENT_FAILED);
            } else if (e instanceof InventoryException) {
                order.setStatus(OrderStatus.INVENTORY_FAILED);
            } else {
                order.setStatus(OrderStatus.CANCELLED);
            }

            System.err.printf("========== 주문 실패: %s (상태: %s) ==========%n%n",
                order.getOrderId(), order.getStatus());
            throw e;
        }
    }
}
```

---

### 6️⃣ 메인 실행 코드

```java
// 📁 Main.java
public class ResilientOrderSystemDemo {
    public static void main(String[] args) {
        // Circuit Breaker 설정
        CircuitBreaker paymentCircuitBreaker = new CircuitBreaker(
            "결제 서비스",
            3,      // 3회 실패 시 OPEN
            10000,  // OPEN 상태 10초 유지
            2       // HALF_OPEN에서 2회 성공 시 CLOSED
        );

        // 서비스 초기화
        InventoryService inventoryService = new InventoryService();
        PaymentService paymentService = new PaymentService(paymentCircuitBreaker);
        OrderService orderService = new OrderService(
            inventoryService,
            paymentService,
            RetryPolicy.defaultPolicy()
        );

        // 테스트 시나리오
        System.out.println("💡 초기 재고 상태:");
        System.out.println("  PROD-001: " + inventoryService.getStock("PROD-001") + "개");
        System.out.println("  PROD-002: " + inventoryService.getStock("PROD-002") + "개");
        System.out.println("  PROD-003: " + inventoryService.getStock("PROD-003") + "개");
        System.out.println();

        // 시나리오 1: 정상 주문 (재시도 후 성공)
        testScenario1(orderService);

        // 시나리오 2: 재고 부족
        testScenario2(orderService);

        // 시나리오 3: 결제 한도 초과
        testScenario3(orderService);

        // 시나리오 4: Circuit Breaker 동작 확인
        testScenario4(orderService, paymentCircuitBreaker);
    }

    /**
     * 시나리오 1: 정상 주문 (네트워크 오류 후 재시도로 성공)
     */
    private static void testScenario1(OrderService orderService) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📝 시나리오 1: 정상 주문 (재시도 후 성공)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        Order order = new Order(
            "ORD-001",
            "USER-001",
            "PROD-001",
            2,
            50000
        );

        try {
            orderService.processOrder(order);
            System.out.printf("✅ 최종 주문 상태: %s%n%n", order.getStatus());

        } catch (Exception e) {
            System.err.printf("❌ 주문 실패: %s%n%n", e.getMessage());
        }
    }

    /**
     * 시나리오 2: 재고 부족 (보상 트랜잭션 동작 안 함 - 재고 차감 자체가 실패)
     */
    private static void testScenario2(OrderService orderService) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📝 시나리오 2: 재고 부족");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        Order order = new Order(
            "ORD-002",
            "USER-001",
            "PROD-003",  // 품절 상품
            1,
            30000
        );

        try {
            orderService.processOrder(order);

        } catch (OutOfStockException e) {
            System.err.printf("❌ 예외 처리: %s%n", e.getMessage());
            System.err.printf("   재시도 가능: %s%n", e.isRetryable());
            System.err.printf("   심각도: %s%n", e.getSeverity());
            System.err.printf("❌ 최종 주문 상태: %s%n%n", order.getStatus());

        } catch (Exception e) {
            System.err.printf("❌ 주문 실패: %s%n%n", e.getMessage());
        }
    }

    /**
     * 시나리오 3: 결제 한도 초과 (재고 차감 → 결제 실패 → 재고 복구)
     */
    private static void testScenario3(OrderService orderService) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📝 시나리오 3: 결제 한도 초과 (보상 트랜잭션)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        Order order = new Order(
            "ORD-003",
            "USER-003",  // 잔액 10,000원
            "PROD-002",
            1,
            50000        // 결제 금액 50,000원 (한도 초과)
        );

        try {
            orderService.processOrder(order);

        } catch (CardLimitExceededException e) {
            System.err.printf("❌ 예외 처리: %s%n", e.getMessage());
            System.err.printf("   재시도 가능: %s%n", e.isRetryable());
            System.err.printf("   심각도: %s%n", e.getSeverity());
            System.err.printf("❌ 최종 주문 상태: %s%n%n", order.getStatus());

        } catch (Exception e) {
            System.err.printf("❌ 주문 실패: %s%n%n", e.getMessage());
        }
    }

    /**
     * 시나리오 4: Circuit Breaker 동작
     */
    private static void testScenario4(OrderService orderService,
                                       CircuitBreaker circuitBreaker) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📝 시나리오 4: Circuit Breaker 테스트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        System.out.printf("현재 Circuit Breaker 상태: %s%n",
            circuitBreaker.getState());
        System.out.println();
    }
}
```

---

### 7️⃣ 실행 결과 예시

```
💡 초기 재고 상태:
  PROD-001: 10개
  PROD-002: 5개
  PROD-003: 0개

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 시나리오 1: 정상 주문 (재시도 후 성공)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

========== 주문 처리 시작: ORD-001 ==========
🔹 [트랜잭션] 재고 차감 실행...
[재시도 1/3] 재고 차감 실행 중...
📦 재고 차감: PROD-001 (10 → 8)
✅ [트랜잭션] 재고 차감 완료
🔹 [트랜잭션] 결제 처리 실행...
[재시도 1/3] 결제 처리 실행 중...
⏳ 100ms 후 재시도... (에러: 결제 게이트웨이 연결 실패)
[재시도 2/3] 결제 처리 실행 중...
⏳ 200ms 후 재시도... (에러: 결제 게이트웨이 연결 실패)
[재시도 3/3] 결제 처리 실행 중...
💳 결제 완료: PAY-1710123456789 (잔액 100,000 → 50,000)
✅ 결제 처리 성공 (시도 횟수: 3)
✅ [트랜잭션] 결제 처리 완료
🔹 [트랜잭션] 배송 정보 생성 실행...
🚚 배송 정보 생성: ORD-001
✅ [트랜잭션] 배송 정보 생성 완료
✅ [트랜잭션] 전체 트랜잭션 성공!
========== 주문 완료: ORD-001 ==========

✅ 최종 주문 상태: COMPLETED

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 시나리오 2: 재고 부족
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

========== 주문 처리 시작: ORD-002 ==========
🔹 [트랜잭션] 재고 차감 실행...
[재시도 1/3] 재고 차감 실행 중...
❌ 재고 차감: 재시도 불가능한 예외 - 재고 부족: 상품ID PROD-003, 현재 재고 0개, 요청 수량 1개
❌ [트랜잭션] 실패: 재고 부족: 상품ID PROD-003, 현재 재고 0개, 요청 수량 1개
🔙 [트랜잭션] 롤백 시작...
🔙 [트랜잭션] 롤백 완료
========== 주문 실패: ORD-002 (상태: INVENTORY_FAILED) ==========

❌ 예외 처리: 재고 부족: 상품ID PROD-003, 현재 재고 0개, 요청 수량 1개
   재시도 가능: true
   심각도: MEDIUM
❌ 최종 주문 상태: INVENTORY_FAILED

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 시나리오 3: 결제 한도 초과 (보상 트랜잭션)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

========== 주문 처리 시작: ORD-003 ==========
🔹 [트랜잭션] 재고 차감 실행...
[재시도 1/3] 재고 차감 실행 중...
📦 재고 차감: PROD-002 (5 → 4)
✅ [트랜잭션] 재고 차감 완료
🔹 [트랜잭션] 결제 처리 실행...
[재시도 1/3] 결제 처리 실행 중...
❌ 결제 처리: 재시도 불가능한 예외 - 카드 한도 초과: 현재 한도 10,000원, 요청 금액 50,000원
❌ [트랜잭션] 실패: 카드 한도 초과: 현재 한도 10,000원, 요청 금액 50,000원
🔙 [트랜잭션] 롤백 시작...
↩️  [롤백] 재고 차감 롤백 중...
↩️  재고 복구: PROD-002 (4 → 5)
✅ [롤백] 재고 차감 롤백 완료
🔙 [트랜잭션] 롤백 완료
========== 주문 실패: ORD-003 (상태: PAYMENT_FAILED) ==========

❌ 예외 처리: 카드 한도 초과: 현재 한도 10,000원, 요청 금액 50,000원
   재시도 가능: false
   심각도: HIGH
❌ 최종 주문 상태: PAYMENT_FAILED

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 시나리오 4: Circuit Breaker 테스트
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
현재 Circuit Breaker 상태: CLOSED
```

---

### 📊 프로젝트 핵심 포인트

| 기능 | 설명 | 구현 클래스 |
|------|------|-------------|
| **커스텀 예외 계층** | 비즈니스 예외를 계층화하여 재시도 가능 여부, 심각도 관리 | `OrderException`, `PaymentException`, `InventoryException` |
| **재시도 메커니즘** | Exponential Backoff 전략으로 일시적 오류 극복 | `RetryExecutor`, `RetryPolicy` |
| **Circuit Breaker** | 연속 실패 시 자동 차단, 일정 시간 후 복구 시도 | `CircuitBreaker` |
| **트랜잭션 롤백** | 보상 트랜잭션으로 이전 단계 복구 (Saga Pattern) | `TransactionManager` |
| **예외 분류** | 재시도 가능/불가능, 심각도 수준으로 예외 분류 | `isRetryable()`, `getSeverity()` |

---

## ❓ FAQ 7선

### Q1. Checked Exception과 Unchecked Exception, 실무에서는 어떤 걸 써야 하나요?

**A1.**
- **Checked Exception**: 호출자가 복구 가능한 상황 (파일 없음, 네트워크 오류 등)
  ```java
  public void readConfig(String path) throws IOException {
      // 호출자가 파일 없음 상황을 처리할 수 있음
  }
  ```

- **Unchecked Exception (RuntimeException)**: 프로그래밍 오류 또는 복구 불가능
  ```java
  public void divide(int a, int b) {
      if (b == 0) {
          throw new IllegalArgumentException("0으로 나눌 수 없습니다");
      }
  }
  ```

**실무 트렌드**:
- Spring Framework 등 현대적인 프레임워크는 **Unchecked Exception 선호**
- 이유: Checked Exception은 메서드 시그니처를 복잡하게 만들고, 호출 체인을 오염시킴

---

### Q2. 예외를 catch하고 아무것도 안 하면 (빈 catch 블록) 왜 안 될까요?

**A2.**
```java
// ❌ 나쁜 예: 예외 무시
try {
    processPayment();
} catch (Exception e) {
    // 아무것도 안 함 - 예외가 사라짐!
}
```

**문제점**:
1. **디버깅 불가능**: 어디서 왜 실패했는지 알 수 없음
2. **조용한 실패**: 사용자는 성공했다고 생각하지만 실제로는 실패
3. **데이터 불일치**: 트랜잭션 중간에 실패했는데 이전 단계는 커밋됨

**올바른 처리**:
```java
// ✅ 좋은 예: 로그 남기기
try {
    processPayment();
} catch (Exception e) {
    logger.error("결제 처리 실패: orderId={}", orderId, e);
    throw new PaymentException("결제 처리 중 오류 발생", e);
}
```

---

### Q3. finally 블록은 항상 실행된다고 하는데, 예외가 있나요?

**A3.**
거의 항상 실행되지만, **다음 경우에는 실행 안 됨**:

1. **JVM 자체가 종료되는 경우**:
   ```java
   try {
       System.exit(0); // JVM 종료
   } finally {
       System.out.println("실행 안 됨!");
   }
   ```

2. **데몬 스레드가 종료되는 경우**
3. **무한 루프에 갇힌 경우**
4. **치명적인 JVM 오류** (OutOfMemoryError 등)

**실무 팁**: try-with-resources를 사용하면 더 안전
```java
// try-with-resources (Java 7+)
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // fis는 자동으로 닫힘
} catch (IOException e) {
    // 예외 처리
}
```

---

### Q4. 예외를 던질 때 `throw`와 `throws`의 차이가 뭔가요?

**A4.**

| 키워드 | 위치 | 역할 | 예시 |
|--------|------|------|------|
| `throw` | 메서드 **내부** | 예외를 **실제로 발생**시킴 | `throw new IllegalArgumentException();` |
| `throws` | 메서드 **시그니처** | 이 메서드가 어떤 예외를 **던질 수 있는지 선언** | `public void read() throws IOException` |

```java
// throws: 이 메서드는 IOException을 던질 수 있다고 선언
public void readFile(String path) throws IOException {
    if (!fileExists(path)) {
        // throw: 실제로 예외를 발생시킴
        throw new FileNotFoundException("파일 없음: " + path);
    }
}
```

---

### Q5. Custom Exception을 만들 때 주의할 점은?

**A5.**
**Best Practices**:

1. **의미 있는 이름**: `Exception1`, `MyException`은 안 됨
   ```java
   // ❌ 나쁜 예
   class Exception1 extends Exception { }

   // ✅ 좋은 예
   class OrderNotFoundException extends RuntimeException { }
   ```

2. **적절한 부모 클래스 선택**:
   - 복구 가능: `Exception` 상속 (Checked)
   - 프로그래밍 오류: `RuntimeException` 상속 (Unchecked)

3. **생성자 체인 제공**:
   ```java
   public class PaymentException extends RuntimeException {
       public PaymentException(String message) {
           super(message);
       }

       public PaymentException(String message, Throwable cause) {
           super(message, cause); // 원인 예외 보존
       }
   }
   ```

4. **추가 정보 제공**:
   ```java
   public class OutOfStockException extends RuntimeException {
       private final String productId;
       private final int availableStock;

       // Getter 제공
   }
   ```

---

### Q6. 예외를 다시 던질 때 (rethrow) 주의할 점은?

**A6.**
```java
// ❌ 나쁜 예: 원인 예외 손실
try {
    callExternalAPI();
} catch (IOException e) {
    throw new RuntimeException("API 호출 실패"); // 원인 손실!
}

// ✅ 좋은 예: 원인 예외 보존
try {
    callExternalAPI();
} catch (IOException e) {
    throw new RuntimeException("API 호출 실패", e); // 원인 보존
}
```

**원인 예외를 보존하는 이유**:
- 스택 트레이스를 따라가며 디버깅 가능
- 루트 원인(Root Cause) 파악 가능

---

### Q7. try-catch를 남발하면 성능에 영향이 있나요?

**A7.**
**결론**: **예외가 발생하지 않으면 성능 영향 거의 없음**

```java
// try-catch 자체는 성능 영향 미미
for (int i = 0; i < 1000000; i++) {
    try {
        normalOperation(); // 예외 안 발생 시 거의 동일
    } catch (Exception e) {
        // ...
    }
}
```

**BUT**, **예외가 실제로 발생하면 비용이 큼**:
- 스택 트레이스 생성 비용
- 예외 객체 생성 비용

**실무 가이드**:
1. **정상 흐름 제어용으로 예외 사용 금지**:
   ```java
   // ❌ 나쁜 예
   try {
       int value = map.get(key);
   } catch (NullPointerException e) {
       value = defaultValue;
   }

   // ✅ 좋은 예
   int value = map.getOrDefault(key, defaultValue);
   ```

2. **예외는 진짜 예외적인 상황에만 사용**

---

## 🎤 면접 질문 12선

### 주니어 레벨 (7문제)

#### Q1. Checked Exception과 Unchecked Exception의 차이를 설명하세요.

**모범 답변**:
- **Checked Exception**: 컴파일 시점에 확인되며, 반드시 처리(try-catch) 또는 선언(throws)해야 합니다. 예: `IOException`, `SQLException`
- **Unchecked Exception**: `RuntimeException`을 상속하며, 컴파일러가 강제하지 않습니다. 예: `NullPointerException`, `IllegalArgumentException`

```java
// Checked Exception
public void readFile() throws IOException { // 선언 필수
    FileReader fr = new FileReader("file.txt");
}

// Unchecked Exception
public void divide(int a, int b) { // 선언 안 해도 됨
    if (b == 0) {
        throw new IllegalArgumentException();
    }
}
```

**추가 설명**:
- Checked Exception은 복구 가능한 상황, Unchecked는 프로그래밍 오류에 사용

---

#### Q2. try-catch-finally의 실행 순서를 설명하세요.

**모범 답변**:
1. **try 블록** 실행
2. 예외 발생 시 **catch 블록** 실행
3. **finally 블록**은 항상 실행 (return 전에도 실행)

```java
public int test() {
    try {
        System.out.println("1. try");
        return 10;
    } catch (Exception e) {
        System.out.println("2. catch");
        return 20;
    } finally {
        System.out.println("3. finally"); // return 전에 실행!
    }
}

// 출력:
// 1. try
// 3. finally
// 반환값: 10
```

**주의점**: finally에서 return하면 try/catch의 return을 덮어씀 (권장하지 않음)

---

#### Q3. throw와 throws의 차이는 무엇인가요?

**모범 답변**:
- **throw**: 메서드 내부에서 예외를 실제로 발생시킬 때 사용
- **throws**: 메서드 시그니처에서 이 메서드가 던질 수 있는 예외를 선언

```java
public void validateAge(int age) throws InvalidAgeException {
    if (age < 0) {
        throw new InvalidAgeException("나이는 0 이상이어야 합니다");
    }
}
```

---

#### Q4. 예외를 catch할 때 여러 개를 한 번에 처리하는 방법은?

**모범 답변**:
**Java 7 이전**:
```java
try {
    // ...
} catch (IOException e) {
    logger.error("IO 오류", e);
} catch (SQLException e) {
    logger.error("DB 오류", e);
}
```

**Java 7 이후 (Multi-catch)**:
```java
try {
    // ...
} catch (IOException | SQLException e) {
    logger.error("오류 발생", e);
}
```

**주의**: Multi-catch에서 `e`는 `final`로 간주됨

---

#### Q5. try-with-resources는 무엇이고 왜 사용하나요?

**모범 답변**:
**Java 7부터 도입**된 자동 자원 관리 기능입니다.

**기존 방식 (finally 사용)**:
```java
FileInputStream fis = null;
try {
    fis = new FileInputStream("file.txt");
    // ...
} catch (IOException e) {
    // ...
} finally {
    if (fis != null) {
        try {
            fis.close(); // 수동으로 닫기
        } catch (IOException e) {
            // ...
        }
    }
}
```

**try-with-resources**:
```java
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // ...
} catch (IOException e) {
    // ...
}
// fis는 자동으로 닫힘!
```

**장점**:
- 코드 간결
- 자원 누수 방지
- `AutoCloseable` 인터페이스 구현 객체에 사용 가능

---

#### Q6. NullPointerException을 피하는 방법은?

**모범 답변**:
1. **null 체크**:
   ```java
   if (user != null) {
       user.getName();
   }
   ```

2. **Optional 사용** (Java 8+):
   ```java
   Optional<User> optUser = findUser(id);
   String name = optUser.map(User::getName).orElse("Unknown");
   ```

3. **기본값 제공 메서드 사용**:
   ```java
   String value = map.getOrDefault(key, "default");
   ```

4. **Null Object Pattern**:
   ```java
   public static final User EMPTY_USER = new User("", 0);
   ```

5. **어노테이션 사용**:
   ```java
   public void process(@NonNull User user) { }
   ```

---

#### Q7. 예외 처리의 Best Practice 3가지를 말하세요.

**모범 답변**:
1. **구체적인 예외 잡기**:
   ```java
   // ❌ 나쁜 예
   catch (Exception e) { }

   // ✅ 좋은 예
   catch (FileNotFoundException e) { }
   ```

2. **원인 예외 보존**:
   ```java
   catch (IOException e) {
       throw new BusinessException("파일 처리 실패", e);
   }
   ```

3. **빈 catch 블록 금지**:
   ```java
   catch (Exception e) {
       logger.error("오류 발생", e);
       throw new RuntimeException(e);
   }
   ```

---

### 중급 레벨 (5문제)

#### Q8. 예외 처리에서 Transaction Rollback은 어떻게 구현하나요?

**모범 답변**:
**Saga Pattern의 보상 트랜잭션**을 사용합니다.

```java
List<CompensatableAction> executedActions = new ArrayList<>();

try {
    for (Action action : actions) {
        action.execute();
        executedActions.add(action);
    }
} catch (Exception e) {
    // 역순으로 롤백
    Collections.reverse(executedActions);
    for (Action action : executedActions) {
        action.compensate(); // 이전 상태로 복구
    }
    throw e;
}
```

**실무 예시**:
- 주문 처리: 재고 차감 → 결제 → 배송 정보 생성
- 결제 실패 시 재고를 다시 증가시킴 (보상)

---

#### Q9. Circuit Breaker 패턴이 무엇이고 왜 필요한가요?

**모범 답변**:
**연속된 실패를 감지하여 일정 시간 동안 요청을 차단**하는 패턴입니다.

**동작 원리**:
1. **CLOSED** (정상): 모든 요청 허용, 실패 카운트
2. **OPEN** (차단): 임계값 초과 시 모든 요청 즉시 거부
3. **HALF_OPEN** (테스트): 일정 시간 후 일부 요청 허용
4. 성공 시 CLOSED로 복귀, 실패 시 다시 OPEN

**필요한 이유**:
- **Cascading Failure 방지**: 장애가 전파되는 것을 막음
- **빠른 실패 (Fail Fast)**: 응답 없는 서비스를 계속 호출하지 않음
- **복구 시간 확보**: 장애 서비스가 복구될 시간을 제공

**실무 예시**:
```java
// Netflix Hystrix, Resilience4j 등의 라이브러리
@HystrixCommand(fallbackMethod = "defaultUser")
public User getUser(String userId) {
    return externalAPI.getUser(userId);
}

public User defaultUser(String userId) {
    return new User("Guest", "guest@example.com");
}
```

---

#### Q10. 재시도 로직을 구현할 때 고려해야 할 점은?

**모범 답변**:
1. **재시도 가능 여부 판단**:
   - 일시적 오류 (네트워크): 재시도 O
   - 영구적 오류 (잘못된 파라미터): 재시도 X

2. **최대 재시도 횟수 제한**:
   ```java
   int maxAttempts = 3;
   ```

3. **Backoff 전략**:
   - **Fixed Delay**: 고정 간격 (100ms, 100ms, 100ms)
   - **Exponential Backoff**: 지수 증가 (100ms, 200ms, 400ms)
   - **Jitter**: 랜덤 요소 추가 (동시 재시도 방지)

4. **멱등성 (Idempotency) 보장**:
   - 같은 요청을 여러 번 해도 결과가 동일해야 함
   ```java
   // ✅ 멱등: PUT (업데이트)
   updateUser(userId, newData);

   // ❌ 비멱등: POST (생성)
   createUser(userData); // 재시도 시 중복 생성!
   ```

5. **타임아웃 설정**:
   ```java
   try {
       Future<Result> future = executor.submit(task);
       return future.get(5, TimeUnit.SECONDS);
   } catch (TimeoutException e) {
       // 재시도
   }
   ```

---

#### Q11. Custom Exception 계층 구조를 어떻게 설계하나요?

**모범 답변**:
**도메인별로 최상위 예외를 만들고, 구체적인 예외를 상속**시킵니다.

```java
// 최상위 비즈니스 예외
public abstract class BusinessException extends RuntimeException {
    private final String errorCode;

    public abstract boolean isRetryable();
    public abstract SeverityLevel getSeverity();
}

// 도메인별 예외
public class OrderException extends BusinessException { }
public class PaymentException extends BusinessException { }

// 구체적인 예외
public class OrderNotFoundException extends OrderException { }
public class OutOfStockException extends OrderException { }
public class CardLimitExceededException extends PaymentException { }
```

**설계 원칙**:
1. **의미 있는 계층 구조**: 예외를 그룹화하여 처리 가능
2. **추가 정보 제공**: errorCode, 타임스탬프, 관련 데이터
3. **재시도 가능 여부**: `isRetryable()` 메서드로 판단
4. **심각도 수준**: 로깅 및 알림 정책 결정

---

#### Q12. 예외 처리와 로깅을 어떻게 연계하나요?

**모범 답변**:
**계층별로 역할을 분리**합니다.

```java
// ❌ 나쁜 예: 모든 계층에서 로깅
public void serviceMethod() {
    try {
        repositoryMethod();
    } catch (Exception e) {
        logger.error("Service 오류", e); // 중복 로그!
        throw e;
    }
}

public void repositoryMethod() {
    try {
        // DB 작업
    } catch (SQLException e) {
        logger.error("Repository 오류", e); // 중복 로그!
        throw new DataAccessException(e);
    }
}
```

**✅ 좋은 예: 최상위에서만 로깅**:
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<?> handleBusinessException(BusinessException e) {
        // 여기서만 로깅
        if (e.getSeverity() == SeverityLevel.HIGH) {
            logger.error("심각한 오류 발생", e);
            alertService.sendAlert(e);
        } else {
            logger.warn("비즈니스 예외", e);
        }

        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(new ErrorResponse(e.getErrorCode(), e.getMessage()));
    }
}
```

**로깅 전략**:
| 심각도 | 로그 레벨 | 추가 조치 |
|--------|-----------|-----------|
| LOW | INFO | 없음 |
| MEDIUM | WARN | 없음 |
| HIGH | ERROR | 이메일 알림 |
| CRITICAL | ERROR | 즉시 SMS/전화 |

**MDC (Mapped Diagnostic Context) 활용**:
```java
MDC.put("userId", userId);
MDC.put("orderId", orderId);
logger.error("주문 처리 실패", e);
// 로그: [userId=123] [orderId=ORD-001] 주문 처리 실패
MDC.clear();
```

---

## 🎯 마무리

이 프로젝트를 통해 다음을 배웠습니다:

✅ **커스텀 예외 계층 구조** - 비즈니스 예외를 체계적으로 관리
✅ **재시도 메커니즘** - Exponential Backoff로 일시적 오류 극복
✅ **Circuit Breaker 패턴** - 장애 전파 방지 및 빠른 실패
✅ **트랜잭션 롤백** - 보상 트랜잭션으로 데이터 일관성 보장
✅ **예외 처리 Best Practices** - 실무에서 사용하는 전략들

**다음 학습 추천**:
1. Spring의 `@Transactional` 어노테이션 학습
2. Resilience4j 라이브러리로 Circuit Breaker 실습
3. 분산 트랜잭션 (Saga Pattern) 심화 학습

---

**📚 참고 자료**:
- Effective Java 3판 - Item 69~77 (예외 처리)
- Spring Framework 공식 문서 - Exception Handling
- Resilience4j 라이브러리 문서
- Martin Fowler - Circuit Breaker Pattern

**🔗 관련 챕터**:
- [23-1. 예외 처리 Part 1 - 실생활 비유](23-1-예외-처리-Part1.md)
- [23-2. 예외 처리 Part 2 - 기업 사례](23-2-예외-처리-Part2.md)

---

행운을 빕니다! 🍀
