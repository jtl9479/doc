# 24. 리소스 제한 및 관리

## 목차
1. [리소스 제한의 중요성](#리소스-제한의-중요성)
2. [CPU 제한](#cpu-제한)
3. [메모리 제한](#메모리-제한)
4. [디스크 I/O 제한](#디스크-io-제한)
5. [네트워크 대역폭 제한](#네트워크-대역폭-제한)
6. [PID 제한](#pid-제한)
7. [리소스 예약 (Reservation)](#리소스-예약-reservation)
8. [실전 예제: LK-Trade 리소스 설정](#실전-예제-lk-trade-리소스-설정)
9. [리소스 모니터링](#리소스-모니터링)
10. [트러블슈팅](#트러블슈팅)

---

## 리소스 제한의 중요성

### 왜 리소스를 제한해야 하나?

**실생활 비유**: 아파트 전기 사용량 제한

```
제한 없는 경우:
- 201호: 에어컨 10대 가동
- 202호: 정상 사용
- 203호: 정상 사용
→ 전체 아파트 정전! ⚡

제한 있는 경우:
- 201호: 최대 5kW 제한 (차단기)
- 202호: 최대 5kW 제한
- 203호: 최대 5kW 제한
→ 201호만 차단, 다른 집은 정상 ✅
```

**Docker 환경**:
```
제한 없는 경우:
Container A: CPU 100% + 메모리 8GB 사용
→ 다른 컨테이너들 느려짐/중단 ❌

제한 있는 경우:
Container A: CPU 최대 50% + 메모리 2GB
→ 다른 컨테이너들 정상 작동 ✅
```

### 리소스 제한의 이점

```
┌────────────────────┬──────────────────────────────────┐
│     이점           │            설명                  │
├────────────────────┼──────────────────────────────────┤
│ 안정성 향상        │ 한 컨테이너가 전체 시스템        │
│                    │ 마비시키는 것 방지               │
├────────────────────┼──────────────────────────────────┤
│ 공평한 리소스 분배 │ 모든 컨테이너가 필요한           │
│                    │ 리소스 보장                      │
├────────────────────┼──────────────────────────────────┤
│ 비용 예측 가능     │ 클라우드 환경에서 비용           │
│                    │ 초과 방지                        │
├────────────────────┼──────────────────────────────────┤
│ 성능 예측 가능     │ 일정한 성능 보장                 │
├────────────────────┼──────────────────────────────────┤
│ 보안 강화          │ 리소스 고갈 공격(DoS) 방어       │
└────────────────────┴──────────────────────────────────┘
```

---

## CPU 제한

### CPU 제한 방식

#### 1. --cpus (추천)

```bash
# 2개 CPU 코어 사용 제한
docker run -d --cpus="2.0" nginx

# 0.5개 CPU 코어 (50%)
docker run -d --cpus="0.5" nginx

# docker-compose.yml
services:
  user-service:
    image: user-service:latest
    cpus: 2.0  # 2 CPU 코어
```

**동작 원리**:
```
호스트: 8 CPU 코어
컨테이너: --cpus="2.0"

→ 컨테이너는 최대 2 CPU 코어만 사용 가능
→ 8 코어 모두 접근 가능하지만, 총 사용량은 2 코어로 제한
```

#### 2. --cpu-shares (상대적 가중치)

```bash
# 기본값: 1024
docker run -d --cpu-shares=512 nginx   # 50% 가중치
docker run -d --cpu-shares=1024 nginx  # 100% 가중치 (기본)
docker run -d --cpu-shares=2048 nginx  # 200% 가중치
```

**동작 원리**:
```
컨테이너 A: --cpu-shares=1024
컨테이너 B: --cpu-shares=2048
컨테이너 C: --cpu-shares=1024

CPU 경합 시:
- 컨테이너 A: 25% (1024 / 4096)
- 컨테이너 B: 50% (2048 / 4096)
- 컨테이너 C: 25% (1024 / 4096)

CPU 여유 시:
- 모든 컨테이너가 필요한 만큼 사용 가능
```

#### 3. --cpuset-cpus (특정 코어 할당)

```bash
# CPU 0, 1번만 사용
docker run -d --cpuset-cpus="0,1" nginx

# CPU 0-3번 사용
docker run -d --cpuset-cpus="0-3" nginx

# docker-compose.yml
services:
  user-service:
    cpuset: "0,1"  # CPU 0, 1번 코어만
```

**사용 사례**:
```
NUMA 시스템에서 성능 최적화:
- CPU 0-7: NUMA 노드 0 (메모리 뱅크 0 가까움)
- CPU 8-15: NUMA 노드 1 (메모리 뱅크 1 가까움)

→ 컨테이너를 특정 NUMA 노드에 고정
```

### CPU 제한 비교

```yaml
# docker-compose.yml

services:
  # 1. 절대적 제한 (추천)
  web-server:
    image: nginx
    cpus: 1.5  # 최대 1.5 CPU 코어

  # 2. 상대적 가중치
  background-job:
    image: worker
    cpu_shares: 512  # 낮은 우선순위

  # 3. 특정 코어 할당
  real-time-service:
    image: rt-service
    cpuset: "0,1"  # CPU 0, 1번 전용
```

### CPU 사용량 모니터링

```bash
# 실시간 CPU 사용량
docker stats

# CPU 제한 확인
docker inspect container_id | jq '.[0].HostConfig.NanoCpus'
# 2000000000 = 2.0 CPU

# 컨테이너 내부에서
docker exec container_id cat /sys/fs/cgroup/cpu/cpu.cfs_quota_us
docker exec container_id cat /sys/fs/cgroup/cpu/cpu.cfs_period_us
# quota / period = CPU 코어 수
```

---

## 메모리 제한

### 메모리 제한 옵션

#### 1. --memory (하드 리미트)

```bash
# 512MB 제한
docker run -d --memory="512m" nginx

# 2GB 제한
docker run -d --memory="2g" nginx

# docker-compose.yml
services:
  user-service:
    image: user-service:latest
    mem_limit: 1g  # 1GB
```

**동작 원리**:
```
메모리 제한: 512MB
프로세스가 512MB 초과 시도:
→ OOM Killer 작동
→ 컨테이너 강제 종료 (Exit Code 137)
```

#### 2. --memory-reservation (소프트 리미트)

```bash
# 예약: 256MB, 최대: 512MB
docker run -d \
  --memory="512m" \
  --memory-reservation="256m" \
  nginx
```

**동작 원리**:
```
정상 상황:
- 256MB 보장받음
- 필요 시 512MB까지 사용 가능

메모리 부족 상황:
- 256MB까지 보장
- 256MB~512MB는 회수될 수 있음
```

#### 3. --memory-swap (스왑 포함 제한)

```bash
# 메모리: 512MB, 스왑: 512MB (총 1GB)
docker run -d \
  --memory="512m" \
  --memory-swap="1g" \
  nginx

# 스왑 비활성화
docker run -d \
  --memory="512m" \
  --memory-swap="512m" \
  nginx
```

**동작 원리**:
```
--memory="512m" --memory-swap="1g"
→ 물리 메모리: 512MB
→ 스왑: 512MB (1g - 512m)

--memory="512m" --memory-swap="512m"
→ 물리 메모리: 512MB
→ 스왑: 0 (스왑 비활성화)
```

### OOM (Out of Memory) 동작 설정

```bash
# OOM Killer 비활성화 (위험!)
docker run -d \
  --memory="512m" \
  --oom-kill-disable \
  nginx

# OOM 점수 조정 (우선순위)
docker run -d \
  --memory="512m" \
  --oom-score-adj=500 \
  nginx
```

```yaml
# docker-compose.yml

services:
  critical-service:
    image: critical:latest
    mem_limit: 1g
    oom_score_adj: -500  # 낮을수록 종료 우선순위 낮음

  non-critical-service:
    image: worker:latest
    mem_limit: 512m
    oom_score_adj: 500   # 높을수록 먼저 종료됨
```

### 메모리 사용량 모니터링

```bash
# 실시간 메모리 사용량
docker stats

# 메모리 제한 확인
docker inspect container_id | jq '.[0].HostConfig.Memory'

# 컨테이너 내부에서
docker exec container_id cat /sys/fs/cgroup/memory/memory.limit_in_bytes
docker exec container_id cat /sys/fs/cgroup/memory/memory.usage_in_bytes
```

### JVM 메모리 설정 (Java/Kotlin)

```dockerfile
# Dockerfile

FROM eclipse-temurin:21-jre-alpine

# 컨테이너 메모리 인식 (JDK 8u191+)
ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:InitialRAMPercentage=50.0"

CMD ["java", "-jar", "app.jar"]
```

```yaml
# docker-compose.yml

services:
  user-service:
    image: user-service:latest
    mem_limit: 2g
    environment:
      # JVM이 전체 2GB 인식
      # MaxRAMPercentage=75.0 → 힙 최대 1.5GB
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0
```

---

## 디스크 I/O 제한

### Block I/O 가중치

```bash
# 기본값: 500
docker run -d --blkio-weight=300 nginx  # 낮은 우선순위
docker run -d --blkio-weight=700 nginx  # 높은 우선순위
```

### 읽기/쓰기 속도 제한

```bash
# 읽기 속도: 10MB/s
docker run -d \
  --device-read-bps /dev/sda:10mb \
  nginx

# 쓰기 속도: 5MB/s
docker run -d \
  --device-write-bps /dev/sda:5mb \
  nginx

# docker-compose.yml
services:
  database:
    image: postgres:15
    device_read_bps:
      - path: /dev/sda
        rate: 50mb
    device_write_bps:
      - path: /dev/sda
        rate: 20mb
```

### IOPS 제한

```bash
# 읽기 IOPS: 100
docker run -d \
  --device-read-iops /dev/sda:100 \
  nginx

# 쓰기 IOPS: 50
docker run -d \
  --device-write-iops /dev/sda:50 \
  nginx
```

---

## 네트워크 대역폭 제한

Docker 자체는 네트워크 대역폭 제한 기능이 없지만, Linux의 `tc` (traffic control)를 사용할 수 있습니다.

### tc를 이용한 대역폭 제한

```bash
#!/bin/bash
# scripts/limit-bandwidth.sh

CONTAINER_ID=$1
BANDWIDTH=${2:-1mbit}  # 기본 1Mbps

# 컨테이너 네트워크 인터페이스 찾기
CONTAINER_PID=$(docker inspect -f '{{.State.Pid}}' $CONTAINER_ID)
CONTAINER_NETNS="docker-${CONTAINER_ID}"

# tc 규칙 추가
sudo tc qdisc add dev veth_${CONTAINER_PID} root tbf \
    rate $BANDWIDTH \
    burst 32kbit \
    latency 400ms

echo "컨테이너 $CONTAINER_ID 대역폭을 $BANDWIDTH로 제한했습니다."
```

### Docker Network Plugin 사용

```yaml
# docker-compose.yml

services:
  user-service:
    image: user-service:latest
    networks:
      - limited-network

networks:
  limited-network:
    driver: bridge
    driver_opts:
      com.docker.network.driver.mtu: 1500
```

---

## PID 제한

### PID (프로세스 수) 제한

```bash
# 최대 100개 프로세스
docker run -d --pids-limit=100 nginx

# docker-compose.yml
services:
  user-service:
    image: user-service:latest
    pids_limit: 200
```

**사용 사례**:
```
포크 폭탄(Fork Bomb) 방어:
무한히 프로세스를 생성하는 악의적 코드

while true; do
    bash &
done

→ PID 제한으로 방어
```

---

## 리소스 예약 (Reservation)

### CPU 예약

```yaml
# docker-compose.yml

services:
  user-service:
    image: user-service:latest
    deploy:
      resources:
        limits:
          cpus: '2.0'      # 최대 2 CPU
        reservations:
          cpus: '1.0'      # 최소 1 CPU 보장
```

### 메모리 예약

```yaml
services:
  database:
    image: postgres:15
    deploy:
      resources:
        limits:
          memory: 4G       # 최대 4GB
        reservations:
          memory: 2G       # 최소 2GB 보장
```

**동작 원리**:
```
Reservations (예약):
- 스케줄러가 컨테이너 배치 시 고려
- 해당 리소스가 없으면 배치 안함

Limits (제한):
- 실제 런타임에서 강제 제한
- 초과 시 제한/종료

예시:
reservations: 2GB, limits: 4GB
→ 최소 2GB 확보 후 시작
→ 최대 4GB까지 사용 가능
```

---

## 실전 예제: LK-Trade 리소스 설정

### 프로덕션 환경 리소스 설정

```yaml
# docker-compose.prod.yml

version: '3.8'

x-resource-limits: &standard-limits
  cpus: '1.0'
  mem_limit: 1g
  mem_reservation: 512m

x-resource-limits-high: &high-limits
  cpus: '2.0'
  mem_limit: 2g
  mem_reservation: 1g

services:
  # 인프라 (높은 리소스)
  postgres:
    image: postgres:15-alpine
    <<: *high-limits
    environment:
      - POSTGRES_DB=lktrade
      - POSTGRES_USER=lkuser
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
    shm_size: 256m  # 공유 메모리

  redis:
    image: redis:7-alpine
    cpus: 0.5
    mem_limit: 512m
    mem_reservation: 256m
    command: >
      redis-server
      --maxmemory 400mb
      --maxmemory-policy allkeys-lru
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M

  # User Service (표준 리소스)
  user-service:
    image: ${REGISTRY}/user-service:${VERSION}
    <<: *standard-limits
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Account Service (표준 리소스)
  account-service:
    image: ${REGISTRY}/account-service:${VERSION}
    <<: *standard-limits
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  # Trade Service (높은 리소스 - 실시간 거래)
  trade-service:
    image: ${REGISTRY}/trade-service:${VERSION}
    <<: *high-limits
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '1.0'
          memory: 1G
    # 높은 우선순위 (OOM 시 마지막에 종료)
    oom_score_adj: -500

  # AI Service (매우 높은 리소스 - GPT 호출)
  ai-service:
    image: ${REGISTRY}/ai-service:${VERSION}
    cpus: 2.0
    mem_limit: 3g
    mem_reservation: 2g
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=80.0
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '2.0'
          memory: 3G
        reservations:
          cpus: '1.0'
          memory: 2G

  # Scraper Service (낮은 리소스 - 백그라운드 작업)
  scraper-service:
    image: ${REGISTRY}/scraper-service:${VERSION}
    cpus: 0.5
    mem_limit: 512m
    mem_reservation: 256m
    cpu_shares: 512  # 낮은 우선순위
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - JAVA_OPTS=-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0
    deploy:
      replicas: 1
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
    # 낮은 우선순위 (OOM 시 먼저 종료)
    oom_score_adj: 500

  # Nginx (낮은 리소스)
  nginx:
    image: nginx:alpine
    cpus: 0.5
    mem_limit: 256m
    ports:
      - "80:80"
      - "443:443"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.25'
          memory: 128M

volumes:
  postgres-data:
```

### 개발 환경 리소스 설정

```yaml
# docker-compose.dev.yml

version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    # 개발 환경: 제한 없음 (빠른 개발)
    shm_size: 128m

  redis:
    image: redis:7-alpine
    # 개발 환경: 제한 없음

  user-service:
    build:
      context: ./modules/user
      dockerfile: Dockerfile.dev
    # 개발 환경: 가벼운 제한만
    mem_limit: 2g
    # OOM 방지용, 핫 리로드 위한 여유 공간
```

---

## 리소스 모니터링

### 리소스 사용량 대시보드

```bash
#!/bin/bash
# scripts/resource-monitor.sh

echo "📊 LK-Trade 리소스 사용량"
echo "========================================"

# 헤더
printf "%-20s %8s %12s %12s\n" "SERVICE" "CPU %" "MEMORY" "NET I/O"
echo "----------------------------------------"

# 각 서비스 리소스 확인
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" | tail -n +2 | while read line; do
    printf "%s\n" "$line"
done

echo "========================================"

# 전체 요약
echo ""
echo "전체 리소스 사용량:"
docker stats --no-stream --format "CPU: {{.CPUPerc}}, Memory: {{.MemUsage}}" | \
    awk '{cpu+=$2; mem+=$4} END {print "  Total CPU: " cpu "%, Total Memory: " mem "MB"}'
```

### Prometheus 메트릭

```yaml
# prometheus.yml

scrape_configs:
  - job_name: 'cadvisor'
    static_configs:
      - targets: ['cadvisor:8080']

  - job_name: 'node-exporter'
    static_configs:
      - targets: ['node-exporter:9100']
```

### Grafana 대시보드 예제

```json
{
  "dashboard": {
    "title": "LK-Trade 리소스 모니터링",
    "panels": [
      {
        "title": "CPU 사용량",
        "targets": [
          {
            "expr": "rate(container_cpu_usage_seconds_total[5m])"
          }
        ]
      },
      {
        "title": "메모리 사용량",
        "targets": [
          {
            "expr": "container_memory_usage_bytes"
          }
        ]
      },
      {
        "title": "네트워크 I/O",
        "targets": [
          {
            "expr": "rate(container_network_receive_bytes_total[5m])"
          }
        ]
      }
    ]
  }
}
```

---

## 트러블슈팅

### 문제 1: OOM Killed (Exit Code 137)

**증상**:
```bash
$ docker ps -a
CONTAINER ID   STATUS                     NAMES
a1b2c3d4e5f6   Exited (137) 1 minute ago  user-service
```

**진단**:
```bash
# 1. 로그 확인
docker logs user-service | tail -50

# 2. 메모리 제한 확인
docker inspect user-service | jq '.[0].HostConfig.Memory'

# 3. OOMKilled 확인
docker inspect user-service | jq '.[0].State.OOMKilled'
# true
```

**해결**:
```yaml
# docker-compose.yml
services:
  user-service:
    mem_limit: 2g  # 1g → 2g 증가
    environment:
      - JAVA_OPTS=-XX:MaxRAMPercentage=75.0  # 80 → 75로 감소
```

### 문제 2: CPU 제한으로 인한 느린 응답

**증상**:
```
API 응답 시간이 평소보다 5배 느림
```

**진단**:
```bash
# CPU 사용률 확인
docker stats user-service

# CPU 제한 확인
docker inspect user-service | jq '.[0].HostConfig.NanoCpus'
```

**해결**:
```yaml
services:
  user-service:
    cpus: 2.0  # 1.0 → 2.0 증가
```

### 문제 3: 디스크 I/O 병목

**증상**:
```
데이터베이스 쿼리가 매우 느림
```

**진단**:
```bash
# I/O 통계
docker stats postgres --no-stream --format "{{.BlockIO}}"

# I/O 제한 확인
docker inspect postgres | jq '.[0].HostConfig.BlkioDeviceReadBps'
```

**해결**:
```yaml
services:
  postgres:
    # I/O 제한 제거 또는 증가
    device_read_bps:
      - path: /dev/sda
        rate: 100mb  # 50mb → 100mb
```

---

## 리소스 제한 베스트 프랙티스

### 1. 프로덕션 환경

```yaml
services:
  # 핵심 서비스: 높은 리소스 + 우선순위
  core-service:
    cpus: 2.0
    mem_limit: 2g
    mem_reservation: 1g
    oom_score_adj: -500  # 낮은 OOM 우선순위

  # 백그라운드 서비스: 낮은 리소스 + 우선순위
  worker:
    cpus: 0.5
    mem_limit: 512m
    cpu_shares: 512
    oom_score_adj: 500   # 높은 OOM 우선순위
```

### 2. 개발 환경

```yaml
services:
  # 개발 환경: 관대한 제한 (편의성)
  dev-service:
    mem_limit: 4g  # 넉넉하게
    # CPU 제한 없음 (빠른 빌드)
```

### 3. 테스트 환경

```yaml
services:
  # 테스트 환경: 프로덕션과 동일한 제한 (정확한 테스트)
  test-service:
    cpus: 1.0
    mem_limit: 1g
```

---

## 다음 단계

### 25. 컨테이너 성능 모니터링
- docker stats 활용
- cAdvisor 설치
- Prometheus + Grafana 연동

### 학습 자료

**리소스 관리**:
- [Docker Resource Constraints](https://docs.docker.com/config/containers/resource_constraints/)
- [cgroups Documentation](https://www.kernel.org/doc/Documentation/cgroup-v1/)

**모니터링**:
- [cAdvisor](https://github.com/google/cadvisor)
- [Prometheus](https://prometheus.io/docs/introduction/overview/)

---

**축하합니다! 🎉** Docker 리소스 제한과 관리를 마스터했습니다!