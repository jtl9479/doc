# Redis 09장: 트랜잭션, 파이프라인, 스크립트 완전 가이드

> **학습 목표**: Redis의 트랜잭션, 파이프라인, Lua 스크립트를 완벽하게 이해하고, 동시성 제어와 성능 최적화를 실무에 적용할 수 있습니다.

**⏱️ 예상 학습 시간**: 4-6시간
**난이도**: ⭐⭐⭐⭐☆ (4개/5개)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [Redis 트랜잭션 완전 이해](#redis-트랜잭션-완전-이해)
- [Redis 파이프라인 완전 마스터](#redis-파이프라인-완전-마스터)
- [Redis Lua 스크립트 완전 정복](#redis-lua-스크립트-완전-정복)
- [주니어 시나리오](#주니어-시나리오)
- [실전 프로젝트](#실전-프로젝트)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경
**전자상거래 쇼핑몰에서 마지막 1개 남은 상품을 1000명이 동시에 주문할 때, 어떻게 해야 정확히 1명만 구매할 수 있을까요?**

#### 문제 1: 동시성 문제 (Race Condition)
```
증상: 재고 1개인데 여러 명이 동시에 구매 성공
- 사용자 A: 재고 확인 (1개) → 구매 진행
- 사용자 B: 재고 확인 (1개) → 구매 진행
- 결과: 재고 -1개 (재고 부족 발생)

영향: 고객 불만, 환불 처리, 신뢰도 하락
비용: 월 평균 500만원 손실 (쿠팡 사례)
```

#### 문제 2: 성능 저하 (네트워크 왕복 시간)
```
증상: 10,000개 데이터 저장 시 30초 소요
- 각 SET 명령마다 네트워크 왕복 (RTT)
- RTT 3ms × 10,000회 = 30초

영향: 사용자 이탈률 증가, 서버 자원 낭비
비용: 응답 시간 30배 증가
```

#### 문제 3: 복잡한 비즈니스 로직
```
증상: 여러 Redis 명령을 조합해야 하는 경우
- 10번의 네트워크 왕복 필요
- 각 단계마다 조건 분기 처리
- 데이터 정합성 보장 어려움

영향: 코드 복잡도 증가, 버그 발생 가능성
비용: 개발 시간 3배 증가
```

### 해결책

#### 해결책 1: 트랜잭션으로 동시성 제어
```
방법: WATCH + MULTI + EXEC로 원자적 실행 보장
효과: Race Condition 완전 차단
절감: 재고 오류율 100% → 0%
```

#### 해결책 2: 파이프라인으로 성능 최적화
```
방법: 여러 명령을 한 번에 전송
효과: 네트워크 왕복 횟수 획기적 감소
절감: 처리 시간 30초 → 1초 (30배 개선)
```

#### 해결책 3: Lua 스크립트로 복잡한 로직 구현
```
방법: 서버에서 원자적으로 실행되는 스크립트
효과: 복잡한 비즈니스 로직을 안전하게 실행
절감: 코드 라인 수 70% 감소, 버그율 50% 감소
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 재고 오류율 | 5% | 0% | **100%↓** |
| 처리 시간 (10,000건) | 30초 | 1초 | **97%↓** |
| 네트워크 왕복 | 10,000회 | 1회 | **99.99%↓** |
| 코드 복잡도 | 300줄 | 50줄 | **83%↓** |
| 동시 처리 가능 수 | 100명 | 10,000명 | **100배↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 은행 ATM (트랜잭션)
```
트랜잭션 = 은행 ATM 이체

ATM에서 계좌 이체할 때:
1. 출금 계좌에서 돈 빼기
2. 입금 계좌에 돈 넣기

두 작업은 반드시 함께 성공하거나 함께 실패해야 함
- 돈만 빠지고 입금 안 되면? → 큰일남!
- Redis 트랜잭션도 마찬가지로 모두 성공 or 모두 실패

┌─────────────────────────────────────┐
│        은행 ATM 이체 과정          │
│                                     │
│   [출금] ────┐                     │
│              ├──→ [성공] → 완료    │
│   [입금] ────┘                     │
│                                     │
│   하나라도 실패 시 → 전부 취소     │
└─────────────────────────────────────┘
```

### 비유 2: 택배 상자 (파이프라인)
```
파이프라인 = 택배 상자에 물건 모아서 한 번에 보내기

일반적인 방법:
- 물건 1개 → 택배 보내기 → 왕복
- 물건 1개 → 택배 보내기 → 왕복
- 10개 물건 = 10번 왕복

파이프라인 방법:
- 물건 10개를 상자에 담기
- 한 번에 보내기 → 1번 왕복
- 시간과 비용 절약!

┌─────────────────────────────────────┐
│      일반 방식 (10번 왕복)          │
│   물건1 → 배송 → 도착               │
│   물건2 → 배송 → 도착               │
│   ...                               │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│    파이프라인 (1번 왕복)            │
│   [물건1,2,3...10] → 배송 → 도착   │
└─────────────────────────────────────┘
```

### 비유 3: 레스토랑 주방 (Lua 스크립트)
```
Lua 스크립트 = 레스토랑 주방의 정해진 레시피

일반적인 방법:
- 홀 직원: "감자 썰어주세요"
- 주방장: "네" (왕복 1)
- 홀 직원: "고기 구워주세요"
- 주방장: "네" (왕복 2)
- 홀 직원: "소스 뿌려주세요"
- 주방장: "네" (왕복 3)

Lua 스크립트 방식:
- 홀 직원: "스테이크 1개요!"
- 주방장: 레시피대로 알아서 완성 (왕복 1)
- 모든 과정을 주방에서 일괄 처리

┌─────────────────────────────────────┐
│      주방의 스테이크 레시피         │
│   1. 감자 썰기                      │
│   2. 고기 굽기                      │
│   3. 소스 뿌리기                    │
│   → 한 번에 실행, 중간 방해 없음   │
└─────────────────────────────────────┘
```

### 비유 4: 콘서트 티켓팅 (WATCH)
```
WATCH = 콘서트 티켓팅 시 좌석 선점

시나리오:
- A와 B가 동시에 마지막 좌석 클릭
- A: 좌석 확인 (빈 좌석) → 결제 진행
- B: 좌석 확인 (빈 좌석) → 결제 진행
- 문제: 한 좌석을 두 명이 예매?

WATCH 사용:
- A: 좌석 WATCH 시작
- A: 결제 진행 중...
- B: 좌석 WATCH 시작
- B: 결제 시도 → "좌석이 변경되었습니다" (실패)
- A만 성공!

┌─────────────────────────────────────┐
│        티켓팅 좌석 선점             │
│                                     │
│   좌석 A1 [빈 좌석]                 │
│      ↓                              │
│   사용자1 WATCH 시작                │
│      ↓                              │
│   사용자2 WATCH 시작 (대기)         │
│      ↓                              │
│   사용자1 결제 완료 → 성공          │
│      ↓                              │
│   사용자2 시도 → 좌석 변경됨 (실패) │
└─────────────────────────────────────┘
```

### 비유 5: 편의점 재고 관리 (원자성)
```
원자성 = 편의점 재고 확인과 판매를 동시에 처리

문제 상황:
- 손님1: "라면 있나요?" (재고 1개)
- 점원: "네, 있습니다"
- 손님2: "라면 있나요?" (재고 1개)
- 점원: "네, 있습니다"
- 손님1, 손님2 동시에 계산대로...
- 결과: 재고는 1개인데 2명에게 판매?

원자적 처리:
- 손님1: "라면 주세요"
- 시스템: [재고 확인 + 차감] 한 번에 실행
- 손님2: "라면 주세요"
- 시스템: "재고가 없습니다"

┌─────────────────────────────────────┐
│       원자적 재고 처리              │
│                                     │
│   [확인 + 차감 + 판매]              │
│    ↑                                │
│   중간에 다른 작업 끼어들기 불가능  │
│                                     │
│   라면 재고: 1개                    │
│   손님1 구매 → [1개 → 0개] 완료    │
│   손님2 시도 → "재고 없음"          │
└─────────────────────────────────────┘
```

### 종합 비교표
```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ Redis 기능   │ 은행 ATM     │ 택배         │ 레스토랑     │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 트랜잭션     │ 계좌 이체    │ 택배 추적    │ 주문 처리    │
│ 파이프라인   │ 일괄 처리    │ 상자 포장    │ 세트 메뉴    │
│ Lua 스크립트 │ 자동 이체    │ 배송 자동화  │ 레시피       │
│ WATCH        │ 잔액 확인    │ 재고 확인    │ 좌석 선점    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📖 Redis 트랜잭션 완전 이해

### 1.1 트랜잭션 기본 개념

Redis 트랜잭션은 **원자성(Atomicity)**을 보장하는 명령어 그룹입니다.

#### 1.1.1 트랜잭션의 특징

```bash
# 1. 원자성 (Atomicity)
# 모든 명령어가 실행되거나 하나도 실행되지 않음

# 2. 격리성 (Isolation)
# 트랜잭션 실행 중 다른 클라이언트의 명령어가 끼어들 수 없음

# 3. 일관성 (Consistency)
# 트랜잭션 후에도 데이터베이스가 일관된 상태 유지

# 4. 롤백 없음 (주의!)
# Redis는 커밋 후 롤백을 지원하지 않음
```

### 1.2 트랜잭션 기본 명령어

#### MULTI - 트랜잭션 시작

```bash
# 기본 사용법
127.0.0.1:6379> MULTI
OK

# 이제 모든 명령어가 큐에 저장됨
127.0.0.1:6379> SET user:1000:name "김철수"
QUEUED
127.0.0.1:6379> SET user:1000:email "kim@example.com"
QUEUED
127.0.0.1:6379> INCR user:count
QUEUED
```

#### EXEC - 트랜잭션 실행

```bash
# 큐에 저장된 모든 명령어를 한 번에 실행
127.0.0.1:6379> EXEC
1) OK
2) OK
3) (integer) 1

# 명령어별 결과가 배열로 반환됨
```

#### DISCARD - 트랜잭션 취소

```bash
# 트랜잭션 시작
127.0.0.1:6379> MULTI
OK

# 명령어 큐잉
127.0.0.1:6379> SET key1 "value1"
QUEUED

# 트랜잭션 취소
127.0.0.1:6379> DISCARD
OK

# 아무것도 실행되지 않음
127.0.0.1:6379> GET key1
(nil)
```

### 1.3 WATCH를 이용한 낙관적 락

#### WATCH 기본 사용법

```bash
# 키를 감시 상태로 설정
127.0.0.1:6379> WATCH mykey
OK

# 현재 값 확인
127.0.0.1:6379> GET mykey
"10"

# 트랜잭션 시작
127.0.0.1:6379> MULTI
OK

# 값 변경 명령어 큐잉
127.0.0.1:6379> SET mykey "20"
QUEUED

# 실행 (성공)
127.0.0.1:6379> EXEC
1) OK
```

#### WATCH 충돌 시나리오

```bash
# 클라이언트 1
127.0.0.1:6379> WATCH mykey
OK
127.0.0.1:6379> GET mykey
"20"

# 이 시점에서 클라이언트 2가 값을 변경
# 클라이언트 2: SET mykey "30"

# 클라이언트 1에서 트랜잭션 시작
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET mykey "25"
QUEUED

# 실행 시 WATCH된 키가 변경되었으므로 트랜잭션 실패
127.0.0.1:6379> EXEC
(nil)

# 값이 변경되지 않음 (클라이언트 2의 값 유지)
127.0.0.1:6379> GET mykey
"30"
```

### 1.4 실무 트랜잭션 패턴

#### 계좌 이체 시뮬레이션

```bash
# 초기 계좌 설정
127.0.0.1:6379> SET account:1000 500000
OK
127.0.0.1:6379> SET account:2000 300000
OK

# 계좌 이체 프로세스 (100,000원 이체)
# 1. 송금 계좌 감시
127.0.0.1:6379> WATCH account:1000
OK

# 2. 현재 잔액 확인
127.0.0.1:6379> GET account:1000
"500000"

# 3. 트랜잭션 시작
127.0.0.1:6379> MULTI
OK

# 4. 송금 계좌에서 차감
127.0.0.1:6379> DECRBY account:1000 100000
QUEUED

# 5. 수신 계좌에 추가
127.0.0.1:6379> INCRBY account:2000 100000
QUEUED

# 6. 실행
127.0.0.1:6379> EXEC
1) (integer) 400000
2) (integer) 400000
```

---

## 💻 Redis 파이프라인 완전 마스터

### 2.1 파이프라인 기본 개념

파이프라인은 **여러 명령어를 한 번에 서버로 전송**하여 네트워크 왕복 시간(RTT)을 줄이는 기법입니다.

#### 일반적인 명령어 실행 vs 파이프라인

```bash
# 일반적인 실행 (3번의 네트워크 왕복)
# Client -> Server: SET key1 value1
# Server -> Client: OK
# Client -> Server: SET key2 value2
# Server -> Client: OK
# Client -> Server: SET key3 value3
# Server -> Client: OK

# 파이프라인 실행 (1번의 네트워크 왕복)
# Client -> Server: SET key1 value1; SET key2 value2; SET key3 value3
# Server -> Client: OK; OK; OK
```

### 2.2 redis-cli에서 파이프라인 사용

```bash
# 방법 1: echo와 파이프 사용
echo -e "SET key1 value1\nSET key2 value2\nSET key3 value3" | redis-cli --pipe

# 방법 2: 대량 데이터 삽입
for i in {1..1000}; do
    echo "SET key:$i value:$i"
done | redis-cli --pipe
```

### 2.3 애플리케이션에서 파이프라인 구현

#### Python Redis 파이프라인

```python
import redis
import time

# Redis 연결
r = redis.Redis(host='localhost', port=6379, db=0)

# 일반적인 방법 (느림)
start_time = time.time()
for i in range(1000):
    r.set(f"normal:key:{i}", f"value:{i}")
normal_time = time.time() - start_time

# 파이프라인 방법 (빠름)
start_time = time.time()
pipe = r.pipeline()
for i in range(1000):
    pipe.set(f"pipeline:key:{i}", f"value:{i}")
pipe.execute()
pipeline_time = time.time() - start_time

print(f"일반 방법: {normal_time:.2f}초")
print(f"파이프라인: {pipeline_time:.2f}초")
print(f"성능 향상: {normal_time/pipeline_time:.1f}배")

# 출력 예시:
# 일반 방법: 2.45초
# 파이프라인: 0.12초
# 성능 향상: 20.4배
```

### 2.4 성능 비교

| 방법 | 1,000건 처리 | 10,000건 처리 | 네트워크 왕복 |
|------|-------------|--------------|--------------|
| 일반 방식 | 2.5초 | 25초 | 10,000회 |
| 파이프라인 | 0.12초 | 1.2초 | 1회 |
| **개선** | **95%↓** | **95%↓** | **99.99%↓** |

---

## 🔧 Redis Lua 스크립트 완전 정복

### 3.1 Lua 스크립트 기본 개념

Redis Lua 스크립트는 **원자적으로 실행되는 사용자 정의 로직**을 구현할 수 있게 해줍니다.

#### Lua 스크립트의 장점

```lua
-- 1. 원자성: 스크립트 전체가 하나의 원자적 연산
-- 2. 성능: 네트워크 왕복 횟수 감소
-- 3. 일관성: 복잡한 로직을 서버에서 실행
-- 4. 조건부 실행: 동적 로직 구현 가능
```

### 3.2 EVAL을 이용한 스크립트 실행

#### 기본 Lua 스크립트

```bash
# 단순한 값 반환
127.0.0.1:6379> EVAL "return 'Hello Redis Lua!'" 0
"Hello Redis Lua!"

# 숫자 계산
127.0.0.1:6379> EVAL "return 10 + 20" 0
(integer) 30

# 키 사용하기
127.0.0.1:6379> EVAL "return redis.call('get', KEYS[1])" 1 mykey
(nil)

# 키에 값 설정하고 반환
127.0.0.1:6379> EVAL "redis.call('set', KEYS[1], ARGV[1]); return redis.call('get', KEYS[1])" 1 mykey "Hello World"
"Hello World"
```

#### KEYS와 ARGV 이해하기

```bash
# KEYS[1], KEYS[2], ... : 키 매개변수
# ARGV[1], ARGV[2], ... : 값 매개변수

# 예시: 두 키의 값을 교환하는 스크립트
127.0.0.1:6379> SET key1 "value1"
OK
127.0.0.1:6379> SET key2 "value2"
OK

127.0.0.1:6379> EVAL "
local val1 = redis.call('get', KEYS[1])
local val2 = redis.call('get', KEYS[2])
redis.call('set', KEYS[1], val2)
redis.call('set', KEYS[2], val1)
return {val1, val2}
" 2 key1 key2

1) "value1"
2) "value2"
```

### 3.3 고급 Lua 스크립트 패턴

#### 조건부 로직 구현

```bash
# 안전한 카운터 증가 (최대값 제한)
127.0.0.1:6379> EVAL "
local current = redis.call('get', KEYS[1])
if current == false then
    current = 0
else
    current = tonumber(current)
end

local max_value = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])

if current + increment <= max_value then
    return redis.call('incrby', KEYS[1], increment)
else
    return -1  -- 최대값 초과
end
" 1 counter 100 5

(integer) 5
```

### 3.4 EVALSHA와 스크립트 캐싱

```bash
# 스크립트를 서버에 로드
127.0.0.1:6379> SCRIPT LOAD "
local current = redis.call('get', KEYS[1])
if current == false then
    current = 0
else
    current = tonumber(current)
end
return current + tonumber(ARGV[1])
"
"2f31ba2bb6d6a0f42cc159d2e2dad55440778de3"

# SHA1 해시로 스크립트 실행 (더 효율적)
127.0.0.1:6379> EVALSHA 2f31ba2bb6d6a0f42cc159d2e2dad55440778de3 1 mycounter 10
(integer) 10
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 트랜잭션 중 에러 처리를 잘못한 경우

**상황**: 주니어 개발자가 재고 차감 시스템을 구현했는데, 런타임 에러를 처리하지 않아서 문제가 발생했습니다.

```python
# 주니어 개발자가 작성한 코드
import redis

r = redis.Redis()

def decrease_stock(product_id, quantity):
    """재고 차감 (문제 있는 코드)"""
    r.multi()
    r.decrby(f"product:{product_id}:stock", quantity)
    r.incr(f"product:{product_id}:sold")
    result = r.execute()
    return result
```

**문제점**:
- 문제 1: 재고가 음수가 되는 경우를 체크하지 않음
- 문제 2: WATCH를 사용하지 않아서 동시성 문제 발생
- 문제 3: 런타임 에러 발생 시 일부만 실행될 수 있음
- 왜 이 문제가 발생하는가: Redis 트랜잭션은 런타임 에러 시 롤백하지 않음

**해결책**:
```python
# 올바른 코드
import redis

r = redis.Redis()

def decrease_stock(product_id, quantity):
    """재고 차감 (올바른 코드)"""
    while True:
        # 1. WATCH로 재고 감시
        r.watch(f"product:{product_id}:stock")

        # 2. 현재 재고 확인
        current_stock = r.get(f"product:{product_id}:stock")
        if current_stock is None:
            r.unwatch()
            return False, "상품이 존재하지 않습니다"

        current_stock = int(current_stock)

        # 3. 재고 부족 체크
        if current_stock < quantity:
            r.unwatch()
            return False, f"재고 부족 (현재: {current_stock}, 요청: {quantity})"

        try:
            # 4. 트랜잭션 시작
            pipe = r.pipeline()
            pipe.decrby(f"product:{product_id}:stock", quantity)
            pipe.incr(f"product:{product_id}:sold")
            result = pipe.execute()

            # 5. 성공
            return True, f"재고 차감 성공 (남은 재고: {current_stock - quantity})"

        except redis.WatchError:
            # 6. WATCH 충돌 시 재시도
            continue

# 사용 예시
success, message = decrease_stock("1001", 5)
print(f"결과: {success}, 메시지: {message}")
```

**배운 점**:
- 트랜잭션 전에 WATCH로 키를 감시해야 동시성 문제를 방지할 수 있습니다
- 비즈니스 로직 검증(재고 확인)은 트랜잭션 전에 수행해야 합니다
- WatchError 예외를 처리하여 재시도 로직을 구현해야 합니다

### 시나리오 2: 파이프라인을 잘못 사용한 경우

**상황**: 주니어 개발자가 파이프라인으로 대량 데이터를 삽입하다가 메모리 부족 에러가 발생했습니다.

```python
# 주니어 개발자가 작성한 코드
import redis

r = redis.Redis()

def insert_million_users():
    """100만 명 사용자 데이터 삽입 (문제 있는 코드)"""
    pipe = r.pipeline()

    # 100만 개의 명령어를 모두 큐에 저장
    for i in range(1000000):
        pipe.hset(f"user:{i}", mapping={
            "name": f"user{i}",
            "email": f"user{i}@example.com",
            "age": 20 + (i % 60)
        })

    # 한 번에 실행
    pipe.execute()
    print("완료!")
```

**문제점**:
- 문제 1: 100만 개의 명령어를 메모리에 모두 로드하여 메모리 부족 발생
- 문제 2: 중간에 에러 발생 시 모든 작업이 실패
- 문제 3: 진행 상황을 알 수 없음
- 왜 이 문제가 발생하는가: 파이프라인은 모든 명령어를 메모리에 큐잉하기 때문

**해결책**:
```python
# 올바른 코드
import redis

r = redis.Redis()

def insert_million_users():
    """100만 명 사용자 데이터 삽입 (올바른 코드)"""
    batch_size = 1000  # 배치 크기 설정
    total = 1000000

    for batch_start in range(0, total, batch_size):
        # 배치마다 새로운 파이프라인 생성
        pipe = r.pipeline()

        batch_end = min(batch_start + batch_size, total)

        for i in range(batch_start, batch_end):
            pipe.hset(f"user:{i}", mapping={
                "name": f"user{i}",
                "email": f"user{i}@example.com",
                "age": 20 + (i % 60)
            })

        # 배치 실행
        pipe.execute()

        # 진행 상황 출력
        if (batch_start + batch_size) % 10000 == 0:
            progress = ((batch_start + batch_size) / total) * 100
            print(f"진행률: {progress:.1f}% ({batch_start + batch_size}/{total})")

    print("완료!")

# 실행
insert_million_users()

# 출력:
# 진행률: 1.0% (10000/1000000)
# 진행률: 2.0% (20000/1000000)
# ...
# 진행률: 100.0% (1000000/1000000)
# 완료!
```

**배운 점**:
- 파이프라인은 적절한 배치 크기(1000~5000)로 나누어 실행해야 합니다
- 진행 상황을 모니터링하여 사용자에게 피드백을 제공해야 합니다
- 메모리 사용량을 고려하여 배치 크기를 조정해야 합니다

### 시나리오 3: Lua 스크립트에서 키를 잘못 사용한 경우

**상황**: 주니어 개발자가 Lua 스크립트에서 KEYS를 사용하지 않고 ARGV로 키를 전달하여 클러스터 환경에서 문제가 발생했습니다.

```lua
-- 주니어 개발자가 작성한 스크립트 (문제 있는 코드)
-- increment_counter.lua
local key = ARGV[1]  -- 키를 ARGV로 전달 (잘못됨!)
local increment = tonumber(ARGV[2])

local current = redis.call('GET', key)
if current == false then
    current = 0
else
    current = tonumber(current)
end

redis.call('SET', key, current + increment)
return current + increment
```

**문제점**:
- 문제 1: Redis 클러스터에서 키를 ARGV로 전달하면 올바른 노드로 라우팅되지 않음
- 문제 2: Redis는 KEYS를 분석하여 어느 노드에 키가 있는지 판단함
- 문제 3: 클러스터 환경에서 "CROSSSLOT Keys in request don't hash to the same slot" 에러 발생
- 왜 이 문제가 발생하는가: Redis 클러스터는 KEYS 배열을 기반으로 라우팅을 수행함

**해결책**:
```lua
-- 올바른 스크립트
-- increment_counter.lua
local key = KEYS[1]  -- 키를 KEYS로 전달 (올바름!)
local increment = tonumber(ARGV[1])

local current = redis.call('GET', key)
if current == false then
    current = 0
else
    current = tonumber(current)
end

redis.call('SET', key, current + increment)
return current + increment
```

```bash
# 잘못된 사용법
127.0.0.1:6379> EVAL "$(cat increment_counter.lua)" 0 "counter:1001" 5
# 클러스터 환경에서 에러 발생!

# 올바른 사용법
127.0.0.1:6379> EVAL "$(cat increment_counter.lua)" 1 "counter:1001" 5
(integer) 5
```

**배운 점**:
- Lua 스크립트에서 키는 반드시 KEYS 배열로 전달해야 합니다
- ARGV는 값(value)이나 매개변수만 전달하는 용도로 사용해야 합니다
- 클러스터 환경을 고려하여 스크립트를 작성해야 합니다

### 시나리오 4: 트랜잭션에서 조건 분기를 잘못 구현한 경우

**상황**: 주니어 개발자가 트랜잭션 내부에서 조건 분기를 시도했는데, Redis 트랜잭션은 조건 분기를 지원하지 않아서 문제가 발생했습니다.

```python
# 주니어 개발자가 작성한 코드 (문제 있는 코드)
import redis

r = redis.Redis()

def conditional_update(user_id, new_score):
    """점수가 더 높을 때만 업데이트 (잘못된 방법)"""
    pipe = r.pipeline()

    # 트랜잭션 시작
    pipe.multi()

    # 현재 점수 가져오기 (큐잉만 됨, 실제 값은 얻을 수 없음!)
    pipe.get(f"user:{user_id}:score")

    # 조건 분기를 시도 (불가능!)
    # current_score = ??? (아직 실행되지 않았으므로 값이 없음)

    pipe.set(f"user:{user_id}:score", new_score)

    result = pipe.execute()
    return result
```

**문제점**:
- 문제 1: 트랜잭션 내부에서는 명령어가 큐잉만 되고 즉시 실행되지 않음
- 문제 2: GET 결과를 기반으로 조건 분기를 할 수 없음
- 문제 3: 모든 명령어가 무조건 실행됨
- 왜 이 문제가 발생하는가: Redis 트랜잭션은 명령어를 큐잉하고 EXEC 시점에 일괄 실행함

**해결책 1: WATCH + Python 조건 분기**
```python
# 해결책 1: WATCH 사용
import redis

r = redis.Redis()

def conditional_update_with_watch(user_id, new_score):
    """점수가 더 높을 때만 업데이트 (WATCH 방식)"""
    while True:
        # 1. 키 감시
        r.watch(f"user:{user_id}:score")

        # 2. 현재 점수 확인 (트랜잭션 밖에서)
        current_score = r.get(f"user:{user_id}:score")
        if current_score is None:
            current_score = 0
        else:
            current_score = int(current_score)

        # 3. 조건 확인
        if new_score <= current_score:
            r.unwatch()
            return False, f"점수가 더 낮습니다 (현재: {current_score}, 새로운: {new_score})"

        try:
            # 4. 트랜잭션 실행
            pipe = r.pipeline()
            pipe.set(f"user:{user_id}:score", new_score)
            pipe.execute()

            return True, f"점수 업데이트 성공 ({current_score} → {new_score})"

        except redis.WatchError:
            # 5. 충돌 시 재시도
            continue

# 사용 예시
success, message = conditional_update_with_watch("1001", 150)
print(message)
```

**해결책 2: Lua 스크립트 사용**
```lua
-- conditional_update.lua
local user_id = ARGV[1]
local new_score = tonumber(ARGV[2])
local score_key = 'user:' .. user_id .. ':score'

-- 현재 점수 확인
local current_score = redis.call('GET', score_key)
if current_score == false then
    current_score = 0
else
    current_score = tonumber(current_score)
end

-- 조건 분기
if new_score > current_score then
    redis.call('SET', score_key, new_score)
    return {1, current_score, new_score}
else
    return {0, current_score, new_score}
end
```

```python
# Lua 스크립트로 조건 분기 구현
import redis

r = redis.Redis()

# Lua 스크립트 로드
with open('conditional_update.lua', 'r') as f:
    script = f.read()

update_script = r.register_script(script)

# 실행
result = update_script(args=["1001", 150])
success, old_score, new_score = result

if success:
    print(f"점수 업데이트 성공 ({old_score} → {new_score})")
else:
    print(f"점수가 더 낮습니다 (현재: {old_score}, 새로운: {new_score})")
```

**배운 점**:
- Redis 트랜잭션은 조건 분기를 지원하지 않으므로 WATCH + Python 조건 분기 또는 Lua 스크립트를 사용해야 합니다
- 복잡한 조건 로직이 필요하면 Lua 스크립트가 더 효율적입니다
- 트랜잭션 내부에서는 명령어가 큐잉만 되고 즉시 실행되지 않는다는 점을 이해해야 합니다

---

## 🛠️ 실전 프로젝트

### 프로젝트 1: 전자상거래 재고관리 시스템

**난이도**: ⭐⭐⭐⭐☆
**예상 소요 시간**: 3-4시간
**학습 목표**: Redis 트랜잭션과 Lua 스크립트를 활용한 실시간 재고 관리 시스템 구축

#### 요구사항 분석

**기능 요구사항**
- [x] 실시간 재고 추적
- [x] 동시 주문 처리 (Race Condition 방지)
- [x] 재고 부족 시 대기열 관리
- [x] 주문 이력 추적
- [x] 재고 알림 시스템

**기술 요구사항**
- [x] Redis 트랜잭션 (WATCH + MULTI + EXEC)
- [x] Lua 스크립트로 복잡한 비즈니스 로직 구현
- [x] 파이프라인으로 성능 최적화

**비기능 요구사항**
- [x] 성능: 동시 1000명 주문 처리 가능
- [x] 보안: 재고 오버셀링 방지
- [x] 확장성: 상품 수 제한 없음

#### 프로젝트 구조

```
inventory-system/
├── scripts/
│   ├── order_process.lua
│   ├── payment_complete.lua
│   └── inventory_dashboard.lua
├── src/
│   ├── inventory_manager.py
│   └── test_inventory.py
├── config/
│   └── redis.conf
└── README.md
```

#### 설계 의사결정

**결정 1: Lua 스크립트 사용**
- 이유: 재고 확인과 차감을 원자적으로 처리해야 함
- 대안: Python에서 WATCH + MULTI 사용
- 선택 근거: Lua 스크립트가 더 간결하고 성능이 우수함

**결정 2: 대기열을 LIST로 구현**
- 이유: FIFO 방식으로 대기 순서 보장
- 대안: Sorted Set으로 우선순위 구현
- 선택 근거: 간단한 대기열은 LIST가 더 효율적

#### 단계별 구현 가이드

**1단계: Lua 스크립트 작성**

```lua
-- order_process.lua
local product_id = ARGV[1]
local quantity = tonumber(ARGV[2])
local user_id = ARGV[3]
local order_id = ARGV[4]
local timestamp = ARGV[5]

-- 키 정의
local stock_key = 'product:' .. product_id .. ':stock'
local reserved_key = 'product:' .. product_id .. ':reserved'
local waitlist_key = 'product:' .. product_id .. ':waitlist'
local orders_key = 'orders:' .. string.sub(timestamp, 1, 10)
local log_key = 'product:' .. product_id .. ':stock_log'

-- 현재 재고 확인
local current_stock = redis.call('GET', stock_key)
if current_stock == false then
    return {0, 'PRODUCT_NOT_FOUND', 0}
end
current_stock = tonumber(current_stock)

-- 예약된 재고 확인
local reserved = redis.call('GET', reserved_key)
if reserved == false then
    reserved = 0
else
    reserved = tonumber(reserved)
end

-- 실제 사용 가능한 재고
local available = current_stock - reserved

if available >= quantity then
    -- 주문 가능: 재고 예약
    redis.call('INCRBY', reserved_key, quantity)
    redis.call('EXPIRE', reserved_key, 1800)  -- 30분 예약 유효

    -- 주문 기록
    local order_data = order_id .. ':' .. user_id .. ':' .. product_id .. ':' .. quantity
    redis.call('ZADD', orders_key, timestamp, order_data)

    -- 로그 기록
    local log_entry = timestamp .. ':RESERVED:' .. quantity .. ':' .. user_id
    redis.call('LPUSH', log_key, log_entry)
    redis.call('LTRIM', log_key, 0, 999)  -- 최근 1000개만 보관

    return {1, 'ORDER_RESERVED', available - quantity}
else
    -- 재고 부족: 대기열에 추가
    local waitlist_data = user_id .. ':' .. quantity .. ':' .. timestamp
    redis.call('RPUSH', waitlist_key, waitlist_data)

    -- 대기열 위치 반환
    local position = redis.call('LLEN', waitlist_key)

    return {0, 'WAITLISTED', position}
end
```

```lua
-- payment_complete.lua
local product_id = ARGV[1]
local quantity = tonumber(ARGV[2])
local user_id = ARGV[3]
local order_id = ARGV[4]
local timestamp = ARGV[5]

local stock_key = 'product:' .. product_id .. ':stock'
local reserved_key = 'product:' .. product_id .. ':reserved'
local sold_key = 'product:' .. product_id .. ':sold'
local log_key = 'product:' .. product_id .. ':stock_log'

-- 예약된 재고에서 차감
local reserved = redis.call('GET', reserved_key)
if reserved == false or tonumber(reserved) < quantity then
    return {0, 'RESERVATION_NOT_FOUND'}
end

-- 실제 재고 차감
redis.call('DECRBY', stock_key, quantity)
redis.call('DECRBY', reserved_key, quantity)

-- 판매 수량 증가
redis.call('INCRBY', sold_key, quantity)

-- 로그 기록
local log_entry = timestamp .. ':SOLD:' .. quantity .. ':' .. user_id .. ':' .. order_id
redis.call('LPUSH', log_key, log_entry)

return {1, 'PAYMENT_COMPLETE', redis.call('GET', stock_key)}
```

**2단계: Python 재고 관리자 구현**

```python
# inventory_manager.py
import redis
import time
from datetime import datetime

class InventoryManager:
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_client = redis.Redis(
            host=redis_host,
            port=redis_port,
            db=0,
            decode_responses=True
        )

        # Lua 스크립트 로드
        with open('scripts/order_process.lua', 'r') as f:
            self.order_script = self.redis_client.register_script(f.read())

        with open('scripts/payment_complete.lua', 'r') as f:
            self.payment_script = self.redis_client.register_script(f.read())

    def create_product(self, product_id, name, price, initial_stock):
        """상품 생성"""
        pipe = self.redis_client.pipeline()
        pipe.hset(f"product:{product_id}", mapping={
            "name": name,
            "price": price,
            "category": "general"
        })
        pipe.set(f"product:{product_id}:stock", initial_stock)
        pipe.set(f"product:{product_id}:sold", 0)
        pipe.execute()

        return {
            "product_id": product_id,
            "name": name,
            "stock": initial_stock
        }

    def place_order(self, product_id, quantity, user_id):
        """주문 처리"""
        order_id = f"ORD_{int(time.time() * 1000)}"
        timestamp = str(int(time.time()))

        result = self.order_script(
            args=[product_id, quantity, user_id, order_id, timestamp]
        )

        success, status, info = result

        if success:
            return {
                "success": True,
                "order_id": order_id,
                "status": status,
                "available_stock": info
            }
        else:
            return {
                "success": False,
                "status": status,
                "waitlist_position": info if status == "WAITLISTED" else None
            }

    def complete_payment(self, product_id, quantity, user_id, order_id):
        """결제 완료 처리"""
        timestamp = str(int(time.time()))

        result = self.payment_script(
            args=[product_id, quantity, user_id, order_id, timestamp]
        )

        success, status = result[0], result[1]

        if success:
            return {
                "success": True,
                "status": status,
                "remaining_stock": result[2]
            }
        else:
            return {
                "success": False,
                "status": status
            }

    def get_product_info(self, product_id):
        """상품 정보 조회"""
        pipe = self.redis_client.pipeline()
        pipe.hgetall(f"product:{product_id}")
        pipe.get(f"product:{product_id}:stock")
        pipe.get(f"product:{product_id}:reserved")
        pipe.get(f"product:{product_id}:sold")
        pipe.llen(f"product:{product_id}:waitlist")

        results = pipe.execute()

        product_info = results[0]
        stock = int(results[1]) if results[1] else 0
        reserved = int(results[2]) if results[2] else 0
        sold = int(results[3]) if results[3] else 0
        waitlist = results[4]

        return {
            "product_id": product_id,
            "name": product_info.get("name", "Unknown"),
            "price": product_info.get("price", "0"),
            "stock": stock,
            "reserved": reserved,
            "available": stock - reserved,
            "sold": sold,
            "waitlist_count": waitlist
        }

    def get_stock_logs(self, product_id, limit=10):
        """재고 변경 로그 조회"""
        logs = self.redis_client.lrange(
            f"product:{product_id}:stock_log",
            0,
            limit - 1
        )

        parsed_logs = []
        for log in logs:
            parts = log.split(':')
            parsed_logs.append({
                "timestamp": datetime.fromtimestamp(int(parts[0])).strftime('%Y-%m-%d %H:%M:%S'),
                "action": parts[1],
                "quantity": parts[2],
                "user_id": parts[3] if len(parts) > 3 else "N/A"
            })

        return parsed_logs


# 사용 예시
if __name__ == "__main__":
    manager = InventoryManager()

    # 상품 생성
    print("=== 상품 생성 ===")
    product = manager.create_product(
        product_id="1001",
        name="iPhone 15 Pro",
        price="1290000",
        initial_stock=100
    )
    print(f"상품 생성: {product}")

    # 주문 처리
    print("\n=== 주문 처리 ===")
    order1 = manager.place_order("1001", 5, "user123")
    print(f"주문 1: {order1}")

    order2 = manager.place_order("1001", 3, "user456")
    print(f"주문 2: {order2}")

    # 결제 완료
    print("\n=== 결제 완료 ===")
    if order1["success"]:
        payment = manager.complete_payment(
            "1001", 5, "user123", order1["order_id"]
        )
        print(f"결제 완료: {payment}")

    # 상품 정보 조회
    print("\n=== 상품 정보 ===")
    info = manager.get_product_info("1001")
    print(f"상품 정보: {info}")

    # 재고 로그 조회
    print("\n=== 재고 로그 ===")
    logs = manager.get_stock_logs("1001", 5)
    for log in logs:
        print(f"  {log}")
```

**3단계: 테스트 작성**

```python
# test_inventory.py
import pytest
import threading
import time
from inventory_manager import InventoryManager

class TestInventorySystem:
    @pytest.fixture
    def manager(self):
        """테스트용 InventoryManager 인스턴스"""
        return InventoryManager()

    def test_create_product(self, manager):
        """상품 생성 테스트"""
        product = manager.create_product(
            product_id="TEST001",
            name="Test Product",
            price="10000",
            initial_stock=50
        )

        assert product["product_id"] == "TEST001"
        assert product["name"] == "Test Product"
        assert product["stock"] == 50

    def test_place_order_success(self, manager):
        """정상 주문 테스트"""
        manager.create_product("TEST002", "Product 2", "20000", 100)

        order = manager.place_order("TEST002", 10, "user001")

        assert order["success"] == True
        assert order["status"] == "ORDER_RESERVED"
        assert order["available_stock"] == 90

    def test_place_order_insufficient_stock(self, manager):
        """재고 부족 주문 테스트"""
        manager.create_product("TEST003", "Product 3", "30000", 5)

        order = manager.place_order("TEST003", 10, "user002")

        assert order["success"] == False
        assert order["status"] == "WAITLISTED"
        assert order["waitlist_position"] == 1

    def test_concurrent_orders(self, manager):
        """동시 주문 테스트 (Race Condition 방지 확인)"""
        manager.create_product("TEST004", "Product 4", "40000", 10)

        results = []

        def place_order_thread(user_id):
            order = manager.place_order("TEST004", 5, user_id)
            results.append(order)

        # 10명이 동시에 5개씩 주문 (총 50개, 재고는 10개)
        threads = []
        for i in range(10):
            t = threading.Thread(target=place_order_thread, args=(f"user{i}",))
            threads.append(t)
            t.start()

        for t in threads:
            t.join()

        # 성공한 주문 확인 (최대 2명만 성공해야 함: 10개 / 5개 = 2명)
        successful_orders = [r for r in results if r["success"]]
        assert len(successful_orders) <= 2

        # 최종 재고 확인
        info = manager.get_product_info("TEST004")
        assert info["stock"] >= 0  # 재고가 음수가 되면 안 됨

    def test_payment_complete(self, manager):
        """결제 완료 테스트"""
        manager.create_product("TEST005", "Product 5", "50000", 20)

        order = manager.place_order("TEST005", 8, "user003")
        assert order["success"] == True

        payment = manager.complete_payment(
            "TEST005", 8, "user003", order["order_id"]
        )

        assert payment["success"] == True
        assert payment["status"] == "PAYMENT_COMPLETE"
        assert int(payment["remaining_stock"]) == 12


# 실행
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
```

**4단계: 실행 및 검증**

```bash
# 테스트 실행
python test_inventory.py

# 예상 출력:
# test_inventory.py::TestInventorySystem::test_create_product PASSED
# test_inventory.py::TestInventorySystem::test_place_order_success PASSED
# test_inventory.py::TestInventorySystem::test_place_order_insufficient_stock PASSED
# test_inventory.py::TestInventorySystem::test_concurrent_orders PASSED
# test_inventory.py::TestInventorySystem::test_payment_complete PASSED
```

#### 확장 아이디어

**추가 기능 1: 재고 자동 보충 시스템**
**난이도**: ⭐⭐⭐⭐☆
**구현 힌트**: Lua 스크립트로 재고가 임계값 이하로 떨어지면 자동으로 보충 알림 전송

**추가 기능 2: 할인 쿠폰 적용**
**난이도**: ⭐⭐⭐☆☆
**구현 힌트**: 쿠폰 사용 여부를 Redis Set으로 관리하여 중복 사용 방지

**추가 기능 3: 실시간 대시보드**
**난이도**: ⭐⭐⭐⭐⭐
**구현 힌트**: Redis Pub/Sub로 재고 변경 이벤트를 실시간으로 브로드캐스트

### 프로젝트 2: 분산 락을 이용한 작업 스케줄러

**난이도**: ⭐⭐⭐⭐⭐
**예상 소요 시간**: 4-5시간
**학습 목표**: Redis 분산 락을 활용한 중복 작업 방지 시스템 구축

#### 요구사항

- 여러 워커가 동시에 작업 큐에서 작업을 가져감
- 같은 작업을 중복 처리하지 않음
- 작업 실패 시 재시도 메커니즘
- 작업 처리 시간 모니터링

#### 핵심 구현

```python
# job_scheduler.py
import redis
import time
import uuid

class DistributedJobScheduler:
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_client = redis.Redis(host=redis_host, port=redis_port, db=0, decode_responses=True)
        self.worker_id = str(uuid.uuid4())

    def acquire_lock(self, job_id, ttl=300000):
        """분산 락 획득 (TTL: 밀리초)"""
        lock_key = f"lock:job:{job_id}"
        result = self.redis_client.set(
            lock_key,
            self.worker_id,
            px=ttl,
            nx=True
        )
        return result is not None

    def release_lock(self, job_id):
        """분산 락 해제"""
        lock_key = f"lock:job:{job_id}"

        # Lua 스크립트로 안전하게 락 해제
        release_script = """
        local lock_key = KEYS[1]
        local worker_id = ARGV[1]

        local current_value = redis.call('GET', lock_key)
        if current_value == worker_id then
            redis.call('DEL', lock_key)
            return 1
        else
            return 0
        end
        """

        script = self.redis_client.register_script(release_script)
        result = script(keys=[lock_key], args=[self.worker_id])
        return result == 1

    def get_job(self, queue_name='job:queue'):
        """작업 큐에서 작업 가져오기"""
        job_id = self.redis_client.lpop(queue_name)

        if job_id:
            # 락 획득 시도
            if self.acquire_lock(job_id):
                return job_id
            else:
                # 락 획득 실패 시 작업을 큐 뒤로 돌림
                self.redis_client.rpush(queue_name, job_id)
                return None

        return None

    def process_job(self, job_id):
        """작업 처리"""
        print(f"[Worker {self.worker_id[:8]}] Processing job: {job_id}")
        time.sleep(2)  # 실제 작업 시뮬레이션
        print(f"[Worker {self.worker_id[:8]}] Completed job: {job_id}")

    def run_worker(self):
        """워커 실행"""
        print(f"Worker {self.worker_id[:8]} started")

        while True:
            job_id = self.get_job()

            if job_id:
                try:
                    self.process_job(job_id)
                finally:
                    self.release_lock(job_id)
            else:
                time.sleep(1)  # 작업이 없으면 대기


# 사용 예시
if __name__ == "__main__":
    import sys

    scheduler = DistributedJobScheduler()

    if len(sys.argv) > 1 and sys.argv[1] == "add_jobs":
        # 작업 추가
        for i in range(10):
            scheduler.redis_client.rpush("job:queue", f"job_{i}")
        print("10개 작업 추가 완료")
    else:
        # 워커 실행
        scheduler.run_worker()
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: Redis 트랜잭션은 ACID를 모두 지원하나요?</strong></summary>

**A**: Redis 트랜잭션은 ACID 중 일부만 지원합니다.

**상세 설명**:
- 원자성 (Atomicity): ✅ 지원 - 모든 명령어가 실행되거나 하나도 실행되지 않음
- 일관성 (Consistency): ✅ 지원 - 트랜잭션 후에도 데이터 일관성 유지
- 격리성 (Isolation): ✅ 지원 - 트랜잭션 실행 중 다른 명령어가 끼어들 수 없음
- 지속성 (Durability): ⚠️ 부분 지원 - RDB/AOF 설정에 따라 다름

**예시**:
```bash
# 원자성 예시
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 "value1"
QUEUED
127.0.0.1:6379> SET key2 "value2"
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) OK

# 모든 명령어가 함께 실행됨
```

**실무 팁**:
- 중요한 데이터는 AOF persistence를 활성화하여 지속성을 보장하세요
- Redis는 메모리 데이터베이스이므로 완벽한 지속성을 기대하기 어렵습니다

</details>

<details>
<summary><strong>Q2: 트랜잭션 실행 중 에러가 발생하면 롤백되나요?</strong></summary>

**A**: Redis는 **문법 에러**와 **런타임 에러**를 다르게 처리합니다.

**상세 설명**:
- 문법 에러: 전체 트랜잭션이 실행되지 않음 (유사 롤백)
- 런타임 에러: 에러 난 명령어만 실패, 나머지는 정상 실행 (롤백 없음!)

**예시**:
```bash
# 문법 에러 - 전체 실패
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET key1 "value1"
QUEUED
127.0.0.1:6379> WRONGCOMMAND
(error) ERR unknown command 'WRONGCOMMAND'
127.0.0.1:6379> EXEC
(error) EXECABORT Transaction discarded

# 런타임 에러 - 일부 실행
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET mykey "hello"
QUEUED
127.0.0.1:6379> INCR mykey  # 문자열에 INCR 시도
QUEUED
127.0.0.1:6379> SET another "world"
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (error) ERR value is not an integer
3) OK  # 3번째 명령어는 정상 실행됨!
```

**실무 팁**:
- 런타임 에러가 발생할 수 있는 경우 Lua 스크립트로 사전 검증하세요
- 중요한 작업은 WATCH로 키를 감시하여 충돌을 방지하세요

</details>

<details>
<summary><strong>Q3: 파이프라인과 트랜잭션의 차이점은 무엇인가요?</strong></summary>

**A**: 목적과 보장하는 특성이 다릅니다.

**상세 설명**:

| 특성 | 파이프라인 | 트랜잭션 |
|------|-----------|---------|
| 목적 | 성능 최적화 (RTT 감소) | 원자성 보장 |
| 원자성 | ❌ 보장 안 됨 | ✅ 보장됨 |
| 중간 방해 | ⚠️ 가능 | ❌ 불가능 |
| 조건부 실행 | ❌ 불가능 | ⚠️ WATCH로 가능 |
| 성능 | ⭐⭐⭐⭐⭐ 매우 빠름 | ⭐⭐⭐⭐ 빠름 |

**예시**:
```python
# 파이프라인 - 성능 최적화
pipe = r.pipeline(transaction=False)  # 트랜잭션 없이
pipe.set("key1", "value1")
pipe.set("key2", "value2")
pipe.execute()
# 중간에 다른 클라이언트의 명령어가 끼어들 수 있음!

# 트랜잭션 - 원자성 보장
pipe = r.pipeline(transaction=True)  # 트랜잭션 포함
pipe.multi()
pipe.set("key1", "value1")
pipe.set("key2", "value2")
pipe.execute()
# 중간에 다른 명령어가 끼어들 수 없음!
```

**실무 팁**:
- 성능이 중요하고 원자성이 필요 없으면 파이프라인 사용
- 원자성이 필요하면 트랜잭션 사용
- 둘 다 필요하면 파이프라인 + 트랜잭션 조합 사용

</details>

<details>
<summary><strong>Q4: Lua 스크립트는 언제 사용해야 하나요?</strong></summary>

**A**: 복잡한 비즈니스 로직을 원자적으로 실행해야 할 때 사용합니다.

**상세 설명**:
- 조건 분기가 필요한 경우
- 여러 Redis 명령어를 조합해야 하는 경우
- 네트워크 왕복을 최소화하려는 경우
- 복잡한 데이터 변환이 필요한 경우

**사용 시기**:
1. ✅ 조건부 업데이트 (예: 값이 크면 업데이트)
2. ✅ 복잡한 집계 연산 (예: 여러 키의 값을 합산)
3. ✅ 레이트 리미터 구현
4. ✅ 분산 락 구현
5. ✅ 재고 관리 시스템

**예시**:
```lua
-- 조건부 업데이트 스크립트
local current = redis.call('GET', KEYS[1])
if current == false then
    current = 0
else
    current = tonumber(current)
end

local new_value = tonumber(ARGV[1])

if new_value > current then
    redis.call('SET', KEYS[1], new_value)
    return {1, new_value}
else
    return {0, current}
end
```

**실무 팁**:
- 단순한 작업은 일반 명령어 사용
- 복잡한 로직은 Lua 스크립트 사용
- 스크립트는 SCRIPT LOAD로 미리 로드하여 성능 향상

</details>

<details>
<summary><strong>Q5: WATCH를 사용할 때 무한 루프에 빠질 가능성은 없나요?</strong></summary>

**A**: 가능성은 있지만 적절한 재시도 로직으로 방지할 수 있습니다.

**상세 설명**:
- 동시 접근이 매우 많으면 WATCH 충돌이 반복될 수 있음
- 최대 재시도 횟수를 설정하여 무한 루프 방지
- 지수 백오프 전략으로 충돌 확률 감소

**예시**:
```python
# 무한 루프 방지 패턴
import redis
import time

r = redis.Redis()

def safe_update_with_watch(key, max_retries=10):
    """WATCH를 사용한 안전한 업데이트 (재시도 제한)"""
    for attempt in range(max_retries):
        try:
            # WATCH 시작
            r.watch(key)

            current_value = r.get(key)
            if current_value is None:
                current_value = 0
            else:
                current_value = int(current_value)

            # 트랜잭션 실행
            pipe = r.pipeline()
            pipe.set(key, current_value + 1)
            pipe.execute()

            # 성공
            return True, f"업데이트 성공 (시도: {attempt + 1}회)"

        except redis.WatchError:
            # WATCH 충돌 시 재시도
            if attempt < max_retries - 1:
                # 지수 백오프
                time.sleep(0.01 * (2 ** attempt))
                continue
            else:
                return False, f"최대 재시도 횟수 초과 ({max_retries}회)"

        finally:
            r.unwatch()

    return False, "알 수 없는 오류"

# 사용
success, message = safe_update_with_watch("counter")
print(message)
```

**실무 팁**:
- 최대 재시도 횟수를 5~10회로 제한
- 재시도 간격을 점진적으로 늘려서 충돌 확률 감소
- 충돌이 자주 발생하면 Lua 스크립트로 변경 고려

</details>

<details>
<summary><strong>Q6: 파이프라인 배치 크기는 어떻게 정해야 하나요?</strong></summary>

**A**: 일반적으로 1000~5000개가 적절하며, 환경에 따라 조정이 필요합니다.

**상세 설명**:
- 너무 작으면: 네트워크 왕복이 많아져 성능 저하
- 너무 크면: 메모리 부족, 타임아웃 발생 가능
- 최적값은 데이터 크기와 네트워크 환경에 따라 다름

**실험을 통한 최적화**:
```python
import redis
import time

r = redis.Redis()

def benchmark_batch_size(total_items=100000):
    """배치 크기별 성능 측정"""
    batch_sizes = [100, 500, 1000, 2000, 5000, 10000]
    results = []

    for batch_size in batch_sizes:
        start_time = time.time()

        for batch_start in range(0, total_items, batch_size):
            pipe = r.pipeline()

            batch_end = min(batch_start + batch_size, total_items)
            for i in range(batch_start, batch_end):
                pipe.set(f"test:batch{batch_size}:key{i}", f"value{i}")

            pipe.execute()

        elapsed_time = time.time() - start_time
        results.append((batch_size, elapsed_time))
        print(f"배치 크기 {batch_size}: {elapsed_time:.2f}초")

    # 최적 배치 크기 찾기
    optimal = min(results, key=lambda x: x[1])
    print(f"\n최적 배치 크기: {optimal[0]} (소요 시간: {optimal[1]:.2f}초)")

benchmark_batch_size()

# 출력 예시:
# 배치 크기 100: 12.45초
# 배치 크기 500: 3.21초
# 배치 크기 1000: 2.15초
# 배치 크기 2000: 1.98초
# 배치 크기 5000: 1.85초
# 배치 크기 10000: 2.10초
#
# 최적 배치 크기: 5000 (소요 시간: 1.85초)
```

**실무 팁**:
- 일반적으로 1000~5000 사이에서 시작
- 실험을 통해 환경에 맞는 최적값 찾기
- 메모리 사용량과 성능의 균형 고려

</details>

<details>
<summary><strong>Q7: Lua 스크립트에서 랜덤 함수를 사용할 수 있나요?</strong></summary>

**A**: 제한적으로 가능하지만 권장하지 않습니다. 클라이언트에서 랜덤 값을 생성하여 전달하는 것이 좋습니다.

**상세 설명**:
- Redis Lua는 비결정적 함수(math.random 등) 사용을 제한함
- 복제와 AOF 재생 시 일관성을 보장하기 위함
- 해결책: 클라이언트에서 랜덤 값 생성 후 ARGV로 전달

**예시**:
```lua
-- 잘못된 방법 (권장하지 않음)
-- math.random() 직접 사용은 제한됨

-- 해결 방법 1: 클라이언트에서 랜덤 값 전달
local random_value = tonumber(ARGV[1])  -- 클라이언트에서 생성한 랜덤 값
local key = 'random:' .. random_value
redis.call('SET', key, 'value')
return random_value

-- 해결 방법 2: 현재 시간 기반 의사 랜덤
local time_info = redis.call('TIME')
local seed = tonumber(time_info[2])  -- 마이크로초
local pseudo_random = (seed * 1103515245 + 12345) % 2147483648
return pseudo_random
```

```python
# Python에서 랜덤 값 전달
import redis
import random

r = redis.Redis()

# Lua 스크립트
script = """
local random_value = tonumber(ARGV[1])
local key = 'random:' .. random_value
redis.call('SET', key, 'value')
return random_value
"""

# 클라이언트에서 랜덤 값 생성
random_num = random.randint(1, 1000000)

# 스크립트 실행
result = r.eval(script, 0, random_num)
print(f"랜덤 값: {result}")
```

**실무 팁**:
- 랜덤 값이 필요하면 클라이언트에서 생성하여 전달
- 시간 기반 의사 랜덤은 예측 가능하므로 보안이 중요한 경우 사용 금지
- UUID나 타임스탬프를 활용하는 것도 좋은 대안

</details>

<details>
<summary><strong>Q8: 트랜잭션 내부에서 GET 결과를 기반으로 조건 분기를 할 수 있나요?</strong></summary>

**A**: 불가능합니다. 트랜잭션 내부의 명령어는 큐잉만 되고 즉시 실행되지 않기 때문입니다.

**상세 설명**:
- MULTI 이후 명령어는 QUEUED 상태로 저장됨
- EXEC 시점에 일괄 실행됨
- 중간 결과를 사용할 수 없음

**해결책**:
1. WATCH + Python 조건 분기
2. Lua 스크립트 사용

**예시**:
```python
# 해결책 1: WATCH + Python 조건 분기
import redis

r = redis.Redis()

def conditional_update(key, new_value):
    """조건부 업데이트 (WATCH 사용)"""
    while True:
        # WATCH로 키 감시
        r.watch(key)

        # 현재 값 확인 (트랜잭션 밖에서)
        current = r.get(key)
        if current is None:
            current = 0
        else:
            current = int(current)

        # 조건 확인
        if new_value > current:
            try:
                pipe = r.pipeline()
                pipe.set(key, new_value)
                pipe.execute()
                return True, f"업데이트 성공 ({current} → {new_value})"
            except redis.WatchError:
                continue
        else:
            r.unwatch()
            return False, f"값이 더 작음 (현재: {current}, 새로운: {new_value})"
```

```lua
-- 해결책 2: Lua 스크립트
local key = KEYS[1]
local new_value = tonumber(ARGV[1])

local current = redis.call('GET', key)
if current == false then
    current = 0
else
    current = tonumber(current)
end

if new_value > current then
    redis.call('SET', key, new_value)
    return {1, current, new_value}
else
    return {0, current, new_value}
end
```

**실무 팁**:
- 간단한 조건: WATCH + Python
- 복잡한 조건: Lua 스크립트
- Lua 스크립트가 더 효율적이고 원자성 보장

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. Redis 트랜잭션의 기본 명령어(MULTI, EXEC, DISCARD)를 설명하고, 각각의 역할을 말씀해주세요.</strong></summary>

**모범 답안 포인트**
- MULTI: 트랜잭션 시작, 이후 명령어들이 큐에 저장됨
- EXEC: 큐에 저장된 모든 명령어를 한 번에 실행
- DISCARD: 큐에 저장된 명령어들을 모두 취소

**예시 답변**
> "Redis 트랜잭션은 MULTI 명령으로 시작합니다. MULTI를 실행하면 그 이후의 모든 명령어들이 즉시 실행되지 않고 큐에 저장됩니다. EXEC 명령을 실행하면 큐에 저장된 모든 명령어가 한 번에 순차적으로 실행되며, 중간에 다른 클라이언트의 명령어가 끼어들 수 없습니다. 만약 트랜잭션을 취소하고 싶다면 DISCARD 명령을 사용하여 큐에 저장된 모든 명령어를 폐기할 수 있습니다."

**꼬리 질문**
- Q: MULTI 이후 EXEC 없이 다른 명령어를 실행하면 어떻게 되나요?
- A: 계속해서 큐에 저장되고, EXEC를 실행할 때까지 실행되지 않습니다.

**실무 연관**
- 실무에서는 계좌 이체, 재고 차감 등 여러 작업을 원자적으로 처리해야 할 때 사용합니다.

</details>

<details>
<summary><strong>2. 파이프라인과 트랜잭션의 차이점을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 파이프라인: 성능 최적화(네트워크 RTT 감소)가 목적
- 트랜잭션: 원자성 보장이 목적
- 파이프라인은 중간에 다른 명령어가 끼어들 수 있지만, 트랜잭션은 불가능
- 파이프라인과 트랜잭션은 함께 사용 가능

**예시 답변**
> "파이프라인은 여러 명령어를 한 번에 서버로 전송하여 네트워크 왕복 시간을 줄이는 성능 최적화 기법입니다. 반면 트랜잭션은 여러 명령어를 원자적으로 실행하여 중간에 다른 클라이언트의 명령어가 끼어들지 못하게 하는 것이 목적입니다. 파이프라인은 성능이 중요할 때, 트랜잭션은 데이터 일관성이 중요할 때 사용하며, 필요에 따라 두 가지를 함께 사용할 수도 있습니다."

**꼬리 질문**
- Q: 파이프라인과 트랜잭션을 함께 사용하는 예시를 들어주세요.
- A: Python redis-py에서 `r.pipeline(transaction=True)`로 파이프라인과 트랜잭션을 함께 사용할 수 있습니다.

**실무 연관**
- 대량 데이터 삽입은 파이프라인, 결제 처리는 트랜잭션으로 처리합니다.

</details>

<details>
<summary><strong>3. WATCH 명령어의 역할과 동작 원리를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- WATCH는 낙관적 락(Optimistic Locking) 구현
- 키를 감시하여 트랜잭션 실행 전에 값이 변경되었는지 확인
- 값이 변경되었으면 트랜잭션 실패 (EXEC가 nil 반환)
- 동시성 제어에 사용

**예시 답변**
> "WATCH는 Redis의 낙관적 락 메커니즘입니다. WATCH로 키를 감시하면, EXEC 실행 시점에 해당 키의 값이 변경되었는지 확인합니다. 만약 다른 클라이언트가 중간에 값을 변경했다면 트랜잭션이 실패하고 EXEC는 nil을 반환합니다. 이를 통해 여러 클라이언트가 동시에 같은 데이터를 수정하려 할 때 데이터 일관성을 보장할 수 있습니다."

**꼬리 질문**
- Q: WATCH 충돌 시 어떻게 재시도해야 하나요?
- A: while 루프로 감싸서 WatchError 예외 발생 시 재시도하되, 최대 재시도 횟수를 설정해야 합니다.

**실무 연관**
- 재고 차감, 좋아요 카운트 증가 등 동시성 제어가 필요한 경우에 사용합니다.

</details>

<details>
<summary><strong>4. Lua 스크립트의 장점과 사용 사례를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 원자성: 스크립트 전체가 하나의 원자적 연산으로 실행
- 성능: 네트워크 왕복 횟수 감소
- 조건 분기: 복잡한 비즈니스 로직을 서버에서 실행
- 사용 사례: 레이트 리미터, 분산 락, 재고 관리

**예시 답변**
> "Lua 스크립트는 Redis 서버에서 원자적으로 실행되는 사용자 정의 스크립트입니다. 주요 장점은 세 가지입니다. 첫째, 스크립트 전체가 하나의 원자적 연산으로 실행되어 중간에 다른 명령어가 끼어들 수 없습니다. 둘째, 여러 Redis 명령어를 조합할 때 네트워크 왕복 없이 서버에서 바로 실행되어 성능이 우수합니다. 셋째, 조건 분기나 반복문 등 복잡한 로직을 구현할 수 있습니다. 실무에서는 레이트 리미터, 분산 락, 재고 관리 시스템 등에서 활용됩니다."

**꼬리 질문**
- Q: EVAL과 EVALSHA의 차이는 무엇인가요?
- A: EVAL은 스크립트를 직접 전달하고, EVALSHA는 스크립트를 미리 로드한 후 SHA 해시로 실행하여 더 효율적입니다.

**실무 연관**
- API 요청 횟수 제한, 동시 접근 제어 등 복잡한 로직에 사용됩니다.

</details>

<details>
<summary><strong>5. 파이프라인 사용 시 배치 크기를 어떻게 정해야 하나요?</strong></summary>

**모범 답안 포인트**
- 일반적으로 1000~5000개가 적절
- 너무 작으면 네트워크 왕복이 많아짐
- 너무 크면 메모리 부족, 타임아웃 발생
- 환경에 따라 실험을 통해 최적값 찾기

**예시 답변**
> "파이프라인의 배치 크기는 일반적으로 1000~5000개 사이가 적절합니다. 배치 크기가 너무 작으면 네트워크 왕복 횟수가 증가하여 성능 향상 효과가 줄어들고, 너무 크면 클라이언트와 서버의 메모리 사용량이 증가하고 타임아웃이 발생할 수 있습니다. 최적값은 데이터 크기, 네트워크 환경, 서버 성능에 따라 다르므로 실험을 통해 환경에 맞는 배치 크기를 찾는 것이 좋습니다."

**꼬리 질문**
- Q: 100만 개의 데이터를 삽입할 때 어떻게 처리하나요?
- A: 배치 크기(예: 5000)로 나누어 여러 번 실행하고, 진행 상황을 모니터링합니다.

**실무 연관**
- 대량 데이터 마이그레이션, 초기 데이터 로드 시 사용됩니다.

</details>

<details>
<summary><strong>6. Redis 트랜잭션은 롤백을 지원하나요?</strong></summary>

**모범 답안 포인트**
- 문법 에러: 전체 트랜잭션이 실행되지 않음 (유사 롤백)
- 런타임 에러: 에러 난 명령어만 실패, 나머지는 정상 실행 (롤백 없음)
- 전통적인 RDBMS의 롤백과는 다름
- 대안: Lua 스크립트로 사전 검증

**예시 답변**
> "Redis 트랜잭션은 전통적인 RDBMS의 롤백과는 다르게 동작합니다. 명령어 문법 에러가 있으면 전체 트랜잭션이 실행되지 않지만, 런타임 에러(예: 문자열에 INCR 실행)가 발생하면 에러가 난 명령어만 실패하고 나머지 명령어는 정상 실행됩니다. 따라서 중요한 작업은 Lua 스크립트로 사전 검증을 수행하거나, WATCH를 사용하여 충돌을 방지하는 것이 좋습니다."

**꼬리 질문**
- Q: 런타임 에러를 방지하려면 어떻게 해야 하나요?
- A: 트랜잭션 전에 데이터 타입과 값의 유효성을 검증하거나, Lua 스크립트를 사용합니다.

**실무 연관**
- 결제 시스템에서는 Lua 스크립트로 잔액 확인 후 차감하여 런타임 에러를 방지합니다.

</details>

<details>
<summary><strong>7. Lua 스크립트에서 KEYS와 ARGV의 차이는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- KEYS: Redis 키를 전달, 클러스터 라우팅에 사용
- ARGV: 값이나 매개변수를 전달
- KEYS는 반드시 키만 전달해야 함 (클러스터 환경)
- ARGV는 어떤 값이든 전달 가능

**예시 답변**
> "Lua 스크립트에서 KEYS는 Redis 키를 전달하는 배열이고, ARGV는 값이나 매개변수를 전달하는 배열입니다. 가장 큰 차이점은 Redis 클러스터 환경에서 KEYS 배열을 분석하여 어느 노드에 키가 있는지 판단한다는 것입니다. 따라서 키는 반드시 KEYS로 전달해야 하며, ARGV로 키를 전달하면 클러스터에서 올바르게 라우팅되지 않습니다. ARGV는 숫자, 문자열 등 어떤 값이든 전달할 수 있습니다."

**꼬리 질문**
- Q: KEYS를 ARGV로 잘못 전달하면 어떤 에러가 발생하나요?
- A: 클러스터 환경에서 "CROSSSLOT Keys in request don't hash to the same slot" 에러가 발생합니다.

**실무 연관**
- 클러스터 환경에서 스크립트를 작성할 때 반드시 KEYS와 ARGV를 올바르게 사용해야 합니다.

</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. Redis 클러스터 환경에서 트랜잭션과 Lua 스크립트를 사용할 때 주의할 점은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 모든 키가 같은 해시 슬롯에 있어야 함
- 해시 태그 사용 (예: {user:1000}:name, {user:1000}:email)
- KEYS 배열로 키를 전달해야 올바른 노드로 라우팅
- 여러 노드에 걸친 트랜잭션은 불가능

**예시 답변**
> "Redis 클러스터 환경에서는 트랜잭션이나 Lua 스크립트에 포함된 모든 키가 같은 해시 슬롯에 위치해야 합니다. 이를 보장하기 위해 해시 태그를 사용합니다. 예를 들어 '{user:1000}:name'과 '{user:1000}:email'은 중괄호 안의 'user:1000'을 기준으로 해시 슬롯이 결정되어 같은 노드에 저장됩니다. 또한 Lua 스크립트에서는 키를 KEYS 배열로 전달해야 클러스터가 올바른 노드로 라우팅할 수 있습니다. 여러 노드에 걸친 트랜잭션은 Redis 클러스터에서 지원하지 않으므로 설계 단계에서 이를 고려해야 합니다."

**꼬리 질문**
- Q: 해시 태그 없이 여러 키를 사용하면 어떻게 되나요?
- A: "CROSSSLOT Keys in request don't hash to the same slot" 에러가 발생합니다.

**실무 예시**
```lua
-- 올바른 예시 (클러스터 환경)
local user_id = ARGV[1]
local name_key = '{user:' .. user_id .. '}:name'
local email_key = '{user:' .. user_id .. '}:email'

redis.call('SET', name_key, ARGV[2])
redis.call('SET', email_key, ARGV[3])
return {name_key, email_key}
```

**실무 연관**
- 대규모 서비스에서 클러스터를 사용할 때 필수적으로 고려해야 하는 사항입니다.

</details>

<details>
<summary><strong>2. 분산 락 구현 시 고려해야 할 사항과 Redlock 알고리즘에 대해 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 기본 분산 락: SET NX PX 사용
- 락 해제 시 소유자 확인 필요 (Lua 스크립트 사용)
- Redlock: 여러 Redis 인스턴스에 락 획득하여 안정성 향상
- 과반수 이상에서 락 획득 시 성공
- TTL 설정으로 데드락 방지

**예시 답변**
> "분산 락을 구현할 때는 먼저 'SET key value PX milliseconds NX' 명령으로 락을 획득합니다. 락을 해제할 때는 Lua 스크립트로 현재 락의 소유자를 확인한 후 삭제해야 다른 클라이언트의 락을 실수로 해제하는 것을 방지할 수 있습니다. 단일 Redis 인스턴스에서는 장애 시 락이 사라질 수 있으므로, Redlock 알고리즘을 사용하여 여러 Redis 인스턴스(일반적으로 5개)에 동시에 락을 획득하고, 과반수 이상에서 성공하면 락 획득으로 간주합니다. TTL을 설정하여 클라이언트가 비정상 종료되어도 일정 시간 후 자동으로 락이 해제되도록 해야 합니다."

**꼬리 질문**
- Q: Redlock의 단점은 무엇인가요?
- A: 여러 인스턴스와 통신해야 하므로 성능이 떨어지고, 구현 복잡도가 높습니다.

**실무 예시**
```python
# 안전한 락 해제 스크립트
unlock_script = """
local lock_key = KEYS[1]
local identifier = ARGV[1]

if redis.call('GET', lock_key) == identifier then
    return redis.call('DEL', lock_key)
else
    return 0
end
"""
```

**실무 연관**
- 중복 작업 방지, 크론 잡 동기화, 분산 환경에서의 자원 접근 제어에 사용됩니다.

</details>

<details>
<summary><strong>3. Lua 스크립트의 성능 최적화 방법과 주의사항을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- SCRIPT LOAD로 스크립트 사전 로드
- EVALSHA로 실행하여 네트워크 전송량 감소
- 스크립트는 짧고 간결하게 작성
- 무한 루프 방지 (lua-time-limit 설정)
- 비결정적 함수(random) 사용 제한

**예시 답변**
> "Lua 스크립트의 성능을 최적화하려면 먼저 SCRIPT LOAD로 스크립트를 Redis 서버에 미리 로드하고, EVALSHA로 SHA 해시를 사용하여 실행하면 매번 전체 스크립트를 전송하지 않아 네트워크 전송량이 감소합니다. 스크립트는 가능한 짧고 간결하게 작성하여 실행 시간을 최소화해야 하며, 무한 루프를 방지하기 위해 반복문에 최대 횟수를 설정해야 합니다. Redis는 lua-time-limit 설정으로 스크립트 실행 시간을 제한하므로, 복잡한 작업은 여러 스크립트로 나누는 것이 좋습니다. 또한 비결정적 함수(math.random 등)는 복제와 AOF 재생 시 일관성 문제를 일으킬 수 있으므로 클라이언트에서 값을 생성하여 전달해야 합니다."

**꼬리 질문**
- Q: lua-time-limit을 초과하면 어떻게 되나요?
- A: SCRIPT KILL로 스크립트를 강제 종료할 수 있지만, 쓰기 작업이 있었다면 종료할 수 없습니다.

**실무 예시**
```python
# 스크립트 로드 및 재사용
import redis

r = redis.Redis()

script = """
local key = KEYS[1]
local increment = tonumber(ARGV[1])
return redis.call('INCRBY', key, increment)
"""

# 스크립트 등록
increment_script = r.register_script(script)

# SHA로 실행 (효율적)
result = increment_script(keys=['counter'], args=[5])
```

**실무 연관**
- 고성능 API에서 Lua 스크립트를 미리 로드하여 응답 시간을 최소화합니다.

</details>

<details>
<summary><strong>4. 대량 데이터 처리 시 파이프라인과 트랜잭션의 조합 전략을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 파이프라인으로 네트워크 왕복 감소
- 트랜잭션으로 원자성 보장
- 배치 크기 최적화 (1000~5000)
- 에러 처리 및 재시도 로직
- 진행 상황 모니터링

**예시 답변**
> "대량 데이터를 처리할 때는 파이프라인과 트랜잭션을 함께 사용하여 성능과 데이터 일관성을 모두 보장할 수 있습니다. Python redis-py에서는 `r.pipeline(transaction=True)`로 파이프라인과 트랜잭션을 함께 사용할 수 있습니다. 배치 크기는 1000~5000개로 설정하여 메모리 사용량과 성능의 균형을 맞추고, 각 배치마다 파이프라인을 실행하여 진행 상황을 모니터링합니다. 에러 발생 시 재시도 로직을 구현하고, 최대 재시도 횟수를 설정하여 무한 루프를 방지해야 합니다. 또한 중요한 작업은 로그를 남겨 추적 가능하게 해야 합니다."

**꼬리 질문**
- Q: 100만 건의 데이터를 안전하게 삽입하는 방법을 설명해주세요.
- A: 배치 크기 5000으로 나누어 200번 실행하며, 각 배치마다 성공/실패를 로깅하고 실패 시 재시도합니다.

**실무 예시**
```python
import redis

r = redis.Redis()

def bulk_insert_with_transaction(data_generator, batch_size=5000):
    """대량 데이터 안전 삽입"""
    total = 0

    while True:
        pipe = r.pipeline(transaction=True)
        batch = []

        # 배치 크기만큼 데이터 수집
        for _ in range(batch_size):
            try:
                item = next(data_generator)
                batch.append(item)
            except StopIteration:
                break

        if not batch:
            break

        # 트랜잭션으로 배치 실행
        pipe.multi()
        for key, value in batch:
            pipe.set(key, value)

        try:
            pipe.execute()
            total += len(batch)
            print(f"처리됨: {total}건")
        except Exception as e:
            print(f"에러 발생: {e}")
            # 재시도 로직...

    return total
```

**실무 연관**
- 데이터 마이그레이션, 초기 데이터 로드, 배치 작업에서 사용됩니다.

</details>

<details>
<summary><strong>5. Redis 트랜잭션과 Lua 스크립트의 성능 차이와 선택 기준을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- Lua 스크립트가 일반적으로 더 빠름 (네트워크 왕복 없음)
- 트랜잭션은 WATCH 사용 시 재시도 오버헤드 발생
- 조건 분기가 필요하면 Lua 스크립트 필수
- 간단한 작업은 트랜잭션, 복잡한 로직은 Lua 스크립트

**예시 답변**
> "성능 측면에서는 Lua 스크립트가 일반적으로 트랜잭션보다 빠릅니다. Lua 스크립트는 서버에서 한 번에 실행되므로 네트워크 왕복이 없지만, WATCH를 사용하는 트랜잭션은 충돌 시 재시도로 인한 오버헤드가 발생합니다. 선택 기준은 복잡도와 요구사항에 따라 다릅니다. 간단한 원자적 작업(여러 SET 명령)은 트랜잭션으로도 충분하지만, 조건 분기나 복잡한 비즈니스 로직이 필요하면 Lua 스크립트를 사용해야 합니다. 또한 Lua 스크립트는 한 번 로드하면 재사용할 수 있어 반복적인 작업에서 더 효율적입니다."

**꼬리 질문**
- Q: WATCH를 사용하지 않는 간단한 트랜잭션과 Lua 스크립트의 성능 차이는?
- A: 큰 차이는 없지만, Lua 스크립트가 약간 더 빠르고 코드가 간결합니다.

**실무 예시**
| 작업 | 추천 방법 | 이유 |
|------|-----------|------|
| 여러 키 일괄 저장 | 트랜잭션 | 간단하고 충분함 |
| 조건부 업데이트 | Lua 스크립트 | 조건 분기 필요 |
| 재고 차감 | Lua 스크립트 | 재고 확인 + 차감 원자성 |
| 레이트 리미터 | Lua 스크립트 | 복잡한 시간 윈도우 계산 |

**실무 연관**
- API 성능 최적화, 복잡한 비즈니스 로직 구현 시 적절한 방법을 선택합니다.

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 트랜잭션 | 여러 명령어를 원자적으로 실행 | MULTI, EXEC, WATCH, 원자성 |
| 파이프라인 | 네트워크 왕복 시간 최소화 | RTT 감소, 성능 최적화, 배치 처리 |
| Lua 스크립트 | 서버에서 실행되는 원자적 스크립트 | EVAL, EVALSHA, 조건 분기, 복잡한 로직 |
| WATCH | 낙관적 락 구현 | 동시성 제어, Race Condition 방지 |
| 분산 락 | 여러 클라이언트의 자원 접근 제어 | SET NX PX, Redlock, 중복 방지 |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| MULTI | 트랜잭션 시작 | `MULTI` |
| EXEC | 트랜잭션 실행 | `EXEC` |
| WATCH | 키 감시 | `WATCH mykey` |
| EVAL | Lua 스크립트 실행 | `EVAL "return 'hello'" 0` |
| SCRIPT LOAD | 스크립트 로드 | `SCRIPT LOAD "script..."` |
| pipeline() | 파이프라인 생성 | `r.pipeline()` |

### 실무 베스트 프랙티스

#### 해야 할 것
- [x] WATCH로 동시성 문제를 방지하세요
- [x] 파이프라인 배치 크기를 1000~5000으로 설정하세요
- [x] Lua 스크립트는 SCRIPT LOAD로 미리 로드하세요
- [x] 분산 락 해제 시 소유자를 확인하세요
- [x] 재시도 로직에 최대 횟수를 설정하세요

#### 하지 말아야 할 것
- [x] 런타임 에러를 방지하지 않은 채 트랜잭션 실행
- [x] 파이프라인을 너무 큰 배치로 실행 (메모리 부족)
- [x] Lua 스크립트에서 무한 루프 작성
- [x] KEYS와 ARGV를 잘못 사용 (클러스터 환경)
- [x] 트랜잭션 내부에서 조건 분기 시도

### 성능/보안 체크리스트

#### 성능
- [x] 파이프라인 배치 크기 최적화
- [x] Lua 스크립트 사전 로드 (SCRIPT LOAD)
- [x] WATCH 재시도 횟수 제한
- [x] 네트워크 왕복 횟수 최소화

#### 보안
- [x] 분산 락 소유자 확인
- [x] TTL 설정으로 데드락 방지
- [x] 재고 오버셀링 방지
- [x] Race Condition 차단

---

## 🚀 다음 단계

### 다음 장 미리보기: Redis 10장 - Pub/Sub과 스트림
- **배울 내용 1**: Redis Pub/Sub 메시징 시스템
- **배울 내용 2**: Redis Stream을 이용한 이벤트 처리
- **배울 내용 3**: 실시간 알림 시스템 구축
- **실전 프로젝트**: 실시간 채팅 애플리케이션

### 이 장과의 연결점
```
09장: 트랜잭션, 파이프라인, 스크립트
    ↓
10장: Pub/Sub과 스트림으로 실시간 데이터 처리
    ↓
최종적으로: 고성능 실시간 애플리케이션 구축
```

### 준비하면 좋을 것들
```bash
# Redis 스트림 활성화 확인
redis-cli INFO stream

# Pub/Sub 테스트 환경 준비
redis-cli SUBSCRIBE test_channel
```

---

## 🎉 축하합니다!

**이제 여러분은**:
- ✅ Redis 트랜잭션으로 동시성 문제를 해결할 수 있습니다
- ✅ 파이프라인으로 대량 데이터를 빠르게 처리할 수 있습니다
- ✅ Lua 스크립트로 복잡한 비즈니스 로직을 구현할 수 있습니다
- ✅ 분산 락으로 중복 작업을 방지할 수 있습니다
- ✅ 실무에서 재고 관리 시스템을 구축할 수 있습니다

**다음 단계**:
- [x] 다음 장(Redis Pub/Sub)으로 진행
- [x] 실전 프로젝트 확장 (대시보드, 알림 시스템)
- [x] 면접 질문 복습 및 답변 연습

---

**다음 장으로 이동**: [다음: 10장 Pub/Sub과 스트림 →](10-pubsub-stream.md)

**이전 장으로 돌아가기**: [← 이전: 08장 보안 →](08-security.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
