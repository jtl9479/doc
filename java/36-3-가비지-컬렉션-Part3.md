# 36장 가비지 컬렉션 (GC) - Part 3: 면접 질문

## 🎤 면접 질문 TOP 3

### Q1. Minor GC와 Major GC의 차이는?

**답변**:
```
Minor GC (Young Generation):
- Eden + Survivor 영역 대상
- 자주 발생 (수초마다)
- 빠른 속도 (수 ms)
- Stop-The-World 짧음
- 대부분 객체가 죽음 (단명 객체)

Major GC (Old Generation):
- Old Generation 대상
- 가끔 발생
- 느린 속도 (수백 ms ~ 초)
- Stop-The-World 김
- Full GC 포함

예시:
[GC (Allocation Failure) [PSYoungGen: 2048K->256K(2560K)]
   → Minor GC, Young만 정리

[Full GC (Ergonomics) [PSYoungGen: 256K->0K]
[ParOldGen: 7000K->5000K(7168K)]
   → Major GC, 전체 정리
```

### Q2. G1 GC가 무엇이고 왜 기본 GC가 되었나?

**답변**:
```
G1 GC (Garbage First):
- Java 9+의 기본 GC
- Region 기반 GC

특징:
1. Heap을 작은 Region으로 분할
   - Young/Old를 고정 영역이 아닌 Region으로 관리
   - 2048개 Region (보통 1~32MB)

2. 예측 가능한 pause time
   - -XX:MaxGCPauseMillis=200 (목표 설정)
   - 목표에 맞춰 GC 수행

3. 큰 Heap에 적합
   - 6GB 이상 권장
   - 수십 GB도 효율적 처리

4. 점진적 정리
   - 가비지 많은 Region 우선 (Garbage First)
   - 전체 Heap 스캔 불필요

기존 CMS 대비 장점:
- Compaction (메모리 단편화 해결)
- 더 예측 가능한 성능
```

### Q3. OutOfMemoryError가 발생하는 원인과 해결 방법은?

**답변**:
```
원인:
1. Heap 부족
   - java.lang.OutOfMemoryError: Java heap space
   - 객체가 너무 많음

2. Metaspace 부족
   - java.lang.OutOfMemoryError: Metaspace
   - 클래스가 너무 많음

3. 메모리 누수
   - 사용 안 하는 객체가 계속 참조됨

해결 방법:

1. Heap 크기 증가
   -Xmx4g → -Xmx8g

2. 메모리 누수 찾기
   // Heap dump 생성
   -XX:+HeapDumpOnOutOfMemoryError
   -XX:HeapDumpPath=/logs/heapdump.hprof

   // MAT로 분석
   - Leak Suspects Report
   - Dominator Tree 확인

3. 코드 최적화
   ❌ 불필요한 객체 생성
   List<Integer> list = new ArrayList<>();
   for (int i = 0; i < 1000000; i++) {
       list.add(i);  // 100만 개 Integer 객체
   }

   ✅ primitive 배열
   int[] array = new int[1000000];

4. 컬렉션 정리
   // WeakHashMap 사용
   private Map<Key, Value> cache = new WeakHashMap<>();

   // 또는 주기적 정리
   if (cache.size() > MAX_SIZE) {
       cache.clear();
   }
```

---

## 🎓 GC 튜닝 체크리스트

```java
// ✅ 1. GC 로그 활성화
-Xlog:gc*:file=gc.log:time,uptime,level,tags

// ✅ 2. OOM 시 Heap dump
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/heapdump.hprof

// ✅ 3. 적절한 Heap 크기
-Xms4g -Xmx4g  // 같은 값으로

// ✅ 4. G1 GC 설정 (기본)
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200

// ✅ 5. GC 스레드 조정
-XX:ConcGCThreads=4
-XX:ParallelGCThreads=8
```

---

## 💡 GC 모니터링 도구

### 1. jstat
```bash
# GC 통계 (1초마다)
jstat -gc <pid> 1000

# 결과:
S0C    S1C    EC       OU       YGC   YGCT    FGC    FGCT
2560   2560   20480    5000     100   0.500   5      1.000
```

### 2. jmap
```bash
# Heap 요약
jmap -heap <pid>

# Heap dump
jmap -dump:format=b,file=heap.bin <pid>
```

### 3. jvisualvm
```
- GUI 도구
- 실시간 모니터링
- GC 시각화
- Heap dump 분석
```

### 4. GC 로그 분석
```bash
# GCeasy (온라인)
https://gceasy.io

# GCViewer (로컬)
java -jar gcviewer.jar gc.log
```

---

## 💡 실전 GC 최적화 예시

### 시나리오: 웹 서버 응답 지연
```
증상:
- 주기적으로 500ms 이상 지연
- GC 로그에서 Full GC 빈번

원인 분석:
[Full GC 18.234s] → Old Generation 가득 참

해결:
1. Heap 크기 증가
   -Xms2g -Xmx2g → -Xms4g -Xmx4g

2. G1 GC로 전환 + pause time 목표
   -XX:+UseG1GC -XX:MaxGCPauseMillis=100

3. 메모리 누수 제거
   - MAT로 Heap dump 분석
   - 캐시 크기 제한 추가

결과:
- Full GC 거의 없음
- 평균 응답 시간 50ms 이하
- 99 percentile 150ms 이하
```

---

## 🎯 GC 선택 가이드

```
작은 Heap (<2GB):
→ Serial GC

중간 Heap (2~6GB):
→ Parallel GC (처리량 중시)
→ G1 GC (지연시간 중시)

큰 Heap (6GB+):
→ G1 GC (기본 선택)

초저지연 요구 (10ms 이하):
→ ZGC / Shenandoah (Java 11+)

컨테이너 환경:
→ G1 GC + 적절한 Heap 크기
→ -XX:+UseContainerSupport
```

**시리즈 완료**: 29-36장 Java 고급 개념 마스터! 🎊🎉
