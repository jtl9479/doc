# 43장 함수형 프로그래밍 - Part 1: 실생활 비유로 이해하기

## 📚 목차
1. [함수형 프로그래밍이란?](#함수형-프로그래밍이란)
2. [비유로 이해하기](#비유로-이해하기)
3. [핵심 개념](#핵심-개념)
4. [실전 예제](#실전-예제)

---

## 🎯 함수형 프로그래밍이란?

### 명령형 vs 선언형

```java
// 🔴 명령형 (Imperative) - "어떻게(How)"
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> result = new ArrayList<>();

for (String name : names) {
    if (name.length() > 3) {
        String upper = name.toUpperCase();
        result.add(upper);
    }
}

// 🟢 선언형 (Declarative) - "무엇을(What)"
List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

**차이점**:
- **명령형**: 상태 변경, 루프, 조건문 → "어떻게 할지" 명령
- **선언형**: 데이터 변환, 파이프라인 → "무엇을 할지" 선언

---

## 📖 비유 1: 공장 조립 라인

**함수형 프로그래밍은 컨베이어 벨트와 같습니다.**

```java
// 🏭 자동차 공장 조립 라인
class CarFactory {
    public List<Car> produceCars(List<Material> materials) {
        return materials.stream()
            .filter(this::isQualityMaterial)      // 품질 검사 (필터)
            .map(this::assembleFrame)             // 프레임 조립 (변환)
            .map(this::paintCar)                  // 도색 (변환)
            .map(this::installEngine)             // 엔진 장착 (변환)
            .filter(this::passInspection)         // 최종 검사 (필터)
            .collect(Collectors.toList());        // 출고 (수집)
    }
}
```

**비유 설명**:
- **filter**: 불량품 걸러내기
- **map**: 각 단계에서 변환
- **collect**: 최종 제품 수집
- **파이프라인**: 순차적 처리

---

## 📖 비유 2: 레시피 요리

**각 단계가 독립적이고 순수합니다.**

```java
// 👨‍🍳 요리 레시피
class CookingRecipe {
    // 순수 함수 - 같은 재료면 항상 같은 결과
    public Dish cook(Ingredients ingredients) {
        return Optional.of(ingredients)
            .map(this::wash)           // 1단계: 세척
            .map(this::cut)            // 2단계: 손질
            .map(this::season)         // 3단계: 양념
            .map(this::cook)           // 4단계: 조리
            .map(this::plate)          // 5단계: 플레이팅
            .orElseThrow(() -> new CookingException("실패"));
    }

    // 각 메서드는 입력을 변경하지 않고 새 결과를 반환
    private Ingredients wash(Ingredients input) {
        return new Ingredients(input.getItems().stream()
            .map(Item::wash)
            .collect(Collectors.toList()));
    }
}
```

---

## 📖 비유 3: 수학 함수

**f(x) = y → 같은 입력은 항상 같은 출력**

```java
// 📐 수학적 함수
class MathFunctions {
    // 순수 함수 (Pure Function)
    public int add(int a, int b) {
        return a + b;  // 항상 같은 결과
    }

    // 비순수 함수 (Impure Function)
    private int counter = 0;
    public int addWithSideEffect(int a, int b) {
        counter++;  // 외부 상태 변경!
        return a + b + counter;  // 매번 다른 결과
    }
}

// 사용
MathFunctions math = new MathFunctions();
System.out.println(math.add(2, 3));  // 항상 5
System.out.println(math.addWithSideEffect(2, 3));  // 6
System.out.println(math.addWithSideEffect(2, 3));  // 7 (다름!)
```

---

## 🔑 핵심 개념

### 1. 순수 함수 (Pure Function)

**같은 입력 → 같은 출력, 부작용 없음**

```java
// ✅ 순수 함수
class PureFunctions {
    // 1. 입력만 사용
    public int multiply(int a, int b) {
        return a * b;
    }

    // 2. 외부 상태 읽지 않음
    public String toUpperCase(String input) {
        return input.toUpperCase();
    }

    // 3. 불변 객체 반환
    public List<Integer> doubleNumbers(List<Integer> numbers) {
        return numbers.stream()
            .map(n -> n * 2)
            .collect(Collectors.toList());
    }
}

// ❌ 비순수 함수
class ImpureFunctions {
    private int total = 0;

    // 외부 상태 변경
    public int add(int value) {
        total += value;  // 부작용!
        return total;
    }

    // 외부 상태 읽기
    public int getTotal() {
        return total;
    }
}
```

**순수 함수의 장점**:
- **테스트 용이**: Mock 불필요
- **예측 가능**: 결과가 명확
- **병렬 처리**: Thread-safe
- **캐싱 가능**: 메모이제이션

---

### 2. 불변성 (Immutability)

**데이터를 변경하지 않고 새로 생성**

```java
// ❌ 가변 객체
class MutablePerson {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;  // 변경!
    }

    public void setAge(int age) {
        this.age = age;  // 변경!
    }
}

// ✅ 불변 객체
class ImmutablePerson {
    private final String name;
    private final int age;

    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 변경이 아닌 새 객체 반환
    public ImmutablePerson withName(String newName) {
        return new ImmutablePerson(newName, this.age);
    }

    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge);
    }
}

// 사용
ImmutablePerson person = new ImmutablePerson("Alice", 30);
ImmutablePerson updated = person.withAge(31);  // 새 객체
System.out.println(person.getAge());   // 30 (원본 유지)
System.out.println(updated.getAge());  // 31
```

---

### 3. 고차 함수 (Higher-Order Function)

**함수를 인자로 받거나 반환하는 함수**

```java
// 고차 함수 예제
class HigherOrderFunctions {
    // 1. 함수를 인자로 받기
    public <T> List<T> filter(List<T> list, Predicate<T> condition) {
        return list.stream()
            .filter(condition)
            .collect(Collectors.toList());
    }

    // 2. 함수를 반환하기
    public Function<Integer, Integer> createMultiplier(int factor) {
        return x -> x * factor;
    }

    // 3. 함수 조합
    public <T, R, V> Function<T, V> compose(
            Function<T, R> f1,
            Function<R, V> f2) {
        return f1.andThen(f2);
    }
}

// 사용
HigherOrderFunctions hof = new HigherOrderFunctions();

// 1. 함수를 인자로 전달
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evens = hof.filter(numbers, n -> n % 2 == 0);
System.out.println(evens);  // [2, 4]

// 2. 함수 생성
Function<Integer, Integer> triple = hof.createMultiplier(3);
System.out.println(triple.apply(5));  // 15

// 3. 함수 조합
Function<String, String> toUpper = String::toUpperCase;
Function<String, Integer> getLength = String::length;
Function<String, Integer> upperLength = hof.compose(toUpper, getLength);
System.out.println(upperLength.apply("hello"));  // 5
```

---

### 4. 함수 합성 (Function Composition)

**작은 함수들을 조합하여 복잡한 기능 구현**

```java
// 함수 합성 예제
class FunctionComposition {
    // 기본 함수들
    Function<String, String> trim = String::trim;
    Function<String, String> toUpper = String::toUpperCase;
    Function<String, String> addExclamation = s -> s + "!";

    // 함수 합성
    public String processText(String text) {
        return trim
            .andThen(toUpper)
            .andThen(addExclamation)
            .apply(text);
    }

    // 더 복잡한 예제
    public Function<User, String> createUserProcessor() {
        Function<User, String> getName = User::getName;
        Function<String, String> validateName = name -> {
            if (name.length() < 2) {
                throw new IllegalArgumentException("이름이 너무 짧습니다");
            }
            return name;
        };
        Function<String, String> formatName = String::toUpperCase;

        return getName
            .andThen(validateName)
            .andThen(formatName);
    }
}

// 사용
FunctionComposition fc = new FunctionComposition();
String result = fc.processText("  hello  ");
System.out.println(result);  // "HELLO!"
```

---

## 💡 실전 예제

### 예제 1: 사용자 데이터 처리

```java
// 🔴 명령형 스타일
class ImperativeUserService {
    public List<String> getActiveUserEmails(List<User> users) {
        List<String> result = new ArrayList<>();

        for (User user : users) {
            if (user.isActive()) {
                String email = user.getEmail();
                if (email != null && !email.isEmpty()) {
                    result.add(email.toLowerCase());
                }
            }
        }

        return result;
    }
}

// 🟢 함수형 스타일
class FunctionalUserService {
    public List<String> getActiveUserEmails(List<User> users) {
        return users.stream()
            .filter(User::isActive)
            .map(User::getEmail)
            .filter(Objects::nonNull)
            .filter(email -> !email.isEmpty())
            .map(String::toLowerCase)
            .collect(Collectors.toList());
    }
}
```

---

### 예제 2: 주문 처리 파이프라인

```java
class OrderProcessor {
    // 각 단계를 순수 함수로 정의
    private Order validateOrder(Order order) {
        if (order.getItems().isEmpty()) {
            throw new IllegalArgumentException("주문 항목이 없습니다");
        }
        return order;
    }

    private Order calculateTotal(Order order) {
        BigDecimal total = order.getItems().stream()
            .map(Item::getPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        return order.withTotal(total);
    }

    private Order applyDiscount(Order order) {
        if (order.getTotal().compareTo(new BigDecimal("100000")) > 0) {
            BigDecimal discounted = order.getTotal().multiply(new BigDecimal("0.9"));
            return order.withTotal(discounted);
        }
        return order;
    }

    private Order addShippingFee(Order order) {
        BigDecimal fee = new BigDecimal("3000");
        return order.withTotal(order.getTotal().add(fee));
    }

    // 함수 조합으로 전체 프로세스 구현
    public Order process(Order order) {
        return Optional.of(order)
            .map(this::validateOrder)
            .map(this::calculateTotal)
            .map(this::applyDiscount)
            .map(this::addShippingFee)
            .orElseThrow(() -> new ProcessingException("처리 실패"));
    }
}
```

---

### 예제 3: 데이터 변환 파이프라인

```java
class DataPipeline {
    // CSV 데이터를 읽어 통계 생성
    public Statistics processCSV(String filePath) {
        try {
            return Files.lines(Paths.get(filePath))
                .skip(1)                              // 헤더 제외
                .map(line -> line.split(","))         // 분리
                .filter(parts -> parts.length == 3)   // 유효성 검사
                .map(this::parseRecord)               // 파싱
                .filter(Optional::isPresent)          // 성공한 것만
                .map(Optional::get)
                .collect(Collectors.collectingAndThen(
                    Collectors.toList(),
                    this::calculateStatistics
                ));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private Optional<Record> parseRecord(String[] parts) {
        try {
            return Optional.of(new Record(
                parts[0],
                Integer.parseInt(parts[1]),
                Double.parseDouble(parts[2])
            ));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }

    private Statistics calculateStatistics(List<Record> records) {
        DoubleSummaryStatistics stats = records.stream()
            .mapToDouble(Record::getValue)
            .summaryStatistics();

        return new Statistics(
            stats.getCount(),
            stats.getAverage(),
            stats.getMax(),
            stats.getMin()
        );
    }
}
```

---

## 🎓 핵심 요약

### 함수형 프로그래밍 4대 원칙

1. **순수 함수**
   - 같은 입력 → 같은 출력
   - 부작용 없음

2. **불변성**
   - 데이터 변경 금지
   - 새 객체 생성

3. **고차 함수**
   - 함수를 값처럼 다룸
   - 함수를 인자/반환

4. **함수 합성**
   - 작은 함수 조합
   - 파이프라인 구성

### 명령형 vs 함수형

```java
// 명령형: 어떻게 (How)
for, while, if, 변수 할당

// 함수형: 무엇을 (What)
map, filter, reduce, compose
```

**다음 Part 2**: 기업 사례 & 주니어 실수
