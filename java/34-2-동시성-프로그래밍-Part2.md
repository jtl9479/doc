# 34장 동시성 프로그래밍 - Part 2: 실전 패턴

## 🏢 실전 패턴

### 1. 생산자-소비자 패턴
```java
BlockingQueue<Task> queue = new LinkedBlockingQueue<>();

// 생산자
new Thread(() -> {
    while (true) {
        Task task = createTask();
        queue.put(task);
    }
}).start();

// 소비자
new Thread(() -> {
    while (true) {
        Task task = queue.take();
        process(task);
    }
}).start();
```

### 2. Future 패턴
```java
ExecutorService executor = Executors.newFixedThreadPool(10);

Future<String> future = executor.submit(() -> {
    // 무거운 작업
    return "결과";
});

// 다른 작업 수행...

// 필요할 때 결과 가져오기
String result = future.get();
```

### 3. Fork/Join 패턴
```java
ForkJoinPool pool = new ForkJoinPool();

RecursiveTask<Integer> task = new RecursiveTask<>() {
    @Override
    protected Integer compute() {
        if (작은_작업) {
            return 직접_계산();
        }
        // 작업 분할
        RecursiveTask<Integer> left = new ...();
        RecursiveTask<Integer> right = new ...();

        left.fork();  // 비동기 실행
        int rightResult = right.compute();
        int leftResult = left.join();

        return leftResult + rightResult;
    }
};

int result = pool.invoke(task);
```

---

## 🚨 주니어 실수

### ❌ 실수 1: ExecutorService 종료 누락
```java
// ❌ 프로그램이 종료 안 됨!
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.submit(() -> {});
// shutdown() 호출 안 함!

// ✅ 반드시 종료
executor.shutdown();
```

### ❌ 실수 2: synchronized 대신 Concurrent 미사용
```java
// ❌ synchronized로 전체 잠금
Map<String, Integer> map = Collections.synchronizedMap(new HashMap<>());

// ✅ ConcurrentHashMap 사용
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
```

### ❌ 실수 3: Future.get() 무한 대기
```java
// ❌ 무한 대기 가능
Future<String> future = executor.submit(() -> {});
String result = future.get();  // 영원히 대기할 수 있음!

// ✅ 타임아웃 설정
String result = future.get(5, TimeUnit.SECONDS);
```

**다음 Part 3**: 면접 질문
