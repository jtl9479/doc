# 섹션 35: 실전 사례 연구

## 개요

이 섹션에서는 실제 기업들이 Docker를 어떻게 활용하고 있는지, 그리고 LK-Trade 프로젝트에서 배운 내용을 어떻게 실전에 적용하는지 살펴봅니다.

---

## 사례 1: Spotify - 마이크로서비스 아키텍처

### 배경

- **회사**: Spotify
- **규모**: 수천 개의 마이크로서비스
- **과제**: 빠른 개발 및 배포, 팀 자율성

### Docker 도입 이유

```
도입 전 문제점
=============
❌ 개발 환경과 프로덕션 환경 불일치
❌ 배포에 수 시간 소요
❌ 서비스 간 의존성 관리 어려움
❌ 리소스 낭비 (VM 단위 배포)

Docker 도입 후
=============
✅ "작동하는 컨테이너"로 표준화
✅ 배포 시간 수 분으로 단축
✅ 컨테이너로 의존성 격리
✅ 리소스 효율 70% 향상
```

### 아키텍처

```
Spotify 아키텍처
================

개발자 워크스테이션
    ↓ (git push)
GitHub
    ↓ (webhook)
Jenkins CI/CD
    ↓ (빌드 & 테스트)
Docker 이미지 생성
    ↓ (푸시)
Docker Registry
    ↓ (배포)
Kubernetes 클러스터 (Google Cloud)
    ↓
수천 개의 마이크로서비스
    ├── 음악 추천 서비스
    ├── 플레이리스트 서비스
    ├── 사용자 인증 서비스
    └── 스트리밍 서비스
```

### 배운 교훈

1. **표준화의 중요성**: 모든 서비스가 동일한 배포 파이프라인 사용
2. **자동화**: CI/CD 없이는 규모 확장 불가능
3. **모니터링**: Prometheus + Grafana로 전체 시스템 가시성 확보
4. **문화**: DevOps 문화가 기술만큼 중요

### LK-Trade에 적용

```yaml
# 동일한 패턴 적용
version: '3.8'

services:
  user-service:
    image: ${REGISTRY}/lk-trade/user-service:${VERSION}
    deploy:
      replicas: 3
      # 표준화된 설정
      update_config:
        parallelism: 1
        delay: 10s
      restart_policy:
        condition: on-failure

  trade-service:
    image: ${REGISTRY}/lk-trade/trade-service:${VERSION}
    deploy:
      replicas: 3
      # 동일한 패턴 반복

  # 모든 서비스가 동일한 구조
```

---

## 사례 2: Netflix - Chaos Engineering

### 배경

- **회사**: Netflix
- **규모**: 하루 1억+ 시청 시간
- **과제**: 높은 가용성, 장애 대응

### Docker 활용

```
Netflix의 안정성 전략
====================

1. Immutable Infrastructure
   - 컨테이너는 변경 불가
   - 업데이트 = 새 컨테이너 배포

2. Chaos Monkey
   - 랜덤하게 컨테이너 종료
   - 자동 복구 테스트

3. Circuit Breaker
   - 장애 서비스 격리
   - 연쇄 장애 방지
```

### Chaos Engineering 실습

```bash
#!/bin/bash
# scripts/chaos-test.sh

echo "🐒 Chaos Monkey Test Started"

# 랜덤하게 Pod 삭제
PODS=$(kubectl get pods -n lk-trade -o name)
RANDOM_POD=$(echo "$PODS" | shuf -n 1)

echo "Killing $RANDOM_POD"
kubectl delete $RANDOM_POD -n lk-trade

echo "Waiting for recovery..."
sleep 30

# 시스템 상태 확인
kubectl get pods -n lk-trade

# 헬스체크
curl http://lk-trade.com/health

echo "✅ Chaos test completed"
```

### LK-Trade에 적용

```yaml
# 자가 치유 설정
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1  # 최소 2개는 항상 실행
      maxSurge: 1
  template:
    spec:
      containers:
      - name: user-service
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          failureThreshold: 3
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          failureThreshold: 3
          periodSeconds: 5
```

---

## 사례 3: Airbnb - 빠른 개발 환경

### 배경

- **회사**: Airbnb
- **과제**: 수백 명의 개발자, 복잡한 로컬 환경 설정

### Docker 도입 효과

```
개발 환경 설정 시간
==================

도입 전: 2-3일
- 의존성 설치
- 데이터베이스 설정
- 환경 변수 설정
- 버전 충돌 해결

도입 후: 10분
$ git clone project
$ docker-compose up
$ # 끝!
```

### 개발자 경험 개선

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  # 모든 의존성 포함
  postgres:
    image: postgres:16
    environment:
      POSTGRES_DB: airbnb_dev
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev
    ports:
      - "5432:5432"

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
    ports:
      - "9200:9200"

  app:
    build:
      context: .
      target: development
    volumes:
      - .:/app  # 코드 변경 즉시 반영
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis
      - elasticsearch
    command: npm run dev  # Hot reload
```

### LK-Trade 개발 환경

```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: lk_trade_dev
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev
    ports:
      - "5432:5432"
    volumes:
      - postgres-dev-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  user-service:
    build:
      context: ./modules/user/api
      dockerfile: Dockerfile.dev
    volumes:
      - ./modules/user/api/src:/app/src  # 소스 코드 마운트
    ports:
      - "8081:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
      - SPRING_DEVTOOLS_RESTART_ENABLED=true
    depends_on:
      - postgres
      - redis

volumes:
  postgres-dev-data:
```

```bash
# 신입 개발자 온보딩
$ git clone https://github.com/lk-trade/backend.git
$ cd backend
$ docker-compose -f docker-compose.dev.yml up -d
$ # 10분 후 개발 시작!
```

---

## 사례 4: Pinterest - 비용 절감

### 배경

- **회사**: Pinterest
- **과제**: AWS 비용 증가, 리소스 최적화

### Docker 도입 효과

```
비용 절감 효과
=============

도입 전: VM 기반
- EC2 인스턴스: 1,000대
- 평균 CPU 사용률: 20%
- 연간 비용: $500만

도입 후: 컨테이너 기반
- EC2 인스턴스: 500대
- 평균 CPU 사용률: 60%
- 연간 비용: $200만

절감액: $300만 (60%)
```

### 리소스 최적화 전략

```yaml
# 적절한 리소스 할당
apiVersion: apps/v1
kind: Deployment
metadata:
  name: image-service
spec:
  replicas: 10
  template:
    spec:
      containers:
      - name: image-service
        resources:
          requests:
            cpu: "250m"      # 실제 사용량 기반
            memory: "512Mi"
          limits:
            cpu: "500m"      # 피크 시 최대
            memory: "1Gi"

      # Bin packing: 여러 컨테이너를 하나의 노드에
      nodeSelector:
        workload-type: general-purpose
```

### LK-Trade 비용 최적화

```bash
# 리소스 사용량 분석
kubectl top pods -n lk-trade --containers

# 결과:
# POD                       CONTAINER      CPU    MEMORY
# user-service-abc          user-service   150m   400Mi
# trade-service-def         trade-service  200m   600Mi

# 적절한 리소스 설정
# requests: 평균의 80%
# limits: 피크의 120%
```

---

## 사례 5: GitLab - CI/CD 자동화

### 배경

- **회사**: GitLab
- **제품**: GitLab CI/CD
- **사용 사례**: 자체 플랫폼도 Docker 기반

### GitLab CI/CD 파이프라인

```yaml
# .gitlab-ci.yml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

build:
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

test:
  stage: test
  image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  script:
    - ./gradlew test

deploy:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl set image deployment/app app=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  only:
    - main
```

### LK-Trade GitLab CI/CD

```yaml
# .gitlab-ci.yml
stages:
  - build
  - test
  - security
  - deploy

variables:
  DOCKER_REGISTRY: registry.gitlab.com/lk-trade
  DOCKER_DRIVER: overlay2

# 병렬 빌드
build:
  stage: build
  parallel:
    matrix:
      - SERVICE: [user-service, trade-service, account-service, strategy-service]
  script:
    - cd modules/${SERVICE}/api
    - docker build -t ${DOCKER_REGISTRY}/${SERVICE}:${CI_COMMIT_SHA} .
    - docker push ${DOCKER_REGISTRY}/${SERVICE}:${CI_COMMIT_SHA}

# 보안 스캔
security:
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy image ${DOCKER_REGISTRY}/user-service:${CI_COMMIT_SHA}
  allow_failure: true

# 스테이징 배포
deploy-staging:
  stage: deploy
  script:
    - kubectl config use-context staging
    - kubectl set image deployment/user-service user-service=${DOCKER_REGISTRY}/user-service:${CI_COMMIT_SHA}
  environment:
    name: staging
    url: https://staging.lk-trade.com
  only:
    - develop

# 프로덕션 배포 (수동 승인)
deploy-production:
  stage: deploy
  script:
    - kubectl config use-context production
    - kubectl set image deployment/user-service user-service=${DOCKER_REGISTRY}/user-service:${CI_COMMIT_SHA}
  environment:
    name: production
    url: https://lk-trade.com
  when: manual
  only:
    - main
```

---

## 실전 팁 모음

### 1. 개발 생산성 향상

```bash
# Makefile로 자주 쓰는 명령어 단축
# Makefile
.PHONY: dev up down logs build test deploy

dev:
	docker-compose -f docker-compose.dev.yml up -d
	@echo "✅ Development environment started"
	@echo "📊 Logs: make logs"

up: dev

down:
	docker-compose -f docker-compose.dev.yml down
	@echo "🛑 Development environment stopped"

logs:
	docker-compose -f docker-compose.dev.yml logs -f

build:
	docker-compose -f docker-compose.dev.yml build

test:
	docker-compose -f docker-compose.test.yml up --abort-on-container-exit
	docker-compose -f docker-compose.test.yml down

deploy:
	@read -p "Deploy to which environment? (staging/production): " env; \
	bash scripts/deploy.sh $$env

# 사용
$ make dev      # 개발 환경 시작
$ make logs     # 로그 확인
$ make test     # 테스트 실행
$ make deploy   # 배포
```

### 2. 디버깅 효율화

```bash
# Shell 별칭 설정
# ~/.bashrc or ~/.zshrc

# Docker
alias d='docker'
alias dc='docker-compose'
alias dps='docker ps'
alias dim='docker images'
alias dlog='docker logs -f'
alias dexec='docker exec -it'

# Kubernetes
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'
alias kdp='kubectl describe pod'
alias klog='kubectl logs -f'
alias kexec='kubectl exec -it'

# 네임스페이스 자동 설정
alias kns='kubectl config set-context --current --namespace'

# 사용 예시
$ kns lk-trade       # 네임스페이스 전환
$ kgp                # Pod 목록
$ klog user-service  # 로그 확인
```

### 3. 모니터링 대시보드

```python
#!/usr/bin/env python3
# scripts/dashboard.py
import subprocess
import time
from rich.console import Console
from rich.table import Table

console = Console()

def get_container_stats():
    result = subprocess.run(
        ['docker', 'stats', '--no-stream', '--format',
         '{{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}'],
        capture_output=True,
        text=True
    )
    return result.stdout.strip().split('\n')

def main():
    while True:
        console.clear()
        table = Table(title="Docker Container Stats")
        table.add_column("Container", style="cyan")
        table.add_column("CPU %", style="magenta")
        table.add_column("Memory", style="green")

        stats = get_container_stats()
        for stat in stats:
            if stat:
                name, cpu, mem = stat.split('\t')
                table.add_row(name, cpu, mem)

        console.print(table)
        time.sleep(2)

if __name__ == "__main__":
    main()
```

---

## 교훈 정리

### 성공 요인

```
✅ 1. 명확한 목표
   - 단순히 "Docker 도입"이 아닌
   - "배포 시간 50% 단축" 같은 구체적 목표

✅ 2. 점진적 마이그레이션
   - 한 번에 모든 서비스를 마이그레이션하지 않음
   - 작은 서비스부터 시작 → 학습 → 확장

✅ 3. 표준화
   - Dockerfile 템플릿
   - CI/CD 파이프라인 표준화
   - 모니터링 표준화

✅ 4. 문서화
   - 온보딩 가이드
   - 트러블슈팅 가이드
   - 아키텍처 다이어그램

✅ 5. 팀 교육
   - 워크숍 개최
   - 내부 세미나
   - 페어 프로그래밍
```

### 흔한 실수

```
❌ 1. 과도한 마이크로서비스화
   - 모놀리스도 컨테이너화 가능
   - 필요에 따라 점진적 분리

❌ 2. 상태 관리 무시
   - 컨테이너는 무상태여야 함
   - 상태는 외부 스토리지에

❌ 3. 로그 관리 소홀
   - stdout/stderr로 로그 출력
   - 중앙집중식 로그 수집 필수

❌ 4. 보안 무시
   - 이미지 스캔 필수
   - Secret 관리 필수
   - non-root 사용자

❌ 5. 모니터링 부족
   - "보이지 않으면 관리 불가"
   - 메트릭, 로그, 트레이싱 모두 필요
```

---

## 다음 단계

이제 실전 사례를 통해 Docker를 어떻게 실무에 적용하는지 배웠습니다!

### 다음 섹션

**섹션 36-44**에서는:
- Docker 치트시트
- 용어 사전
- 자주 묻는 질문 (FAQ)
- 문제 해결 가이드
- 추가 학습 리소스
- 커뮤니티 및 컨퍼런스
- 인증 및 자격증
- 마무리 및 다음 학습 경로

---

**계속해서 학습하세요!** 🚀