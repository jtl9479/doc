# 섹션 29: 프로덕션 배포 전략

## 비유로 시작하기

배포 전략은 **비행기 교체**와 같습니다.

```
항공사의 비행기 교체                 프로덕션 배포
====================                 =============
✈️ 신형 비행기 도입              →   새 버전 배포
👥 승객 이동 계획                →   트래픽 전환 전략
🔧 점진적 교체                   →   Rolling/Canary 배포
✈️✈️ 두 대 동시 운영            →   Blue-Green 배포
🚨 문제 시 즉시 복귀            →   롤백 전략
📊 승객 피드백 수집              →   모니터링 & 알림
```

비행기를 한 번에 모두 교체하면 위험하듯이, 서비스를 한 번에 모두 업데이트하면 장애 발생 시 큰 피해를 입습니다.

---

## 왜 배포 전략이 중요한가?

### 1. 배포 실패 시나리오

```
❌ 무계획 배포 (All at Once)
===========================

15:00 - 새 버전 배포 시작
15:01 - 모든 서버를 동시에 새 버전으로 교체
15:02 - 치명적인 버그 발견!
15:03 - 모든 사용자가 서비스 이용 불가
15:04 - 긴급 롤백 시도
15:10 - 롤백 완료, 6분간 전체 서비스 중단
결과: 매출 손실, 고객 이탈, 브랜드 이미지 손상 💀


✅ Canary 배포 (점진적)
=======================

15:00 - 새 버전 배포 시작
15:01 - 5%의 트래픽만 새 버전으로 전환
15:02 - 5% 사용자 모니터링 → 버그 발견!
15:03 - 즉시 새 버전 중단
15:04 - 95%의 사용자는 영향 없음
결과: 5%만 잠깐 영향, 빠른 대응, 피해 최소화 ✨
```

### 2. 다운타임의 비용

```
다운타임 비용 계산
=================

가정:
- 일 평균 거래액: $1,000,000
- 1시간 다운타임 비용: $1,000,000 / 24 = $41,667
- 1분 다운타임 비용: $694

시나리오별 비용:
┌─────────────────────┬──────────────┬─────────────┐
│ 배포 전략           │ 다운타임     │ 비용        │
├─────────────────────┼──────────────┼─────────────┤
│ All at Once         │ 5분          │ $3,470      │
│ Rolling Update      │ 0분 (무중단) │ $0          │
│ Blue-Green          │ 30초 (전환)  │ $347        │
│ Canary (버그 발견)  │ 0분 (5%만)   │ ~$0         │
└─────────────────────┴──────────────┴─────────────┘

+ 고객 신뢰도 하락
+ 브랜드 이미지 손상
+ 경쟁사로 이탈
```

---

## 배포 전략의 종류

### 1. 전체 비교

```
┌──────────────────┬──────────────┬───────────┬───────────┬──────────────┐
│ 전략             │ 다운타임     │ 롤백 속도 │ 리소스    │ 복잡도       │
├──────────────────┼──────────────┼───────────┼───────────┼──────────────┤
│ Recreate         │ 있음 (5분+)  │ 느림      │ 1배       │ 낮음         │
│ Rolling Update   │ 없음         │ 느림      │ 1배       │ 중간         │
│ Blue-Green       │ 거의 없음    │ 매우 빠름 │ 2배       │ 중간         │
│ Canary           │ 없음         │ 빠름      │ 1.1배     │ 높음         │
│ A/B Testing      │ 없음         │ 빠름      │ 1.2배     │ 높음         │
└──────────────────┴──────────────┴───────────┴───────────┴──────────────┘
```

---

## 1. Recreate 배포

가장 간단하지만 다운타임이 발생합니다.

### 동작 방식

```
시간 흐름
=========

기존 버전 (v1.0)
┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │  ← 3개의 컨테이너 실행 중
└─────┘ └─────┘ └─────┘
   |       |       |
   ↓       ↓       ↓
  Stop    Stop    Stop    ← 모두 중지 (다운타임 시작!)
   X       X       X

   ⏳ 다운타임 (5-10분)

   ↓       ↓       ↓
┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │  ← 새 버전 시작 (다운타임 종료)
└─────┘ └─────┘ └─────┘
```

### docker-compose 예시

```yaml
# docker-compose.yml
version: '3.8'

services:
  user-service:
    image: lk-trade/user-service:${VERSION}
    deploy:
      replicas: 3
      # 기본 전략 (Recreate)
```

```bash
# 배포 명령
export VERSION=2.0.0
docker-compose down
docker-compose pull
docker-compose up -d

# 다운타임: docker-compose down부터 up -d 완료까지
```

### 장단점

```
✅ 장점:
- 구현이 매우 간단
- 버전 충돌 없음 (한 번에 하나의 버전만 실행)
- 리소스 효율적 (추가 서버 불필요)

❌ 단점:
- 다운타임 발생 (5-10분)
- 사용자 경험 저하
- 프로덕션 환경에는 부적합
```

**사용 시나리오:**
- 개발/테스트 환경
- 사용자가 없는 시간대 (새벽)
- 유지보수 창구 (maintenance window) 활용

---

## 2. Rolling Update (순차 배포)

무중단으로 점진적으로 업데이트합니다.

### 동작 방식

```
시간 흐름
=========

초기 상태 (v1.0)
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ v1  │ │ v1  │ │ v1  │ │ v1  │  (4개 인스턴스)
└─────┘ └─────┘ └─────┘ └─────┘
   ↓
1단계: 하나씩 교체
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v1  │ │ v1  │ │ v1  │  ← 1개 업데이트
└─────┘ └─────┘ └─────┘ └─────┘
   ↓
2단계
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v1  │ │ v1  │  ← 2개 업데이트
└─────┘ └─────┘ └─────┘ └─────┘
   ↓
3단계
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │ │ v1  │  ← 3개 업데이트
└─────┘ └─────┘ └─────┘ └─────┘
   ↓
완료
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│ v2  │ │ v2  │ │ v2  │ │ v2  │  ← 모두 업데이트
└─────┘ └─────┘ └─────┘ └─────┘

✅ 전체 과정에서 다운타임 없음!
```

### Docker Swarm으로 Rolling Update

```bash
# Swarm 초기화
docker swarm init

# Stack 배포
docker stack deploy -c docker-stack.yml lk-trade
```

```yaml
# docker-stack.yml
version: '3.8'

services:
  user-service:
    image: lk-trade/user-service:${VERSION:-latest}
    deploy:
      replicas: 4
      update_config:
        parallelism: 1        # 한 번에 1개씩 업데이트
        delay: 10s            # 각 업데이트 사이 대기 시간
        failure_action: rollback  # 실패 시 자동 롤백
        monitor: 60s          # 모니터링 시간
        max_failure_ratio: 0.25   # 25% 실패 시 롤백
        order: stop-first     # 기존 컨테이너 중지 후 새 컨테이너 시작
      rollback_config:
        parallelism: 1
        delay: 10s
        failure_action: pause
        monitor: 60s
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 40s
    networks:
      - lk-trade-network

networks:
  lk-trade-network:
    driver: overlay
```

### 배포 및 모니터링

```bash
# 새 버전 배포
export VERSION=2.0.0
docker stack deploy -c docker-stack.yml lk-trade

# 배포 진행 상황 모니터링
watch -n 1 'docker service ps lk-trade_user-service'

# 출력:
ID            NAME                         IMAGE                    NODE    DESIRED STATE  CURRENT STATE
abc123...     lk-trade_user-service.1      lk-trade/user-service:2.0.0  node1   Running        Running 30 seconds ago
def456...     lk-trade_user-service.2      lk-trade/user-service:2.0.0  node1   Running        Running 20 seconds ago
ghi789...     lk-trade_user-service.3      lk-trade/user-service:2.0.0  node1   Running        Running 10 seconds ago
jkl012...     lk-trade_user-service.4      lk-trade/user-service:1.0.0  node1   Shutdown       Shutdown 5 seconds ago

# 서비스 상태 확인
docker service ls
docker service logs -f lk-trade_user-service

# 롤백 (문제 발생 시)
docker service rollback lk-trade_user-service

# 또는 이전 버전으로 재배포
export VERSION=1.0.0
docker stack deploy -c docker-stack.yml lk-trade
```

### 장단점

```
✅ 장점:
- 무중단 배포 (Zero Downtime)
- 점진적 업데이트로 위험 분산
- 자동 헬스체크 및 롤백
- 추가 리소스 불필요

❌ 단점:
- 배포 시간이 김 (전체 업데이트까지)
- v1과 v2가 동시에 실행됨 (호환성 필요)
- 롤백이 느림 (다시 rolling)
```

**사용 시나리오:**
- 일반적인 프로덕션 배포
- 리소스가 제한적인 환경
- 버전 간 호환성이 보장되는 경우

---

## 3. Blue-Green 배포

두 개의 동일한 환경을 운영하고 즉시 전환합니다.

### 동작 방식

```
Blue (기존 환경, v1.0)          Green (새 환경, v2.0)
=========================        =========================

┌───────────────────────┐        ┌───────────────────────┐
│ Load Balancer         │        │                       │
│   ↓                   │        │                       │
│ Blue Environment      │        │ Green Environment     │
│ ┌─────┐ ┌─────┐      │        │ ┌─────┐ ┌─────┐      │
│ │ v1  │ │ v1  │      │        │ │ v2  │ │ v2  │      │
│ └─────┘ └─────┘      │        │ └─────┘ └─────┘      │
│   ↑                   │        │                       │
│ 100% 트래픽           │        │ 0% 트래픽             │
└───────────────────────┘        └───────────────────────┘

            ↓ 테스트 완료, 전환 준비

┌───────────────────────┐        ┌───────────────────────┐
│ Load Balancer         │        │                       │
│       ↓               │        │                       │
│ Blue Environment      │        │ Green Environment     │
│ ┌─────┐ ┌─────┐      │        │ ┌─────┐ ┌─────┐      │
│ │ v1  │ │ v1  │      │        │ │ v2  │ │ v2  │      │
│ └─────┘ └─────┘      │        │ └─────┘ └─────┘      │
│                       │        │   ↑                   │
│ 0% 트래픽             │        │ 100% 트래픽           │
└───────────────────────┘        └───────────────────────┘

            ↓ 문제 없으면 Blue 환경 종료

┌───────────────────────┐
│ Green Environment     │
│ ┌─────┐ ┌─────┐      │
│ │ v2  │ │ v2  │      │
│ └─────┘ └─────┘      │
│   ↑                   │
│ 100% 트래픽           │
└───────────────────────┘

            ↓ Green이 이제 Blue가 됨
```

### Nginx를 이용한 Blue-Green 배포

```yaml
# docker-compose.blue-green.yml
version: '3.8'

services:
  # Nginx 로드 밸런서
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/upstream.conf:/etc/nginx/conf.d/upstream.conf:ro
    networks:
      - lk-trade-network
    depends_on:
      - user-service-blue
      - user-service-green

  # Blue 환경 (현재 운영)
  user-service-blue:
    image: lk-trade/user-service:1.0.0
    container_name: user-service-blue
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DEPLOYMENT_COLOR=blue
    networks:
      - lk-trade-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:8080/actuator/health"]
      interval: 10s
      timeout: 3s
      retries: 3

  # Green 환경 (새 버전)
  user-service-green:
    image: lk-trade/user-service:2.0.0
    container_name: user-service-green
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DEPLOYMENT_COLOR=green
    networks:
      - lk-trade-network
    healthcheck:
      test: ["CMD", "wget", "--spider", "http://localhost:8080/actuator/health"]
      interval: 10s
      timeout: 3s
      retries: 3

networks:
  lk-trade-network:
    driver: bridge
```

```nginx
# nginx/upstream.conf (초기 상태: Blue)
upstream user_service {
    server user-service-blue:8080 max_fails=3 fail_timeout=30s;
    # server user-service-green:8080 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;

    location / {
        proxy_pass http://user_service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # 헬스 체크 응답 시간 초과 설정
        proxy_connect_timeout 2s;
        proxy_send_timeout 2s;
        proxy_read_timeout 2s;
    }

    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
```

### Blue-Green 전환 스크립트

```bash
#!/bin/bash
# scripts/blue-green-deploy.sh

set -e

CURRENT_ENV=${1:-blue}
NEW_ENV=${2:-green}

if [ "$CURRENT_ENV" != "blue" ] && [ "$CURRENT_ENV" != "green" ]; then
    echo "❌ Invalid environment. Use 'blue' or 'green'"
    exit 1
fi

if [ "$CURRENT_ENV" == "blue" ]; then
    NEW_ENV="green"
else
    NEW_ENV="blue"
fi

echo "
╔═══════════════════════════════════════════════════╗
║   Blue-Green Deployment                           ║
╚═══════════════════════════════════════════════════╝

Current Environment: $CURRENT_ENV
New Environment:     $NEW_ENV
"

# 1. 새 환경 헬스 체크
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "1️⃣  Health Check: $NEW_ENV environment"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

MAX_RETRIES=30
RETRY=0

while [ $RETRY -lt $MAX_RETRIES ]; do
    if docker exec user-service-$NEW_ENV wget -q --spider http://localhost:8080/actuator/health; then
        echo "✅ $NEW_ENV environment is healthy"
        break
    fi
    RETRY=$((RETRY+1))
    echo "⏳ Waiting for $NEW_ENV to be ready... ($RETRY/$MAX_RETRIES)"
    sleep 2
done

if [ $RETRY -eq $MAX_RETRIES ]; then
    echo "❌ $NEW_ENV environment health check failed"
    exit 1
fi

# 2. 스모크 테스트
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "2️⃣  Smoke Tests"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

# 기본 API 테스트
if ! docker exec user-service-$NEW_ENV wget -q -O- http://localhost:8080/actuator/info > /dev/null; then
    echo "❌ Smoke test failed"
    exit 1
fi

echo "✅ Smoke tests passed"

# 3. 트래픽 전환
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "3️⃣  Traffic Switch"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

read -p "Switch traffic to $NEW_ENV? (yes/no): " CONFIRM
if [ "$CONFIRM" != "yes" ]; then
    echo "Deployment cancelled"
    exit 0
fi

# Nginx 설정 변경
cat > nginx/upstream.conf <<EOF
upstream user_service {
    server user-service-$NEW_ENV:8080 max_fails=3 fail_timeout=30s;
    # server user-service-$CURRENT_ENV:8080 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;

    location / {
        proxy_pass http://user_service;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;

        proxy_connect_timeout 2s;
        proxy_send_timeout 2s;
        proxy_read_timeout 2s;
    }
}
EOF

# Nginx 재시작
docker exec nginx nginx -s reload
echo "✅ Traffic switched to $NEW_ENV"

# 4. 모니터링
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "4️⃣  Monitoring (60 seconds)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Press Ctrl+C to stop monitoring and rollback"
echo ""

for i in {1..60}; do
    if ! docker exec user-service-$NEW_ENV wget -q --spider http://localhost:8080/actuator/health; then
        echo ""
        echo "❌ Health check failed during monitoring!"
        echo "🔄 Rolling back to $CURRENT_ENV..."

        # 롤백
        cat > nginx/upstream.conf <<EOF
upstream user_service {
    server user-service-$CURRENT_ENV:8080 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    location / {
        proxy_pass http://user_service;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
    }
}
EOF
        docker exec nginx nginx -s reload
        echo "✅ Rolled back to $CURRENT_ENV"
        exit 1
    fi
    echo -n "."
    sleep 1
done

echo ""
echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "5️⃣  Cleanup"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

read -p "Stop $CURRENT_ENV environment? (yes/no): " CLEANUP
if [ "$CLEANUP" == "yes" ]; then
    docker-compose stop user-service-$CURRENT_ENV
    echo "✅ $CURRENT_ENV environment stopped"
else
    echo "⚠️  $CURRENT_ENV environment is still running"
    echo "   You can manually stop it later with:"
    echo "   docker-compose stop user-service-$CURRENT_ENV"
fi

echo ""
echo "✅ Blue-Green deployment completed successfully!"
echo ""
echo "Current active environment: $NEW_ENV"
```

### 사용 방법

```bash
# 1. 초기 상태: Blue 운영 중
docker-compose -f docker-compose.blue-green.yml up -d user-service-blue nginx

# 2. Green 환경에 새 버전 배포
docker-compose -f docker-compose.blue-green.yml up -d user-service-green

# 3. Blue → Green 전환
bash scripts/blue-green-deploy.sh blue

# 4. 문제 발생 시 즉시 롤백 (Green → Blue)
bash scripts/blue-green-rollback.sh green
```

### 장단점

```
✅ 장점:
- 거의 즉시 전환 (1-2초)
- 매우 빠른 롤백 (1-2초)
- 프로덕션과 동일한 환경에서 테스트 가능
- v1과 v2가 격리됨

❌ 단점:
- 리소스 2배 필요
- 데이터베이스 마이그레이션 복잡
- 인프라 비용 증가
```

**사용 시나리오:**
- 중요한 프로덕션 배포
- 빠른 롤백이 필수인 경우
- 리소스가 충분한 환경

---

## 4. Canary 배포

소수의 사용자에게 먼저 배포하여 테스트합니다.

### 동작 방식

```
시간 흐름
=========

초기: 5% Canary
┌───────────────────────────────────────────────┐
│ Load Balancer                                 │
│                                               │
│  5% ──→ ┌─────┐  Canary (v2.0)              │
│         │ v2  │                               │
│         └─────┘                               │
│                                               │
│ 95% ──→ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐     │
│         │ v1  │ │ v1  │ │ v1  │ │ v1  │     │
│         └─────┘ └─────┘ └─────┘ └─────┘     │
└───────────────────────────────────────────────┘

    ↓ 모니터링 (15분) → 문제 없음

25% Canary
┌───────────────────────────────────────────────┐
│ 25% ──→ ┌─────┐ ┌─────┐  Canary (v2.0)       │
│         │ v2  │ │ v2  │                       │
│         └─────┘ └─────┘                       │
│                                               │
│ 75% ──→ ┌─────┐ ┌─────┐ ┌─────┐              │
│         │ v1  │ │ v1  │ │ v1  │              │
│         └─────┘ └─────┘ └─────┘              │
└───────────────────────────────────────────────┘

    ↓ 모니터링 (15분) → 문제 없음

50% Canary
┌───────────────────────────────────────────────┐
│ 50% ──→ ┌─────┐ ┌─────┐ ┌─────┐              │
│         │ v2  │ │ v2  │ │ v2  │              │
│         └─────┘ └─────┘ └─────┘              │
│                                               │
│ 50% ──→ ┌─────┐ ┌─────┐                      │
│         │ v1  │ │ v1  │                      │
│         └─────┘ └─────┘                      │
└───────────────────────────────────────────────┘

    ↓ 모니터링 (15분) → 문제 없음

100% 전환
┌───────────────────────────────────────────────┐
│100% ──→ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐      │
│         │ v2  │ │ v2  │ │ v2  │ │ v2  │      │
│         └─────┘ └─────┘ └─────┘ └─────┘      │
└───────────────────────────────────────────────┘
```

### Traefik을 이용한 Canary 배포

```yaml
# docker-compose.canary.yml
version: '3.8'

services:
  # Traefik (로드 밸런서)
  traefik:
    image: traefik:v2.10
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
    ports:
      - "80:80"
      - "8080:8080"  # Traefik 대시보드
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - lk-trade-network

  # Stable 버전 (v1.0)
  user-service-stable:
    image: lk-trade/user-service:1.0.0
    deploy:
      replicas: 4
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.user-stable.rule=Host(`api.lk-trade.com`)"
        - "traefik.http.services.user-stable.loadbalancer.server.port=8080"
        - "traefik.http.services.user-stable.loadbalancer.sticky.cookie=true"
        # 가중치: 95%
        - "traefik.http.services.user-stable.loadbalancer.weight=95"
    networks:
      - lk-trade-network

  # Canary 버전 (v2.0)
  user-service-canary:
    image: lk-trade/user-service:2.0.0
    deploy:
      replicas: 1
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.user-canary.rule=Host(`api.lk-trade.com`)"
        - "traefik.http.services.user-canary.loadbalancer.server.port=8080"
        - "traefik.http.services.user-canary.loadbalancer.sticky.cookie=true"
        # 가중치: 5%
        - "traefik.http.services.user-canary.loadbalancer.weight=5"
    networks:
      - lk-trade-network

networks:
  lk-trade-network:
    driver: overlay
```

### Canary 배포 자동화 스크립트

```bash
#!/bin/bash
# scripts/canary-deploy.sh

set -e

NEW_VERSION=$1
CANARY_PERCENTAGES=(5 25 50 100)
MONITORING_DURATION=900  # 15분 (초)

if [ -z "$NEW_VERSION" ]; then
    echo "Usage: $0 <new-version>"
    echo "Example: $0 2.0.0"
    exit 1
fi

echo "
╔═══════════════════════════════════════════════════╗
║   Canary Deployment                               ║
╚═══════════════════════════════════════════════════╝

New Version: $NEW_VERSION
Canary Stages: ${CANARY_PERCENTAGES[@]}%
Monitoring Duration: $MONITORING_DURATION seconds per stage
"

# Prometheus 메트릭 체크 함수
check_metrics() {
    local version=$1

    # 에러율 체크
    ERROR_RATE=$(curl -s "http://localhost:9090/api/v1/query?query=rate(http_requests_total{status=~\"5..\",version=\"$version\"}[5m])" | jq -r '.data.result[0].value[1] // 0')

    # 응답 시간 체크
    AVG_RESPONSE_TIME=$(curl -s "http://localhost:9090/api/v1/query?query=histogram_quantile(0.95,http_request_duration_seconds{version=\"$version\"})" | jq -r '.data.result[0].value[1] // 0')

    echo "  Error Rate: $ERROR_RATE"
    echo "  P95 Response Time: ${AVG_RESPONSE_TIME}s"

    # 임계값 체크
    if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
        echo "  ❌ Error rate too high (>1%)"
        return 1
    fi

    if (( $(echo "$AVG_RESPONSE_TIME > 1.0" | bc -l) )); then
        echo "  ❌ Response time too slow (>1s)"
        return 1
    fi

    return 0
}

# Canary 단계별 배포
for PERCENTAGE in "${CANARY_PERCENTAGES[@]}"; do
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "🚀 Deploying Canary: $PERCENTAGE%"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

    # 가중치 계산
    STABLE_WEIGHT=$((100 - PERCENTAGE))
    CANARY_WEIGHT=$PERCENTAGE

    # Docker Compose 파일 업데이트
    cat > docker-compose.canary-weights.yml <<EOF
version: '3.8'

services:
  user-service-stable:
    image: lk-trade/user-service:1.0.0
    deploy:
      labels:
        - "traefik.http.services.user-stable.loadbalancer.weight=$STABLE_WEIGHT"

  user-service-canary:
    image: lk-trade/user-service:$NEW_VERSION
    deploy:
      labels:
        - "traefik.http.services.user-canary.loadbalancer.weight=$CANARY_WEIGHT"
EOF

    # 배포
    docker stack deploy -c docker-compose.canary.yml -c docker-compose.canary-weights.yml lk-trade

    echo "⏳ Monitoring for $MONITORING_DURATION seconds..."

    # 모니터링
    ELAPSED=0
    while [ $ELAPSED -lt $MONITORING_DURATION ]; do
        sleep 30
        ELAPSED=$((ELAPSED + 30))

        echo ""
        echo "[$ELAPSED/${MONITORING_DURATION}s] Checking metrics..."

        if ! check_metrics "$NEW_VERSION"; then
            echo ""
            echo "❌ Canary deployment failed at $PERCENTAGE%"
            echo "🔄 Rolling back..."

            # 롤백
            docker stack deploy -c docker-compose.stable-only.yml lk-trade

            echo "✅ Rolled back to stable version"
            exit 1
        fi

        echo "  ✅ Metrics OK"
    done

    echo ""
    echo "✅ Canary $PERCENTAGE% successful"
    echo ""

    if [ $PERCENTAGE -ne 100 ]; then
        read -p "Continue to next stage? (yes/no): " CONTINUE
        if [ "$CONTINUE" != "yes" ]; then
            echo "Deployment paused at $PERCENTAGE%"
            exit 0
        fi
    fi
done

echo "
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Canary deployment completed successfully!
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Version $NEW_VERSION is now serving 100% of traffic.
"
```

### 장단점

```
✅ 장점:
- 위험 최소화 (소수 사용자만 영향)
- 실제 사용자 환경에서 테스트
- 점진적 트래픽 증가
- 빠른 문제 감지 및 롤백

❌ 단점:
- 구현 복잡도 높음
- 모니터링 필수
- 배포 시간 김 (단계별 모니터링)
- 인프라 복잡성 증가
```

**사용 시나리오:**
- 중대한 변경 사항
- 새로운 기능 출시
- 대규모 사용자 대상 서비스

---

## 5. A/B Testing

비즈니스 메트릭 기반으로 두 버전을 비교합니다.

### Canary vs A/B Testing

```
┌─────────────────┬───────────────────┬──────────────────┐
│                 │ Canary            │ A/B Testing      │
├─────────────────┼───────────────────┼──────────────────┤
│ 목적            │ 안정성 검증       │ 비즈니스 검증    │
│ 사용자 선택     │ 랜덤              │ 의도적 그룹 분리 │
│ 모니터링 지표   │ 에러율, 응답시간  │ 전환율, 매출     │
│ 기간            │ 짧음 (분~시간)    │ 길음 (일~주)     │
│ 최종 결정       │ 자동 (메트릭)     │ 수동 (비즈니스)  │
└─────────────────┴───────────────────┴──────────────────┘
```

### 구현 예시

```yaml
# docker-compose.ab-testing.yml
version: '3.8'

services:
  traefik:
    image: traefik:v2.10
    command:
      - "--providers.docker=true"
      - "--entrypoints.web.address=:80"
    ports:
      - "80:80"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - lk-trade-network

  # 버전 A (기존 UI)
  frontend-a:
    image: lk-trade/frontend:1.0.0-old-ui
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.frontend-a.rule=Host(`lk-trade.com`) && Header(`X-AB-Test`, `A`)"
        - "traefik.http.services.frontend-a.loadbalancer.server.port=80"
        - "traefik.http.middlewares.ab-test-a.headers.customrequestheaders.X-AB-Group=A"
    environment:
      - AB_TEST_GROUP=A
      - FEATURE_NEW_CHECKOUT=false
    networks:
      - lk-trade-network

  # 버전 B (새 UI)
  frontend-b:
    image: lk-trade/frontend:2.0.0-new-ui
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.frontend-b.rule=Host(`lk-trade.com`) && Header(`X-AB-Test`, `B`)"
        - "traefik.http.services.frontend-b.loadbalancer.server.port=80"
        - "traefik.http.middlewares.ab-test-b.headers.customrequestheaders.X-AB-Group=B"
    environment:
      - AB_TEST_GROUP=B
      - FEATURE_NEW_CHECKOUT=true
    networks:
      - lk-trade-network

networks:
  lk-trade-network:
    driver: overlay
```

사용자를 그룹별로 분리:

```javascript
// frontend/ab-test.js
function getABTestGroup() {
    // 쿠키에서 그룹 확인
    let group = getCookie('ab_test_group');

    if (!group) {
        // 50/50 랜덤 배정
        group = Math.random() < 0.5 ? 'A' : 'B';
        setCookie('ab_test_group', group, 30);  // 30일
    }

    return group;
}

// API 요청 시 헤더 추가
fetch('/api/orders', {
    headers: {
        'X-AB-Test': getABTestGroup()
    }
});

// 이벤트 트래킹
function trackEvent(eventName, data) {
    analytics.track(eventName, {
        ...data,
        ab_test_group: getABTestGroup(),
        timestamp: new Date().toISOString()
    });
}

// 예: 체크아웃 완료 트래킹
trackEvent('checkout_completed', {
    order_id: orderId,
    amount: orderAmount
});
```

---

## 6. LK-Trade 프로젝트 배포 전략

### 권장 전략

```
서비스별 배포 전략
=================

┌────────────────────┬──────────────────┬─────────────┐
│ 서비스             │ 배포 전략        │ 이유        │
├────────────────────┼──────────────────┼─────────────┤
│ user-service       │ Blue-Green       │ 중요도 높음 │
│ trade-service      │ Canary           │ 위험도 높음 │
│ account-service    │ Rolling Update   │ 일반적      │
│ strategy-service   │ Rolling Update   │ 일반적      │
│ notification       │ Recreate         │ 중요도 낮음 │
│ admin              │ Recreate         │ 사용자 적음 │
└────────────────────┴──────────────────┴─────────────┘
```

### Makefile 통합

```makefile
# Makefile
.PHONY: deploy-blue-green deploy-canary deploy-rolling

# Blue-Green 배포
deploy-blue-green:
	@echo "🔵🟢 Blue-Green Deployment"
	@read -p "Enter service name: " service; \
	read -p "Enter new version: " version; \
	bash scripts/blue-green-deploy.sh $$service $$version

# Canary 배포
deploy-canary:
	@echo "🐤 Canary Deployment"
	@read -p "Enter service name: " service; \
	read -p "Enter new version: " version; \
	bash scripts/canary-deploy.sh $$service $$version

# Rolling Update
deploy-rolling:
	@echo "🔄 Rolling Update"
	@read -p "Enter service name: " service; \
	read -p "Enter new version: " version; \
	export VERSION=$$version && docker stack deploy -c docker-stack.yml lk-trade

# 롤백
rollback:
	@echo "⏪ Rollback"
	@read -p "Enter service name: " service; \
	docker service rollback lk-trade_$$service

# 배포 상태 확인
deploy-status:
	@docker service ls
	@echo ""
	@docker service ps lk-trade_user-service --format "table {{.Name}}\t{{.Image}}\t{{.CurrentState}}"
```

---

## 다음 단계

축하합니다! 🎉 프로덕션 배포 전략을 완벽하게 마스터했습니다.

### 이번 섹션에서 배운 것

✅ 배포 전략의 중요성
✅ Recreate 배포
✅ Rolling Update (순차 배포)
✅ Blue-Green 배포
✅ Canary 배포
✅ A/B Testing
✅ 서비스별 배포 전략 선택

### 다음에 배울 것

**섹션 30: CI/CD 파이프라인 구축**에서는:
- GitHub Actions를 이용한 CI/CD
- Jenkins를 이용한 CI/CD
- GitLab CI/CD
- 자동화된 테스트 및 배포

### 추가 학습 자료

**공식 문서:**
- [Docker Swarm Deploy](https://docs.docker.com/engine/swarm/stack-deploy/)
- [Rolling Updates](https://docs.docker.com/engine/swarm/swarm-tutorial/rolling-update/)

**도구:**
- [Traefik](https://traefik.io/) - 현대적인 로드 밸런서
- [Flagger](https://flagger.app/) - Canary 배포 자동화

---

**다음 섹션에서 만나요!** 🚀