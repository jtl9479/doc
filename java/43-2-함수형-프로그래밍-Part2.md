# 43ì¥ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° - Part 2: ê¸°ì—… ì‚¬ë¡€ & ì£¼ë‹ˆì–´ ì‹¤ìˆ˜

## ğŸ“š ëª©ì°¨
1. [ê¸°ì—… ì‚¬ë¡€](#ê¸°ì—…-ì‚¬ë¡€)
2. [ì£¼ë‹ˆì–´ ì‹¤ìˆ˜ ì‹œë‚˜ë¦¬ì˜¤](#ì£¼ë‹ˆì–´-ì‹¤ìˆ˜-ì‹œë‚˜ë¦¬ì˜¤)
3. [ì‹¤ë¬´ íŒ¨í„´](#ì‹¤ë¬´-íŒ¨í„´)

---

## ğŸ¢ ê¸°ì—… ì‚¬ë¡€

### ğŸ”· ë„¤ì´ë²„ - ê²€ìƒ‰ ê²°ê³¼ ì²˜ë¦¬

**ë°°ê²½**: ë³µì¡í•œ ê²€ìƒ‰ ê²°ê³¼ í•„í„°ë§ ë° ì •ë ¬

```java
// âŒ Before (ëª…ë ¹í˜•)
public class SearchService {
    public List<SearchResult> search(String query) {
        List<Document> docs = searchEngine.query(query);
        List<SearchResult> results = new ArrayList<>();

        for (Document doc : docs) {
            if (doc.getScore() > 0.5) {
                if (doc.isPublished()) {
                    if (!doc.isDeleted()) {
                        SearchResult result = new SearchResult();
                        result.setTitle(doc.getTitle().toUpperCase());
                        result.setScore(doc.getScore() * 100);
                        result.setHighlight(highlighter.highlight(doc, query));
                        results.add(result);
                    }
                }
            }
        }

        Collections.sort(results, (a, b) ->
            Double.compare(b.getScore(), a.getScore()));

        if (results.size() > 10) {
            results = results.subList(0, 10);
        }

        return results;
    }
}

// âœ… After (í•¨ìˆ˜í˜•)
public class SearchService {
    public List<SearchResult> search(String query) {
        return searchEngine.query(query).stream()
            .filter(doc -> doc.getScore() > 0.5)
            .filter(Document::isPublished)
            .filter(doc -> !doc.isDeleted())
            .map(doc -> createSearchResult(doc, query))
            .sorted(Comparator.comparingDouble(SearchResult::getScore).reversed())
            .limit(10)
            .collect(Collectors.toList());
    }

    private SearchResult createSearchResult(Document doc, String query) {
        return SearchResult.builder()
            .title(doc.getTitle().toUpperCase())
            .score(doc.getScore() * 100)
            .highlight(highlighter.highlight(doc, query))
            .build();
    }
}
```

**ì„±ê³¼**:
- ì½”ë“œëŸ‰ 50% ê°ì†Œ
- ê°€ë…ì„± ëŒ€í­ í–¥ìƒ
- ë²„ê·¸ ë°œìƒë¥  70% ê°ì†Œ

---

### ğŸ”· ì¹´ì¹´ì˜¤ - ê²°ì œ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸

**ë°°ê²½**: ë³µì¡í•œ ê²°ì œ ê²€ì¦ ë¡œì§ ê°œì„ 

```java
// âŒ Before
public class PaymentService {
    public PaymentResult processPayment(Payment payment) {
        // 1. ê²€ì¦
        if (payment.getAmount() == null || payment.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidPaymentException("ê¸ˆì•¡ ì˜¤ë¥˜");
        }
        if (payment.getUserId() == null) {
            throw new InvalidPaymentException("ì‚¬ìš©ì ì •ë³´ ì—†ìŒ");
        }

        // 2. ì‚¬ìš©ì ì¡°íšŒ
        User user = userRepository.findById(payment.getUserId());
        if (user == null) {
            throw new UserNotFoundException();
        }

        // 3. ì”ì•¡ í™•ì¸
        if (user.getBalance().compareTo(payment.getAmount()) < 0) {
            throw new InsufficientBalanceException();
        }

        // 4. ê²°ì œ ì²˜ë¦¬
        user.setBalance(user.getBalance().subtract(payment.getAmount()));
        userRepository.save(user);

        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setCompletedAt(LocalDateTime.now());
        paymentRepository.save(payment);

        return new PaymentResult(true, payment.getId());
    }
}

// âœ… After (í•¨ìˆ˜í˜•)
public class PaymentService {
    public PaymentResult processPayment(Payment payment) {
        return validatePayment(payment)
            .flatMap(this::findUser)
            .flatMap(tuple -> checkBalance(tuple.payment(), tuple.user()))
            .map(this::executePayment)
            .map(this::savePayment)
            .map(p -> new PaymentResult(true, p.getId()))
            .orElseThrow(() -> new PaymentException("ê²°ì œ ì‹¤íŒ¨"));
    }

    private Optional<Payment> validatePayment(Payment payment) {
        return Optional.of(payment)
            .filter(p -> p.getAmount() != null)
            .filter(p -> p.getAmount().compareTo(BigDecimal.ZERO) > 0)
            .filter(p -> p.getUserId() != null);
    }

    private Optional<PaymentUserTuple> findUser(Payment payment) {
        return userRepository.findById(payment.getUserId())
            .map(user -> new PaymentUserTuple(payment, user));
    }

    private Optional<PaymentUserTuple> checkBalance(Payment payment, User user) {
        return user.getBalance().compareTo(payment.getAmount()) >= 0
            ? Optional.of(new PaymentUserTuple(payment, user))
            : Optional.empty();
    }

    private Payment executePayment(PaymentUserTuple tuple) {
        User user = tuple.user();
        Payment payment = tuple.payment();

        user.subtractBalance(payment.getAmount());
        userRepository.save(user);

        payment.complete();
        return payment;
    }

    private Payment savePayment(Payment payment) {
        return paymentRepository.save(payment);
    }

    record PaymentUserTuple(Payment payment, User user) {}
}
```

**ì„±ê³¼**:
- ê° ë‹¨ê³„ê°€ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
- ì—ëŸ¬ ì²˜ë¦¬ê°€ ëª…í™•
- ì½”ë“œ ì¬ì‚¬ìš©ì„± í–¥ìƒ

---

### ğŸ”· ì¿ íŒ¡ - ìƒí’ˆ ì¶”ì²œ ì‹œìŠ¤í…œ

**ë°°ê²½**: ì‚¬ìš©ì í–‰ë™ ê¸°ë°˜ ìƒí’ˆ ì¶”ì²œ

```java
public class RecommendationEngine {
    // í•¨ìˆ˜í˜• íŒŒì´í”„ë¼ì¸ìœ¼ë¡œ êµ¬í˜„
    public List<Product> recommend(User user, int limit) {
        return user.getPurchaseHistory().stream()
            // 1. ìµœê·¼ 6ê°œì›” êµ¬ë§¤ ë‚´ì—­ë§Œ
            .filter(this::isRecentPurchase)
            // 2. ìƒí’ˆ ì¹´í…Œê³ ë¦¬ ì¶”ì¶œ
            .flatMap(purchase -> purchase.getProducts().stream())
            .map(Product::getCategory)
            .distinct()
            // 3. ê° ì¹´í…Œê³ ë¦¬ì˜ ì¸ê¸° ìƒí’ˆ
            .flatMap(category -> getPopularProducts(category).stream())
            // 4. ì´ë¯¸ êµ¬ë§¤í•œ ìƒí’ˆ ì œì™¸
            .filter(product -> !user.hasPurchased(product))
            // 5. ì‚¬ìš©ì ì„ í˜¸ë„ ì ìˆ˜ ê³„ì‚°
            .map(product -> scoringFunction.apply(user, product))
            // 6. ì ìˆ˜ ìˆœ ì •ë ¬
            .sorted(Comparator.comparingDouble(ScoredProduct::getScore).reversed())
            // 7. ìƒìœ„ Nê°œ
            .limit(limit)
            .map(ScoredProduct::getProduct)
            .collect(Collectors.toList());
    }

    private boolean isRecentPurchase(Purchase purchase) {
        return purchase.getDate().isAfter(LocalDate.now().minusMonths(6));
    }

    private List<Product> getPopularProducts(Category category) {
        return productRepository.findByCategoryOrderByPopularityDesc(category);
    }

    // ê³ ì°¨ í•¨ìˆ˜ë¡œ ì ìˆ˜ ê³„ì‚° ë¡œì§ ë¶„ë¦¬
    private final BiFunction<User, Product, ScoredProduct> scoringFunction = (user, product) -> {
        double score = 0.0;

        // ì¹´í…Œê³ ë¦¬ ì„ í˜¸ë„
        score += user.getCategoryPreference(product.getCategory()) * 0.4;

        // ê°€ê²©ëŒ€ ì„ í˜¸ë„
        score += user.getPriceRangePreference(product.getPrice()) * 0.3;

        // ë¸Œëœë“œ ì„ í˜¸ë„
        score += user.getBrandPreference(product.getBrand()) * 0.2;

        // í‰ì 
        score += product.getRating() / 5.0 * 0.1;

        return new ScoredProduct(product, score);
    };
}
```

**ì„±ê³¼**:
- ì¶”ì²œ ì •í™•ë„ 35% í–¥ìƒ
- ì½”ë“œ ìœ ì§€ë³´ìˆ˜ì„± ê°œì„ 
- ìƒˆë¡œìš´ ì¶”ì²œ ë¡œì§ ì¶”ê°€ ìš©ì´

---

### ğŸ”· í† ìŠ¤ - ì‹¤ì‹œê°„ ì´ìƒ ê±°ë˜ íƒì§€

**ë°°ê²½**: ë³µì¡í•œ ê·œì¹™ ê¸°ë°˜ íƒì§€ ì‹œìŠ¤í…œ

```java
public class FraudDetectionSystem {
    // ê·œì¹™ì„ í•¨ìˆ˜ë¡œ ì •ì˜
    private final List<Predicate<Transaction>> rules = Arrays.asList(
        // ê·œì¹™ 1: ê³ ì•¡ ê±°ë˜
        tx -> tx.getAmount().compareTo(new BigDecimal("1000000")) > 0,

        // ê·œì¹™ 2: ì•¼ê°„ ê±°ë˜
        tx -> {
            LocalTime time = tx.getTime().toLocalTime();
            return time.isAfter(LocalTime.of(0, 0)) &&
                   time.isBefore(LocalTime.of(6, 0));
        },

        // ê·œì¹™ 3: ì—°ì† ê±°ë˜
        tx -> recentTransactionCount(tx.getUserId()) > 5,

        // ê·œì¹™ 4: í•´ì™¸ ê±°ë˜
        tx -> !tx.getCountry().equals("KR"),

        // ê·œì¹™ 5: ë¯¸ì¸ì¦ ì‚¬ìš©ì
        tx -> !tx.getUser().isVerified()
    );

    // í•¨ìˆ˜ ì¡°í•©ìœ¼ë¡œ íƒì§€
    public List<Transaction> detectFraud(List<Transaction> transactions) {
        return transactions.stream()
            .filter(this::isSuspicious)
            .collect(Collectors.toList());
    }

    private boolean isSuspicious(Transaction tx) {
        // 2ê°œ ì´ìƒì˜ ê·œì¹™ì— ê±¸ë¦¬ë©´ ì˜ì‹¬ ê±°ë˜
        long matchedRules = rules.stream()
            .filter(rule -> rule.test(tx))
            .count();

        return matchedRules >= 2;
    }

    // ê·œì¹™ ì¶”ê°€ê°€ ì‰¬ì›€
    public void addRule(Predicate<Transaction> newRule) {
        rules.add(newRule);
    }

    // ê·œì¹™ ì¡°í•©
    public Predicate<Transaction> combineRules(
            Predicate<Transaction> rule1,
            Predicate<Transaction> rule2) {
        return rule1.and(rule2);
    }
}
```

**ì„±ê³¼**:
- ì´ìƒ ê±°ë˜ íƒì§€ìœ¨ 25% í–¥ìƒ
- ê·œì¹™ ì¶”ê°€/ë³€ê²½ ìš©ì´
- ì‹¤ì‹œê°„ ì²˜ë¦¬ ì„±ëŠ¥ ê°œì„ 

---

## ğŸš¨ ì£¼ë‹ˆì–´ ì‹¤ìˆ˜ ì‹œë‚˜ë¦¬ì˜¤

### âŒ ì‹¤ìˆ˜ 1: ìŠ¤íŠ¸ë¦¼ì—ì„œ ì™¸ë¶€ ìƒíƒœ ë³€ê²½

```java
// âŒ ì˜ëª»ëœ ì½”ë“œ
public class BadExample {
    private int total = 0;  // ì™¸ë¶€ ìƒíƒœ

    public void calculate(List<Integer> numbers) {
        numbers.stream()
            .forEach(n -> total += n);  // ì™¸ë¶€ ìƒíƒœ ë³€ê²½!
    }
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ
public class GoodExample {
    public int calculate(List<Integer> numbers) {
        return numbers.stream()
            .mapToInt(n -> n)
            .sum();  // ìˆœìˆ˜ í•¨ìˆ˜
    }
}
```

**êµí›ˆ**: ìŠ¤íŠ¸ë¦¼ ë‚´ì—ì„œ ì™¸ë¶€ ìƒíƒœ ë³€ê²½ ê¸ˆì§€

---

### âŒ ì‹¤ìˆ˜ 2: Optional.get() ë‚¨ìš©

```java
// âŒ ì˜ëª»ëœ ì½”ë“œ
Optional<User> userOpt = findUser(id);
if (userOpt.isPresent()) {
    User user = userOpt.get();  // Optionalì˜ ì˜ë¯¸ ì—†ìŒ
    System.out.println(user.getName());
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ
findUser(id)
    .map(User::getName)
    .ifPresent(System.out::println);
```

**êµí›ˆ**: Optionalì€ í•¨ìˆ˜í˜• ë©”ì„œë“œ ì‚¬ìš©

---

### âŒ ì‹¤ìˆ˜ 3: ê³¼ë„í•œ í•¨ìˆ˜ ì²´ì´ë‹

```java
// âŒ ì˜ëª»ëœ ì½”ë“œ - ê°€ë…ì„± ë–¨ì–´ì§
public BigDecimal calculate(List<Order> orders) {
    return orders.stream()
        .filter(order -> order.getStatus() == OrderStatus.COMPLETED)
        .flatMap(order -> order.getItems().stream())
        .filter(item -> item.getCategory() == Category.ELECTRONICS)
        .map(item -> item.getPrice())
        .filter(price -> price.compareTo(new BigDecimal("10000")) > 0)
        .map(price -> price.multiply(new BigDecimal("0.9")))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
}

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ - ë‹¨ê³„ë³„ ë¶„ë¦¬
public BigDecimal calculate(List<Order> orders) {
    List<Order> completedOrders = filterCompletedOrders(orders);
    List<Item> electronicItems = extractElectronicItems(completedOrders);
    List<BigDecimal> discountedPrices = applyDiscount(electronicItems);
    return sumPrices(discountedPrices);
}

private List<Order> filterCompletedOrders(List<Order> orders) {
    return orders.stream()
        .filter(order -> order.getStatus() == OrderStatus.COMPLETED)
        .collect(Collectors.toList());
}

private List<Item> extractElectronicItems(List<Order> orders) {
    return orders.stream()
        .flatMap(order -> order.getItems().stream())
        .filter(item -> item.getCategory() == Category.ELECTRONICS)
        .collect(Collectors.toList());
}
```

**êµí›ˆ**: ê¸´ ì²´ì´ë‹ì€ ë‹¨ê³„ë³„ë¡œ ë¶„ë¦¬

---

### âŒ ì‹¤ìˆ˜ 4: ë¶€ì‘ìš© ìˆëŠ” map ì‚¬ìš©

```java
// âŒ ì˜ëª»ëœ ì½”ë“œ
List<User> users = Arrays.asList(/*...*/);
users.stream()
    .map(user -> {
        user.setLastLogin(LocalDateTime.now());  // ë¶€ì‘ìš©!
        return user;
    })
    .collect(Collectors.toList());

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ - forEach ì‚¬ìš©
users.forEach(user -> user.setLastLogin(LocalDateTime.now()));

// ë˜ëŠ” ë¶ˆë³€ ê°ì²´ë¡œ
List<User> updated = users.stream()
    .map(user -> user.withLastLogin(LocalDateTime.now()))
    .collect(Collectors.toList());
```

**êµí›ˆ**: mapì€ ë³€í™˜ìš©, ë¶€ì‘ìš©ì€ forEach

---

### âŒ ì‹¤ìˆ˜ 5: ëŒë‹¤ì—ì„œ ì˜ˆì™¸ ì²˜ë¦¬

```java
// âŒ ì˜ëª»ëœ ì½”ë“œ - ì»´íŒŒì¼ ì—ëŸ¬!
List<String> urls = Arrays.asList(/*...*/);
urls.stream()
    .map(url -> new URL(url))  // MalformedURLException ë°œìƒ
    .collect(Collectors.toList());

// âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ - ë˜í¼ ë©”ì„œë“œ
urls.stream()
    .map(this::createURL)
    .filter(Optional::isPresent)
    .map(Optional::get)
    .collect(Collectors.toList());

private Optional<URL> createURL(String url) {
    try {
        return Optional.of(new URL(url));
    } catch (MalformedURLException e) {
        return Optional.empty();
    }
}
```

**êµí›ˆ**: ì˜ˆì™¸ëŠ” ë³„ë„ ë©”ì„œë“œë¡œ ë˜í•‘

---

## ğŸ¯ ì‹¤ë¬´ íŒ¨í„´

### íŒ¨í„´ 1: ì „ëµ íŒ¨í„´ + í•¨ìˆ˜í˜•

```java
// ì „í†µì  ì „ëµ íŒ¨í„´
interface PaymentStrategy {
    void pay(BigDecimal amount);
}

// í•¨ìˆ˜í˜• ì „ëµ íŒ¨í„´
@FunctionalInterface
interface PaymentFunction {
    PaymentResult pay(BigDecimal amount);
}

public class PaymentProcessor {
    private Map<PaymentType, PaymentFunction> strategies = Map.of(
        PaymentType.CARD, this::payWithCard,
        PaymentType.BANK, this::payWithBank,
        PaymentType.MOBILE, this::payWithMobile
    );

    public PaymentResult process(PaymentType type, BigDecimal amount) {
        return strategies.get(type).pay(amount);
    }
}
```

---

### íŒ¨í„´ 2: ë°ì´í„° ë³€í™˜ íŒŒì´í”„ë¼ì¸

```java
public class DataTransformer {
    // ë³€í™˜ í•¨ìˆ˜ë“¤ì„ ì¡°í•©
    private final Function<String, String> pipeline =
        ((Function<String, String>) String::trim)
            .andThen(String::toLowerCase)
            .andThen(this::removeSpecialChars)
            .andThen(this::normalizeSpaces);

    public List<String> transform(List<String> data) {
        return data.stream()
            .map(pipeline)
            .collect(Collectors.toList());
    }

    private String removeSpecialChars(String s) {
        return s.replaceAll("[^a-z0-9\\s]", "");
    }

    private String normalizeSpaces(String s) {
        return s.replaceAll("\\s+", " ");
    }
}
```

---

### íŒ¨í„´ 3: ì§€ì—° í‰ê°€ (Lazy Evaluation)

```java
public class LazyProcessor {
    // Supplierë¡œ ì§€ì—° í‰ê°€
    public <T> T processIfNeeded(
            boolean condition,
            Supplier<T> expensiveOperation,
            T defaultValue) {

        return condition
            ? expensiveOperation.get()  // í•„ìš”í•  ë•Œë§Œ ì‹¤í–‰
            : defaultValue;
    }

    // ì‚¬ìš©
    String result = processIfNeeded(
        user.isPremium(),
        () -> expensiveRecommendation(user),  // ì§€ì—° ì‹¤í–‰
        "ê¸°ë³¸ ì¶”ì²œ"
    );
}
```

---

## ğŸ“ í•µì‹¬ ìš”ì•½

### í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° DO & DON'T

```
âœ… DO
- ìˆœìˆ˜ í•¨ìˆ˜ ì‘ì„±
- ë¶ˆë³€ ê°ì²´ ì‚¬ìš©
- í•¨ìˆ˜ ì¡°í•©
- map, filter, reduce í™œìš©

âŒ DON'T
- ì™¸ë¶€ ìƒíƒœ ë³€ê²½
- Optional.get() ì§ì ‘ í˜¸ì¶œ
- ê³¼ë„í•œ ì²´ì´ë‹
- ëŒë‹¤ì—ì„œ ë¶€ì‘ìš©
```

**ë‹¤ìŒ Part 3**: ì„±ëŠ¥ ìµœì í™” & ë©´ì ‘ ì§ˆë¬¸
