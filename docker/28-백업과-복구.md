# 섹션 28: 백업과 복구

## 비유로 시작하기

백업은 **보험**과 같습니다.

```
실생활 보험                          Docker 백업
===========                          ===========
🏠 화재 보험                    →    데이터 손실 대비
💾 자동차 블랙박스              →    자동 백업 시스템
🗄️ 중요 서류 사본              →    볼륨 백업
📸 사진 클라우드 백업           →    원격 백업 저장소
⏰ 정기 건강검진                →    정기 백업 스케줄
🔄 보험금 청구 연습             →    복구 테스트
```

보험 없이 사고 나면 큰 손해를 보듯이, 백업 없이 데이터 손실되면 복구 불가능합니다.

---

## 왜 백업이 중요한가?

### 1. 데이터 손실 시나리오

```
실제 사고 사례
=============

❌ 사례 1: 개발자 실수
------------------------
개발자: "docker volume prune -f"
시스템: "3년치 거래 데이터 삭제 완료"
개발자: "...!!! 😱"
회사: "백업이 없습니다"
결과: 폐업


❌ 사례 2: 하드웨어 장애
------------------------
03:00 AM - 서버 디스크 물리적 고장
03:15 AM - 모든 컨테이너 중단
03:30 AM - 데이터 복구 시도 실패
결과: 비즈니스 중단, 고객 이탈


❌ 사례 3: 랜섬웨어 공격
------------------------
해커: 암호화 완료, 비트코인 요구
회사: 백업도 함께 암호화됨 (오프라인 백업 없음)
결과: 협상 or 데이터 포기


✅ 백업이 있었다면:
------------------
10:00 AM - 데이터 손실 발견
10:05 AM - 백업 확인 (어제 자정 백업 존재)
10:10 AM - 복구 시작
10:30 AM - 복구 완료, 서비스 재개
결과: 30분 다운타임, 데이터 손실 최소화 ✨
```

### 2. 백업의 3-2-1 규칙

```
3-2-1 백업 전략
===============

3개의 복사본
    ├── 원본 (운영 서버)
    ├── 백업 1 (같은 서버)
    └── 백업 2 (다른 서버)

2가지 다른 매체
    ├── SSD/HDD
    └── 클라우드 스토리지

1개의 오프사이트 백업
    └── 다른 지역/클라우드

예시:
-----
원본: 서울 데이터센터 SSD
백업1: 같은 서버 HDD
백업2: AWS S3 (서울 리전)
백업3: AWS S3 (도쿄 리전) ← 오프사이트
```

---

## Docker 백업의 종류

### 1. 백업 대상

```
백업해야 할 것들
===============

┌─────────────────────────────────────────────┐
│ 1. 데이터 볼륨                              │
│    - 데이터베이스 데이터                    │
│    - 사용자 업로드 파일                     │
│    - 로그 파일                              │
├─────────────────────────────────────────────┤
│ 2. 바인드 마운트                            │
│    - 설정 파일 (.env, config/)              │
│    - 인증서 (SSL certificates)              │
├─────────────────────────────────────────────┤
│ 3. 컨테이너 이미지                          │
│    - 커스텀 빌드 이미지                     │
│    - 특정 버전 이미지                       │
├─────────────────────────────────────────────┤
│ 4. Docker 설정                              │
│    - docker-compose.yml                     │
│    - Dockerfile                             │
│    - 환경 변수 템플릿                       │
└─────────────────────────────────────────────┘
```

---

## 1. 데이터 볼륨 백업

### 1.1 수동 백업 (tar 아카이브)

```bash
# 볼륨 목록 확인
docker volume ls

# 출력:
DRIVER    VOLUME NAME
local     backend1_postgres-data
local     backend1_redis-data
local     backend1_elasticsearch-data

# 방법 1: 임시 컨테이너를 이용한 백업
docker run --rm \
  -v backend1_postgres-data:/data \
  -v $(pwd)/backups:/backup \
  alpine \
  tar czf /backup/postgres-data-$(date +%Y%m%d-%H%M%S).tar.gz -C /data .

# 출력: backups/postgres-data-20250930-103000.tar.gz 생성됨

# 방법 2: 실행 중인 컨테이너를 일시 중지하고 백업
docker-compose stop postgres
docker run --rm \
  -v backend1_postgres-data:/data \
  -v $(pwd)/backups:/backup \
  alpine \
  tar czf /backup/postgres-data-stopped-$(date +%Y%m%d-%H%M%S).tar.gz -C /data .
docker-compose start postgres

# 백업 파일 확인
ls -lh backups/
# -rw-r--r-- 1 user user 1.2G Sep 30 10:30 postgres-data-20250930-103000.tar.gz
```

### 1.2 볼륨 복구

```bash
# 방법 1: 새 볼륨에 복구
docker volume create backend1_postgres-data-restored

docker run --rm \
  -v backend1_postgres-data-restored:/data \
  -v $(pwd)/backups:/backup \
  alpine \
  tar xzf /backup/postgres-data-20250930-103000.tar.gz -C /data

# 방법 2: 기존 볼륨 교체 (주의: 기존 데이터 삭제됨!)
docker-compose stop postgres
docker run --rm \
  -v backend1_postgres-data:/data \
  alpine \
  sh -c "rm -rf /data/* && mkdir -p /data"
docker run --rm \
  -v backend1_postgres-data:/data \
  -v $(pwd)/backups:/backup \
  alpine \
  tar xzf /backup/postgres-data-20250930-103000.tar.gz -C /data
docker-compose start postgres
```

### 1.3 자동화된 백업 스크립트

```bash
#!/bin/bash
# scripts/backup-volumes.sh

set -e  # 에러 발생 시 즉시 중단

# 설정
BACKUP_DIR="./backups/volumes"
RETENTION_DAYS=30  # 30일 이상 된 백업 삭제
DATE=$(date +%Y%m%d-%H%M%S)

# 백업 디렉토리 생성
mkdir -p "$BACKUP_DIR"

# 백업할 볼륨 목록
VOLUMES=(
    "backend1_postgres-data"
    "backend1_redis-data"
    "backend1_elasticsearch-data"
)

echo "🔄 Starting volume backup at $(date)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

for VOLUME in "${VOLUMES[@]}"; do
    echo "📦 Backing up volume: $VOLUME"

    # 볼륨 존재 확인
    if ! docker volume inspect "$VOLUME" > /dev/null 2>&1; then
        echo "  ⚠️  Volume not found, skipping..."
        continue
    fi

    # 백업 파일명
    BACKUP_FILE="$BACKUP_DIR/${VOLUME}-${DATE}.tar.gz"

    # 백업 실행
    docker run --rm \
        -v "$VOLUME:/data:ro" \
        -v "$(pwd)/$BACKUP_DIR:/backup" \
        alpine \
        tar czf "/backup/$(basename $BACKUP_FILE)" -C /data .

    # 백업 크기 확인
    SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
    echo "  ✅ Backup completed: $(basename $BACKUP_FILE) ($SIZE)"
done

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🧹 Cleaning up old backups (older than $RETENTION_DAYS days)..."

# 오래된 백업 삭제
find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "✅ Backup completed successfully at $(date)"
echo ""
echo "📊 Backup Summary:"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
du -sh "$BACKUP_DIR"
ls -lh "$BACKUP_DIR" | tail -n +2 | wc -l | xargs echo "Total backups:"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
```

실행:

```bash
# 실행 권한 부여
chmod +x scripts/backup-volumes.sh

# 백업 실행
bash scripts/backup-volumes.sh

# 출력:
🔄 Starting volume backup at Mon Sep 30 10:30:00 KST 2025
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 Backing up volume: backend1_postgres-data
  ✅ Backup completed: backend1_postgres-data-20250930-103000.tar.gz (1.2G)
📦 Backing up volume: backend1_redis-data
  ✅ Backup completed: backend1_redis-data-20250930-103000.tar.gz (256M)
📦 Backing up volume: backend1_elasticsearch-data
  ✅ Backup completed: backend1_elasticsearch-data-20250930-103000.tar.gz (3.5G)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🧹 Cleaning up old backups (older than 30 days)...
✅ Backup completed successfully at Mon Sep 30 10:35:00 KST 2025

📊 Backup Summary:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4.9G    ./backups/volumes
Total backups: 90
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

---

## 2. 데이터베이스 백업

파일 시스템 백업보다 **데이터베이스 네이티브 백업**이 더 안전합니다.

### 2.1 PostgreSQL 백업

```bash
#!/bin/bash
# scripts/backup-postgres.sh

set -e

BACKUP_DIR="./backups/postgres"
DATE=$(date +%Y%m%d-%H%M%S)
RETENTION_DAYS=30

mkdir -p "$BACKUP_DIR"

echo "🐘 Starting PostgreSQL backup..."

# pg_dump를 이용한 논리적 백업
docker exec lk-postgres pg_dump -U lk_admin lk_trade | gzip > "$BACKUP_DIR/lk_trade-${DATE}.sql.gz"

# 또는 pg_dumpall (모든 데이터베이스 + 역할/권한)
docker exec lk-postgres pg_dumpall -U lk_admin | gzip > "$BACKUP_DIR/lk_trade-all-${DATE}.sql.gz"

# 커스텀 포맷 (더 빠른 복구, 선택적 복구 가능)
docker exec lk-postgres pg_dump -U lk_admin -Fc lk_trade > "$BACKUP_DIR/lk_trade-${DATE}.dump"

SIZE=$(du -h "$BACKUP_DIR/lk_trade-${DATE}.sql.gz" | cut -f1)
echo "✅ PostgreSQL backup completed: lk_trade-${DATE}.sql.gz ($SIZE)"

# 오래된 백업 삭제
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "*.dump" -mtime +$RETENTION_DAYS -delete

echo "✅ Backup completed successfully"
```

### 2.2 PostgreSQL 복구

```bash
#!/bin/bash
# scripts/restore-postgres.sh

set -e

if [ -z "$1" ]; then
    echo "Usage: $0 <backup-file>"
    echo "Example: $0 ./backups/postgres/lk_trade-20250930-103000.sql.gz"
    exit 1
fi

BACKUP_FILE=$1

echo "⚠️  WARNING: This will overwrite the current database!"
echo "Backup file: $BACKUP_FILE"
read -p "Are you sure? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
    echo "Restore cancelled."
    exit 0
fi

echo "🔄 Stopping services..."
docker-compose stop user-service trade-service account-service strategy-service

echo "🗄️ Dropping and recreating database..."
docker exec lk-postgres psql -U lk_admin -c "DROP DATABASE IF EXISTS lk_trade;"
docker exec lk-postgres psql -U lk_admin -c "CREATE DATABASE lk_trade;"

echo "📥 Restoring database..."
if [[ "$BACKUP_FILE" == *.sql.gz ]]; then
    # gzip 압축 파일 복구
    gunzip -c "$BACKUP_FILE" | docker exec -i lk-postgres psql -U lk_admin lk_trade
elif [[ "$BACKUP_FILE" == *.dump ]]; then
    # 커스텀 포맷 복구
    docker exec -i lk-postgres pg_restore -U lk_admin -d lk_trade < "$BACKUP_FILE"
else
    echo "❌ Unsupported backup format"
    exit 1
fi

echo "🚀 Starting services..."
docker-compose start user-service trade-service account-service strategy-service

echo "✅ Database restored successfully!"
```

### 2.3 Redis 백업

```bash
#!/bin/bash
# scripts/backup-redis.sh

set -e

BACKUP_DIR="./backups/redis"
DATE=$(date +%Y%m%d-%H%M%S)
RETENTION_DAYS=30

mkdir -p "$BACKUP_DIR"

echo "📦 Starting Redis backup..."

# Redis BGSAVE (백그라운드 저장)
docker exec lk-redis redis-cli BGSAVE

# BGSAVE 완료 대기
echo "⏳ Waiting for BGSAVE to complete..."
while [ "$(docker exec lk-redis redis-cli LASTSAVE)" = "$(docker exec lk-redis redis-cli LASTSAVE)" ]; do
    sleep 1
done

# dump.rdb 파일 복사
docker cp lk-redis:/data/dump.rdb "$BACKUP_DIR/dump-${DATE}.rdb"

# 압축
gzip "$BACKUP_DIR/dump-${DATE}.rdb"

SIZE=$(du -h "$BACKUP_DIR/dump-${DATE}.rdb.gz" | cut -f1)
echo "✅ Redis backup completed: dump-${DATE}.rdb.gz ($SIZE)"

# 오래된 백업 삭제
find "$BACKUP_DIR" -name "*.rdb.gz" -mtime +$RETENTION_DAYS -delete

echo "✅ Backup completed successfully"
```

### 2.4 Redis 복구

```bash
#!/bin/bash
# scripts/restore-redis.sh

set -e

if [ -z "$1" ]; then
    echo "Usage: $0 <backup-file>"
    echo "Example: $0 ./backups/redis/dump-20250930-103000.rdb.gz"
    exit 1
fi

BACKUP_FILE=$1

echo "⚠️  WARNING: This will overwrite the current Redis data!"
echo "Backup file: $BACKUP_FILE"
read -p "Are you sure? (yes/no): " CONFIRM

if [ "$CONFIRM" != "yes" ]; then
    echo "Restore cancelled."
    exit 0
fi

echo "🔄 Stopping Redis..."
docker-compose stop redis

# 압축 해제
TEMP_FILE="/tmp/dump.rdb"
gunzip -c "$BACKUP_FILE" > "$TEMP_FILE"

# Redis 데이터 디렉토리에 복사
docker cp "$TEMP_FILE" lk-redis:/data/dump.rdb

# 권한 설정
docker run --rm -v backend1_redis-data:/data alpine chown redis:redis /data/dump.rdb

echo "🚀 Starting Redis..."
docker-compose start redis

# 정리
rm "$TEMP_FILE"

echo "✅ Redis restored successfully!"
```

---

## 3. 컨테이너 이미지 백업

### 3.1 이미지 내보내기 (export)

```bash
# 단일 이미지 저장
docker save lk-trade/user-service:latest | gzip > backups/images/user-service-latest.tar.gz

# 여러 이미지 한 번에 저장
docker save \
    lk-trade/user-service:latest \
    lk-trade/trade-service:latest \
    lk-trade/account-service:latest \
    lk-trade/strategy-service:latest \
    | gzip > backups/images/lk-trade-all-$(date +%Y%m%d).tar.gz

# 이미지 크기 확인
ls -lh backups/images/
```

### 3.2 이미지 가져오기 (import)

```bash
# 압축 해제하면서 로드
gunzip -c backups/images/user-service-latest.tar.gz | docker load

# 또는
docker load < backups/images/user-service-latest.tar.gz

# 로드된 이미지 확인
docker images | grep lk-trade
```

### 3.3 이미지 백업 자동화

```bash
#!/bin/bash
# scripts/backup-images.sh

set -e

BACKUP_DIR="./backups/images"
DATE=$(date +%Y%m%d-%H%M%S)

mkdir -p "$BACKUP_DIR"

echo "🖼️  Starting image backup..."

# LK-Trade 이미지 목록
IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^lk-trade/")

if [ -z "$IMAGES" ]; then
    echo "⚠️  No LK-Trade images found"
    exit 1
fi

echo "Found images:"
echo "$IMAGES"
echo ""

# 백업 파일명
BACKUP_FILE="$BACKUP_DIR/lk-trade-images-${DATE}.tar.gz"

echo "📦 Saving images to: $BACKUP_FILE"
docker save $IMAGES | gzip > "$BACKUP_FILE"

SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
echo "✅ Image backup completed: $(basename $BACKUP_FILE) ($SIZE)"
```

---

## 4. 설정 파일 백업

```bash
#!/bin/bash
# scripts/backup-configs.sh

set -e

BACKUP_DIR="./backups/configs"
DATE=$(date +%Y%m%d-%H%M%S)
RETENTION_DAYS=90  # 설정은 오래 보관

mkdir -p "$BACKUP_DIR"

echo "⚙️  Starting configuration backup..."

# 백업할 파일/디렉토리 목록
CONFIG_FILES=(
    "docker-compose.yml"
    "docker-compose.prod.yml"
    "docker-compose.dev.yml"
    ".env.example"
    "Makefile"
    "modules/*/api/Dockerfile"
    "modules/*/api/src/main/resources/application*.yml"
    "elk/"
    "scripts/"
)

BACKUP_FILE="$BACKUP_DIR/configs-${DATE}.tar.gz"

echo "📦 Creating backup archive..."
tar czf "$BACKUP_FILE" \
    --exclude="*.log" \
    --exclude=".env" \
    --exclude="secrets/" \
    "${CONFIG_FILES[@]}"

SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
echo "✅ Configuration backup completed: $(basename $BACKUP_FILE) ($SIZE)"

# 오래된 백업 삭제
find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "✅ Backup completed successfully"
```

---

## 5. 전체 시스템 백업

모든 것을 한 번에 백업합니다.

```bash
#!/bin/bash
# scripts/backup-all.sh

set -e

echo "
╔════════════════════════════════════════════╗
║   LK-Trade Full System Backup              ║
╚════════════════════════════════════════════╝
"

DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_ROOT="./backups/full-backup-${DATE}"

mkdir -p "$BACKUP_ROOT"

# 1. 데이터베이스 백업
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "1️⃣  Database Backup"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
mkdir -p "$BACKUP_ROOT/database"

echo "🐘 PostgreSQL..."
docker exec lk-postgres pg_dumpall -U lk_admin | gzip > "$BACKUP_ROOT/database/postgres.sql.gz"

echo "📦 Redis..."
docker exec lk-redis redis-cli BGSAVE > /dev/null
sleep 2
docker cp lk-redis:/data/dump.rdb "$BACKUP_ROOT/database/redis.rdb"
gzip "$BACKUP_ROOT/database/redis.rdb"

echo "✅ Database backup completed"
echo ""

# 2. 볼륨 백업
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "2️⃣  Volume Backup"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
mkdir -p "$BACKUP_ROOT/volumes"

VOLUMES=$(docker volume ls --format "{{.Name}}" | grep "^backend1_")
for VOLUME in $VOLUMES; do
    echo "📦 $VOLUME..."
    docker run --rm \
        -v "$VOLUME:/data:ro" \
        -v "$(pwd)/$BACKUP_ROOT/volumes:/backup" \
        alpine \
        tar czf "/backup/${VOLUME}.tar.gz" -C /data .
done

echo "✅ Volume backup completed"
echo ""

# 3. 이미지 백업
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "3️⃣  Image Backup"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
mkdir -p "$BACKUP_ROOT/images"

IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^lk-trade/")
if [ ! -z "$IMAGES" ]; then
    echo "🖼️  Saving images..."
    docker save $IMAGES | gzip > "$BACKUP_ROOT/images/lk-trade-images.tar.gz"
    echo "✅ Image backup completed"
else
    echo "⚠️  No LK-Trade images found"
fi
echo ""

# 4. 설정 파일 백업
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "4️⃣  Configuration Backup"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
mkdir -p "$BACKUP_ROOT/configs"

echo "⚙️  Copying configuration files..."
tar czf "$BACKUP_ROOT/configs/configs.tar.gz" \
    --exclude="*.log" \
    --exclude=".env" \
    --exclude="secrets/" \
    --exclude="backups/" \
    --exclude="build/" \
    --exclude="node_modules/" \
    --exclude=".git/" \
    .

echo "✅ Configuration backup completed"
echo ""

# 5. 백업 정보 파일 생성
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "5️⃣  Backup Metadata"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

cat > "$BACKUP_ROOT/backup-info.txt" <<EOF
LK-Trade System Backup
======================

Backup Date: $(date)
Hostname: $(hostname)
Docker Version: $(docker --version)
Docker Compose Version: $(docker-compose --version)

Containers at backup time:
--------------------------
$(docker ps --format "{{.Names}}: {{.Image}}")

Volumes at backup time:
-----------------------
$(docker volume ls)

Images at backup time:
----------------------
$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "^lk-trade/")

Git Information:
----------------
Branch: $(git branch --show-current 2>/dev/null || echo "N/A")
Commit: $(git rev-parse HEAD 2>/dev/null || echo "N/A")
EOF

echo "✅ Metadata created"
echo ""

# 6. 백업 요약
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "📊 Backup Summary"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
du -sh "$BACKUP_ROOT"
du -sh "$BACKUP_ROOT"/* | sort -h

echo ""
echo "✅ Full system backup completed successfully!"
echo ""
echo "Backup location: $BACKUP_ROOT"
echo ""
echo "To restore this backup, use:"
echo "  bash scripts/restore-all.sh $BACKUP_ROOT"
```

실행 결과:

```
╔════════════════════════════════════════════╗
║   LK-Trade Full System Backup              ║
╚════════════════════════════════════════════╝

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1️⃣  Database Backup
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🐘 PostgreSQL...
📦 Redis...
✅ Database backup completed

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2️⃣  Volume Backup
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 backend1_postgres-data...
📦 backend1_redis-data...
📦 backend1_elasticsearch-data...
✅ Volume backup completed

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3️⃣  Image Backup
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🖼️  Saving images...
✅ Image backup completed

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
4️⃣  Configuration Backup
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️  Copying configuration files...
✅ Configuration backup completed

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
5️⃣  Backup Metadata
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ Metadata created

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📊 Backup Summary
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
8.5G    ./backups/full-backup-20250930-103000
256K    ./backups/full-backup-20250930-103000/configs
1.5G    ./backups/full-backup-20250930-103000/database
2.8G    ./backups/full-backup-20250930-103000/images
4.2G    ./backups/full-backup-20250930-103000/volumes

✅ Full system backup completed successfully!

Backup location: ./backups/full-backup-20250930-103000

To restore this backup, use:
  bash scripts/restore-all.sh ./backups/full-backup-20250930-103000
```

---

## 6. 전체 시스템 복구

```bash
#!/bin/bash
# scripts/restore-all.sh

set -e

if [ -z "$1" ]; then
    echo "Usage: $0 <backup-directory>"
    echo "Example: $0 ./backups/full-backup-20250930-103000"
    exit 1
fi

BACKUP_DIR=$1

if [ ! -d "$BACKUP_DIR" ]; then
    echo "❌ Backup directory not found: $BACKUP_DIR"
    exit 1
fi

echo "
╔════════════════════════════════════════════╗
║   LK-Trade Full System Restore             ║
╚════════════════════════════════════════════╝
"

echo "⚠️  WARNING: This will OVERWRITE all current data!"
echo "Backup directory: $BACKUP_DIR"
echo ""
cat "$BACKUP_DIR/backup-info.txt"
echo ""
read -p "Are you absolutely sure? Type 'RESTORE' to continue: " CONFIRM

if [ "$CONFIRM" != "RESTORE" ]; then
    echo "Restore cancelled."
    exit 0
fi

# 1. 모든 컨테이너 중지
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "1️⃣  Stopping all containers"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
docker-compose down
echo "✅ Containers stopped"
echo ""

# 2. 이미지 복구
if [ -f "$BACKUP_DIR/images/lk-trade-images.tar.gz" ]; then
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    echo "2️⃣  Restoring images"
    echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    gunzip -c "$BACKUP_DIR/images/lk-trade-images.tar.gz" | docker load
    echo "✅ Images restored"
    echo ""
fi

# 3. 볼륨 복구
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "3️⃣  Restoring volumes"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
for BACKUP_FILE in "$BACKUP_DIR/volumes"/*.tar.gz; do
    VOLUME=$(basename "$BACKUP_FILE" .tar.gz)
    echo "📦 Restoring $VOLUME..."

    # 볼륨 재생성
    docker volume rm "$VOLUME" 2>/dev/null || true
    docker volume create "$VOLUME"

    # 데이터 복구
    docker run --rm \
        -v "$VOLUME:/data" \
        -v "$(pwd)/$BACKUP_DIR/volumes:/backup" \
        alpine \
        tar xzf "/backup/$(basename $BACKUP_FILE)" -C /data
done
echo "✅ Volumes restored"
echo ""

# 4. 컨테이너 시작
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "4️⃣  Starting containers"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
docker-compose up -d
echo "⏳ Waiting for containers to be healthy..."
sleep 30
echo "✅ Containers started"
echo ""

# 5. 데이터베이스 복구
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "5️⃣  Restoring databases"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ -f "$BACKUP_DIR/database/postgres.sql.gz" ]; then
    echo "🐘 PostgreSQL..."
    docker-compose stop user-service trade-service account-service strategy-service
    gunzip -c "$BACKUP_DIR/database/postgres.sql.gz" | docker exec -i lk-postgres psql -U lk_admin
    docker-compose start user-service trade-service account-service strategy-service
fi

if [ -f "$BACKUP_DIR/database/redis.rdb.gz" ]; then
    echo "📦 Redis..."
    docker-compose stop redis
    gunzip -c "$BACKUP_DIR/database/redis.rdb.gz" > /tmp/dump.rdb
    docker cp /tmp/dump.rdb lk-redis:/data/dump.rdb
    rm /tmp/dump.rdb
    docker-compose start redis
fi

echo "✅ Databases restored"
echo ""

# 6. 헬스 체크
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "6️⃣  Health Check"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
docker-compose ps

echo ""
echo "✅ Full system restore completed successfully!"
echo ""
echo "Next steps:"
echo "1. Verify data integrity"
echo "2. Check application logs"
echo "3. Test critical functionality"
```

---

## 7. 자동화된 백업 스케줄링

### 7.1 Cron 작업 (Linux/Mac)

```bash
# crontab 편집
crontab -e

# 추가할 내용:
# 매일 새벽 2시에 전체 백업
0 2 * * * cd /home/user/trade/backend1 && bash scripts/backup-all.sh >> logs/backup.log 2>&1

# 매 6시간마다 데이터베이스 백업
0 */6 * * * cd /home/user/trade/backend1 && bash scripts/backup-postgres.sh >> logs/backup-db.log 2>&1

# 매주 일요일 새벽 3시에 오래된 백업 정리
0 3 * * 0 find /home/user/trade/backend1/backups -name "*.tar.gz" -mtime +30 -delete
```

### 7.2 Windows 작업 스케줄러

```powershell
# PowerShell로 작업 스케줄러 등록
$action = New-ScheduledTaskAction -Execute "bash.exe" -Argument "scripts/backup-all.sh" -WorkingDirectory "C:\trade\backend1"
$trigger = New-ScheduledTaskTrigger -Daily -At 2am
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
Register-ScheduledTask -TaskName "LK-Trade Daily Backup" -Action $action -Trigger $trigger -Principal $principal
```

### 7.3 Docker 컨테이너로 백업 자동화

```yaml
# docker-compose.backup.yml
version: '3.8'

services:
  backup-service:
    build:
      context: ./backup-service
      dockerfile: Dockerfile
    container_name: lk-backup-service
    environment:
      - BACKUP_SCHEDULE=0 2 * * *  # cron 표현식: 매일 새벽 2시
      - RETENTION_DAYS=30
      - S3_BUCKET=lk-trade-backups
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./backups:/backups
      - backend1_postgres-data:/volumes/postgres:ro
      - backend1_redis-data:/volumes/redis:ro
    networks:
      - lk-trade-network
    depends_on:
      - postgres
      - redis

networks:
  lk-trade-network:
    external: true
```

```dockerfile
# backup-service/Dockerfile
FROM alpine:3.18

RUN apk add --no-cache \
    docker-cli \
    postgresql-client \
    redis \
    aws-cli \
    dcron \
    bash \
    curl

COPY backup-entrypoint.sh /backup-entrypoint.sh
COPY backup-script.sh /backup-script.sh
RUN chmod +x /backup-entrypoint.sh /backup-script.sh

ENTRYPOINT ["/backup-entrypoint.sh"]
```

```bash
#!/bin/bash
# backup-service/backup-entrypoint.sh

# Cron 작업 추가
echo "$BACKUP_SCHEDULE /backup-script.sh >> /var/log/backup.log 2>&1" > /etc/crontabs/root

# Cron 시작
crond -f -l 2
```

---

## 8. 원격 백업 (클라우드)

### 8.1 AWS S3로 백업

```bash
#!/bin/bash
# scripts/backup-to-s3.sh

set -e

S3_BUCKET="s3://lk-trade-backups"
LOCAL_BACKUP_DIR="./backups"
DATE=$(date +%Y%m%d)

echo "☁️  Starting S3 backup..."

# AWS CLI 설치 확인
if ! command -v aws &> /dev/null; then
    echo "❌ AWS CLI not found. Install it first."
    exit 1
fi

# 로컬 백업 실행
echo "📦 Creating local backup..."
bash scripts/backup-all.sh

# S3로 업로드
echo "☁️  Uploading to S3..."
aws s3 sync "$LOCAL_BACKUP_DIR" "$S3_BUCKET/$DATE/" \
    --exclude "*.tmp" \
    --storage-class STANDARD_IA \
    --no-progress

echo "✅ S3 backup completed"

# 오래된 S3 백업 삭제 (90일 이상)
echo "🧹 Cleaning up old S3 backups..."
aws s3 ls "$S3_BUCKET/" | awk '{print $2}' | while read folder; do
    folder_date=$(echo $folder | tr -d '/')
    if [ $(date -d "$folder_date" +%s 2>/dev/null || echo 0) -lt $(date -d "90 days ago" +%s) ]; then
        echo "Deleting old backup: $folder"
        aws s3 rm "$S3_BUCKET/$folder" --recursive
    fi
done

echo "✅ S3 backup completed successfully"
```

### 8.2 S3에서 복구

```bash
#!/bin/bash
# scripts/restore-from-s3.sh

set -e

S3_BUCKET="s3://lk-trade-backups"

if [ -z "$1" ]; then
    echo "Available backups:"
    aws s3 ls "$S3_BUCKET/"
    echo ""
    echo "Usage: $0 <backup-date>"
    echo "Example: $0 20250930"
    exit 1
fi

BACKUP_DATE=$1
LOCAL_RESTORE_DIR="./backups/restore-from-s3-$BACKUP_DATE"

echo "☁️  Downloading backup from S3..."
mkdir -p "$LOCAL_RESTORE_DIR"
aws s3 sync "$S3_BUCKET/$BACKUP_DATE/" "$LOCAL_RESTORE_DIR/" --no-progress

echo "✅ Download completed"
echo ""
echo "Now run restore:"
echo "  bash scripts/restore-all.sh $LOCAL_RESTORE_DIR/full-backup-*"
```

---

## 9. 재해 복구 계획 (Disaster Recovery)

### 9.1 RPO와 RTO

```
RPO (Recovery Point Objective)
= 최대 허용 가능한 데이터 손실 시간
================================

예시: RPO = 1시간
→ 1시간마다 백업 필요
→ 최악의 경우 1시간치 데이터 손실 허용

RTO (Recovery Time Objective)
= 최대 허용 가능한 서비스 중단 시간
==================================

예시: RTO = 30분
→ 장애 발생 후 30분 내 복구 완료
→ 빠른 복구를 위한 준비 필요
```

### 9.2 LK-Trade 재해 복구 계획

```
┌─────────────────────────────────────────────────┐
│ 재해 복구 단계                                  │
├─────────────────────────────────────────────────┤
│ 1. 감지 (0-5분)                                 │
│    - 모니터링 알림 수신                         │
│    - 장애 유형 파악                             │
├─────────────────────────────────────────────────┤
│ 2. 평가 (5-10분)                                │
│    - 영향 범위 확인                             │
│    - 복구 방법 결정                             │
├─────────────────────────────────────────────────┤
│ 3. 복구 (10-30분)                               │
│    - 백업에서 데이터 복구                       │
│    - 서비스 재시작                              │
│    - 헬스 체크                                  │
├─────────────────────────────────────────────────┤
│ 4. 검증 (30-40분)                               │
│    - 데이터 무결성 확인                         │
│    - 기능 테스트                                │
├─────────────────────────────────────────────────┤
│ 5. 사후 조치 (40-60분)                          │
│    - 원인 분석                                  │
│    - 재발 방지 대책                             │
└─────────────────────────────────────────────────┘
```

### 9.3 재해 복구 매뉴얼

```bash
#!/bin/bash
# scripts/disaster-recovery.sh

cat <<'EOF'
╔═══════════════════════════════════════════════════╗
║   LK-Trade Disaster Recovery Manual               ║
╚═══════════════════════════════════════════════════╝

🚨 DISASTER RECOVERY PROCEDURE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📋 Pre-Recovery Checklist:
──────────────────────────
[ ] Identify the disaster type:
    - Hardware failure
    - Data corruption
    - Security breach
    - Human error
    - Natural disaster

[ ] Assess the impact:
    - Which services are affected?
    - How much data is lost?
    - Are backups accessible?

[ ] Notify stakeholders:
    - Development team
    - Management
    - Customers (if necessary)

🔧 Recovery Steps:
──────────────────

Step 1: Stop all services
--------------------------
$ cd /path/to/backend1
$ docker-compose down

Step 2: Identify the latest good backup
---------------------------------------
$ ls -lht backups/
$ ls -lht backups/full-backup-*/

Or check S3:
$ aws s3 ls s3://lk-trade-backups/

Step 3: Restore from backup
----------------------------
Local backup:
$ bash scripts/restore-all.sh ./backups/full-backup-YYYYMMDD-HHMMSS

S3 backup:
$ bash scripts/restore-from-s3.sh YYYYMMDD
$ bash scripts/restore-all.sh ./backups/restore-from-s3-YYYYMMDD/full-backup-*

Step 4: Verify data integrity
------------------------------
$ docker-compose ps
$ docker-compose logs -f

Check databases:
$ docker exec lk-postgres psql -U lk_admin -d lk_trade -c "SELECT COUNT(*) FROM users;"
$ docker exec lk-redis redis-cli DBSIZE

Step 5: Test critical functionality
------------------------------------
[ ] User login
[ ] Place order
[ ] Check account balance
[ ] View trading history

Step 6: Resume normal operations
---------------------------------
$ docker-compose ps
(All containers should be "Up (healthy)")

Step 7: Post-recovery actions
------------------------------
[ ] Document the incident
[ ] Analyze root cause
[ ] Implement preventive measures
[ ] Update disaster recovery plan
[ ] Conduct post-mortem meeting

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

📞 Emergency Contacts:
──────────────────────
DevOps Team:    +82-10-XXXX-XXXX
Database Admin: +82-10-YYYY-YYYY
Security Team:  +82-10-ZZZZ-ZZZZ
AWS Support:    +1-XXX-XXX-XXXX

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
EOF
```

---

## 10. Makefile 통합

```makefile
# Makefile에 백업/복구 명령 추가

.PHONY: backup backup-all backup-db backup-volumes backup-images restore restore-all backup-s3 restore-s3

# 전체 백업
backup-all:
	@bash scripts/backup-all.sh

# 데이터베이스만 백업
backup-db:
	@bash scripts/backup-postgres.sh
	@bash scripts/backup-redis.sh

# 볼륨만 백업
backup-volumes:
	@bash scripts/backup-volumes.sh

# 이미지만 백업
backup-images:
	@bash scripts/backup-images.sh

# 설정만 백업
backup-configs:
	@bash scripts/backup-configs.sh

# 전체 복구
restore-all:
	@echo "Available backups:"
	@ls -lht backups/full-backup-*/
	@echo ""
	@read -p "Enter backup directory: " dir; \
	bash scripts/restore-all.sh $$dir

# S3 백업
backup-s3:
	@bash scripts/backup-to-s3.sh

# S3에서 복구
restore-s3:
	@bash scripts/restore-from-s3.sh

# 백업 목록 보기
backup-list:
	@echo "Local Backups:"
	@echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
	@du -sh backups/*/ | sort -h
	@echo ""
	@echo "S3 Backups:"
	@echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
	@aws s3 ls s3://lk-trade-backups/ 2>/dev/null || echo "AWS CLI not configured"

# 재해 복구 매뉴얼
disaster-recovery:
	@bash scripts/disaster-recovery.sh
```

사용 예시:

```bash
# 전체 백업
make backup-all

# 데이터베이스만 백업
make backup-db

# 백업 목록 보기
make backup-list

# S3로 백업
make backup-s3

# 복구
make restore-all

# 재해 복구 매뉴얼 보기
make disaster-recovery
```

---

## 트러블슈팅

### 문제 1: 백업이 너무 느림

```bash
# 원인: 압축에 시간이 오래 걸림

# 해결책 1: pigz (병렬 gzip) 사용
# 설치
sudo apt install pigz  # Ubuntu/Debian
brew install pigz      # Mac

# 사용
tar cf - data/ | pigz > backup.tar.gz
# 압축 해제
pigz -dc backup.tar.gz | tar xf -

# 해결책 2: 압축 레벨 조정 (속도 우선)
tar czf backup.tar.gz --use-compress-program="gzip -1" data/
```

### 문제 2: 백업 중 디스크 공간 부족

```bash
# 증상
tar: Error writing to archive: No space left on device

# 해결책 1: 오래된 백업 먼저 삭제
find backups/ -name "*.tar.gz" -mtime +7 -delete

# 해결책 2: 다른 디스크로 백업
tar czf /mnt/backup-disk/backup.tar.gz data/

# 해결책 3: 스트리밍 백업 (중간 파일 생성 없이 S3로 직접)
tar czf - data/ | aws s3 cp - s3://bucket/backup.tar.gz
```

### 문제 3: 복구 후 권한 문제

```bash
# 증상
Permission denied: /data/file.db

# 원인: 백업 시 권한 정보가 보존되지 않음

# 해결책: 권한 수정
docker exec lk-postgres chown -R postgres:postgres /var/lib/postgresql/data
docker exec lk-redis chown -R redis:redis /data
```

---

## 다음 단계

축하합니다! 🎉 Docker 백업과 복구를 완벽하게 마스터했습니다.

### 이번 섹션에서 배운 것

✅ 백업의 중요성 및 3-2-1 규칙
✅ 데이터 볼륨 백업 및 복구
✅ 데이터베이스 네이티브 백업 (PostgreSQL, Redis)
✅ 컨테이너 이미지 백업
✅ 전체 시스템 백업 및 복구
✅ 자동화된 백업 스케줄링
✅ 클라우드 백업 (AWS S3)
✅ 재해 복구 계획 (DR Plan)

### 다음에 배울 것

**섹션 29: 프로덕션 배포 전략**에서는:
- Blue-Green 배포
- Rolling 업데이트
- Canary 배포
- 무중단 배포 전략
- 롤백 전략

### 추가 학습 자료

**공식 문서:**
- [Docker Volume Backup](https://docs.docker.com/storage/volumes/#back-up-restore-or-migrate-data-volumes)
- [PostgreSQL Backup](https://www.postgresql.org/docs/current/backup.html)
- [Redis Persistence](https://redis.io/docs/management/persistence/)

**도구:**
- [Restic](https://restic.net/) - 효율적인 백업 도구
- [Duplicati](https://www.duplicati.com/) - 암호화된 백업
- [Velero](https://velero.io/) - Kubernetes 백업 (참고용)

**심화 학습:**
- [Disaster Recovery Best Practices](https://aws.amazon.com/disaster-recovery/)
- [Backup Strategies](https://www.backblaze.com/blog/the-3-2-1-backup-strategy/)

---

**다음 섹션에서 만나요!** 🚀