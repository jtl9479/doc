# 24장 제네릭 Part 3 - 실전 프로젝트 & FAQ 🚀

## 💼 실전 프로젝트: 제네릭 비즈니스 규칙 엔진

### 프로젝트 개요
전자상거래 시스템에서 주문, 결제, 배송 등 다양한 도메인에 대해 비즈니스 규칙을 검증하고 변환하는 범용 규칙 엔진을 제네릭으로 구현합니다.

### 핵심 기능
1. **제네릭 검증기(Validator)**: 다양한 엔티티의 유효성 검사
2. **제네릭 변환기(Transformer)**: 데이터 변환 파이프라인
3. **제네릭 필터(Filter)**: 조건부 데이터 필터링
4. **규칙 체이닝**: 여러 규칙을 조합하는 빌더 패턴

### 전체 코드

```java
import java.time.LocalDateTime;
import java.util.*;
import java.util.function.*;
import java.util.stream.Collectors;

// ========== 1. 제네릭 규칙 인터페이스 ==========

/**
 * 제네릭 검증 규칙 인터페이스
 * @param <T> 검증 대상 타입
 */
@FunctionalInterface
interface ValidationRule<T> {
    ValidationResult validate(T target);

    // 여러 규칙을 AND 조건으로 결합
    default ValidationRule<T> and(ValidationRule<T> other) {
        return target -> {
            ValidationResult first = this.validate(target);
            return first.isValid() ? other.validate(target) : first;
        };
    }
}

/**
 * 검증 결과
 */
class ValidationResult {
    private final boolean valid;
    private final String errorMessage;

    private ValidationResult(boolean valid, String errorMessage) {
        this.valid = valid;
        this.errorMessage = errorMessage;
    }

    public static ValidationResult success() {
        return new ValidationResult(true, null);
    }

    public static ValidationResult fail(String errorMessage) {
        return new ValidationResult(false, errorMessage);
    }

    public boolean isValid() { return valid; }
    public String getErrorMessage() { return errorMessage; }

    @Override
    public String toString() {
        return valid ? "✅ 검증 통과" : "❌ 검증 실패: " + errorMessage;
    }
}

/**
 * 제네릭 변환 규칙 인터페이스
 * @param <S> 소스 타입
 * @param <T> 타겟 타입
 */
@FunctionalInterface
interface TransformationRule<S, T> {
    T transform(S source);

    // 변환 체이닝
    default <R> TransformationRule<S, R> andThen(TransformationRule<T, R> next) {
        return source -> next.transform(this.transform(source));
    }
}

/**
 * 제네릭 필터 규칙 인터페이스
 * @param <T> 필터링 대상 타입
 */
@FunctionalInterface
interface FilterRule<T> {
    boolean test(T item);

    default FilterRule<T> and(FilterRule<T> other) {
        return item -> this.test(item) && other.test(item);
    }

    default FilterRule<T> or(FilterRule<T> other) {
        return item -> this.test(item) || other.test(item);
    }
}

// ========== 2. 도메인 모델 ==========

class Order {
    private String orderId;
    private String customerId;
    private List<OrderItem> items;
    private int totalAmount;
    private LocalDateTime orderDate;
    private OrderStatus status;

    public Order(String orderId, String customerId, List<OrderItem> items,
                 int totalAmount, LocalDateTime orderDate, OrderStatus status) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.items = items;
        this.totalAmount = totalAmount;
        this.orderDate = orderDate;
        this.status = status;
    }

    // Getters
    public String getOrderId() { return orderId; }
    public String getCustomerId() { return customerId; }
    public List<OrderItem> getItems() { return items; }
    public int getTotalAmount() { return totalAmount; }
    public LocalDateTime getOrderDate() { return orderDate; }
    public OrderStatus getStatus() { return status; }

    public void setStatus(OrderStatus status) { this.status = status; }

    @Override
    public String toString() {
        return "Order[" + orderId + "] " + customerId +
               " - " + String.format("%,d원", totalAmount) +
               " (" + status + ")";
    }
}

class OrderItem {
    private String productId;
    private String productName;
    private int quantity;
    private int price;

    public OrderItem(String productId, String productName, int quantity, int price) {
        this.productId = productId;
        this.productName = productName;
        this.quantity = quantity;
        this.price = price;
    }

    public String getProductId() { return productId; }
    public String getProductName() { return productName; }
    public int getQuantity() { return quantity; }
    public int getPrice() { return price; }

    @Override
    public String toString() {
        return productName + " x" + quantity + " (" + String.format("%,d원", price) + ")";
    }
}

enum OrderStatus {
    PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
}

class OrderSummary {
    private String orderId;
    private int totalAmount;
    private int itemCount;

    public OrderSummary(String orderId, int totalAmount, int itemCount) {
        this.orderId = orderId;
        this.totalAmount = totalAmount;
        this.itemCount = itemCount;
    }

    @Override
    public String toString() {
        return "Summary[" + orderId + "] " + itemCount + "개 상품, " +
               String.format("%,d원", totalAmount);
    }
}

// ========== 3. 제네릭 규칙 엔진 ==========

/**
 * 제네릭 규칙 엔진 - Validator, Transformer, Filter 통합
 */
class RuleEngine<T> {
    private List<ValidationRule<T>> validationRules = new ArrayList<>();
    private List<FilterRule<T>> filterRules = new ArrayList<>();

    // Validation 규칙 추가
    public RuleEngine<T> addValidation(ValidationRule<T> rule) {
        validationRules.add(rule);
        return this;
    }

    // Filter 규칙 추가
    public RuleEngine<T> addFilter(FilterRule<T> rule) {
        filterRules.add(rule);
        return this;
    }

    // 단일 객체 검증
    public List<ValidationResult> validate(T target) {
        List<ValidationResult> results = new ArrayList<>();
        for (ValidationRule<T> rule : validationRules) {
            results.add(rule.validate(target));
        }
        return results;
    }

    // 여러 객체 필터링
    public List<T> filter(List<T> items) {
        return items.stream()
                   .filter(item -> filterRules.stream().allMatch(rule -> rule.test(item)))
                   .collect(Collectors.toList());
    }

    // 검증 + 필터링
    public List<T> validateAndFilter(List<T> items) {
        return items.stream()
                   .filter(item -> {
                       List<ValidationResult> results = validate(item);
                       return results.stream().allMatch(ValidationResult::isValid);
                   })
                   .filter(item -> filterRules.stream().allMatch(rule -> rule.test(item)))
                   .collect(Collectors.toList());
    }
}

/**
 * 제네릭 변환 파이프라인
 */
class TransformPipeline<S, T> {
    private final TransformationRule<S, T> rule;

    public TransformPipeline(TransformationRule<S, T> rule) {
        this.rule = rule;
    }

    public static <S, T> TransformPipeline<S, T> from(TransformationRule<S, T> rule) {
        return new TransformPipeline<>(rule);
    }

    public <R> TransformPipeline<S, R> then(TransformationRule<T, R> next) {
        return new TransformPipeline<>(rule.andThen(next));
    }

    public T execute(S source) {
        return rule.transform(source);
    }

    public List<T> executeAll(List<S> sources) {
        return sources.stream()
                     .map(rule::transform)
                     .collect(Collectors.toList());
    }
}

// ========== 4. 비즈니스 규칙 정의 ==========

class OrderRules {

    // 검증 규칙 1: 주문 금액 최소값
    public static ValidationRule<Order> minimumAmount(int minAmount) {
        return order -> {
            if (order.getTotalAmount() >= minAmount) {
                return ValidationResult.success();
            }
            return ValidationResult.fail(
                "최소 주문 금액 미달: " + String.format("%,d원", minAmount) + " 필요"
            );
        };
    }

    // 검증 규칙 2: 주문 항목 개수 제한
    public static ValidationRule<Order> maximumItems(int maxItems) {
        return order -> {
            if (order.getItems().size() <= maxItems) {
                return ValidationResult.success();
            }
            return ValidationResult.fail(
                "주문 항목 초과: 최대 " + maxItems + "개까지 가능"
            );
        };
    }

    // 검증 규칙 3: 고객 ID 형식
    public static ValidationRule<Order> validCustomerId() {
        return order -> {
            String customerId = order.getCustomerId();
            if (customerId != null && customerId.matches("CUST-\\d{4}")) {
                return ValidationResult.success();
            }
            return ValidationResult.fail(
                "잘못된 고객 ID 형식: CUST-XXXX 형식이어야 함"
            );
        };
    }

    // 필터 규칙 1: 상태별 필터
    public static FilterRule<Order> byStatus(OrderStatus status) {
        return order -> order.getStatus() == status;
    }

    // 필터 규칙 2: 금액 범위 필터
    public static FilterRule<Order> amountBetween(int min, int max) {
        return order -> {
            int amount = order.getTotalAmount();
            return amount >= min && amount <= max;
        };
    }

    // 변환 규칙: Order → OrderSummary
    public static TransformationRule<Order, OrderSummary> toSummary() {
        return order -> new OrderSummary(
            order.getOrderId(),
            order.getTotalAmount(),
            order.getItems().size()
        );
    }

    // 변환 규칙: 할인 적용
    public static TransformationRule<Order, Order> applyDiscount(double discountRate) {
        return order -> {
            int discountedAmount = (int) (order.getTotalAmount() * (1 - discountRate));
            return new Order(
                order.getOrderId(),
                order.getCustomerId(),
                order.getItems(),
                discountedAmount,
                order.getOrderDate(),
                order.getStatus()
            );
        };
    }
}

// ========== 5. 메인 실행 ==========

public class GenericRuleEngineProject {
    public static void main(String[] args) {
        System.out.println("=== 제네릭 비즈니스 규칙 엔진 ===\n");

        // 테스트 데이터 생성
        List<Order> orders = createSampleOrders();

        // ===== 1. Validation 규칙 =====
        System.out.println("--- 1. 주문 검증 규칙 ---\n");

        RuleEngine<Order> validator = new RuleEngine<>();
        validator.addValidation(OrderRules.minimumAmount(10000))
                .addValidation(OrderRules.maximumItems(5))
                .addValidation(OrderRules.validCustomerId());

        for (Order order : orders) {
            System.out.println("검증 대상: " + order);
            List<ValidationResult> results = validator.validate(order);
            results.forEach(result -> System.out.println("   " + result));
            System.out.println();
        }

        // ===== 2. Filter 규칙 =====
        System.out.println("--- 2. 주문 필터링 규칙 ---\n");

        RuleEngine<Order> filter = new RuleEngine<>();
        filter.addFilter(OrderRules.byStatus(OrderStatus.CONFIRMED))
             .addFilter(OrderRules.amountBetween(20000, 100000));

        List<Order> filteredOrders = filter.filter(orders);
        System.out.println("필터 조건: CONFIRMED 상태 + 20,000~100,000원");
        System.out.println("필터 결과 (" + filteredOrders.size() + "건):");
        filteredOrders.forEach(order -> System.out.println("   " + order));
        System.out.println();

        // ===== 3. Transformation 규칙 =====
        System.out.println("--- 3. 주문 변환 규칙 ---\n");

        // Order → OrderSummary 변환
        TransformPipeline<Order, OrderSummary> summaryPipeline =
            TransformPipeline.from(OrderRules.toSummary());

        List<OrderSummary> summaries = summaryPipeline.executeAll(orders);
        System.out.println("Order → OrderSummary 변환:");
        summaries.forEach(summary -> System.out.println("   " + summary));
        System.out.println();

        // 할인 적용 후 요약 변환 (체이닝)
        TransformPipeline<Order, OrderSummary> discountPipeline =
            TransformPipeline.from(OrderRules.applyDiscount(0.1))  // 10% 할인
                           .then(OrderRules.toSummary());          // 요약 변환

        System.out.println("10% 할인 적용 후 요약:");
        List<OrderSummary> discountedSummaries = discountPipeline.executeAll(orders);
        discountedSummaries.forEach(summary -> System.out.println("   " + summary));
        System.out.println();

        // ===== 4. 복합 규칙 (Validation + Filter) =====
        System.out.println("--- 4. 복합 규칙 (검증 + 필터) ---\n");

        RuleEngine<Order> complexEngine = new RuleEngine<>();
        complexEngine.addValidation(OrderRules.minimumAmount(10000))
                    .addValidation(OrderRules.validCustomerId())
                    .addFilter(OrderRules.byStatus(OrderStatus.CONFIRMED));

        List<Order> validAndFiltered = complexEngine.validateAndFilter(orders);
        System.out.println("검증 통과 + CONFIRMED 상태 주문 (" + validAndFiltered.size() + "건):");
        validAndFiltered.forEach(order -> System.out.println("   " + order));

        // ===== 5. 실무 시나리오: 주문 승인 파이프라인 =====
        System.out.println("\n--- 5. 실무 시나리오: 주문 승인 파이프라인 ---\n");

        System.out.println("총 주문: " + orders.size() + "건");

        // Step 1: 검증
        ValidationRule<Order> combinedValidation =
            OrderRules.minimumAmount(10000)
                     .and(OrderRules.maximumItems(10))
                     .and(OrderRules.validCustomerId());

        List<Order> validOrders = orders.stream()
            .filter(order -> combinedValidation.validate(order).isValid())
            .collect(Collectors.toList());
        System.out.println("Step 1 - 검증 통과: " + validOrders.size() + "건");

        // Step 2: PENDING 주문만 필터
        List<Order> pendingOrders = validOrders.stream()
            .filter(order -> order.getStatus() == OrderStatus.PENDING)
            .collect(Collectors.toList());
        System.out.println("Step 2 - PENDING 주문: " + pendingOrders.size() + "건");

        // Step 3: 상태 변경 (PENDING → CONFIRMED)
        pendingOrders.forEach(order -> order.setStatus(OrderStatus.CONFIRMED));
        System.out.println("Step 3 - 주문 승인 완료: " + pendingOrders.size() + "건");

        System.out.println("\n승인된 주문:");
        pendingOrders.forEach(order -> System.out.println("   " + order));

        System.out.println("\n\n✅ 제네릭 규칙 엔진의 장점:");
        System.out.println("1. 재사용성: 동일한 엔진으로 Order, User, Product 등 다양한 도메인 처리");
        System.out.println("2. 타입 안전성: 컴파일 타임에 타입 체크");
        System.out.println("3. 조합 가능: 규칙을 and, or, andThen으로 유연하게 조합");
        System.out.println("4. 함수형 프로그래밍: 람다 표현식과 완벽한 조합");
        System.out.println("5. 확장성: 새로운 규칙을 쉽게 추가 가능");
    }

    // 테스트 데이터 생성
    private static List<Order> createSampleOrders() {
        return Arrays.asList(
            new Order("ORD-001", "CUST-1001",
                Arrays.asList(
                    new OrderItem("P001", "노트북", 1, 150000),
                    new OrderItem("P002", "마우스", 2, 3000)
                ),
                50000, LocalDateTime.now(), OrderStatus.PENDING),

            new Order("ORD-002", "CUST-1002",
                Arrays.asList(
                    new OrderItem("P003", "키보드", 1, 80000)
                ),
                80000, LocalDateTime.now(), OrderStatus.CONFIRMED),

            new Order("ORD-003", "INVALID",  // 잘못된 고객 ID
                Arrays.asList(
                    new OrderItem("P004", "모니터", 1, 30000)
                ),
                30000, LocalDateTime.now(), OrderStatus.CONFIRMED),

            new Order("ORD-004", "CUST-1003",
                Arrays.asList(
                    new OrderItem("P005", "USB", 1, 5000)  // 최소 금액 미달
                ),
                5000, LocalDateTime.now(), OrderStatus.PENDING),

            new Order("ORD-005", "CUST-1004",
                Arrays.asList(
                    new OrderItem("P006", "책상", 1, 200000)
                ),
                200000, LocalDateTime.now(), OrderStatus.SHIPPED)
        );
    }
}
```

### 실행 결과

```
=== 제네릭 비즈니스 규칙 엔진 ===

--- 1. 주문 검증 규칙 ---

검증 대상: Order[ORD-001] CUST-1001 - 50,000원 (PENDING)
   ✅ 검증 통과
   ✅ 검증 통과
   ✅ 검증 통과

검증 대상: Order[ORD-002] CUST-1002 - 80,000원 (CONFIRMED)
   ✅ 검증 통과
   ✅ 검증 통과
   ✅ 검증 통과

검증 대상: Order[ORD-003] INVALID - 30,000원 (CONFIRMED)
   ✅ 검증 통과
   ✅ 검증 통과
   ❌ 검증 실패: 잘못된 고객 ID 형식: CUST-XXXX 형식이어야 함

검증 대상: Order[ORD-004] CUST-1003 - 5,000원 (PENDING)
   ❌ 검증 실패: 최소 주문 금액 미달: 10,000원 필요
   ✅ 검증 통과
   ✅ 검증 통과

검증 대상: Order[ORD-005] CUST-1004 - 200,000원 (SHIPPED)
   ✅ 검증 통과
   ✅ 검증 통과
   ✅ 검증 통과

--- 2. 주문 필터링 규칙 ---

필터 조건: CONFIRMED 상태 + 20,000~100,000원
필터 결과 (2건):
   Order[ORD-002] CUST-1002 - 80,000원 (CONFIRMED)
   Order[ORD-003] INVALID - 30,000원 (CONFIRMED)

--- 3. 주문 변환 규칙 ---

Order → OrderSummary 변환:
   Summary[ORD-001] 2개 상품, 50,000원
   Summary[ORD-002] 1개 상품, 80,000원
   Summary[ORD-003] 1개 상품, 30,000원
   Summary[ORD-004] 1개 상품, 5,000원
   Summary[ORD-005] 1개 상품, 200,000원

10% 할인 적용 후 요약:
   Summary[ORD-001] 2개 상품, 45,000원
   Summary[ORD-002] 1개 상품, 72,000원
   Summary[ORD-003] 1개 상품, 27,000원
   Summary[ORD-004] 1개 상품, 4,500원
   Summary[ORD-005] 1개 상품, 180,000원

--- 4. 복합 규칙 (검증 + 필터) ---

검증 통과 + CONFIRMED 상태 주문 (1건):
   Order[ORD-002] CUST-1002 - 80,000원 (CONFIRMED)

--- 5. 실무 시나리오: 주문 승인 파이프라인 ---

총 주문: 5건
Step 1 - 검증 통과: 3건
Step 2 - PENDING 주문: 1건
Step 3 - 주문 승인 완료: 1건

승인된 주문:
   Order[ORD-001] CUST-1001 - 50,000원 (CONFIRMED)


✅ 제네릭 규칙 엔진의 장점:
1. 재사용성: 동일한 엔진으로 Order, User, Product 등 다양한 도메인 처리
2. 타입 안전성: 컴파일 타임에 타입 체크
3. 조합 가능: 규칙을 and, or, andThen으로 유연하게 조합
4. 함수형 프로그래밍: 람다 표현식과 완벽한 조합
5. 확장성: 새로운 규칙을 쉽게 추가 가능
```

### 프로젝트 핵심 포인트

#### 1. 제네릭 인터페이스 설계
```java
@FunctionalInterface
interface ValidationRule<T> {
    ValidationResult validate(T target);
}
```
- 어떤 타입이든 검증 가능한 범용 인터페이스
- `@FunctionalInterface`로 람다 표현식 사용 가능

#### 2. 제네릭 메서드 체이닝
```java
default ValidationRule<T> and(ValidationRule<T> other) {
    return target -> {
        ValidationResult first = this.validate(target);
        return first.isValid() ? other.validate(target) : first;
    };
}
```
- 여러 규칙을 조합하는 Fluent API
- 함수형 프로그래밍 패턴

#### 3. 다중 타입 파라미터
```java
interface TransformationRule<S, T> {
    T transform(S source);
}
```
- Source 타입 → Target 타입 변환
- `Order → OrderSummary` 등 다양한 변환 표현

#### 4. 제네릭 + 빌더 패턴
```java
TransformPipeline<Order, OrderSummary> pipeline =
    TransformPipeline.from(OrderRules.applyDiscount(0.1))
                   .then(OrderRules.toSummary());
```
- 변환 규칙을 체이닝하는 파이프라인
- 가독성과 재사용성 극대화

### 확장 아이디어
1. **제네릭 이벤트 버스**: `EventBus<T>`로 다양한 이벤트 처리
2. **제네릭 리포지토리**: Spring Data JPA 스타일의 `Repository<T, ID>`
3. **제네릭 상태 머신**: `StateMachine<S, E>` (State, Event)
4. **제네릭 커맨드 패턴**: `Command<T>`, `CommandHandler<T>`

---

## ❓ 자주 묻는 질문 (FAQ)

### Q1. 제네릭을 사용하지 않으면 어떤 문제가 있나요?

**A:** 제네릭 없이 `Object`를 사용하면 세 가지 문제가 발생합니다:

1. **타입 안전성 상실**
```java
List list = new ArrayList();
list.add("문자열");
list.add(123);  // 컴파일 OK, 런타임 에러 위험
String str = (String) list.get(1);  // ClassCastException!
```

2. **불필요한 타입 캐스팅**
```java
// 제네릭 없음
Object obj = list.get(0);
String str = (String) obj;  // 매번 캐스팅 필요

// 제네릭 사용
List<String> list = new ArrayList<>();
String str = list.get(0);  // 캐스팅 불필요
```

3. **컴파일 타임 체크 불가**
```java
// 제네릭 없음: 런타임에서야 에러 발견
List list = new ArrayList();
list.add(new Integer(10));
String str = (String) list.get(0);  // 💥 런타임 에러

// 제네릭 사용: 컴파일 타임에 에러 발견
List<String> list = new ArrayList<>();
list.add(10);  // ❌ 컴파일 에러! 즉시 발견
```

**핵심**: 제네릭은 "빠른 실패(Fail-fast)" 원칙으로 런타임 에러를 컴파일 타임으로 앞당깁니다.

---

### Q2. `<? extends T>`와 `<? super T>`의 차이가 헷갈려요. 언제 어떤 것을 사용하나요?

**A:** **PECS 원칙**을 기억하세요: **Producer-Extends, Consumer-Super**

#### `<? extends T>` - 읽기 전용 (Producer)
```java
// 데이터를 "생산"하는 경우 - 읽기만 가능
public static double sumNumbers(List<? extends Number> numbers) {
    double sum = 0;
    for (Number num : numbers) {  // ✅ 읽기 가능
        sum += num.doubleValue();
    }
    // numbers.add(10);  // ❌ 쓰기 불가능
    return sum;
}

// Integer, Double 등 모든 Number 하위 타입 허용
sumNumbers(Arrays.asList(1, 2, 3));        // List<Integer>
sumNumbers(Arrays.asList(1.5, 2.5, 3.5));  // List<Double>
```

**왜 쓰기 불가능?**
- `List<? extends Number>`는 `List<Integer>`, `List<Double>` 등 어떤 타입인지 모릅니다
- `List<Integer>`에 `Double`을 넣으면 타입 안전성 위반!

#### `<? super T>` - 쓰기 전용 (Consumer)
```java
// 데이터를 "소비"하는 경우 - 쓰기만 가능
public static void addNumbers(List<? super Integer> numbers) {
    numbers.add(10);  // ✅ 쓰기 가능
    numbers.add(20);
    numbers.add(30);

    // Integer num = numbers.get(0);  // ❌ 읽기 제한
    Object obj = numbers.get(0);      // ⚠️ Object로만 가능
}

// Integer의 상위 타입 허용
List<Number> numbers = new ArrayList<>();
addNumbers(numbers);  // List<Number>
List<Object> objects = new ArrayList<>();
addNumbers(objects);  // List<Object>
```

**왜 읽기 제한?**
- `List<? super Integer>`는 `List<Number>`, `List<Object>` 등 어떤 타입인지 모릅니다
- 꺼낼 때 `Number`인지 `Object`인지 알 수 없으므로 `Object`로만 읽기 가능

#### 실무 사용 예시
```java
// Collections.copy() 실제 구현
public static <T> void copy(
    List<? super T> dest,     // Consumer (쓰기)
    List<? extends T> src     // Producer (읽기)
) {
    for (T item : src) {
        dest.add(item);
    }
}

List<Integer> source = Arrays.asList(1, 2, 3);
List<Number> destination = new ArrayList<>();
Collections.copy(destination, source);  // ✅ 가능
```

---

### Q3. 타입 소거(Type Erasure)란 무엇이고, 왜 필요한가요?

**A:** 타입 소거는 **컴파일 후 제네릭 타입 정보를 제거**하는 Java의 메커니즘입니다.

#### 타입 소거 과정
```java
// 컴파일 전 (소스 코드)
List<String> strings = new ArrayList<String>();
strings.add("Hello");
String str = strings.get(0);

// 컴파일 후 (바이트코드 - 타입 소거)
List strings = new ArrayList();  // 타입 파라미터 제거
strings.add("Hello");
String str = (String) strings.get(0);  // 컴파일러가 자동 캐스팅 삽입
```

#### 타입 소거 규칙
1. **타입 파라미터 → 바운드 또는 Object**
```java
// 소스 코드
class Box<T> { private T item; }
class NumberBox<T extends Number> { private T value; }

// 컴파일 후
class Box { private Object item; }  // T → Object
class NumberBox { private Number value; }  // T extends Number → Number
```

2. **제네릭 메서드도 동일**
```java
// 소스 코드
public <T> T getFirst(List<T> list) {
    return list.get(0);
}

// 컴파일 후
public Object getFirst(List list) {  // T → Object
    return list.get(0);
}
```

#### 왜 타입 소거가 필요한가?
**하위 호환성 유지 (Backward Compatibility)**

Java 5 이전 코드와 호환되도록 하기 위함:
```java
// Java 1.4 (제네릭 없음)
List oldList = new ArrayList();
oldList.add("old");

// Java 5+ (제네릭 있음)
List<String> newList = new ArrayList<>();
newList.add("new");

// 타입 소거 덕분에 두 코드가 함께 동작 가능!
oldList = newList;  // ✅ 가능 (경고 발생하지만 실행 가능)
```

#### 타입 소거로 인한 제약
```java
// 1. 제네릭 배열 생성 불가
T[] array = new T[10];  // ❌ 컴파일 에러

// 2. instanceof 체크 불가
if (obj instanceof List<String>) { }  // ❌ 컴파일 에러
if (obj instanceof List) { }  // ✅ Raw type만 가능

// 3. static 필드에 타입 파라미터 사용 불가
class Box<T> {
    private static T value;  // ❌ 컴파일 에러
}

// 4. 런타임에 타입 정보 없음
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass());  // true!
```

---

### Q4. 제네릭 메서드는 언제 사용하고, 제네릭 클래스와 어떻게 다른가요?

**A:** 제네릭 메서드는 **메서드 레벨에서만 타입 파라미터가 필요한 경우** 사용합니다.

#### 제네릭 클래스
```java
// 클래스 전체가 타입에 의존
class Box<T> {
    private T item;

    public void set(T item) { this.item = item; }
    public T get() { return item; }
}

// 사용 시 타입 지정
Box<String> stringBox = new Box<>();
Box<Integer> intBox = new Box<>();
```
- **전체 클래스**가 하나의 타입으로 특화됨
- 인스턴스마다 다른 타입 지정 가능

#### 제네릭 메서드
```java
// 메서드만 타입 파라미터 사용
class Util {
    // 제네릭 메서드: <T>가 메서드 앞에 위치
    public static <T> T getFirst(List<T> list) {
        return list.isEmpty() ? null : list.get(0);
    }

    public static <T> void swap(List<T> list, int i, int j) {
        T temp = list.get(i);
        list.set(i, list.get(j));
        list.set(j, temp);
    }
}

// 사용 시 타입 추론
String first = Util.getFirst(Arrays.asList("A", "B", "C"));  // T = String
Integer num = Util.getFirst(Arrays.asList(1, 2, 3));  // T = Integer
```
- **특정 메서드**만 타입 파라미터 사용
- 호출할 때마다 타입 결정 (타입 추론)

#### 비제네릭 클래스 내부의 제네릭 메서드
```java
class StringProcessor {  // 클래스는 제네릭 아님

    // 메서드만 제네릭
    public <T> List<T> convert(List<String> strings, Function<String, T> converter) {
        return strings.stream()
                     .map(converter)
                     .collect(Collectors.toList());
    }
}

// 사용
StringProcessor processor = new StringProcessor();
List<Integer> lengths = processor.convert(
    Arrays.asList("a", "bb", "ccc"),
    String::length  // String → Integer 변환
);  // [1, 2, 3]
```

#### 제네릭 클래스 + 제네릭 메서드 조합
```java
class Pair<K, V> {  // 클래스 레벨 제네릭
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    // 메서드 레벨 제네릭 (클래스 타입 파라미터와 독립적)
    public <T> T transform(Function<Pair<K, V>, T> transformer) {
        return transformer.apply(this);
    }
}

// 사용
Pair<String, Integer> pair = new Pair<>("Age", 30);  // K=String, V=Integer
String result = pair.transform(p -> p.key + ": " + p.value);  // T=String
```

#### 언제 제네릭 메서드를 사용할까?
1. **유틸리티 메서드**: `Collections.swap()`, `Collections.sort()`
2. **타입 변환**: 입력과 출력 타입이 다를 때
3. **일회성 작업**: 클래스 전체를 제네릭으로 만들 필요 없는 경우

---

### Q5. 제네릭에서 원시 타입(int, double)을 사용할 수 없는 이유는?

**A:** 제네릭은 **참조 타입(Reference Type)만** 사용 가능하며, 원시 타입은 **오토박싱/언박싱**으로 해결합니다.

#### 원시 타입 직접 사용 불가
```java
List<int> numbers = new ArrayList<>();  // ❌ 컴파일 에러!
List<double> values = new ArrayList<>();  // ❌ 컴파일 에러!
```

#### 이유: 타입 소거와 Object 대체
```java
// 타입 소거 과정
List<T> → List  // T는 Object로 대체됨

// 원시 타입은 Object의 하위 타입이 아님
int는 Object를 상속하지 않음!
```

#### 해결책: 래퍼 클래스 사용
```java
// ✅ 래퍼 클래스 사용
List<Integer> numbers = new ArrayList<>();
List<Double> values = new ArrayList<>();
List<Boolean> flags = new ArrayList<>();

numbers.add(10);  // 오토박싱: int → Integer
int num = numbers.get(0);  // 언박싱: Integer → int
```

#### 오토박싱/언박싱 동작
```java
// 오토박싱 (Auto-Boxing)
Integer wrapped = 10;  // 컴파일러가 Integer.valueOf(10)으로 변환

// 언박싱 (Auto-Unboxing)
int primitive = wrapped;  // 컴파일러가 wrapped.intValue()로 변환

// 제네릭 + 오토박싱
List<Integer> list = new ArrayList<>();
list.add(5);  // int → Integer (오토박싱)
int value = list.get(0);  // Integer → int (언박싱)
```

#### 성능 고려사항
```java
// ❌ 성능 비효율: 매번 박싱/언박싱
List<Integer> numbers = new ArrayList<>();
for (int i = 0; i < 1000000; i++) {
    numbers.add(i);  // 100만 번의 Integer 객체 생성!
}

// ✅ 원시 타입 배열 사용 (제네릭 없음)
int[] numbers = new int[1000000];
for (int i = 0; i < 1000000; i++) {
    numbers[i] = i;  // 박싱 없음, 빠름
}
```

#### 전문 라이브러리 활용
```java
// Eclipse Collections, Trove 등 원시 타입 컬렉션
IntArrayList numbers = new IntArrayList();  // int 전용
numbers.add(10);  // 박싱 없음!

// Java Stream API - 원시 타입 특화
IntStream.range(0, 1000000)
        .sum();  // 박싱 없이 빠른 연산
```

---

### Q6. 제네릭에서 `new T()` 같은 객체 생성이 불가능한 이유와 해결 방법은?

**A:** 타입 소거로 인해 **런타임에 T의 실제 타입 정보가 없기 때문**입니다.

#### 불가능한 작업들
```java
class Container<T> {
    private T item;

    public Container() {
        // this.item = new T();  // ❌ 컴파일 에러: Cannot instantiate the type T
    }

    public T createNew() {
        // return new T();  // ❌ 불가능
    }

    public T[] createArray(int size) {
        // return new T[size];  // ❌ 불가능
    }
}
```

#### 왜 불가능한가?
```java
// 타입 소거 후
class Container {
    private Object item;  // T → Object

    public Object createNew() {
        return new Object();  // new T()는 new Object()가 되어버림!
    }
}

// 사용자가 원한 것
Container<String> container = new Container<>();
String str = container.createNew();  // String을 원했지만 Object가 반환됨!
```

#### 해결 방법 1: Class 객체 전달
```java
class Container<T> {
    private Class<T> type;

    public Container(Class<T> type) {
        this.type = type;
    }

    // ✅ Class 객체로 인스턴스 생성
    public T createNew() throws Exception {
        return type.getDeclaredConstructor().newInstance();
    }
}

// 사용
Container<String> container = new Container<>(String.class);
String str = container.createNew();  // ✅ "String" 타입 객체 생성
```

#### 해결 방법 2: Supplier 함수 전달
```java
class Container<T> {
    private Supplier<T> factory;

    public Container(Supplier<T> factory) {
        this.factory = factory;
    }

    // ✅ Supplier로 객체 생성
    public T createNew() {
        return factory.get();
    }
}

// 사용
Container<String> container = new Container<>(String::new);
String str = container.createNew();  // ✅ "String" 타입 객체 생성

Container<ArrayList<Integer>> listContainer =
    new Container<>(ArrayList::new);
ArrayList<Integer> list = listContainer.createNew();
```

#### 해결 방법 3: 배열 - 제네릭 배열 우회
```java
class Container<T> {
    private T[] items;

    @SuppressWarnings("unchecked")
    public Container(int size) {
        // ⚠️ 경고 발생하지만 동작 가능
        items = (T[]) new Object[size];
    }

    public T get(int index) {
        return items[index];
    }

    public void set(int index, T item) {
        items[index] = item;
    }
}

// 사용
Container<String> container = new Container<>(10);
container.set(0, "Hello");
String str = container.get(0);  // ✅ 동작
```

#### 실무 라이브러리 예시
```java
// Gson - Class 객체 사용
Gson gson = new Gson();
MyClass obj = gson.fromJson(json, MyClass.class);

// Jackson - TypeReference 사용
ObjectMapper mapper = new ObjectMapper();
List<MyClass> list = mapper.readValue(json,
    new TypeReference<List<MyClass>>() {});  // 익명 클래스로 타입 정보 유지
```

---

### Q7. 제네릭 와일드카드 `<?>`는 언제 사용하나요?

**A:** `<?>`는 **타입을 모르거나, 타입에 관계없이 작업할 때** 사용합니다.

#### 무제한 와일드카드 `<?>`
```java
// 어떤 타입이든 허용, 읽기만 가능 (Object로)
public static void printSize(List<?> list) {
    System.out.println("크기: " + list.size());

    // Object obj = list.get(0);  // ✅ Object로 읽기 가능
    // list.add("Hello");  // ❌ 쓰기 불가능 (타입 안전성)
}

// 사용
printSize(Arrays.asList(1, 2, 3));          // List<Integer>
printSize(Arrays.asList("A", "B"));         // List<String>
printSize(Arrays.asList(true, false));      // List<Boolean>
```

#### `<?>` vs `<Object>` 차이
```java
// List<Object>: Object 리스트만 허용
public static void addObject(List<Object> list) {
    list.add(new Object());
}

List<String> strings = new ArrayList<>();
addObject(strings);  // ❌ 컴파일 에러! List<String>은 List<Object>가 아님

// List<?>: 어떤 타입이든 허용
public static void printAll(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}

printAll(strings);  // ✅ 가능! List<String>도 List<?>의 일종
```

#### `<?>` vs `<T>` 언제 사용?
```java
// <?> - 타입 파라미터가 불필요한 경우
public static void printList(List<?> list) {
    list.forEach(System.out::println);  // 타입 정보 불필요
}

// <T> - 타입 파라미터가 필요한 경우
public static <T> T getFirst(List<T> list) {
    return list.isEmpty() ? null : list.get(0);  // 반환 타입에 T 사용
}
```

#### 실무 사용 예시
```java
// 1. 컬렉션 비우기
public static void clearAll(List<?> list) {
    list.clear();  // 타입 관계없이 비우기
}

// 2. null 체크
public static boolean isNullOrEmpty(List<?> list) {
    return list == null || list.isEmpty();
}

// 3. 로깅
public static void logCollection(String name, Collection<?> collection) {
    System.out.println(name + ": " + collection.size() + " items");
}
```

---

## 🎤 면접 질문

### 주니어 레벨 (Junior Level)

#### Q1. 제네릭이 무엇이고, 왜 사용하나요?

**모범 답변:**
제네릭은 클래스나 메서드를 정의할 때 타입을 파라미터로 받아 사용하는 기능입니다. 주요 이유는:

1. **타입 안전성**: 컴파일 타임에 타입 체크로 런타임 에러 방지
2. **타입 캐스팅 제거**: 자동 타입 변환으로 코드 간결화
3. **코드 재사용성**: 하나의 코드로 다양한 타입 처리

```java
// 제네릭 사용 전
List list = new ArrayList();
list.add("Hello");
String str = (String) list.get(0);  // 캐스팅 필요

// 제네릭 사용 후
List<String> list = new ArrayList<>();
list.add("Hello");
String str = list.get(0);  // 캐스팅 불필요
```

---

#### Q2. 제네릭 클래스를 어떻게 선언하나요? 예제를 들어 설명해주세요.

**모범 답변:**
제네릭 클래스는 클래스명 뒤에 `<T>`를 붙여 선언합니다:

```java
public class Box<T> {
    private T item;

    public void set(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}

// 사용
Box<String> stringBox = new Box<>();
stringBox.set("Hello");
String value = stringBox.get();

Box<Integer> intBox = new Box<>();
intBox.set(100);
Integer number = intBox.get();
```

**핵심 포인트:**
- `T`는 타입 파라미터 (Type Parameter)
- 관례적으로 `T` (Type), `E` (Element), `K` (Key), `V` (Value) 사용
- 인스턴스 생성 시 구체적인 타입 지정

---

#### Q3. `List<Object>`와 `List<?>`의 차이는 무엇인가요?

**모범 답변:**

**`List<Object>`**: Object 타입의 요소만 담은 리스트
```java
List<Object> objects = new ArrayList<>();
objects.add("String");
objects.add(123);

List<String> strings = new ArrayList<>();
objects = strings;  // ❌ 컴파일 에러! List<String>은 List<Object>가 아님
```

**`List<?>`**: 어떤 타입이든 허용하는 리스트 (읽기 전용)
```java
List<?> wildcards = new ArrayList<String>();  // ✅ 가능
wildcards = new ArrayList<Integer>();  // ✅ 가능

Object obj = wildcards.get(0);  // ✅ 읽기 가능
wildcards.add("Hello");  // ❌ 쓰기 불가능
```

**핵심 차이:**
- `List<Object>`: Object 타입 리스트만 허용
- `List<?>`: 모든 제네릭 리스트 허용, 단 쓰기 불가

---

#### Q4. 제네릭 메서드를 어떻게 선언하나요?

**모범 답변:**
제네릭 메서드는 반환 타입 앞에 `<T>`를 선언합니다:

```java
public class Util {
    // 제네릭 메서드
    public static <T> T getFirst(List<T> list) {
        return list.isEmpty() ? null : list.get(0);
    }

    // 다중 타입 파라미터
    public static <K, V> Map<K, V> createMap(K key, V value) {
        Map<K, V> map = new HashMap<>();
        map.put(key, value);
        return map;
    }
}

// 사용 (타입 추론)
String first = Util.getFirst(Arrays.asList("A", "B", "C"));
Integer num = Util.getFirst(Arrays.asList(1, 2, 3));

Map<String, Integer> map = Util.createMap("Age", 30);
```

---

#### Q5. 타입 소거(Type Erasure)란 무엇인가요?

**모범 답변:**
타입 소거는 컴파일 후 제네릭 타입 정보를 제거하는 Java의 메커니즘입니다.

```java
// 컴파일 전
List<String> strings = new ArrayList<String>();
strings.add("Hello");
String str = strings.get(0);

// 컴파일 후 (바이트코드)
List strings = new ArrayList();  // 타입 파라미터 제거
strings.add("Hello");
String str = (String) strings.get(0);  // 컴파일러가 캐스팅 삽입
```

**이유**: Java 5 이전 코드와의 하위 호환성 유지

**결과**: 런타임에는 `List<String>`과 `List<Integer>`가 동일한 `List` 타입

---

#### Q6. `<? extends T>`와 `<? super T>`의 차이를 설명해주세요.

**모범 답변:**

**`<? extends T>` - 상한 제한 (Upper Bound)**
```java
// T와 T의 하위 타입만 허용, 읽기 전용
public static double sum(List<? extends Number> numbers) {
    double total = 0;
    for (Number num : numbers) {  // ✅ 읽기 가능
        total += num.doubleValue();
    }
    // numbers.add(10);  // ❌ 쓰기 불가
    return total;
}

sum(Arrays.asList(1, 2, 3));      // List<Integer>
sum(Arrays.asList(1.5, 2.5));     // List<Double>
```

**`<? super T>` - 하한 제한 (Lower Bound)**
```java
// T와 T의 상위 타입만 허용, 쓰기 전용
public static void addNumbers(List<? super Integer> list) {
    list.add(10);  // ✅ 쓰기 가능
    list.add(20);

    // Integer num = list.get(0);  // ❌ 읽기 제한
    Object obj = list.get(0);      // ⚠️ Object로만 가능
}

List<Number> numbers = new ArrayList<>();
addNumbers(numbers);  // List<Number>
List<Object> objects = new ArrayList<>();
addNumbers(objects);  // List<Object>
```

**PECS 원칙**: Producer-Extends, Consumer-Super

---

#### Q7. 제네릭에서 원시 타입(int, double)을 사용할 수 없는 이유는?

**모범 답변:**
제네릭은 참조 타입만 허용하며, 원시 타입은 Object의 하위 타입이 아니기 때문입니다.

```java
List<int> numbers = new ArrayList<>();  // ❌ 컴파일 에러
List<Integer> numbers = new ArrayList<>();  // ✅ 래퍼 클래스 사용

numbers.add(10);  // 오토박싱: int → Integer
int value = numbers.get(0);  // 언박싱: Integer → int
```

**이유**: 타입 소거 시 `T`가 `Object`로 대체되는데, `int`는 `Object`를 상속하지 않음

---

### 중급 레벨 (Intermediate Level)

#### Q8. 제네릭의 공변성(Covariance)과 반공변성(Contravariance)을 설명해주세요.

**모범 답변:**

**불공변성 (Invariance)** - 제네릭의 기본 특성
```java
List<Object> objects = new ArrayList<String>();  // ❌ 컴파일 에러!
// List<String>은 List<Object>의 하위 타입이 아님
```

**공변성 (Covariance)** - `<? extends T>`
```java
// "Producer"로 사용 - 데이터를 생산(읽기)
List<? extends Number> numbers = new ArrayList<Integer>();  // ✅ 가능
Number num = numbers.get(0);  // ✅ 읽기 가능
numbers.add(10);  // ❌ 쓰기 불가
```
- `Integer`는 `Number`의 하위 타입
- `List<Integer>`를 `List<? extends Number>`로 취급 가능
- 읽기는 안전하지만, 쓰기는 위험 (타입 안전성 위반)

**반공변성 (Contravariance)** - `<? super T>`
```java
// "Consumer"로 사용 - 데이터를 소비(쓰기)
List<? super Integer> numbers = new ArrayList<Number>();  // ✅ 가능
numbers.add(10);  // ✅ 쓰기 가능
Integer num = numbers.get(0);  // ❌ 읽기 제한 (Object로만 가능)
```
- `Number`는 `Integer`의 상위 타입
- `List<Number>`를 `List<? super Integer>`로 취급 가능
- 쓰기는 안전하지만, 읽기는 제한 (어떤 상위 타입인지 모름)

**실무 예시: Collections.copy()**
```java
public static <T> void copy(
    List<? super T> dest,     // 반공변 - Consumer (쓰기)
    List<? extends T> src     // 공변 - Producer (읽기)
) {
    for (T item : src) {
        dest.add(item);
    }
}
```

---

#### Q9. 제네릭 배열을 생성할 수 없는 이유와 우회 방법을 설명해주세요.

**모범 답변:**

**불가능한 이유:**
```java
// ❌ 컴파일 에러
List<String>[] stringLists = new List<String>[10];
T[] array = new T[10];

// 이유: 타입 소거로 인해 런타임에 타입 정보 없음
List<String>[] stringLists = new List[10];  // 타입 소거 후
// 런타임에 List<String>인지 List<Integer>인지 알 수 없음!
```

**문제 시나리오 (허용된다면):**
```java
// 만약 제네릭 배열이 허용된다면...
Object[] objArray = stringLists;  // 배열은 공변
objArray[0] = new ArrayList<Integer>();  // ArrayStoreException 없이 통과!
String str = stringLists[0].get(0);  // 💥 런타임 에러!
```

**우회 방법 1: ArrayList 사용**
```java
// ✅ 제네릭 배열 대신 ArrayList
List<T> list = new ArrayList<>();
list.add(item);
T value = list.get(0);
```

**우회 방법 2: @SuppressWarnings + 주의 깊은 사용**
```java
@SuppressWarnings("unchecked")
public class GenericArray<T> {
    private T[] array;

    public GenericArray(int size) {
        array = (T[]) new Object[size];  // ⚠️ 경고 억제
    }

    public T get(int index) { return array[index]; }
    public void set(int index, T value) { array[index] = value; }
}

// 주의: 배열 자체를 외부에 노출하면 ClassCastException 가능
```

**우회 방법 3: Class 객체 + Array.newInstance()**
```java
public class GenericArray<T> {
    private T[] array;

    @SuppressWarnings("unchecked")
    public GenericArray(Class<T> type, int size) {
        array = (T[]) Array.newInstance(type, size);  // ✅ 안전
    }
}

// 사용
GenericArray<String> array = new GenericArray<>(String.class, 10);
```

---

#### Q10. 제네릭의 브리지 메서드(Bridge Method)가 무엇이고 왜 필요한가요?

**모범 답변:**
브리지 메서드는 타입 소거 후에도 **다형성을 유지**하기 위해 컴파일러가 자동으로 생성하는 메서드입니다.

**예시:**
```java
// 제네릭 인터페이스
interface Comparable<T> {
    int compareTo(T other);
}

// 구현 클래스
class MyString implements Comparable<MyString> {
    private String value;

    @Override
    public int compareTo(MyString other) {  // (1) 실제 메서드
        return this.value.compareTo(other.value);
    }

    // 컴파일러가 자동 생성하는 브리지 메서드
    public int compareTo(Object other) {  // (2) 브리지 메서드
        return compareTo((MyString) other);  // (1)을 호출
    }
}
```

**타입 소거 후:**
```java
// 인터페이스
interface Comparable {
    int compareTo(Object other);  // T → Object
}

// 구현 클래스가 compareTo(MyString)만 가지면 인터페이스 위배!
// → 브리지 메서드 compareTo(Object)가 필요
```

**브리지 메서드가 필요한 이유:**
1. **메서드 시그니처 일치**: 타입 소거 후 인터페이스 메서드와 시그니처가 달라지는 문제 해결
2. **다형성 유지**: 런타임에 올바른 메서드 호출 보장

**실제 사례:**
```java
Comparable<MyString> c = new MyString();
c.compareTo(new MyString());  // 컴파일 타임: compareTo(MyString)
                              // 런타임: compareTo(Object) → 브리지 → compareTo(MyString)
```

**확인 방법:**
```java
// 리플렉션으로 브리지 메서드 확인
for (Method method : MyString.class.getDeclaredMethods()) {
    if (method.isBridge()) {
        System.out.println("브리지 메서드: " + method);
    }
}
```

---

#### Q11. 제네릭의 재귀적 타입 바운드(Recursive Type Bound)를 설명해주세요.

**모범 답변:**
재귀적 타입 바운드는 **타입 파라미터가 자기 자신을 포함하는 제약**을 말합니다.

**가장 유명한 예: Comparable**
```java
// 재귀적 타입 바운드
public interface Comparable<T extends Comparable<T>> {
    int compareTo(T other);
}

// 해석: "T는 Comparable<T>를 구현해야 한다"
// → "자기 자신과 비교 가능한 타입"
```

**올바른 구현:**
```java
class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {  // Person끼리만 비교
        return Integer.compare(this.age, other.age);
    }
}

// 제네릭 메서드에서 사용
public static <T extends Comparable<T>> T max(T a, T b) {
    return a.compareTo(b) > 0 ? a : b;
}

Person p1 = new Person("Alice", 30);
Person p2 = new Person("Bob", 25);
Person older = max(p1, p2);  // ✅ 타입 안전하게 비교
```

**잘못된 구현 방지:**
```java
// ❌ 재귀적 바운드 위반
class BadPerson implements Comparable<String> {  // Person이 아닌 String과 비교?
    @Override
    public int compareTo(String other) {  // 이상한 비교!
        return 0;
    }
}

// 재귀적 바운드가 이를 방지
// <T extends Comparable<T>>에서 T = BadPerson, Comparable<String> 불일치
```

**실무 사용 예시:**
```java
// Enum의 정의
public abstract class Enum<E extends Enum<E>> implements Comparable<E> {
    // E는 자기 자신(Enum)의 하위 타입이어야 함
}

// Builder 패턴
abstract class Builder<T extends Builder<T>> {
    protected abstract T self();  // 자기 자신 반환

    public T withName(String name) {
        // ...
        return self();  // 메서드 체이닝
    }
}
```

---

#### Q12. 제네릭과 가변인자(Varargs)를 함께 사용할 때 주의할 점은?

**모범 답변:**
제네릭 가변인자는 **힙 오염(Heap Pollution)** 위험이 있어 `@SafeVarargs` 어노테이션이 필요합니다.

**문제 코드:**
```java
// ⚠️ 컴파일 경고: "Possible heap pollution"
public static <T> void addToList(List<T>... lists) {  // 제네릭 가변인자
    Object[] array = lists;  // 가변인자는 배열로 변환됨
    List<String> strings = Arrays.asList("A", "B");
    array[0] = strings;  // 타입 안전성 위반 가능!
}

// 사용
List<Integer> ints1 = new ArrayList<>();
List<Integer> ints2 = new ArrayList<>();
addToList(ints1, ints2);
```

**힙 오염(Heap Pollution):**
```java
// 가변인자 → 배열 변환
List<String>... stringLists → List<String>[] (내부적으로 배열)

// 타입 소거 후
List[] stringLists  // 제네릭 정보 상실!

// 문제 발생 가능
Object[] array = stringLists;
array[0] = new ArrayList<Integer>();  // ❌ List<String>에 List<Integer> 대입!
```

**해결 방법: @SafeVarargs**
```java
@SafeVarargs  // "이 메서드는 힙 오염을 일으키지 않음"을 보증
public static <T> void addToList(List<T>... lists) {
    for (List<T> list : lists) {
        list.add(null);  // 안전한 사용
    }
}

// 또는 final 메서드에만 사용
@SafeVarargs
public static final <T> void safePrint(T... elements) {
    for (T element : elements) {
        System.out.println(element);
    }
}
```

**안전한 사용 조건:**
1. 가변인자 배열에 저장하지 않음
2. 가변인자 배열을 외부에 노출하지 않음
3. 가변인자 배열을 신뢰할 수 없는 코드에 전달하지 않음

**실무 예시:**
```java
// ✅ 안전한 사용
@SafeVarargs
public static <T> List<T> asList(T... elements) {
    List<T> list = new ArrayList<>();
    for (T element : elements) {
        list.add(element);  // 배열 요소를 읽기만 함
    }
    return list;
}

// ❌ 위험한 사용
public static <T> T[] toArray(T... elements) {
    return elements;  // 가변인자 배열을 그대로 반환 → 위험!
}
```

---

## 🎯 Part 3 핵심 요약

### 실전 프로젝트 핵심
1. **제네릭 규칙 엔진**: `ValidationRule<T>`, `TransformationRule<S, T>`, `FilterRule<T>`
2. **함수형 인터페이스**: `@FunctionalInterface`로 람다 표현식 활용
3. **메서드 체이닝**: `and()`, `andThen()`, `or()`로 규칙 조합
4. **PECS 원칙**: Producer-Extends, Consumer-Super

### 면접 대비 핵심 키워드
- **타입 안전성** (Type Safety)
- **타입 소거** (Type Erasure)
- **공변성/반공변성** (Covariance/Contravariance)
- **와일드카드** (`?`, `? extends`, `? super`)
- **브리지 메서드** (Bridge Method)
- **재귀적 타입 바운드** (Recursive Type Bound)
- **힙 오염** (Heap Pollution)

### 실무 적용 체크리스트
- ✅ Raw Type 사용 금지
- ✅ 제네릭 배열 대신 `ArrayList` 사용
- ✅ PECS 원칙으로 와일드카드 선택
- ✅ `@SafeVarargs`로 가변인자 안전성 보장
- ✅ `Class<T>` 또는 `Supplier<T>`로 객체 생성

---

**24장 제네릭 완료!** 🎉

다음 25장에서는 제네릭을 활용하는 **컬렉션 프레임워크**를 다룹니다!
