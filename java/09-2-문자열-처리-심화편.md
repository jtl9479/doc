# 09-2장: 문자열 처리 (심화편)

> **이전 내용 요약**: 09-1장에서는 String 클래스의 기본 개념, 불변성, 주요 메서드, StringBuilder 사용법, 실무 사례, 실전 프로젝트를 다뤘습니다.

> **이번 장의 목표**: FAQ, 면접 질문, 핵심 정리를 통해 문자열 처리에 대한 완벽한 이해를 달성합니다.

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [FAQ (자주 묻는 질문)](#-faq)
- [면접 질문 리스트](#-면접-질문-리스트)
- [핵심 정리](#-핵심-정리)
- [관련 기술](#-관련-기술)
- [다음 단계](#-다음-단계)
- [추가 학습 자료](#-추가-학습-자료)

---

## ❓ FAQ

<details>
<summary><strong>Q1: String은 왜 불변(Immutable)인가요?</strong></summary>

**A**: **보안, 성능, Thread-safe**를 위해 불변으로 설계되었습니다.

**상세 설명**:

**1. 보안(Security)**
```java
// 보안 관련 시나리오
String password = "admin123";
authenticateUser(password);

// 만약 String이 가변이라면?
// 다른 곳에서 password 값을 변경할 수 있음!
// password.value[0] = 'x';  // "xdmin123"으로 변경
// → 보안 취약점 발생!

// String이 불변이므로 이런 공격 불가능
```

**2. String Pool (성능)**
```java
String s1 = "Hello";
String s2 = "Hello";  // s1과 같은 객체 재사용!

// 불변이기 때문에 안전하게 공유 가능
// 가변이라면 s1을 변경할 때 s2도 영향받음
```

**3. Thread-Safe (동시성)**
```java
// 멀티스레드 환경
String shared = "공유 데이터";

// 스레드 A
new Thread(() -> {
    System.out.println(shared);  // 안전!
}).start();

// 스레드 B
new Thread(() -> {
    System.out.println(shared);  // 안전!
}).start();

// 불변이므로 동기화(synchronized) 불필요
```

**4. hashCode 캐싱 (성능)**
```java
public final class String {
    private int hash;  // hashCode 캐싱

    public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            h = calculateHashCode();
            hash = h;  // 한 번만 계산하고 캐싱
        }
        return h;
    }
}

// HashMap에서 String 키 사용 시 성능 향상
Map<String, User> users = new HashMap<>();
users.put("admin", user);  // hashCode 한 번만 계산
```

**실무 팁**:
💡 String이 불변이라서 비밀번호 보안에 취약할 수 있습니다. 민감 정보는 `char[]`을 사용하세요.

```java
// ❌ 보안에 취약
String password = "admin123";  // 메모리에 계속 남아있음

// ✅ 더 안전
char[] password = {'a', 'd', 'm', 'i', 'n'};
// 사용 후
Arrays.fill(password, '0');  // 즉시 지우기 가능
```

</details>

<details>
<summary><strong>Q2: String, StringBuilder, StringBuffer의 차이는 무엇인가요?</strong></summary>

**A**: **불변성과 Thread-safe 여부**가 다릅니다.

| 특징 | String | StringBuilder | StringBuffer |
|------|--------|--------------|--------------|
| 불변성 | 불변(Immutable) | 가변(Mutable) | 가변(Mutable) |
| Thread-safe | Yes | No | Yes (synchronized) |
| 성능 | 느림 (연결 시) | 빠름 | 중간 (동기화 비용) |
| 사용 시기 | 변경 없음 | 단일 스레드 | 멀티 스레드 |
| 메모리 | 많이 사용 | 적게 사용 | 적게 사용 |

**성능 비교 (10,000번 연결)**:
```java
// String: 5,230ms
String s = "";
for (int i = 0; i < 10000; i++) {
    s += i;  // 매번 새 객체 생성
}

// StringBuilder: 2ms (2600배 빠름!)
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);  // 같은 객체에 추가
}

// StringBuffer: 5ms (동기화 비용)
StringBuffer sbf = new StringBuffer();
for (int i = 0; i < 10000; i++) {
    sbf.append(i);
}
```

**사용 가이드**:
```java
// 1. String: 변경이 없을 때
String name = "김철수";  // 변경 안 함
String email = "user@example.com";  // 변경 안 함

// 2. StringBuilder: 단일 스레드에서 문자열 조립
void generateReport() {
    StringBuilder report = new StringBuilder();
    report.append("이름: ").append(name).append("\n");
    report.append("이메일: ").append(email).append("\n");
    return report.toString();
}

// 3. StringBuffer: 멀티 스레드 환경
class SharedLogger {
    private StringBuffer log = new StringBuffer();

    public synchronized void addLog(String message) {
        log.append(message).append("\n");  // Thread-safe
    }
}
```

**실무 팁**:
💡 대부분의 경우 **StringBuilder**를 사용하세요. StringBuffer는 거의 사용하지 않습니다 (Spring 등 프레임워크가 동기화 처리).

</details>

<details>
<summary><strong>Q3: intern() 메서드는 언제 사용하나요?</strong></summary>

**A**: **동일한 문자열을 여러 번 생성할 때 메모리 절약**을 위해 사용합니다.

**동작 원리**:
```java
String s1 = new String("Hello");  // Heap에 생성
String s2 = new String("Hello");  // Heap에 또 생성

System.out.println(s1 == s2);  // false (다른 객체)

// intern() 사용
String s3 = s1.intern();  // String Pool에 추가/조회
String s4 = s2.intern();  // String Pool에서 기존 것 반환

System.out.println(s3 == s4);  // true (같은 Pool 객체)
```

**메모리 구조**:
```
[Before intern()]
Heap
├─ new String("Hello") ← s1
└─ new String("Hello") ← s2
(메모리 낭비!)

[After intern()]
String Pool
└─ "Hello" ← s3, s4 (공유)

Heap
├─ new String("Hello") (참조 없음, GC 대상)
└─ new String("Hello") (참조 없음, GC 대상)
```

**실무 사례 - 대량 데이터 중복 제거**:
```java
// CSV 파일에서 10만 건의 도시 이름 읽기
// 실제로는 100개 도시만 반복됨

// ❌ intern() 없이
List<String> cities = new ArrayList<>();
for (String line : csvLines) {
    cities.add(new String(line));  // 10만 개 객체 생성!
}
// 메모리: 10만 개 * 20byte = 2MB

// ✅ intern() 사용
List<String> cities = new ArrayList<>();
for (String line : csvLines) {
    cities.add(line.intern());  // 100개 객체만 생성!
}
// 메모리: 100개 * 20byte = 2KB (1000배 절감!)
```

**주의사항**:
```java
// ⚠️ 주의: 너무 많은 고유 문자열에 intern() 사용 시
// String Pool이 계속 커져서 OutOfMemoryError 발생 가능

// ❌ 나쁜 예: 모든 문자열에 intern()
for (int i = 0; i < 1000000; i++) {
    String s = ("user_" + i).intern();  // Pool이 100만 개로 증가!
}

// ✅ 좋은 예: 중복이 많은 경우에만
String[] commonValues = {"서울", "부산", "대구", "인천"};
// 이런 값들에만 intern() 사용
```

**실무 팁**:
💡 `intern()`은 신중하게 사용하세요. 중복이 많은 경우에만 효과적입니다.

</details>

<details>
<summary><strong>Q4: substring()은 메모리 누수를 일으키나요?</strong></summary>

**A**: **Java 7 이후로는 안전**합니다. Java 6에서는 메모리 누수가 있었습니다.

**Java 6 (문제)**:
```java
// Java 6에서 substring() 내부 구현
public String substring(int beginIndex, int endIndex) {
    return new String(value, beginIndex, endIndex - beginIndex);
    // value 배열을 원본과 공유! (메모리 누수)
}

// 문제 발생 시나리오
String huge = "100MB 크기의 거대한 문자열...";
String small = huge.substring(0, 10);  // 10글자만 필요

// small이 여전히 100MB 배열 전체를 참조!
// huge = null로 설정해도 GC가 회수 못함
```

**메모리 구조 (Java 6)**:
```
[원본 문자열]
huge → char[100MB] "100MB 크기의 거대한..."

[substring 결과]
small → String {
    value: char[100MB]  ← 같은 배열 참조!
    offset: 0
    count: 10
}

huge를 null로 설정해도
small이 여전히 100MB 배열 참조
→ 메모리 누수!
```

**Java 7 이후 (해결)**:
```java
// Java 7 이후 substring() 구현
public String substring(int beginIndex, int endIndex) {
    int subLen = endIndex - beginIndex;
    return new String(value, beginIndex, subLen);
    // 새로운 배열에 복사! (안전)
}

String huge = "100MB 크기의 거대한 문자열...";
String small = huge.substring(0, 10);
huge = null;  // 이제 GC가 회수 가능!
```

**메모리 구조 (Java 7+)**:
```
[원본 문자열]
huge → char[100MB] "100MB 크기의..."

[substring 결과]
small → String {
    value: char[10]  ← 필요한 부분만 복사!
    "100MB 크기"
}

huge = null 설정 시
char[100MB]는 GC에 의해 회수됨
→ 메모리 안전!
```

**실무 팁**:
💡 Java 7+ 사용 중이라면 `substring()`을 안심하고 사용하세요.

</details>

<details>
<summary><strong>Q5: 문자열 연결 시 + 연산자를 쓰면 항상 느린가요?</strong></summary>

**A**: **컴파일러 최적화** 덕분에 간단한 경우는 빠릅니다.

**컴파일러 최적화 (상수)**:
```java
// 컴파일 시점에 하나로 합쳐짐
String s = "Hello" + " " + "World";  // 빠름!

// 컴파일러가 자동으로 변환:
String s = "Hello World";  // 하나의 String 리터럴
```

**컴파일러 최적화 (변수 - Java 5+)**:
```java
// 단순 연결
String name = "김철수";
String greeting = "안녕하세요, " + name + "님";

// 컴파일러가 자동으로 StringBuilder 사용:
String greeting = new StringBuilder()
    .append("안녕하세요, ")
    .append(name)
    .append("님")
    .toString();
```

**최적화 안 되는 경우 (반복문)**:
```java
// ❌ 반복문: 최적화 안 됨!
String result = "";
for (int i = 0; i < 1000; i++) {
    result = result + i;  // 매번 새 StringBuilder 생성!
}

// 컴파일러 변환 (비효율):
for (int i = 0; i < 1000; i++) {
    result = new StringBuilder(result).append(i).toString();
    // 1000번의 StringBuilder 생성!
}

// ✅ 직접 StringBuilder 사용
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);  // 하나의 StringBuilder
}
String result = sb.toString();
```

**성능 비교**:
```java
// 1. 상수 연결: 매우 빠름
String s1 = "A" + "B" + "C";  // 컴파일 타임에 "ABC"

// 2. 변수 3개 이하: 빠름
String a = "A", b = "B", c = "C";
String s2 = a + b + c;  // StringBuilder 자동 사용

// 3. 반복 연결 (100번): 느림
String s3 = "";
for (int i = 0; i < 100; i++) {
    s3 += i;  // 100개의 StringBuilder 생성
}

// 4. StringBuilder (100번): 빠름
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100; i++) {
    sb.append(i);  // 하나의 StringBuilder
}
```

**가이드라인**:
```java
// ✅ + 연산자 사용 OK
String simple = "Hello " + name + "!";
String email = user.getName() + "@" + domain;

// ✅ StringBuilder 사용 권장
// - 반복문
// - 조건문 안에서
// - 많은 연결 (5개 이상)
StringBuilder complex = new StringBuilder();
for (Data data : dataList) {
    complex.append(data.toString()).append(",");
}
```

**실무 팁**:
💡 3개 이하 연결은 `+` 사용, 반복문이나 많은 연결은 `StringBuilder` 사용

</details>

<details>
<summary><strong>Q6: null과 빈 문자열("")의 차이는 무엇인가요?</strong></summary>

**A**: **null은 참조 없음, 빈 문자열은 길이 0인 String 객체**입니다.

**차이점**:
```java
String s1 = null;     // 참조 없음 (객체 자체가 없음)
String s2 = "";       // 빈 문자열 객체 (길이 0)

// 메모리 구조
// s1 → null (주소 없음)
// s2 → String { value: char[0] }
```

**주요 차이**:
```java
// 1. 메서드 호출
String s1 = null;
String s2 = "";

s1.length();  // ❌ NullPointerException!
s2.length();  // ✅ 0

s1.equals("test");  // ❌ NullPointerException!
s2.equals("test");  // ✅ false

// 2. 비교
s1 == null;   // true
s2 == null;   // false

s1.isEmpty();  // ❌ NullPointerException!
s2.isEmpty();  // ✅ true

// 3. 문자열 연결
String result1 = s1 + "test";  // "nulltest" (문자열 "null")
String result2 = s2 + "test";  // "test"
```

**실무 처리 방법**:
```java
// ❌ 나쁜 예: null 체크 누락
public String getUserName(String name) {
    return name.trim();  // name이 null이면 에러!
}

// ✅ 좋은 예 1: null 체크
public String getUserName(String name) {
    if (name == null || name.isEmpty()) {
        return "Unknown";
    }
    return name.trim();
}

// ✅ 좋은 예 2: Java 11+ isBlank()
public String getUserName(String name) {
    if (name == null || name.isBlank()) {  // 공백 문자도 체크
        return "Unknown";
    }
    return name.trim();
}

// ✅ 좋은 예 3: Apache Commons
import org.apache.commons.lang3.StringUtils;

public String getUserName(String name) {
    if (StringUtils.isBlank(name)) {  // null, "", "  " 모두 체크
        return "Unknown";
    }
    return name.trim();
}
```

**유틸리티 메서드**:
```java
public class StringUtil {
    // null 또는 빈 문자열 체크
    public static boolean isNullOrEmpty(String str) {
        return str == null || str.isEmpty();
    }

    // null, 빈 문자열, 공백 체크
    public static boolean isNullOrBlank(String str) {
        return str == null || str.trim().isEmpty();
    }

    // 안전한 trim
    public static String safeTrim(String str) {
        return str == null ? "" : str.trim();
    }

    // 기본값 처리
    public static String defaultIfEmpty(String str, String defaultValue) {
        return isNullOrEmpty(str) ? defaultValue : str;
    }
}
```

**실무 팁**:
💡 항상 **null 체크를 먼저** 수행하세요. `str != null && str.isEmpty()` 순서가 중요합니다.

</details>

<details>
<summary><strong>Q7: 문자열을 숫자로, 숫자를 문자열로 변환하는 방법은?</strong></summary>

**A**: **valueOf(), parseInt(), toString()** 등을 사용합니다.

**문자열 → 숫자**:
```java
// 1. Integer.parseInt() - int 반환
String str1 = "123";
int num1 = Integer.parseInt(str1);  // 123

// 2. Integer.valueOf() - Integer 객체 반환
String str2 = "456";
Integer num2 = Integer.valueOf(str2);  // 456 (Integer 객체)

// 3. Double, Long 등도 동일
String str3 = "3.14";
double num3 = Double.parseDouble(str3);  // 3.14

String str4 = "9876543210";
long num4 = Long.parseLong(str4);  // 9876543210L

// 4. 에러 처리
try {
    int num = Integer.parseInt("abc");  // NumberFormatException!
} catch (NumberFormatException e) {
    System.out.println("숫자가 아닙니다: " + e.getMessage());
}
```

**숫자 → 문자열**:
```java
// 1. String.valueOf() - 권장
int num1 = 123;
String str1 = String.valueOf(num1);  // "123"

// 2. Integer.toString()
int num2 = 456;
String str2 = Integer.toString(num2);  // "456"

// 3. 문자열 연결 (간단하지만 비효율적)
int num3 = 789;
String str3 = "" + num3;  // "789"
String str4 = num3 + "";  // "789"

// 4. 다양한 타입
double d = 3.14;
String str5 = String.valueOf(d);  // "3.14"

boolean b = true;
String str6 = String.valueOf(b);  // "true"
```

**포맷팅 변환**:
```java
// 1. String.format() - printf 스타일
int num = 42;
String formatted1 = String.format("숫자: %d", num);  // "숫자: 42"
String formatted2 = String.format("소수점: %.2f", 3.14159);  // "소수점: 3.14"

// 2. DecimalFormat - 숫자 포맷팅
import java.text.DecimalFormat;

DecimalFormat df = new DecimalFormat("#,###");
String formatted3 = df.format(1234567);  // "1,234,567"

DecimalFormat df2 = new DecimalFormat("0.00");
String formatted4 = df2.format(3.1);  // "3.10"

// 3. 진법 변환
int num10 = 255;
String binary = Integer.toBinaryString(num10);  // "11111111"
String hex = Integer.toHexString(num10);        // "ff"
String octal = Integer.toOctalString(num10);    // "377"

// 역변환
int fromBinary = Integer.parseInt("11111111", 2);  // 255
int fromHex = Integer.parseInt("ff", 16);          // 255
```

**실무 예제 - 금액 처리**:
```java
public class MoneyFormatter {
    // 숫자를 한국 원화 포맷으로
    public static String formatMoney(long amount) {
        DecimalFormat df = new DecimalFormat("#,###원");
        return df.format(amount);
    }

    // 문자열을 숫자로 (쉼표 제거)
    public static long parseMoney(String moneyStr) {
        // "1,234,567원" → 1234567
        String cleaned = moneyStr
            .replace(",", "")
            .replace("원", "")
            .trim();
        return Long.parseLong(cleaned);
    }

    public static void main(String[] args) {
        long amount = 1234567;
        String formatted = formatMoney(amount);
        System.out.println(formatted);  // "1,234,567원"

        long parsed = parseMoney(formatted);
        System.out.println(parsed);  // 1234567
    }
}
```

**실무 팁**:
💡 **숫자 → 문자열**: `String.valueOf()` 사용
💡 **문자열 → 숫자**: `Integer.parseInt()` + try-catch

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. String을 ==로 비교하면 안 되는 이유를 설명해주세요</strong></summary>

**모범 답안 포인트**
- `==`는 주소 비교 (참조 비교)
- `equals()`는 내용 비교
- String Pool과 new String()의 차이

**예시 답변**
> "Java에서 `==` 연산자는 객체의 주소를 비교합니다. 문자열의 내용이 같더라도 서로 다른 객체라면 false를 반환합니다.
>
> 예를 들어, `new String("Hello")`로 생성하면 Heap에 새로운 객체가 만들어지므로, 같은 문자열을 담고 있어도 주소가 다릅니다.
>
> 반면 `equals()` 메서드는 실제 문자열의 내용을 비교하므로, 문자열 비교에는 항상 `equals()`를 사용해야 합니다."

**꼬리 질문**
- Q: String Pool은 무엇인가요?
- A: "String Pool은 같은 문자열 리터럴을 재사용하기 위한 특별한 메모리 영역입니다. `\"Hello\"`처럼 리터럴로 생성하면 Pool에 저장되고, 같은 리터럴을 다시 사용하면 새로 만들지 않고 기존 것을 재사용합니다."

**실무 연관**
- 로그인 기능에서 비밀번호 비교 시 `==` 사용하면 항상 실패
- 검색 기능에서 키워드 비교 시 잘못된 결과 발생
- 실무에서 가장 흔한 실수 중 하나

</details>

<details>
<summary><strong>2. String이 불변(Immutable)인 이유는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 보안 (비밀번호, 파일 경로 변조 방지)
- String Pool (메모리 절약)
- Thread-safe (동기화 불필요)
- hashCode 캐싱 (HashMap 성능)

**예시 답변**
> "String이 불변인 이유는 크게 네 가지입니다.
>
> 첫째, 보안을 위해서입니다. 비밀번호나 파일 경로 같은 중요한 정보가 임의로 변경되는 것을 방지합니다.
>
> 둘째, String Pool을 통한 메모리 절약입니다. 불변이기 때문에 같은 문자열을 안전하게 공유할 수 있습니다.
>
> 셋째, Thread-safe합니다. 여러 스레드가 동시에 접근해도 값이 변하지 않으므로 동기화가 필요 없습니다.
>
> 넷째, hashCode를 캐싱할 수 있어 HashMap 등에서 성능이 향상됩니다."

**실무 예시**
```java
// 보안: 파일 경로 변조 방지
void loadFile(String path) {
    // path가 가변이라면 중간에 누가 변경할 수 있음
    // 불변이므로 안전
    File file = new File(path);
}

// String Pool: 메모리 절약
String s1 = "Hello";
String s2 = "Hello";  // 같은 객체 재사용
```

**꼬리 질문**
- Q: 불변의 단점은 무엇인가요?
- A: "문자열을 변경할 때마다 새로운 객체를 생성해야 하므로, 빈번한 변경이 필요한 경우 메모리와 성능에 비효율적입니다. 이런 경우 StringBuilder를 사용해야 합니다."

**실무 연관**
- Spring Security에서 비밀번호 처리
- 설정 파일 경로 관리
- API 토큰 관리

</details>

<details>
<summary><strong>3. StringBuilder와 StringBuffer의 차이를 설명해주세요</strong></summary>

**모범 답안 포인트**
- Thread-safe 여부
- 성능 차이
- 사용 시나리오

**예시 답변**
> "StringBuilder와 StringBuffer의 주요 차이는 Thread-safe 여부입니다.
>
> StringBuffer는 모든 메서드가 synchronized로 동기화되어 있어 멀티스레드 환경에서 안전하지만, 동기화 비용으로 인해 상대적으로 느립니다.
>
> StringBuilder는 동기화되지 않아서 빠르지만, 멀티스레드 환경에서는 안전하지 않습니다.
>
> 실무에서는 대부분 단일 스레드 환경(메서드 내부)에서 사용하므로 StringBuilder를 주로 사용합니다."

**성능 비교**
```java
// 10,000번 연결 기준
// StringBuilder: 2ms
// StringBuffer: 5ms (동기화 비용)
// String +: 5,230ms
```

**실무 사례**
```java
// ✅ 일반적 사용: StringBuilder
public String generateReport() {
    StringBuilder report = new StringBuilder();
    report.append("제목: ").append(title).append("\n");
    report.append("내용: ").append(content);
    return report.toString();
}

// ✅ 멀티스레드: StringBuffer
class Logger {
    private StringBuffer logs = new StringBuffer();

    public void log(String message) {
        // 여러 스레드가 동시 호출
        logs.append(message).append("\n");
    }
}
```

**꼬리 질문**
- Q: 언제 StringBuilder를 사용해야 하나요?
- A: "반복문에서 문자열을 연결하거나, 많은 문자열을 조합할 때 사용합니다. 일반적으로 5개 이상의 문자열을 연결하거나 반복문 안에서 연결할 때 StringBuilder를 권장합니다."

**실무 연관**
- CSV, JSON 생성 시 StringBuilder
- 로그 수집 시 StringBuffer (멀티스레드)
- 대부분의 경우 StringBuilder로 충분

</details>

<details>
<summary><strong>4. substring() 메서드의 동작 원리를 설명해주세요</strong></summary>

**모범 답안 포인트**
- 시작 인덱스, 끝 인덱스 (끝 인덱스는 포함 안 됨)
- 새로운 String 객체 생성
- Java 6와 Java 7+ 차이

**예시 답변**
> "`substring(int beginIndex, int endIndex)`는 문자열의 일부를 추출하여 새로운 String 객체로 반환합니다.
>
> beginIndex는 포함되고, endIndex는 포함되지 않습니다. 예를 들어 `\"Hello\".substring(0, 3)`은 `\"Hel\"`을 반환합니다.
>
> Java 7 이후부터는 필요한 부분만 새로운 char 배열로 복사하여 반환하므로 메모리 누수 위험이 없습니다."

**예시 코드**
```java
String text = "Hello World";

// 인덱스 6부터 11 전까지
String sub1 = text.substring(6, 11);  // "World"

// 인덱스 6부터 끝까지
String sub2 = text.substring(6);  // "World"

// 처음부터 인덱스 5 전까지
String sub3 = text.substring(0, 5);  // "Hello"
```

**실무 예시**
```java
// 파일 확장자 추출
String fileName = "document.pdf";
int dotIndex = fileName.lastIndexOf(".");
String extension = fileName.substring(dotIndex + 1);  // "pdf"

// 이메일 도메인 추출
String email = "user@example.com";
int atIndex = email.indexOf("@");
String domain = email.substring(atIndex + 1);  // "example.com"
```

**꼬리 질문**
- Q: substring()으로 원본 문자열이 변경되나요?
- A: "아니요. String은 불변이므로 substring()은 항상 새로운 String 객체를 반환하고, 원본은 변경되지 않습니다."

**실무 연관**
- URL 파싱
- 파일명 처리
- 문자열 데이터 추출

</details>

<details>
<summary><strong>5. null 체크를 어떻게 해야 하나요?</strong></summary>

**모범 답안 포인트**
- null 먼저 체크
- isEmpty() vs isBlank()
- Optional 사용 (Java 8+)

**예시 답변**
> "문자열 null 체크는 항상 null을 먼저 확인해야 합니다.
>
> `if (str != null && !str.isEmpty())`처럼 null 체크를 먼저 하면, null일 때 뒤의 메서드가 호출되지 않아 NullPointerException을 방지할 수 있습니다.
>
> Java 11부터는 `isBlank()` 메서드로 null, 빈 문자열, 공백 문자를 한 번에 체크할 수 있으며, Java 8 이상에서는 Optional을 활용할 수도 있습니다."

**다양한 방법**
```java
// 1. 기본 null 체크
if (str != null && !str.isEmpty()) {
    // str 사용
}

// 2. Java 11+ isBlank()
if (str != null && !str.isBlank()) {
    // str 사용 (공백도 체크)
}

// 3. 상수를 앞에 (NullPointerException 방지)
if ("admin".equals(str)) {  // str이 null이어도 안전
    // ...
}

// 4. Optional 사용
Optional.ofNullable(str)
    .filter(s -> !s.isEmpty())
    .ifPresent(s -> System.out.println(s));

// 5. Apache Commons
if (StringUtils.isNotBlank(str)) {
    // null, "", "  " 모두 체크
}
```

**실무 예시**
```java
// ✅ 안전한 trim
public String safeTrim(String str) {
    return str == null ? "" : str.trim();
}

// ✅ 기본값 처리
public String getOrDefault(String str, String defaultValue) {
    return (str != null && !str.isEmpty()) ? str : defaultValue;
}
```

**꼬리 질문**
- Q: isEmpty()와 isBlank()의 차이는?
- A: "`isEmpty()`는 길이가 0인지만 체크하고, `isBlank()`는 공백 문자(`\" \"`, `\"\\t\"`, `\"\\n\"`)도 빈 문자열로 판단합니다. `\"  \".isEmpty()`는 false지만 `\"  \".isBlank()`는 true입니다."

**실무 연관**
- 사용자 입력 검증
- API 파라미터 검증
- DB 데이터 처리

</details>

<details>
<summary><strong>6. String 연결 시 + 연산자와 concat(), StringBuilder 중 무엇을 사용해야 하나요?</strong></summary>

**모범 답안 포인트**
- + 연산자: 간단한 연결 (3개 이하)
- StringBuilder: 반복문, 많은 연결
- concat(): 거의 사용 안 함

**예시 답변**
> "상황에 따라 다릅니다.
>
> 간단한 연결(3개 이하)은 `+` 연산자가 가독성이 좋고, 컴파일러가 자동으로 최적화합니다.
>
> 반복문이나 조건문에서 많은 연결을 하는 경우는 StringBuilder를 직접 사용해야 합니다. 컴파일러가 반복문은 최적화하지 못하기 때문입니다.
>
> `concat()` 메서드는 + 연산자보다 느리고 가독성도 떨어져서 거의 사용하지 않습니다."

**성능 비교**
```java
// 1. + 연산자 (간단): 빠름
String result = "Hello " + name + "!";

// 2. concat(): 느림 (비권장)
String result = "Hello ".concat(name).concat("!");

// 3. StringBuilder (많은 연결): 빠름
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);
}
```

**실무 가이드**
```java
// ✅ 간단한 연결: + 사용
String greeting = "안녕하세요, " + name + "님";
String fullName = firstName + " " + lastName;

// ✅ 반복 연결: StringBuilder
StringBuilder csv = new StringBuilder();
for (String item : items) {
    csv.append(item).append(",");
}

// ✅ 조건부 연결: StringBuilder
StringBuilder query = new StringBuilder("SELECT * FROM users");
if (name != null) {
    query.append(" WHERE name = '").append(name).append("'");
}
```

**꼬리 질문**
- Q: + 연산자를 반복문에서 쓰면 왜 느린가요?
- A: "컴파일러가 반복문 안의 + 연산을 최적화하지 못해서, 매 반복마다 새로운 StringBuilder가 생성되고 toString()이 호출됩니다. 1000번 반복하면 1000개의 StringBuilder가 생성되어 매우 비효율적입니다."

**실무 연관**
- CSV 생성
- SQL 쿼리 동적 생성
- 로그 메시지 조립

</details>

<details>
<summary><strong>7. 문자열을 불변으로 만들면 성능이 떨어지지 않나요?</strong></summary>

**모범 답안 포인트**
- String Pool로 메모리 절약
- hashCode 캐싱으로 HashMap 성능 향상
- StringBuilder로 변경 작업 최적화

**예시 답변**
> "String이 불변이라서 성능이 떨어진다고 생각할 수 있지만, 실제로는 여러 최적화 기법으로 오히려 성능이 향상됩니다.
>
> 첫째, String Pool을 통해 같은 문자열을 재사용하므로 메모리를 절약합니다.
>
> 둘째, hashCode를 한 번만 계산하고 캐싱하므로 HashMap 등에서 성능이 크게 향상됩니다.
>
> 셋째, 자주 변경되는 작업은 StringBuilder를 사용하면 되므로, 불변성의 단점을 보완할 수 있습니다."

**성능 최적화 예시**
```java
// 1. String Pool - 메모리 절약
String s1 = "Hello";
String s2 = "Hello";  // 새 객체 생성 안 함

// 2. hashCode 캐싱 - HashMap 성능 향상
Map<String, User> users = new HashMap<>();
String key = "admin";
users.put(key, user);  // hashCode 한 번만 계산
users.get(key);        // 캐시된 hashCode 재사용

// 3. StringBuilder - 변경 작업 최적화
// 문자열 변경이 잦으면 StringBuilder 사용
StringBuilder mutable = new StringBuilder("Hello");
mutable.append(" World");  // 효율적
```

**꼬리 질문**
- Q: 그럼 언제 StringBuilder를 사용해야 하나요?
- A: "반복문이나 조건문에서 문자열을 자주 변경할 때 StringBuilder를 사용합니다. 간단한 연결은 String의 + 연산자를 사용해도 컴파일러가 최적화하므로 문제없습니다."

**실무 연관**
- 캐시 키로 String 사용
- HashMap/HashSet에서 String 키 사용
- 변경이 많은 경우만 StringBuilder

</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. String의 내부 구현이 Java 9부터 어떻게 변경되었나요?</strong></summary>

**모범 답안 포인트**
- Java 8 이하: char[] 사용
- Java 9 이상: byte[] + encoding flag 사용
- Compact Strings 최적화

**예시 답변**
> "Java 9부터 String의 내부 구현이 `char[]`에서 `byte[] + encoding flag`로 변경되었습니다.
>
> 이는 Compact Strings 최적화로, 대부분의 문자열이 Latin-1 (ISO-8859-1) 범위의 문자만 사용한다는 점에 착안했습니다.
>
> Latin-1 문자는 1바이트로 표현 가능하므로, char(2바이트) 대신 byte(1바이트)를 사용하여 메모리를 50% 절약합니다.
>
> UTF-16 문자가 필요한 경우에만 2바이트를 사용하며, coder 플래그로 어떤 인코딩을 사용할지 구분합니다."

**내부 구조 변화**
```java
// Java 8
public final class String {
    private final char[] value;  // 모든 문자 2바이트
}
// "Hello" → char[5] = 10 bytes

// Java 9+
public final class String {
    private final byte[] value;  // 1 또는 2바이트
    private final byte coder;    // LATIN1 or UTF16
}
// "Hello" → byte[5] = 5 bytes (50% 절약!)
// "한글" → byte[6] = 6 bytes (UTF-16)
```

**성능 영향**
```java
// 메모리 절약
String latin = "Hello World";  // 11bytes (기존 22bytes)
String korean = "안녕하세요";    // 15bytes (UTF-16)

// GC 부담 감소
// 힙 메모리 사용량 30% 이상 감소 (실제 서버 워크로드 기준)
```

**실무 예시**
```java
// 로그, API 응답 등 대부분 영문
String apiResponse = "{\"status\":\"success\"}";  // 메모리 50% 절감

// 한글 데이터는 여전히 UTF-16
String userMessage = "주문이 완료되었습니다";
```

**꼬리 질문**
- Q: 왜 모든 문자를 UTF-8로 저장하지 않나요?
- A: "Java 내부에서는 문자열 처리 속도를 위해 UTF-16을 기본으로 사용하고, Latin-1로 표현 가능한 경우만 1바이트로 압축합니다. UTF-8은 가변 길이라서 랜덤 액세스(charAt 등)가 느려지기 때문입니다."

**실무 연관**
- Java 9+ 사용 시 자동으로 메모리 절약
- 특별한 코드 변경 없이 성능 향상
- 영문 위주 서비스에서 큰 효과

</details>

<details>
<summary><strong>2. String.intern()의 내부 동작과 성능 영향을 설명해주세요</strong></summary>

**모범 답안 포인트**
- String Pool에 추가/조회
- 동일 문자열 재사용으로 메모리 절약
- 과도한 사용 시 OutOfMemoryError 위험

**예시 답변**
> "`intern()` 메서드는 문자열을 String Pool에 등록하고, Pool에 이미 같은 문자열이 있으면 그것을 반환합니다.
>
> 이를 통해 동일한 문자열을 여러 번 생성할 때 메모리를 절약할 수 있습니다. 예를 들어 CSV 파일에서 같은 도시 이름이 10만 번 반복되면, intern()을 사용해 1개의 String만 유지할 수 있습니다.
>
> 하지만 너무 많은 고유 문자열에 intern()을 사용하면 String Pool이 계속 커져서 OutOfMemoryError가 발생할 수 있으므로 주의해야 합니다."

**동작 원리**
```java
String s1 = new String("Hello");  // Heap에 생성
String s2 = s1.intern();  // String Pool 확인
// Pool에 "Hello" 없으면 추가, 있으면 기존 것 반환

String s3 = "Hello";  // Pool의 "Hello"
System.out.println(s2 == s3);  // true (같은 Pool 객체)
```

**메모리 절약 예시**
```java
// 중복이 많은 데이터
List<String> cities = new ArrayList<>();
for (int i = 0; i < 100000; i++) {
    String city = getCity();  // "서울", "부산" 등 100개 도시 반복
    cities.add(city.intern());  // 100개 String만 유지
}
// 메모리: 100MB → 1MB (99% 절약!)
```

**위험한 사용**
```java
// ❌ OutOfMemoryError 위험
for (int i = 0; i < 10000000; i++) {
    String s = ("user_" + i).intern();  // Pool이 1000만 개로 증가!
}
// String Pool은 GC되지 않음 (Java 7+에서는 GC 가능하지만 여전히 위험)
```

**실무 활용**
```java
// ✅ 좋은 사용: 제한된 값 집합
enum Status { ACTIVE, INACTIVE, PENDING }
String status = dbValue.intern();  // 3개 값만 재사용

// ✅ 좋은 사용: 고정된 카테고리
String category = productCategory.intern();  // 50개 카테고리 재사용
```

**꼬리 질문**
- Q: String Pool의 크기는 어떻게 조정하나요?
- A: "Java 7+에서는 `-XX:StringTableSize=N` JVM 옵션으로 String Pool의 해시 테이블 크기를 조정할 수 있습니다. 기본값은 60013이며, intern()을 많이 사용하는 경우 늘려서 충돌을 줄일 수 있습니다."

**실무 연관**
- 대량 CSV/JSON 파싱 시 메모리 최적화
- 캐시 키 관리
- Enum 대신 String 사용 시

</details>

<details>
<summary><strong>3. 문자열 처리에서 정규표현식을 사용할 때 성능 고려사항은?</strong></summary>

**모범 답안 포인트**
- Pattern.compile() 재사용
- 간단한 경우 String 메서드 사용
- 복잡한 패턴은 컴파일 비용 고려

**예시 답변**
> "정규표현식은 강력하지만 성능 비용이 큽니다. 주요 고려사항은 다음과 같습니다.
>
> 첫째, Pattern.compile()은 비용이 크므로 반복 사용 시 컴파일된 Pattern을 재사용해야 합니다.
>
> 둘째, 간단한 작업은 String의 내장 메서드(contains, startsWith 등)를 사용하는 것이 훨씬 빠릅니다.
>
> 셋째, 복잡한 패턴은 백트래킹으로 인해 지수 시간이 걸릴 수 있으므로 패턴을 최적화해야 합니다."

**성능 비교**
```java
// ❌ 나쁜 예: 매번 컴파일
for (String str : list) {
    if (str.matches("\\d+")) {  // 매번 Pattern.compile() 호출!
        // ...
    }
}

// ✅ 좋은 예: Pattern 재사용
Pattern pattern = Pattern.compile("\\d+");
Matcher matcher = pattern.matcher("");
for (String str : list) {
    matcher.reset(str);
    if (matcher.matches()) {
        // ...
    }
}

// ✅ 더 좋은 예: 간단한 경우 String 메서드
for (String str : list) {
    if (str.chars().allMatch(Character::isDigit)) {
        // 정규식보다 10배 빠름
    }
}
```

**실제 벤치마크**
```java
String text = "12345";

// String.matches() (매번 컴파일): 8000ns
text.matches("\\d+");

// Pattern 재사용: 500ns
Pattern p = Pattern.compile("\\d+");
p.matcher(text).matches();

// String 메서드: 50ns
text.chars().allMatch(Character::isDigit);
```

**실무 예시**
```java
public class EmailValidator {
    // ✅ static final로 Pattern 재사용
    private static final Pattern EMAIL_PATTERN =
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$");

    public static boolean isValid(String email) {
        if (email == null) return false;

        // 간단한 검증은 String 메서드로
        if (!email.contains("@")) return false;

        // 복잡한 검증만 정규식 사용
        return EMAIL_PATTERN.matcher(email).matches();
    }
}
```

**백트래킹 위험**
```java
// ❌ 위험: 백트래킹 폭발 (ReDOS 공격 가능)
Pattern dangerous = Pattern.compile("(a+)+b");
// "aaaaaaaaaaaaaaaaaac" 입력 시 지수 시간 소요!

// ✅ 안전: Possessive quantifier 사용
Pattern safe = Pattern.compile("(a++)+ b");
```

**꼬리 질문**
- Q: 이메일 검증에 정규식을 사용해야 하나요?
- A: "간단한 형식 체크는 정규식을 사용할 수 있지만, 완벽한 이메일 검증은 RFC 5322를 완전히 구현하는 것이 거의 불가능합니다. 실무에서는 Apache Commons Validator 같은 검증된 라이브러리를 사용하는 것이 좋습니다."

**실무 연관**
- 입력 검증 (이메일, 전화번호, URL)
- 로그 파싱
- 텍스트 처리 파이프라인

</details>

<details>
<summary><strong>4. String, CharSequence, CharBuffer의 관계와 사용 시나리오를 설명해주세요</strong></summary>

**모범 답안 포인트**
- CharSequence: 인터페이스
- String: 불변 구현체
- CharBuffer: NIO 버퍼

**예시 답변**
> "CharSequence는 문자 시퀀스를 나타내는 인터페이스이며, String, StringBuilder, CharBuffer 등이 이를 구현합니다.
>
> String은 불변 CharSequence로 일반적인 문자열 처리에 사용하고, StringBuilder는 가변 CharSequence로 문자열 조립에 사용합니다.
>
> CharBuffer는 NIO의 일부로, 대용량 문자 데이터를 효율적으로 처리할 때 사용하며, 파일 I/O나 네트워크 통신에서 메모리를 절약할 수 있습니다."

**계층 구조**
```java
interface CharSequence {
    int length();
    char charAt(int index);
    CharSequence subSequence(int start, int end);
    String toString();
}

// 구현체들
class String implements CharSequence { }
class StringBuilder implements CharSequence { }
class StringBuffer implements CharSequence { }
class CharBuffer implements CharSequence { }
```

**유연한 메서드 설계**
```java
// ✅ 좋은 설계: CharSequence로 받기
public static int countVowels(CharSequence text) {
    int count = 0;
    for (int i = 0; i < text.length(); i++) {
        char c = Character.toLowerCase(text.charAt(i));
        if ("aeiou".indexOf(c) >= 0) {
            count++;
        }
    }
    return count;
}

// String, StringBuilder, CharBuffer 모두 사용 가능
countVowels("Hello");  // String
countVowels(new StringBuilder("Hello"));  // StringBuilder
countVowels(CharBuffer.wrap("Hello"));  // CharBuffer
```

**CharBuffer 활용**
```java
// NIO 파일 읽기 (메모리 효율적)
try (FileChannel channel = FileChannel.open(path)) {
    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    channel.read(byteBuffer);
    byteBuffer.flip();

    CharBuffer charBuffer = StandardCharsets.UTF_8.decode(byteBuffer);
    // charBuffer를 직접 사용 (String 변환 없이)
    processText(charBuffer);  // CharSequence 받는 메서드
}
```

**실무 예시**
```java
public class TextProcessor {
    // CharSequence로 받아서 유연하게
    public String highlight(CharSequence text, String keyword) {
        StringBuilder result = new StringBuilder();
        String str = text.toString();
        // ... 처리 로직
        return result.toString();
    }

    // 사용
    String s = "Hello World";
    StringBuilder sb = new StringBuilder("Hello World");

    highlight(s, "Hello");   // OK
    highlight(sb, "Hello");  // OK
}
```

**꼬리 질문**
- Q: 왜 매개변수를 String 대신 CharSequence로 받나요?
- A: "CharSequence로 받으면 String, StringBuilder, CharBuffer 등 모든 구현체를 받을 수 있어 유연합니다. 특히 StringBuilder를 String으로 변환하지 않고 바로 전달할 수 있어 불필요한 객체 생성을 피할 수 있습니다."

**실무 연관**
- API 설계 시 매개변수 타입
- 대용량 파일 처리
- 네트워크 프로토콜 구현

</details>

<details>
<summary><strong>5. 문자열 풀(String Pool)의 메모리 위치가 Java 버전에 따라 어떻게 변했나요?</strong></summary>

**모범 답안 포인트**
- Java 6: PermGen (고정 크기)
- Java 7: Heap (GC 가능)
- Java 8: Metaspace

**예시 답변**
> "String Pool의 메모리 위치는 Java 버전에 따라 변경되었습니다.
>
> Java 6 이하에서는 PermGen 영역에 있어서 크기가 고정되어 있고, 많은 문자열을 intern()하면 OutOfMemoryError가 쉽게 발생했습니다.
>
> Java 7부터는 Heap 영역으로 이동하여 동적으로 크기가 조절되고 GC의 대상이 되었습니다. 따라서 더 이상 사용하지 않는 interned 문자열은 GC로 회수될 수 있습니다.
>
> Java 8에서는 PermGen이 완전히 제거되고 Metaspace로 대체되었지만, String Pool은 여전히 Heap에 있습니다."

**메모리 구조 변화**
```java
// Java 6
┌─────────────────┐
│   PermGen       │ ← String Pool (고정 크기, GC 안 됨)
│   - Class 메타  │
│   - String Pool │
└─────────────────┘
┌─────────────────┐
│   Heap          │
│   - 일반 객체   │
└─────────────────┘

// Java 7+
┌─────────────────┐
│   Metaspace     │
│   - Class 메타  │
└─────────────────┘
┌─────────────────┐
│   Heap          │ ← String Pool (동적, GC 가능)
│   - String Pool │
│   - 일반 객체   │
└─────────────────┘
```

**GC 동작 변화**
```java
// Java 6: PermGen에서 GC 안 됨
for (int i = 0; i < 1000000; i++) {
    String s = new String("test" + i).intern();
}
// OutOfMemoryError: PermGen space

// Java 7+: Heap에서 GC 가능
for (int i = 0; i < 1000000; i++) {
    String s = new String("test" + i).intern();
}
// s = null 시 GC로 회수 가능
```

**JVM 옵션**
```bash
# Java 6
-XX:PermSize=64m
-XX:MaxPermSize=128m

# Java 7+
-XX:StringTableSize=60013  # String Pool 해시 테이블 크기
-Xmx2g  # Heap 크기 (String Pool 포함)

# Java 8+
-XX:MetaspaceSize=128m
-XX:MaxMetaspaceSize=256m  # String Pool과 무관
```

**실무 영향**
```java
// Java 7+ 이점
// 1. 동적 크기 조절
// 많은 intern() 사용해도 Heap이 충분하면 OK

// 2. GC로 회수 가능
Map<String, Data> cache = new HashMap<>();
for (String key : largeDataSet) {
    cache.put(key.intern(), data);  // 캐시 제거 시 GC 가능
}

// 3. PermGen 에러 없음
// "OutOfMemoryError: PermGen space" 발생 안 함
```

**꼬리 질문**
- Q: String Pool이 Heap에 있으면 Young GC 때 계속 스캔되나요?
- A: "String Pool은 Heap의 Old Generation에 직접 할당되어 Young GC의 영향을 받지 않습니다. 또한 대부분의 interned 문자열은 오래 살아남으므로 Old Generation이 적합합니다."

**실무 연관**
- Java 7+ 사용 시 intern() 더 안전
- PermGen 에러 해결
- 메모리 튜닝 전략

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| String | 불변(Immutable) 문자열 클래스 | 불변, Pool, Thread-safe |
| String Pool | 같은 문자열 리터럴을 재사용하는 메모리 영역 | 리터럴, 재사용, 메모리 절약 |
| == vs equals() | ==는 주소 비교, equals()는 내용 비교 | 참조, 값, 비교 |
| StringBuilder | 가변 문자열 (단일 스레드) | 가변, 성능, append |
| StringBuffer | 가변 문자열 (멀티 스레드) | Thread-safe, synchronized |
| intern() | String Pool에 문자열 등록/조회 | 중복 제거, 메모리 최적화 |
| substring() | 부분 문자열 추출 | 인덱스, 새 객체 |
| 문자열 연결 | +, concat(), StringBuilder | 성능, 최적화 |

### 필수 메서드 정리

| 메서드 | 용도 | 반환 타입 | 예시 |
|--------|------|-----------|------|
| `length()` | 문자열 길이 | int | `"Hello".length()` → 5 |
| `charAt(int)` | 특정 위치 문자 | char | `"Hello".charAt(1)` → 'e' |
| `substring(int, int)` | 부분 문자열 | String | `"Hello".substring(0,2)` → "He" |
| `equals(Object)` | 내용 비교 | boolean | `"a".equals("a")` → true |
| `equalsIgnoreCase(String)` | 대소문자 무시 비교 | boolean | `"A".equalsIgnoreCase("a")` → true |
| `indexOf(String)` | 문자열 찾기 | int | `"Hello".indexOf("ll")` → 2 |
| `contains(String)` | 문자열 포함 여부 | boolean | `"Hello".contains("ell")` → true |
| `startsWith(String)` | 시작 확인 | boolean | `"Hello".startsWith("He")` → true |
| `endsWith(String)` | 끝 확인 | boolean | `"Hello".endsWith("lo")` → true |
| `replace(char, char)` | 문자 치환 | String | `"Hello".replace('l','x')` → "Hexxo" |
| `toUpperCase()` | 대문자 변환 | String | `"hello".toUpperCase()` → "HELLO" |
| `toLowerCase()` | 소문자 변환 | String | `"HELLO".toLowerCase()` → "hello" |
| `trim()` | 앞뒤 공백 제거 | String | `" Hi ".trim()` → "Hi" |
| `split(String)` | 문자열 분리 | String[] | `"a,b,c".split(",")` → ["a","b","c"] |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] **문자열 비교는 equals()** 사용 (`==` 금지)
- [ ] **반복문에서는 StringBuilder** 사용
- [ ] **null 체크 먼저** 수행 (`str != null && !str.isEmpty()`)
- [ ] **상수를 앞에** 두기 (`"admin".equals(input)`)
- [ ] **대소문자 무시는 equalsIgnoreCase()** 사용
- [ ] **Pattern 객체는 재사용** (정규식)
- [ ] **문자열 연결 3개 이하는 +** 사용 OK

#### ❌ 하지 말아야 할 것
- [ ] **==로 문자열 비교** (주소 비교됨)
- [ ] **반복문에서 + 연결** (성능 저하)
- [ ] **null 체크 누락** (NullPointerException)
- [ ] **불필요한 intern()** 사용 (메모리 누수)
- [ ] **정규식 매번 컴파일** (Pattern.compile() 재사용)
- [ ] **StringBuffer 남용** (단일 스레드면 StringBuilder)

### 성능/메모리 체크리스트

#### 성능
- [ ] **반복 연결은 StringBuilder** (1000배 빠름)
- [ ] **Pattern 객체 재사용** (정규식 컴파일 비용 큼)
- [ ] **간단한 연결은 + 연산자** (컴파일러 최적화)
- [ ] **String Pool 활용** (리터럴 사용)

#### 메모리
- [ ] **중복 문자열은 intern()** 고려 (신중하게)
- [ ] **불필요한 String 객체 생성 최소화**
- [ ] **큰 문자열의 substring() 후 원본 null** 처리
- [ ] **StringBuilder 초기 용량 지정** (`new StringBuilder(capacity)`)

### 문자열 비교 완벽 가이드

```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = new String("Hello");
String s4 = new String("Hello");

// 1. == : 주소 비교
s1 == s2  // true  (같은 Pool 객체)
s1 == s3  // false (Pool vs Heap)
s3 == s4  // false (서로 다른 Heap 객체)

// 2. equals() : 내용 비교
s1.equals(s2)  // true
s1.equals(s3)  // true
s3.equals(s4)  // true

// 3. equalsIgnoreCase() : 대소문자 무시
"Hello".equalsIgnoreCase("HELLO")  // true

// 4. compareTo() : 사전순 비교
"Apple".compareTo("Banana")  // < 0 (앞)
"Banana".compareTo("Apple")  // > 0 (뒤)
"Apple".compareTo("Apple")   // 0 (같음)

// 5. contentEquals() : CharSequence 비교
String s = "Hello";
StringBuilder sb = new StringBuilder("Hello");
s.contentEquals(sb)  // true
```

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| 정규표현식 (Regex) | 문자열 패턴 매칭 | ⭐⭐⭐ |
| StringBuilder/StringBuffer | 가변 문자열 | ⭐⭐⭐ (필수) |
| Formatter | 문자열 포맷팅 | ⭐⭐⭐ |
| Pattern/Matcher | 정규식 처리 | ⭐⭐⭐ |
| StringTokenizer | 문자열 분리 (구식) | ⭐☆☆ |
| Charset | 문자 인코딩 | ⭐⭐☆ |
| Scanner | 문자열 파싱 | ⭐⭐☆ |
| MessageFormat | 다국어 지원 | ⭐⭐☆ |

**학습 순서 추천**:
```
문자열 처리 (현재) ✅
    ↓
정규표현식 (11장)
    ↓
파일 입출력 (텍스트 파일)
    ↓
JSON/XML 파싱
    ↓
국제화(i18n)
```

---

## 🚀 다음 단계

### 다음 장 미리보기: 10장 패키지와 import

**배울 내용**:
- **패키지 개념**: 클래스들을 묶어 관리하는 방법
- **import 문**: 다른 패키지의 클래스 사용
- **접근 제어자**: public, private, protected, default
- **패키지 명명 규칙**: 실무 관례
- **JAR 파일**: 패키지를 배포하는 방법

**실전 프로젝트**:
- 📦 여러 패키지로 구성된 도서관 시스템
- 🏗️ 계층형 패키지 구조 설계

### 이 장과의 연결점

```
09장: 문자열 처리
    ↓
문자열 데이터를 다루는 방법 배움
    ↓
10장: 패키지와 import
    ↓
코드를 체계적으로 구조화하는 방법 배움
    ↓
최종적으로
    ↓
대규모 프로젝트 구조 설계 능력
```

### 준비하면 좋을 것들

```bash
# 09장 복습 - 문자열 처리 연습
# 다음 기능들을 직접 구현해보세요

# 1. 이메일 검증기
# - @가 있는지 확인
# - 도메인이 유효한지 확인
# - 금지된 특수문자 체크

# 2. 비밀번호 강도 체크
# - 8자 이상
# - 대문자, 소문자, 숫자, 특수문자 포함
# - 연속된 문자 체크

# 3. URL 파서
# - 프로토콜, 도메인, 경로 추출
# - 쿼리 파라미터 파싱

# 이 기능들을 10장에서 패키지로 구조화합니다!
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Oracle Java String Documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html)
- [String (Java SE 17 API)](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html)
- [Pattern Class Documentation](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/regex/Pattern.html)

### 추천 블로그/아티클
- [Baeldung - Java String](https://www.baeldung.com/java-string)
- [Baeldung - StringBuilder vs StringBuffer](https://www.baeldung.com/java-string-builder-string-buffer)
- [Java String Pool 이해하기](https://www.baeldung.com/java-string-pool)
- [정규표현식 완벽 가이드](https://regexr.com/)

### 영상 강의
- [인프런 - 김영한의 자바 입문](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8)
- [YouTube - 코딩애플 Java String](https://www.youtube.com/@codingapple)

### 도서
- **"Effective Java" (조슈아 블로크)** ⭐⭐⭐⭐⭐
  - Item 63: 문자열 연결은 느리니 주의하라
  - Item 62: 다른 타입이 적절하다면 문자열 사용을 피하라

- **"Clean Code" (로버트 C. 마틴)** ⭐⭐⭐⭐⭐
  - 의미 있는 이름 (문자열 변수명)

### 연습 문제 사이트
- [프로그래머스 - 문자열 문제](https://programmers.co.kr/learn/challenges?tab=all_challenges&order=recent&levels=1%2C2&languages=java&types=all)
- [백준 - 문자열 문제](https://www.acmicpc.net/problemset?sort=ac_desc&algo=158)
- [LeetCode - String Problems](https://leetcode.com/tag/string/)

### 정규표현식 학습
- [RegexOne - 대화형 튜토리얼](https://regexone.com/)
- [Regex101 - 테스트 도구](https://regex101.com/)
- [RegExr - 학습 및 테스트](https://regexr.com/)

---

## 🎉 축하합니다!

**09장 문자열 처리 완전 마스터!**

**이제 여러분은**:
✅ String의 불변성과 그 이유를 완벽히 이해했습니다
✅ ==와 equals()의 차이를 명확히 알았습니다
✅ StringBuilder로 성능을 최적화할 수 있습니다
✅ 주요 문자열 메서드를 자유롭게 사용합니다
✅ String Pool의 동작 원리를 이해했습니다
✅ 실무에서 자주 하는 실수를 피할 수 있습니다
✅ 텍스트 분석 프로그램을 구현했습니다
✅ FAQ 7개 질문에 답할 수 있습니다
✅ 면접 질문 12개를 준비했습니다
✅ 정규표현식 성능 최적화를 이해했습니다

**다음 단계**:
- [ ] 09장 실전 프로젝트 복습하기
- [ ] 문자열 처리 연습 문제 풀기
- [ ] 면접 질문 답변 연습하기
- [ ] 10장 "패키지와 import"로 진행하기

---

## 💬 학습 후 체크리스트

### 기초 개념 (09-1장)
- [ ] String이 불변인 이유를 설명할 수 있다
- [ ] ==와 equals()의 차이를 안다
- [ ] 주요 String 메서드를 사용할 수 있다
- [ ] StringBuilder를 적절히 사용할 수 있다
- [ ] String Pool의 개념을 이해했다
- [ ] 텍스트 분석 프로그램을 구현했다

### 심화 개념 (09-2장)
- [ ] FAQ 7개 질문에 답할 수 있다
- [ ] 주니어 면접 질문 7개를 준비했다
- [ ] 중급 면접 질문 5개를 이해했다
- [ ] intern()의 동작 원리를 안다
- [ ] 정규식 성능 최적화를 이해했다
- [ ] CharSequence 인터페이스를 활용할 수 있다

### 실무 역량
- [ ] 로그인 기능에서 올바른 문자열 비교를 한다
- [ ] 반복문에서 StringBuilder를 사용한다
- [ ] null 체크를 습관화했다
- [ ] 이메일, URL 등을 올바르게 파싱할 수 있다
- [ ] 성능을 고려한 문자열 처리를 한다

---

**💪 "문자열 처리의 모든 것을 마스터했습니다!"**

**📖 다음 장에서 만나요!**

[← 이전: 09-1장 기초편](09-1-문자열-처리-기초편.md) | [다음: 10장 패키지와 import →](10-패키지와-import.md)

[📚 전체 목차로 돌아가기](README.md)

---

**🌟 Java 마스터의 길, 계속 전진하세요! 🚀**

*"Practice makes perfect." - 꾸준한 연습이 완벽을 만듭니다.*
