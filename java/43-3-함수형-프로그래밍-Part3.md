# 43장 함수형 프로그래밍 - Part 3: 성능 최적화 & 면접 질문

## 📚 목차
1. [성능 최적화](#성능-최적화)
2. [고급 기법](#고급-기법)
3. [면접 질문](#면접-질문)

---

## ⚡ 성능 최적화

### 1. 스트림 성능 비교

```java
import java.util.*;
import java.util.stream.*;

public class StreamPerformance {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(0, 10_000_000)
            .boxed()
            .collect(Collectors.toList());

        // 1. For Loop
        long start = System.nanoTime();
        int sum = 0;
        for (int n : numbers) {
            if (n % 2 == 0) {
                sum += n * 2;
            }
        }
        long forTime = System.nanoTime() - start;

        // 2. Stream
        start = System.nanoTime();
        sum = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToInt(n -> n * 2)
            .sum();
        long streamTime = System.nanoTime() - start;

        // 3. Parallel Stream
        start = System.nanoTime();
        sum = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .mapToInt(n -> n * 2)
            .sum();
        long parallelTime = System.nanoTime() - start;

        System.out.println("For Loop: " + forTime / 1_000_000 + "ms");
        System.out.println("Stream: " + streamTime / 1_000_000 + "ms");
        System.out.println("Parallel: " + parallelTime / 1_000_000 + "ms");
    }
}

/* 결과 (1000만 건)
For Loop: 45ms
Stream: 68ms
Parallel: 22ms
*/
```

**최적화 팁**:
- **대량 데이터 (> 100만)**: 병렬 스트림
- **중간 데이터**: 가독성 우선, 스트림 사용
- **소량 데이터 (< 10만)**: 전통적 반복문

---

### 2. 지연 평가 활용

```java
public class LazyEvaluation {
    // ❌ 즉시 평가 - 모든 연산 실행
    public List<String> eagerProcessing(List<String> data) {
        return data.stream()
            .map(s -> expensiveOperation1(s))  // 모두 실행
            .map(s -> expensiveOperation2(s))  // 모두 실행
            .filter(s -> s.length() > 5)       // 필터링
            .collect(Collectors.toList());
    }

    // ✅ 지연 평가 - 필요한 만큼만
    public List<String> lazyProcessing(List<String> data) {
        return data.stream()
            .filter(s -> s.length() > 5)       // 먼저 필터링!
            .map(s -> expensiveOperation1(s))  // 적은 데이터만 처리
            .map(s -> expensiveOperation2(s))
            .collect(Collectors.toList());
    }

    // 더 나은 방법 - limit 활용
    public List<String> betterProcessing(List<String> data) {
        return data.stream()
            .filter(s -> s.length() > 5)
            .limit(10)                          // 10개만!
            .map(s -> expensiveOperation1(s))   // 10개만 처리
            .map(s -> expensiveOperation2(s))
            .collect(Collectors.toList());
    }
}
```

---

### 3. 메서드 레퍼런스 vs 람다

```java
public class MethodReferencePerformance {
    // 벤치마크
    public void benchmark() {
        List<String> names = generateLargeList();

        // 람다 표현식
        long start = System.nanoTime();
        names.stream()
            .map(s -> s.toUpperCase())
            .collect(Collectors.toList());
        long lambdaTime = System.nanoTime() - start;

        // 메서드 레퍼런스
        start = System.nanoTime();
        names.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        long methodRefTime = System.nanoTime() - start;

        // 메서드 레퍼런스가 약간 더 빠름 (10-15%)
        System.out.println("Lambda: " + lambdaTime);
        System.out.println("Method Ref: " + methodRefTime);
    }
}
```

**최적화 팁**: 가능하면 메서드 레퍼런스 사용

---

### 4. Collector 최적화

```java
public class CollectorOptimization {
    // ❌ 비효율적 - 여러 번 순회
    public Map<String, Long> inefficient(List<User> users) {
        Map<String, Long> result = new HashMap<>();

        for (String city : users.stream()
                .map(User::getCity)
                .distinct()
                .collect(Collectors.toList())) {

            long count = users.stream()
                .filter(u -> u.getCity().equals(city))
                .count();

            result.put(city, count);
        }

        return result;
    }

    // ✅ 효율적 - 한 번만 순회
    public Map<String, Long> efficient(List<User> users) {
        return users.stream()
            .collect(Collectors.groupingBy(
                User::getCity,
                Collectors.counting()
            ));
    }
}
```

---

### 5. 병렬 스트림 최적화

```java
public class ParallelStreamOptimization {
    // ✅ 병렬 스트림이 효과적인 경우
    public List<Result> goodParallel(List<Data> data) {
        return data.parallelStream()
            .map(this::heavyComputation)  // CPU 집약적
            .collect(Collectors.toList());
    }

    // ❌ 병렬 스트림이 비효율적인 경우
    public List<Result> badParallel(List<Data> data) {
        return data.parallelStream()
            .map(this::databaseCall)  // I/O 작업 (블로킹)
            .collect(Collectors.toList());
    }

    // ✅ Custom ForkJoinPool 사용
    public List<Result> customPool(List<Data> data) {
        ForkJoinPool customPool = new ForkJoinPool(4);

        try {
            return customPool.submit(() ->
                data.parallelStream()
                    .map(this::heavyComputation)
                    .collect(Collectors.toList())
            ).get();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            customPool.shutdown();
        }
    }
}
```

---

## 🚀 고급 기법

### 1. 메모이제이션 (Caching)

```java
public class Memoization {
    // 캐시를 사용한 메모이제이션
    private Map<Integer, BigInteger> cache = new ConcurrentHashMap<>();

    public BigInteger fibonacci(int n) {
        return cache.computeIfAbsent(n, this::computeFibonacci);
    }

    private BigInteger computeFibonacci(int n) {
        if (n <= 1) return BigInteger.valueOf(n);
        return fibonacci(n - 1).add(fibonacci(n - 2));
    }

    // Java 8+ 스타일
    private Function<Integer, BigInteger> memoize(
            Function<Integer, BigInteger> function) {

        Map<Integer, BigInteger> cache = new ConcurrentHashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }

    // 사용
    Function<Integer, BigInteger> memoizedFib = memoize(this::computeFibonacci);
}
```

---

### 2. 커링 (Currying)

```java
public class Currying {
    // 일반 함수
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // 커링된 함수
    public Function<Integer, Function<Integer, Function<Integer, Integer>>>
        curriedAdd() {

        return a -> b -> c -> a + b + c;
    }

    // 사용
    public void example() {
        var add = curriedAdd();
        var add5 = add.apply(5);
        var add5And10 = add5.apply(10);
        int result = add5And10.apply(3);  // 18

        // 또는 체이닝
        int result2 = curriedAdd().apply(5).apply(10).apply(3);  // 18
    }

    // 실용적인 예제
    public Function<Double, Double> createTaxCalculator(double taxRate) {
        return price -> price * (1 + taxRate);
    }

    public void practicalExample() {
        var koreanTax = createTaxCalculator(0.10);
        var usTax = createTaxCalculator(0.07);

        System.out.println(koreanTax.apply(10000.0));  // 11000
        System.out.println(usTax.apply(10000.0));      // 10700
    }
}
```

---

### 3. 함수 조합 (Composition)

```java
public class FunctionComposition {
    // 기본 함수들
    Function<String, String> trim = String::trim;
    Function<String, String> toLowerCase = String::toLowerCase;
    Function<String, String[]> split = s -> s.split("\\s+");
    Function<String[], List<String>> toList = Arrays::asList;

    // compose vs andThen
    public void compositionExample() {
        // andThen: 왼쪽에서 오른쪽
        Function<String, String> process1 = trim.andThen(toLowerCase);

        // compose: 오른쪽에서 왼쪽
        Function<String, String> process2 = toLowerCase.compose(trim);

        // 둘 다 같은 결과
        System.out.println(process1.apply("  HELLO  "));  // "hello"
        System.out.println(process2.apply("  HELLO  "));  // "hello"
    }

    // 복잡한 파이프라인
    public Function<String, List<String>> createPipeline() {
        return trim
            .andThen(toLowerCase)
            .andThen(split)
            .andThen(toList);
    }

    // 사용
    public void usage() {
        var pipeline = createPipeline();
        List<String> words = pipeline.apply("  HELLO WORLD  ");
        System.out.println(words);  // [hello, world]
    }
}
```

---

### 4. Monad 패턴

```java
public class MonadPattern {
    // Optional은 Monad!
    public Optional<User> findUser(Long id) {
        return userRepository.findById(id);
    }

    public Optional<String> getUserEmail(Long id) {
        return findUser(id)
            .flatMap(user -> Optional.ofNullable(user.getProfile()))
            .flatMap(profile -> Optional.ofNullable(profile.getEmail()))
            .map(Email::getAddress);
    }

    // Custom Monad: Try
    public class Try<T> {
        private final T value;
        private final Exception exception;

        private Try(T value, Exception exception) {
            this.value = value;
            this.exception = exception;
        }

        public static <T> Try<T> success(T value) {
            return new Try<>(value, null);
        }

        public static <T> Try<T> failure(Exception e) {
            return new Try<>(null, e);
        }

        public <R> Try<R> map(Function<T, R> mapper) {
            if (exception != null) {
                return Try.failure(exception);
            }
            try {
                return Try.success(mapper.apply(value));
            } catch (Exception e) {
                return Try.failure(e);
            }
        }

        public <R> Try<R> flatMap(Function<T, Try<R>> mapper) {
            if (exception != null) {
                return Try.failure(exception);
            }
            try {
                return mapper.apply(value);
            } catch (Exception e) {
                return Try.failure(e);
            }
        }

        public T orElse(T defaultValue) {
            return exception != null ? defaultValue : value;
        }
    }

    // 사용
    public Try<Integer> divide(int a, int b) {
        return Try.success(a / b);
    }

    public void example() {
        int result = divide(10, 2)
            .map(n -> n * 2)
            .map(n -> n + 1)
            .orElse(0);  // 21
    }
}
```

---

## 💡 면접 질문

### Q1. 함수형 프로그래밍의 핵심 개념은?

**답변**:
```
함수형 프로그래밍의 4대 핵심 개념:

1. 순수 함수 (Pure Function)
   - 같은 입력 → 같은 출력
   - 부작용 없음
   - 예측 가능, 테스트 용이

2. 불변성 (Immutability)
   - 데이터 변경 금지
   - 새 객체 생성
   - Thread-safe

3. 고차 함수 (Higher-Order Function)
   - 함수를 인자로 받음
   - 함수를 반환
   - 함수 조합 가능

4. 선언형 프로그래밍
   - "무엇을" 할지 선언
   - "어떻게"가 아닌 "무엇을"
```

---

### Q2. 순수 함수와 비순수 함수의 차이는?

**답변**:
```java
// 순수 함수
public int add(int a, int b) {
    return a + b;  // 항상 같은 결과
}

// 비순수 함수
private int counter = 0;
public int addWithCounter(int a, int b) {
    counter++;  // 외부 상태 변경 (부작용)
    return a + b + counter;  // 매번 다른 결과
}
```

**차이점**:
- **순수 함수**: 참조 투명성, 테스트 용이, 병렬 처리 가능
- **비순수 함수**: 상태 의존, 예측 불가, Thread-unsafe

---

### Q3. 스트림의 지연 평가란?

**답변**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 지연 평가
Stream<Integer> stream = numbers.stream()
    .filter(n -> {
        System.out.println("filter: " + n);
        return n % 2 == 0;
    })
    .map(n -> {
        System.out.println("map: " + n);
        return n * 2;
    });

// 여기까지는 아무것도 출력 안 됨!

// 최종 연산이 호출될 때 실행
List<Integer> result = stream.collect(Collectors.toList());

/* 출력:
filter: 1
filter: 2
map: 2
filter: 3
filter: 4
map: 4
filter: 5
*/
```

**장점**:
- 필요한 만큼만 처리
- 성능 최적화
- 무한 스트림 가능

---

### Q4. map과 flatMap의 차이는?

**답변**:
```java
// map - 1:1 변환
List<String> names = Arrays.asList("Alice", "Bob");
List<Integer> lengths = names.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 3]

// flatMap - 1:N 변환 후 평탄화
List<String> words = Arrays.asList("Hello World", "Java Stream");
List<String> allWords = words.stream()
    .flatMap(line -> Arrays.stream(line.split(" ")))
    .collect(Collectors.toList());
// [Hello, World, Java, Stream]

// map vs flatMap
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);

// map - 그대로
List<Stream<Integer>> mapped = nested.stream()
    .map(List::stream)
    .collect(Collectors.toList());
// [Stream, Stream]

// flatMap - 평탄화
List<Integer> flattened = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4]
```

---

### Q5. 병렬 스트림을 사용할 때 주의사항은?

**답변**:
```java
// ❌ 잘못된 사용
List<Integer> list = new ArrayList<>();
IntStream.range(0, 1000).parallel()
    .forEach(list::add);  // ConcurrentModificationException!

// ✅ 올바른 사용
List<Integer> list = IntStream.range(0, 1000)
    .parallel()
    .boxed()
    .collect(Collectors.toList());
```

**주의사항**:
1. **공유 상태 수정 금지** - Thread-unsafe
2. **대량 데이터에만 사용** - 오버헤드 고려
3. **순서 보장 안 됨** - forEach 대신 forEachOrdered
4. **블로킹 I/O 피하기** - ForkJoinPool 고갈

---

### Q6. 함수형 프로그래밍의 장단점은?

**답변**:

**장점**:
```
✅ 코드 간결성 - 보일러플레이트 감소
✅ 가독성 - 선언적 코드
✅ 테스트 용이성 - 순수 함수
✅ 병렬 처리 - Thread-safe
✅ 버그 감소 - 불변성
```

**단점**:
```
❌ 학습 곡선 - 개념 이해 필요
❌ 성능 오버헤드 - 작은 데이터는 느림
❌ 디버깅 어려움 - 스택 트레이스 복잡
❌ 과도한 객체 생성 - GC 부하
```

---

### Q7. Collector의 내부 동작 원리는?

**답변**:
```java
// Collector 구조
public interface Collector<T, A, R> {
    Supplier<A> supplier();        // 컨테이너 생성
    BiConsumer<A, T> accumulator(); // 요소 추가
    BinaryOperator<A> combiner();  // 병렬 처리 시 결합
    Function<A, R> finisher();     // 최종 변환
}

// Custom Collector 예제
public static Collector<String, StringBuilder, String> joining() {
    return Collector.of(
        StringBuilder::new,              // supplier
        StringBuilder::append,           // accumulator
        StringBuilder::append,           // combiner
        StringBuilder::toString          // finisher
    );
}

// 사용
String result = Stream.of("a", "b", "c")
    .collect(joining());  // "abc"
```

---

## 🎓 최종 정리

### 함수형 프로그래밍 체크리스트

```
✅ 순수 함수로 작성
✅ 불변 객체 사용
✅ 외부 상태 변경 금지
✅ 선언적 코드 작성
✅ 함수 조합 활용
✅ 지연 평가 고려
✅ 적절한 컬렉터 사용
✅ 병렬 처리 시 주의
```

### 성능 최적화 팁

```
🚀 필터링 먼저, 변환 나중
🚀 메서드 레퍼런스 우선
🚀 대량 데이터는 병렬 스트림
🚀 적절한 컬렉터 선택
🚀 무한 스트림은 limit
```

**축하합니다! 함수형 프로그래밍을 마스터했습니다!** 🎉
