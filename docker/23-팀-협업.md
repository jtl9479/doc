# 23. 팀 협업

> **학습 목표**: Docker를 활용한 팀 협업 환경 구축 방법을 익히고, 환경 차이로 인한 문제를 제거하여 팀 생산성을 극대화할 수 있습니다.

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐☆☆ (3개/5개)

---

## 목차
1. [공통 개발 환경 구성](#공통-개발-환경-구성)
2. [Git을 통한 설정 공유](#git을-통한-설정-공유)
3. [환경 변수 관리 전략](#환경-변수-관리-전략)
4. [팀 코드 리뷰 프로세스](#팀-코드-리뷰-프로세스)
5. [문서화 가이드](#문서화-가이드)
6. [온보딩 가이드](#온보딩-가이드)
7. [팀 컨벤션](#팀-컨벤션)
8. [트러블슈팅 공유](#트러블슈팅-공유)

---

## 💡 왜 팀 협업 환경이 필요한가?

### 실무 배경

**"내 컴퓨터에서는 되는데요?"** - 모든 개발팀이 겪는 악몽

#### ❌ 표준화된 환경이 없으면 발생하는 문제

```
문제 1: 환경 차이로 인한 버그 재현 불가
- 개발자 A: "로컬에서는 완벽하게 작동하는데요!"
- 개발자 B: "제 컴퓨터에서는 에러가 나는데요?"
- 원인: Node 16 vs 18, PostgreSQL 14 vs 15 차이
- 비용: 디버깅에 하루 4시간 소요, 주당 20시간 낭비 (월 400만원 손실)

문제 2: 신입 개발자 온보딩에 3일 소요
- 증상: "환경 설정이 안돼요" 반복
- 대응: 시니어 개발자가 1:1로 설정 도와줌
- 영향: 시니어 개발자 3일 허비, 신입 3일 허비
- 비용: 2명 × 3일 = 6인일 손실 (약 120만원)

문제 3: 설정 파일 동기화 누락
- 증상: docker-compose.yml 각자 다르게 수정
- 대응: "제 설정으로 하면 됩니다" (비표준화)
- 영향: 프로덕션 배포 시 예기치 않은 동작
- 비용: 장애 복구 4시간 (다운타임 비용 수천만원)
```

#### ✅ 표준화된 팀 협업 환경 구축 시

```
해결책 1: 환경 차이 제로화
- 방법: Docker Compose로 동일한 개발 환경 제공
- 효과: "내 컴퓨터에서는 되는데" 문제 98% 감소
- 절감: 디버깅 시간 주당 20시간 → 1시간 (월 380만원 절감)

해결책 2: 신입 온보딩 3일 → 30분
- 방법: 자동화된 환경 설정 스크립트 + README
- 효과: git clone → docker-compose up 2단계로 완료
- 절감: 온보딩 비용 6인일 → 0.5인일 (110만원 절감)

해결책 3: 설정 파일 Git으로 버전 관리
- 방법: docker-compose.yml, .env.example Git 공유
- 효과: 모든 팀원이 동일한 설정 사용
- 절감: 배포 장애 90% 감소, 다운타임 비용 대폭 절감
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 환경 관련 버그 | 주 10건 | 주 1건 | **90%↓** |
| 신입 온보딩 시간 | 3일 | 30분 | **94%↓** |
| 환경 설정 문의 | 일 5회 | 주 1회 | **96%↓** |
| 프로덕션 배포 실패율 | 20% | 2% | **90%↓** |
| 팀 생산성 | 보통 | 높음 | **40%↑** |

---

## 🔍 실생활 비유로 이해하기

### 비유 1: 오케스트라의 악기 조율

```
조율되지 않은 오케스트라:
┌──────────────────────────────────────┐
│ 바이올린: A=440Hz                     │
│ 플루트:   A=442Hz                     │
│ 피아노:   A=438Hz                     │
│ → 불협화음 발생! 🎵❌                │
└──────────────────────────────────────┘

조율된 오케스트라:
┌──────────────────────────────────────┐
│ 모든 악기: A=440Hz로 통일             │
│ → 아름다운 하모니! 🎵✅              │
└──────────────────────────────────────┘

개발팀도 동일:
┌──────────────────────────────────────┐
│ 개발자 A: Node 16, PostgreSQL 14     │
│ 개발자 B: Node 18, PostgreSQL 15     │
│ → "내 컴퓨터에서는 되는데?" ❌       │
└──────────────────────────────────────┘

Docker로 해결:
┌──────────────────────────────────────┐
│ 모든 팀원: 동일한 Docker 이미지       │
│ → 환경 차이 제로! ✅                 │
└──────────────────────────────────────┘
```

### 비유 2: 레시피(Recipe) 공유하기

```
레시피 없이 요리:
👨‍🍳 "이 요리 어떻게 만드셨어요?"
👩‍🍳 "기억이 안 나는데... 대충 이렇게 했던 것 같아요."
👨‍🍳 "만들어봤는데 맛이 이상해요..."
→ 재현 불가능 ❌

레시피 공유:
┌─────────────────────────────────────┐
│ 📖 김치찌개 레시피                   │
│                                      │
│ 재료:                                │
│ - 돼지고기 200g                      │
│ - 김치 300g                          │
│ - 물 500ml                           │
│                                      │
│ 조리법:                              │
│ 1. 돼지고기 볶기 (중불 3분)          │
│ 2. 김치 추가 (중불 5분)              │
│ 3. 물 추가 후 끓이기 (20분)          │
└─────────────────────────────────────┘
→ 누구나 동일한 맛 재현 가능! ✅

Docker 개발 환경:
┌─────────────────────────────────────┐
│ 📖 docker-compose.yml (레시피)       │
│                                      │
│ 재료 (서비스):                        │
│ - PostgreSQL 15                      │
│ - Redis 7                            │
│ - Node.js 18                         │
│                                      │
│ 조리법 (명령어):                      │
│ 1. git clone                         │
│ 2. docker-compose up -d              │
│ 3. 끝! 개발 시작                     │
└─────────────────────────────────────┘
→ 모든 팀원이 동일한 환경! ✅
```

### 비유 3: 자동차 공장의 표준 공구

```
각자 다른 공구 사용:
작업자 A: 10mm 렌치
작업자 B: 3/8인치 렌치 (약 9.5mm)
작업자 C: 11mm 렌치
→ 볼트가 맞지 않음, 생산 중단! ❌

표준 공구 세트:
┌──────────────────────────────────────┐
│ 🔧 표준 공구함                        │
│ - 10mm 렌치 (모두 동일)               │
│ - 12mm 렌치 (모두 동일)               │
│ - 14mm 렌치 (모두 동일)               │
│ → 누가 작업해도 동일한 품질! ✅      │
└──────────────────────────────────────┘

Docker 환경:
┌──────────────────────────────────────┐
│ 🐳 표준 개발 환경 (공구함)            │
│ - Node.js 18.0.0 (모두 동일)         │
│ - PostgreSQL 15.2 (모두 동일)        │
│ - Redis 7.0 (모두 동일)              │
│ → 누가 개발해도 동일하게 작동! ✅    │
└──────────────────────────────────────┘

💡 핵심:
표준화는 선택이 아닌 필수!
Docker는 팀 전체의 공구함입니다.
```

---

## 공통 개발 환경 구성

### 표준화된 docker-compose.yml

```yaml
# docker-compose.dev.yml
# 모든 팀원이 동일하게 사용

version: '3.8'

x-common-variables: &common-variables
  TZ: Asia/Seoul
  LANG: ko_KR.UTF-8

x-spring-boot-service: &spring-boot-service
  build:
    context: .
    dockerfile: Dockerfile.dev
  environment:
    <<: *common-variables
    SPRING_PROFILES_ACTIVE: dev
  restart: unless-stopped

services:
  # 인프라 (모든 팀원 공통)
  postgres:
    image: postgres:15-alpine
    environment:
      <<: *common-variables
      POSTGRES_DB: lktrade_dev
      POSTGRES_USER: lkuser
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-devpass}
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U lkuser -d lktrade_dev"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    ports:
      - "${REDIS_PORT:-6379}:6379"
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

  # 마이크로서비스 (공통 템플릿)
  user-service:
    <<: *spring-boot-service
    container_name: lk-user-service
    ports:
      - "${USER_SERVICE_PORT:-8081}:8080"
      - "${USER_SERVICE_DEBUG_PORT:-5005}:5005"
    volumes:
      - ./modules/user/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      <<: *common-variables
      SPRING_PROFILES_ACTIVE: dev
      DATABASE_URL: jdbc:postgresql://postgres:5432/lktrade_dev
      REDIS_HOST: redis

  account-service:
    <<: *spring-boot-service
    container_name: lk-account-service
    ports:
      - "${ACCOUNT_SERVICE_PORT:-8082}:8080"
      - "${ACCOUNT_SERVICE_DEBUG_PORT:-5006}:5005"
    volumes:
      - ./modules/account/api/src:/app/api/src:cached
      - gradle-cache:/root/.gradle
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  # 개발 도구 (profile로 선택적 실행)
  pgadmin:
    image: dpage/pgadmin4:latest
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_EMAIL:-admin@lktrade.com}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_PASSWORD:-admin}
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "${PGADMIN_PORT:-5050}:80"
    volumes:
      - pgadmin-data:/var/lib/pgadmin
    profiles:
      - tools
    depends_on:
      - postgres

  redis-commander:
    image: rediscommander/redis-commander:latest
    environment:
      - REDIS_HOSTS=local:redis:6379
    ports:
      - "${REDIS_COMMANDER_PORT:-8090}:8081"
    profiles:
      - tools
    depends_on:
      - redis

volumes:
  postgres-data:
  redis-data:
  pgadmin-data:
  gradle-cache:

networks:
  default:
    name: lktrade-dev
```

### .env 파일 템플릿

```bash
# .env.example
# Git에 커밋 (실제 값 제외)
# 새 팀원은 이 파일을 복사하여 .env.dev 생성

# ======================
# 데이터베이스 설정
# ======================
POSTGRES_PORT=5432
POSTGRES_PASSWORD=  # 팀 리더에게 문의

# ======================
# Redis 설정
# ======================
REDIS_PORT=6379

# ======================
# 서비스 포트 설정
# ======================
USER_SERVICE_PORT=8081
USER_SERVICE_DEBUG_PORT=5005

ACCOUNT_SERVICE_PORT=8082
ACCOUNT_SERVICE_DEBUG_PORT=5006

TRADE_SERVICE_PORT=8083
TRADE_SERVICE_DEBUG_PORT=5007

AI_SERVICE_PORT=8084
AI_SERVICE_DEBUG_PORT=5008

SCRAPER_SERVICE_PORT=8085
SCRAPER_SERVICE_DEBUG_PORT=5009

# ======================
# 개발 도구 포트
# ======================
PGADMIN_PORT=5050
PGADMIN_EMAIL=admin@lktrade.com
PGADMIN_PASSWORD=  # 팀 리더에게 문의

REDIS_COMMANDER_PORT=8090

# ======================
# 외부 API 키
# ======================
# Alpaca API
ALPACA_API_KEY=  # 본인의 테스트 키 입력
ALPACA_SECRET_KEY=  # 본인의 테스트 키 입력
ALPACA_BASE_URL=https://paper-api.alpaca.markets  # Paper Trading

# OpenAI API
OPENAI_API_KEY=  # 팀 공용 키 (팀 리더에게 문의)
OPENAI_MODEL=gpt-4

# ======================
# 기타 설정
# ======================
LOG_LEVEL=debug
DEBUG_MODE=true
```

---

## Git을 통한 설정 공유

### Git 저장소 구조

```
lk-trade/
├── .gitignore                 # Git 제외 파일
├── .env.example               # 환경 변수 템플릿 ✅ Git 포함
├── .env.dev                   # 실제 환경 변수 ❌ Git 제외
├── docker-compose.dev.yml     # 개발 환경 ✅ Git 포함
├── docker-compose.prod.yml    # 프로덕션 환경 ✅ Git 포함
├── Dockerfile.dev             # 개발용 Dockerfile ✅ Git 포함
├── Dockerfile                 # 프로덕션용 Dockerfile ✅ Git 포함
├── Makefile                   # 자동화 스크립트 ✅ Git 포함
├── README.md                  # 프로젝트 설명 ✅ Git 포함
├── docs/
│   ├── SETUP.md              # 환경 설정 가이드 ✅ Git 포함
│   ├── CONVENTIONS.md        # 팀 컨벤션 ✅ Git 포함
│   └── TROUBLESHOOTING.md    # 트러블슈팅 ✅ Git 포함
├── scripts/
│   ├── init-dev-env.sh       # 초기 설정 스크립트 ✅ Git 포함
│   ├── morning-start.sh      # 개발 환경 시작 ✅ Git 포함
│   └── backup-db.sh          # 백업 스크립트 ✅ Git 포함
└── modules/
    ├── user/
    ├── account/
    └── trade/
```

### .gitignore 설정

```gitignore
# .gitignore

# ==================
# 환경 변수 (보안)
# ==================
.env
.env.dev
.env.local
.env.*.local
*.env

# 환경 변수 템플릿은 포함
!.env.example
!.env.template

# ==================
# Docker 관련
# ==================
# 로그 파일
logs/
*.log

# 백업 파일
backup/
*.sql
*.sql.gz
*.tar.gz

# ==================
# IDE 설정 (선택적)
# ==================
# IntelliJ IDEA
.idea/
*.iml
*.iws

# VSCode (개인 설정 제외)
.vscode/*
!.vscode/settings.json.example
!.vscode/launch.json.example
!.vscode/tasks.json.example

# ==================
# OS 생성 파일
# ==================
.DS_Store
Thumbs.db
```

### 팀 설정 파일 공유

```json
// .vscode/settings.json.example
// 팀원은 이 파일을 복사하여 .vscode/settings.json 생성

{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true
  },

  // Kotlin 설정
  "[kotlin]": {
    "editor.defaultFormatter": "fwcd.kotlin",
    "editor.tabSize": 4
  },

  // Docker 설정
  "docker.showExplorer": true,
  "docker.explorerRefreshInterval": 1000,

  // 프로젝트 경로
  "gradle.nestedProjects": true
}
```

---

## 환경 변수 관리 전략

### 환경 변수 계층 구조

```
우선순위 (높음 → 낮음):
1. 셸 환경 변수 (export DATABASE_PASSWORD=...)
2. docker-compose.yml의 environment
3. .env 파일
4. 애플리케이션 기본값
```

### 보안 환경 변수 관리

#### 1. 팀 공용 시크릿 (1Password, LastPass 등)

```markdown
# docs/SECRETS.md (Git 제외)

## 팀 공용 시크릿

### 데이터베이스
- **위치**: 1Password > LK-Trade Vault > Database
- **항목**: Dev Database Password
- **값**: [1Password에서 확인]

### OpenAI API
- **위치**: 1Password > LK-Trade Vault > APIs
- **항목**: OpenAI API Key
- **값**: [1Password에서 확인]

### 획득 방법
1. 1Password 팀 초대 메일 확인
2. LK-Trade Vault 접근 권한 요청
3. .env.dev 파일에 값 복사
```

#### 2. 개인 테스트 키

```bash
# .env.dev (각자 관리)

# 개인 Alpaca Paper Trading 키
# 획득: https://app.alpaca.markets/paper/dashboard/overview
ALPACA_API_KEY=PK... # 본인 키
ALPACA_SECRET_KEY=... # 본인 키

# 팀 공용 OpenAI 키
# 획득: 1Password > LK-Trade Vault
OPENAI_API_KEY=sk-... # 팀 공용
```

### 환경별 설정 파일

```yaml
# docker-compose.override.yml (Git 제외)
# 개인 맞춤 설정 (포트 충돌 해결 등)

version: '3.8'

services:
  user-service:
    ports:
      - "9081:8080"  # 8081 대신 9081 사용 (개인 설정)

  postgres:
    ports:
      - "5433:5432"  # 5432 대신 5433 사용
```

---

## 팀 코드 리뷰 프로세스

### Pull Request 템플릿

```markdown
# .github/pull_request_template.md

## 변경 사항 요약
<!-- 무엇을 변경했는지 간략히 설명 -->

## 변경 이유
<!-- 왜 이 변경이 필요한지 설명 -->

## 테스트 방법
<!-- 리뷰어가 어떻게 테스트할 수 있는지 -->

### 로컬 테스트
\`\`\`bash
# 1. 브랜치 체크아웃
git checkout feature/user-authentication

# 2. Docker 이미지 재빌드
docker-compose build user-service

# 3. 컨테이너 재시작
docker-compose up -d user-service

# 4. 테스트 실행
curl http://localhost:8081/api/auth/login \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test123"}'

# 기대 결과: 200 OK, JWT 토큰 반환
\`\`\`

## 체크리스트
- [ ] 코드 스타일 가이드 준수
- [ ] 단위 테스트 추가/업데이트
- [ ] 통합 테스트 통과
- [ ] 문서 업데이트 (필요시)
- [ ] Docker 이미지 빌드 성공
- [ ] 로컬에서 동작 확인

## 스크린샷 (UI 변경 시)
<!-- 스크린샷 첨부 -->

## 관련 이슈
Closes #123
```

### 코드 리뷰 가이드라인

```markdown
# docs/CODE_REVIEW.md

## 코드 리뷰 원칙

### 리뷰어의 자세
1. **친절하게**: "이렇게 하면 안돼" (❌) → "이렇게 하면 어떨까요?" (✅)
2. **구체적으로**: "코드가 별로" (❌) → "14번 라인의 반복문을 map으로 개선하면 가독성이 좋을 것 같습니다" (✅)
3. **배우는 태도**: 더 나은 방법이 있다면 제안 수용

### 리뷰 체크리스트

#### 기능
- [ ] 요구사항을 충족하는가?
- [ ] 엣지 케이스를 처리하는가?
- [ ] 에러 핸들링이 적절한가?

#### 코드 품질
- [ ] 읽기 쉬운가?
- [ ] 중복 코드가 없는가?
- [ ] 적절히 추상화되었는가?

#### 테스트
- [ ] 테스트 커버리지 충분한가?
- [ ] 테스트가 의미 있는가?

#### Docker 관련
- [ ] Dockerfile 최적화되었는가?
- [ ] docker-compose.yml 변경 사항 문서화되었는가?
- [ ] 환경 변수 변경 시 .env.example 업데이트되었는가?

#### 보안
- [ ] 민감한 정보(API 키, 비밀번호) 하드코딩 안 했는가?
- [ ] SQL Injection 취약점 없는가?
- [ ] XSS 취약점 없는가?

### 리뷰 예제

#### ✅ 좋은 리뷰
\`\`\`
user-service/UserController.kt:45
💡 제안: 이 로직을 UserService로 이동하면 어떨까요?
Controller는 요청/응답 처리만 담당하고, 비즈니스 로직은 Service에서
처리하는 것이 일반적입니다.

참고: https://martinfowler.com/eaaCatalog/serviceLayer.html
\`\`\`

#### ❌ 나쁜 리뷰
\`\`\`
이 코드 스타일이 마음에 안 듭니다. 다시 작성하세요.
\`\`\`
```

---

## 문서화 가이드

### README.md 구조

```markdown
# LK-Trade 프로젝트

## 프로젝트 개요
GPT 기반 자동매매 시스템

## 기술 스택
- Backend: Kotlin, Spring Boot
- Database: PostgreSQL, Redis
- Infrastructure: Docker, Docker Compose
- CI/CD: GitHub Actions

## 빠른 시작

### 사전 요구사항
- Docker Desktop 설치
- Git
- JDK 21 (로컬 개발 시)

### 초기 설정
\`\`\`bash
# 1. 저장소 클론
git clone https://github.com/your-org/lk-trade.git
cd lk-trade

# 2. 환경 변수 설정
cp .env.example .env.dev
# .env.dev 파일 편집 (팀 리더에게 시크릿 요청)

# 3. 개발 환경 시작
make morning

# 또는
docker-compose -f docker-compose.dev.yml up -d
\`\`\`

### 서비스 URL
- User Service: http://localhost:8081
- Account Service: http://localhost:8082
- Trade Service: http://localhost:8083
- pgAdmin: http://localhost:5050

## 개발 워크플로우

### 브랜치 전략
- \`main\`: 프로덕션
- \`develop\`: 개발
- \`feature/*\`: 기능 개발
- \`hotfix/*\`: 긴급 수정

### 커밋 메시지 컨벤션
\`\`\`
feat: 새로운 기능 추가
fix: 버그 수정
docs: 문서 수정
style: 코드 포맷팅
refactor: 코드 리팩토링
test: 테스트 추가/수정
chore: 빌드, 설정 변경
\`\`\`

## 자주 사용하는 명령어
\`\`\`bash
# 개발 환경 시작
make morning

# 로그 확인
make logs

# 특정 서비스 재시작
make restart SERVICE=user-service

# 테스트 실행
make test

# 정리
make clean
\`\`\`

## 문서
- [환경 설정 가이드](docs/SETUP.md)
- [팀 컨벤션](docs/CONVENTIONS.md)
- [트러블슈팅](docs/TROUBLESHOOTING.md)
- [API 문서](docs/API.md)

## 팀 연락처
- 팀 리더: @leader
- 백엔드: @backend-team
- 프론트엔드: @frontend-team

## 라이선스
MIT
```

### 트러블슈팅 문서

```markdown
# docs/TROUBLESHOOTING.md

## 자주 발생하는 문제

### Q1: "Cannot connect to Docker daemon"

**증상**:
\`\`\`
Cannot connect to the Docker daemon at unix:///var/run/docker.sock
\`\`\`

**해결**:
1. Docker Desktop이 실행 중인지 확인
2. (Linux) Docker 서비스 시작: \`sudo systemctl start docker\`
3. 권한 확인: \`sudo usermod -aG docker $USER\` (재로그인 필요)

---

### Q2: "Port 8081 is already allocated"

**증상**:
\`\`\`
Error: bind: address already in use
\`\`\`

**해결**:
\`\`\`bash
# 1. 사용 중인 프로세스 찾기
netstat -tuln | grep 8081

# 2. 프로세스 종료
kill <PID>

# 또는 다른 포트 사용
# .env.dev에서 USER_SERVICE_PORT=9081 설정
\`\`\`

---

### Q3: "Database connection refused"

**증상**:
\`\`\`
Connection refused: postgres:5432
\`\`\`

**해결**:
\`\`\`bash
# 1. PostgreSQL 컨테이너 상태 확인
docker-compose ps postgres

# 2. PostgreSQL 로그 확인
docker-compose logs postgres

# 3. PostgreSQL 재시작
docker-compose restart postgres

# 4. 연결 테스트
docker-compose exec postgres psql -U lkuser -d lktrade_dev
\`\`\`

---

### Q4: "Out of memory" / OOM Killed

**증상**:
\`\`\`
Container exited with code 137
\`\`\`

**해결**:
\`\`\`yaml
# docker-compose.yml에 메모리 증가
services:
  user-service:
    mem_limit: 2g
    environment:
      - JAVA_OPTS=-XX:MaxRAMPercentage=75.0
\`\`\`

---

## 도움 요청하기

문제가 해결되지 않으면:

1. **Slack #dev-help 채널**에 다음 정보와 함께 질문:
   - 문제 증상
   - 시도한 해결 방법
   - 에러 로그 (docker logs 출력)
   - 환경 정보 (OS, Docker 버전)

2. **GitHub Issue** 생성:
   - 재현 가능한 최소 예제
   - 스크린샷
   - docker-compose.yml 관련 부분

3. **페어 프로그래밍** 요청
```

---

## 온보딩 가이드

### 신입 팀원 체크리스트

```markdown
# docs/ONBOARDING.md

## 환영합니다! 🎉

### Day 1: 환경 설정

#### 1. 계정 생성
- [ ] GitHub 계정 (팀 Organization에 초대됨)
- [ ] Slack 계정
- [ ] 1Password 계정 (시크릿 관리)

#### 2. 도구 설치
- [ ] Docker Desktop 설치
- [ ] Git 설치
- [ ] IDE 설치 (IntelliJ IDEA / VSCode)

#### 3. 저장소 클론 및 설정
\`\`\`bash
git clone https://github.com/your-org/lk-trade.git
cd lk-trade
cp .env.example .env.dev
# .env.dev 편집 (팀 리더에게 시크릿 요청)
\`\`\`

#### 4. 개발 환경 시작
\`\`\`bash
./scripts/init-dev-env.sh
\`\`\`

#### 5. 동작 확인
- [ ] http://localhost:8081/actuator/health 접속
- [ ] 모든 서비스 UP 확인

---

### Day 2-3: 프로젝트 이해

#### 1. 문서 읽기
- [ ] README.md
- [ ] docs/ARCHITECTURE.md
- [ ] docs/CONVENTIONS.md

#### 2. 코드 탐색
- [ ] User Service 코드 리뷰
- [ ] API 엔드포인트 테스트 (Postman/curl)

#### 3. 첫 번째 작업
- [ ] 간단한 버그 수정 또는 테스트 추가
- [ ] Pull Request 생성
- [ ] 코드 리뷰 받기

---

### Week 2: 첫 기능 개발

#### 1. 기능 선택
멘토와 함께 첫 번째 기능 선택

#### 2. 개발 프로세스
- [ ] 브랜치 생성 (\`feature/...\`)
- [ ] 로컬 개발
- [ ] 테스트 작성
- [ ] Pull Request

#### 3. 배포 프로세스 이해
- [ ] CI/CD 파이프라인 확인
- [ ] 스테이징 배포 관찰
- [ ] 프로덕션 배포 관찰

---

### Month 1: 독립적 작업

#### 1. 복잡한 기능 개발
멘토 도움 최소화, 독립적으로 작업

#### 2. 팀 프로세스 이해
- [ ] 스프린트 플래닝 참여
- [ ] 데일리 스탠드업 리드
- [ ] 회고 참여

#### 3. 지식 공유
- [ ] 배운 내용 문서화
- [ ] 팀 발표 (선택)

---

## 멘토 배정
- 멘토: @mentor-name
- 질문 환영!
```

---

## 팀 컨벤션

### 코드 스타일

```markdown
# docs/CONVENTIONS.md

## 코드 스타일

### Kotlin
- **포맷터**: IntelliJ IDEA 기본 + ktlint
- **네이밍**:
  - 클래스: PascalCase (\`UserService\`)
  - 함수: camelCase (\`getUserById\`)
  - 상수: UPPER_SNAKE_CASE (\`MAX_RETRY_COUNT\`)

### Docker 파일명
- 개발: \`Dockerfile.dev\`
- 프로덕션: \`Dockerfile\`
- 특정 서비스: \`Dockerfile.user-service\`

### Git 브랜치명
- 기능: \`feature/user-authentication\`
- 버그: \`fix/login-error\`
- 긴급: \`hotfix/security-patch\`

### 커밋 메시지
\`\`\`
<type>: <subject>

<body>

<footer>
\`\`\`

**예제**:
\`\`\`
feat: 사용자 인증 API 추가

- JWT 기반 인증 구현
- Refresh Token 로직 추가
- 로그인/로그아웃 엔드포인트

Closes #123
\`\`\`

### Docker Compose 서비스명
- 소문자, 하이픈 구분: \`user-service\`
- 일관성: 모든 서비스 동일한 네이밍 패턴

### 환경 변수명
- 대문자, 언더스코어 구분: \`DATABASE_URL\`
- 프리픽스 사용: \`USER_SERVICE_PORT\`, \`ACCOUNT_SERVICE_PORT\`
```

---

## 트러블슈팅 공유

### 팀 위키 (Confluence/Notion)

```markdown
## 해결된 문제 목록

### 2024-01-15: Docker 빌드 느림
**문제**:
이미지 빌드 시 10분 이상 소요

**원인**:
.dockerignore 누락으로 node_modules 전체 복사

**해결**:
\`\`\`
# .dockerignore 추가
node_modules/
.git/
*.log
\`\`\`

**해결한 사람**: @john
**관련 PR**: #456

---

### 2024-01-10: PostgreSQL 연결 실패
**문제**:
로컬 환경에서 PostgreSQL 연결 안됨

**원인**:
이전 컨테이너의 볼륨이 남아있어 충돌

**해결**:
\`\`\`bash
docker-compose down -v
docker-compose up -d
\`\`\`

**해결한 사람**: @jane
**관련 이슈**: #789
```

### Slack 채널 운영

```
#dev-general: 일반 개발 논의
#dev-help: 도움 요청
#dev-deploy: 배포 알림
#dev-docker: Docker 관련 논의
#dev-random: 잡담
```

---

## 👨‍💻 주니어 개발자 시나리오

### 시나리오 1: 첫 출근 - 환경 설정 해매기

**상황**:
```
신입 A (첫날): "환경 설정부터 시작하라고 하셨는데... 어떻게 하죠?"
시니어: "README 보고 따라하면 돼요."
신입 A (2시간 후): "Node.js 버전이 달라서 안 되는데요..."
시니어: "어... Docker 사용하세요."
신입 A: "Docker요? 그게 뭐죠?"
```

**단계별 해결**:
```bash
# 시니어가 제공한 가이드

# Step 1: Docker Desktop 설치
# https://www.docker.com/products/docker-desktop

# Step 2: 저장소 클론
git clone https://github.com/your-org/lk-trade.git
cd lk-trade

# Step 3: 환경 변수 복사
cp .env.example .env.dev

# Step 4: 시크릿 설정 (Slack DM으로 전달받음)
# .env.dev 파일 열어서 비밀번호 입력

# Step 5: 한 방에 실행!
docker-compose up -d

# Step 6: 확인
curl http://localhost:8081/actuator/health
# {"status":"UP"}

✅ 30분 만에 환경 설정 완료!
```

**배운 점**:
- Docker 덕분에 "내 컴퓨터에서는 안돼요" 없음
- README 잘 읽으면 금방 해결
- 시니어에게 물어보는 것 두려워하지 말기

---

### 시나리오 2: 코드 변경했는데 반영 안됨

**상황**:
```
주니어 B: "UserController.kt 수정했는데 API 응답이 안 바뀌어요!"
시니어: "재시작했어?"
주니어 B: "docker-compose restart 했는데요?"
시니어: "이미지 다시 빌드했어?"
주니어 B: "???"
```

**단계별 해결**:
```bash
# 문제 원인: 이미지 재빌드 안함
# docker-compose restart는 기존 이미지로 재시작만 함

# 해결 Step 1: 이미지 재빌드
docker-compose build user-service

# Step 2: 컨테이너 재시작
docker-compose up -d user-service

# 또는 한 번에:
docker-compose up -d --build user-service

# Step 3: 로그 확인
docker-compose logs -f user-service

# Step 4: 변경사항 확인
curl http://localhost:8081/api/users
# 새로운 응답!

✅ 해결!
```

**배운 점**:
- 코드 변경 시 이미지 재빌드 필수
- `restart`는 재시작만, `up --build`는 빌드 + 재시작
- 개발 중엔 볼륨 마운트 사용하면 핫 리로드 가능

---

### 시나리오 3: 팀원과 환경 차이로 버그 재현 안됨

**상황**:
```
주니어 C: "A 팀원이 보고한 버그를 재현할 수 없어요!"
A 팀원: "분명히 제 로컬에서는 에러가 나는데요..."
주니어 C: "제 환경에서는 정상이에요..."
```

**단계별 해결**:
```bash
# Step 1: 환경 차이 확인
# A 팀원 환경
docker-compose ps
# PostgreSQL 14

# C 팀원 환경
docker-compose ps
# PostgreSQL 15

# 아하! PostgreSQL 버전 차이!

# Step 2: docker-compose.yml 확인
services:
  postgres:
    image: postgres:latest  # ❌ 문제!
    # latest는 시간에 따라 변경됨

# Step 3: 버전 고정
services:
  postgres:
    image: postgres:15-alpine  # ✅ 버전 명시

# Step 4: 전체 재배포
docker-compose down -v
docker-compose up -d

# Step 5: 버그 재현 확인
# 이제 둘 다 동일한 환경!

✅ 해결!
```

**배운 점**:
- Docker 이미지 버전은 명시적으로 고정
- `latest` 태그는 위험 (시간에 따라 변경)
- 팀 전체가 동일한 `docker-compose.yml` 사용해야 함

---

### 시나리오 4: .env 파일을 Git에 커밋해버림

**상황**:
```
주니어 D: "환경 변수 설정하고 커밋했어요!"
시니어: "어... .env 파일도 커밋했네요?"
주니어 D: "네! 팀원들이 편하게 쓰라고요."
시니어: "그 안에 비밀번호가 다 들어있는데..."
주니어 D: "😱"
```

**단계별 해결**:
```bash
# 긴급 대응!

# Step 1: 커밋 되돌리기 (아직 push 안 했다면)
git reset HEAD~1

# Step 2: .env 파일 Git에서 제거
git rm --cached .env.dev

# Step 3: .gitignore 확인
cat .gitignore
# .env* 있는지 확인

# Step 4: 올바른 방법
# .env.example만 Git에 커밋
git add .env.example
git commit -m "docs: Add .env.example template"

# Step 5: 팀원들에게 알림
# Slack: ".env.dev 파일은 .env.example을 복사해서 사용하세요!"

# Step 6: 비밀번호 변경 (이미 노출됨)
# 1Password에서 비밀번호 재생성

✅ 해결! (하지만 식은땀...)
```

**배운 점**:
- .env 파일은 절대 Git에 커밋 금지!
- .env.example만 커밋 (실제 값 제외)
- 실수로 커밋했으면 즉시 비밀번호 변경
- .gitignore 설정 확인 습관화

---

## ❓ FAQ

<details>
<summary><strong>Q1: 팀원마다 포트가 충돌하는데 어떻게 해결하나요?</strong></summary>

**A**: `.env` 파일로 개인별 포트를 설정하면 됩니다.

**상세 설명**:

**문제 상황**:
```
개발자 A: localhost:8081에 이미 다른 앱이 떠있음
개발자 B: 5432 포트가 호스트 PostgreSQL과 충돌
```

**해결 방법**:

**1. .env.dev 파일에서 포트 변경**
```bash
# 개발자 A의 .env.dev
USER_SERVICE_PORT=9081  # 8081 대신
POSTGRES_PORT=5433      # 5432 대신
```

**2. docker-compose.yml에서 환경 변수 사용**
```yaml
services:
  user-service:
    ports:
      - "${USER_SERVICE_PORT:-8081}:8080"
```

**3. docker-compose.override.yml 활용 (개인 설정)**
```yaml
# docker-compose.override.yml (Git 제외)
version: '3.8'

services:
  user-service:
    ports:
      - "9081:8080"  # 개인 맞춤 포트
```

**Best Practice**:
- 팀 공통 설정: docker-compose.yml (Git 포함)
- 개인 맞춤 설정: docker-compose.override.yml (Git 제외)
- 환경 변수: .env.dev (Git 제외)

</details>

<details>
<summary><strong>Q2: 신입 개발자가 "Docker가 뭔지 모르겠어요"라고 하는데 어떻게 설명하나요?</strong></summary>

**A**: 간단한 비유로 시작하고, 실습으로 익히게 하세요!

**상세 설명**:

**1단계: 비유로 이해시키기**
```
"Docker는 이삿짐 컨테이너와 같아요.

🏠 옛날 이사:
- 짐을 하나하나 포장
- 트럭마다 짐 싣는 방법이 다름
- 도착해서 다시 하나하나 풀기
- 시간 오래 걸림 ❌

📦 컨테이너 이사:
- 모든 짐을 컨테이너에 담기
- 어떤 트럭이든 동일하게 실을 수 있음
- 도착해서 컨테이너째 내리기
- 빠르고 간편 ✅

🐳 Docker:
- 애플리케이션과 모든 의존성을 '컨테이너'에 담기
- 어떤 컴퓨터에서든 동일하게 실행
- 환경 차이 제로!"
```

**2단계: 실습으로 체감시키기**
```bash
# "한번 해볼까요?"

# 1. 프로젝트 클론
git clone https://github.com/your-org/lk-trade.git
cd lk-trade

# 2. 환경 변수 복사
cp .env.example .env.dev

# 3. 마법의 명령어!
docker-compose up -d

# 4. 확인
curl http://localhost:8081/actuator/health
# {"status":"UP"}

# "와! 30초 만에 전체 개발 환경이 떴어요!"
```

**3단계: 이점 설명**
```
Docker 없이:
1. Node.js 18 설치 (20분)
2. PostgreSQL 15 설치 (30분)
3. Redis 설치 (10분)
4. 환경 변수 설정 (20분)
5. 각종 에러 해결 (2시간)
→ 총 3시간 20분 ❌

Docker 사용:
1. docker-compose up -d (30초)
→ 총 30초 ✅

차이: 640배 빠름!
```

**Best Practice**:
- 이론보다 실습 먼저
- 비유로 쉽게 설명
- 즉각적인 성과를 보여주기

</details>

<details>
<summary><strong>Q3: .env 파일에 비밀번호를 공유하는 안전한 방법은?</strong></summary>

**A**: **절대 Git에 올리지 말고**, 1Password 같은 비밀번호 관리 도구를 사용하세요!

**상세 설명**:

**❌ 위험한 방법들**:
```bash
# 1. .env 파일을 Slack/이메일로 전송 ❌
# - 평문으로 전송됨
# - 채팅 히스토리에 영구 보관

# 2. .env 파일을 Git에 커밋 ❌
# - GitHub에 영구 기록
# - 공개 저장소면 전 세계에 노출

# 3. Google Drive/Dropbox 공유 ❌
# - 링크 유출 시 누구나 접근 가능
```

**✅ 안전한 방법**:

**방법 1: 1Password (추천!)**
```markdown
1. 1Password 팀 계정 생성
2. "LK-Trade Vault" 생성
3. 시크릿 저장:
   - POSTGRES_PASSWORD
   - OPENAI_API_KEY
   등

4. 팀원 초대:
   - 초대 링크 이메일 전송
   - 팀원이 1Password 앱 설치
   - Vault 접근 권한 부여

5. .env.dev 파일 생성:
   - .env.example 복사
   - 1Password에서 값 복사/붙여넣기
```

**방법 2: Doppler / Vault (대규모 팀)**
```bash
# Doppler CLI 설치
brew install dopplerhq/cli/doppler

# 로그인
doppler login

# 프로젝트 설정
doppler setup

# 시크릿 자동 주입하여 실행
doppler run -- docker-compose up -d
```

**방법 3: 개인 시크릿은 개별 발급**
```bash
# 팀 공용 시크릿: 1Password
POSTGRES_PASSWORD=...  # 1Password에서 관리
OPENAI_API_KEY=...     # 1Password에서 관리

# 개인 시크릿: 각자 발급
ALPACA_API_KEY=...     # 각자 Paper Trading 계정 생성
ALPACA_SECRET_KEY=...  # 각자 발급받기
```

**Git 설정**:
```gitignore
# .gitignore
.env
.env.dev
.env.local
.env.*.local

# .env.example만 Git에 포함
!.env.example
```

**Best Practice**:
- 시크릿은 절대 평문으로 전송 금지
- 1Password, LastPass 등 전용 도구 사용
- 개인 테스트 키는 각자 발급
- 정기적으로 비밀번호 갱신

</details>

<details>
<summary><strong>Q4: 팀원이 docker-compose.yml을 각자 수정해서 버전이 달라졌어요. 어떻게 통합하나요?</strong></summary>

**A**: **Git으로 표준 버전 관리** + **개인 설정은 override 파일 사용**!

**상세 설명**:

**문제 상황**:
```
개발자 A의 docker-compose.yml:
services:
  postgres:
    image: postgres:14

개발자 B의 docker-compose.yml:
services:
  postgres:
    image: postgres:15

개발자 C의 docker-compose.yml:
services:
  postgres:
    image: postgres:latest

→ 환경이 달라서 버그 재현 안됨!
```

**해결 단계**:

**Step 1: 표준 docker-compose.yml 합의**
```yaml
# docker-compose.dev.yml (팀 표준)
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine  # 버전 명시!
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
```

**Step 2: Git에 커밋**
```bash
git add docker-compose.dev.yml
git commit -m "chore: Standardize development environment"
git push origin main
```

**Step 3: 개인 설정은 override 사용**
```yaml
# docker-compose.override.yml (개인 맞춤, Git 제외)
version: '3.8'

services:
  postgres:
    ports:
      - "5433:5432"  # 개인 포트 변경
    environment:
      POSTGRES_MAX_CONNECTIONS: 200  # 개인 설정 추가
```

**Step 4: 팀원들에게 안내**
```markdown
# 팀 공지 (Slack)

📢 docker-compose.yml 표준화 완료!

**앞으로의 규칙**:
1. `docker-compose.dev.yml`: 팀 표준 (Git 포함)
   - 절대 임의로 수정 금지!
   - 변경 필요 시 PR로 제안

2. `docker-compose.override.yml`: 개인 맞춤 (Git 제외)
   - 포트 충돌 등 개인 환경 문제 해결
   - 이 파일로 개인 설정 추가

**마이그레이션**:
```bash
# 1. 최신 코드 받기
git pull origin main

# 2. 기존 컨테이너 정리
docker-compose down -v

# 3. 새 환경으로 시작
docker-compose up -d
```
```

**Best Practice**:
- 팀 표준: Git으로 버전 관리
- 개인 설정: override 파일 활용
- 변경 시 PR + 코드 리뷰
- 정기적으로 표준 환경 동기화

</details>

<details>
<summary><strong>Q5: 원격 근무 팀원과 협업 시 주의사항은?</strong></summary>

**A**: **비동기 커뮤니케이션 + 명확한 문서화 + 자동화**!

**상세 설명**:

**원격 팀 협업 원칙**:

**1. 비동기 커뮤니케이션**
```
❌ 나쁜 예:
"이거 어떻게 하는 거예요?" (Slack DM)
→ 상대방이 5시간 후에 봄
→ 업무 중단

✅ 좋은 예:
"user-service 빌드 실패 이슈입니다.
에러 로그: [첨부]
시도한 방법:
1. docker-compose build 재실행
2. 캐시 삭제 후 재빌드
3. Docker Desktop 재시작

여전히 해결 안 됩니다. 조언 부탁드립니다!"

→ 충분한 정보 제공
→ 상대방이 시간 날 때 답변 가능
```

**2. 명확한 문서화**
```markdown
# docs/SETUP.md (필수!)

## 환경 설정 (예상 시간: 10분)

### 1. Docker Desktop 설치
[다운로드 링크]

### 2. 저장소 클론
\`\`\`bash
git clone https://github.com/your-org/lk-trade.git
cd lk-trade
\`\`\`

### 3. 환경 변수 설정
\`\`\`bash
cp .env.example .env.dev
\`\`\`

### 4. 시크릿 획득
[1Password 가이드 링크]

### 5. 환경 시작
\`\`\`bash
docker-compose up -d
\`\`\`

### 6. 확인
http://localhost:8081/actuator/health

### 트러블슈팅
- 포트 충돌: [링크]
- DB 연결 실패: [링크]
```

**3. 자동화 스크립트**
```bash
#!/bin/bash
# scripts/morning-start.sh
# 매일 아침 이 스크립트만 실행하면 환경 준비 완료

echo "🌅 좋은 아침! 개발 환경을 시작합니다..."

# 1. 최신 코드 받기
git pull origin develop

# 2. 이미지 재빌드 (필요 시)
docker-compose build

# 3. 컨테이너 시작
docker-compose up -d

# 4. 헬스체크
sleep 10
curl -f http://localhost:8081/actuator/health && echo "✅ User Service" || echo "❌ User Service"
curl -f http://localhost:8082/actuator/health && echo "✅ Account Service" || echo "❌ Account Service"

echo "🎉 준비 완료! 개발 시작하세요!"
```

**4. 코드 리뷰 문화**
```markdown
# Pull Request 규칙

## 필수 항목
- [ ] 변경 사항 설명 (왜 필요한지)
- [ ] 테스트 방법 (재현 단계)
- [ ] 스크린샷 (UI 변경 시)
- [ ] 로컬에서 동작 확인

## 리뷰 시간
- 24시간 내 1차 리뷰 (긴급 아닌 경우)
- 피드백 후 48시간 내 수정

## 리뷰 태도
- 친절하게, 구체적으로
- "이렇게 하면 어떨까요?" (제안)
- "이 방법도 고려해보셨나요?" (질문)
```

**5. 타임존 고려**
```
팀 구성:
- 개발자 A: 한국 (UTC+9)
- 개발자 B: 미국 서부 (UTC-8)
- 개발자 C: 독일 (UTC+1)

중복 시간대:
한국 18:00 = 미국 01:00 = 독일 10:00
→ 실시간 회의는 이 시간대에

비동기 작업:
- GitHub Issues, PR로 작업 공유
- Slack 스레드로 논의
- Notion/Confluence로 문서화
```

**Best Practice**:
- 문서화가 생명
- 스크린샷, 로그 첨부
- 자동화로 수작업 최소화
- 타임존 존중
- 비동기 우선, 실시간은 필요시만

</details>

---

## 📝 면접 질문

### 주니어 레벨

**Q1: Docker를 사용한 팀 협업의 가장 큰 장점은 무엇인가요?**

**A**: **"내 컴퓨터에서는 되는데" 문제를 완전히 제거**할 수 있습니다.

**상세 답변**:

Docker 없이 협업할 때의 문제:
```
개발자 A: Node.js 16, PostgreSQL 14
개발자 B: Node.js 18, PostgreSQL 15
개발자 C: Node.js 20, PostgreSQL 13

→ 환경이 달라서 버그 재현 안됨
→ "제 컴퓨터에서는 정상인데요?"
→ 디버깅에 시간 낭비
```

Docker 사용 시:
```yaml
# docker-compose.yml (모든 팀원 동일)
services:
  app:
    image: node:18-alpine

  postgres:
    image: postgres:15-alpine

→ 모든 팀원이 동일한 환경
→ 버그 재현율 100%
→ 생산성 대폭 향상
```

**핵심 이점**:
1. **환경 일관성**: 모든 팀원이 동일한 환경
2. **빠른 온보딩**: 신입 개발자도 30분 내 환경 구축
3. **프로덕션 일치**: 개발 환경 = 프로덕션 환경
4. **의존성 격리**: 프로젝트별 독립된 환경

**실무 예시**:
```bash
# 신입 개발자의 첫날
git clone https://github.com/company/project.git
cd project
docker-compose up -d

# 끝! 30초 만에 환경 구축 완료
```

---

**Q2: .env 파일은 Git에 커밋해야 하나요, 말아야 하나요? 이유는?**

**A**: **절대 커밋하면 안 됩니다!** 대신 `.env.example`을 커밋해야 합니다.

**상세 답변**:

**❌ .env 파일을 커밋하면 안 되는 이유**:
```bash
# .env 파일 내용
DATABASE_PASSWORD=super_secret_password_123
OPENAI_API_KEY=sk-proj-abc123xyz...
AWS_SECRET_KEY=wJalrXUtnFEMI/K7MDENG...

# Git에 커밋하면:
1. GitHub에 영구 기록됨
2. 공개 저장소면 전 세계에 노출
3. 삭제해도 Git 히스토리에 남음
4. 보안 위협 (계정 탈취, 과금 폭탄)
```

**✅ 올바른 방법**:
```bash
# 1. .env.example 생성 (실제 값 제외)
DATABASE_HOST=postgres
DATABASE_PORT=5432
DATABASE_USER=myuser
DATABASE_PASSWORD=  # 1Password에서 확인
OPENAI_API_KEY=     # 1Password에서 확인

# 2. .gitignore에 추가
.env
.env.dev
.env.local
.env.*.local

# 3. .env.example만 Git에 커밋
git add .env.example
git commit -m "docs: Add environment variables template"

# 4. 팀원은 .env.example 복사 후 실제 값 입력
cp .env.example .env.dev
# .env.dev 편집하여 1Password에서 비밀번호 복사
```

**시크릿 관리 Best Practice**:
- 개발: 1Password, LastPass
- 프로덕션: AWS Secrets Manager, HashiCorp Vault
- CI/CD: GitHub Secrets, GitLab CI/CD Variables

**실수로 커밋했을 때**:
```bash
# 1. 즉시 비밀번호 변경!
# 2. Git 히스토리에서 완전 삭제
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch .env" \
  --prune-empty --tag-name-filter cat -- --all

# 3. 강제 푸시
git push origin --force --all
```

---

### 중급 레벨

**Q3: 여러 개발자가 docker-compose.yml을 동시에 수정하려 할 때, 충돌을 방지하는 전략은?**

**A**: **표준 설정과 개인 설정을 분리**하고, **변경 시 PR + 코드 리뷰** 프로세스를 거칩니다.

**상세 답변**:

**전략 1: 계층화된 설정 파일**
```yaml
# 1. docker-compose.yml (기본, Git 포함)
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    ports:
      - "5432:5432"

# 2. docker-compose.dev.yml (개발 환경, Git 포함)
version: '3.8'
services:
  postgres:
    environment:
      POSTGRES_DB: myapp_dev

# 3. docker-compose.override.yml (개인 설정, Git 제외)
version: '3.8'
services:
  postgres:
    ports:
      - "5433:5432"  # 개인 포트 변경
```

**실행 방법**:
```bash
# Docker Compose는 자동으로 병합:
# 1. docker-compose.yml
# 2. docker-compose.override.yml (있다면)

docker-compose up -d

# 명시적으로 파일 지정:
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
```

**전략 2: PR + 코드 리뷰 프로세스**
```
개발자 A: "Redis 추가하고 싶어요"

1. 브랜치 생성
git checkout -b feature/add-redis

2. docker-compose.yml 수정
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

3. PR 생성
- 제목: "feat: Add Redis for caching"
- 설명: Redis 캐싱 레이어 추가
- 리뷰어: @team-lead, @senior-dev

4. 팀 리뷰 및 승인
- "포트가 겹칠 수 있으니 환경 변수로 처리하면 어떨까요?"
- 수정 반영

5. Merge 후 팀 공지
"Redis가 추가되었습니다. docker-compose up -d 재실행 부탁드립니다!"
```

**전략 3: 환경 변수로 유연성 확보**
```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:${POSTGRES_VERSION:-15}-alpine
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
```

```bash
# .env.dev (개인 설정)
POSTGRES_VERSION=14  # 개인적으로 14 사용
POSTGRES_PORT=5433   # 포트 충돌 회피
```

**팀 컨벤션 문서화**:
```markdown
# docs/CONVENTIONS.md

## Docker Compose 변경 규칙

1. **표준 설정 변경** (docker-compose.yml)
   - 반드시 PR 생성
   - 최소 2명 이상 리뷰 필요
   - 팀 전체에 영향을 주므로 신중히

2. **개인 설정** (docker-compose.override.yml)
   - Git에 커밋 금지
   - 개인 환경 문제 해결용

3. **커밋 메시지**
   - feat: 새 서비스 추가
   - fix: 설정 버그 수정
   - chore: 버전 업데이트
```

**핵심 포인트**:
- 표준과 개인 설정 분리
- 변경 시 PR + 리뷰
- 환경 변수로 유연성 확보
- 팀 컨벤션 문서화

---

**Q4: 신입 개발자 온보딩 시간을 3일에서 30분으로 줄이는 방법은?**

**A**: **자동화 스크립트 + 명확한 문서 + Docker 환경**을 조합합니다.

**상세 답변**:

**Before (3일 소요)**:
```
Day 1: 개발 환경 설정
- Node.js 18 설치 (1시간)
- PostgreSQL 15 설치 및 설정 (2시간)
- Redis 설치 (30분)
- 환경 변수 설정 (1시간)
- 각종 오류 해결 (4시간)

Day 2: 코드 이해
- 프로젝트 구조 파악 (3시간)
- 의존성 이해 (2시간)
- 빌드 및 실행 (3시간)

Day 3: 첫 작업
- 간단한 버그 수정 시도
- 환경 문제로 계속 실패
```

**After (30분 소요)**:

**1. 자동화 스크립트 작성**
```bash
#!/bin/bash
# scripts/onboarding.sh

echo "🎉 LK-Trade 온보딩을 시작합니다!"

# Step 1: 사전 확인
echo "📋 Step 1: 사전 확인"
command -v docker >/dev/null 2>&1 || { echo "Docker를 먼저 설치하세요: https://docker.com"; exit 1; }
command -v git >/dev/null 2>&1 || { echo "Git을 먼저 설치하세요"; exit 1; }

# Step 2: 환경 변수 복사
echo "⚙️  Step 2: 환경 변수 설정"
if [ ! -f .env.dev ]; then
    cp .env.example .env.dev
    echo "⚠️  .env.dev 파일을 열어 비밀번호를 입력하세요 (1Password 참조)"
    echo "완료 후 엔터를 누르세요..."
    read
fi

# Step 3: Docker 환경 시작
echo "🐳 Step 3: Docker 환경 시작"
docker-compose up -d

# Step 4: 헬스체크
echo "🏥 Step 4: 서비스 확인"
sleep 15
curl -f http://localhost:8081/actuator/health && echo "✅ User Service" || echo "❌ User Service 실패"
curl -f http://localhost:8082/actuator/health && echo "✅ Account Service" || echo "❌ Account Service 실패"

# Step 5: 완료
echo ""
echo "🎊 온보딩 완료!"
echo ""
echo "다음 URL에서 서비스를 확인하세요:"
echo "  - User Service: http://localhost:8081"
echo "  - Account Service: http://localhost:8082"
echo "  - pgAdmin: http://localhost:5050"
echo ""
echo "문제가 있다면 docs/TROUBLESHOOTING.md를 확인하거나 #dev-help 채널에 문의하세요!"
```

**2. 명확한 README.md**
```markdown
# LK-Trade 프로젝트

## 빠른 시작 (5분)

### 사전 요구사항
- [ ] Docker Desktop 설치
- [ ] Git 설치
- [ ] 1Password 계정 (팀 초대 메일 확인)

### 환경 구축
\`\`\`bash
# 1. 저장소 클론
git clone https://github.com/your-org/lk-trade.git
cd lk-trade

# 2. 온보딩 스크립트 실행
./scripts/onboarding.sh

# 3. 끝! 개발 시작
\`\`\`

### 트러블슈팅
문제가 있나요? → [TROUBLESHOOTING.md](docs/TROUBLESHOOTING.md)
```

**3. 체크리스트 제공**
```markdown
# docs/ONBOARDING_CHECKLIST.md

## 신입 개발자 체크리스트

### Day 1 (30분)
- [ ] GitHub 계정 팀 Organization에 초대됨
- [ ] Slack 계정 생성 및 채널 참여
- [ ] 1Password 초대 수락
- [ ] Docker Desktop 설치
- [ ] 저장소 클론
- [ ] ./scripts/onboarding.sh 실행
- [ ] http://localhost:8081 접속 확인

### Day 1 오후 (2시간)
- [ ] README.md 읽기
- [ ] docs/ARCHITECTURE.md 읽기
- [ ] 팀 소개 미팅

### Day 2
- [ ] 간단한 버그 수정 (멘토가 배정)
- [ ] 첫 PR 생성
- [ ] 코드 리뷰 경험

### Week 1
- [ ] 첫 기능 개발
- [ ] 팀 회의 참여
```

**효과 측정**:
| 단계 | Before | After |
|------|--------|-------|
| 환경 구축 | 8시간 | 5분 |
| 문서 읽기 | 4시간 | 1시간 |
| 첫 작업 | 8시간 | 2시간 |
| **총 온보딩 시간** | **3일** | **0.5일** |

**핵심 요소**:
1. 자동화 스크립트 (onboarding.sh)
2. Docker로 환경 일관성
3. 명확한 문서 (README, TROUBLESHOOTING)
4. 체크리스트 제공
5. 멘토 배정

---

**Q5: 원격 근무 환경에서 Docker를 활용한 협업 시 가장 중요한 점은?**

**A**: **비동기 커뮤니케이션 + 철저한 문서화 + 재현 가능한 환경**입니다.

**상세 답변**:

**원격 근무의 도전 과제**:
```
문제 1: 시간대 차이
- 한국: UTC+9
- 미국 서부: UTC-8
- 실시간 소통 어려움

문제 2: 환경 차이 디버깅
- "제 컴퓨터에서는 되는데요" (화상 통화 어려움)
- 환경 차이 원격으로 해결 난이도 높음

문제 3: 암묵적 지식 전달 불가
- 오프라인: 옆 자리에서 물어봄
- 원격: 모든 것을 명시적으로 문서화해야 함
```

**Docker + 협업 도구로 해결**:

**1. 환경 재현성 100%**
```yaml
# docker-compose.yml
# 전 세계 어디서든 동일한 환경

services:
  app:
    image: node:18-alpine
    volumes:
      - ./src:/app/src  # 코드만 마운트
    environment:
      DATABASE_URL: postgresql://postgres:5432/mydb
      REDIS_URL: redis://redis:6379
```

```bash
# 한국 개발자
docker-compose up -d
# 환경: Node 18, PostgreSQL 15, Redis 7

# 미국 개발자
docker-compose up -d
# 환경: Node 18, PostgreSQL 15, Redis 7 (동일!)
```

**2. 비동기 커뮤니케이션**
```markdown
# GitHub Issue로 문제 공유

**제목**: User Service 컨테이너 시작 실패

**환경**:
- OS: Windows 11
- Docker Desktop: 4.25.0
- 브랜치: feature/user-auth

**재현 단계**:
1. \`git checkout feature/user-auth\`
2. \`docker-compose up -d user-service\`
3. 컨테이너 즉시 종료

**에러 로그**:
\`\`\`
docker logs user-service
Error: Cannot find module 'express'
\`\`\`

**시도한 해결 방법**:
1. \`docker-compose build --no-cache\` → 실패
2. \`npm install\` 재실행 → 실패
3. Docker Desktop 재시작 → 실패

**요청**:
조언 부탁드립니다!
```

→ 충분한 정보 제공, 다른 시간대 팀원도 즉시 도움 가능

**3. 재현 가능한 환경**
```bash
# scripts/reproduce-issue.sh
# 버그 재현 환경 자동 구축

#!/bin/bash
echo "🐛 Issue #123 재현 환경 구축"

# 1. 해당 브랜치 체크아웃
git checkout issue-123-user-auth-fail

# 2. 환경 정리
docker-compose down -v

# 3. 이미지 재빌드
docker-compose build

# 4. 컨테이너 시작
docker-compose up -d

# 5. 버그 재현
curl http://localhost:8081/api/login
# 예상: 500 Internal Server Error

echo "버그가 재현되었나요? (yes/no)"
```

**4. 문서화된 트러블슈팅**
```markdown
# docs/TROUBLESHOOTING.md

## 원격 협업 시 자주 발생하는 문제

### 컨테이너 시작 실패
**증상**: \`docker-compose up -d\` 후 컨테이너 즉시 종료

**원인**: 의존성 설치 안됨

**해결**:
\`\`\`bash
docker-compose build --no-cache
docker-compose up -d
\`\`\`

**관련 이슈**: #45, #67, #89
**해결 시간**: 평균 2분
```

**5. 자동화된 CI/CD**
```yaml
# .github/workflows/pr-check.yml
# PR 생성 시 자동으로 환경 검증

name: PR Check

on: [pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Start Docker environment
        run: docker-compose up -d

      - name: Wait for services
        run: sleep 30

      - name: Health check
        run: |
          curl -f http://localhost:8081/health || exit 1
          curl -f http://localhost:8082/health || exit 1

      - name: Run tests
        run: docker-compose exec -T app npm test
```

**Best Practice**:
- 모든 커뮤니케이션을 GitHub Issues/PR로
- 재현 가능한 환경 스크립트 제공
- 트러블슈팅 문서 지속 업데이트
- CI/CD로 자동 검증
- 비동기 우선, 실시간은 주 1회 정도

**효과**:
- 시간대 차이 극복
- 환경 차이 제로
- 온보딩 시간 단축
- 팀 생산성 향상

---

## 다음 단계

### 24. 리소스 제한과 관리
- CPU, 메모리 제한
- 디스크 I/O 제한
- 리소스 모니터링

### 학습 자료

**팀 협업**:
- [GitHub Flow](https://guides.github.com/introduction/flow/)
- [Trunk Based Development](https://trunkbaseddevelopment.com/)

**문서화**:
- [Write the Docs](https://www.writethedocs.org/)
- [Documentation Guide](https://www.divio.com/blog/documentation/)

---

**축하합니다! 🎉** 효율적인 팀 협업 환경을 구축했습니다!
