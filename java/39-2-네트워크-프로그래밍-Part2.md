# 39장 네트워크 프로그래밍 - Part 2: HTTP와 URL 처리

> **학습 목표**: HTTP 통신과 URL 클래스를 활용하여 웹 리소스를 가져올 수 있다

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐☆☆ (3/5)

---

## 📚 URL 클래스

### URL이란?

```
URL (Uniform Resource Locator):
인터넷 자원의 주소

구조:
protocol://host:port/path?query#fragment
   ↓       ↓     ↓    ↓     ↓      ↓
 http  google.com 80 /search q=java #top

예시:
https://www.example.com:8080/api/users?id=123#section1
  ↓         ↓            ↓      ↓      ↓        ↓
프로토콜   호스트        포트   경로   쿼리     프래그먼트
```

### URL 클래스 사용

```java
import java.net.*;
import java.io.*;

public class URLExample {
    public static void main(String[] args) throws Exception {
        // URL 생성
        URL url = new URL("https://www.google.com/search?q=java");

        // URL 정보 출력
        System.out.println("프로토콜: " + url.getProtocol());
        System.out.println("호스트: " + url.getHost());
        System.out.println("포트: " + url.getPort());  // -1 (기본)
        System.out.println("경로: " + url.getPath());
        System.out.println("쿼리: " + url.getQuery());
        System.out.println("전체 URL: " + url.toString());

        // 웹 페이지 읽기
        System.out.println("\n=== 웹 페이지 내용 ===");
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(url.openStream()))) {

            String line;
            int count = 0;
            while ((line = reader.readLine()) != null && count++ < 10) {
                System.out.println(line);
            }
        }
    }
}
```

**출력**:
```
프로토콜: https
호스트: www.google.com
포트: -1
경로: /search
쿼리: q=java
전체 URL: https://www.google.com/search?q=java

=== 웹 페이지 내용 ===
<!doctype html>
<html lang="ko">
<head>
...
```

---

## 🌐 HttpURLConnection

### 기본 GET 요청

```java
import java.net.*;
import java.io.*;

public class HttpGetExample {
    public static void main(String[] args) {
        String urlString = "https://jsonplaceholder.typicode.com/posts/1";

        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();

            // GET 요청 설정
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);  // 5초
            conn.setReadTimeout(5000);

            // 응답 코드
            int responseCode = conn.getResponseCode();
            System.out.println("응답 코드: " + responseCode);

            if (responseCode == 200) {  // HTTP_OK
                // 응답 읽기
                BufferedReader in = new BufferedReader(
                    new InputStreamReader(conn.getInputStream()));

                String line;
                StringBuilder response = new StringBuilder();
                while ((line = in.readLine()) != null) {
                    response.append(line);
                }
                in.close();

                System.out.println("\n응답 내용:");
                System.out.println(response.toString());
            } else {
                System.out.println("요청 실패");
            }

            conn.disconnect();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**출력**:
```
응답 코드: 200

응답 내용:
{
  "userId": 1,
  "id": 1,
  "title": "sunt aut facere repellat provident",
  "body": "quia et suscipit..."
}
```

---

### POST 요청 (데이터 전송)

```java
import java.net.*;
import java.io.*;

public class HttpPostExample {
    public static void main(String[] args) {
        String urlString = "https://jsonplaceholder.typicode.com/posts";

        try {
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();

            // POST 요청 설정
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "application/json");
            conn.setDoOutput(true);  // POST에 필수!

            // JSON 데이터
            String jsonData = """
                {
                    "title": "테스트 제목",
                    "body": "테스트 본문",
                    "userId": 1
                }
                """;

            // 데이터 전송
            try (OutputStream os = conn.getOutputStream()) {
                byte[] input = jsonData.getBytes("utf-8");
                os.write(input, 0, input.length);
            }

            // 응답 코드
            int responseCode = conn.getResponseCode();
            System.out.println("응답 코드: " + responseCode);

            // 응답 읽기
            if (responseCode == 201) {  // HTTP_CREATED
                BufferedReader in = new BufferedReader(
                    new InputStreamReader(conn.getInputStream()));

                String line;
                StringBuilder response = new StringBuilder();
                while ((line = in.readLine()) != null) {
                    response.append(line);
                }
                in.close();

                System.out.println("\n생성된 리소스:");
                System.out.println(response.toString());
            }

            conn.disconnect();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**출력**:
```
응답 코드: 201

생성된 리소스:
{
  "title": "테스트 제목",
  "body": "테스트 본문",
  "userId": 1,
  "id": 101
}
```

---

## 📊 HTTP 상태 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| 200 | OK | 성공 |
| 201 | Created | 리소스 생성 성공 |
| 204 | No Content | 성공 (응답 본문 없음) |
| 400 | Bad Request | 잘못된 요청 |
| 401 | Unauthorized | 인증 필요 |
| 403 | Forbidden | 권한 없음 |
| 404 | Not Found | 리소스 없음 |
| 500 | Internal Server Error | 서버 오류 |
| 503 | Service Unavailable | 서비스 불가 |

---

## 🏢 실무 사례 1: 네이버 뉴스 크롤러 (RSS 수집)

### 배경
네이버 뉴스팀에서 언론사 RSS를 주기적으로 수집하여 뉴스 데이터베이스에 저장하는 시스템

### 요구사항
- 100개 언론사 RSS 동시 수집
- 실패 시 재시도 로직 (최대 3회)
- 타임아웃 처리 (10초)
- 배치 처리 (5분마다)

### 전체 코드

```java
import java.net.*;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;

/**
 * 네이버 뉴스 크롤러
 * - 100개 언론사 RSS 동시 수집
 * - 재시도 로직, 타임아웃 처리
 * - 배치 스케줄링
 */
public class NaverNewsCrawler {
    private static final int TIMEOUT = 10000;  // 10초
    private static final int MAX_RETRY = 3;
    private static final int THREAD_POOL_SIZE = 20;

    // 언론사 RSS 목록
    private static final List<String> RSS_URLS = Arrays.asList(
        "https://news.example.com/rss/politics.xml",
        "https://news.example.com/rss/economy.xml",
        "https://news.example.com/rss/society.xml"
        // ... 100개 언론사
    );

    public static void main(String[] args) {
        NaverNewsCrawler crawler = new NaverNewsCrawler();

        // 배치 스케줄링: 5분마다 실행
        ScheduledExecutorService scheduler =
            Executors.newScheduledThreadPool(1);

        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("\n=== 뉴스 수집 시작: " +
                new java.util.Date() + " ===");
            crawler.crawlAllNews();
        }, 0, 5, TimeUnit.MINUTES);
    }

    /**
     * 모든 RSS 수집
     */
    public void crawlAllNews() {
        ExecutorService executor =
            Executors.newFixedThreadPool(THREAD_POOL_SIZE);

        List<Future<CrawlResult>> futures = new ArrayList<>();

        for (String rssUrl : RSS_URLS) {
            Future<CrawlResult> future = executor.submit(() ->
                crawlRSS(rssUrl)
            );
            futures.add(future);
        }

        // 결과 집계
        int success = 0, fail = 0, totalArticles = 0;

        for (Future<CrawlResult> future : futures) {
            try {
                CrawlResult result = future.get(15, TimeUnit.SECONDS);
                if (result.success) {
                    success++;
                    totalArticles += result.articleCount;
                } else {
                    fail++;
                }
            } catch (Exception e) {
                fail++;
                System.err.println("타임아웃: " + e.getMessage());
            }
        }

        executor.shutdown();

        System.out.println("\n=== 수집 완료 ===");
        System.out.println("성공: " + success + "개");
        System.out.println("실패: " + fail + "개");
        System.out.println("수집 기사: " + totalArticles + "건");
    }

    /**
     * RSS 수집 (재시도 로직 포함)
     */
    private CrawlResult crawlRSS(String rssUrl) {
        for (int retry = 0; retry < MAX_RETRY; retry++) {
            try {
                // HTTP 요청
                URL url = new URL(rssUrl);
                HttpURLConnection conn =
                    (HttpURLConnection) url.openConnection();

                // 요청 설정
                conn.setRequestMethod("GET");
                conn.setConnectTimeout(TIMEOUT);
                conn.setReadTimeout(TIMEOUT);
                conn.setRequestProperty("User-Agent",
                    "NaverNewsBot/1.0");

                int responseCode = conn.getResponseCode();

                if (responseCode == 200) {
                    // XML 파싱
                    List<Article> articles = parseRSS(
                        conn.getInputStream());

                    // DB 저장 (생략)
                    saveArticles(articles);

                    System.out.println("✅ 성공: " + rssUrl +
                        " (" + articles.size() + "건)");

                    conn.disconnect();
                    return new CrawlResult(true, articles.size());

                } else {
                    System.err.println("❌ HTTP 오류 " +
                        responseCode + ": " + rssUrl);
                }

                conn.disconnect();

            } catch (SocketTimeoutException e) {
                System.err.println("⏰ 타임아웃 (재시도 " +
                    (retry + 1) + "/" + MAX_RETRY + "): " + rssUrl);

            } catch (Exception e) {
                System.err.println("❌ 오류: " + rssUrl +
                    " - " + e.getMessage());
            }

            // 재시도 전 대기 (exponential backoff)
            try {
                Thread.sleep(1000 * (retry + 1));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        return new CrawlResult(false, 0);
    }

    /**
     * RSS XML 파싱
     */
    private List<Article> parseRSS(InputStream inputStream) {
        List<Article> articles = new ArrayList<>();

        try {
            DocumentBuilderFactory factory =
                DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            Document doc = builder.parse(inputStream);

            NodeList items = doc.getElementsByTagName("item");

            for (int i = 0; i < items.getLength(); i++) {
                Element item = (Element) items.item(i);

                String title = getTagValue("title", item);
                String link = getTagValue("link", item);
                String description = getTagValue("description", item);
                String pubDate = getTagValue("pubDate", item);

                articles.add(new Article(title, link,
                    description, pubDate));
            }

        } catch (Exception e) {
            System.err.println("XML 파싱 오류: " + e.getMessage());
        }

        return articles;
    }

    private String getTagValue(String tag, Element element) {
        NodeList nodeList = element.getElementsByTagName(tag);
        if (nodeList.getLength() > 0) {
            Node node = nodeList.item(0);
            if (node.hasChildNodes()) {
                return node.getFirstChild().getNodeValue();
            }
        }
        return "";
    }

    /**
     * DB 저장 (Mock)
     */
    private void saveArticles(List<Article> articles) {
        // 실제로는 JDBC로 MySQL에 저장
        // INSERT INTO articles (title, link, ...) VALUES (?, ?, ...)
    }

    // DTO 클래스
    static class Article {
        String title, link, description, pubDate;

        Article(String title, String link, String description,
                String pubDate) {
            this.title = title;
            this.link = link;
            this.description = description;
            this.pubDate = pubDate;
        }
    }

    static class CrawlResult {
        boolean success;
        int articleCount;

        CrawlResult(boolean success, int articleCount) {
            this.success = success;
            this.articleCount = articleCount;
        }
    }
}
```

### 실행 결과

```
=== 뉴스 수집 시작: Fri Jan 10 14:00:00 KST 2025 ===
✅ 성공: https://news.example.com/rss/politics.xml (15건)
✅ 성공: https://news.example.com/rss/economy.xml (20건)
⏰ 타임아웃 (재시도 1/3): https://news.slow.com/rss/sports.xml
✅ 성공: https://news.slow.com/rss/sports.xml (18건)
✅ 성공: https://news.example.com/rss/society.xml (12건)
...

=== 수집 완료 ===
성공: 98개
실패: 2개
수집 기사: 1,847건

=== 뉴스 수집 시작: Fri Jan 10 14:05:00 KST 2025 ===
...
```

### 핵심 기술

1. **재시도 로직**
```java
for (int retry = 0; retry < MAX_RETRY; retry++) {
    try {
        // HTTP 요청
        if (성공) return;
    } catch (SocketTimeoutException e) {
        // exponential backoff
        Thread.sleep(1000 * (retry + 1));
    }
}
```

2. **타임아웃 설정**
```java
conn.setConnectTimeout(10000);  // 연결 타임아웃
conn.setReadTimeout(10000);     // 읽기 타임아웃
```

3. **병렬 처리**
```java
ExecutorService executor =
    Executors.newFixedThreadPool(20);  // 20개 스레드
for (String url : urls) {
    executor.submit(() -> crawlRSS(url));
}
```

### 성과
- **처리량**: 100개 언론사 RSS → 1,800건 기사/5분
- **성공률**: 98% (재시도 덕분에 일시적 네트워크 오류 극복)
- **운영 비용**: 자동화로 인건비 월 1,000만원 절감

---

## 🏢 실무 사례 2: 카카오페이 PG사 결제 검증 API

### 배경
카카오페이에서 외부 PG사(토스페이먼츠, 이니시스)에 결제 승인 요청 및 검증

### 요구사항
- 결제 승인 API POST 요청
- 실패 시 자동 롤백
- 재시도 로직 (멱등성 보장)
- 응답 시간 모니터링

### 전체 코드

```java
import java.net.*;
import java.io.*;
import java.util.*;

/**
 * 카카오페이 결제 검증 시스템
 * - PG사 API 연동
 * - 재시도 및 롤백 로직
 * - 멱등성 보장 (idempotency key)
 */
public class KakaoPayPaymentGateway {
    private static final String PG_API_URL =
        "https://api.tosspayments.com/v1/payments/confirm";
    private static final String SECRET_KEY = "test_sk_12345";
    private static final int TIMEOUT = 5000;  // 5초
    private static final int MAX_RETRY = 2;

    public static void main(String[] args) {
        KakaoPayPaymentGateway gateway = new KakaoPayPaymentGateway();

        // 테스트: 결제 승인
        PaymentRequest request = new PaymentRequest(
            "pay_abc123",      // paymentKey
            "order_xyz789",    // orderId
            50000              // amount (50,000원)
        );

        PaymentResult result = gateway.confirmPayment(request);

        if (result.success) {
            System.out.println("✅ 결제 성공!");
            System.out.println("거래 ID: " + result.transactionId);
            System.out.println("승인 번호: " + result.approvalNumber);
        } else {
            System.out.println("❌ 결제 실패: " + result.errorMessage);
        }
    }

    /**
     * 결제 승인 요청 (재시도 포함)
     */
    public PaymentResult confirmPayment(PaymentRequest request) {
        String idempotencyKey = generateIdempotencyKey(request);

        for (int retry = 0; retry <= MAX_RETRY; retry++) {
            long startTime = System.currentTimeMillis();

            try {
                // HTTP POST 요청
                URL url = new URL(PG_API_URL);
                HttpURLConnection conn =
                    (HttpURLConnection) url.openConnection();

                // 요청 설정
                conn.setRequestMethod("POST");
                conn.setRequestProperty("Content-Type",
                    "application/json");
                conn.setRequestProperty("Authorization",
                    "Basic " + encodeBase64(SECRET_KEY + ":"));
                conn.setRequestProperty("Idempotency-Key",
                    idempotencyKey);  // 멱등성 보장!
                conn.setConnectTimeout(TIMEOUT);
                conn.setReadTimeout(TIMEOUT);
                conn.setDoOutput(true);

                // JSON 요청 본문
                String jsonBody = String.format("""
                    {
                        "paymentKey": "%s",
                        "orderId": "%s",
                        "amount": %d
                    }
                    """, request.paymentKey, request.orderId,
                         request.amount);

                // 요청 전송
                try (OutputStream os = conn.getOutputStream()) {
                    byte[] input = jsonBody.getBytes("utf-8");
                    os.write(input, 0, input.length);
                }

                // 응답 코드
                int responseCode = conn.getResponseCode();
                long responseTime = System.currentTimeMillis() - startTime;

                System.out.println("[시도 " + (retry + 1) + "] " +
                    "응답 코드: " + responseCode +
                    " (응답 시간: " + responseTime + "ms)");

                if (responseCode == 200) {
                    // 성공 응답 파싱
                    String responseBody = readResponse(
                        conn.getInputStream());

                    conn.disconnect();

                    // JSON 파싱 (간소화)
                    PaymentResult result = parseSuccessResponse(
                        responseBody);
                    result.responseTime = responseTime;

                    System.out.println("✅ 결제 승인 성공!");
                    return result;

                } else {
                    // 실패 응답
                    String errorBody = readResponse(
                        conn.getErrorStream());

                    conn.disconnect();

                    // 재시도 불가능한 오류 (4xx)
                    if (responseCode >= 400 && responseCode < 500) {
                        System.err.println("❌ 클라이언트 오류 " +
                            responseCode + " (재시도 불가)");
                        return new PaymentResult(false,
                            "클라이언트 오류: " + errorBody);
                    }

                    // 서버 오류 (5xx) - 재시도
                    System.err.println("⚠️ 서버 오류 " +
                        responseCode + " (재시도 예정)");
                }

            } catch (SocketTimeoutException e) {
                System.err.println("⏰ 타임아웃 (재시도 " +
                    (retry + 1) + "/" + (MAX_RETRY + 1) + ")");

            } catch (Exception e) {
                System.err.println("❌ 오류: " + e.getMessage());
            }

            // 재시도 전 대기
            if (retry < MAX_RETRY) {
                try {
                    Thread.sleep(500 * (retry + 1));  // 0.5초, 1초
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }

        // 모든 재시도 실패 → 자동 롤백
        System.err.println("❌ 결제 실패 (최대 재시도 초과)");
        rollbackPayment(request);

        return new PaymentResult(false, "최대 재시도 초과");
    }

    /**
     * 멱등성 키 생성
     */
    private String generateIdempotencyKey(PaymentRequest request) {
        // orderId 기반으로 생성 (같은 주문은 항상 같은 키)
        return "idem_" + request.orderId + "_" +
               UUID.nameUUIDFromBytes(
                   (request.orderId + request.amount).getBytes()
               ).toString();
    }

    /**
     * Base64 인코딩 (간소화)
     */
    private String encodeBase64(String str) {
        return Base64.getEncoder().encodeToString(
            str.getBytes());
    }

    /**
     * 응답 본문 읽기
     */
    private String readResponse(InputStream inputStream)
            throws IOException {
        if (inputStream == null) return "";

        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(inputStream))) {
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            return response.toString();
        }
    }

    /**
     * 성공 응답 파싱 (간소화)
     */
    private PaymentResult parseSuccessResponse(String json) {
        // 실제로는 JSON 라이브러리 사용 (Jackson, Gson)
        PaymentResult result = new PaymentResult(true, null);
        result.transactionId = "txn_" + UUID.randomUUID();
        result.approvalNumber = "12345678";
        return result;
    }

    /**
     * 결제 롤백
     */
    private void rollbackPayment(PaymentRequest request) {
        System.out.println("🔄 결제 롤백 시작: " + request.orderId);

        // 1. DB 트랜잭션 롤백
        // 2. 재고 복구
        // 3. 고객에게 실패 알림

        System.out.println("✅ 롤백 완료");
    }

    // DTO 클래스
    static class PaymentRequest {
        String paymentKey, orderId;
        int amount;

        PaymentRequest(String paymentKey, String orderId, int amount) {
            this.paymentKey = paymentKey;
            this.orderId = orderId;
            this.amount = amount;
        }
    }

    static class PaymentResult {
        boolean success;
        String errorMessage;
        String transactionId;
        String approvalNumber;
        long responseTime;

        PaymentResult(boolean success, String errorMessage) {
            this.success = success;
            this.errorMessage = errorMessage;
        }
    }
}
```

### 실행 결과 (성공)

```
[시도 1] 응답 코드: 200 (응답 시간: 234ms)
✅ 결제 승인 성공!
✅ 결제 성공!
거래 ID: txn_a1b2c3d4-5678-90ab-cdef-1234567890ab
승인 번호: 12345678
```

### 실행 결과 (재시도 후 성공)

```
[시도 1] 응답 코드: 503 (응답 시간: 156ms)
⚠️ 서버 오류 503 (재시도 예정)
[시도 2] 응답 코드: 200 (응답 시간: 198ms)
✅ 결제 승인 성공!
✅ 결제 성공!
거래 ID: txn_a1b2c3d4-5678-90ab-cdef-1234567890ab
승인 번호: 12345678
```

### 핵심 기술

1. **멱등성 보장 (Idempotency Key)**
```java
String idempotencyKey = "idem_" + orderId + "_" + UUID;
conn.setRequestProperty("Idempotency-Key", idempotencyKey);

// 같은 주문을 여러 번 요청해도 PG사에서 중복 처리 방지!
```

2. **재시도 전략**
```java
// 4xx (클라이언트 오류) → 재시도 불가
if (responseCode >= 400 && responseCode < 500) {
    return fail;
}

// 5xx (서버 오류) 또는 타임아웃 → 재시도
```

3. **자동 롤백**
```java
if (모든_재시도_실패) {
    rollbackPayment();  // DB 롤백, 재고 복구
}
```

### 성과
- **성공률**: 99.8% (재시도 덕분에 일시적 네트워크 오류 극복)
- **평균 응답 시간**: 210ms
- **멱등성 보장**: 중복 결제 0건 (Idempotency Key 덕분)

---

## 🏢 실무 사례 3: 쿠팡 상품 가격 모니터링 (Rate Limiting)

### 배경
쿠팡 로켓배송 운영팀에서 경쟁사 가격을 주기적으로 모니터링하여 자동으로 가격 조정

### 요구사항
- 경쟁사 API 주기적 호출 (1분마다)
- Rate Limiting 준수 (분당 100건)
- 가격 변동 감지 시 알림
- API 키 관리

### 전체 코드

```java
import java.net.*;
import java.io.*;
import java.util.*;
import java.util.concurrent.*;

/**
 * 쿠팡 상품 가격 모니터링 시스템
 * - 경쟁사 API 주기적 호출
 * - Rate Limiting (분당 100건)
 * - 가격 변동 알림
 */
public class CoupangPriceMonitor {
    private static final String COMPETITOR_API_URL =
        "https://api.competitor.com/products";
    private static final String API_KEY = "coupang_api_key_12345";
    private static final int RATE_LIMIT = 100;  // 분당 100건

    // Rate Limiter (Guava 라이브러리 대신 간단한 구현)
    private final Semaphore rateLimiter =
        new Semaphore(RATE_LIMIT);

    // 가격 캐시 (이전 가격 저장)
    private final ConcurrentHashMap<String, Integer> priceCache =
        new ConcurrentHashMap<>();

    public static void main(String[] args) {
        CoupangPriceMonitor monitor = new CoupangPriceMonitor();

        // 모니터링할 상품 목록
        List<String> productIds = Arrays.asList(
            "PROD001", "PROD002", "PROD003"
            // ... 1,000개 상품
        );

        // 1분마다 가격 모니터링
        ScheduledExecutorService scheduler =
            Executors.newScheduledThreadPool(1);

        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("\n=== 가격 모니터링 시작: " +
                new Date() + " ===");
            monitor.monitorPrices(productIds);
        }, 0, 1, TimeUnit.MINUTES);

        // Rate Limiter 초기화 (1분마다 세마포어 리셋)
        scheduler.scheduleAtFixedRate(() -> {
            monitor.resetRateLimiter();
        }, 1, 1, TimeUnit.MINUTES);
    }

    /**
     * 상품 가격 모니터링
     */
    public void monitorPrices(List<String> productIds) {
        ExecutorService executor =
            Executors.newFixedThreadPool(10);

        List<Future<PriceResult>> futures = new ArrayList<>();

        for (String productId : productIds) {
            Future<PriceResult> future = executor.submit(() ->
                checkPrice(productId)
            );
            futures.add(future);
        }

        // 결과 집계
        int totalChecked = 0, priceChanged = 0;

        for (Future<PriceResult> future : futures) {
            try {
                PriceResult result = future.get(10, TimeUnit.SECONDS);
                if (result != null) {
                    totalChecked++;

                    if (result.priceChanged) {
                        priceChanged++;
                        handlePriceChange(result);
                    }
                }
            } catch (Exception e) {
                System.err.println("오류: " + e.getMessage());
            }
        }

        executor.shutdown();

        System.out.println("\n=== 모니터링 완료 ===");
        System.out.println("확인한 상품: " + totalChecked + "개");
        System.out.println("가격 변동: " + priceChanged + "개");
    }

    /**
     * 상품 가격 확인 (Rate Limiting 적용)
     */
    private PriceResult checkPrice(String productId) {
        try {
            // Rate Limiting: 세마포어 획득
            if (!rateLimiter.tryAcquire(100, TimeUnit.MILLISECONDS)) {
                System.err.println("⚠️ Rate Limit 초과: " + productId);
                return null;
            }

            // API 호출
            String urlString = COMPETITOR_API_URL + "/" + productId;
            URL url = new URL(urlString);
            HttpURLConnection conn =
                (HttpURLConnection) url.openConnection();

            // 요청 설정
            conn.setRequestMethod("GET");
            conn.setRequestProperty("Authorization",
                "Bearer " + API_KEY);
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);

            int responseCode = conn.getResponseCode();

            if (responseCode == 200) {
                // 응답 파싱
                String responseBody = readResponse(
                    conn.getInputStream());

                conn.disconnect();

                // 가격 추출 (JSON 파싱 간소화)
                int currentPrice = parsePrice(responseBody);

                // 가격 변동 감지
                Integer previousPrice = priceCache.get(productId);
                boolean priceChanged = false;

                if (previousPrice != null &&
                    previousPrice != currentPrice) {
                    priceChanged = true;
                    System.out.println("💰 가격 변동 감지: " +
                        productId + " (" + previousPrice + "원 → " +
                        currentPrice + "원)");
                }

                // 캐시 업데이트
                priceCache.put(productId, currentPrice);

                return new PriceResult(productId, currentPrice,
                    previousPrice, priceChanged);

            } else if (responseCode == 429) {
                // Too Many Requests
                System.err.println("⚠️ API Rate Limit 초과 (429)");

            } else {
                System.err.println("❌ API 오류 " + responseCode +
                    ": " + productId);
            }

            conn.disconnect();

        } catch (Exception e) {
            System.err.println("❌ 오류: " + productId +
                " - " + e.getMessage());
        }

        return null;
    }

    /**
     * 응답 본문 읽기
     */
    private String readResponse(InputStream inputStream)
            throws IOException {
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(inputStream))) {
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            return response.toString();
        }
    }

    /**
     * 가격 파싱 (간소화)
     */
    private int parsePrice(String json) {
        // 실제로는 JSON 라이브러리 사용
        // {"productId": "PROD001", "price": 29900}
        return 29900 + (int)(Math.random() * 5000);  // Mock
    }

    /**
     * 가격 변동 처리
     */
    private void handlePriceChange(PriceResult result) {
        int diff = result.currentPrice - result.previousPrice;
        double changePercent = (double) diff / result.previousPrice * 100;

        System.out.println("📊 가격 변동 분석:");
        System.out.println("  상품 ID: " + result.productId);
        System.out.println("  이전 가격: " + result.previousPrice + "원");
        System.out.println("  현재 가격: " + result.currentPrice + "원");
        System.out.println("  변동: " + diff + "원 (" +
            String.format("%.2f", changePercent) + "%)");

        // 가격 인하 (5% 이상)
        if (changePercent <= -5.0) {
            System.out.println("✅ 경쟁사 가격 인하 → 자동 가격 조정 필요!");
            adjustCoupangPrice(result.productId, result.currentPrice);
        }

        // 가격 인상 (10% 이상)
        if (changePercent >= 10.0) {
            System.out.println("✅ 경쟁사 가격 인상 → 우리 가격 경쟁력 확보!");
        }

        // Slack 알림 (생략)
        sendSlackNotification(result);
    }

    /**
     * 쿠팡 가격 자동 조정
     */
    private void adjustCoupangPrice(String productId, int competitorPrice) {
        // 경쟁사보다 500원 저렴하게 설정
        int newPrice = competitorPrice - 500;

        System.out.println("🔄 가격 자동 조정: " + productId +
            " → " + newPrice + "원");

        // DB 업데이트 (생략)
        // UPDATE products SET price = ? WHERE product_id = ?
    }

    /**
     * Slack 알림 전송
     */
    private void sendSlackNotification(PriceResult result) {
        // Slack Webhook API 호출 (생략)
    }

    /**
     * Rate Limiter 초기화
     */
    private void resetRateLimiter() {
        int available = rateLimiter.availablePermits();
        int released = RATE_LIMIT - available;

        if (released > 0) {
            rateLimiter.release(released);
            System.out.println("🔄 Rate Limiter 리셋: " +
                released + "개 복구");
        }
    }

    // DTO 클래스
    static class PriceResult {
        String productId;
        int currentPrice;
        Integer previousPrice;
        boolean priceChanged;

        PriceResult(String productId, int currentPrice,
                    Integer previousPrice, boolean priceChanged) {
            this.productId = productId;
            this.currentPrice = currentPrice;
            this.previousPrice = previousPrice;
            this.priceChanged = priceChanged;
        }
    }
}
```

### 실행 결과

```
=== 가격 모니터링 시작: Fri Jan 10 14:00:00 KST 2025 ===
💰 가격 변동 감지: PROD001 (29900원 → 27900원)
📊 가격 변동 분석:
  상품 ID: PROD001
  이전 가격: 29900원
  현재 가격: 27900원
  변동: -2000원 (-6.69%)
✅ 경쟁사 가격 인하 → 자동 가격 조정 필요!
🔄 가격 자동 조정: PROD001 → 27400원

💰 가격 변동 감지: PROD002 (49000원 → 54000원)
📊 가격 변동 분석:
  상품 ID: PROD002
  이전 가격: 49000원
  현재 가격: 54000원
  변동: 5000원 (+10.20%)
✅ 경쟁사 가격 인상 → 우리 가격 경쟁력 확보!

=== 모니터링 완료 ===
확인한 상품: 1000개
가격 변동: 47개

=== 가격 모니터링 시작: Fri Jan 10 14:01:00 KST 2025 ===
🔄 Rate Limiter 리셋: 100개 복구
...
```

### 핵심 기술

1. **Rate Limiting (세마포어 사용)**
```java
Semaphore rateLimiter = new Semaphore(100);  // 분당 100건

// API 호출 전
if (!rateLimiter.tryAcquire(100, TimeUnit.MILLISECONDS)) {
    System.err.println("Rate Limit 초과");
    return;
}

// 1분마다 리셋
scheduler.scheduleAtFixedRate(() -> {
    rateLimiter.release(released);
}, 1, 1, TimeUnit.MINUTES);
```

2. **가격 변동 감지**
```java
ConcurrentHashMap<String, Integer> priceCache;

Integer previousPrice = priceCache.get(productId);
if (previousPrice != null && previousPrice != currentPrice) {
    handlePriceChange();  // 알림 + 자동 조정
}
```

3. **자동 가격 조정**
```java
if (경쟁사_가격_인하 >= 5%) {
    int newPrice = competitorPrice - 500;  // 500원 저렴하게
    updateCoupangPrice(newPrice);
}
```

### 성과
- **모니터링 상품**: 1,000개
- **가격 변동 감지**: 평균 47개/분
- **자동 조정**: 10개/분 (수동 대비 10배 빠름)
- **매출 증가**: 경쟁력 있는 가격으로 월 매출 5% 증가

---

## 👶 주니어 개발자 시나리오 1: Connection Timeout 미설정

### 상황
입사 1개월 차 신입 개발자가 외부 API 호출 코드를 작성했습니다.

```java
public class WeatherAPI {
    public String getWeather(String city) throws Exception {
        String url = "http://slow-weather-api.com/weather?city=" + city;

        URL apiUrl = new URL(url);
        HttpURLConnection conn =
            (HttpURLConnection) apiUrl.openConnection();

        conn.setRequestMethod("GET");
        // ❌ 타임아웃 설정 없음!

        BufferedReader reader = new BufferedReader(
            new InputStreamReader(conn.getInputStream()));

        String line;
        StringBuilder response = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }

        reader.close();
        conn.disconnect();

        return response.toString();
    }
}
```

### 문제 발생

```
사용자 요청 → 날씨 API 호출 → 응답 없음 (서버 느림)
                        ↓
                   무한 대기! ⏰
                        ↓
            스레드 블로킹 (CPU 100%)
                        ↓
        서버 전체 다운 (OOM) 💥
```

**로그**:
```
14:32:15 INFO  - 날씨 조회 요청: Seoul
14:32:15 INFO  - API 호출 중...
(30분 경과)
15:02:15 ERROR - OutOfMemoryError: unable to create new native thread
```

### 해결 방법

```java
public class WeatherAPI {
    private static final int CONNECT_TIMEOUT = 5000;  // 5초
    private static final int READ_TIMEOUT = 10000;    // 10초

    public String getWeather(String city) throws Exception {
        String url = "http://slow-weather-api.com/weather?city=" + city;

        URL apiUrl = new URL(url);
        HttpURLConnection conn =
            (HttpURLConnection) apiUrl.openConnection();

        conn.setRequestMethod("GET");

        // ✅ 타임아웃 설정!
        conn.setConnectTimeout(CONNECT_TIMEOUT);  // 연결 타임아웃
        conn.setReadTimeout(READ_TIMEOUT);        // 읽기 타임아웃

        try {
            BufferedReader reader = new BufferedReader(
                new InputStreamReader(conn.getInputStream()));

            String line;
            StringBuilder response = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }

            reader.close();
            return response.toString();

        } catch (SocketTimeoutException e) {
            // ✅ 타임아웃 처리
            System.err.println("API 타임아웃: " + e.getMessage());
            throw new RuntimeException("날씨 API 응답 시간 초과", e);

        } finally {
            conn.disconnect();
        }
    }
}
```

### 배운 점

1. **타임아웃은 필수**
   - `setConnectTimeout()`: 서버 연결 시간 제한
   - `setReadTimeout()`: 응답 읽기 시간 제한

2. **권장 시간**
   - 연결 타임아웃: 5초
   - 읽기 타임아웃: 10-30초 (API 특성에 따라)

3. **예외 처리**
   - `SocketTimeoutException` catch → 사용자에게 안내 메시지
   - 무한 대기 방지 → 서버 안정성 확보

---

## 👶 주니어 개발자 시나리오 2: HttpURLConnection 재사용 시도

### 상황
입사 2개월 차 개발자가 성능 최적화를 위해 HttpURLConnection을 재사용하려고 했습니다.

```java
public class ProductAPI {
    private HttpURLConnection conn;  // ❌ 인스턴스 변수로 재사용 시도

    public ProductAPI() throws Exception {
        URL url = new URL("https://api.example.com/products");
        conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("GET");
    }

    public String getProduct(String productId) throws Exception {
        // ❌ 재사용 시도!
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(conn.getInputStream()));

        String line;
        StringBuilder response = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }

        reader.close();
        return response.toString();
    }

    public static void main(String[] args) throws Exception {
        ProductAPI api = new ProductAPI();

        // 첫 번째 호출: 성공 ✅
        System.out.println(api.getProduct("PROD001"));

        // 두 번째 호출: 실패! ❌
        System.out.println(api.getProduct("PROD002"));
    }
}
```

### 문제 발생

```
Exception in thread "main" java.net.ProtocolException:
    Cannot write output after reading input.
```

**이유**:
- HttpURLConnection은 **1회용 객체**
- `getInputStream()` 호출 후 재사용 불가
- 매 요청마다 새로운 객체 생성 필요

### 해결 방법

```java
public class ProductAPI {
    private static final String BASE_URL =
        "https://api.example.com/products";

    // ✅ 메서드마다 새로운 연결 생성
    public String getProduct(String productId) throws Exception {
        String urlString = BASE_URL + "/" + productId;
        URL url = new URL(urlString);

        // ✅ 매번 새로운 HttpURLConnection 생성!
        HttpURLConnection conn =
            (HttpURLConnection) url.openConnection();

        conn.setRequestMethod("GET");
        conn.setConnectTimeout(5000);
        conn.setReadTimeout(5000);

        try {
            int responseCode = conn.getResponseCode();

            if (responseCode == 200) {
                BufferedReader reader = new BufferedReader(
                    new InputStreamReader(conn.getInputStream()));

                String line;
                StringBuilder response = new StringBuilder();
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }

                reader.close();
                return response.toString();
            } else {
                throw new RuntimeException("API 오류: " + responseCode);
            }

        } finally {
            conn.disconnect();  // ✅ 연결 종료
        }
    }

    public static void main(String[] args) throws Exception {
        ProductAPI api = new ProductAPI();

        // 모든 호출 성공! ✅
        System.out.println(api.getProduct("PROD001"));
        System.out.println(api.getProduct("PROD002"));
        System.out.println(api.getProduct("PROD003"));
    }
}
```

### 배운 점

1. **HttpURLConnection은 1회용**
   - 매 요청마다 새로운 객체 생성
   - `disconnect()` 후 재사용 불가

2. **Connection Pool이 필요하다면?**
   - Apache HttpClient 사용
   - OkHttp 사용
   - RestTemplate (Spring) 사용

3. **올바른 패턴**
```java
// ❌ 잘못된 패턴
HttpURLConnection conn;  // 인스턴스 변수

// ✅ 올바른 패턴
public String request() {
    HttpURLConnection conn = ...;  // 메서드 내 생성
    try {
        // 요청 처리
    } finally {
        conn.disconnect();
    }
}
```

---

## 👶 주니어 개발자 시나리오 3: POST 요청 시 setDoOutput() 누락

### 상황
입사 3개월 차 개발자가 회원가입 API를 호출하는 코드를 작성했습니다.

```java
public class UserAPI {
    public String registerUser(String username, String email)
            throws Exception {
        String urlString = "https://api.example.com/users";
        URL url = new URL(urlString);

        HttpURLConnection conn =
            (HttpURLConnection) url.openConnection();

        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-Type", "application/json");
        // ❌ setDoOutput(true) 누락!

        // JSON 데이터
        String jsonData = String.format(
            "{\"username\":\"%s\",\"email\":\"%s\"}",
            username, email);

        // 데이터 전송 시도
        OutputStream os = conn.getOutputStream();  // ❌ 예외 발생!
        os.write(jsonData.getBytes());
        os.close();

        // 응답 읽기
        int responseCode = conn.getResponseCode();
        return "Success: " + responseCode;
    }
}
```

### 문제 발생

```
Exception in thread "main" java.net.ProtocolException:
    cannot write to a URLConnection if doOutput=false -
    call setDoOutput(true)
```

**이유**:
- HttpURLConnection은 기본적으로 **읽기 전용** (GET)
- POST로 데이터를 보내려면 `setDoOutput(true)` 필수
- 이를 설정해야 `getOutputStream()` 사용 가능

### 해결 방법

```java
public class UserAPI {
    public String registerUser(String username, String email)
            throws Exception {
        String urlString = "https://api.example.com/users";
        URL url = new URL(urlString);

        HttpURLConnection conn =
            (HttpURLConnection) url.openConnection();

        conn.setRequestMethod("POST");
        conn.setRequestProperty("Content-Type", "application/json");
        conn.setDoOutput(true);  // ✅ POST 요청에 필수!
        conn.setConnectTimeout(5000);
        conn.setReadTimeout(5000);

        // JSON 데이터
        String jsonData = String.format(
            "{\"username\":\"%s\",\"email\":\"%s\"}",
            username, email);

        // ✅ 데이터 전송 (try-with-resources)
        try (OutputStream os = conn.getOutputStream()) {
            byte[] input = jsonData.getBytes("utf-8");
            os.write(input, 0, input.length);
        }

        // 응답 읽기
        int responseCode = conn.getResponseCode();

        if (responseCode == 201) {  // HTTP_CREATED
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(conn.getInputStream()))) {

                String line;
                StringBuilder response = new StringBuilder();
                while ((line = reader.readLine()) != null) {
                    response.append(line);
                }

                return response.toString();
            }
        } else {
            throw new RuntimeException("API 오류: " + responseCode);
        }
    }

    public static void main(String[] args) throws Exception {
        UserAPI api = new UserAPI();

        String result = api.registerUser("john_doe", "john@example.com");
        System.out.println("✅ 회원가입 성공:");
        System.out.println(result);
    }
}
```

### 배운 점

1. **POST/PUT 요청 시 필수 설정**
```java
conn.setRequestMethod("POST");
conn.setDoOutput(true);  // ✅ 필수!
```

2. **GET vs POST 차이**
```java
// GET (데이터 읽기 only)
conn.setRequestMethod("GET");
// setDoOutput() 불필요

// POST (데이터 쓰기)
conn.setRequestMethod("POST");
conn.setDoOutput(true);  // ✅ 필수!
```

3. **OutputStream 올바른 사용**
```java
// ✅ try-with-resources (자동 close)
try (OutputStream os = conn.getOutputStream()) {
    os.write(data);
}

// ❌ 수동 close (누락 위험)
OutputStream os = conn.getOutputStream();
os.write(data);
os.close();  // 예외 발생 시 누락 위험!
```

---

## 👶 주니어 개발자 시나리오 4: InputStream 닫지 않아 리소스 누수

### 상황
입사 4개월 차 개발자가 API 호출을 반복하는 배치 작업을 작성했습니다.

```java
public class DataSyncBatch {
    public void syncData() {
        List<String> urls = getUrls();  // 1,000개 URL

        for (String urlString : urls) {
            try {
                URL url = new URL(urlString);
                HttpURLConnection conn =
                    (HttpURLConnection) url.openConnection();

                conn.setRequestMethod("GET");

                // ❌ InputStream을 닫지 않음!
                InputStream is = conn.getInputStream();
                BufferedReader reader = new BufferedReader(
                    new InputStreamReader(is));

                String line;
                while ((line = reader.readLine()) != null) {
                    processLine(line);
                }

                // ❌ close() 누락!

                conn.disconnect();

            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    private List<String> getUrls() {
        // 1,000개 URL 반환
        return Arrays.asList("url1", "url2", ...);
    }

    private void processLine(String line) {
        // 데이터 처리
    }
}
```

### 문제 발생

**처음에는 정상 동작**:
```
처리 중: 1/1000
처리 중: 2/1000
처리 중: 3/1000
...
```

**500번째 요청 즈음**:
```
처리 중: 498/1000
처리 중: 499/1000
처리 중: 500/1000
java.io.IOException: Too many open files
```

**시스템 상태**:
```bash
$ lsof -p <pid> | wc -l
1024  # ❌ 파일 디스크립터 한계 도달!
```

### 해결 방법

```java
public class DataSyncBatch {
    public void syncData() {
        List<String> urls = getUrls();  // 1,000개 URL

        int success = 0, fail = 0;

        for (String urlString : urls) {
            HttpURLConnection conn = null;

            try {
                URL url = new URL(urlString);
                conn = (HttpURLConnection) url.openConnection();

                conn.setRequestMethod("GET");
                conn.setConnectTimeout(5000);
                conn.setReadTimeout(5000);

                // ✅ try-with-resources로 자동 close
                try (InputStream is = conn.getInputStream();
                     BufferedReader reader = new BufferedReader(
                         new InputStreamReader(is))) {

                    String line;
                    while ((line = reader.readLine()) != null) {
                        processLine(line);
                    }
                }

                success++;
                System.out.println("✅ 처리 완료: " + success +
                    "/" + urls.size());

            } catch (Exception e) {
                fail++;
                System.err.println("❌ 오류: " + urlString);

            } finally {
                // ✅ 연결 종료
                if (conn != null) {
                    conn.disconnect();
                }
            }
        }

        System.out.println("\n=== 배치 완료 ===");
        System.out.println("성공: " + success + "개");
        System.out.println("실패: " + fail + "개");
    }

    private List<String> getUrls() {
        // 1,000개 URL 반환
        List<String> urls = new ArrayList<>();
        for (int i = 1; i <= 1000; i++) {
            urls.add("https://api.example.com/data/" + i);
        }
        return urls;
    }

    private void processLine(String line) {
        // 데이터 처리
    }

    public static void main(String[] args) {
        DataSyncBatch batch = new DataSyncBatch();
        batch.syncData();
    }
}
```

### 배운 점

1. **리소스는 반드시 닫아야 한다**
   - InputStream
   - OutputStream
   - Reader/Writer
   - HttpURLConnection

2. **try-with-resources 사용**
```java
// ✅ 자동 close (권장)
try (InputStream is = conn.getInputStream();
     BufferedReader reader = new BufferedReader(
         new InputStreamReader(is))) {
    // 사용
}  // ← 자동으로 close() 호출

// ❌ 수동 close (위험)
InputStream is = conn.getInputStream();
BufferedReader reader = new BufferedReader(...);
// 사용
is.close();   // 예외 발생 시 누락 위험!
reader.close();
```

3. **finally 블록 활용**
```java
HttpURLConnection conn = null;
try {
    conn = (HttpURLConnection) url.openConnection();
    // 사용
} finally {
    if (conn != null) {
        conn.disconnect();  // ✅ 반드시 실행
    }
}
```

4. **리소스 누수 확인 방법**
```bash
# 열린 파일 디스크립터 확인
$ lsof -p <pid> | wc -l

# 시스템 한계 확인
$ ulimit -n
1024
```

---

## 🎯 핵심 정리

### HTTP 통신 필수 체크리스트

```java
// ✅ 완벽한 HTTP 요청 템플릿
public String httpRequest(String urlString, String method,
                          String jsonData) throws Exception {
    URL url = new URL(urlString);
    HttpURLConnection conn =
        (HttpURLConnection) url.openConnection();

    // 1. 기본 설정
    conn.setRequestMethod(method);
    conn.setConnectTimeout(5000);   // ✅ 타임아웃
    conn.setReadTimeout(10000);

    // 2. 헤더 설정
    conn.setRequestProperty("Content-Type", "application/json");
    conn.setRequestProperty("User-Agent", "MyApp/1.0");

    // 3. POST 요청 시
    if ("POST".equals(method) || "PUT".equals(method)) {
        conn.setDoOutput(true);  // ✅ 필수!

        try (OutputStream os = conn.getOutputStream()) {  // ✅ try-with-resources
            byte[] input = jsonData.getBytes("utf-8");
            os.write(input, 0, input.length);
        }
    }

    // 4. 응답 처리
    int responseCode = conn.getResponseCode();

    try (BufferedReader reader = new BufferedReader(  // ✅ try-with-resources
            new InputStreamReader(
                responseCode == 200 ?
                    conn.getInputStream() :
                    conn.getErrorStream()))) {

        String line;
        StringBuilder response = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }

        return response.toString();

    } finally {
        conn.disconnect();  // ✅ 연결 종료
    }
}
```

### 실무 패턴

| 상황 | 해결책 |
|------|--------|
| 타임아웃 | `setConnectTimeout(5000)`, `setReadTimeout(10000)` |
| POST 요청 | `setDoOutput(true)` 필수 |
| 재사용 불가 | 매 요청마다 새 HttpURLConnection |
| 리소스 누수 | try-with-resources 사용 |
| 재시도 | for 루프 + exponential backoff |
| Rate Limiting | Semaphore 또는 Guava RateLimiter |
| 멱등성 보장 | Idempotency-Key 헤더 |

---

**다음 Part에서 계속**: [39-3: 면접 질문 및 채팅 프로젝트 →](39-3-네트워크-프로그래밍-Part3.md)

**이전 Part**: [← 39-1: Socket 기초](39-1-네트워크-프로그래밍-Part1.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
