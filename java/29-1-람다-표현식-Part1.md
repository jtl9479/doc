# 29장 람다 표현식 - Part 1: 실생활 비유로 이해하기

## 📚 목차
1. [비유 1: 레시피 카드 (함수를 값으로)](#비유-1-레시피-카드)
2. [비유 2: 정렬 기준 변경 (Comparator)](#비유-2-정렬-기준-변경)
3. [비유 3: 필터링 (조건 전달)](#비유-3-필터링)
4. [비유 4: 이벤트 핸들러 (콜백)](#비유-4-이벤트-핸들러)
5. [비유 5: 변환 작업 (Mapping)](#비유-5-변환-작업)

---

## 🔍 람다 표현식이란?

람다 표현식은 **메서드를 하나의 식으로 표현**한 것입니다. 익명 함수(Anonymous Function)라고도 합니다.

**핵심 개념**:
```java
// 전통적인 방식 (익명 클래스)
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

// 람다 표현식
Runnable runnable = () -> System.out.println("Hello");
```

**람다의 장점**:
```
1. 간결성: 코드가 짧아짐
2. 가독성: 의도가 명확함
3. 함수형 프로그래밍: 함수를 일급 객체로 취급
```

---

## 📖 비유 1: 레시피 카드 (함수를 값으로)

### 🎯 실생활 비유

요리사가 레시피 카드를 다른 사람에게 전달하는 상황을 생각해봅시다.

**전통적인 방식 (레시피 책)**:
```
1. 두꺼운 요리책을 통째로 전달
2. 필요한 레시피는 한 페이지뿐
3. 무겁고 불편함
```

**람다 방식 (레시피 카드)**:
```
1. 필요한 레시피만 카드에 작성
2. 간단하고 휴대 가능
3. 필요한 정보만 담음
```

### 💻 Java 코드로 구현

```java
package lambda.example1;

/**
 * 레시피 (함수형 인터페이스)
 */
@FunctionalInterface
interface Recipe {
    void cook(String ingredient);
}

/**
 * 요리사 클래스
 */
class Chef {
    private String name;

    public Chef(String name) {
        this.name = name;
    }

    /**
     * 레시피에 따라 요리
     */
    public void cookWithRecipe(String ingredient, Recipe recipe) {
        System.out.println(name + "님이 요리 시작:");
        recipe.cook(ingredient);
        System.out.println("요리 완성!\n");
    }
}

/**
 * 레시피 카드 데모
 */
public class RecipeCardDemo {
    public static void main(String[] args) {
        Chef chef = new Chef("김철수");

        System.out.println("=== 레시피 카드 (람다 표현식) ===\n");

        // 시나리오 1: 전통적인 방식 (익명 클래스)
        System.out.println("📍 시나리오 1: 전통적인 방식 (익명 클래스)");

        chef.cookWithRecipe("토마토", new Recipe() {
            @Override
            public void cook(String ingredient) {
                System.out.println("  1. " + ingredient + "을 씻는다");
                System.out.println("  2. " + ingredient + "을 썬다");
                System.out.println("  3. 냄비에 넣고 끓인다");
            }
        });

        // 시나리오 2: 람다 표현식 (간결함)
        System.out.println("📍 시나리오 2: 람다 표현식");

        chef.cookWithRecipe("양파", ingredient -> {
            System.out.println("  1. " + ingredient + "을 다진다");
            System.out.println("  2. 프라이팬에 볶는다");
            System.out.println("  3. 소금으로 간한다");
        });

        // 시나리오 3: 간단한 레시피 (한 줄)
        System.out.println("📍 시나리오 3: 간단한 레시피 (한 줄)");

        chef.cookWithRecipe("계란",
            ingredient -> System.out.println("  " + ingredient + "을 후라이팬에 굽기"));

        // 시나리오 4: 여러 레시피 전달
        System.out.println("📍 시나리오 4: 여러 레시피 저장 및 재사용");

        // 레시피를 변수에 저장
        Recipe pastaRecipe = ingredient -> {
            System.out.println("  1. 물을 끓인다");
            System.out.println("  2. " + ingredient + "을 넣는다");
            System.out.println("  3. 8분간 삶는다");
            System.out.println("  4. 소스와 버무린다");
        };

        Recipe saladRecipe = ingredient -> {
            System.out.println("  1. " + ingredient + "을 씻는다");
            System.out.println("  2. 적당한 크기로 자른다");
            System.out.println("  3. 드레싱을 뿌린다");
        };

        chef.cookWithRecipe("스파게티", pastaRecipe);
        chef.cookWithRecipe("양상추", saladRecipe);

        // 시나리오 5: 비교 (코드 라인 수)
        System.out.println("📊 코드 비교:");
        System.out.println("익명 클래스: ~8줄");
        System.out.println("람다 표현식: ~3줄");
        System.out.println("→ 60% 이상 코드 감소!");
    }
}
```

### 🎯 핵심 포인트

**1. 람다의 기본 문법**:
```java
// 형식: (매개변수) -> { 실행문 }

// 매개변수 1개, 실행문 1개
(ingredient) -> System.out.println(ingredient);

// 매개변수 타입 생략 가능 (타입 추론)
ingredient -> System.out.println(ingredient);

// 실행문이 여러 개면 {} 필요
ingredient -> {
    System.out.println("1단계");
    System.out.println("2단계");
}

// 매개변수 없음
() -> System.out.println("Hello");

// 매개변수 여러 개
(a, b) -> a + b
```

**2. 함수형 인터페이스**:
```java
// 추상 메서드가 1개인 인터페이스
@FunctionalInterface
interface Recipe {
    void cook(String ingredient); // 추상 메서드 1개만!
}

// @FunctionalInterface: 컴파일러가 검증
// - 추상 메서드가 2개 이상이면 컴파일 에러
```

**3. 람다 vs 익명 클래스**:
```
익명 클래스:
- 긴 코드 (8~10줄)
- this는 익명 클래스 객체
- 모든 인터페이스 구현 가능

람다:
- 짧은 코드 (1~3줄)
- this는 외부 클래스 객체
- 함수형 인터페이스만 가능
```

---

## 📖 비유 2: 정렬 기준 변경 (Comparator)

### 🎯 실생활 비유

도서관에서 책을 정렬하는 방법은 여러 가지입니다.

**정렬 기준**:
```
1. 제목순 (가나다순)
2. 저자순
3. 출판일순
4. 인기순
```

정렬 기준을 **동적으로 변경**하고 싶을 때 람다가 유용합니다.

### 💻 Java 코드로 구현

```java
package lambda.example2;

import java.util.*;

/**
 * 도서 정보
 */
class Book {
    private String title;
    private String author;
    private int year;
    private int price;

    public Book(String title, String author, int year, int price) {
        this.title = title;
        this.author = author;
        this.year = year;
        this.price = price;
    }

    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public int getYear() { return year; }
    public int getPrice() { return price; }

    @Override
    public String toString() {
        return String.format("《%s》 - %s (%d년, %d원)", title, author, year, price);
    }
}

/**
 * 도서관 정렬 데모
 */
public class LibrarySortingDemo {
    public static void main(String[] args) {
        System.out.println("=== 도서관 정렬 시스템 (Comparator 람다) ===\n");

        List<Book> books = Arrays.asList(
            new Book("자바의 정석", "남궁성", 2022, 35000),
            new Book("클린 코드", "로버트 마틴", 2013, 29000),
            new Book("이펙티브 자바", "조슈아 블로크", 2018, 36000),
            new Book("토비의 스프링", "이일민", 2020, 45000),
            new Book("리팩터링", "마틴 파울러", 2020, 38000)
        );

        // 시나리오 1: 전통적인 방식 (익명 클래스)
        System.out.println("📍 시나리오 1: 전통적인 방식 (익명 클래스)");

        List<Book> books1 = new ArrayList<>(books);
        books1.sort(new Comparator<Book>() {
            @Override
            public int compare(Book b1, Book b2) {
                return b1.getTitle().compareTo(b2.getTitle());
            }
        });

        System.out.println("제목순 정렬 (익명 클래스):");
        books1.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 시나리오 2: 람다 표현식
        System.out.println("📍 시나리오 2: 람다 표현식");

        // 2-1. 제목순
        List<Book> books2 = new ArrayList<>(books);
        books2.sort((b1, b2) -> b1.getTitle().compareTo(b2.getTitle()));

        System.out.println("제목순 정렬 (람다):");
        books2.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 2-2. 저자순
        List<Book> books3 = new ArrayList<>(books);
        books3.sort((b1, b2) -> b1.getAuthor().compareTo(b2.getAuthor()));

        System.out.println("저자순 정렬:");
        books3.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 2-3. 출판년도순 (최신순)
        List<Book> books4 = new ArrayList<>(books);
        books4.sort((b1, b2) -> b2.getYear() - b1.getYear());

        System.out.println("출판년도순 (최신순):");
        books4.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 2-4. 가격순 (저렴한 순)
        List<Book> books5 = new ArrayList<>(books);
        books5.sort((b1, b2) -> b1.getPrice() - b2.getPrice());

        System.out.println("가격순 (저렴한 순):");
        books5.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 시나리오 3: Comparator 메서드 참조 (더 간결)
        System.out.println("📍 시나리오 3: Comparator 정적 메서드 (Java 8+)");

        List<Book> books6 = new ArrayList<>(books);
        books6.sort(Comparator.comparing(Book::getTitle));

        System.out.println("제목순 (메서드 참조):");
        books6.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 시나리오 4: 다단계 정렬
        System.out.println("📍 시나리오 4: 다단계 정렬");

        List<Book> books7 = new ArrayList<>(books);
        books7.sort(
            Comparator.comparing(Book::getYear).reversed()
                .thenComparing(Book::getTitle)
        );

        System.out.println("출판년도순 (최신) → 제목순:");
        books7.forEach(b -> System.out.println("  " + b));
        System.out.println();

        // 시나리오 5: 정렬 기준을 변수로 저장
        System.out.println("📍 시나리오 5: 정렬 기준 재사용");

        Comparator<Book> byPrice = (b1, b2) -> b1.getPrice() - b2.getPrice();
        Comparator<Book> byPriceDesc = (b1, b2) -> b2.getPrice() - b1.getPrice();

        List<Book> books8 = new ArrayList<>(books);
        books8.sort(byPrice);
        System.out.println("저렴한 순:");
        books8.stream().limit(3).forEach(b -> System.out.println("  " + b));

        List<Book> books9 = new ArrayList<>(books);
        books9.sort(byPriceDesc);
        System.out.println("\n비싼 순:");
        books9.stream().limit(3).forEach(b -> System.out.println("  " + b));
    }
}
```

### 🎯 핵심 포인트

**1. Comparator 람다**:
```java
// 전통적인 방식
books.sort(new Comparator<Book>() {
    public int compare(Book b1, Book b2) {
        return b1.getPrice() - b2.getPrice();
    }
});

// 람다
books.sort((b1, b2) -> b1.getPrice() - b2.getPrice());

// Comparator 정적 메서드 (가장 간결)
books.sort(Comparator.comparing(Book::getPrice));
```

**2. Comparator 유틸리티 메서드**:
```java
// 오름차순
Comparator.comparing(Book::getPrice)

// 내림차순
Comparator.comparing(Book::getPrice).reversed()

// 다단계 정렬
Comparator.comparing(Book::getYear)
    .thenComparing(Book::getTitle)

// null 안전
Comparator.comparing(Book::getAuthor, Comparator.nullsLast(String::compareTo))
```

---

## 📖 비유 3: 필터링 (조건 전달)

### 🎯 실생활 비유

커피숍에서 원하는 조건의 커피만 선택하는 상황입니다.

**필터 조건**:
```
1. 가격이 5000원 이하
2. 카페인이 없는 것
3. 아이스 음료
4. 사이즈가 Grande 이상
```

조건을 **람다로 전달**하여 유연하게 필터링할 수 있습니다.

### 💻 Java 코드로 구현

```java
package lambda.example3;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * 커피 정보
 */
class Coffee {
    private String name;
    private int price;
    private boolean hasCaffeine;
    private boolean isHot;
    private String size; // Tall, Grande, Venti

    public Coffee(String name, int price, boolean hasCaffeine, boolean isHot, String size) {
        this.name = name;
        this.price = price;
        this.hasCaffeine = hasCaffeine;
        this.isHot = isHot;
        this.size = size;
    }

    public String getName() { return name; }
    public int getPrice() { return price; }
    public boolean hasCaffeine() { return hasCaffeine; }
    public boolean isHot() { return isHot; }
    public String getSize() { return size; }

    @Override
    public String toString() {
        return String.format("%s (%d원, %s, %s, %s)",
            name,
            price,
            hasCaffeine ? "카페인O" : "디카페인",
            isHot ? "HOT" : "ICE",
            size
        );
    }
}

/**
 * 커피 필터 시스템
 */
class CoffeeFilter {
    /**
     * 조건에 맞는 커피 필터링
     */
    public static List<Coffee> filter(List<Coffee> coffees, Predicate<Coffee> condition) {
        List<Coffee> result = new ArrayList<>();

        for (Coffee coffee : coffees) {
            if (condition.test(coffee)) {
                result.add(coffee);
            }
        }

        return result;
    }
}

/**
 * 커피 필터링 데모
 */
public class CoffeeFilterDemo {
    public static void main(String[] args) {
        System.out.println("=== 커피 필터링 시스템 (Predicate 람다) ===\n");

        List<Coffee> menu = Arrays.asList(
            new Coffee("아메리카노", 4000, true, true, "Tall"),
            new Coffee("카페라떼", 4500, true, true, "Grande"),
            new Coffee("카푸치노", 4500, true, true, "Tall"),
            new Coffee("아이스 아메리카노", 4500, true, false, "Tall"),
            new Coffee("디카페인 아메리카노", 4500, false, true, "Grande"),
            new Coffee("바닐라 라떼", 5500, true, true, "Venti"),
            new Coffee("아이스 카페라떼", 5000, true, false, "Grande"),
            new Coffee("디카페인 라떼", 5000, false, true, "Tall")
        );

        // 시나리오 1: 가격 필터
        System.out.println("📍 시나리오 1: 가격 필터 (5000원 이하)");

        List<Coffee> affordable = CoffeeFilter.filter(
            menu,
            coffee -> coffee.getPrice() <= 5000
        );

        affordable.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // 시나리오 2: 카페인 필터
        System.out.println("📍 시나리오 2: 디카페인 커피");

        List<Coffee> decaf = CoffeeFilter.filter(
            menu,
            coffee -> !coffee.hasCaffeine()
        );

        decaf.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // 시나리오 3: 아이스 음료
        System.out.println("📍 시나리오 3: 아이스 음료");

        List<Coffee> iceCoffees = CoffeeFilter.filter(
            menu,
            coffee -> !coffee.isHot()
        );

        iceCoffees.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // 시나리오 4: 복합 조건 (AND)
        System.out.println("📍 시나리오 4: 복합 조건 (5000원 이하 + 아이스)");

        List<Coffee> affordableIce = CoffeeFilter.filter(
            menu,
            coffee -> coffee.getPrice() <= 5000 && !coffee.isHot()
        );

        affordableIce.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // 시나리오 5: Predicate 조합
        System.out.println("📍 시나리오 5: Predicate 조합");

        Predicate<Coffee> isAffordable = coffee -> coffee.getPrice() <= 5000;
        Predicate<Coffee> isDecaf = coffee -> !coffee.hasCaffeine();
        Predicate<Coffee> isIce = coffee -> !coffee.isHot();

        // AND 조합
        List<Coffee> result1 = CoffeeFilter.filter(
            menu,
            isAffordable.and(isDecaf)
        );

        System.out.println("5000원 이하 + 디카페인:");
        result1.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // OR 조합
        List<Coffee> result2 = CoffeeFilter.filter(
            menu,
            isDecaf.or(isIce)
        );

        System.out.println("디카페인 또는 아이스:");
        result2.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // NOT 조합
        List<Coffee> result3 = CoffeeFilter.filter(
            menu,
            isAffordable.negate()
        );

        System.out.println("5000원 초과:");
        result3.forEach(c -> System.out.println("  " + c));
        System.out.println();

        // 시나리오 6: Stream API와 결합
        System.out.println("📍 시나리오 6: Stream API와 결합");

        List<String> names = menu.stream()
            .filter(coffee -> coffee.getPrice() <= 4500)
            .filter(coffee -> coffee.hasCaffeine())
            .map(Coffee::getName)
            .collect(Collectors.toList());

        System.out.println("4500원 이하 + 카페인 있는 메뉴:");
        names.forEach(name -> System.out.println("  - " + name));
    }
}
```

### 🎯 핵심 포인트

**1. Predicate 람다**:
```java
// Predicate<T>: T → boolean
Predicate<Coffee> isAffordable = coffee -> coffee.getPrice() <= 5000;

// test() 메서드로 조건 검사
boolean result = isAffordable.test(someCoffee);
```

**2. Predicate 조합**:
```java
Predicate<Coffee> condition1 = coffee -> coffee.getPrice() <= 5000;
Predicate<Coffee> condition2 = coffee -> !coffee.hasCaffeine();

// AND
Predicate<Coffee> both = condition1.and(condition2);

// OR
Predicate<Coffee> either = condition1.or(condition2);

// NOT
Predicate<Coffee> not = condition1.negate();
```

**3. 표준 함수형 인터페이스**:
```java
// Predicate<T>: T → boolean (조건 검사)
Predicate<String> isEmpty = s -> s.isEmpty();

// Function<T, R>: T → R (변환)
Function<String, Integer> length = s -> s.length();

// Consumer<T>: T → void (소비)
Consumer<String> print = s -> System.out.println(s);

// Supplier<T>: () → T (공급)
Supplier<String> greeting = () -> "Hello";
```

---

## 📖 비유 4: 이벤트 핸들러 (콜백)

### 🎯 실생활 비유

버튼 클릭, 타이머 종료 등의 **이벤트가 발생했을 때 실행할 코드**를 미리 등록하는 것입니다.

**이벤트 핸들러의 특징**:
```
1. 이벤트 발생 시점은 미래
2. 실행할 코드를 미리 등록
3. 여러 이벤트에 다른 동작 지정
```

### 💻 Java 코드로 구현

```java
package lambda.example4;

import java.util.*;

/**
 * 이벤트 리스너 (함수형 인터페이스)
 */
@FunctionalInterface
interface EventListener {
    void onEvent(String eventName);
}

/**
 * 버튼 클래스
 */
class Button {
    private String label;
    private List<EventListener> clickListeners = new ArrayList<>();

    public Button(String label) {
        this.label = label;
    }

    /**
     * 클릭 이벤트 리스너 등록
     */
    public void onClick(EventListener listener) {
        clickListeners.add(listener);
    }

    /**
     * 버튼 클릭 시뮬레이션
     */
    public void click() {
        System.out.println("[" + label + "] 버튼 클릭!");

        // 등록된 모든 리스너 실행
        for (EventListener listener : clickListeners) {
            listener.onEvent(label);
        }

        System.out.println();
    }
}

/**
 * 타이머 클래스
 */
class Timer {
    private int seconds;

    public Timer(int seconds) {
        this.seconds = seconds;
    }

    /**
     * 타이머 시작 (콜백 실행)
     */
    public void start(Runnable onComplete) {
        System.out.println("타이머 시작: " + seconds + "초");

        try {
            Thread.sleep(seconds * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("타이머 종료!");
        onComplete.run(); // 콜백 실행
        System.out.println();
    }
}

/**
 * 이벤트 핸들러 데모
 */
public class EventHandlerDemo {
    public static void main(String[] args) {
        System.out.println("=== 이벤트 핸들러 (람다 콜백) ===\n");

        // 시나리오 1: 버튼 클릭 이벤트 (전통적인 방식)
        System.out.println("📍 시나리오 1: 전통적인 방식 (익명 클래스)");

        Button button1 = new Button("저장");
        button1.onClick(new EventListener() {
            @Override
            public void onEvent(String eventName) {
                System.out.println("→ 데이터 저장 중...");
                System.out.println("→ 저장 완료!");
            }
        });

        button1.click();

        // 시나리오 2: 버튼 클릭 이벤트 (람다)
        System.out.println("📍 시나리오 2: 람다 표현식");

        Button button2 = new Button("삭제");
        button2.onClick(eventName -> {
            System.out.println("→ 정말 삭제하시겠습니까?");
            System.out.println("→ 데이터 삭제 완료");
        });

        button2.click();

        // 시나리오 3: 여러 리스너 등록
        System.out.println("📍 시나리오 3: 여러 리스너 등록");

        Button button3 = new Button("로그인");

        // 리스너 1: 로그 기록
        button3.onClick(eventName ->
            System.out.println("→ [LOG] " + eventName + " 버튼 클릭됨")
        );

        // 리스너 2: 분석 데이터 전송
        button3.onClick(eventName ->
            System.out.println("→ [ANALYTICS] 클릭 이벤트 전송")
        );

        // 리스너 3: 실제 로그인 처리
        button3.onClick(eventName -> {
            System.out.println("→ 로그인 처리 중...");
            System.out.println("→ 로그인 성공!");
        });

        button3.click();

        // 시나리오 4: 타이머 콜백
        System.out.println("📍 시나리오 4: 타이머 콜백");

        Timer timer1 = new Timer(2);
        timer1.start(() -> {
            System.out.println("→ 알림: 시간이 다 되었습니다!");
        });

        // 시나리오 5: 콜백 체이닝
        System.out.println("📍 시나리오 5: 콜백 체이닝");

        performTask(
            "데이터 로드",
            () -> {
                System.out.println("→ 데이터 로드 완료");

                performTask(
                    "데이터 처리",
                    () -> {
                        System.out.println("→ 데이터 처리 완료");

                        performTask(
                            "결과 저장",
                            () -> System.out.println("→ 모든 작업 완료!")
                        );
                    }
                );
            }
        );
    }

    /**
     * 비동기 작업 시뮬레이션
     */
    static void performTask(String taskName, Runnable callback) {
        System.out.println(taskName + " 시작...");

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        callback.run();
    }
}
```

### 🎯 핵심 포인트

**1. 콜백 패턴**:
```java
// 콜백: 나중에 실행될 코드를 미리 등록

// 전통적인 방식
button.onClick(new EventListener() {
    public void onEvent(String name) {
        // 이벤트 처리
    }
});

// 람다
button.onClick(name -> {
    // 이벤트 처리
});
```

**2. Runnable 람다**:
```java
// Runnable: () → void

// 전통적인 방식
new Thread(new Runnable() {
    public void run() {
        System.out.println("실행");
    }
}).start();

// 람다
new Thread(() -> System.out.println("실행")).start();
```

---

## 📖 비유 5: 변환 작업 (Mapping)

### 🎯 실생활 비유

공장에서 원자재를 제품으로 변환하는 작업입니다.

**변환 예시**:
```
원자재 → 가공 → 완제품

예:
- 우유 → 치즈
- 밀가루 → 빵
- 목재 → 가구
```

변환 규칙을 **람다로 전달**하여 다양한 변환을 수행할 수 있습니다.

### 💻 Java 코드로 구현

```java
package lambda.example5;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * 원자재
 */
class Material {
    private String name;
    private int quantity;

    public Material(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    public String getName() { return name; }
    public int getQuantity() { return quantity; }

    @Override
    public String toString() {
        return name + " " + quantity + "개";
    }
}

/**
 * 제품
 */
class Product {
    private String name;
    private int price;

    public Product(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public String getName() { return name; }
    public int getPrice() { return price; }

    @Override
    public String toString() {
        return name + " (" + price + "원)";
    }
}

/**
 * 공장 (변환기)
 */
class Factory {
    /**
     * 원자재를 제품으로 변환
     */
    public static <T, R> List<R> transform(List<T> input, Function<T, R> transformer) {
        List<R> result = new ArrayList<>();

        for (T item : input) {
            R transformed = transformer.apply(item);
            result.add(transformed);
        }

        return result;
    }
}

/**
 * 변환 작업 데모
 */
public class TransformDemo {
    public static void main(String[] args) {
        System.out.println("=== 변환 작업 (Function 람다) ===\n");

        // 시나리오 1: 원자재 → 제품 변환
        System.out.println("📍 시나리오 1: 원자재 → 제품 변환");

        List<Material> materials = Arrays.asList(
            new Material("밀가루", 10),
            new Material("우유", 5),
            new Material("계란", 20)
        );

        List<Product> products = Factory.transform(
            materials,
            material -> {
                String productName = material.getName() + " 가공품";
                int price = material.getQuantity() * 1000;
                return new Product(productName, price);
            }
        );

        System.out.println("변환 결과:");
        products.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 2: 문자열 변환
        System.out.println("📍 시나리오 2: 문자열 변환");

        List<String> names = Arrays.asList("apple", "banana", "cherry");

        // 대문자 변환
        List<String> upperNames = Factory.transform(
            names,
            name -> name.toUpperCase()
        );

        System.out.println("대문자 변환:");
        upperNames.forEach(n -> System.out.println("  " + n));
        System.out.println();

        // 길이 변환
        List<Integer> lengths = Factory.transform(
            names,
            name -> name.length()
        );

        System.out.println("길이 변환:");
        lengths.forEach(len -> System.out.println("  " + len));
        System.out.println();

        // 시나리오 3: 메서드 참조
        System.out.println("📍 시나리오 3: 메서드 참조 (더 간결)");

        List<String> names2 = Arrays.asList("apple", "banana", "cherry");

        // 람다
        List<String> upper1 = Factory.transform(names2, name -> name.toUpperCase());

        // 메서드 참조
        List<String> upper2 = Factory.transform(names2, String::toUpperCase);

        System.out.println("메서드 참조 결과:");
        upper2.forEach(n -> System.out.println("  " + n));
        System.out.println();

        // 시나리오 4: Function 체이닝
        System.out.println("📍 시나리오 4: Function 체이닝");

        Function<String, String> trim = String::trim;
        Function<String, String> upper = String::toUpperCase;
        Function<String, String> addPrefix = s -> ">> " + s;

        // andThen: f.andThen(g) = g(f(x))
        Function<String, String> chain = trim.andThen(upper).andThen(addPrefix);

        List<String> messyNames = Arrays.asList("  apple  ", "  banana  ", "  cherry  ");
        List<String> cleaned = Factory.transform(messyNames, chain);

        System.out.println("체이닝 결과:");
        cleaned.forEach(n -> System.out.println(n));
        System.out.println();

        // 시나리오 5: Stream API와 결합
        System.out.println("📍 시나리오 5: Stream API의 map()");

        List<String> names3 = Arrays.asList("apple", "banana", "cherry");

        List<Integer> wordLengths = names3.stream()
            .map(String::length)
            .collect(Collectors.toList());

        System.out.println("단어 길이:");
        wordLengths.forEach(len -> System.out.println("  " + len));
        System.out.println();

        // 시나리오 6: 복잡한 변환
        System.out.println("📍 시나리오 6: 복잡한 객체 변환");

        List<Material> materials2 = Arrays.asList(
            new Material("철", 100),
            new Material("나무", 50),
            new Material("플라스틱", 75)
        );

        // Material → String (요약 정보)
        List<String> summaries = Factory.transform(
            materials2,
            m -> String.format("[%s] %d개 보유", m.getName(), m.getQuantity())
        );

        System.out.println("요약 정보:");
        summaries.forEach(s -> System.out.println("  " + s));
    }
}
```

### 🎯 핵심 포인트

**1. Function 람다**:
```java
// Function<T, R>: T → R (변환)

Function<String, Integer> length = s -> s.length();

int result = length.apply("Hello"); // 5
```

**2. Function 체이닝**:
```java
Function<String, String> f = s -> s.trim();
Function<String, String> g = s -> s.toUpperCase();

// andThen: f 실행 후 g 실행
Function<String, String> chain1 = f.andThen(g);

// compose: g 실행 후 f 실행
Function<String, String> chain2 = f.compose(g);
```

**3. 메서드 참조**:
```java
// 람다
list.stream().map(s -> s.toUpperCase())

// 메서드 참조
list.stream().map(String::toUpperCase)

// 메서드 참조 종류:
// 1. 정적 메서드: ClassName::methodName
// 2. 인스턴스 메서드: instance::methodName
// 3. 특정 타입의 인스턴스 메서드: ClassName::methodName
// 4. 생성자: ClassName::new
```

---

## 🎓 Part 1 종합 정리

### 📊 람다 표현식 기본 문법

```java
// 기본 형식
(매개변수) -> { 실행문 }

// 1. 매개변수 없음
() -> System.out.println("Hello")

// 2. 매개변수 1개 (괄호 생략 가능)
x -> x * 2
(x) -> x * 2  // 동일

// 3. 매개변수 여러 개
(x, y) -> x + y

// 4. 타입 명시 (생략 가능)
(int x, int y) -> x + y

// 5. 실행문 여러 개 (중괄호 필요)
x -> {
    int result = x * 2;
    return result;
}

// 6. 반환값 (단일 표현식은 return 생략)
x -> x * 2           // return 생략
x -> { return x * 2; }  // 명시적 return
```

---

### 🎯 표준 함수형 인터페이스 (java.util.function)

| 인터페이스 | 메서드 | 설명 | 예시 |
|-----------|--------|------|------|
| `Predicate<T>` | `boolean test(T t)` | 조건 검사 | `x -> x > 0` |
| `Function<T, R>` | `R apply(T t)` | 변환 | `s -> s.length()` |
| `Consumer<T>` | `void accept(T t)` | 소비 | `s -> System.out.println(s)` |
| `Supplier<T>` | `T get()` | 공급 | `() -> "Hello"` |
| `UnaryOperator<T>` | `T apply(T t)` | 단항 연산 | `x -> x * 2` |
| `BinaryOperator<T>` | `T apply(T t1, T t2)` | 이항 연산 | `(x, y) -> x + y` |

---

### 💡 람다 vs 익명 클래스

| | 람다 | 익명 클래스 |
|---|------|-----------|
| **코드 길이** | 짧음 (1~3줄) | 김 (5~10줄) |
| **this** | 외부 클래스 | 익명 클래스 자체 |
| **사용 가능** | 함수형 인터페이스만 | 모든 인터페이스/추상 클래스 |
| **인스턴스 변수** | 불가 | 가능 |
| **성능** | 약간 빠름 | 약간 느림 |

---

### 🚀 실전 활용

```java
// 1. 정렬
list.sort((a, b) -> a.compareTo(b));
list.sort(Comparator.comparing(String::length));

// 2. 필터링
list.stream()
    .filter(x -> x > 10)
    .collect(Collectors.toList());

// 3. 변환
list.stream()
    .map(s -> s.toUpperCase())
    .collect(Collectors.toList());

// 4. 이벤트 핸들러
button.onClick(event -> System.out.println("Clicked"));

// 5. 스레드
new Thread(() -> System.out.println("Running")).start();
```

**다음 Part 2에서는**: 3개 기업 사례 (네이버, 쿠팡, 토스) + 4개 주니어 실수 시나리오를 다룹니다.
