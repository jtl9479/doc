# 15-3. 상속 (Inheritance) - Part 3

## 📋 목차
1. [실전 프로젝트: 게임 캐릭터 관리 시스템](#실전-프로젝트)
2. [FAQ - 자주 묻는 질문](#faq)
3. [면접 질문](#면접-질문)

---

## 🎮 실전 프로젝트: 게임 캐릭터 관리 시스템 {#실전-프로젝트}

### 프로젝트 개요
RPG 게임의 캐릭터 관리 시스템을 상속을 활용하여 구현합니다. 전사, 마법사, 궁수 등 다양한 직업의 캐릭터가 있으며, 각 캐릭터는 공통 속성과 고유 스킬을 가집니다.

### 요구사항
1. 모든 캐릭터는 이름, 레벨, HP, MP를 가짐
2. 각 직업별로 고유한 스킬과 능력치를 가짐
3. 레벨업 시스템 구현
4. 전투 시스템 구현
5. 아이템 장착 시스템 구현

---

### 1단계: 기본 클래스 설계

```java
/**
 * 모든 캐릭터의 부모 클래스
 */
public class GameCharacter {
    // 공통 속성
    protected String name;
    protected int level;
    protected int maxHp;
    protected int currentHp;
    protected int maxMp;
    protected int currentMp;
    protected int attack;
    protected int defense;
    protected int experience;
    protected String characterClass;  // 직업

    // 생성자
    public GameCharacter(String name, String characterClass) {
        this.name = name;
        this.characterClass = characterClass;
        this.level = 1;
        this.maxHp = 100;
        this.currentHp = maxHp;
        this.maxMp = 50;
        this.currentMp = maxMp;
        this.attack = 10;
        this.defense = 5;
        this.experience = 0;

        System.out.println("⚔️ 새로운 " + characterClass + " 탄생: " + name);
    }

    // 공통 메서드들
    public void showStatus() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("👤 캐릭터 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("이름: " + name);
        System.out.println("직업: " + characterClass);
        System.out.println("레벨: " + level);
        System.out.println("❤️  HP: " + currentHp + "/" + maxHp);
        System.out.println("💙 MP: " + currentMp + "/" + maxMp);
        System.out.println("⚔️  공격력: " + attack);
        System.out.println("🛡️  방어력: " + defense);
        System.out.println("✨ 경험치: " + experience + "/" + getRequiredExp());
        showHpBar();
        showMpBar();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    // HP 바 표시
    private void showHpBar() {
        int barLength = 20;
        int filledLength = (int)((double)currentHp / maxHp * barLength);
        System.out.print("HP [");
        for (int i = 0; i < barLength; i++) {
            if (i < filledLength) {
                System.out.print("█");
            } else {
                System.out.print("░");
            }
        }
        System.out.println("]");
    }

    // MP 바 표시
    private void showMpBar() {
        int barLength = 20;
        int filledLength = (int)((double)currentMp / maxMp * barLength);
        System.out.print("MP [");
        for (int i = 0; i < barLength; i++) {
            if (i < filledLength) {
                System.out.print("█");
            } else {
                System.out.print("░");
            }
        }
        System.out.println("]");
    }

    // 기본 공격
    public int basicAttack() {
        System.out.println(name + "의 기본 공격!");
        int damage = attack + (int)(Math.random() * 10);
        System.out.println("💥 " + damage + "의 피해를 입혔습니다!");
        return damage;
    }

    // 피해 받기
    public void takeDamage(int damage) {
        int actualDamage = Math.max(damage - defense, 0);
        currentHp = Math.max(currentHp - actualDamage, 0);

        System.out.println(name + "이(가) " + actualDamage + "의 피해를 받았습니다!");
        System.out.println("❤️  남은 HP: " + currentHp + "/" + maxHp);

        if (currentHp == 0) {
            System.out.println("💀 " + name + "이(가) 쓰러졌습니다!");
        }
    }

    // 회복
    public void heal(int amount) {
        int beforeHp = currentHp;
        currentHp = Math.min(currentHp + amount, maxHp);
        int healedAmount = currentHp - beforeHp;

        System.out.println("💚 " + name + "이(가) " + healedAmount + " HP 회복!");
        System.out.println("❤️  현재 HP: " + currentHp + "/" + maxHp);
    }

    // MP 회복
    public void restoreMp(int amount) {
        int beforeMp = currentMp;
        currentMp = Math.min(currentMp + amount, maxMp);
        int restoredAmount = currentMp - beforeMp;

        System.out.println("💙 " + name + "이(가) " + restoredAmount + " MP 회복!");
        System.out.println("💙 현재 MP: " + currentMp + "/" + maxMp);
    }

    // 경험치 획득
    public void gainExperience(int exp) {
        experience += exp;
        System.out.println("✨ " + exp + " 경험치 획득! (총: " + experience + ")");

        // 레벨업 체크
        while (experience >= getRequiredExp()) {
            levelUp();
        }
    }

    // 필요 경험치 계산
    private int getRequiredExp() {
        return level * 100;
    }

    // 레벨업
    protected void levelUp() {
        level++;
        experience -= getRequiredExp();

        // 능력치 상승
        maxHp += 20;
        maxMp += 10;
        attack += 5;
        defense += 3;

        // HP, MP 완전 회복
        currentHp = maxHp;
        currentMp = maxMp;

        System.out.println("\n🎉 ═══════════════════════════");
        System.out.println("   레벨 업! Level " + level);
        System.out.println("═══════════════════════════");
        System.out.println("HP: " + (maxHp - 20) + " → " + maxHp);
        System.out.println("MP: " + (maxMp - 10) + " → " + maxMp);
        System.out.println("공격력: " + (attack - 5) + " → " + attack);
        System.out.println("방어력: " + (defense - 3) + " → " + defense);
        System.out.println("═══════════════════════════\n");
    }

    // MP 사용 가능 여부 확인
    protected boolean useMp(int mpCost) {
        if (currentMp >= mpCost) {
            currentMp -= mpCost;
            return true;
        } else {
            System.out.println("❌ MP가 부족합니다! (필요: " + mpCost + ", 현재: " + currentMp + ")");
            return false;
        }
    }

    // Getter 메서드들
    public String getName() { return name; }
    public int getLevel() { return level; }
    public int getCurrentHp() { return currentHp; }
    public int getAttack() { return attack; }
    public boolean isAlive() { return currentHp > 0; }
    public String getCharacterClass() { return characterClass; }
}
```

---

### 2단계: 전사 (Warrior) 클래스

```java
/**
 * 전사 - 높은 HP와 방어력, 근접 공격 전문
 */
public class Warrior extends GameCharacter {
    private int rage;  // 분노 게이지
    private boolean isDefending;  // 방어 자세

    public Warrior(String name) {
        super(name, "전사");

        // 전사 특화 능력치
        this.maxHp = 150;  // 높은 HP
        this.currentHp = maxHp;
        this.maxMp = 30;   // 낮은 MP
        this.currentMp = maxMp;
        this.attack = 15;  // 높은 공격력
        this.defense = 10; // 높은 방어력
        this.rage = 0;
        this.isDefending = false;

        System.out.println("💪 강력한 전사가 되었습니다!");
    }

    @Override
    protected void levelUp() {
        super.levelUp();
        // 전사 추가 보너스
        maxHp += 30;  // 일반 +20, 전사 보너스 +30 = 총 +50
        defense += 2; // 일반 +3, 전사 보너스 +2 = 총 +5
        currentHp = maxHp;
        System.out.println("💪 전사 보너스: HP +30, 방어력 +2");
    }

    // 스킬 1: 강타 (Power Strike)
    public int powerStrike() {
        System.out.println("\n⚔️ " + name + "의 [강타]!");

        if (useMp(10)) {
            int damage = (int)(attack * 2.0 + Math.random() * 20);
            rage = Math.min(rage + 20, 100);  // 분노 게이지 증가

            System.out.println("💥 강력한 일격! " + damage + "의 피해!");
            System.out.println("😡 분노 게이지: " + rage + "/100");
            return damage;
        }

        return 0;
    }

    // 스킬 2: 방어 자세 (Defensive Stance)
    public void defensiveStance() {
        System.out.println("\n🛡️ " + name + "의 [방어 자세]!");

        if (useMp(15)) {
            isDefending = true;
            defense += 10;
            System.out.println("🛡️ 방어력이 크게 증가했습니다! (" + (defense - 10) + " → " + defense + ")");
            System.out.println("⚠️ 다음 공격까지 방어 자세 유지");
        }
    }

    // 스킬 3: 분노 폭발 (Rage Burst)
    public int rageBurst() {
        System.out.println("\n😡 " + name + "의 [분노 폭발]!");

        if (rage < 100) {
            System.out.println("❌ 분노 게이지가 부족합니다! (현재: " + rage + "/100)");
            return 0;
        }

        int damage = (int)(attack * 3.0 + rage);
        rage = 0;

        System.out.println("💥💥💥 폭발적인 공격! " + damage + "의 피해!");
        System.out.println("😡 분노 게이지 소진: 100 → 0");
        return damage;
    }

    @Override
    public void takeDamage(int damage) {
        // 방어 자세 효과 적용
        if (isDefending) {
            System.out.println("🛡️ 방어 자세로 피해 감소!");
            damage = (int)(damage * 0.5);  // 피해 50% 감소
            isDefending = false;
            defense -= 10;  // 방어 자세 해제
        }

        super.takeDamage(damage);

        // 피해 받을 때 분노 게이지 증가
        if (currentHp > 0) {
            rage = Math.min(rage + 10, 100);
            System.out.println("😡 분노 게이지 증가: " + rage + "/100");
        }
    }

    @Override
    public void showStatus() {
        super.showStatus();
        System.out.println("😡 분노: " + rage + "/100");
        System.out.println("🛡️  방어 자세: " + (isDefending ? "활성" : "비활성"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void showSkills() {
        System.out.println("\n⚔️ " + name + "의 스킬");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("1. 강타 (MP 10) - 공격력의 2배 피해");
        System.out.println("2. 방어 자세 (MP 15) - 방어력 증가, 다음 피해 50% 감소");
        System.out.println("3. 분노 폭발 (분노 100) - 공격력의 3배 + 분노 게이지 피해");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

---

### 3단계: 마법사 (Mage) 클래스

```java
/**
 * 마법사 - 높은 MP와 마법 공격, 낮은 방어력
 */
public class Mage extends GameCharacter {
    private int mana;  // 마나 (MP와 별개)
    private int intelligence;  // 지능

    public Mage(String name) {
        super(name, "마법사");

        // 마법사 특화 능력치
        this.maxHp = 80;   // 낮은 HP
        this.currentHp = maxHp;
        this.maxMp = 100;  // 높은 MP
        this.currentMp = maxMp;
        this.attack = 8;   // 낮은 물리 공격력
        this.defense = 3;  // 낮은 방어력
        this.mana = 0;
        this.intelligence = 20;

        System.out.println("🔮 신비로운 마법사가 되었습니다!");
    }

    @Override
    protected void levelUp() {
        super.levelUp();
        // 마법사 추가 보너스
        maxMp += 20;  // 일반 +10, 마법사 보너스 +20 = 총 +30
        intelligence += 5;
        currentMp = maxMp;
        System.out.println("🔮 마법사 보너스: MP +20, 지능 +5");
    }

    // 마법 공격력 계산
    private int getMagicAttack() {
        return attack + intelligence;
    }

    // 스킬 1: 파이어볼 (Fireball)
    public int fireball() {
        System.out.println("\n🔥 " + name + "의 [파이어볼]!");

        if (useMp(20)) {
            int damage = (int)(getMagicAttack() * 1.5 + Math.random() * 15);
            mana = Math.min(mana + 10, 100);

            System.out.println("🔥 불꽃이 적을 태웁니다! " + damage + "의 마법 피해!");
            System.out.println("✨ 마나: " + mana + "/100");
            return damage;
        }

        return 0;
    }

    // 스킬 2: 아이스 블라스트 (Ice Blast)
    public int iceBlast() {
        System.out.println("\n❄️ " + name + "의 [아이스 블라스트]!");

        if (useMp(25)) {
            int damage = (int)(getMagicAttack() * 1.8 + Math.random() * 20);
            mana = Math.min(mana + 15, 100);

            System.out.println("❄️ 얼음이 적을 얼립니다! " + damage + "의 마법 피해!");
            System.out.println("🧊 적의 이동 속도 감소!");
            System.out.println("✨ 마나: " + mana + "/100");
            return damage;
        }

        return 0;
    }

    // 스킬 3: 메테오 (Meteor)
    public int meteor() {
        System.out.println("\n☄️ " + name + "의 [메테오]!");

        if (mana < 100) {
            System.out.println("❌ 마나가 부족합니다! (현재: " + mana + "/100)");
            return 0;
        }

        if (useMp(50)) {
            int damage = (int)(getMagicAttack() * 4.0 + mana);
            mana = 0;

            System.out.println("☄️ 거대한 운석이 떨어집니다!");
            System.out.println("💥💥💥 엄청난 폭발! " + damage + "의 광역 마법 피해!");
            System.out.println("✨ 마나 소진: 100 → 0");
            return damage;
        }

        return 0;
    }

    // 스킬 4: 텔레포트 (Teleport)
    public void teleport() {
        System.out.println("\n✨ " + name + "의 [텔레포트]!");

        if (useMp(30)) {
            System.out.println("✨ 순간이동으로 안전한 곳으로 이동했습니다!");
            System.out.println("💙 MP 20 회복!");
            restoreMp(20);
        }
    }

    // 스킬 5: 힐 (Heal)
    public void healSpell() {
        System.out.println("\n💚 " + name + "의 [힐]!");

        if (useMp(35)) {
            int healAmount = (int)(intelligence * 1.5 + Math.random() * 20);
            heal(healAmount);
        }
    }

    @Override
    public int basicAttack() {
        System.out.println(name + "의 마법 탄환!");
        int damage = getMagicAttack() + (int)(Math.random() * 10);
        mana = Math.min(mana + 5, 100);
        System.out.println("✨ " + damage + "의 마법 피해!");
        System.out.println("✨ 마나: " + mana + "/100");
        return damage;
    }

    @Override
    public void showStatus() {
        super.showStatus();
        System.out.println("🔮 지능: " + intelligence);
        System.out.println("✨ 마나: " + mana + "/100");
        System.out.println("💫 마법 공격력: " + getMagicAttack());
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void showSkills() {
        System.out.println("\n🔮 " + name + "의 스킬");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("1. 파이어볼 (MP 20) - 화염 마법 공격");
        System.out.println("2. 아이스 블라스트 (MP 25) - 빙결 마법 공격");
        System.out.println("3. 메테오 (MP 50, 마나 100) - 광역 마법 공격");
        System.out.println("4. 텔레포트 (MP 30) - 순간이동 및 MP 회복");
        System.out.println("5. 힐 (MP 35) - HP 회복");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

---

### 4단계: 궁수 (Archer) 클래스

```java
/**
 * 궁수 - 빠른 공격 속도, 원거리 공격 전문
 */
public class Archer extends GameCharacter {
    private int arrows;  // 화살 수
    private int criticalChance;  // 치명타 확률 (%)
    private int agility;  // 민첩성

    public Archer(String name) {
        super(name, "궁수");

        // 궁수 특화 능력치
        this.maxHp = 100;  // 중간 HP
        this.currentHp = maxHp;
        this.maxMp = 60;   // 중간 MP
        this.currentMp = maxMp;
        this.attack = 12;  // 중간 공격력
        this.defense = 6;  // 중간 방어력
        this.arrows = 50;
        this.criticalChance = 20;  // 20% 치명타
        this.agility = 15;

        System.out.println("🏹 민첩한 궁수가 되었습니다!");
    }

    @Override
    protected void levelUp() {
        super.levelUp();
        // 궁수 추가 보너스
        agility += 3;
        criticalChance += 2;
        arrows += 20;
        System.out.println("🏹 궁수 보너스: 민첩성 +3, 치명타 +2%, 화살 +20");
    }

    // 치명타 판정
    private boolean isCritical() {
        return Math.random() * 100 < criticalChance;
    }

    // 스킬 1: 집중 사격 (Focused Shot)
    public int focusedShot() {
        System.out.println("\n🎯 " + name + "의 [집중 사격]!");

        if (arrows < 1) {
            System.out.println("❌ 화살이 부족합니다!");
            return 0;
        }

        if (useMp(15)) {
            arrows--;
            int damage = (int)((attack + agility) * 1.5);

            if (isCritical()) {
                damage *= 2;
                System.out.println("💥 치명타 발동! 2배 피해!");
            }

            System.out.println("🏹 정확한 명중! " + damage + "의 피해!");
            System.out.println("🏹 남은 화살: " + arrows);
            return damage;
        }

        return 0;
    }

    // 스킬 2: 연사 (Rapid Fire)
    public int rapidFire() {
        System.out.println("\n🏹🏹🏹 " + name + "의 [연사]!");

        int arrowsNeeded = 5;
        if (arrows < arrowsNeeded) {
            System.out.println("❌ 화살이 부족합니다! (필요: " + arrowsNeeded + ", 보유: " + arrows + ")");
            return 0;
        }

        if (useMp(25)) {
            arrows -= arrowsNeeded;
            int totalDamage = 0;

            for (int i = 0; i < 5; i++) {
                int damage = attack + agility;
                if (isCritical()) {
                    damage *= 2;
                    System.out.print("💥");
                } else {
                    System.out.print("🏹");
                }
                totalDamage += damage;
            }

            System.out.println("\n빠른 연사로 총 " + totalDamage + "의 피해!");
            System.out.println("🏹 남은 화살: " + arrows);
            return totalDamage;
        }

        return 0;
    }

    // 스킬 3: 폭발 화살 (Explosive Arrow)
    public int explosiveArrow() {
        System.out.println("\n💣 " + name + "의 [폭발 화살]!");

        if (arrows < 3) {
            System.out.println("❌ 화살이 부족합니다! (필요: 3, 보유: " + arrows + ")");
            return 0;
        }

        if (useMp(40)) {
            arrows -= 3;
            int damage = (int)((attack + agility) * 2.5 + Math.random() * 30);

            System.out.println("💣 화살이 폭발합니다!");
            System.out.println("💥💥💥 광역 폭발! " + damage + "의 피해!");
            System.out.println("🏹 남은 화살: " + arrows);
            return damage;
        }

        return 0;
    }

    // 스킬 4: 화살 제작 (Craft Arrows)
    public void craftArrows() {
        System.out.println("\n🛠️ " + name + "의 [화살 제작]!");

        if (useMp(10)) {
            int craftedArrows = 20 + (int)(Math.random() * 10);
            arrows += craftedArrows;
            System.out.println("🏹 화살 " + craftedArrows + "개 제작!");
            System.out.println("🏹 총 화살: " + arrows);
        }
    }

    @Override
    public int basicAttack() {
        if (arrows < 1) {
            System.out.println(name + "의 기본 공격! (화살 없음 - 근접 공격)");
            int damage = attack / 2;
            System.out.println("💥 " + damage + "의 피해!");
            return damage;
        }

        arrows--;
        System.out.println(name + "의 화살 사격!");
        int damage = attack + agility;

        if (isCritical()) {
            damage *= 2;
            System.out.println("💥 치명타! " + damage + "의 피해!");
        } else {
            System.out.println("🏹 " + damage + "의 피해!");
        }

        System.out.println("🏹 남은 화살: " + arrows);
        return damage;
    }

    @Override
    public void showStatus() {
        super.showStatus();
        System.out.println("🏹 화살: " + arrows);
        System.out.println("💨 민첩성: " + agility);
        System.out.println("💥 치명타 확률: " + criticalChance + "%");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    public void showSkills() {
        System.out.println("\n🏹 " + name + "의 스킬");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("1. 집중 사격 (MP 15, 화살 1) - 강력한 단일 공격");
        System.out.println("2. 연사 (MP 25, 화살 5) - 5회 빠른 공격");
        System.out.println("3. 폭발 화살 (MP 40, 화살 3) - 광역 폭발 공격");
        System.out.println("4. 화살 제작 (MP 10) - 화살 20~30개 제작");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

---

### 5단계: 게임 실행 테스트

```java
/**
 * 게임 캐릭터 시스템 테스트
 */
public class RPGGameDemo {
    public static void main(String[] args) {
        System.out.println("🎮 ═══════════════════════════════════");
        System.out.println("      RPG 게임 캐릭터 시스템");
        System.out.println("═══════════════════════════════════\n");

        // 캐릭터 생성
        Warrior warrior = new Warrior("아서");
        Mage mage = new Mage("멀린");
        Archer archer = new Archer("로빈");

        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("   파티 구성 완료!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━\n");

        // 전사 테스트
        System.out.println("\n📊 ═══ 전사 테스트 ═══");
        warrior.showStatus();
        warrior.showSkills();

        System.out.println("\n⚔️ 전투 시작!");
        warrior.powerStrike();
        warrior.takeDamage(30);
        warrior.defensiveStance();
        warrior.takeDamage(50);

        // 마법사 테스트
        System.out.println("\n\n📊 ═══ 마법사 테스트 ═══");
        mage.showStatus();
        mage.showSkills();

        System.out.println("\n🔮 마법 시전!");
        mage.fireball();
        mage.iceBlast();
        mage.healSpell();

        // 궁수 테스트
        System.out.println("\n\n📊 ═══ 궁수 테스트 ═══");
        archer.showStatus();
        archer.showSkills();

        System.out.println("\n🏹 사격 시작!");
        archer.focusedShot();
        archer.rapidFire();
        archer.craftArrows();

        // 레벨업 테스트
        System.out.println("\n\n📊 ═══ 레벨업 테스트 ═══");
        System.out.println("\n전사 레벨업:");
        warrior.gainExperience(100);
        warrior.showStatus();

        System.out.println("\n마법사 레벨업:");
        mage.gainExperience(200);
        mage.showStatus();

        System.out.println("\n궁수 레벨업:");
        archer.gainExperience(150);
        archer.showStatus();

        // 보스 전투 시뮬레이션
        System.out.println("\n\n🐲 ═══════════════════════════════════");
        System.out.println("      보스 전투!");
        System.out.println("═══════════════════════════════════");

        simulateBossBattle(warrior, mage, archer);

        // 최종 상태
        System.out.println("\n\n📊 ═══ 최종 파티 상태 ═══");
        warrior.showStatus();
        mage.showStatus();
        archer.showStatus();
    }

    private static void simulateBossBattle(Warrior warrior, Mage mage, Archer archer) {
        System.out.println("\n🐲 드래곤이 나타났다!");
        int bossHp = 500;
        int bossDamage = 40;

        System.out.println("🐲 드래곤 HP: " + bossHp);

        int round = 1;
        while (bossHp > 0 && warrior.isAlive() && mage.isAlive() && archer.isAlive()) {
            System.out.println("\n━━━━━━ 라운드 " + round + " ━━━━━━");

            // 파티 공격
            System.out.println("\n👥 파티의 공격!");

            int damage1 = warrior.powerStrike();
            bossHp -= damage1;
            System.out.println("🐲 드래곤 HP: " + Math.max(bossHp, 0) + "/500");

            if (bossHp <= 0) break;

            int damage2 = mage.fireball();
            bossHp -= damage2;
            System.out.println("🐲 드래곤 HP: " + Math.max(bossHp, 0) + "/500");

            if (bossHp <= 0) break;

            int damage3 = archer.focusedShot();
            bossHp -= damage3;
            System.out.println("🐲 드래곤 HP: " + Math.max(bossHp, 0) + "/500");

            if (bossHp <= 0) break;

            // 보스 반격
            System.out.println("\n🐲 드래곤의 불꽃 브레스!");
            warrior.takeDamage(bossDamage);
            mage.takeDamage(bossDamage);
            archer.takeDamage(bossDamage);

            // 마법사 힐
            if (round % 2 == 0) {
                System.out.println();
                mage.healSpell();
            }

            round++;

            if (round > 5) break;  // 최대 5라운드
        }

        if (bossHp <= 0) {
            System.out.println("\n🎉 ═══════════════════════════════════");
            System.out.println("      승리! 드래곤을 물리쳤습니다!");
            System.out.println("═══════════════════════════════════");

            // 경험치 보상
            warrior.gainExperience(300);
            mage.gainExperience(300);
            archer.gainExperience(300);
        } else {
            System.out.println("\n💀 전투 종료");
        }
    }
}
```

### 실행 결과

```
🎮 ═══════════════════════════════════
      RPG 게임 캐릭터 시스템
═══════════════════════════════════

⚔️ 새로운 전사 탄생: 아서
💪 강력한 전사가 되었습니다!
⚔️ 새로운 마법사 탄생: 멀린
🔮 신비로운 마법사가 되었습니다!
⚔️ 새로운 궁수 탄생: 로빈
🏹 민첩한 궁수가 되었습니다!

━━━━━━━━━━━━━━━━━━━━━━━━━━
   파티 구성 완료!
━━━━━━━━━━━━━━━━━━━━━━━━━━


📊 ═══ 전사 테스트 ═══

━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 캐릭터 정보
━━━━━━━━━━━━━━━━━━━━━━━━━━
이름: 아서
직업: 전사
레벨: 1
❤️  HP: 150/150
💙 MP: 30/30
⚔️  공격력: 15
🛡️  방어력: 10
✨ 경험치: 0/100
HP [████████████████████]
MP [████████████████████]
━━━━━━━━━━━━━━━━━━━━━━━━━━
😡 분노: 0/100
🛡️  방어 자세: 비활성
━━━━━━━━━━━━━━━━━━━━━━━━━━

⚔️ 아서의 스킬
━━━━━━━━━━━━━━━━━━━━
1. 강타 (MP 10) - 공격력의 2배 피해
2. 방어 자세 (MP 15) - 방어력 증가, 다음 피해 50% 감소
3. 분노 폭발 (분노 100) - 공격력의 3배 + 분노 게이지 피해
━━━━━━━━━━━━━━━━━━━━

⚔️ 전투 시작!

⚔️ 아서의 [강타]!
💥 강력한 일격! 37의 피해!
😡 분노 게이지: 20/100
아서이(가) 20의 피해를 받았습니다!
❤️  남은 HP: 130/150
😡 분노 게이지 증가: 30/100

🛡️ 아서의 [방어 자세]!
🛡️ 방어력이 크게 증가했습니다! (10 → 20)
⚠️ 다음 공격까지 방어 자세 유지
🛡️ 방어 자세로 피해 감소!
아서이(가) 5의 피해를 받았습니다!
❤️  남은 HP: 125/150
😡 분노 게이지 증가: 40/100


📊 ═══ 마법사 테스트 ═══

━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 캐릭터 정보
━━━━━━━━━━━━━━━━━━━━━━━━━━
이름: 멀린
직업: 마법사
레벨: 1
❤️  HP: 80/80
💙 MP: 100/100
⚔️  공격력: 8
🛡️  방어력: 3
✨ 경험치: 0/100
HP [████████████████████]
MP [████████████████████]
━━━━━━━━━━━━━━━━━━━━━━━━━━
🔮 지능: 20
✨ 마나: 0/100
💫 마법 공격력: 28
━━━━━━━━━━━━━━━━━━━━━━━━━━

🔮 멀린의 스킬
━━━━━━━━━━━━━━━━━━━━
1. 파이어볼 (MP 20) - 화염 마법 공격
2. 아이스 블라스트 (MP 25) - 빙결 마법 공격
3. 메테오 (MP 50, 마나 100) - 광역 마법 공격
4. 텔레포트 (MP 30) - 순간이동 및 MP 회복
5. 힐 (MP 35) - HP 회복
━━━━━━━━━━━━━━━━━━━━

🔮 마법 시전!

🔥 멀린의 [파이어볼]!
🔥 불꽃이 적을 태웁니다! 49의 마법 피해!
✨ 마나: 10/100

❄️ 멀린의 [아이스 블라스트]!
❄️ 얼음이 적을 얼립니다! 60의 마법 피해!
🧊 적의 이동 속도 감소!
✨ 마나: 25/100

💚 멀린의 [힐]!
💚 멀린이(가) 33 HP 회복!
❤️  현재 HP: 80/80


📊 ═══ 궁수 테스트 ═══

━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 캐릭터 정보
━━━━━━━━━━━━━━━━━━━━━━━━━━
이름: 로빈
직업: 궁수
레벨: 1
❤️  HP: 100/100
💙 MP: 60/60
⚔️  공격력: 12
🛡️  방어력: 6
✨ 경험치: 0/100
HP [████████████████████]
MP [████████████████████]
━━━━━━━━━━━━━━━━━━━━━━━━━━
🏹 화살: 50
💨 민첩성: 15
💥 치명타 확률: 20%
━━━━━━━━━━━━━━━━━━━━━━━━━━

🏹 로빈의 스킬
━━━━━━━━━━━━━━━━━━━━
1. 집중 사격 (MP 15, 화살 1) - 강력한 단일 공격
2. 연사 (MP 25, 화살 5) - 5회 빠른 공격
3. 폭발 화살 (MP 40, 화살 3) - 광역 폭발 공격
4. 화살 제작 (MP 10) - 화살 20~30개 제작
━━━━━━━━━━━━━━━━━━━━

🏹 사격 시작!

🎯 로빈의 [집중 사격]!
💥 치명타 발동! 2배 피해!
🏹 정확한 명중! 80의 피해!
🏹 남은 화살: 49

🏹🏹🏹 로빈의 [연사]!
💥🏹💥🏹🏹
빠른 연사로 총 162의 피해!
🏹 남은 화살: 44

🛠️ 로빈의 [화살 제작]!
🏹 화살 25개 제작!
🏹 총 화살: 69


📊 ═══ 레벨업 테스트 ═══

전사 레벨업:
✨ 100 경험치 획득! (총: 100)

🎉 ═══════════════════════════
   레벨 업! Level 2
═══════════════════════════
HP: 150 → 220
MP: 30 → 40
공격력: 15 → 20
방어력: 10 → 15
═══════════════════════════

💪 전사 보너스: HP +30, 방어력 +2

━━━━━━━━━━━━━━━━━━━━━━━━━━
👤 캐릭터 정보
━━━━━━━━━━━━━━━━━━━━━━━━━━
이름: 아서
직업: 전사
레벨: 2
❤️  HP: 220/220
💙 MP: 40/40
⚔️  공격력: 20
🛡️  방어력: 15
✨ 경험치: 0/200
HP [████████████████████]
MP [████████████████████]
━━━━━━━━━━━━━━━━━━━━━━━━━━
😡 분노: 40/100
🛡️  방어 자세: 비활성
━━━━━━━━━━━━━━━━━━━━━━━━━━

[... 이하 생략 ...]
```

---

## ❓ FAQ - 자주 묻는 질문 {#faq}

### Q1. 상속을 사용하면 무조건 좋은가요?

**A:** 아니요. 상속은 강력한 도구지만 남용하면 문제가 발생합니다.

**상속을 사용하면 좋은 경우:**
- 명확한 IS-A 관계가 있을 때
- 부모와 자식이 강하게 결합되어야 할 때
- 코드 재사용이 필요할 때

**상속을 피해야 하는 경우:**
- HAS-A 관계일 때 (포함 사용)
- 자식 클래스가 부모의 모든 기능을 필요로 하지 않을 때
- 다중 상속이 필요할 때 (인터페이스 사용)

```java
// ❌ 잘못된 상속
class Stack extends ArrayList {
    // ArrayList의 모든 메서드가 노출됨 (잘못된 설계)
}

// ✅ 올바른 포함
class Stack {
    private ArrayList list = new ArrayList();  // 포함

    public void push(Object obj) {
        list.add(obj);
    }

    public Object pop() {
        return list.remove(list.size() - 1);
    }
}
```

---

### Q2. Java에서 다중 상속이 불가능한 이유는 무엇인가요?

**A:** Java는 **다이아몬드 문제(Diamond Problem)**를 피하기 위해 다중 상속을 금지합니다.

**다이아몬드 문제란?**
```java
// ❌ 가상의 다중 상속 (Java에서 불가능)
class A {
    public void show() {
        System.out.println("A");
    }
}

class B extends A {
    @Override
    public void show() {
        System.out.println("B");
    }
}

class C extends A {
    @Override
    public void show() {
        System.out.println("C");
    }
}

// ❌ D는 B와 C 둘 다 상속 (불가능)
class D extends B, C {  // 컴파일 에러!
    // show()를 호출하면 B의 것? C의 것? → 모호함!
}
```

**Java의 해결책:**
1. **단일 상속**: 클래스는 하나의 부모만 상속
2. **인터페이스**: 여러 인터페이스 구현 가능 (다중 구현)

```java
// ✅ Java에서의 해결 방법
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck extends Animal implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("날고 있습니다");
    }

    @Override
    public void swim() {
        System.out.println("수영하고 있습니다");
    }
}
```

---

### Q3. protected와 private, public의 정확한 차이는 무엇인가요?

**A:** 접근 제어자는 멤버의 접근 범위를 제어합니다.

| 접근 제어자 | 같은 클래스 | 같은 패키지 | 자식 클래스<br>(다른 패키지) | 전체 |
|------------|-----------|-----------|------------------------|------|
| `private` | ✅ | ❌ | ❌ | ❌ |
| `default`<br>(없음) | ✅ | ✅ | ❌ | ❌ |
| `protected` | ✅ | ✅ | ✅ | ❌ |
| `public` | ✅ | ✅ | ✅ | ✅ |

**실무 가이드:**
```java
public class BankAccount {
    // ✅ 외부 완전 차단 - 내부 로직에만 사용
    private String accountPassword;

    // ✅ 자식 클래스에서도 접근 필요 - 상속 고려
    protected long balance;

    // ✅ 같은 패키지 내 접근 허용 - 기본값
    String accountType;

    // ✅ 모든 곳에서 접근 가능 - API
    public String accountNumber;
}
```

**상속에서의 활용:**
```java
class Parent {
    private int a = 1;    // 자식 접근 불가
    protected int b = 2;  // 자식 접근 가능
    public int c = 3;     // 자식 접근 가능
}

class Child extends Parent {
    public void test() {
        // System.out.println(a);  // ❌ 컴파일 에러
        System.out.println(b);  // ✅ 접근 가능
        System.out.println(c);  // ✅ 접근 가능
    }
}
```

---

### Q4. super()를 명시적으로 호출하지 않으면 어떻게 되나요?

**A:** 컴파일러가 자동으로 `super()`를 첫 줄에 추가합니다.

**자동 추가되는 경우:**
```java
class Parent {
    public Parent() {
        System.out.println("부모 생성자");
    }
}

class Child extends Parent {
    public Child() {
        // super();  // ← 컴파일러가 자동 추가
        System.out.println("자식 생성자");
    }
}

// 실행 결과:
// 부모 생성자
// 자식 생성자
```

**에러가 발생하는 경우:**
```java
class Parent {
    // 기본 생성자 없음
    public Parent(String name) {
        System.out.println("부모: " + name);
    }
}

class Child extends Parent {
    public Child() {
        // super();  // ← 컴파일러가 자동 추가하지만...
        // Parent에 기본 생성자가 없어서 에러!
    }
}

// ❌ 컴파일 에러:
// There is no default constructor available in 'Parent'
```

**해결 방법:**
```java
class Child extends Parent {
    public Child() {
        super("기본 이름");  // ✅ 명시적으로 매개변수 전달
        System.out.println("자식 생성자");
    }
}
```

---

### Q5. 부모 메서드를 자식에서 오버라이드할 때 주의사항은?

**A:** 메서드 오버라이딩 시 여러 규칙을 지켜야 합니다.

**오버라이딩 규칙:**
1. **메서드 시그니처가 동일**해야 함 (이름, 매개변수)
2. **리턴 타입이 같거나 하위 타입**이어야 함 (공변 반환)
3. **접근 제어자를 더 좁게 할 수 없음**
4. **더 많은 예외를 던질 수 없음**

```java
class Parent {
    protected Object getData() throws IOException {
        return new Object();
    }
}

// ✅ 올바른 오버라이딩
class Child1 extends Parent {
    @Override
    public String getData() {  // ✅ String은 Object의 하위 타입 (공변 반환)
        return "data";
    }
}

// ❌ 잘못된 오버라이딩
class Child2 extends Parent {
    @Override
    private Object getData() {  // ❌ 접근 제어자를 더 좁게 변경 (에러!)
        return new Object();
    }
}

// ❌ 잘못된 오버라이딩
class Child3 extends Parent {
    @Override
    public Object getData() throws Exception {  // ❌ 더 상위 예외 던짐 (에러!)
        return new Object();
    }
}
```

**@Override 어노테이션 사용 권장:**
```java
class Child extends Parent {
    @Override  // ✅ 컴파일러가 오버라이딩 검증
    public Object getData() {
        return super.getData();
    }
}
```

---

### Q6. 생성자 체이닝(Constructor Chaining)이란?

**A:** 한 생성자에서 다른 생성자를 호출하는 것을 말합니다.

**this()를 사용한 체이닝:**
```java
public class Employee {
    private String name;
    private int age;
    private String department;
    private double salary;

    // 모든 매개변수를 받는 생성자
    public Employee(String name, int age, String department, double salary) {
        this.name = name;
        this.age = age;
        this.department = department;
        this.salary = salary;
    }

    // 일부 매개변수만 받는 생성자 - this()로 체이닝
    public Employee(String name, int age) {
        this(name, age, "미정", 0.0);  // ✅ 다른 생성자 호출
    }

    // 최소 매개변수 생성자
    public Employee(String name) {
        this(name, 0);  // ✅ 위의 생성자 호출
    }
}

// 호출 체인:
// Employee("홍길동")
//   → this("홍길동", 0)
//     → this("홍길동", 0, "미정", 0.0)
```

**super()와 this()를 함께 사용할 수 없는 이유:**
```java
class Child extends Parent {
    public Child(String name) {
        super(name);  // ❌ super()와
        this();       // ❌ this()를 동시에 사용 불가!
        // 둘 다 생성자의 첫 줄에 와야 하기 때문
    }
}
```

---

### Q7. Object 클래스와의 관계는?

**A:** Java의 모든 클래스는 암시적으로 `Object` 클래스를 상속합니다.

**Object 클래스의 주요 메서드:**
```java
public class MyClass {
    // extends Object가 자동으로 추가됨
}

// 위 코드는 실제로 이렇게 동작:
public class MyClass extends Object {
    // Object의 메서드들을 모두 상속받음
}
```

**Object 클래스의 주요 메서드:**
```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // ✅ Object의 toString() 오버라이딩
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }

    // ✅ Object의 equals() 오버라이딩
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }

    // ✅ Object의 hashCode() 오버라이딩
    @Override
    public int hashCode() {
        return name.hashCode() + age;
    }
}

// 사용 예시:
Person p1 = new Person("홍길동", 30);
Person p2 = new Person("홍길동", 30);

System.out.println(p1.toString());  // Person{name='홍길동', age=30}
System.out.println(p1.equals(p2));  // true
System.out.println(p1.hashCode()); // 계산된 해시코드
```

**Object의 주요 메서드:**
| 메서드 | 설명 | 오버라이딩 권장 |
|--------|------|----------------|
| `toString()` | 객체의 문자열 표현 | ✅ 권장 |
| `equals()` | 객체 동등성 비교 | ✅ 권장 |
| `hashCode()` | 해시 코드 반환 | ✅ equals() 오버라이딩 시 필수 |
| `clone()` | 객체 복제 | ⚠️ 필요시 |
| `getClass()` | 클래스 정보 | ❌ final 메서드 |
| `finalize()` | 가비지 수집 전 호출 | ❌ Deprecated |

---

## 💼 면접 질문 {#면접-질문}

### 주니어 레벨 (Junior Level)

#### Q1. 상속이란 무엇이며, 왜 사용하나요?

**모범 답안:**
상속은 기존 클래스의 속성과 메서드를 새로운 클래스가 물려받는 객체지향 프로그래밍의 핵심 개념입니다.

**사용 이유:**
1. **코드 재사용**: 공통 기능을 부모 클래스에 한 번만 작성
2. **계층 구조**: 클래스 간의 관계를 명확하게 표현
3. **다형성**: 부모 타입으로 자식 객체를 다룰 수 있음
4. **유지보수성**: 공통 기능 수정 시 부모 클래스만 수정

```java
// 예시
class Animal {
    protected String name;

    public void eat() {
        System.out.println(name + " 먹는 중");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println(name + " 짖는 중");
    }
}

// Dog는 eat() 메서드를 재사용하면서 bark()라는 고유 기능 추가
```

**핵심 키워드:** 코드 재사용, IS-A 관계, extends, 다형성

---

#### Q2. IS-A 관계와 HAS-A 관계의 차이를 설명하세요.

**모범 답안:**
- **IS-A 관계**: "~은 ~이다" (상속 사용)
- **HAS-A 관계**: "~은 ~을 가진다" (포함 사용)

**IS-A 예시:**
```java
class Vehicle { }
class Car extends Vehicle { }  // "자동차는 차량이다"
```

**HAS-A 예시:**
```java
class Engine { }
class Car {
    private Engine engine;  // "자동차는 엔진을 가진다"
}
```

**선택 기준:**
- 부모의 모든 특성을 자식이 가져야 하면 → IS-A (상속)
- 독립적인 객체를 포함하면 → HAS-A (포함)

**핵심 키워드:** IS-A (상속), HAS-A (포함/Composition), extends vs 멤버 변수

---

#### Q3. super 키워드의 역할을 설명하세요.

**모범 답안:**
`super`는 부모 클래스의 멤버에 접근하기 위한 참조 변수입니다.

**주요 사용 용도:**
1. **부모 생성자 호출**: `super()`
2. **부모 메서드 호출**: `super.methodName()`
3. **부모 필드 접근**: `super.fieldName`

```java
class Parent {
    protected int value = 100;

    public Parent(int value) {
        this.value = value;
    }

    public void show() {
        System.out.println("Parent: " + value);
    }
}

class Child extends Parent {
    private int value = 200;

    public Child() {
        super(10);  // 1️⃣ 부모 생성자 호출
    }

    @Override
    public void show() {
        super.show();  // 2️⃣ 부모 메서드 호출
        System.out.println("Parent value: " + super.value);  // 3️⃣ 부모 필드 접근
        System.out.println("Child value: " + this.value);
    }
}
```

**핵심 키워드:** super(), 부모 생성자, 부모 메서드 호출, this vs super

---

#### Q4. 생성자에서 super()를 항상 명시해야 하나요?

**모범 답안:**
아니요, 명시하지 않으면 컴파일러가 자동으로 `super()`를 추가합니다.

**자동 추가되는 경우:**
```java
class Parent {
    public Parent() { }  // 기본 생성자 존재
}

class Child extends Parent {
    public Child() {
        // super();  ← 컴파일러가 자동 추가
        System.out.println("Child");
    }
}
```

**에러가 발생하는 경우:**
```java
class Parent {
    public Parent(int x) { }  // 매개변수 있는 생성자만 존재
    // 기본 생성자 없음!
}

class Child extends Parent {
    public Child() {
        // super();  ← 자동 추가되지만 Parent()가 없어서 에러!
    }
}

// ✅ 해결:
class Child extends Parent {
    public Child() {
        super(10);  // 명시적으로 호출
    }
}
```

**핵심 키워드:** super() 자동 호출, 기본 생성자, 명시적 호출 필요 시점

---

#### Q5. protected 접근 제어자는 언제 사용하나요?

**모범 답안:**
`protected`는 같은 패키지 또는 자식 클래스에서 접근을 허용할 때 사용합니다.

**접근 범위:**
- ✅ 같은 클래스
- ✅ 같은 패키지
- ✅ 자식 클래스 (다른 패키지도 가능)
- ❌ 그 외 모든 클래스

**사용 시나리오:**
```java
public class BankAccount {
    private String password;      // ❌ 자식도 접근 불가
    protected long balance;       // ✅ 자식이 접근 가능
    public String accountNumber;  // ✅ 모두 접근 가능

    protected void updateBalance(long amount) {
        // 자식 클래스가 잔액을 변경할 수 있도록 허용
        balance += amount;
    }
}

class SavingsAccount extends BankAccount {
    public void addInterest(double rate) {
        // ✅ protected 멤버 접근 가능
        long interest = (long)(balance * rate);
        updateBalance(interest);
    }
}
```

**사용 가이드:**
- 외부 완전 차단: `private`
- 상속 구조에서 공유: `protected`
- 공개 API: `public`

**핵심 키워드:** protected, 상속에서의 접근 제어, private vs protected vs public

---

#### Q6. 메서드 오버라이딩의 규칙을 설명하세요.

**모범 답안:**
메서드 오버라이딩은 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것입니다.

**오버라이딩 규칙:**
1. **메서드 시그니처 동일**: 이름, 매개변수 타입, 개수가 같아야 함
2. **리턴 타입 동일 또는 하위 타입**: 공변 반환 타입 허용
3. **접근 제어자 범위 확대만 가능**: `protected` → `public` (O), `public` → `protected` (X)
4. **더 많은 예외를 던질 수 없음**: 예외 범위를 좁히거나 유지해야 함

```java
class Parent {
    protected Object getData() throws IOException {
        return new Object();
    }
}

class Child extends Parent {
    // ✅ 올바른 오버라이딩
    @Override
    public String getData() {  // String은 Object의 하위 타입
        return "data";
    }
}

// ❌ 잘못된 예시들
class BadChild extends Parent {
    @Override
    private Object getData() { }  // ❌ 접근 제어자를 좁힘

    @Override
    public Object getData() throws Exception { }  // ❌ 더 상위 예외

    @Override
    public Object getData(int x) { }  // ❌ 매개변수 다름 (오버로딩임)
}
```

**핵심 키워드:** @Override, 메서드 시그니처, 공변 반환 타입, 접근 제어자

---

#### Q7. this()와 super()의 차이점은 무엇인가요?

**모범 답안:**
- `this()`: 같은 클래스의 다른 생성자 호출
- `super()`: 부모 클래스의 생성자 호출

**비교:**
```java
class Parent {
    protected String name;

    public Parent(String name) {
        this.name = name;
    }
}

class Child extends Parent {
    private int age;

    // super() 사용
    public Child(String name, int age) {
        super(name);  // 부모 생성자 호출
        this.age = age;
    }

    // this() 사용
    public Child(String name) {
        this(name, 0);  // 같은 클래스의 다른 생성자 호출
    }

    public Child() {
        this("Unknown");  // 같은 클래스의 다른 생성자 호출
    }
}
```

**공통 규칙:**
- 생성자의 첫 줄에만 사용 가능
- 둘 중 하나만 사용 가능 (동시 사용 불가)

**생성자 호출 체인:**
```
Child()
  → this("Unknown")
    → this("Unknown", 0)
      → super("Unknown")
        → Parent("Unknown")
```

**핵심 키워드:** this(), super(), 생성자 체이닝, 첫 줄 규칙

---

### 중급 레벨 (Intermediate Level)

#### Q8. Java에서 다중 상속이 불가능한 이유와 해결 방법을 설명하세요.

**모범 답안:**
Java는 **다이아몬드 문제(Diamond Problem)**를 방지하기 위해 클래스의 다중 상속을 금지합니다.

**다이아몬드 문제:**
```
     A
    / \
   B   C
    \ /
     D
```

만약 B와 C가 모두 A의 메서드를 오버라이드하고, D가 B와 C를 다중 상속하면, D에서 해당 메서드 호출 시 어느 것을 호출해야 할지 모호해집니다.

**Java의 해결 방법:**

1. **단일 상속 + 다중 인터페이스 구현:**
```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Animal {
    public void eat() {
        System.out.println("먹는 중");
    }
}

// ✅ 하나의 클래스 상속 + 여러 인터페이스 구현
class Duck extends Animal implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("날고 있습니다");
    }

    @Override
    public void swim() {
        System.out.println("수영하고 있습니다");
    }
}
```

2. **Java 8 이후 인터페이스의 default 메서드:**
```java
interface Flyable {
    default void move() {
        System.out.println("하늘을 날아 이동");
    }
}

interface Swimmable {
    default void move() {
        System.out.println("물에서 수영");
    }
}

class Duck implements Flyable, Swimmable {
    // ✅ 충돌 시 명시적으로 오버라이드 필수
    @Override
    public void move() {
        Flyable.super.move();  // 특정 인터페이스의 구현 선택
    }
}
```

**핵심 키워드:** 다이아몬드 문제, 단일 상속, 다중 인터페이스, default 메서드

---

#### Q9. 상속과 컴포지션(Composition)의 차이점과 선택 기준을 설명하세요.

**모범 답안:**
- **상속**: 클래스 간 IS-A 관계, `extends` 사용
- **컴포지션**: 클래스 간 HAS-A 관계, 객체를 멤버로 포함

**상속의 특징:**
```java
// 상속: "자동차는 차량이다"
class Vehicle {
    protected String brand;

    public void start() {
        System.out.println("시동 걸기");
    }
}

class Car extends Vehicle {
    public void drive() {
        start();  // 부모 메서드 직접 호출 가능
    }
}
```

**장점:**
- 코드 재사용이 간단함
- 다형성 활용 가능
- 계층 구조가 명확함

**단점:**
- 강한 결합 (부모 변경 시 자식 영향)
- 캡슐화 약화
- 런타임에 관계 변경 불가

**컴포지션의 특징:**
```java
// 컴포지션: "자동차는 엔진을 가진다"
class Engine {
    public void start() {
        System.out.println("엔진 시동");
    }
}

class Car {
    private Engine engine;  // 포함

    public Car(Engine engine) {
        this.engine = engine;
    }

    public void start() {
        engine.start();  // 위임
    }

    // ✅ 런타임에 엔진 교체 가능
    public void replaceEngine(Engine newEngine) {
        this.engine = newEngine;
    }
}
```

**장점:**
- 느슨한 결합
- 런타임에 동작 변경 가능
- 더 나은 캡슐화
- 다중 객체 포함 가능

**선택 기준:**

| 기준 | 상속 | 컴포지션 |
|------|------|---------|
| 관계 | IS-A | HAS-A |
| 결합도 | 강함 | 약함 |
| 유연성 | 낮음 | 높음 |
| 다형성 | 필요함 | 필요 없음 |
| 런타임 변경 | 불가 | 가능 |

**실무 가이드:**
- 명확한 IS-A 관계 + 다형성 필요 → 상속
- 기능 재사용만 필요 → 컴포지션
- 확신이 없으면 → 컴포지션 우선

**핵심 키워드:** 상속 vs 컴포지션, IS-A vs HAS-A, 강한 결합 vs 느슨한 결합, 위임(delegation)

---

#### Q10. Object 클래스의 역할과 주요 메서드를 설명하세요.

**모범 답안:**
`Object`는 Java의 모든 클래스가 암시적으로 상속하는 최상위 클래스입니다.

**주요 메서드:**

1. **toString()**: 객체의 문자열 표현
```java
@Override
public String toString() {
    return "Person{name='" + name + "', age=" + age + "}";
}
```

2. **equals()**: 객체 동등성 비교
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;

    Person person = (Person) obj;
    return age == person.age && Objects.equals(name, person.name);
}
```

3. **hashCode()**: 해시 기반 컬렉션에서 사용
```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

4. **clone()**: 객체 복제 (얕은 복사)
```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
```

5. **getClass()**: 런타임 클래스 정보
```java
Class<?> clazz = obj.getClass();
System.out.println(clazz.getName());
```

**equals()와 hashCode() 계약:**
- `equals()`가 true면 `hashCode()`도 같아야 함
- `equals()`를 오버라이드하면 `hashCode()`도 반드시 오버라이드

```java
// ❌ 잘못된 예
class Person {
    private String name;

    @Override
    public boolean equals(Object obj) {
        // equals만 오버라이드
    }
    // hashCode() 오버라이드 안 함 → 버그 발생!
}

// ✅ 올바른 예
class Person {
    private String name;

    @Override
    public boolean equals(Object obj) { ... }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}
```

**핵심 키워드:** Object 클래스, toString, equals, hashCode, clone, getClass

---

#### Q11. 상속과 다형성의 관계를 설명하고, 실무에서의 활용 예시를 제시하세요.

**모범 답안:**
상속은 다형성을 구현하는 핵심 메커니즘입니다. 부모 타입의 참조 변수로 자식 객체를 다룰 수 있게 합니다.

**다형성의 구현:**
```java
class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("야옹!");
    }
}

// ✅ 다형성 활용
Animal[] animals = {new Dog(), new Cat(), new Dog()};

for (Animal animal : animals) {
    animal.makeSound();  // 각 객체의 실제 타입에 따라 다른 동작
}

// 출력:
// 멍멍!
// 야옹!
// 멍멍!
```

**실무 활용 예시 1: 결제 시스템**
```java
abstract class PaymentMethod {
    protected String accountInfo;

    public abstract boolean processPayment(long amount);
    public abstract String getPaymentType();
}

class CreditCard extends PaymentMethod {
    @Override
    public boolean processPayment(long amount) {
        System.out.println("신용카드 결제: " + amount + "원");
        // 신용카드 결제 로직
        return true;
    }

    @Override
    public String getPaymentType() {
        return "신용카드";
    }
}

class KakaoPay extends PaymentMethod {
    @Override
    public boolean processPayment(long amount) {
        System.out.println("카카오페이 결제: " + amount + "원");
        // 카카오페이 API 호출
        return true;
    }

    @Override
    public String getPaymentType() {
        return "카카오페이";
    }
}

class NaverPay extends PaymentMethod {
    @Override
    public boolean processPayment(long amount) {
        System.out.println("네이버페이 결제: " + amount + "원");
        // 네이버페이 API 호출
        return true;
    }

    @Override
    public String getPaymentType() {
        return "네이버페이";
    }
}

// ✅ 결제 처리 시스템
class PaymentProcessor {
    public void processOrder(PaymentMethod payment, long amount) {
        // 어떤 결제 수단이든 동일하게 처리
        System.out.println("결제 수단: " + payment.getPaymentType());

        if (payment.processPayment(amount)) {
            System.out.println("결제 성공!");
        } else {
            System.out.println("결제 실패!");
        }
    }
}

// 사용
PaymentProcessor processor = new PaymentProcessor();
processor.processOrder(new CreditCard(), 50_000);
processor.processOrder(new KakaoPay(), 30_000);
processor.processOrder(new NaverPay(), 20_000);
```

**실무 활용 예시 2: 로깅 시스템**
```java
abstract class Logger {
    public void log(String message) {
        String formatted = formatMessage(message);
        write(formatted);
    }

    protected String formatMessage(String message) {
        return "[" + LocalDateTime.now() + "] " + message;
    }

    protected abstract void write(String message);
}

class FileLogger extends Logger {
    @Override
    protected void write(String message) {
        // 파일에 기록
        System.out.println("파일에 기록: " + message);
    }
}

class DatabaseLogger extends Logger {
    @Override
    protected void write(String message) {
        // DB에 저장
        System.out.println("DB에 저장: " + message);
    }
}

class CloudLogger extends Logger {
    @Override
    protected void write(String message) {
        // 클라우드에 전송
        System.out.println("클라우드 전송: " + message);
    }
}

// ✅ 로거 선택을 런타임에 결정
class Application {
    private Logger logger;

    public Application(String loggerType) {
        switch (loggerType) {
            case "file":
                logger = new FileLogger();
                break;
            case "database":
                logger = new DatabaseLogger();
                break;
            case "cloud":
                logger = new CloudLogger();
                break;
        }
    }

    public void doSomething() {
        logger.log("작업 시작");
        // 비즈니스 로직
        logger.log("작업 완료");
    }
}
```

**다형성의 이점:**
1. **확장성**: 새로운 결제 수단 추가 시 기존 코드 변경 불필요
2. **유연성**: 런타임에 객체 타입 결정 가능
3. **유지보수성**: 공통 인터페이스로 일관된 처리

**핵심 키워드:** 다형성, 동적 바인딩, 런타임 다형성, 실무 활용, 확장성

---

#### Q12. 상속의 단점과 이를 보완하는 설계 패턴을 설명하세요.

**모범 답안:**

**상속의 단점:**

1. **강한 결합 (Tight Coupling)**
```java
class Parent {
    protected void internalMethod() {
        // 내부 구현
    }
}

class Child extends Parent {
    public void doSomething() {
        internalMethod();  // 부모의 내부 구현에 의존
    }
}

// Parent의 internalMethod() 변경 시 Child에 영향
```

2. **캡슐화 위반**
```java
class Parent {
    protected int data;  // 자식에게 노출됨
}

class Child extends Parent {
    public void changeData() {
        data = 100;  // 부모의 내부 상태 직접 변경
    }
}
```

3. **불필요한 기능 상속**
```java
class Stack extends Vector {
    // Vector의 불필요한 메서드들까지 모두 상속받음
    // add(int index, Object element) 같은 메서드는 Stack에 부적합
}
```

4. **다중 상속 불가**
```java
// ❌ Java에서 불가능
class Child extends Parent1, Parent2 {
}
```

**보완 설계 패턴:**

**1. 컴포지션 패턴 (Composition over Inheritance)**
```java
// ❌ 상속
class Stack extends ArrayList {
    public void push(Object obj) {
        add(obj);
    }
}

// ✅ 컴포지션
class Stack {
    private List list = new ArrayList();  // 포함

    public void push(Object obj) {
        list.add(obj);  // 위임
    }

    public Object pop() {
        return list.remove(list.size() - 1);
    }

    // ArrayList의 불필요한 메서드는 노출되지 않음
}
```

**2. 전략 패턴 (Strategy Pattern)**
```java
// ❌ 상속으로 구현
class Duck {
    public void fly() {
        System.out.println("날고 있습니다");
    }
}

class RubberDuck extends Duck {
    @Override
    public void fly() {
        // 고무 오리는 날 수 없음!
        throw new UnsupportedOperationException();
    }
}

// ✅ 전략 패턴
interface FlyBehavior {
    void fly();
}

class FlyWithWings implements FlyBehavior {
    public void fly() {
        System.out.println("날고 있습니다");
    }
}

class FlyNoWay implements FlyBehavior {
    public void fly() {
        System.out.println("날 수 없습니다");
    }
}

class Duck {
    private FlyBehavior flyBehavior;

    public void setFlyBehavior(FlyBehavior fb) {
        this.flyBehavior = fb;
    }

    public void performFly() {
        flyBehavior.fly();
    }
}

// 사용
Duck mallard = new Duck();
mallard.setFlyBehavior(new FlyWithWings());
mallard.performFly();  // "날고 있습니다"

Duck rubber = new Duck();
rubber.setFlyBehavior(new FlyNoWay());
rubber.performFly();  // "날 수 없습니다"
```

**3. 인터페이스 + 디폴트 메서드**
```java
interface Drawable {
    void draw();

    default void rotate(int angle) {
        System.out.println(angle + "도 회전");
    }
}

interface Movable {
    void move(int x, int y);

    default void stop() {
        System.out.println("정지");
    }
}

// ✅ 다중 구현으로 다중 상속 효과
class Shape implements Drawable, Movable {
    @Override
    public void draw() {
        System.out.println("도형 그리기");
    }

    @Override
    public void move(int x, int y) {
        System.out.println("(" + x + ", " + y + ")로 이동");
    }

    // rotate(), stop()은 디폴트 메서드 사용 가능
}
```

**4. 템플릿 메서드 패턴**
```java
abstract class DataProcessor {
    // 템플릿 메서드
    public final void process() {
        readData();
        processData();
        saveData();
    }

    protected abstract void readData();
    protected abstract void processData();
    protected abstract void saveData();
}

class CSVProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("CSV 파일 읽기");
    }

    @Override
    protected void processData() {
        System.out.println("CSV 데이터 처리");
    }

    @Override
    protected void saveData() {
        System.out.println("CSV 저장");
    }
}
```

**선택 가이드:**

| 상황 | 권장 패턴 |
|------|----------|
| 행동을 런타임에 변경하고 싶을 때 | 전략 패턴 |
| 불필요한 메서드 노출을 피하고 싶을 때 | 컴포지션 |
| 여러 기능을 조합하고 싶을 때 | 인터페이스 다중 구현 |
| 알고리즘의 골격은 같고 세부만 다를 때 | 템플릿 메서드 |

**핵심 키워드:** 상속의 단점, Composition over Inheritance, 전략 패턴, 템플릿 메서드 패턴, 느슨한 결합

---

## 🎓 학습 완료!

15장 "상속"을 완료했습니다!

**다음 학습 내용:**
- **16장**: 메서드 오버라이딩 (Method Overriding)
  - @Override 어노테이션
  - 동적 바인딩
  - 오버로딩 vs 오버라이딩

**복습 체크리스트:**
- [ ] 상속의 개념과 extends 키워드 이해
- [ ] super 키워드의 역할
- [ ] 생성자 체이닝
- [ ] 접근 제어자 (protected)
- [ ] IS-A vs HAS-A 관계
- [ ] Object 클래스
- [ ] 상속의 장단점

---

**작성일**: 2025-01-10
**챕터**: 15. 상속 (Inheritance) - Part 3
**난이도**: ⭐⭐⭐ (중급)
