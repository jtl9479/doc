# 16-3. 메서드 오버라이딩 (Method Overriding) - Part 3

## 📋 목차
1. [실전 프로젝트: RPG 전투 시스템](#실전-프로젝트)
2. [FAQ - 자주 묻는 질문](#faq)
3. [면접 질문](#면접-질문)

---

## ⚔️ 실전 프로젝트: RPG 전투 시스템 {#실전-프로젝트}

### 프로젝트 개요
메서드 오버라이딩을 활용하여 RPG 게임의 전투 시스템을 구현합니다. 각 직업(전사, 마법사, 궁수, 힐러)마다 공격 방식, 스킬 사용, 피해 계산이 다릅니다.

### 요구사항
1. 모든 캐릭터는 공통 전투 메서드를 가짐
2. 각 직업마다 고유한 공격 방식과 스킬
3. 피해 계산 공식이 직업별로 다름
4. 레벨업 시 능력치 증가 방식이 다름
5. 방어 메커니즘이 직업별로 다름

---

### 1단계: 기본 캐릭터 클래스

```java
/**
 * 모든 전투 캐릭터의 부모 클래스
 */
public abstract class BattleCharacter {
    // 기본 속성
    protected String name;
    protected int level;
    protected int maxHp;
    protected int currentHp;
    protected int maxMp;
    protected int currentMp;
    protected int attack;
    protected int defense;
    protected int speed;
    protected boolean isAlive;

    public BattleCharacter(String name, int level) {
        this.name = name;
        this.level = level;
        this.isAlive = true;
        initializeStats();
    }

    // 초기 능력치 설정
    protected abstract void initializeStats();

    // ✅ 기본 공격 - 각 직업마다 오버라이딩
    public int basicAttack(BattleCharacter target) {
        if (!isAlive) {
            System.out.println(name + "은(는) 전투 불능 상태입니다.");
            return 0;
        }

        System.out.println("\n" + name + "의 기본 공격!");
        int damage = calculateDamage(target);
        target.takeDamage(damage);
        return damage;
    }

    // ✅ 피해 계산 - 각 직업마다 다른 공식
    protected int calculateDamage(BattleCharacter target) {
        int baseDamage = attack - target.defense / 2;
        int randomFactor = (int)(Math.random() * 10) - 5;
        return Math.max(baseDamage + randomFactor, 1);
    }

    // ✅ 피해 받기 - 각 직업마다 다른 방어 메커니즘
    public void takeDamage(int damage) {
        currentHp = Math.max(0, currentHp - damage);
        System.out.println(name + "이(가) " + damage + "의 피해를 입었습니다!");
        System.out.println("❤️  " + name + " HP: " + currentHp + "/" + maxHp);

        if (currentHp == 0) {
            isAlive = false;
            System.out.println("💀 " + name + "이(가) 쓰러졌습니다!");
        }
    }

    // ✅ 스킬 사용 - 각 직업마다 고유 스킬
    public abstract int useSkill(BattleCharacter target);

    // ✅ 방어 자세 - 각 직업마다 다른 방어 방식
    public void defend() {
        System.out.println(name + "이(가) 방어 자세를 취했습니다!");
    }

    // ✅ 레벨업 - 각 직업마다 다른 성장률
    public void levelUp() {
        level++;
        System.out.println("\n🎉 " + name + " 레벨업! Lv." + level);
    }

    // 상태 표시
    public void showStatus() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("👤 " + name + " (Lv." + level + ")");
        System.out.println("❤️  HP: " + currentHp + "/" + maxHp);
        System.out.println("💙 MP: " + currentMp + "/" + maxMp);
        System.out.println("⚔️  공격력: " + attack);
        System.out.println("🛡️  방어력: " + defense);
        System.out.println("💨 속도: " + speed);
        showHpBar();
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    private void showHpBar() {
        int barLength = 20;
        int filledLength = (int)((double)currentHp / maxHp * barLength);
        System.out.print("HP [");
        for (int i = 0; i < barLength; i++) {
            if (i < filledLength) {
                System.out.print("█");
            } else {
                System.out.print("░");
            }
        }
        System.out.println("]");
    }

    public boolean isAlive() { return isAlive; }
    public String getName() { return name; }
    public int getSpeed() { return speed; }
}
```

---

### 2단계: 전사 (Warrior)

```java
/**
 * 전사 - 높은 체력과 방어력, 강력한 물리 공격
 */
public class Warrior extends BattleCharacter {
    private int rage;  // 분노 게이지
    private boolean isDefending;
    private int originalDefense;

    public Warrior(String name, int level) {
        super(name, level);
        this.rage = 0;
        this.isDefending = false;
    }

    @Override
    protected void initializeStats() {
        maxHp = 150 + (level - 1) * 30;
        currentHp = maxHp;
        maxMp = 50 + (level - 1) * 5;
        currentMp = maxMp;
        attack = 25 + (level - 1) * 5;
        defense = 20 + (level - 1) * 3;
        speed = 5 + (level - 1);
        originalDefense = defense;
    }

    @Override
    public int basicAttack(BattleCharacter target) {
        System.out.println("\n⚔️ " + name + "의 강력한 베기!");

        // 분노 게이지 증가
        rage = Math.min(100, rage + 15);

        int damage = calculateDamage(target);
        target.takeDamage(damage);

        System.out.println("😡 분노: " + rage + "/100");

        return damage;
    }

    @Override
    protected int calculateDamage(BattleCharacter target) {
        // 전사는 분노 게이지에 따라 추가 데미지
        int baseDamage = super.calculateDamage(target);
        int ragebonus = rage / 10;
        return baseDamage + rageBonus;
    }

    @Override
    public int useSkill(BattleCharacter target) {
        if (currentMp < 20) {
            System.out.println("❌ MP가 부족합니다!");
            return 0;
        }

        currentMp -= 20;

        if (rage >= 100) {
            // 분노 폭발
            System.out.println("\n💥💥💥 " + name + "의 [분노 폭발]!");
            System.out.println("😡 분노가 폭발합니다!");

            int damage = (attack * 3) + rage;
            rage = 0;

            target.takeDamage(damage);
            System.out.println("💥 엄청난 피해: " + damage);

            return damage;
        } else {
            // 회전 베기
            System.out.println("\n🌀 " + name + "의 [회전 베기]!");
            int damage = (int)(attack * 1.8);
            target.takeDamage(damage);
            rage = Math.min(100, rage + 20);

            return damage;
        }
    }

    @Override
    public void defend() {
        super.defend();
        isDefending = true;
        defense += 15;
        System.out.println("🛡️ 방어력 증가: " + originalDefense + " → " + defense);
    }

    @Override
    public void takeDamage(int damage) {
        if (isDefending) {
            damage = (int)(damage * 0.5);
            System.out.println("🛡️ 방어 자세! 피해 50% 감소");
            isDefending = false;
            defense = originalDefense;
        }

        super.takeDamage(damage);

        // 피해 받을 때 분노 증가
        if (isAlive) {
            rage = Math.min(100, rage + 10);
            System.out.println("😡 분노 증가: " + rage + "/100");
        }
    }

    @Override
    public void levelUp() {
        super.levelUp();
        maxHp += 30;
        currentHp = maxHp;
        maxMp += 5;
        currentMp = maxMp;
        attack += 5;
        defense += 3;
        speed += 1;
        originalDefense = defense;

        System.out.println("💪 전사 성장!");
        System.out.println("  HP +30, 공격력 +5, 방어력 +3");
    }
}
```

---

### 3단계: 마법사 (Mage)

```java
/**
 * 마법사 - 강력한 마법 공격, 낮은 방어력
 */
public class Mage extends BattleCharacter {
    private int intelligence;
    private int manaShield;  // 마나 실드
    private boolean hasShield;

    public Mage(String name, int level) {
        super(name, level);
        this.manaShield = 0;
        this.hasShield = false;
    }

    @Override
    protected void initializeStats() {
        maxHp = 80 + (level - 1) * 15;
        currentHp = maxHp;
        maxMp = 120 + (level - 1) * 15;
        currentMp = maxMp;
        attack = 15 + (level - 1) * 3;
        defense = 8 + (level - 1) * 2;
        speed = 8 + (level - 1);
        intelligence = 30 + (level - 1) * 5;
    }

    @Override
    public int basicAttack(BattleCharacter target) {
        if (currentMp < 10) {
            System.out.println("❌ MP가 부족합니다! 지팡이로 공격...");
            return super.basicAttack(target);
        }

        currentMp -= 10;
        System.out.println("\n✨ " + name + "의 [마법 화살]!");

        int damage = intelligence + (int)(Math.random() * 15);
        target.takeDamage(damage);

        return damage;
    }

    @Override
    protected int calculateDamage(BattleCharacter target) {
        // 마법사는 지능 기반 데미지
        return intelligence + (int)(Math.random() * 20);
    }

    @Override
    public int useSkill(BattleCharacter target) {
        if (currentMp < 40) {
            System.out.println("❌ MP가 부족합니다!");
            return 0;
        }

        currentMp -= 40;

        // 파이어볼
        System.out.println("\n🔥🔥🔥 " + name + "의 [파이어볼]!");
        System.out.println("거대한 화염구가 적을 향해 날아갑니다!");

        int damage = intelligence * 2 + (int)(Math.random() * 30);
        target.takeDamage(damage);

        // 마나 회복 효과
        int manaRestore = 15;
        currentMp = Math.min(maxMp, currentMp + manaRestore);
        System.out.println("💙 마나 회복: +" + manaRestore + " MP");

        return damage;
    }

    @Override
    public void defend() {
        super.defend();

        if (currentMp >= 30) {
            currentMp -= 30;
            hasShield = true;
            manaShield = intelligence;
            System.out.println("🔮 마나 실드 생성! (" + manaShield + " 피해 흡수)");
        } else {
            System.out.println("💙 MP가 부족하여 마나 실드를 생성할 수 없습니다.");
        }
    }

    @Override
    public void takeDamage(int damage) {
        if (hasShield) {
            if (manaShield >= damage) {
                manaShield -= damage;
                System.out.println("🔮 마나 실드가 피해를 흡수했습니다!");
                System.out.println("   남은 실드: " + manaShield);
                return;
            } else {
                damage -= manaShield;
                System.out.println("🔮 마나 실드가 파괴되었습니다!");
                hasShield = false;
                manaShield = 0;
            }
        }

        super.takeDamage(damage);
    }

    @Override
    public void levelUp() {
        super.levelUp();
        maxHp += 15;
        currentHp = maxHp;
        maxMp += 15;
        currentMp = maxMp;
        attack += 3;
        defense += 2;
        speed += 1;
        intelligence += 5;

        System.out.println("🔮 마법사 성장!");
        System.out.println("  HP +15, MP +15, 지능 +5");
    }
}
```

---

### 4단계: 궁수 (Archer)

```java
/**
 * 궁수 - 빠른 속도와 치명타, 원거리 공격
 */
public class Archer extends BattleCharacter {
    private int criticalChance;  // 치명타 확률 (%)
    private int arrows;
    private boolean isAiming;  // 조준 중

    public Archer(String name, int level) {
        super(name, level);
        this.arrows = 50;
        this.isAiming = false;
    }

    @Override
    protected void initializeStats() {
        maxHp = 100 + (level - 1) * 20;
        currentHp = maxHp;
        maxMp = 70 + (level - 1) * 8;
        currentMp = maxMp;
        attack = 22 + (level - 1) * 4;
        defense = 12 + (level - 1) * 2;
        speed = 15 + (level - 1) * 2;
        criticalChance = 25 + (level - 1) * 2;
    }

    @Override
    public int basicAttack(BattleCharacter target) {
        if (arrows <= 0) {
            System.out.println("❌ 화살이 없습니다! 근접 공격...");
            return super.basicAttack(target) / 2;
        }

        arrows--;
        System.out.println("\n🏹 " + name + "의 화살 사격!");
        System.out.println("🏹 남은 화살: " + arrows);

        int damage = calculateDamage(target);

        // 조준 중이었다면 추가 데미지
        if (isAiming) {
            damage = (int)(damage * 1.5);
            System.out.println("🎯 정확한 조준! 데미지 1.5배");
            isAiming = false;
        }

        target.takeDamage(damage);

        return damage;
    }

    @Override
    protected int calculateDamage(BattleCharacter target) {
        int baseDamage = super.calculateDamage(target);

        // 치명타 판정
        if (Math.random() * 100 < criticalChance) {
            baseDamage *= 2;
            System.out.println("💥 치명타 발동! 2배 데미지!");
        }

        return baseDamage;
    }

    @Override
    public int useSkill(BattleCharacter target) {
        if (currentMp < 25 || arrows < 3) {
            System.out.println("❌ MP 또는 화살이 부족합니다!");
            return 0;
        }

        currentMp -= 25;
        arrows -= 3;

        // 다중 사격
        System.out.println("\n🏹🏹🏹 " + name + "의 [다중 사격]!");
        System.out.println("3발의 화살을 동시에 발사합니다!");

        int totalDamage = 0;

        for (int i = 1; i <= 3; i++) {
            int damage = attack + (int)(Math.random() * 10);

            // 각 화살마다 치명타 판정
            if (Math.random() * 100 < criticalChance) {
                damage *= 2;
                System.out.print("💥");
            } else {
                System.out.print("🏹");
            }

            totalDamage += damage;
        }

        System.out.println();
        target.takeDamage(totalDamage);
        System.out.println("총 피해: " + totalDamage);

        return totalDamage;
    }

    @Override
    public void defend() {
        super.defend();
        isAiming = true;
        System.out.println("🎯 다음 공격을 위해 조준합니다!");
        System.out.println("💡 다음 공격 데미지 1.5배");

        // 화살 3개 획득
        arrows += 3;
        System.out.println("🏹 화살 3개 획득! 총: " + arrows + "개");
    }

    @Override
    public void takeDamage(int damage) {
        // 궁수는 회피 확률이 있음
        if (Math.random() * 100 < speed) {
            System.out.println("💨 " + name + "이(가) 재빠르게 회피했습니다!");
            return;
        }

        super.takeDamage(damage);
    }

    @Override
    public void levelUp() {
        super.levelUp();
        maxHp += 20;
        currentHp = maxHp;
        maxMp += 8;
        currentMp = maxMp;
        attack += 4;
        defense += 2;
        speed += 2;
        criticalChance += 2;
        arrows += 20;

        System.out.println("🏹 궁수 성장!");
        System.out.println("  HP +20, 공격력 +4, 치명타 +2%, 화살 +20");
    }
}
```

---

### 5단계: 힐러 (Healer)

```java
/**
 * 힐러 - 회복 전문, 지원 능력
 */
public class Healer extends BattleCharacter {
    private int healingPower;
    private int holyPower;  // 신성력

    public Healer(String name, int level) {
        super(name, level);
        this.holyPower = 0;
    }

    @Override
    protected void initializeStats() {
        maxHp = 90 + (level - 1) * 18;
        currentHp = maxHp;
        maxMp = 150 + (level - 1) * 20;
        currentMp = maxMp;
        attack = 12 + (level - 1) * 2;
        defense = 10 + (level - 1) * 2;
        speed = 10 + (level - 1);
        healingPower = 40 + (level - 1) * 8;
    }

    @Override
    public int basicAttack(BattleCharacter target) {
        System.out.println("\n✨ " + name + "의 [신성한 빛]!");

        int damage = healingPower / 2 + (int)(Math.random() * 10);
        target.takeDamage(damage);

        // 신성력 축적
        holyPower = Math.min(100, holyPower + 10);
        System.out.println("✨ 신성력: " + holyPower + "/100");

        return damage;
    }

    @Override
    public int useSkill(BattleCharacter target) {
        if (currentMp < 30) {
            System.out.println("❌ MP가 부족합니다!");
            return 0;
        }

        // 대상이 아군인지 적인지에 따라 다른 스킬
        if (target == this || target.currentHp < target.maxHp) {
            // 아군으로 간주 - 힐
            return healAlly(target);
        } else {
            // 적으로 간주 - 공격
            return holyAttack(target);
        }
    }

    private int healAlly(BattleCharacter target) {
        currentMp -= 30;

        System.out.println("\n💚💚💚 " + name + "의 [치유의 기도]!");

        int healAmount = healingPower + (int)(Math.random() * 20);

        int beforeHp = target.currentHp;
        target.currentHp = Math.min(target.maxHp, target.currentHp + healAmount);
        int actualHeal = target.currentHp - beforeHp;

        System.out.println("💚 " + target.name + " HP 회복: +" + actualHeal);
        System.out.println("❤️  " + target.name + " HP: " + target.currentHp + "/" + target.maxHp);

        // 신성력 증가
        holyPower = Math.min(100, holyPower + 15);

        return actualHeal;
    }

    private int holyAttack(BattleCharacter target) {
        currentMp -= 30;

        System.out.println("\n⚡⚡⚡ " + name + "의 [천벌]!");

        int damage = healingPower + (int)(Math.random() * 25);

        // 신성력이 높으면 추가 데미지
        if (holyPower >= 100) {
            damage *= 2;
            holyPower = 0;
            System.out.println("✨ 신성력 폭발! 2배 데미지!");
        }

        target.takeDamage(damage);

        return damage;
    }

    @Override
    public void defend() {
        super.defend();

        if (currentMp >= 20) {
            currentMp -= 20;

            // 자신을 치유
            int healAmount = healingPower / 2;
            currentHp = Math.min(maxHp, currentHp + healAmount);

            System.out.println("💚 자가 치유: +" + healAmount + " HP");
            System.out.println("❤️  현재 HP: " + currentHp + "/" + maxHp);
        }

        // MP 회복
        int mpRestore = 30;
        currentMp = Math.min(maxMp, currentMp + mpRestore);
        System.out.println("💙 명상으로 MP 회복: +" + mpRestore);
    }

    @Override
    public void takeDamage(int damage) {
        super.takeDamage(damage);

        // 피해 받을 때 MP 일부 회복
        if (isAlive) {
            int mpRestore = damage / 2;
            currentMp = Math.min(maxMp, currentMp + mpRestore);
            System.out.println("💙 고통을 힘으로! MP +" + mpRestore);
        }
    }

    @Override
    public void levelUp() {
        super.levelUp();
        maxHp += 18;
        currentHp = maxHp;
        maxMp += 20;
        currentMp = maxMp;
        attack += 2;
        defense += 2;
        speed += 1;
        healingPower += 8;

        System.out.println("💚 힐러 성장!");
        System.out.println("  HP +18, MP +20, 치유력 +8");
    }

    // 파티원 힐 (여러 대상)
    public void healParty(BattleCharacter[] party) {
        if (currentMp < 50) {
            System.out.println("❌ MP가 부족합니다!");
            return;
        }

        currentMp -= 50;

        System.out.println("\n💚💚💚 " + name + "의 [광역 치유]!");

        for (BattleCharacter member : party) {
            if (member.isAlive) {
                int healAmount = healingPower / 2;
                int beforeHp = member.currentHp;
                member.currentHp = Math.min(member.maxHp, member.currentHp + healAmount);
                int actualHeal = member.currentHp - beforeHp;

                System.out.println("💚 " + member.name + " +" + actualHeal + " HP");
            }
        }
    }
}
```

---

### 6단계: 전투 시스템 및 테스트

```java
/**
 * RPG 전투 시스템
 */
public class BattleSystem {
    public static void main(String[] args) {
        System.out.println("⚔️ ═══════════════════════════════");
        System.out.println("   RPG 전투 시스템 v1.0");
        System.out.println("═══════════════════════════════\n");

        // 파티 구성
        Warrior warrior = new Warrior("아서", 5);
        Mage mage = new Mage("멀린", 5);
        Archer archer = new Archer("로빈", 5);
        Healer healer = new Healer("엘레나", 5);

        System.out.println("🛡️ 파티 구성 완료!");
        warrior.showStatus();
        mage.showStatus();
        archer.showStatus();
        healer.showStatus();

        // 적 생성
        System.out.println("\n\n🐉 ═══════════════════════════════");
        System.out.println("   드래곤 등장!");
        System.out.println("═══════════════════════════════\n");

        Warrior dragon = new Warrior("드래곤", 7);
        dragon.maxHp = 500;
        dragon.currentHp = 500;
        dragon.attack = 35;
        dragon.defense = 25;
        dragon.showStatus();

        // 전투 시뮬레이션
        BattleCharacter[] party = {warrior, archer, mage, healer};

        int round = 1;
        while (dragon.isAlive() && isPartyAlive(party)) {
            System.out.println("\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━");
            System.out.println("    라운드 " + round);
            System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━\n");

            // 속도 순으로 행동 (간단화)
            // 파티 공격 턴
            System.out.println("👥 === 파티 턴 ===");

            // 전사 공격
            if (warrior.isAlive()) {
                if (round % 3 == 0) {
                    warrior.useSkill(dragon);
                } else {
                    warrior.basicAttack(dragon);
                }
            }

            if (!dragon.isAlive()) break;

            // 궁수 공격
            if (archer.isAlive()) {
                if (round % 4 == 0) {
                    archer.useSkill(dragon);
                } else {
                    archer.basicAttack(dragon);
                }
            }

            if (!dragon.isAlive()) break;

            // 마법사 공격
            if (mage.isAlive()) {
                if (round % 2 == 0) {
                    mage.useSkill(dragon);
                } else {
                    mage.basicAttack(dragon);
                }
            }

            if (!dragon.isAlive()) break;

            // 힐러 행동
            if (healer.isAlive()) {
                // 체력이 50% 이하인 파티원 힐
                BattleCharacter needHeal = findMostInjured(party);
                if (needHeal != null && needHeal.currentHp < needHeal.maxHp * 0.5) {
                    healer.useSkill(needHeal);
                } else {
                    healer.basicAttack(dragon);
                }
            }

            if (!dragon.isAlive()) break;

            // 드래곤 턴
            System.out.println("\n🐉 === 드래곤 턴 ===");

            if (round % 5 == 0) {
                // 브레스 공격 (전체 공격)
                System.out.println("\n🔥🔥🔥 드래곤의 화염 브레스!");
                for (BattleCharacter member : party) {
                    if (member.isAlive()) {
                        int damage = 30 + (int)(Math.random() * 20);
                        member.takeDamage(damage);
                    }
                }
            } else {
                // 단일 대상 공격
                BattleCharacter target = selectTarget(party);
                if (target != null) {
                    dragon.basicAttack(target);
                }
            }

            // 라운드 종료 후 상태 표시
            System.out.println("\n📊 === 라운드 " + round + " 종료 ===");
            System.out.println("🐉 드래곤 HP: " + dragon.currentHp + "/" + dragon.maxHp);
            System.out.println("\n파티 상태:");
            for (BattleCharacter member : party) {
                if (member.isAlive()) {
                    System.out.println("  " + member.name + ": " +
                                     member.currentHp + "/" + member.maxHp + " HP");
                } else {
                    System.out.println("  " + member.name + ": 💀 전투불능");
                }
            }

            round++;

            if (round > 10) break;  // 최대 10라운드
        }

        // 전투 결과
        System.out.println("\n\n🏆 ═══════════════════════════════");
        System.out.println("      전투 결과");
        System.out.println("═══════════════════════════════\n");

        if (!dragon.isAlive()) {
            System.out.println("✨ 승리! 드래곤을 물리쳤습니다!");
            System.out.println("🎉 경험치 획득!");

            for (BattleCharacter member : party) {
                if (member.isAlive()) {
                    member.levelUp();
                }
            }
        } else if (!isPartyAlive(party)) {
            System.out.println("💀 패배... 파티가 전멸했습니다.");
        } else {
            System.out.println("⏰ 시간 초과! 무승부");
        }

        System.out.println("\n\n💡 메서드 오버라이딩 활용:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ basicAttack() - 각 직업마다 다른 공격 방식");
        System.out.println("✅ useSkill() - 직업별 고유 스킬");
        System.out.println("✅ takeDamage() - 직업별 방어 메커니즘");
        System.out.println("✅ defend() - 직업별 방어 행동");
        System.out.println("✅ levelUp() - 직업별 성장 패턴");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    private static boolean isPartyAlive(BattleCharacter[] party) {
        for (BattleCharacter member : party) {
            if (member.isAlive()) {
                return true;
            }
        }
        return false;
    }

    private static BattleCharacter findMostInjured(BattleCharacter[] party) {
        BattleCharacter mostInjured = null;
        double lowestHpPercent = 1.0;

        for (BattleCharacter member : party) {
            if (member.isAlive()) {
                double hpPercent = (double)member.currentHp / member.maxHp;
                if (hpPercent < lowestHpPercent) {
                    lowestHpPercent = hpPercent;
                    mostInjured = member;
                }
            }
        }

        return mostInjured;
    }

    private static BattleCharacter selectTarget(BattleCharacter[] party) {
        // 살아있는 파티원 중 랜덤 선택
        java.util.ArrayList<BattleCharacter> alive = new java.util.ArrayList<>();
        for (BattleCharacter member : party) {
            if (member.isAlive()) {
                alive.add(member);
            }
        }

        if (alive.isEmpty()) return null;

        int index = (int)(Math.random() * alive.size());
        return alive.get(index);
    }
}
```

### 프로젝트 핵심 포인트
1. **다중 메서드 오버라이딩**: 5개 이상의 메서드를 각 클래스에서 오버라이딩
2. **super 활용**: 부모의 로직을 재사용하면서 추가 기능 구현
3. **다형성**: BattleCharacter 배열로 모든 직업을 통합 관리
4. **실전 활용**: 실제 게임에서 사용할 수 있는 전투 시스템

---

## ❓ FAQ - 자주 묻는 질문 {#faq}

### Q1. 메서드 오버라이딩과 메서드 오버로딩의 차이는?

**A:** 완전히 다른 개념입니다.

| 구분 | 오버라이딩 (Overriding) | 오버로딩 (Overloading) |
|------|------------------------|----------------------|
| 정의 | 부모 메서드를 자식이 재정의 | 같은 이름, 다른 매개변수 |
| 관계 | 상속 관계 필요 | 같은 클래스 내 |
| 메서드 시그니처 | 동일해야 함 | 달라야 함 |
| 바인딩 | 동적 (런타임) | 정적 (컴파일타임) |
| 어노테이션 | @Override | 없음 |
| 목적 | 다형성 구현 | 편의성 제공 |

```java
// 오버라이딩
class Parent {
    public void display() {
        System.out.println("부모");
    }
}

class Child extends Parent {
    @Override
    public void display() {  // 같은 시그니처
        System.out.println("자식");
    }
}

// 오버로딩
class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {  // 다른 매개변수
        return a + b;
    }

    public int add(int a, int b, int c) {  // 다른 개수
        return a + b + c;
    }
}
```

---

### Q2. @Override 어노테이션은 필수인가요?

**A:** 필수는 아니지만 **반드시 사용해야 합니다**.

**@Override를 사용하지 않을 때의 문제:**

```java
class Parent {
    public void display() {
        System.out.println("부모");
    }
}

class Child extends Parent {
    // ❌ @Override 없이 오타
    public void Display() {  // 'D'가 대문자!
        System.out.println("자식");
    }
}

// 문제:
Parent p = new Child();
p.display();  // "부모" 출력 (의도와 다름!)
// Display()는 새로운 메서드가 되어버림
```

**@Override 사용 시:**

```java
class Child extends Parent {
    @Override
    public void Display() {  // 컴파일 에러 발생!
        System.out.println("자식");
    }
}

// 컴파일 에러:
// Method does not override method from its superclass
```

**@Override의 장점:**
1. **컴파일 타임 검증**: 오타나 실수를 즉시 발견
2. **가독성 향상**: 이 메서드가 오버라이딩임을 명확히 표시
3. **유지보수성**: 부모 메서드 변경 시 자동으로 에러 감지
4. **IDE 지원**: 자동완성, 리팩토링 등 IDE 기능 활용

---

### Q3. private 메서드를 오버라이딩할 수 있나요?

**A:** 아니요, **private 메서드는 오버라이딩할 수 없습니다**.

```java
class Parent {
    private void privateMethod() {
        System.out.println("부모의 private 메서드");
    }

    public void callPrivate() {
        privateMethod();
    }
}

class Child extends Parent {
    // ❌ 이것은 오버라이딩이 아님! (새로운 메서드)
    private void privateMethod() {
        System.out.println("자식의 private 메서드");
    }

    public void test() {
        privateMethod();  // 자식의 메서드 호출
        callPrivate();    // 부모의 private 메서드 호출됨
    }
}

public class Test {
    public static void main(String[] args) {
        Child child = new Child();
        child.test();
        // 출력:
        // 자식의 private 메서드
        // 부모의 private 메서드  ← 부모의 것!
    }
}
```

**오버라이딩 가능 여부:**
- ✅ `public` → 오버라이딩 가능
- ✅ `protected` → 오버라이딩 가능
- ✅ `default` (package-private) → 같은 패키지면 가능
- ❌ `private` → 오버라이딩 불가 (상속조차 안 됨)

---

### Q4. final 메서드는 어떻게 되나요?

**A:** **final 메서드는 오버라이딩할 수 없습니다**.

```java
class Parent {
    // final 메서드 - 변경 불가
    public final void immutableMethod() {
        System.out.println("이 메서드는 변경할 수 없습니다");
    }

    public void changeableMethod() {
        System.out.println("이 메서드는 변경 가능합니다");
    }
}

class Child extends Parent {
    // ❌ 컴파일 에러!
    @Override
    public void immutableMethod() {
        System.out.println("변경 시도");
    }

    // ✅ 정상 오버라이딩
    @Override
    public void changeableMethod() {
        System.out.println("변경됨");
    }
}

// 컴파일 에러:
// Cannot override the final method from Parent
```

**final을 사용하는 이유:**
1. **보안**: 중요한 메서드가 변경되는 것을 방지
2. **최적화**: 컴파일러가 인라이닝 등 최적화 가능
3. **설계 의도**: 이 메서드는 반드시 이렇게 동작해야 함을 명시

```java
class BankAccount {
    // 보안상 중요한 메서드는 final로
    public final void validateTransaction() {
        // 이 검증 로직은 절대 변경되면 안 됨
        System.out.println("거래 유효성 검증 중...");
    }
}
```

---

### Q5. 생성자는 오버라이딩되나요?

**A:** 아니요, **생성자는 오버라이딩되지 않습니다**.

생성자는 상속되지 않기 때문에 오버라이딩도 불가능합니다.

```java
class Parent {
    public Parent() {
        System.out.println("부모 생성자");
    }

    public Parent(String name) {
        System.out.println("부모 생성자: " + name);
    }
}

class Child extends Parent {
    // ❌ @Override 사용 불가 (컴파일 에러)
    public Child() {
        super();  // 부모 생성자 명시적 호출
        System.out.println("자식 생성자");
    }

    // 이것은 오버라이딩이 아니라 새로운 생성자
    public Child(String name) {
        super(name);
        System.out.println("자식 생성자: " + name);
    }
}
```

**생성자 호출 순서:**
1. 자식 생성자 호출
2. 부모 생성자가 먼저 실행 (super())
3. 자식 생성자의 나머지 코드 실행

```java
Child child = new Child("테스트");

// 출력 순서:
// 부모 생성자: 테스트  ← 부모가 먼저
// 자식 생성자: 테스트  ← 자식이 나중
```

---

### Q6. 오버라이딩 시 리턴 타입을 변경할 수 있나요?

**A:** **공변 반환 타입(Covariant Return Type)**은 가능합니다.

```java
class Animal {
    public Animal reproduce() {
        return new Animal();
    }
}

class Dog extends Animal {
    // ✅ Dog는 Animal의 하위 타입이므로 가능
    @Override
    public Dog reproduce() {
        return new Dog();
    }
}

class Cat extends Animal {
    // ✅ 이것도 가능
    @Override
    public Cat reproduce() {
        return new Cat();
    }
}
```

**규칙:**
- ✅ 같은 타입: `Animal → Animal`
- ✅ 하위 타입: `Animal → Dog` (공변 반환)
- ❌ 상위 타입: `Dog → Animal` (불가능)
- ❌ 완전히 다른 타입: `Animal → String` (불가능)

**실전 예제:**

```java
class Shape {
    public Shape copy() {
        return new Shape();
    }
}

class Circle extends Shape {
    private int radius;

    public Circle(int radius) {
        this.radius = radius;
    }

    @Override
    public Circle copy() {  // ✅ Circle 반환
        return new Circle(this.radius);
    }
}

// 사용
Circle c1 = new Circle(10);
Circle c2 = c1.copy();  // ✅ Circle 타입으로 직접 받을 수 있음

Shape s = new Circle(20);
Shape s2 = s.copy();  // ✅ 다형성도 정상 작동
```

---

### Q7. 오버라이딩된 메서드에서 부모 메서드를 호출하려면?

**A:** **super 키워드**를 사용합니다.

```java
class Parent {
    public void display() {
        System.out.println("1. 부모의 로직");
    }
}

class Child extends Parent {
    @Override
    public void display() {
        System.out.println("0. 자식의 전처리");

        super.display();  // ✅ 부모 메서드 호출

        System.out.println("2. 자식의 추가 로직");
    }
}

public class Test {
    public static void main(String[] args) {
        Child child = new Child();
        child.display();

        // 출력:
        // 0. 자식의 전처리
        // 1. 부모의 로직      ← super.display()
        // 2. 자식의 추가 로직
    }
}
```

**실전 활용 패턴:**

```java
class BankAccount {
    protected long balance;

    public void withdraw(long amount) {
        // 중요한 검증 로직
        if (amount > balance) {
            System.out.println("잔액 부족!");
            return;
        }

        balance -= amount;
        System.out.println("출금 완료: " + amount);
    }
}

class SavingsAccount extends BankAccount {
    private long withdrawFee = 1000;

    @Override
    public void withdraw(long amount) {
        // 수수료 추가
        long totalAmount = amount + withdrawFee;

        System.out.println("수수료: " + withdrawFee);

        // ✅ 부모의 검증 로직 재사용
        super.withdraw(totalAmount);

        // 추가 로직
        if (balance > 0) {
            System.out.println("남은 잔액: " + balance);
        }
    }
}
```

**super 사용 시나리오:**
1. **검증 로직 재사용**: 부모의 검증을 그대로 사용
2. **기본 동작 + 추가 동작**: 부모 기능에 추가 기능만 덧붙임
3. **템플릿 메서드 패턴**: 부모의 골격 유지하며 세부만 변경

---

## 💼 면접 질문 {#면접-질문}

### 주니어 레벨 (Junior Level)

#### Q1. 메서드 오버라이딩이란 무엇이며, 왜 사용하나요?

**모범 답안:**
메서드 오버라이딩은 부모 클래스에 정의된 메서드를 자식 클래스에서 재정의하는 것입니다.

**사용 이유:**
1. **다형성 구현**: 같은 인터페이스로 다른 동작 구현
2. **특화된 기능**: 자식 클래스에 맞게 동작 변경
3. **확장성**: 부모의 기본 동작을 유지하면서 확장

```java
class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

// 다형성 활용
Animal animal = new Dog();
animal.makeSound();  // "멍멍!" 출력
```

**핵심 키워드:** 재정의, 다형성, @Override, 동적 바인딩

---

#### Q2. @Override 어노테이션의 역할은 무엇인가요?

**모범 답안:**
@Override는 메서드가 부모 클래스의 메서드를 오버라이딩한다는 것을 컴파일러에게 알려주는 어노테이션입니다.

**주요 기능:**
1. **컴파일 타임 검증**: 메서드 시그니처가 정확한지 확인
2. **오타 방지**: 메서드 이름이나 매개변수 오타 감지
3. **가독성**: 코드를 읽는 사람에게 의도 명확히 전달
4. **유지보수**: 부모 메서드 변경 시 자동으로 에러 발견

```java
class Parent {
    public void display() { }
}

class Child extends Parent {
    @Override
    public void display() { }  // ✅ 검증됨

    @Override
    public void Display() { }  // ❌ 컴파일 에러
}
```

**핵심 키워드:** 컴파일 타임 검증, 오타 방지, 가독성

---

#### Q3. 오버라이딩할 때 접근 제어자를 어떻게 변경할 수 있나요?

**모범 답안:**
오버라이딩 시 접근 제어자는 **같거나 더 넓게**만 변경할 수 있습니다.

**가능한 변경:**
- `protected` → `protected` ✅
- `protected` → `public` ✅
- `public` → `public` ✅

**불가능한 변경:**
- `public` → `protected` ❌
- `public` → `private` ❌
- `protected` → `private` ❌

```java
class Parent {
    protected void method() { }
}

class Child extends Parent {
    @Override
    public void method() { }  // ✅ 확대 가능
}

class BadChild extends Parent {
    @Override
    private void method() { }  // ❌ 컴파일 에러
}
```

**이유:** 리스코프 치환 원칙 - 자식 객체가 부모를 대체할 수 있어야 함

**핵심 키워드:** 접근 제어자 확대, 리스코프 치환 원칙

---

#### Q4. super 키워드는 언제 사용하나요?

**모범 답안:**
`super`는 부모 클래스의 멤버에 접근할 때 사용합니다.

**주요 사용 용도:**
1. **부모 메서드 호출**: `super.methodName()`
2. **부모 생성자 호출**: `super()`
3. **부모 필드 접근**: `super.fieldName`

```java
class BankAccount {
    protected long balance;

    public void withdraw(long amount) {
        if (amount > balance) {
            System.out.println("잔액 부족!");
            return;
        }
        balance -= amount;
    }
}

class SavingsAccount extends BankAccount {
    private long fee = 1000;

    @Override
    public void withdraw(long amount) {
        System.out.println("수수료: " + fee);
        super.withdraw(amount + fee);  // 부모 메서드 호출
    }
}
```

**핵심 키워드:** super, 부모 메서드 호출, 코드 재사용

---

#### Q5. 오버라이딩과 오버로딩의 차이를 설명하세요.

**모범 답안:**

| 구분 | 오버라이딩 | 오버로딩 |
|------|-----------|---------|
| 정의 | 부모 메서드 재정의 | 같은 이름, 다른 매개변수 |
| 관계 | 상속 관계 | 같은 클래스 |
| 시그니처 | 동일 | 다름 |
| 바인딩 | 동적 (런타임) | 정적 (컴파일타임) |

```java
// 오버라이딩
class Parent {
    public void print() { }
}
class Child extends Parent {
    @Override
    public void print() { }  // 재정의
}

// 오버로딩
class Calculator {
    public int add(int a, int b) { }
    public double add(double a, double b) { }  // 다른 매개변수
}
```

**핵심 키워드:** 재정의 vs 다중 정의, 동적 바인딩 vs 정적 바인딩

---

#### Q6. private 메서드를 오버라이딩할 수 있나요?

**모범 답안:**
아니요, **private 메서드는 오버라이딩할 수 없습니다**.

**이유:**
- private 메서드는 자식 클래스에 상속되지 않음
- 자식 클래스에서 보이지도 않음
- 같은 이름의 메서드를 만들어도 새로운 메서드일 뿐

```java
class Parent {
    private void secret() {
        System.out.println("부모의 비밀");
    }

    public void callSecret() {
        secret();  // 부모의 secret() 호출
    }
}

class Child extends Parent {
    // 이것은 오버라이딩이 아님!
    private void secret() {
        System.out.println("자식의 비밀");
    }
}

Child c = new Child();
c.callSecret();  // "부모의 비밀" 출력
```

**오버라이딩 가능:**
- ✅ `public`
- ✅ `protected`
- ✅ `default` (같은 패키지)
- ❌ `private`

**핵심 키워드:** private, 상속 불가, 가시성

---

#### Q7. final 메서드는 오버라이딩할 수 있나요?

**모범 답안:**
아니요, **final 메서드는 오버라이딩할 수 없습니다**.

**final의 의미:**
- 이 메서드는 더 이상 변경할 수 없음
- 자식 클래스에서 재정의 불가
- 보안이나 설계상 중요한 메서드에 사용

```java
class Parent {
    public final void immutable() {
        System.out.println("변경 불가");
    }

    public void changeable() {
        System.out.println("변경 가능");
    }
}

class Child extends Parent {
    // ❌ 컴파일 에러
    @Override
    public void immutable() { }

    // ✅ 가능
    @Override
    public void changeable() { }
}
```

**final을 사용하는 경우:**
1. **보안**: 중요한 로직 변경 방지
2. **최적화**: 컴파일러 최적화 가능
3. **설계 의도**: 이 동작은 반드시 이래야 함

**핵심 키워드:** final, 변경 불가, 보안

---

### 중급 레벨 (Intermediate Level)

#### Q8. 동적 바인딩과 정적 바인딩의 차이를 설명하세요.

**모범 답안:**
- **정적 바인딩**: 컴파일 타임에 메서드가 결정됨
- **동적 바인딩**: 런타임에 실제 객체 타입에 따라 메서드가 결정됨

**정적 바인딩 (Static Binding):**
- 오버로딩된 메서드
- static 메서드
- private 메서드
- final 메서드

**동적 바인딩 (Dynamic Binding):**
- 오버라이딩된 인스턴스 메서드

```java
class Parent {
    public void instanceMethod() {
        System.out.println("Parent instance");
    }

    public static void staticMethod() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    @Override
    public void instanceMethod() {
        System.out.println("Child instance");
    }

    public static void staticMethod() {
        System.out.println("Child static");
    }
}

// 테스트
Parent p = new Child();

p.instanceMethod();  // "Child instance" ← 동적 바인딩
p.staticMethod();    // "Parent static" ← 정적 바인딩
```

**핵심 차이:**

| 구분 | 정적 바인딩 | 동적 바인딩 |
|------|-----------|-----------|
| 결정 시점 | 컴파일타임 | 런타임 |
| 기준 | 참조 변수 타입 | 실제 객체 타입 |
| 성능 | 빠름 | 느림 (조회 필요) |
| 다형성 | 지원 안 함 | 지원함 |

**핵심 키워드:** 정적 바인딩, 동적 바인딩, 런타임, 컴파일타임

---

#### Q9. 공변 반환 타입(Covariant Return Type)이란 무엇인가요?

**모범 답안:**
오버라이딩 시 부모 메서드의 반환 타입을 **하위 타입**으로 변경할 수 있는 기능입니다 (Java 5부터 지원).

**기본 규칙:**
```java
class Animal {
    public Animal reproduce() {
        return new Animal();
    }
}

class Dog extends Animal {
    // ✅ Dog는 Animal의 하위 타입
    @Override
    public Dog reproduce() {
        return new Dog();
    }
}
```

**장점:**
```java
// 공변 반환 타입이 없었다면:
Animal animal = new Dog();
Animal offspring = animal.reproduce();  // Animal 타입
Dog dog = (Dog) offspring;  // ❌ 명시적 캐스팅 필요

// 공변 반환 타입 사용:
Dog myDog = new Dog();
Dog puppy = myDog.reproduce();  // ✅ Dog 타입으로 바로 받음
```

**실전 예제:**
```java
class Shape {
    public Shape clone() {
        return new Shape();
    }
}

class Circle extends Shape {
    private int radius;

    @Override
    public Circle clone() {  // ✅ Circle 반환
        Circle copy = new Circle();
        copy.radius = this.radius;
        return copy;
    }
}

// 사용
Circle c1 = new Circle();
Circle c2 = c1.clone();  // ✅ 캐스팅 불필요
```

**제약사항:**
- ✅ 같은 타입: `Animal → Animal`
- ✅ 하위 타입: `Animal → Dog`
- ❌ 상위 타입: `Dog → Animal`
- ❌ 무관한 타입: `Animal → String`

**핵심 키워드:** 공변 반환, 하위 타입, Java 5, 타입 안전성

---

#### Q10. 오버라이딩 시 예외 처리 규칙을 설명하세요.

**모범 답안:**
오버라이딩된 메서드는 부모 메서드보다 **더 많은 checked 예외를 던질 수 없습니다**.

**규칙:**
1. **Checked 예외**: 같거나 더 적게, 또는 하위 타입
2. **Unchecked 예외**: 제한 없음

```java
// ✅ 올바른 예제
class Parent {
    public void method() throws IOException {
    }
}

class Child1 extends Parent {
    @Override
    public void method() {  // ✅ 예외 안 던져도 됨
    }
}

class Child2 extends Parent {
    @Override
    public void method() throws IOException {  // ✅ 같은 예외
    }
}

class Child3 extends Parent {
    @Override
    public void method() throws FileNotFoundException {  // ✅ 하위 예외
    }
}

// ❌ 잘못된 예제
class BadChild extends Parent {
    @Override
    public void method() throws Exception {  // ❌ 컴파일 에러!
        // Exception은 IOException보다 상위 예외
    }
}
```

**이유:**
```java
try {
    Parent p = new BadChild();
    p.method();  // IOException만 처리하면 된다고 생각
} catch (IOException e) {
    // 하지만 실제로는 Exception이 던져질 수 있음!
}
```

**Unchecked 예외는 제한 없음:**
```java
class Parent {
    public void method() {
    }
}

class Child extends Parent {
    @Override
    public void method() throws RuntimeException {  // ✅ 가능
    }
}
```

**핵심 키워드:** Checked 예외, 예외 계층, 하위 예외, 리스코프 치환

---

#### Q11. 템플릿 메서드 패턴과 오버라이딩의 관계를 설명하세요.

**모범 답안:**
템플릿 메서드 패턴은 오버라이딩을 활용하여 알고리즘의 골격은 유지하면서 세부 단계만 자식 클래스에서 구현하는 디자인 패턴입니다.

**구조:**
```java
abstract class DataProcessor {
    // 템플릿 메서드 (final로 변경 방지)
    public final void process() {
        readData();
        processData();
        writeData();
    }

    // 하위 클래스에서 구현할 추상 메서드
    protected abstract void readData();
    protected abstract void processData();
    protected abstract void writeData();
}

class CSVProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("CSV 파일 읽기");
    }

    @Override
    protected void processData() {
        System.out.println("CSV 데이터 처리");
    }

    @Override
    protected void writeData() {
        System.out.println("CSV 파일 저장");
    }
}

class XMLProcessor extends DataProcessor {
    @Override
    protected void readData() {
        System.out.println("XML 파일 읽기");
    }

    @Override
    protected void processData() {
        System.out.println("XML 데이터 처리");
    }

    @Override
    protected void writeData() {
        System.out.println("XML 파일 저장");
    }
}
```

**실전 예제:**
```java
abstract class Game {
    // 템플릿 메서드
    public final void play() {
        initialize();
        startPlay();
        endPlay();
    }

    protected abstract void initialize();
    protected abstract void startPlay();
    protected abstract void endPlay();
}

class Chess extends Game {
    @Override
    protected void initialize() {
        System.out.println("체스 보드 설치");
    }

    @Override
    protected void startPlay() {
        System.out.println("체스 게임 시작");
    }

    @Override
    protected void endPlay() {
        System.out.println("체스 게임 종료");
    }
}
```

**장점:**
1. **코드 재사용**: 공통 로직을 한 곳에서 관리
2. **일관성**: 알고리즘 구조가 일정하게 유지
3. **확장성**: 새로운 구현 추가가 쉬움
4. **제어의 역전**: 부모가 흐름을 제어

**핵심 키워드:** 템플릿 메서드, 디자인 패턴, 알고리즘 골격, 제어의 역전

---

#### Q12. 다형성과 메서드 오버라이딩의 관계를 설명하고, 실무에서의 활용 예시를 제시하세요.

**모범 답안:**
메서드 오버라이딩은 **다형성을 구현하는 핵심 메커니즘**입니다. 부모 타입의 참조 변수로 다양한 자식 객체를 다루면서, 실제로는 각 객체의 오버라이딩된 메서드가 호출됩니다.

**기본 개념:**
```java
class Shape {
    public double calculateArea() {
        return 0;
    }
}

class Circle extends Shape {
    private double radius;

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width, height;

    @Override
    public double calculateArea() {
        return width * height;
    }
}

// 다형성 활용
Shape[] shapes = {
    new Circle(5),
    new Rectangle(4, 6),
    new Circle(3)
};

double totalArea = 0;
for (Shape shape : shapes) {
    totalArea += shape.calculateArea();  // 각 객체의 메서드 호출
}
```

**실무 예제 1: 결제 시스템**
```java
abstract class PaymentMethod {
    public abstract boolean processPayment(long amount);
}

class CreditCard extends PaymentMethod {
    @Override
    public boolean processPayment(long amount) {
        System.out.println("신용카드 결제: " + amount);
        // 신용카드 결제 로직
        return true;
    }
}

class KakaoPay extends PaymentMethod {
    @Override
    public boolean processPayment(long amount) {
        System.out.println("카카오페이 결제: " + amount);
        // 카카오페이 API 호출
        return true;
    }
}

// 결제 처리 시스템
class PaymentProcessor {
    public void checkout(PaymentMethod payment, long amount) {
        // 어떤 결제 수단이든 동일하게 처리
        if (payment.processPayment(amount)) {
            System.out.println("결제 성공!");
        }
    }
}

// 사용
PaymentProcessor processor = new PaymentProcessor();
processor.checkout(new CreditCard(), 50000);
processor.checkout(new KakaoPay(), 30000);
```

**실무 예제 2: 로깅 시스템**
```java
abstract class Logger {
    public void log(String message) {
        String formatted = formatMessage(message);
        write(formatted);
    }

    protected String formatMessage(String message) {
        return "[" + LocalDateTime.now() + "] " + message;
    }

    protected abstract void write(String message);
}

class FileLogger extends Logger {
    @Override
    protected void write(String message) {
        // 파일에 기록
    }
}

class DatabaseLogger extends Logger {
    @Override
    protected void write(String message) {
        // DB에 저장
    }
}

class CloudLogger extends Logger {
    @Override
    protected void write(String message) {
        // 클라우드에 전송
    }
}

// 로거 팩토리
class Application {
    private Logger logger;

    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    public void doSomething() {
        logger.log("작업 시작");
        // 비즈니스 로직
        logger.log("작업 완료");
    }
}
```

**다형성의 이점:**
1. **확장성**: 새로운 결제 수단 추가 시 기존 코드 변경 불필요
2. **유연성**: 런타임에 객체 타입 변경 가능
3. **유지보수성**: 각 구현이 독립적
4. **테스트 용이성**: Mock 객체로 쉽게 대체

**OCP(Open-Closed Principle) 준수:**
- Open for extension: 새로운 클래스 추가 가능
- Closed for modification: 기존 코드 변경 불필요

**핵심 키워드:** 다형성, 동적 바인딩, 확장성, OCP, 실무 활용

---

## 🎓 학습 완료!

16장 "메서드 오버라이딩"을 완료했습니다!

**다음 학습 내용:**
- **17장**: 다형성 (Polymorphism)
  - 다형성의 개념
  - 업캐스팅과 다운캐스팅
  - instanceof 연산자

**복습 체크리스트:**
- [ ] 메서드 오버라이딩의 개념
- [ ] @Override 어노테이션의 중요성
- [ ] 오버라이딩 규칙 (시그니처, 접근 제어자, 예외)
- [ ] super 키워드 활용
- [ ] 동적 바인딩
- [ ] 오버라이딩 vs 오버로딩
- [ ] 실전 프로젝트 구현

---

**작성일**: 2025-01-10
**챕터**: 16. 메서드 오버라이딩 (Method Overriding) - Part 3
**난이도**: ⭐⭐⭐ (중급)
