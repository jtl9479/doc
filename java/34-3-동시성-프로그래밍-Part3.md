# 34장 동시성 프로그래밍 - Part 3: 면접 질문

## 🎤 면접 질문 TOP 3

### Q1. synchronized vs Lock 차이는?

**답변**:
```
synchronized:
- 자바 키워드
- 자동 락 해제
- 간단한 사용
- 타임아웃 불가
- 공정성 제어 불가

Lock (ReentrantLock):
- 인터페이스
- 수동 락 해제 (unlock 필수)
- 유연한 제어
- tryLock(timeout) 가능
- 공정성 설정 가능

예시:
// synchronized
synchronized(obj) {
    // 자동 해제
}

// Lock
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 작업
} finally {
    lock.unlock();  // 반드시 해제
}
```

### Q2. ConcurrentHashMap의 동작 원리는?

**답변**:
```
세그먼트 기반 잠금:
- Map을 여러 세그먼트로 분할
- 각 세그먼트에 독립적인 락
- 다른 세그먼트 동시 접근 가능

vs Hashtable/Collections.synchronizedMap:
- 전체 Map에 하나의 락
- 동시성 낮음

장점:
- 높은 동시성
- 읽기는 락 없음
- putIfAbsent, computeIfAbsent 등 atomic 메서드

사용:
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();
map.computeIfAbsent(key, k -> createValue());
```

### Q3. CompletableFuture의 장점은?

**답변**:
```
Future의 한계:
- get()으로만 결과 확인 (블로킹)
- 여러 Future 조합 어려움
- 예외 처리 복잡

CompletableFuture 장점:
- 비블로킹 콜백
- 체이닝 가능
- 여러 작업 조합 쉬움
- 예외 처리 명확

예시:
// Future (구식)
Future<String> future = executor.submit(() -> "결과");
String result = future.get();  // 블로킹!

// CompletableFuture (신식)
CompletableFuture.supplyAsync(() -> "결과")
    .thenApply(s -> s.toUpperCase())
    .thenAccept(System.out::println)
    .exceptionally(ex -> {
        System.err.println("오류: " + ex);
        return null;
    });
```

---

## 🎓 Best Practices

```java
// ✅ ExecutorService 사용
ExecutorService executor = Executors.newFixedThreadPool(10);
try {
    executor.submit(() -> {});
} finally {
    executor.shutdown();
}

// ✅ Concurrent 컬렉션
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();

// ✅ Atomic 클래스
AtomicInteger count = new AtomicInteger();

// ✅ CompletableFuture
CompletableFuture.supplyAsync(() -> {})
    .thenApply(...)
    .thenAccept(...);
```

**시리즈 완료**: 34장 동시성 프로그래밍 마스터! 🎊
