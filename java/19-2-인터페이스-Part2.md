# 19-2. 인터페이스 Part 2: 기업 사례 및 주니어 개발자 시나리오

## 📚 기업 사례 (Company Case Studies)

실제 기업과 프레임워크에서 인터페이스가 어떻게 활용되는지 살펴보겠습니다.

---

## 🏢 기업 사례 1: Java의 Comparable과 Comparator 인터페이스

### 📖 개요

Java에서 객체를 정렬할 때 사용하는 `Comparable`과 `Comparator` 인터페이스는 인터페이스 설계의 교과서적인 예입니다. 이 두 인터페이스를 통해 객체의 "자연 순서(natural ordering)"와 "사용자 정의 순서"를 구현할 수 있습니다.

### 💡 왜 인터페이스를 사용했을까?

- **다양한 정렬 기준**: 같은 객체라도 상황에 따라 다른 기준으로 정렬 필요
- **표준 API 통합**: `Collections.sort()`, `Arrays.sort()` 등과 자연스럽게 통합
- **유연성**: 기존 클래스를 수정하지 않고도 새로운 정렬 기준 추가 가능
- **단일 메서드 인터페이스**: 명확하고 간단한 계약

### 💻 실제 코드 구현

```java
import java.util.*;

/**
 * Comparable 인터페이스 - 객체의 자연 순서 정의
 * (실제 java.lang.Comparable을 시뮬레이션)
 */
interface Comparable<T> {
    /**
     * 이 객체와 다른 객체를 비교
     * @return 음수(this < other), 0(this == other), 양수(this > other)
     */
    int compareTo(T other);
}

/**
 * Comparator 인터페이스 - 사용자 정의 순서 정의
 * (실제 java.util.Comparator를 시뮬레이션)
 */
interface Comparator<T> {
    int compare(T obj1, T obj2);

    // Java 8+ default 메서드
    default Comparator<T> reversed() {
        return (obj1, obj2) -> compare(obj2, obj1);
    }

    default Comparator<T> thenComparing(Comparator<T> other) {
        return (obj1, obj2) -> {
            int result = compare(obj1, obj2);
            return (result != 0) ? result : other.compare(obj1, obj2);
        };
    }
}

/**
 * 직원 클래스 - Comparable 구현 (자연 순서: 사번 기준)
 */
class Employee implements Comparable<Employee> {
    private int employeeId;
    private String name;
    private int salary;
    private String department;
    private int age;

    public Employee(int employeeId, String name, int salary, String department, int age) {
        this.employeeId = employeeId;
        this.name = name;
        this.salary = salary;
        this.department = department;
        this.age = age;
    }

    @Override
    public int compareTo(Employee other) {
        // 자연 순서: 사번 기준 오름차순
        return Integer.compare(this.employeeId, other.employeeId);
    }

    // Getters
    public int getEmployeeId() { return employeeId; }
    public String getName() { return name; }
    public int getSalary() { return salary; }
    public String getDepartment() { return department; }
    public int getAge() { return age; }

    @Override
    public String toString() {
        return String.format("Employee[ID=%d, Name=%s, Salary=%,d원, Dept=%s, Age=%d]",
            employeeId, name, salary, department, age);
    }
}

/**
 * Comparator 구현 예제들
 */

/**
 * 급여 기준 Comparator
 */
class SalaryComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return Integer.compare(e1.getSalary(), e2.getSalary());
    }
}

/**
 * 이름 기준 Comparator
 */
class NameComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return e1.getName().compareTo(e2.getName());
    }
}

/**
 * 부서 기준 Comparator
 */
class DepartmentComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return e1.getDepartment().compareTo(e2.getDepartment());
    }
}

/**
 * 나이 기준 Comparator
 */
class AgeComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return Integer.compare(e1.getAge(), e2.getAge());
    }
}

/**
 * 복합 정렬: 부서별로 그룹화한 후 급여순
 */
class DepartmentThenSalaryComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        // 먼저 부서로 비교
        int deptComparison = e1.getDepartment().compareTo(e2.getDepartment());
        if (deptComparison != 0) {
            return deptComparison;
        }
        // 부서가 같으면 급여로 비교 (내림차순)
        return Integer.compare(e2.getSalary(), e1.getSalary());
    }
}

/**
 * 정렬 유틸리티 클래스 (Java의 Collections.sort()를 시뮬레이션)
 */
class SortUtil {

    /**
     * Comparable을 구현한 객체 리스트 정렬 (자연 순서)
     */
    public static <T extends Comparable<T>> void sort(List<T> list) {
        // 버블 정렬로 간단히 구현 (실제로는 더 효율적인 알고리즘 사용)
        int n = list.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (list.get(j).compareTo(list.get(j + 1)) > 0) {
                    // 교환
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                }
            }
        }
    }

    /**
     * Comparator를 사용한 리스트 정렬 (사용자 정의 순서)
     */
    public static <T> void sort(List<T> list, Comparator<T> comparator) {
        int n = list.size();
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (comparator.compare(list.get(j), list.get(j + 1)) > 0) {
                    // 교환
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                }
            }
        }
    }
}
```

### 🧪 테스트 코드

```java
/**
 * Comparable/Comparator 인터페이스 테스트
 */
public class ComparableComparatorTest {

    public static void main(String[] args) {

        System.out.println("=================================================");
        System.out.println("Java Comparable/Comparator 인터페이스 패턴 테스트");
        System.out.println("=================================================\n");

        // 직원 데이터 생성
        List<Employee> employees = createEmployees();

        // 테스트 1: 자연 순서 정렬 (사번 기준)
        test1_NaturalOrder(new ArrayList<>(employees));

        // 테스트 2: 급여 기준 정렬
        test2_SalaryOrder(new ArrayList<>(employees));

        // 테스트 3: 이름 기준 정렬
        test3_NameOrder(new ArrayList<>(employees));

        // 테스트 4: 복합 정렬 (부서 → 급여)
        test4_ComplexOrder(new ArrayList<>(employees));

        // 테스트 5: 역순 정렬
        test5_ReverseOrder(new ArrayList<>(employees));

        // 테스트 6: 람다식 사용 (Java 8+)
        test6_LambdaExpressions(new ArrayList<>(employees));
    }

    static List<Employee> createEmployees() {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee(103, "김철수", 5000000, "개발팀", 35));
        employees.add(new Employee(101, "이영희", 6000000, "기획팀", 32));
        employees.add(new Employee(105, "박민수", 4500000, "개발팀", 28));
        employees.add(new Employee(102, "정지원", 7000000, "개발팀", 40));
        employees.add(new Employee(104, "최서연", 5500000, "기획팀", 30));
        return employees;
    }

    static void test1_NaturalOrder(List<Employee> employees) {
        System.out.println("### 테스트 1: 자연 순서 정렬 (사번 기준) ###\n");

        System.out.println("정렬 전:");
        employees.forEach(System.out::println);

        // Comparable을 사용한 정렬
        SortUtil.sort(employees);

        System.out.println("\n정렬 후 (사번 오름차순):");
        employees.forEach(System.out::println);
        System.out.println();
    }

    static void test2_SalaryOrder(List<Employee> employees) {
        System.out.println("### 테스트 2: 급여 기준 정렬 ###\n");

        // Comparator를 사용한 정렬
        SortUtil.sort(employees, new SalaryComparator());

        System.out.println("정렬 후 (급여 오름차순):");
        employees.forEach(System.out::println);
        System.out.println();
    }

    static void test3_NameOrder(List<Employee> employees) {
        System.out.println("### 테스트 3: 이름 기준 정렬 ###\n");

        SortUtil.sort(employees, new NameComparator());

        System.out.println("정렬 후 (이름 가나다순):");
        employees.forEach(System.out::println);
        System.out.println();
    }

    static void test4_ComplexOrder(List<Employee> employees) {
        System.out.println("### 테스트 4: 복합 정렬 (부서 → 급여) ###\n");

        SortUtil.sort(employees, new DepartmentThenSalaryComparator());

        System.out.println("정렬 후 (부서별 그룹화 → 급여 내림차순):");
        employees.forEach(System.out::println);
        System.out.println();
    }

    static void test5_ReverseOrder(List<Employee> employees) {
        System.out.println("### 테스트 5: 역순 정렬 ###\n");

        // reversed() default 메서드 사용
        Comparator<Employee> salaryComparator = new SalaryComparator();
        SortUtil.sort(employees, salaryComparator.reversed());

        System.out.println("정렬 후 (급여 내림차순):");
        employees.forEach(System.out::println);
        System.out.println();
    }

    static void test6_LambdaExpressions(List<Employee> employees) {
        System.out.println("### 테스트 6: 람다식 사용 (Java 8+) ###\n");

        // 람다식으로 Comparator 생성
        SortUtil.sort(employees, (e1, e2) -> Integer.compare(e1.getAge(), e2.getAge()));

        System.out.println("정렬 후 (나이 오름차순):");
        employees.forEach(System.out::println);
        System.out.println();

        // 메서드 레퍼런스 사용
        System.out.println("부서명으로 정렬 (메서드 레퍼런스):");
        SortUtil.sort(employees, (e1, e2) -> e1.getDepartment().compareTo(e2.getDepartment()));
        employees.forEach(System.out::println);
        System.out.println();
    }
}
```

### 🎯 핵심 포인트

1. **Comparable vs Comparator**
   - `Comparable`: 객체의 기본(자연) 순서 정의 (클래스 내부에 구현)
   - `Comparator`: 외부에서 다양한 정렬 기준 정의 (클래스 외부에 구현)

2. **단일 메서드 인터페이스 (Functional Interface)**
   - 명확한 계약: 하나의 메서드만 구현하면 됨
   - Java 8+에서 람다식 사용 가능

3. **유연한 정렬**
   - 같은 객체를 상황에 따라 다르게 정렬 가능
   - 복합 정렬, 역순 정렬 등 다양한 조합 가능

4. **default 메서드 활용**
   - `reversed()`: 역순 정렬
   - `thenComparing()`: 복합 정렬
   - 인터페이스에 기본 구현 제공하여 편의성 증가

5. **실제 Java API와의 통합**
   - `Collections.sort()`, `Arrays.sort()` 등과 완벽히 호환
   - 표준 라이브러리의 정렬 알고리즘 활용 가능

---

## 🏢 기업 사례 2: JDBC의 인터페이스 기반 설계

### 📖 개요

Java Database Connectivity (JDBC)는 데이터베이스와 통신하기 위한 표준 API입니다. JDBC는 인터페이스 기반 설계의 완벽한 예로, 다양한 데이터베이스 벤더(MySQL, Oracle, PostgreSQL 등)가 동일한 인터페이스를 구현하여 일관된 방식으로 사용할 수 있습니다.

### 💡 왜 인터페이스를 사용했을까?

- **데이터베이스 독립성**: 코드 변경 없이 다른 DB로 전환 가능
- **벤더 중립성**: 각 DB 회사가 자신만의 구현 제공
- **표준화**: 모든 DB가 동일한 API 제공
- **유연성**: 새로운 DB가 추가되어도 기존 코드 영향 없음

### 💻 실제 코드 구현

```java
import java.util.*;

/**
 * JDBC Driver 인터페이스 - 데이터베이스 드라이버
 */
interface Driver {
    Connection connect(String url, String username, String password) throws SQLException;
    boolean acceptsURL(String url);
    String getDriverName();
}

/**
 * Connection 인터페이스 - 데이터베이스 연결
 */
interface Connection extends AutoCloseable {
    Statement createStatement() throws SQLException;
    PreparedStatement prepareStatement(String sql) throws SQLException;
    void commit() throws SQLException;
    void rollback() throws SQLException;
    void setAutoCommit(boolean autoCommit) throws SQLException;
    boolean isClosed();
    void close();
}

/**
 * Statement 인터페이스 - SQL 실행
 */
interface Statement extends AutoCloseable {
    ResultSet executeQuery(String sql) throws SQLException;
    int executeUpdate(String sql) throws SQLException;
    void close();
}

/**
 * PreparedStatement 인터페이스 - 파라미터화된 SQL
 */
interface PreparedStatement extends Statement {
    void setString(int parameterIndex, String value);
    void setInt(int parameterIndex, int value);
    void setDouble(int parameterIndex, double value);
}

/**
 * ResultSet 인터페이스 - 쿼리 결과
 */
interface ResultSet extends AutoCloseable {
    boolean next() throws SQLException;
    String getString(String columnName) throws SQLException;
    int getInt(String columnName) throws SQLException;
    double getDouble(String columnName) throws SQLException;
    void close();
}

/**
 * SQLException - 데이터베이스 예외
 */
class SQLException extends Exception {
    public SQLException(String message) {
        super(message);
    }
}

// ========== MySQL 구현 ==========

/**
 * MySQL 드라이버
 */
class MySQLDriver implements Driver {

    @Override
    public Connection connect(String url, String username, String password) throws SQLException {
        if (!acceptsURL(url)) {
            throw new SQLException("Invalid MySQL URL: " + url);
        }

        System.out.println("[MySQL Driver] 연결 중...");
        System.out.println("  URL: " + url);
        System.out.println("  Username: " + username);

        // 연결 시뮬레이션
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("  ✓ MySQL 연결 성공");

        return new MySQLConnection(url, username);
    }

    @Override
    public boolean acceptsURL(String url) {
        return url.startsWith("jdbc:mysql://");
    }

    @Override
    public String getDriverName() {
        return "MySQL JDBC Driver";
    }
}

/**
 * MySQL 연결
 */
class MySQLConnection implements Connection {
    private String url;
    private String username;
    private boolean closed = false;
    private boolean autoCommit = true;

    public MySQLConnection(String url, String username) {
        this.url = url;
        this.username = username;
    }

    @Override
    public Statement createStatement() throws SQLException {
        if (closed) {
            throw new SQLException("Connection is closed");
        }
        return new MySQLStatement(this);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        if (closed) {
            throw new SQLException("Connection is closed");
        }
        return new MySQLPreparedStatement(this, sql);
    }

    @Override
    public void commit() throws SQLException {
        if (autoCommit) {
            throw new SQLException("Cannot commit when auto-commit is enabled");
        }
        System.out.println("[MySQL] 트랜잭션 커밋");
    }

    @Override
    public void rollback() throws SQLException {
        if (autoCommit) {
            throw new SQLException("Cannot rollback when auto-commit is enabled");
        }
        System.out.println("[MySQL] 트랜잭션 롤백");
    }

    @Override
    public void setAutoCommit(boolean autoCommit) {
        this.autoCommit = autoCommit;
        System.out.println("[MySQL] Auto-commit: " + autoCommit);
    }

    @Override
    public boolean isClosed() {
        return closed;
    }

    @Override
    public void close() {
        if (!closed) {
            System.out.println("[MySQL] 연결 종료");
            closed = true;
        }
    }
}

/**
 * MySQL Statement
 */
class MySQLStatement implements Statement {
    protected MySQLConnection connection;
    private boolean closed = false;

    public MySQLStatement(MySQLConnection connection) {
        this.connection = connection;
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        if (closed) {
            throw new SQLException("Statement is closed");
        }

        System.out.println("[MySQL] 쿼리 실행: " + sql);

        // 쿼리 결과 시뮬레이션
        List<Map<String, Object>> rows = new ArrayList<>();

        if (sql.toLowerCase().contains("select")) {
            // SELECT 결과 시뮬레이션
            Map<String, Object> row1 = new HashMap<>();
            row1.put("id", 1);
            row1.put("name", "김철수");
            row1.put("salary", 5000000);
            rows.add(row1);

            Map<String, Object> row2 = new HashMap<>();
            row2.put("id", 2);
            row2.put("name", "이영희");
            row2.put("salary", 6000000);
            rows.add(row2);
        }

        return new MySQLResultSet(rows);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        if (closed) {
            throw new SQLException("Statement is closed");
        }

        System.out.println("[MySQL] 업데이트 실행: " + sql);

        // 영향받은 행 수 시뮬레이션
        int affectedRows = 1;
        System.out.println("  ✓ " + affectedRows + "개 행 영향받음");

        return affectedRows;
    }

    @Override
    public void close() {
        if (!closed) {
            System.out.println("[MySQL] Statement 종료");
            closed = true;
        }
    }
}

/**
 * MySQL PreparedStatement
 */
class MySQLPreparedStatement extends MySQLStatement implements PreparedStatement {
    private String sql;
    private Map<Integer, Object> parameters = new HashMap<>();

    public MySQLPreparedStatement(MySQLConnection connection, String sql) {
        super(connection);
        this.sql = sql;
    }

    @Override
    public void setString(int parameterIndex, String value) {
        parameters.put(parameterIndex, value);
    }

    @Override
    public void setInt(int parameterIndex, int value) {
        parameters.put(parameterIndex, value);
    }

    @Override
    public void setDouble(int parameterIndex, double value) {
        parameters.put(parameterIndex, value);
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        // PreparedStatement는 미리 설정된 SQL 사용
        String finalSql = replacePlaceholders(this.sql);
        System.out.println("[MySQL] Prepared 쿼리 실행: " + finalSql);

        return super.executeQuery(finalSql);
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        String finalSql = replacePlaceholders(this.sql);
        return super.executeUpdate(finalSql);
    }

    private String replacePlaceholders(String sql) {
        String result = sql;
        for (Map.Entry<Integer, Object> entry : parameters.entrySet()) {
            result = result.replaceFirst("\\?", entry.getValue().toString());
        }
        return result;
    }
}

/**
 * MySQL ResultSet
 */
class MySQLResultSet implements ResultSet {
    private List<Map<String, Object>> rows;
    private int currentRow = -1;
    private boolean closed = false;

    public MySQLResultSet(List<Map<String, Object>> rows) {
        this.rows = rows;
    }

    @Override
    public boolean next() {
        currentRow++;
        return currentRow < rows.size();
    }

    @Override
    public String getString(String columnName) throws SQLException {
        if (currentRow < 0 || currentRow >= rows.size()) {
            throw new SQLException("Invalid cursor position");
        }
        Object value = rows.get(currentRow).get(columnName.toLowerCase());
        return value != null ? value.toString() : null;
    }

    @Override
    public int getInt(String columnName) throws SQLException {
        String value = getString(columnName);
        return value != null ? Integer.parseInt(value) : 0;
    }

    @Override
    public double getDouble(String columnName) throws SQLException {
        String value = getString(columnName);
        return value != null ? Double.parseDouble(value) : 0.0;
    }

    @Override
    public void close() {
        if (!closed) {
            System.out.println("[MySQL] ResultSet 종료");
            closed = true;
        }
    }
}

// ========== PostgreSQL 구현 ==========

/**
 * PostgreSQL 드라이버 (MySQL과 다른 구현)
 */
class PostgreSQLDriver implements Driver {

    @Override
    public Connection connect(String url, String username, String password) throws SQLException {
        if (!acceptsURL(url)) {
            throw new SQLException("Invalid PostgreSQL URL: " + url);
        }

        System.out.println("[PostgreSQL Driver] 연결 중...");
        System.out.println("  URL: " + url);
        System.out.println("  Username: " + username);
        System.out.println("  ✓ PostgreSQL 연결 성공");

        return new PostgreSQLConnection(url, username);
    }

    @Override
    public boolean acceptsURL(String url) {
        return url.startsWith("jdbc:postgresql://");
    }

    @Override
    public String getDriverName() {
        return "PostgreSQL JDBC Driver";
    }
}

/**
 * PostgreSQL 연결 (MySQL과 다른 구현이지만 동일한 인터페이스)
 */
class PostgreSQLConnection implements Connection {
    private String url;
    private boolean closed = false;

    public PostgreSQLConnection(String url, String username) {
        this.url = url;
    }

    @Override
    public Statement createStatement() {
        return new PostgreSQLStatement();
    }

    @Override
    public PreparedStatement prepareStatement(String sql) {
        return new PostgreSQLPreparedStatement(sql);
    }

    @Override
    public void commit() {
        System.out.println("[PostgreSQL] 트랜잭션 커밋");
    }

    @Override
    public void rollback() {
        System.out.println("[PostgreSQL] 트랜잭션 롤백");
    }

    @Override
    public void setAutoCommit(boolean autoCommit) {
        System.out.println("[PostgreSQL] Auto-commit: " + autoCommit);
    }

    @Override
    public boolean isClosed() {
        return closed;
    }

    @Override
    public void close() {
        if (!closed) {
            System.out.println("[PostgreSQL] 연결 종료");
            closed = true;
        }
    }
}

/**
 * PostgreSQL Statement
 */
class PostgreSQLStatement implements Statement {
    @Override
    public ResultSet executeQuery(String sql) {
        System.out.println("[PostgreSQL] 쿼리 실행: " + sql);
        return new PostgreSQLResultSet();
    }

    @Override
    public int executeUpdate(String sql) {
        System.out.println("[PostgreSQL] 업데이트 실행: " + sql);
        return 1;
    }

    @Override
    public void close() {
        System.out.println("[PostgreSQL] Statement 종료");
    }
}

/**
 * PostgreSQL PreparedStatement
 */
class PostgreSQLPreparedStatement extends PostgreSQLStatement implements PreparedStatement {
    private String sql;

    public PostgreSQLPreparedStatement(String sql) {
        this.sql = sql;
    }

    @Override
    public void setString(int parameterIndex, String value) {
        // PostgreSQL 파라미터 설정
    }

    @Override
    public void setInt(int parameterIndex, int value) {
        // PostgreSQL 파라미터 설정
    }

    @Override
    public void setDouble(int parameterIndex, double value) {
        // PostgreSQL 파라미터 설정
    }
}

/**
 * PostgreSQL ResultSet
 */
class PostgreSQLResultSet implements ResultSet {
    private int position = -1;

    @Override
    public boolean next() {
        position++;
        return position < 2; // 시뮬레이션: 2개 행
    }

    @Override
    public String getString(String columnName) {
        return "PostgreSQL Data";
    }

    @Override
    public int getInt(String columnName) {
        return 100;
    }

    @Override
    public double getDouble(String columnName) {
        return 100.0;
    }

    @Override
    public void close() {
        System.out.println("[PostgreSQL] ResultSet 종료");
    }
}
```

### 🧪 테스트 코드

```java
/**
 * JDBC 인터페이스 패턴 테스트
 */
public class JDBCInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("JDBC 인터페이스 기반 설계 테스트");
        System.out.println("===============================================\n");

        // 테스트 1: MySQL 사용
        test1_MySQL();

        // 테스트 2: PostgreSQL 사용 (동일한 코드!)
        test2_PostgreSQL();

        // 테스트 3: 데이터베이스 독립적인 DAO 패턴
        test3_DatabaseIndependentDAO();
    }

    static void test1_MySQL() {
        System.out.println("### 테스트 1: MySQL 데이터베이스 ###\n");

        try {
            // 드라이버 생성
            Driver driver = new MySQLDriver();

            // 연결
            Connection conn = driver.connect(
                "jdbc:mysql://localhost:3306/mydb",
                "admin",
                "password"
            );

            // Statement 사용
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM employees");

            // 결과 출력
            System.out.println("\n조회 결과:");
            while (rs.next()) {
                int id = rs.getInt("id");
                String name = rs.getString("name");
                int salary = rs.getInt("salary");
                System.out.println("  ID: " + id + ", Name: " + name + ", Salary: " + salary);
            }

            // 리소스 정리
            rs.close();
            stmt.close();
            conn.close();

        } catch (SQLException e) {
            System.err.println("에러: " + e.getMessage());
        }

        System.out.println();
    }

    static void test2_PostgreSQL() {
        System.out.println("### 테스트 2: PostgreSQL 데이터베이스 ###\n");

        try {
            // MySQL 대신 PostgreSQL 사용 (코드는 동일!)
            Driver driver = new PostgreSQLDriver();

            Connection conn = driver.connect(
                "jdbc:postgresql://localhost:5432/mydb",
                "admin",
                "password"
            );

            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT * FROM employees");

            System.out.println("\n조회 결과:");
            while (rs.next()) {
                String data = rs.getString("name");
                System.out.println("  Data: " + data);
            }

            rs.close();
            stmt.close();
            conn.close();

        } catch (SQLException e) {
            System.err.println("에러: " + e.getMessage());
        }

        System.out.println();
    }

    static void test3_DatabaseIndependentDAO() {
        System.out.println("### 테스트 3: 데이터베이스 독립적인 DAO ###\n");

        // 동일한 DAO 클래스로 다른 DB 사용
        EmployeeDAO mysqlDao = new EmployeeDAO(new MySQLDriver(),
            "jdbc:mysql://localhost:3306/mydb", "admin", "password");

        EmployeeDAO postgresDao = new EmployeeDAO(new PostgreSQLDriver(),
            "jdbc:postgresql://localhost:5432/mydb", "admin", "password");

        System.out.println("MySQL로 직원 조회:");
        mysqlDao.findAllEmployees();

        System.out.println("\nPostgreSQL로 직원 조회 (동일한 코드!):");
        postgresDao.findAllEmployees();
    }
}

/**
 * 데이터베이스 독립적인 DAO 클래스
 */
class EmployeeDAO {
    private Driver driver;
    private String url;
    private String username;
    private String password;

    public EmployeeDAO(Driver driver, String url, String username, String password) {
        this.driver = driver;
        this.url = url;
        this.username = username;
        this.password = password;
    }

    public void findAllEmployees() {
        try (Connection conn = driver.connect(url, username, password);
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("SELECT * FROM employees")) {

            while (rs.next()) {
                System.out.println("  직원: " + rs.getString("name"));
            }

        } catch (SQLException e) {
            System.err.println("에러: " + e.getMessage());
        }
    }

    public void insertEmployee(String name, int salary) {
        try (Connection conn = driver.connect(url, username, password);
             PreparedStatement pstmt = conn.prepareStatement(
                 "INSERT INTO employees (name, salary) VALUES (?, ?)")) {

            pstmt.setString(1, name);
            pstmt.setInt(2, salary);

            int rows = pstmt.executeUpdate("INSERT ...");
            System.out.println("  삽입된 행: " + rows);

        } catch (SQLException e) {
            System.err.println("에러: " + e.getMessage());
        }
    }
}
```

### 🎯 핵심 포인트

1. **인터페이스 계층 구조**
   - `Driver`: 드라이버 관리
   - `Connection`: 연결 관리
   - `Statement`: SQL 실행
   - `PreparedStatement`: 파라미터화된 SQL
   - `ResultSet`: 결과 처리

2. **데이터베이스 독립성**
   - 동일한 코드로 MySQL, PostgreSQL, Oracle 등 모든 DB 사용 가능
   - 드라이버만 교체하면 됨

3. **벤더 구현의 자유**
   - 각 DB 회사가 자신의 방식으로 구현
   - 성능 최적화, 특수 기능 등을 독립적으로 개발

4. **표준 API**
   - Java 표준 라이브러리에 포함
   - 모든 Java 개발자가 동일한 방식으로 사용

5. **리소스 관리**
   - `AutoCloseable` 인터페이스 상속으로 try-with-resources 지원
   - 자동으로 리소스 정리

---

## 🏢 기업 사례 3: Spring Framework의 인터페이스 기반 설계

### 📖 개요

Spring Framework는 인터페이스 기반 설계의 교과서입니다. 거의 모든 핵심 기능이 인터페이스로 정의되어 있어, 유연하고 테스트 가능하며 확장 가능한 애플리케이션을 만들 수 있습니다.

### 💡 왜 인터페이스를 사용했을까?

- **느슨한 결합 (Loose Coupling)**: 구현체를 쉽게 교체 가능
- **테스트 용이성**: Mock 객체로 쉽게 대체하여 단위 테스트 가능
- **AOP (Aspect-Oriented Programming)**: 프록시 패턴으로 부가 기능 추가
- **의존성 주입 (Dependency Injection)**: 인터페이스를 통한 DI 패턴 구현

### 💻 실제 코드 구현

```java
import java.util.*;

/**
 * ApplicationContext 인터페이스 - Spring의 핵심 컨테이너
 */
interface ApplicationContext {
    <T> T getBean(Class<T> requiredType);
    <T> T getBean(String name, Class<T> requiredType);
    boolean containsBean(String name);
    String[] getBeanDefinitionNames();
}

/**
 * BeanFactory 인터페이스 - Bean 생성 및 관리
 */
interface BeanFactory {
    Object getBean(String name);
    <T> T getBean(Class<T> requiredType);
}

/**
 * Repository 인터페이스 - 데이터 액세스 계층
 */
interface UserRepository {
    User findById(int id);
    List<User> findAll();
    void save(User user);
    void delete(int id);
}

/**
 * Service 인터페이스 - 비즈니스 로직 계층
 */
interface UserService {
    User getUserById(int id);
    List<User> getAllUsers();
    void registerUser(User user);
    void deleteUser(int id);
}

/**
 * User 엔티티
 */
class User {
    private int id;
    private String username;
    private String email;

    public User(int id, String username, String email) {
        this.id = id;
        this.username = username;
        this.email = email;
    }

    // Getters and Setters
    public int getId() { return id; }
    public String getUsername() { return username; }
    public String getEmail() { return email; }

    @Override
    public String toString() {
        return "User[id=" + id + ", username=" + username + ", email=" + email + "]";
    }
}

// ========== Repository 구현 ==========

/**
 * JDBC 기반 Repository 구현
 */
class JdbcUserRepository implements UserRepository {
    private Map<Integer, User> database = new HashMap<>();
    private int nextId = 1;

    public JdbcUserRepository() {
        // 초기 데이터
        database.put(1, new User(1, "admin", "admin@example.com"));
        database.put(2, new User(2, "user1", "user1@example.com"));
        nextId = 3;
    }

    @Override
    public User findById(int id) {
        System.out.println("[JdbcUserRepository] findById: " + id);
        return database.get(id);
    }

    @Override
    public List<User> findAll() {
        System.out.println("[JdbcUserRepository] findAll");
        return new ArrayList<>(database.values());
    }

    @Override
    public void save(User user) {
        if (user.getId() == 0) {
            // 새 사용자
            User newUser = new User(nextId++, user.getUsername(), user.getEmail());
            database.put(newUser.getId(), newUser);
            System.out.println("[JdbcUserRepository] save (insert): " + newUser);
        } else {
            // 기존 사용자 업데이트
            database.put(user.getId(), user);
            System.out.println("[JdbcUserRepository] save (update): " + user);
        }
    }

    @Override
    public void delete(int id) {
        System.out.println("[JdbcUserRepository] delete: " + id);
        database.remove(id);
    }
}

/**
 * JPA 기반 Repository 구현 (다른 구현체)
 */
class JpaUserRepository implements UserRepository {
    private Map<Integer, User> entityManager = new HashMap<>();

    public JpaUserRepository() {
        entityManager.put(1, new User(1, "jpa_admin", "jpa_admin@example.com"));
    }

    @Override
    public User findById(int id) {
        System.out.println("[JpaUserRepository] findById using JPA: " + id);
        return entityManager.get(id);
    }

    @Override
    public List<User> findAll() {
        System.out.println("[JpaUserRepository] findAll using JPA");
        return new ArrayList<>(entityManager.values());
    }

    @Override
    public void save(User user) {
        System.out.println("[JpaUserRepository] persist: " + user);
        entityManager.put(user.getId(), user);
    }

    @Override
    public void delete(int id) {
        System.out.println("[JpaUserRepository] remove: " + id);
        entityManager.remove(id);
    }
}

// ========== Service 구현 ==========

/**
 * UserService 구현 - Repository에 의존
 */
class UserServiceImpl implements UserService {
    private final UserRepository userRepository;

    // 생성자 주입 (Constructor Injection)
    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
        System.out.println("[UserServiceImpl] 생성됨 with " +
            userRepository.getClass().getSimpleName());
    }

    @Override
    public User getUserById(int id) {
        System.out.println("[UserService] getUserById: " + id);
        return userRepository.findById(id);
    }

    @Override
    public List<User> getAllUsers() {
        System.out.println("[UserService] getAllUsers");
        return userRepository.findAll();
    }

    @Override
    public void registerUser(User user) {
        System.out.println("[UserService] registerUser: " + user.getUsername());
        // 비즈니스 로직: 유효성 검사 등
        if (user.getUsername() == null || user.getUsername().isEmpty()) {
            throw new IllegalArgumentException("Username cannot be empty");
        }
        userRepository.save(user);
    }

    @Override
    public void deleteUser(int id) {
        System.out.println("[UserService] deleteUser: " + id);
        userRepository.delete(id);
    }
}

// ========== Spring ApplicationContext 구현 (단순화) ==========

/**
 * 간단한 ApplicationContext 구현
 */
class SimpleApplicationContext implements ApplicationContext {
    private Map<String, Object> beans = new HashMap<>();
    private Map<Class<?>, String> beanNamesByType = new HashMap<>();

    public void registerBean(String name, Object bean) {
        beans.put(name, bean);
        beanNamesByType.put(bean.getClass(), name);

        // 인터페이스도 등록
        for (Class<?> iface : bean.getClass().getInterfaces()) {
            beanNamesByType.put(iface, name);
        }
    }

    @Override
    public <T> T getBean(Class<T> requiredType) {
        String beanName = beanNamesByType.get(requiredType);
        if (beanName == null) {
            throw new RuntimeException("No bean found for type: " + requiredType.getName());
        }
        return getBean(beanName, requiredType);
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T getBean(String name, Class<T> requiredType) {
        Object bean = beans.get(name);
        if (bean == null) {
            throw new RuntimeException("No bean found with name: " + name);
        }
        return (T) bean;
    }

    @Override
    public boolean containsBean(String name) {
        return beans.containsKey(name);
    }

    @Override
    public String[] getBeanDefinitionNames() {
        return beans.keySet().toArray(new String[0]);
    }
}
```

### 🧪 테스트 코드

```java
/**
 * Spring 인터페이스 패턴 테스트
 */
public class SpringInterfaceTest {

    public static void main(String[] args) {

        System.out.println("===============================================");
        System.out.println("Spring Framework 인터페이스 기반 설계 테스트");
        System.out.println("===============================================\n");

        // 테스트 1: JDBC Repository 사용
        test1_JdbcRepository();

        // 테스트 2: JPA Repository로 교체 (코드 변경 없음!)
        test2_JpaRepository();

        // 테스트 3: Spring ApplicationContext 사용
        test3_SpringContainer();

        // 테스트 4: 의존성 주입의 장점
        test4_DependencyInjection();
    }

    static void test1_JdbcRepository() {
        System.out.println("### 테스트 1: JDBC Repository 사용 ###\n");

        // Repository 생성
        UserRepository repository = new JdbcUserRepository();

        // Service 생성 (Repository 주입)
        UserService service = new UserServiceImpl(repository);

        // Service 사용
        System.out.println("\n모든 사용자 조회:");
        List<User> users = service.getAllUsers();
        users.forEach(System.out::println);

        System.out.println("\n사용자 등록:");
        service.registerUser(new User(0, "newuser", "newuser@example.com"));

        System.out.println("\n특정 사용자 조회:");
        User user = service.getUserById(1);
        System.out.println(user);

        System.out.println();
    }

    static void test2_JpaRepository() {
        System.out.println("### 테스트 2: JPA Repository로 교체 ###\n");

        // JDBC 대신 JPA 사용 (Service 코드는 동일!)
        UserRepository repository = new JpaUserRepository();
        UserService service = new UserServiceImpl(repository);

        System.out.println("\n모든 사용자 조회:");
        List<User> users = service.getAllUsers();
        users.forEach(System.out::println);

        System.out.println();
    }

    static void test3_SpringContainer() {
        System.out.println("### 테스트 3: Spring ApplicationContext 사용 ###\n");

        // ApplicationContext 생성 및 Bean 등록
        SimpleApplicationContext context = new SimpleApplicationContext();

        // Repository Bean 등록
        UserRepository repository = new JdbcUserRepository();
        context.registerBean("userRepository", repository);

        // Service Bean 등록
        UserService service = new UserServiceImpl(repository);
        context.registerBean("userService", service);

        // Bean 조회
        System.out.println("\n등록된 Bean 목록:");
        for (String beanName : context.getBeanDefinitionNames()) {
            System.out.println("  - " + beanName);
        }

        // Bean 사용
        System.out.println("\nBean 조회 및 사용:");
        UserService userService = context.getBean(UserService.class);
        List<User> users = userService.getAllUsers();
        users.forEach(System.out::println);

        System.out.println();
    }

    static void test4_DependencyInjection() {
        System.out.println("### 테스트 4: 의존성 주입의 장점 ###\n");

        System.out.println("1. 테스트 용이성 (Mock 객체 사용):");

        // Mock Repository 생성
        UserRepository mockRepository = new UserRepository() {
            @Override
            public User findById(int id) {
                System.out.println("  [Mock] findById called");
                return new User(id, "mockuser", "mock@example.com");
            }

            @Override
            public List<User> findAll() {
                System.out.println("  [Mock] findAll called");
                return Arrays.asList(new User(1, "mock1", "mock1@example.com"));
            }

            @Override
            public void save(User user) {
                System.out.println("  [Mock] save called");
            }

            @Override
            public void delete(int id) {
                System.out.println("  [Mock] delete called");
            }
        };

        // Mock Repository로 Service 테스트
        UserService service = new UserServiceImpl(mockRepository);
        User user = service.getUserById(1);
        System.out.println("  조회된 사용자: " + user);

        System.out.println("\n2. 구현체 교체 용이성:");
        System.out.println("  - 설정 파일만 변경하면 JDBC ↔ JPA 전환");
        System.out.println("  - 코드 수정 없이 다른 구현체 사용 가능");
        System.out.println("  - 인터페이스 계약만 지키면 됨");

        System.out.println();
    }
}
```

### 🎯 핵심 포인트

1. **계층 분리 (Layered Architecture)**
   - Controller → Service → Repository
   - 각 계층이 인터페이스로 정의됨
   - 계층 간 느슨한 결합

2. **의존성 주입 (Dependency Injection)**
   - 생성자 주입으로 의존성 전달
   - 인터페이스 타입으로 의존성 선언
   - 구현체는 외부에서 주입

3. **테스트 용이성**
   - Mock 객체로 쉽게 대체 가능
   - 단위 테스트 작성이 용이
   - 통합 테스트도 간편

4. **유연한 구현체 교체**
   - JDBC → JPA → MongoDB 등 자유롭게 전환
   - 비즈니스 로직 코드는 변경 불필요
   - 설정만으로 구현체 변경

5. **실제 Spring과의 유사성**
   - 실제 Spring도 거의 모든 기능이 인터페이스 기반
   - `@Autowired`, `@Bean` 등의 어노테이션으로 DI
   - AOP 프록시를 통한 부가 기능 추가

---

## 👨‍💻 주니어 개발자 시나리오 (Junior Developer Scenarios)

실무에서 주니어 개발자들이 인터페이스를 사용할 때 자주 겪는 실수와 해결 방법을 알아보겠습니다.

---

## 🚫 시나리오 1: 인터페이스를 인스턴스화하려는 시도

### 📋 상황

주니어 개발자 김개발씨가 결제 시스템을 구현하다가 인터페이스를 직접 인스턴스화하려고 시도했습니다.

### ❌ 잘못된 코드

```java
/**
 * 결제 인터페이스
 */
interface PaymentProcessor {
    boolean processPayment(double amount);
    void refund(double amount);
}

/**
 * 주니어 개발자의 잘못된 시도
 */
public class PaymentSystemWrong {

    public static void main(String[] args) {

        // ❌ 컴파일 에러: 인터페이스는 인스턴스화 불가능!
        // PaymentProcessor processor = new PaymentProcessor();

        // 개발자가 생각한 이유:
        // "PaymentProcessor가 클래스인 줄 알았어요.
        //  클래스처럼 생겼는데 왜 new로 만들 수 없죠?"
    }
}
```

### 💥 에러 메시지

```
Error: PaymentProcessor is abstract; cannot be instantiated
```

### ✅ 올바른 코드

```java
/**
 * 결제 인터페이스
 */
interface PaymentProcessor {
    boolean processPayment(double amount);
    void refund(double amount);
}

/**
 * 신용카드 결제 구현
 */
class CreditCardProcessor implements PaymentProcessor {

    @Override
    public boolean processPayment(double amount) {
        System.out.println("신용카드로 " + amount + "원 결제 처리");
        return true;
    }

    @Override
    public void refund(double amount) {
        System.out.println("신용카드로 " + amount + "원 환불 처리");
    }
}

/**
 * 올바른 방법
 */
public class PaymentSystemCorrect {

    public static void main(String[] args) {

        System.out.println("=== 인터페이스 인스턴스화 올바른 방법 ===\n");

        // ✅ 방법 1: 구현 클래스로 인스턴스 생성
        PaymentProcessor processor1 = new CreditCardProcessor();
        processor1.processPayment(50000);

        System.out.println();

        // ✅ 방법 2: 익명 클래스 사용
        PaymentProcessor processor2 = new PaymentProcessor() {
            @Override
            public boolean processPayment(double amount) {
                System.out.println("익명 클래스로 " + amount + "원 결제 처리");
                return true;
            }

            @Override
            public void refund(double amount) {
                System.out.println("익명 클래스로 " + amount + "원 환불 처리");
            }
        };
        processor2.processPayment(30000);

        System.out.println();

        // ✅ 방법 3: 람다식 사용 (단, 메서드가 1개일 때만 - Functional Interface)
        // PaymentProcessor는 메서드가 2개라서 람다식 불가
        // 단일 메서드 인터페이스 예제:
        interface SimplePayment {
            boolean pay(double amount);
        }

        SimplePayment simpleProcessor = (amount) -> {
            System.out.println("람다식으로 " + amount + "원 결제 처리");
            return true;
        };
        simpleProcessor.pay(20000);
    }
}
```

### 📚 배운 내용

1. **인터페이스는 직접 인스턴스화 불가능**
   - 인터페이스는 추상적인 계약(contract)일 뿐
   - 구현 클래스를 통해서만 사용 가능

2. **인터페이스 사용 방법 3가지**
   - 구현 클래스 생성
   - 익명 클래스 사용
   - 람다식 (Functional Interface인 경우)

3. **인터페이스 vs 클래스**
   - 인터페이스: 무엇을 할지 정의 (what)
   - 클래스: 어떻게 할지 구현 (how)

---

## 🚫 시나리오 2: 인터페이스 메서드를 일부만 구현

### 📋 상황

주니어 개발자 박코드씨가 미디어 플레이어를 만들면서 필요한 메서드만 구현하고 나머지는 생략했습니다.

### ❌ 잘못된 코드

```java
/**
 * 미디어 플레이어 인터페이스
 */
interface MediaPlayer {
    void play();
    void pause();
    void stop();
    void rewind();
    void fastForward();
    int getCurrentPosition();
    int getTotalDuration();
}

/**
 * 주니어 개발자의 잘못된 구현
 */
class SimpleVideoPlayer implements MediaPlayer {

    // ❌ 컴파일 에러: 모든 메서드를 구현하지 않음!
    @Override
    public void play() {
        System.out.println("재생");
    }

    @Override
    public void pause() {
        System.out.println("일시정지");
    }

    @Override
    public void stop() {
        System.out.println("정지");
    }

    // rewind(), fastForward(), getCurrentPosition(), getTotalDuration()
    // 메서드를 구현하지 않음!

    // 개발자가 생각한 이유:
    // "저는 재생, 일시정지, 정지만 필요한데
    //  나머지는 나중에 구현하면 안 되나요?"
}
```

### 💥 에러 메시지

```
Error: SimpleVideoPlayer is not abstract and does not override abstract method
rewind() in MediaPlayer
```

### ✅ 올바른 코드

```java
/**
 * 미디어 플레이어 인터페이스
 */
interface MediaPlayer {
    void play();
    void pause();
    void stop();
    void rewind();
    void fastForward();
    int getCurrentPosition();
    int getTotalDuration();
}

/**
 * 올바른 구현 - 방법 1: 모든 메서드 구현
 */
class FullMediaPlayer implements MediaPlayer {
    private int currentPosition = 0;
    private int totalDuration = 300; // 5분

    @Override
    public void play() {
        System.out.println("▶ 재생");
    }

    @Override
    public void pause() {
        System.out.println("⏸ 일시정지");
    }

    @Override
    public void stop() {
        System.out.println("⏹ 정지");
        currentPosition = 0;
    }

    @Override
    public void rewind() {
        currentPosition = Math.max(0, currentPosition - 10);
        System.out.println("⏪ 되감기: " + currentPosition + "초");
    }

    @Override
    public void fastForward() {
        currentPosition = Math.min(totalDuration, currentPosition + 10);
        System.out.println("⏩ 빨리감기: " + currentPosition + "초");
    }

    @Override
    public int getCurrentPosition() {
        return currentPosition;
    }

    @Override
    public int getTotalDuration() {
        return totalDuration;
    }
}

/**
 * 더 나은 설계 - 방법 2: 인터페이스 분리 (Interface Segregation Principle)
 */

// 기본 재생 기능만 포함
interface BasicPlayer {
    void play();
    void pause();
    void stop();
}

// 추가 제어 기능
interface AdvancedPlayer extends BasicPlayer {
    void rewind();
    void fastForward();
}

// 정보 제공 기능
interface PlayerInfo {
    int getCurrentPosition();
    int getTotalDuration();
}

/**
 * 간단한 플레이어 - 기본 기능만 구현
 */
class SimplePlayer implements BasicPlayer {

    @Override
    public void play() {
        System.out.println("재생");
    }

    @Override
    public void pause() {
        System.out.println("일시정지");
    }

    @Override
    public void stop() {
        System.out.println("정지");
    }
}

/**
 * 고급 플레이어 - 모든 기능 구현
 */
class AdvancedMediaPlayer implements AdvancedPlayer, PlayerInfo {
    private int position = 0;

    @Override
    public void play() {
        System.out.println("▶ 재생");
    }

    @Override
    public void pause() {
        System.out.println("⏸ 일시정지");
    }

    @Override
    public void stop() {
        System.out.println("⏹ 정지");
        position = 0;
    }

    @Override
    public void rewind() {
        position = Math.max(0, position - 10);
        System.out.println("⏪ 되감기");
    }

    @Override
    public void fastForward() {
        position += 10;
        System.out.println("⏩ 빨리감기");
    }

    @Override
    public int getCurrentPosition() {
        return position;
    }

    @Override
    public int getTotalDuration() {
        return 300;
    }
}

/**
 * 테스트
 */
public class MediaPlayerTest {

    public static void main(String[] args) {

        System.out.println("=== 인터페이스 메서드 구현 방법 ===\n");

        System.out.println("1. 모든 메서드를 구현한 플레이어:");
        MediaPlayer fullPlayer = new FullMediaPlayer();
        fullPlayer.play();
        fullPlayer.fastForward();
        fullPlayer.rewind();
        fullPlayer.stop();

        System.out.println("\n2. 인터페이스를 분리한 간단한 플레이어:");
        BasicPlayer simplePlayer = new SimplePlayer();
        simplePlayer.play();
        simplePlayer.pause();
        simplePlayer.stop();

        System.out.println("\n3. 필요한 기능만 선택한 고급 플레이어:");
        AdvancedMediaPlayer advancedPlayer = new AdvancedMediaPlayer();
        advancedPlayer.play();
        advancedPlayer.fastForward();
        System.out.println("현재 위치: " + advancedPlayer.getCurrentPosition() + "초");
    }
}
```

### 📚 배운 내용

1. **인터페이스의 모든 메서드 구현 필수**
   - 인터페이스를 구현하면 모든 메서드를 반드시 구현해야 함
   - 선택적 구현 불가능

2. **해결 방법**
   - 방법 1: 모든 메서드를 구현 (필요없는 메서드는 빈 구현 또는 기본 동작)
   - 방법 2: 인터페이스를 더 작게 분리 (ISP - Interface Segregation Principle)

3. **인터페이스 분리 원칙 (ISP)**
   - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 함
   - 큰 인터페이스보다 작고 구체적인 여러 인터페이스가 더 좋음

---

## 🚫 시나리오 3: 인터페이스와 추상 클래스 혼동

### 📋 상황

주니어 개발자 최자바씨가 인터페이스와 추상 클래스를 언제 사용해야 할지 혼란스러워했습니다.

### ❓ 혼란스러운 상황

```java
/**
 * 문제: 이것을 인터페이스로 만들어야 할까? 추상 클래스로 만들어야 할까?
 */

// 방법 1: 인터페이스로 정의?
interface Animal_Interface {
    void eat();
    void sleep();
    void makeSound();
}

// 방법 2: 추상 클래스로 정의?
abstract class Animal_AbstractClass {
    public abstract void eat();
    public abstract void sleep();
    public abstract void makeSound();
}

// 개발자의 고민:
// "둘 다 비슷해 보이는데 뭐가 다른가요?"
// "언제 인터페이스를 쓰고 언제 추상 클래스를 써야 하나요?"
```

### 📊 인터페이스 vs 추상 클래스 비교

```java
/**
 * 비교 예제: 동물 시스템
 */

// ========== 추상 클래스 사용이 적합한 경우 ==========

/**
 * 추상 클래스: 공통 구현이 있을 때
 */
abstract class Animal {
    // ✅ 인스턴스 변수 가능
    protected String name;
    protected int age;

    // ✅ 생성자 가능
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // ✅ 공통 구현 메서드 (모든 동물이 같은 방식)
    public void sleep() {
        System.out.println(name + "이(가) 잠을 잡니다... 💤");
    }

    public void printInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }

    // ✅ 추상 메서드 (서브클래스가 반드시 구현)
    public abstract void eat();
    public abstract void makeSound();
}

class Dog extends Animal {

    public Dog(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + "이(가) 사료를 먹습니다. 🦴");
    }

    @Override
    public void makeSound() {
        System.out.println(name + ": 멍멍! 🐕");
    }
}

class Cat extends Animal {

    public Cat(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + "이(가) 생선을 먹습니다. 🐟");
    }

    @Override
    public void makeSound() {
        System.out.println(name + ": 야옹~ 🐈");
    }
}

// ========== 인터페이스 사용이 적합한 경우 ==========

/**
 * 인터페이스: 능력(capability)을 정의할 때
 */
interface Flyable {
    void fly();
    int getMaxAltitude();
}

interface Swimmable {
    void swim();
    int getMaxDepth();
}

interface Climbable {
    void climb();
}

/**
 * 오리: 날 수도 있고 수영도 가능 (다중 인터페이스 구현)
 */
class Duck extends Animal implements Flyable, Swimmable {

    public Duck(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + "이(가) 벌레를 먹습니다. 🐛");
    }

    @Override
    public void makeSound() {
        System.out.println(name + ": 꽥꽥! 🦆");
    }

    // Flyable 구현
    @Override
    public void fly() {
        System.out.println(name + "이(가) 날아갑니다! 🦆");
    }

    @Override
    public int getMaxAltitude() {
        return 1000; // 1000미터
    }

    // Swimmable 구현
    @Override
    public void swim() {
        System.out.println(name + "이(가) 수영합니다! 🦆");
    }

    @Override
    public int getMaxDepth() {
        return 5; // 5미터
    }
}

/**
 * 펭귄: 수영만 가능 (날지 못함)
 */
class Penguin extends Animal implements Swimmable {

    public Penguin(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + "이(가) 물고기를 먹습니다. 🐟");
    }

    @Override
    public void makeSound() {
        System.out.println(name + ": 끼룩끼룩! 🐧");
    }

    @Override
    public void swim() {
        System.out.println(name + "이(가) 물속을 헤엄칩니다! 🐧");
    }

    @Override
    public int getMaxDepth() {
        return 500; // 500미터
    }
}

/**
 * 원숭이: 나무를 탈 수 있음
 */
class Monkey extends Animal implements Climbable {

    public Monkey(String name, int age) {
        super(name, age);
    }

    @Override
    public void eat() {
        System.out.println(name + "이(가) 바나나를 먹습니다. 🍌");
    }

    @Override
    public void makeSound() {
        System.out.println(name + ": 우끼끼! 🐵");
    }

    @Override
    public void climb() {
        System.out.println(name + "이(가) 나무를 탑니다! 🌴");
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 인터페이스 vs 추상 클래스 테스트
 */
public class InterfaceVsAbstractClassTest {

    public static void main(String[] args) {

        System.out.println("===================================");
        System.out.println("인터페이스 vs 추상 클래스 비교");
        System.out.println("===================================\n");

        // 다양한 동물 생성
        Dog dog = new Dog("바둑이", 3);
        Cat cat = new Cat("나비", 2);
        Duck duck = new Duck("도날드", 1);
        Penguin penguin = new Penguin("펭수", 5);
        Monkey monkey = new Monkey("손오공", 4);

        System.out.println("### 1. 추상 클래스의 공통 기능 ###\n");
        dog.printInfo();
        dog.eat();
        dog.makeSound();
        dog.sleep(); // 추상 클래스의 공통 메서드

        System.out.println();

        cat.printInfo();
        cat.eat();
        cat.makeSound();
        cat.sleep(); // 모든 동물이 같은 방식으로 잠

        System.out.println("\n### 2. 인터페이스로 다양한 능력 표현 ###\n");

        System.out.println("오리의 능력:");
        duck.printInfo();
        duck.eat();
        duck.fly();  // Flyable
        duck.swim(); // Swimmable
        System.out.println("최대 고도: " + duck.getMaxAltitude() + "m");
        System.out.println("최대 수심: " + duck.getMaxDepth() + "m");

        System.out.println("\n펭귄의 능력:");
        penguin.printInfo();
        penguin.eat();
        penguin.swim(); // Swimmable만 가능 (Flyable 없음)
        System.out.println("최대 수심: " + penguin.getMaxDepth() + "m");

        System.out.println("\n원숭이의 능력:");
        monkey.printInfo();
        monkey.eat();
        monkey.climb(); // Climbable

        System.out.println("\n### 3. 인터페이스 타입으로 다형성 ###\n");

        List<Swimmable> swimmers = new ArrayList<>();
        swimmers.add(duck);
        swimmers.add(penguin);

        System.out.println("수영 가능한 동물들:");
        for (Swimmable swimmer : swimmers) {
            swimmer.swim();
        }

        System.out.println("\n### 4. 핵심 차이점 정리 ###\n");

        System.out.println("📌 추상 클래스 (Animal):");
        System.out.println("  - 공통 속성 (name, age) 제공");
        System.out.println("  - 공통 동작 (sleep, printInfo) 구현");
        System.out.println("  - 단일 상속만 가능");
        System.out.println("  - 'is-a' 관계 (Dog is an Animal)");

        System.out.println("\n📌 인터페이스 (Flyable, Swimmable, Climbable):");
        System.out.println("  - 능력/행동 정의 (fly, swim, climb)");
        System.out.println("  - 다중 구현 가능 (Duck은 Flyable + Swimmable)");
        System.out.println("  - 'can-do' 관계 (Duck can fly, can swim)");
    }
}
```

### 📚 배운 내용

1. **추상 클래스 사용 시기**
   - 관련된 클래스들 간에 코드를 공유하고 싶을 때
   - 공통 필드와 메서드가 있을 때
   - `is-a` 관계 (Dog **is an** Animal)
   - 단일 상속 계층 구조

2. **인터페이스 사용 시기**
   - 관련 없는 클래스들이 같은 기능을 구현할 때
   - 다중 구현이 필요할 때
   - `can-do` 관계 (Duck **can** fly, **can** swim)
   - 능력(capability) 정의

3. **핵심 차이점**

| 구분 | 추상 클래스 | 인터페이스 |
|------|-------------|------------|
| 상속/구현 | 단일 상속 | 다중 구현 |
| 필드 | 인스턴스 변수 가능 | 상수만 가능 (static final) |
| 생성자 | 가능 | 불가능 |
| 메서드 구현 | 가능 | default/static 메서드만 가능 |
| 관계 | is-a | can-do |
| 목적 | 공통 구현 제공 | 계약(contract) 정의 |

4. **실무 가이드**
   - 공통 코드가 많으면 → 추상 클래스
   - 다양한 클래스가 같은 동작을 하면 → 인터페이스
   - 둘 다 사용 가능 (추상 클래스 + 인터페이스)

---

## 🚫 시나리오 4: 인터페이스 다중 구현의 메서드 충돌

### 📋 상황

주니어 개발자 정코더씨가 여러 인터페이스를 구현하다가 같은 이름의 메서드가 충돌하는 문제를 겪었습니다.

### ❌ 문제 상황

```java
/**
 * 인쇄 가능 인터페이스
 */
interface Printable {
    void print();
    String getFormat();
}

/**
 * 표시 가능 인터페이스
 */
interface Displayable {
    void display();
    String getFormat(); // ⚠️ Printable과 같은 메서드 이름!
}

/**
 * 주니어 개발자의 혼란
 */
class Document implements Printable, Displayable {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    @Override
    public void print() {
        System.out.println("문서 인쇄: " + content);
    }

    @Override
    public void display() {
        System.out.println("화면 표시: " + content);
    }

    // 개발자의 고민:
    // "getFormat() 메서드가 두 인터페이스에 다 있는데
    //  어떻게 구현해야 하나요? 두 개를 다 만들어야 하나요?"

    @Override
    public String getFormat() {
        // ✅ 하나만 구현하면 두 인터페이스 모두 만족!
        // 하지만 두 인터페이스가 다른 의미로 사용될 수 있어 주의 필요
        return "PDF";
    }
}
```

### 📊 메서드 충돌 시나리오

```java
/**
 * 시나리오 1: 반환 타입이 같은 경우 (OK)
 */
interface A {
    String getValue();
}

interface B {
    String getValue();
}

class Case1 implements A, B {
    @Override
    public String getValue() {
        // ✅ 하나의 구현으로 두 인터페이스 모두 만족
        return "같은 값";
    }
}

/**
 * 시나리오 2: 반환 타입이 다른 경우 (컴파일 에러!)
 */
interface C {
    String getData();
}

interface D {
    int getData(); // ❌ 반환 타입이 다름!
}

// ❌ 컴파일 에러: 반환 타입이 다른 같은 이름의 메서드는 구현 불가능
// class Case2 implements C, D {
//     // 불가능!
// }

/**
 * 시나리오 3: default 메서드 충돌
 */
interface E {
    default void process() {
        System.out.println("E의 process");
    }
}

interface F {
    default void process() {
        System.out.println("F의 process");
    }
}

class Case3 implements E, F {
    // ❌ 컴파일 에러: 어떤 default 메서드를 사용할지 모호함
    // 해결: 명시적으로 오버라이드해야 함

    @Override
    public void process() {
        // ✅ 방법 1: 직접 구현
        System.out.println("Case3의 process (직접 구현)");

        // ✅ 방법 2: 특정 인터페이스의 default 메서드 호출
        // E.super.process();
        // F.super.process();
    }
}
```

### ✅ 올바른 해결 방법

```java
/**
 * 해결 방법 1: 메서드 이름을 명확하게 분리
 */
interface PrintFormatter {
    String getPrintFormat();
    void print();
}

interface DisplayFormatter {
    String getDisplayFormat();
    void display();
}

class SmartDocument implements PrintFormatter, DisplayFormatter {
    private String content;

    public SmartDocument(String content) {
        this.content = content;
    }

    @Override
    public String getPrintFormat() {
        return "PDF"; // 인쇄용 포맷
    }

    @Override
    public String getDisplayFormat() {
        return "HTML"; // 화면용 포맷
    }

    @Override
    public void print() {
        System.out.println("[인쇄] " + content + " (" + getPrintFormat() + ")");
    }

    @Override
    public void display() {
        System.out.println("[화면] " + content + " (" + getDisplayFormat() + ")");
    }
}

/**
 * 해결 방법 2: 제네릭 인터페이스 사용
 */
interface Formatter<T> {
    String format(T data);
}

class Report {
    String title;
    String content;

    public Report(String title, String content) {
        this.title = title;
        this.content = content;
    }
}

class ReportFormatter implements Formatter<Report> {

    @Override
    public String format(Report data) {
        return "=== " + data.title + " ===\n" + data.content;
    }
}

/**
 * 해결 방법 3: default 메서드 충돌 해결
 */
interface Saveable {
    default void save() {
        System.out.println("Saveable: 기본 저장");
    }

    void saveToFile(String filename);
}

interface Exportable {
    default void save() {
        System.out.println("Exportable: 기본 저장");
    }

    void exportToFormat(String format);
}

class DataManager implements Saveable, Exportable {
    private String data;

    public DataManager(String data) {
        this.data = data;
    }

    // 충돌 해결 1: 직접 구현
    @Override
    public void save() {
        System.out.println("DataManager: 커스텀 저장 로직");
        System.out.println("  데이터: " + data);
    }

    @Override
    public void saveToFile(String filename) {
        System.out.println("파일에 저장: " + filename);
    }

    @Override
    public void exportToFormat(String format) {
        System.out.println("포맷으로 내보내기: " + format);
    }

    // 특정 인터페이스의 default 메서드를 명시적으로 호출하는 메서드
    public void useSaveableDefault() {
        Saveable.super.save();
    }

    public void useExportableDefault() {
        Exportable.super.save();
    }
}

/**
 * 해결 방법 4: 인터페이스 계층 구조 사용
 */
interface BaseProcessor {
    void process();
}

interface AdvancedProcessor extends BaseProcessor {
    @Override
    default void process() {
        System.out.println("고급 처리");
    }

    void advancedProcess();
}

interface SpecialProcessor extends BaseProcessor {
    @Override
    default void process() {
        System.out.println("특별 처리");
    }

    void specialProcess();
}

class MultiProcessor implements AdvancedProcessor, SpecialProcessor {

    @Override
    public void process() {
        // 명시적으로 하나를 선택하거나 둘 다 호출
        System.out.println("MultiProcessor: 통합 처리");
        AdvancedProcessor.super.process();
        SpecialProcessor.super.process();
    }

    @Override
    public void advancedProcess() {
        System.out.println("고급 기능 실행");
    }

    @Override
    public void specialProcess() {
        System.out.println("특별 기능 실행");
    }
}
```

### 🧪 테스트 코드

```java
/**
 * 인터페이스 메서드 충돌 테스트
 */
public class InterfaceConflictTest {

    public static void main(String[] args) {

        System.out.println("=========================================");
        System.out.println("인터페이스 메서드 충돌 해결 방법");
        System.out.println("=========================================\n");

        // 테스트 1: 메서드 이름 분리
        test1_SeparateMethodNames();

        // 테스트 2: 제네릭 인터페이스
        test2_GenericInterface();

        // 테스트 3: default 메서드 충돌 해결
        test3_DefaultMethodConflict();

        // 테스트 4: 인터페이스 계층 구조
        test4_InterfaceHierarchy();
    }

    static void test1_SeparateMethodNames() {
        System.out.println("### 테스트 1: 메서드 이름 분리 ###\n");

        SmartDocument doc = new SmartDocument("중요한 보고서");

        System.out.println("인쇄 포맷: " + doc.getPrintFormat());
        doc.print();

        System.out.println("\n화면 포맷: " + doc.getDisplayFormat());
        doc.display();

        System.out.println();
    }

    static void test2_GenericInterface() {
        System.out.println("### 테스트 2: 제네릭 인터페이스 ###\n");

        Report report = new Report("월간 실적 보고", "이번 달 매출은 전월 대비 20% 증가했습니다.");
        ReportFormatter formatter = new ReportFormatter();

        String formatted = formatter.format(report);
        System.out.println(formatted);

        System.out.println();
    }

    static void test3_DefaultMethodConflict() {
        System.out.println("### 테스트 3: default 메서드 충돌 해결 ###\n");

        DataManager manager = new DataManager("중요 데이터");

        System.out.println("1. 커스텀 save() 호출:");
        manager.save();

        System.out.println("\n2. Saveable의 default 메서드 호출:");
        manager.useSaveableDefault();

        System.out.println("\n3. Exportable의 default 메서드 호출:");
        manager.useExportableDefault();

        System.out.println("\n4. 각 인터페이스의 고유 메서드:");
        manager.saveToFile("data.txt");
        manager.exportToFormat("JSON");

        System.out.println();
    }

    static void test4_InterfaceHierarchy() {
        System.out.println("### 테스트 4: 인터페이스 계층 구조 ###\n");

        MultiProcessor processor = new MultiProcessor();

        System.out.println("통합 처리 실행:");
        processor.process();

        System.out.println("\n개별 기능:");
        processor.advancedProcess();
        processor.specialProcess();

        System.out.println();
    }
}
```

### 📚 배운 내용

1. **메서드 충돌 유형**
   - 같은 시그니처, 같은 반환 타입: ✅ OK (하나만 구현)
   - 같은 시그니처, 다른 반환 타입: ❌ 컴파일 에러
   - default 메서드 충돌: ⚠️ 명시적 오버라이드 필요

2. **해결 방법**
   - 메서드 이름을 명확하게 분리
   - 제네릭 사용으로 타입 안정성 확보
   - default 메서드는 명시적으로 오버라이드
   - `InterfaceName.super.method()` 로 특정 인터페이스의 default 메서드 호출

3. **베스트 프랙티스**
   - 인터페이스 설계 시 메서드 이름을 명확하게
   - 의미가 다른 메서드는 다른 이름 사용
   - default 메서드는 신중하게 사용
   - 문서화를 통해 의도를 명확히 전달

4. **실무 팁**
   - 여러 인터페이스를 구현할 때는 먼저 메서드 충돌 가능성 확인
   - IDE의 경고를 주의 깊게 확인
   - 충돌 발생 시 명시적으로 해결하여 의도를 명확히 표현

---

## 🎯 Part 2 핵심 정리

### 📌 기업 사례에서 배운 점

1. **Java Comparable/Comparator**
   - 단일 메서드 인터페이스의 강력함
   - 정렬 기준의 유연한 변경
   - 람다식과의 완벽한 조화

2. **JDBC**
   - 인터페이스 기반 설계의 교과서
   - 데이터베이스 독립성
   - 벤더별 자유로운 구현

3. **Spring Framework**
   - 계층 분리와 느슨한 결합
   - 의존성 주입 패턴
   - 테스트 용이성

### 📌 주니어 개발자가 주의할 점

1. **인터페이스는 직접 인스턴스화 불가**
   - 구현 클래스, 익명 클래스, 람다식 활용

2. **모든 메서드 구현 필수**
   - 인터페이스 분리 원칙 (ISP) 고려

3. **인터페이스 vs 추상 클래스**
   - is-a → 추상 클래스
   - can-do → 인터페이스

4. **메서드 충돌 해결**
   - 명시적 오버라이드
   - 명확한 메서드 이름 사용

---

다음 Part 3에서는 **실전 프로젝트**, **FAQ**, **면접 질문**을 다루겠습니다! 🚀