# 30장: 자동 설정 원리 - Spring Boot의 마법을 파헤치다

> **"자동으로 돌아가는 것처럼 보이지만, 그 안에는 정교한 메커니즘이 숨어있습니다"**

---

## 📋 학습 목표

이 장을 학습하면 다음을 할 수 있습니다:

- Spring Boot 자동 설정의 내부 동작 원리를 이해합니다
- @Conditional 애노테이션의 다양한 활용법을 익힙니다
- 커스텀 자동 설정을 직접 만들 수 있습니다
- 자동 설정 디버깅 및 문제 해결 방법을 습득합니다
- spring.factories와 AutoConfiguration.imports를 이해합니다

**예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐ (중고급)

---

## 🤔 왜 자동 설정 원리를 알아야 하는가?

### 문제 상황: 블랙박스의 함정

#### 문제 1: 예상치 못한 Bean 충돌

```java
// 개발자가 작성한 DataSource
@Configuration
public class MyConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();  // 내가 만든 DataSource
    }
}

// 문제 발생!
// Spring Boot도 DataSource를 자동으로 생성하려고 함
// → 어떤 Bean이 사용될까?
// → 예측 불가능한 동작
```

**개발자의 혼란:**
- "내가 만든 Bean이 무시당했어요"
- "왜 이 설정이 적용 안 되죠?"
- "자동 설정을 어떻게 끄나요?"

#### 문제 2: 디버깅 어려움

```
애플리케이션 시작 실패:
Error creating bean with name 'dataSource'

// 로그 100줄...
// 어디서 무엇이 잘못된 걸까?
// 자동 설정? 내 설정? 라이브러리 문제?
```

#### 문제 3: 성능 이슈

```java
// 필요 없는 자동 설정이 로딩되어 시작 시간 증가
// 예: MongoDB를 안 쓰는데 MongoDB 자동 설정이 실행됨
```

### 자동 설정 원리를 알면

```java
// ✅ 정확한 제어
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class  // 자동 설정 제외
})

// ✅ 조건부 Bean 생성
@Configuration
@ConditionalOnMissingBean(DataSource.class)  // 없을 때만 생성
public class MyConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();
    }
}

// ✅ 디버깅 능력
// --debug 옵션으로 어떤 자동 설정이 적용되었는지 확인
java -jar app.jar --debug
```

---

## 🌍 실생활 비유로 이해하는 자동 설정

### 비유 1: 스마트 온도 조절기

**전통 방식 (수동 설정):**
```
매일 아침 6시: 난방 22도로 설정
매일 오전 9시: 난방 18도로 낮춤
매일 오후 6시: 난방 23도로 올림
매일 밤 11시: 난방 20도로 낮춤
→ 매번 수동으로 조절
```

**자동 설정 (스마트 온도 조절기):**
```
센서가 감지:
- 사람이 있는가? → 난방 ON
- 밖 온도는? → 적정 온도 자동 계산
- 시간대는? → 수면/활동 모드 자동 전환
→ 조건에 따라 자동 조절
```

**Spring Boot 자동 설정:**
```java
@ConditionalOnClass(DataSource.class)  // DataSource 클래스 있으면
@ConditionalOnMissingBean  // DataSource Bean 없으면
public class DataSourceAutoConfiguration {
    @Bean
    public DataSource dataSource() {
        // 자동으로 DataSource 생성
    }
}
```

### 비유 2: 자동 주차 시스템

**수동 주차:**
```
1. 주차 공간 찾기
2. 각도 계산
3. 핸들 조작
4. 전진/후진 반복
5. 미세 조정
→ 운전자가 모든 것을 직접
```

**자동 주차:**
```
시스템이 판단:
- 주차 공간 크기 충분? → YES → 자동 주차 시작
- 주차 공간 크기 충분? → NO → "공간 부족" 알림
- 장애물 감지? → YES → 즉시 정지
→ 조건 판단 후 자동 실행
```

**@Conditional 동작:**
```java
@Configuration
@ConditionalOnClass(name = "javax.sql.DataSource")  // 공간 있나?
@ConditionalOnMissingBean(DataSource.class)  // 이미 주차된 차 없나?
public class AutoConfig {
    @Bean
    public DataSource dataSource() {
        return new HikariDataSource();  // 자동 주차
    }
}
```

### 비유 3: 식당 주방의 자동화

**전통 주방:**
```
주문: "파스타 1개"
→ 셰프가 직접:
   1. 냄비에 물 끓이기
   2. 면 삶기
   3. 소스 만들기
   4. 플레이팅
```

**자동화 주방:**
```
주문: "파스타 1개"
→ 시스템 판단:
   - 면 재고 있나? → YES → 자동 조리 시작
   - 파스타 소스 있나? → YES → 소스 준비
   - 토핑 있나? → NO → 기본 파스타만 제공
→ 조건에 따라 자동 처리
```

**spring.factories 메커니즘:**
```
META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

// 주방의 레시피북
DataSourceAutoConfiguration
JpaAutoConfiguration
WebMvcAutoConfiguration
// 필요한 것만 자동으로 실행
```

---

## 💡 자동 설정 핵심 개념

### 1️⃣ 초급: @EnableAutoConfiguration의 동작

#### 동작 흐름

```
애플리케이션 시작
     ↓
@SpringBootApplication 처리
     ↓
@EnableAutoConfiguration 활성화
     ↓
AutoConfigurationImportSelector 실행
     ↓
spring.factories 파일 읽기
     ↓
자동 설정 클래스 목록 로드
     ↓
@Conditional 조건 평가
     ↓
조건 만족하는 Bean만 생성
```

#### spring.factories 파일 구조

**Spring Boot 3.0 이전:**
```properties
# META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
```

**Spring Boot 3.0 이후:**
```
# META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration
```

#### 자동 설정 클래스 예시

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class,
          DataSourceInitializationConfiguration.class })
public class DataSourceAutoConfiguration {

    @Configuration(proxyBeanMethods = false)
    @Conditional(EmbeddedDatabaseCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import(EmbeddedDataSourceConfiguration.class)
    protected static class EmbeddedDatabaseConfiguration {
    }

    @Configuration(proxyBeanMethods = false)
    @Conditional(PooledDataSourceCondition.class)
    @ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
    @Import({ DataSourceConfiguration.Hikari.class,
              DataSourceConfiguration.Tomcat.class,
              DataSourceConfiguration.Dbcp2.class })
    protected static class PooledDataSourceConfiguration {
    }
}
```

### 2️⃣ 중급: @Conditional 애노테이션 완전 정복

#### 주요 @Conditional 애노테이션

| 애노테이션 | 조건 | 사용 예시 |
|----------|------|----------|
| `@ConditionalOnClass` | 클래스패스에 특정 클래스 존재 | `@ConditionalOnClass(DataSource.class)` |
| `@ConditionalOnMissingClass` | 클래스패스에 특정 클래스 없음 | `@ConditionalOnMissingClass("com.example.Custom")` |
| `@ConditionalOnBean` | 특정 타입의 Bean 존재 | `@ConditionalOnBean(DataSource.class)` |
| `@ConditionalOnMissingBean` | 특정 타입의 Bean 없음 | `@ConditionalOnMissingBean(DataSource.class)` |
| `@ConditionalOnProperty` | 프로퍼티가 특정 값 | `@ConditionalOnProperty(name="app.enabled", havingValue="true")` |
| `@ConditionalOnResource` | 특정 리소스 존재 | `@ConditionalOnResource(resources="classpath:config.yml")` |
| `@ConditionalOnWebApplication` | 웹 애플리케이션 | `@ConditionalOnWebApplication` |
| `@ConditionalOnExpression` | SpEL 표현식 | `@ConditionalOnExpression("${app.enabled:false}")` |

#### 실전 예제

**예제 1: 클래스 존재 여부**

```java
@Configuration
@ConditionalOnClass(name = "redis.clients.jedis.Jedis")
public class RedisAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public RedisTemplate<Object, Object> redisTemplate(
            RedisConnectionFactory connectionFactory) {
        RedisTemplate<Object, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        return template;
    }
}
```

**예제 2: Bean 존재 여부**

```java
@Configuration
public class DataSourceConfig {

    // 1순위: 개발자가 직접 만든 DataSource 사용
    // (이미 있으면 아래 Bean은 생성 안 됨)

    // 2순위: 자동 설정
    @Bean
    @ConditionalOnMissingBean(DataSource.class)
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
}
```

**예제 3: 프로퍼티 기반 조건**

```java
@Configuration
@ConditionalOnProperty(
    prefix = "app.cache",
    name = "enabled",
    havingValue = "true",
    matchIfMissing = false  // 프로퍼티 없으면 false
)
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users", "products");
    }
}
```

```yaml
# application.yml
app:
  cache:
    enabled: true  # 이 값이 true일 때만 CacheConfig 활성화
```

**예제 4: 복합 조건**

```java
@Configuration
@ConditionalOnClass(DataSource.class)
@ConditionalOnProperty(name = "spring.datasource.url")
public class DatabaseConfig {

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "app.database.pool", havingValue = "hikari")
    public DataSource hikariDataSource() {
        return new HikariDataSource();
    }

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnProperty(name = "app.database.pool", havingValue = "tomcat")
    public DataSource tomcatDataSource() {
        return new org.apache.tomcat.jdbc.pool.DataSource();
    }
}
```

### 3️⃣ 고급: 커스텀 자동 설정 만들기

#### 시나리오: 회사 공통 라이브러리 자동 설정

**요구사항:**
- 모든 프로젝트에서 사용하는 공통 기능 자동 설정
- API 클라이언트 자동 생성
- 로깅 설정 자동 적용

#### Step 1: 프로퍼티 클래스 작성

```java
package com.company.autoconfigure;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "company.api")
public class CompanyApiProperties {

    /**
     * API 서버 URL
     */
    private String baseUrl = "https://api.company.com";

    /**
     * 타임아웃 (ms)
     */
    private int timeout = 5000;

    /**
     * 재시도 횟수
     */
    private int retryCount = 3;

    /**
     * API 활성화 여부
     */
    private boolean enabled = true;

    // Getter, Setter
    public String getBaseUrl() { return baseUrl; }
    public void setBaseUrl(String baseUrl) { this.baseUrl = baseUrl; }
    public int getTimeout() { return timeout; }
    public void setTimeout(int timeout) { this.timeout = timeout; }
    public int getRetryCount() { return retryCount; }
    public void setRetryCount(int retryCount) { this.retryCount = retryCount; }
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}
```

#### Step 2: API 클라이언트 작성

```java
package com.company.autoconfigure;

import org.springframework.web.client.RestTemplate;

public class CompanyApiClient {

    private final RestTemplate restTemplate;
    private final CompanyApiProperties properties;

    public CompanyApiClient(RestTemplate restTemplate, CompanyApiProperties properties) {
        this.restTemplate = restTemplate;
        this.properties = properties;
    }

    public <T> T get(String path, Class<T> responseType) {
        String url = properties.getBaseUrl() + path;
        return restTemplate.getForObject(url, responseType);
    }

    public <T> T post(String path, Object request, Class<T> responseType) {
        String url = properties.getBaseUrl() + path;
        return restTemplate.postForObject(url, request, responseType);
    }
}
```

#### Step 3: 자동 설정 클래스 작성

```java
package com.company.autoconfigure;

import org.springframework.boot.autoconfigure.AutoConfiguration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@AutoConfiguration
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnProperty(
    prefix = "company.api",
    name = "enabled",
    havingValue = "true",
    matchIfMissing = true
)
@EnableConfigurationProperties(CompanyApiProperties.class)
public class CompanyApiAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public RestTemplate companyRestTemplate(CompanyApiProperties properties) {
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setRequestFactory(clientHttpRequestFactory(properties));
        return restTemplate;
    }

    private ClientHttpRequestFactory clientHttpRequestFactory(CompanyApiProperties properties) {
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(properties.getTimeout());
        factory.setReadTimeout(properties.getTimeout());
        return factory;
    }

    @Bean
    @ConditionalOnMissingBean
    public CompanyApiClient companyApiClient(
            RestTemplate restTemplate,
            CompanyApiProperties properties) {
        return new CompanyApiClient(restTemplate, properties);
    }
}
```

#### Step 4: AutoConfiguration.imports 파일 생성

```
# src/main/resources/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.company.autoconfigure.CompanyApiAutoConfiguration
```

#### Step 5: 사용하기

**1. 라이브러리 배포**
```gradle
// company-spring-boot-starter 프로젝트
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.springframework.boot:spring-boot-starter-web'
}
```

**2. 다른 프로젝트에서 사용**
```gradle
// 실제 애플리케이션 프로젝트
dependencies {
    implementation 'com.company:company-spring-boot-starter:1.0.0'
}
```

```yaml
# application.yml
company:
  api:
    base-url: https://api.company.com
    timeout: 10000
    retry-count: 5
    enabled: true
```

```java
@RestController
@RequiredArgsConstructor
public class MyController {

    private final CompanyApiClient apiClient;  // 자동 주입!

    @GetMapping("/data")
    public MyData getData() {
        return apiClient.get("/v1/data", MyData.class);
    }
}
```

---

## 🛠️ 기본 실습

### 실습 1: 자동 설정 디버깅

#### Step 1: 디버그 모드 활성화

```yaml
# application.yml
debug: true
```

또는

```bash
java -jar app.jar --debug
```

#### Step 2: 로그 확인

```
============================
CONDITIONS EVALUATION REPORT
============================

Positive matches:
-----------------

DataSourceAutoConfiguration matched:
   - @ConditionalOnClass found required classes 'javax.sql.DataSource' (OnClassCondition)

JpaRepositoriesAutoConfiguration matched:
   - @ConditionalOnClass found required class 'org.springframework.data.jpa.repository.JpaRepository' (OnClassCondition)

Negative matches:
-----------------

MongoAutoConfiguration:
   Did not match:
      - @ConditionalOnClass did not find required class 'com.mongodb.client.MongoClient' (OnClassCondition)

RedisAutoConfiguration:
   Did not match:
      - @ConditionalOnClass did not find required class 'org.springframework.data.redis.core.RedisOperations' (OnClassCondition)
```

#### Step 3: 특정 자동 설정 제외

```java
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    HibernateJpaAutoConfiguration.class
})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

또는

```yaml
spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

---

### 실습 2: 조건부 Bean 생성

```java
@Configuration
public class ConditionalConfig {

    // 1. 개발 환경에서만 H2 콘솔 활성화
    @Bean
    @Profile("dev")
    @ConditionalOnClass(name = "org.h2.server.web.WebServlet")
    public ServletRegistrationBean<WebServlet> h2Console() {
        String path = "/h2-console";
        WebServlet servlet = new WebServlet();
        ServletRegistrationBean<WebServlet> registration =
            new ServletRegistrationBean<>(servlet, path + "/*");
        registration.setLoadOnStartup(1);
        return registration;
    }

    // 2. Redis가 있을 때만 캐시 매니저 생성
    @Bean
    @ConditionalOnClass(RedisConnectionFactory.class)
    @ConditionalOnMissingBean(CacheManager.class)
    public CacheManager redisCacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10));

        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }

    // 3. 프로퍼티 기반 조건
    @Bean
    @ConditionalOnProperty(name = "app.feature.new-ui", havingValue = "true")
    public NewUiService newUiService() {
        return new NewUiService();
    }

    @Bean
    @ConditionalOnProperty(name = "app.feature.new-ui", havingValue = "false", matchIfMissing = true)
    public OldUiService oldUiService() {
        return new OldUiService();
    }
}
```

---

### 실습 3: 커스텀 Condition 만들기

```java
// 1. Condition 인터페이스 구현
public class LinuxCondition implements Condition {

    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String osName = context.getEnvironment().getProperty("os.name");
        return osName != null && osName.toLowerCase().contains("linux");
    }
}

// 2. 사용
@Configuration
public class OsSpecificConfig {

    @Bean
    @Conditional(LinuxCondition.class)
    public CommandLineRunner linuxRunner() {
        return args -> System.out.println("Running on Linux!");
    }

    @Bean
    @ConditionalOnProperty(name = "os.name", havingValue = "Windows")
    public CommandLineRunner windowsRunner() {
        return args -> System.out.println("Running on Windows!");
    }
}
```

---

## 👨‍💻 주니어 개발자 실전 시나리오

### 시나리오: "자동 설정 충돌 해결"

**상황:**
```
프로젝트에 Spring Security 의존성 추가 후
모든 API가 401 Unauthorized 에러 발생

원인: Spring Security 자동 설정이 활성화되어
      모든 엔드포인트에 인증 요구
```

#### 해결 과정

**1단계: 문제 파악**
```bash
# 디버그 모드로 실행
java -jar app.jar --debug | grep Security

# 결과
SecurityAutoConfiguration matched:
   - @ConditionalOnClass found required class 'org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration'
```

**2단계: 자동 설정 확인**
```java
// SecurityAutoConfiguration이 자동으로 생성한 것
@Bean
@ConditionalOnMissingBean
public SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) {
    http.authorizeHttpRequests(auth -> auth.anyRequest().authenticated());
    // 모든 요청에 인증 필요!
    return http.build();
}
```

**3단계: 해결 방법 선택**

**방법 1: 자동 설정 제외 (비추천)**
```java
@SpringBootApplication(exclude = SecurityAutoConfiguration.class)
```

**방법 2: 커스텀 설정으로 오버라이드 (권장)**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()  // 공개 API
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .csrf(csrf -> csrf.disable())  // 개발 단계에서만
            .formLogin(form -> form.disable());

        return http.build();
    }
}
```

**결과:**
- 공개 API는 인증 없이 접근 가능
- 관리자 API는 ADMIN 권한 필요
- 나머지는 인증 필요

---

## 🏢 기업 사례: Spotify

### 배경

Spotify는 수천 개의 마이크로서비스를 운영하며, 공통 기능을 자동 설정으로 표준화했습니다.

**요구사항:**
- 모든 서비스에 공통 로깅, 메트릭, 트레이싱 적용
- 개발자가 별도 설정 없이 사용 가능
- 팀별 커스터마이징 허용

### 해결책: 커스텀 스타터

```java
// spotify-spring-boot-starter
@AutoConfiguration
@ConditionalOnProperty(name = "spotify.features.enabled", havingValue = "true", matchIfMissing = true)
@EnableConfigurationProperties(SpotifyProperties.class)
public class SpotifyAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    public SpotifyMetricsCollector metricsCollector() {
        return new SpotifyMetricsCollector();
    }

    @Bean
    @ConditionalOnClass(name = "io.opentelemetry.api.trace.Tracer")
    public SpotifyTracingInterceptor tracingInterceptor() {
        return new SpotifyTracingInterceptor();
    }

    @Bean
    @ConditionalOnProperty(name = "spotify.logging.enhanced", havingValue = "true")
    public EnhancedLoggingAspect loggingAspect() {
        return new EnhancedLoggingAspect();
    }
}
```

**효과:**
- 신규 서비스 생성 시간 50% 단축
- 표준화로 유지보수성 향상
- 온보딩 시간 70% 감소

---

## ❓ FAQ

### Q1. 자동 설정이 적용되지 않아요

**A:** 조건을 확인하세요.

```bash
# 디버그 모드로 확인
java -jar app.jar --debug | grep -A 5 "YourAutoConfiguration"

# Negative matches 섹션 확인
Negative matches:
-----------------
YourAutoConfiguration:
   Did not match:
      - @ConditionalOnClass did not find required class 'com.example.Required'
```

**해결:**
1. 필요한 의존성 추가
2. 프로퍼티 값 확인
3. @ComponentScan 범위 확인

### Q2. 내 Bean이 자동 설정 Bean에 의해 무시당해요

**A:** Bean 생성 순서 문제입니다.

```java
// ❌ 문제 상황
@Configuration
public class MyConfig {
    @Bean
    public DataSource myDataSource() {
        // 자동 설정이 먼저 실행되어 이 Bean이 무시됨
    }
}

// ✅ 해결 방법 1: @Primary
@Bean
@Primary
public DataSource myDataSource() {
    return new HikariDataSource();
}

// ✅ 해결 방법 2: 자동 설정 제외
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
```

### Q3. 자동 설정의 순서를 제어할 수 있나요?

**A:** `@AutoConfigureBefore`, `@AutoConfigureAfter` 사용

```java
@AutoConfiguration
@AutoConfigureBefore(DataSourceAutoConfiguration.class)
public class MyAutoConfiguration {
    // DataSourceAutoConfiguration 보다 먼저 실행
}

@AutoConfiguration
@AutoConfigureAfter(RedisAutoConfiguration.class)
public class CacheAutoConfiguration {
    // RedisAutoConfiguration 이후 실행
}
```

### Q4. @ConditionalOnMissingBean은 정확히 언제 평가되나요?

**A:** 설정 클래스 처리 시점에 평가됩니다.

```java
@Configuration
public class Config1 {
    @Bean
    @ConditionalOnMissingBean
    public MyService myService() {
        return new MyServiceImpl1();
    }
}

@Configuration
@DependsOn("config1")  // 순서 보장 안 됨!
public class Config2 {
    @Bean
    @ConditionalOnMissingBean
    public MyService myService() {
        return new MyServiceImpl2();  // 둘 중 하나만 생성됨
    }
}
```

**해결:**
```java
// 한 곳에서 관리
@Configuration
public class UnifiedConfig {

    @Bean
    @ConditionalOnProperty(name = "my.service.type", havingValue = "impl1")
    public MyService myService1() {
        return new MyServiceImpl1();
    }

    @Bean
    @ConditionalOnProperty(name = "my.service.type", havingValue = "impl2", matchIfMissing = true)
    public MyService myService2() {
        return new MyServiceImpl2();
    }
}
```

### Q5. 성능을 위해 자동 설정을 최적화하려면?

**A:** 불필요한 자동 설정 제외

```java
@SpringBootApplication(exclude = {
    MongoAutoConfiguration.class,        // MongoDB 안 쓰면
    RedisAutoConfiguration.class,        // Redis 안 쓰면
    KafkaAutoConfiguration.class,        // Kafka 안 쓰면
    ElasticsearchDataAutoConfiguration.class  // Elasticsearch 안 쓰면
})
```

```yaml
# 또는 application.yml
spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration
      - org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration
```

---

## 💼 면접 질문 TOP 5

### ⭐ 초급 1: Spring Boot 자동 설정은 어떻게 동작하나요?

**답변:**

```
1. @EnableAutoConfiguration 처리
2. AutoConfigurationImportSelector 실행
3. spring.factories 또는 AutoConfiguration.imports 읽기
4. 자동 설정 클래스 로드
5. @Conditional 조건 평가
6. 조건 만족 시 Bean 생성
```

### ⭐ 초급 2: @ConditionalOnMissingBean의 용도는?

**답변:**
개발자가 직접 Bean을 정의하지 않았을 때만 자동으로 생성하는 조건입니다.

```java
@Bean
@ConditionalOnMissingBean(DataSource.class)
public DataSource dataSource() {
    // 개발자가 DataSource를 만들지 않았을 때만 실행
    return DataSourceBuilder.create().build();
}
```

### ⭐⭐ 중급 1: 자동 설정 클래스를 만드는 방법은?

**답변:**

```java
// 1. 자동 설정 클래스 작성
@AutoConfiguration
@ConditionalOnClass(MyService.class)
@EnableConfigurationProperties(MyProperties.class)
public class MyAutoConfiguration {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}

// 2. AutoConfiguration.imports 파일 생성
// META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports
com.example.MyAutoConfiguration
```

### ⭐⭐ 중급 2: 여러 @Conditional을 조합하면 AND인가 OR인가?

**답변:**
**AND 조건**입니다. 모든 조건이 만족해야 Bean이 생성됩니다.

```java
@Configuration
@ConditionalOnClass(DataSource.class)         // AND
@ConditionalOnProperty(name = "app.enabled")  // AND
@ConditionalOnMissingBean(DataSource.class)   // AND
public class MyConfig {
    // 3개 조건 모두 만족해야 활성화
}
```

### ⭐⭐ 중급 3: 자동 설정 디버깅 방법은?

**답변:**

```bash
# 1. 디버그 모드
java -jar app.jar --debug

# 2. Actuator 사용
# build.gradle
implementation 'org.springframework.boot:spring-boot-starter-actuator'

# 확인
curl http://localhost:8080/actuator/conditions

# 3. 로그 레벨 조정
logging:
  level:
    org.springframework.boot.autoconfigure: DEBUG
```

---

## 🎯 다음 단계

자동 설정 원리를 마쳤다면:

1. **31장: 프로퍼티 관리** - 외부 설정 완벽 이해
2. **32장: Actuator** - 운영 모니터링
3. **커스텀 스타터 개발** - 사내 표준 라이브러리 제작

---

**🎓 학습 완료 체크리스트:**

- [ ] @EnableAutoConfiguration 동작 원리 이해
- [ ] spring.factories 파일 역할 파악
- [ ] @Conditional 애노테이션 활용
- [ ] 커스텀 자동 설정 클래스 작성
- [ ] 자동 설정 디버깅 방법 습득
- [ ] Bean 충돌 문제 해결 능력

**다음 장에서는 프로퍼티 관리와 외부 설정을 마스터합니다!** 🚀
