# 📝 Chapter 23-2: 예외 처리 (Exception Handling) Part 2

## 🎯 학습 목표
- 실제 기업에서 예외 처리를 어떻게 활용하는지 학습합니다
- Spring Framework의 예외 처리 패턴을 이해합니다
- Database Transaction Rollback 메커니즘을 학습합니다
- 주니어 개발자가 자주 실수하는 예외 처리 방법을 배웁니다
- 실전에서 마주칠 수 있는 문제와 해결 방법을 익힙니다

---

## 🏢 기업 사례 연구

---

## 📘 Case Study 1: Spring Framework - 계층별 예외 처리

### 배경
**Naver Pay** 개발 팀은 결제 시스템에서 발생하는 다양한 예외를 계층별로 체계적으로 처리해야 했습니다.
- Controller: HTTP 상태 코드와 사용자 친화적 메시지
- Service: 비즈니스 로직 예외
- Repository: 데이터베이스 예외

**해결책**: Custom Exception과 @ControllerAdvice를 활용한 전역 예외 처리

### 실제 코드

```java
// 📁 SpringExceptionHandlingExample.java

import java.util.*;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ Custom Exception 계층 구조
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

// Base Exception
class BusinessException extends RuntimeException {
    private final String errorCode;

    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() { return errorCode; }
}

// Domain-specific Exceptions
class InsufficientBalanceException extends BusinessException {
    public InsufficientBalanceException(int balance, int amount) {
        super("INSUFFICIENT_BALANCE",
              "잔액 부족: 현재 " + balance + "원, 필요 " + amount + "원");
    }
}

class UserNotFoundException extends BusinessException {
    public UserNotFoundException(Long userId) {
        super("USER_NOT_FOUND", "사용자를 찾을 수 없습니다: ID=" + userId);
    }
}

class InvalidPaymentMethodException extends BusinessException {
    public InvalidPaymentMethodException(String method) {
        super("INVALID_PAYMENT_METHOD", "유효하지 않은 결제 수단: " + method);
    }
}

class DuplicateTransactionException extends BusinessException {
    public DuplicateTransactionException(String transactionId) {
        super("DUPLICATE_TRANSACTION", "중복된 거래입니다: " + transactionId);
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ Domain Models
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class User {
    private Long id;
    private String name;
    private int balance;

    public User(Long id, String name, int balance) {
        this.id = id;
        this.name = name;
        this.balance = balance;
    }

    public Long getId() { return id; }
    public String getName() { return name; }
    public int getBalance() { return balance; }

    public void withdraw(int amount) {
        if (balance < amount) {
            throw new InsufficientBalanceException(balance, amount);
        }
        balance -= amount;
    }
}

class Payment {
    private String id;
    private Long userId;
    private int amount;
    private String method;
    private String status;

    public Payment(String id, Long userId, int amount, String method) {
        this.id = id;
        this.userId = userId;
        this.amount = amount;
        this.method = method;
        this.status = "PENDING";
    }

    public String getId() { return id; }
    public Long getUserId() { return userId; }
    public int getAmount() { return amount; }
    public String getMethod() { return method; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    @Override
    public String toString() {
        return String.format("Payment{id='%s', userId=%d, amount=%d, method='%s', status='%s'}",
                           id, userId, amount, method, status);
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3️⃣ Repository Layer
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class UserRepository {
    private static Map<Long, User> users = new HashMap<>();

    static {
        users.put(1L, new User(1L, "김철수", 100000));
        users.put(2L, new User(2L, "이영희", 50000));
    }

    public User findById(Long userId) {
        User user = users.get(userId);
        if (user == null) {
            throw new UserNotFoundException(userId);
        }
        return user;
    }
}

class PaymentRepository {
    private static Map<String, Payment> payments = new HashMap<>();

    public void save(Payment payment) {
        if (payments.containsKey(payment.getId())) {
            throw new DuplicateTransactionException(payment.getId());
        }
        payments.put(payment.getId(), payment);
        System.out.println("  💾 [Repository] 결제 정보 저장: " + payment.getId());
    }

    public Payment findById(String paymentId) {
        return payments.get(paymentId);
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 4️⃣ Service Layer
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class PaymentService {
    private final UserRepository userRepository = new UserRepository();
    private final PaymentRepository paymentRepository = new PaymentRepository();

    private static final Set<String> VALID_METHODS = Set.of("CARD", "BANK", "KAKAO_PAY", "NAVER_PAY");

    public Payment processPayment(String paymentId, Long userId, int amount, String method) {
        System.out.println("\n💳 [Service] 결제 처리 시작");

        // 1. 결제 수단 검증
        if (!VALID_METHODS.contains(method)) {
            throw new InvalidPaymentMethodException(method);
        }

        // 2. 사용자 조회
        User user = userRepository.findById(userId);
        System.out.println("  ✅ 사용자 조회 완료: " + user.getName());

        // 3. 잔액 차감
        user.withdraw(amount);
        System.out.println("  ✅ 잔액 차감 완료: " + user.getBalance() + "원 남음");

        // 4. 결제 정보 저장
        Payment payment = new Payment(paymentId, userId, amount, method);
        paymentRepository.save(payment);

        // 5. 결제 완료 처리
        payment.setStatus("COMPLETED");
        System.out.println("  ✅ 결제 완료: " + payment);

        return payment;
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 5️⃣ Controller Layer (전역 예외 처리)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class ErrorResponse {
    private final String errorCode;
    private final String message;
    private final int httpStatus;

    public ErrorResponse(String errorCode, String message, int httpStatus) {
        this.errorCode = errorCode;
        this.message = message;
        this.httpStatus = httpStatus;
    }

    @Override
    public String toString() {
        return String.format("ErrorResponse{errorCode='%s', message='%s', httpStatus=%d}",
                           errorCode, message, httpStatus);
    }
}

class GlobalExceptionHandler {

    public ErrorResponse handleBusinessException(BusinessException e) {
        System.out.println("\n🛡️ [GlobalExceptionHandler] BusinessException 처리");

        int httpStatus = switch (e.getErrorCode()) {
            case "USER_NOT_FOUND" -> 404;
            case "INSUFFICIENT_BALANCE" -> 400;
            case "INVALID_PAYMENT_METHOD" -> 400;
            case "DUPLICATE_TRANSACTION" -> 409;
            default -> 500;
        };

        ErrorResponse response = new ErrorResponse(e.getErrorCode(), e.getMessage(), httpStatus);
        System.out.println("  📤 응답: " + response);
        return response;
    }

    public ErrorResponse handleUnexpectedException(Exception e) {
        System.out.println("\n🛡️ [GlobalExceptionHandler] 예상치 못한 예외 처리");
        ErrorResponse response = new ErrorResponse("INTERNAL_SERVER_ERROR",
                                                   "서버 오류가 발생했습니다", 500);
        System.out.println("  📤 응답: " + response);
        return response;
    }
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 6️⃣ 실행 및 테스트
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

public class SpringExceptionHandlingExample {
    public static void main(String[] args) {
        System.out.println("=== Spring 계층별 예외 처리 - Naver Pay 사례 ===\n");

        PaymentService paymentService = new PaymentService();
        GlobalExceptionHandler exceptionHandler = new GlobalExceptionHandler();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 1: 정상 처리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(60));
        System.out.println("Case 1: 정상 결제");
        System.out.println("=".repeat(60));

        try {
            Payment payment = paymentService.processPayment("PAY-001", 1L, 30000, "CARD");
            System.out.println("\n✅ 결제 성공: " + payment);
        } catch (BusinessException e) {
            exceptionHandler.handleBusinessException(e);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 2: 잔액 부족
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("Case 2: 잔액 부족");
        System.out.println("=".repeat(60));

        try {
            paymentService.processPayment("PAY-002", 2L, 100000, "CARD");
        } catch (BusinessException e) {
            exceptionHandler.handleBusinessException(e);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 3: 존재하지 않는 사용자
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("Case 3: 존재하지 않는 사용자");
        System.out.println("=".repeat(60));

        try {
            paymentService.processPayment("PAY-003", 999L, 10000, "CARD");
        } catch (BusinessException e) {
            exceptionHandler.handleBusinessException(e);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Case 4: 잘못된 결제 수단
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("Case 4: 잘못된 결제 수단");
        System.out.println("=".repeat(60));

        try {
            paymentService.processPayment("PAY-004", 1L, 10000, "BITCOIN");
        } catch (BusinessException e) {
            exceptionHandler.handleBusinessException(e);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("\n💡 계층별 예외 처리 패턴:");

        System.out.println("\n1️⃣ Repository Layer:");
        System.out.println("   - 데이터 접근 예외");
        System.out.println("   - UserNotFoundException, DataAccessException");

        System.out.println("\n2️⃣ Service Layer:");
        System.out.println("   - 비즈니스 로직 예외");
        System.out.println("   - InsufficientBalanceException, InvalidPaymentMethodException");

        System.out.println("\n3️⃣ Controller Layer:");
        System.out.println("   - HTTP 응답 변환");
        System.out.println("   - @ControllerAdvice로 전역 예외 처리");

        System.out.println("\n🎯 장점:");
        System.out.println("   ✅ 일관된 에러 응답 형식");
        System.out.println("   ✅ 비즈니스 예외와 기술 예외 분리");
        System.out.println("   ✅ 중복 코드 제거 (전역 처리)");
        System.out.println("   ✅ 사용자 친화적 메시지");
    }
}
```

**실행 결과:**
```
=== Spring 계층별 예외 처리 - Naver Pay 사례 ===

============================================================
Case 1: 정상 결제
============================================================

💳 [Service] 결제 처리 시작
  ✅ 사용자 조회 완료: 김철수
  ✅ 잔액 차감 완료: 70000원 남음
  💾 [Repository] 결제 정보 저장: PAY-001
  ✅ 결제 완료: Payment{id='PAY-001', userId=1, amount=30000, method='CARD', status='COMPLETED'}

✅ 결제 성공: Payment{id='PAY-001', userId=1, amount=30000, method='CARD', status='COMPLETED'}

============================================================
Case 2: 잔액 부족
============================================================

💳 [Service] 결제 처리 시작
  ✅ 사용자 조회 완료: 이영희

🛡️ [GlobalExceptionHandler] BusinessException 처리
  📤 응답: ErrorResponse{errorCode='INSUFFICIENT_BALANCE', message='잔액 부족: 현재 50000원, 필요 100000원', httpStatus=400}

============================================================
Case 3: 존재하지 않는 사용자
============================================================

💳 [Service] 결제 처리 시작

🛡️ [GlobalExceptionHandler] BusinessException 처리
  📤 응답: ErrorResponse{errorCode='USER_NOT_FOUND', message='사용자를 찾을 수 없습니다: ID=999', httpStatus=404}

============================================================
Case 4: 잘못된 결제 수단
============================================================

💳 [Service] 결제 처리 시작

🛡️ [GlobalExceptionHandler] BusinessException 처리
  📤 응답: ErrorResponse{errorCode='INVALID_PAYMENT_METHOD', message='유효하지 않은 결제 수단: BITCOIN', httpStatus=400}

============================================================

💡 계층별 예외 처리 패턴:

1️⃣ Repository Layer:
   - 데이터 접근 예외
   - UserNotFoundException, DataAccessException

2️⃣ Service Layer:
   - 비즈니스 로직 예외
   - InsufficientBalanceException, InvalidPaymentMethodException

3️⃣ Controller Layer:
   - HTTP 응답 변환
   - @ControllerAdvice로 전역 예외 처리

🎯 장점:
   ✅ 일관된 에러 응답 형식
   ✅ 비즈니스 예외와 기술 예외 분리
   ✅ 중복 코드 제거 (전역 처리)
   ✅ 사용자 친화적 메시지
```

---

## 📗 Case Study 2: Database Transaction - Rollback 메커니즘

### 배경
**카카오뱅크** 개발 팀은 계좌 이체 시 예외 발생 시 트랜잭션을 롤백해야 했습니다.
한 계좌에서 출금했는데 입금에 실패하면 데이터 정합성이 깨집니다.

**해결책**: try-catch와 Rollback 메커니즘으로 원자성(Atomicity) 보장

### 실제 코드

```java
// 📁 TransactionRollbackExample.java

import java.util.*;

class Account {
    private String accountNumber;
    private String owner;
    private int balance;

    public Account(String accountNumber, String owner, int balance) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.balance = balance;
    }

    public String getAccountNumber() { return accountNumber; }
    public String getOwner() { return owner; }
    public int getBalance() { return balance; }

    public void withdraw(int amount) throws InsufficientBalanceException {
        if (balance < amount) {
            throw new InsufficientBalanceException(accountNumber, balance, amount);
        }
        balance -= amount;
    }

    public void deposit(int amount) {
        balance += amount;
    }

    @Override
    public String toString() {
        return String.format("Account{%s, %s, %,d원}", accountNumber, owner, balance);
    }
}

class TransferException extends Exception {
    public TransferException(String message, Throwable cause) {
        super(message, cause);
    }
}

class InsufficientBalanceException extends Exception {
    public InsufficientBalanceException(String accountNumber, int balance, int amount) {
        super(String.format("잔액 부족 [%s]: 현재 %,d원, 요청 %,d원",
                          accountNumber, balance, amount));
    }
}

class AccountService {
    private Map<String, Account> accounts = new HashMap<>();

    public AccountService() {
        accounts.put("1001", new Account("1001", "김철수", 1000000));
        accounts.put("1002", new Account("1002", "이영희", 500000));
        accounts.put("1003", new Account("1003", "박민수", 0));  // 잔액 0원
    }

    public Account getAccount(String accountNumber) {
        return accounts.get(accountNumber);
    }

    // ✅ 트랜잭션 + 롤백 메커니즘
    public void transfer(String fromAccount, String toAccount, int amount) throws TransferException {
        System.out.println("\n💸 [Transaction Start] 계좌 이체 시작");
        System.out.println("  출금 계좌: " + fromAccount);
        System.out.println("  입금 계좌: " + toAccount);
        System.out.println("  금액: " + amount + "원");

        Account from = getAccount(fromAccount);
        Account to = getAccount(toAccount);

        if (from == null || to == null) {
            throw new TransferException("계좌를 찾을 수 없습니다", null);
        }

        // 이체 전 잔액 저장 (롤백용)
        int originalFromBalance = from.getBalance();
        int originalToBalance = to.getBalance();

        System.out.println("\n  📊 이체 전 잔액:");
        System.out.println("    " + from);
        System.out.println("    " + to);

        try {
            // 1단계: 출금
            System.out.println("\n  1️⃣ 출금 처리 중...");
            from.withdraw(amount);
            System.out.println("    ✅ 출금 완료: " + from.getBalance() + "원 남음");

            // 2단계: 입금 (시뮬레이션: 랜덤 실패)
            System.out.println("\n  2️⃣ 입금 처리 중...");

            // 30% 확률로 입금 실패 시뮬레이션
            if (Math.random() < 0.3) {
                throw new RuntimeException("네트워크 오류: 입금 처리 실패");
            }

            to.deposit(amount);
            System.out.println("    ✅ 입금 완료: " + to.getBalance() + "원");

            // 트랜잭션 커밋
            System.out.println("\n✅ [Transaction Commit] 이체 성공!");
            System.out.println("  📊 이체 후 잔액:");
            System.out.println("    " + from);
            System.out.println("    " + to);

        } catch (Exception e) {
            // ❌ 롤백 수행
            System.out.println("\n❌ [Transaction Rollback] 예외 발생: " + e.getMessage());
            System.out.println("  🔄 롤백 시작...");

            // 원래 잔액으로 복구
            from.deposit(from.getBalance() - originalFromBalance < 0 ?
                        originalFromBalance - from.getBalance() : 0);
            to.deposit(to.getBalance() - originalToBalance < 0 ?
                      originalToBalance - to.getBalance() : 0);

            System.out.println("  ✅ 롤백 완료");
            System.out.println("  📊 롤백 후 잔액:");
            System.out.println("    " + from);
            System.out.println("    " + to);

            throw new TransferException("이체 실패", e);
        }
    }
}

public class TransactionRollbackExample {
    public static void main(String[] args) {
        System.out.println("=== Transaction Rollback - 카카오뱅크 사례 ===\n");

        AccountService service = new AccountService();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오: 여러 번 이체 시도 (일부 성공, 일부 실패)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(60));
        System.out.println("시나리오: 여러 번 이체 시도 (롤백 메커니즘 확인)");
        System.out.println("=".repeat(60));

        for (int i = 1; i <= 3; i++) {
            System.out.println("\n" + "=".repeat(60));
            System.out.println("이체 시도 #" + i);
            System.out.println("=".repeat(60));

            try {
                service.transfer("1001", "1002", 100000);
            } catch (TransferException e) {
                System.out.println("\n⚠️ 최종 결과: " + e.getMessage());
            }

            try {
                Thread.sleep(1000);  // 가독성을 위한 지연
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(60));
        System.out.println("=".repeat(60));
        System.out.println("\n💡 Transaction Rollback 핵심:");

        System.out.println("\n1️⃣ ACID 원칙:");
        System.out.println("   - Atomicity (원자성): 전부 성공 또는 전부 실패");
        System.out.println("   - Consistency (일관성): 데이터 정합성 유지");
        System.out.println("   - Isolation (격리성): 트랜잭션 간 독립");
        System.out.println("   - Durability (영속성): 커밋 후 영구 저장");

        System.out.println("\n2️⃣ 롤백 시나리오:");
        System.out.println("   - 출금 성공 → 입금 실패 → 출금 취소 (롤백)");
        System.out.println("   - 데이터베이스 연결 끊김");
        System.out.println("   - 비즈니스 규칙 위반");

        System.out.println("\n3️⃣ 구현 방법:");
        System.out.println("   - try-catch로 예외 감지");
        System.out.println("   - catch 블록에서 롤백 수행");
        System.out.println("   - 원래 상태로 복구");

        System.out.println("\n4️⃣ 실무 활용:");
        System.out.println("   - @Transactional (Spring)");
        System.out.println("   - Connection.rollback() (JDBC)");
        System.out.println("   - EntityManager.getTransaction().rollback() (JPA)");
    }
}
```

**실행 결과 (예시):**
```
=== Transaction Rollback - 카카오뱅크 사례 ===

============================================================
시나리오: 여러 번 이체 시도 (롤백 메커니즘 확인)
============================================================

============================================================
이체 시도 #1
============================================================

💸 [Transaction Start] 계좌 이체 시작
  출금 계좌: 1001
  입금 계좌: 1002
  금액: 100000원

  📊 이체 전 잔액:
    Account{1001, 김철수, 1,000,000원}
    Account{1002, 이영희, 500,000원}

  1️⃣ 출금 처리 중...
    ✅ 출금 완료: 900000원 남음

  2️⃣ 입금 처리 중...
    ✅ 입금 완료: 600000원

✅ [Transaction Commit] 이체 성공!
  📊 이체 후 잔액:
    Account{1001, 김철수, 900,000원}
    Account{1002, 이영희, 600,000원}

============================================================
이체 시도 #2
============================================================

💸 [Transaction Start] 계좌 이체 시작
  출금 계좌: 1001
  입금 계좌: 1002
  금액: 100000원

  📊 이체 전 잔액:
    Account{1001, 김철수, 900,000원}
    Account{1002, 이영희, 600,000원}

  1️⃣ 출금 처리 중...
    ✅ 출금 완료: 800000원 남음

  2️⃣ 입금 처리 중...

❌ [Transaction Rollback] 예외 발생: 네트워크 오류: 입금 처리 실패
  🔄 롤백 시작...
  ✅ 롤백 완료
  📊 롤백 후 잔액:
    Account{1001, 김철수, 900,000원}
    Account{1002, 이영희, 600,000원}

⚠️ 최종 결과: 이체 실패

============================================================
이체 시도 #3
============================================================

💸 [Transaction Start] 계좌 이체 시작
  출금 계좌: 1001
  입금 계좌: 1002
  금액: 100000원

  📊 이체 전 잔액:
    Account{1001, 김철수, 900,000원}
    Account{1002, 이영희, 600,000원}

  1️⃣ 출금 처리 중...
    ✅ 출금 완료: 800000원 남음

  2️⃣ 입금 처리 중...
    ✅ 입금 완료: 700000원

✅ [Transaction Commit] 이체 성공!
  📊 이체 후 잔액:
    Account{1001, 김철수, 800,000원}
    Account{1002, 이영희, 700,000원}

============================================================
============================================================

💡 Transaction Rollback 핵심:

1️⃣ ACID 원칙:
   - Atomicity (원자성): 전부 성공 또는 전부 실패
   - Consistency (일관성): 데이터 정합성 유지
   - Isolation (격리성): 트랜잭션 간 독립
   - Durability (영속성): 커밋 후 영구 저장

2️⃣ 롤백 시나리오:
   - 출금 성공 → 입금 실패 → 출금 취소 (롤백)
   - 데이터베이스 연결 끊김
   - 비즈니스 규칙 위반

3️⃣ 구현 방법:
   - try-catch로 예외 감지
   - catch 블록에서 롤백 수행
   - 원래 상태로 복구

4️⃣ 실무 활용:
   - @Transactional (Spring)
   - Connection.rollback() (JDBC)
   - EntityManager.getTransaction().rollback() (JPA)
```

---

## 📙 Case Study 3: Retry 메커니즘 - 일시적 오류 대응

### 배경
**쿠팡** 주문 시스템에서 외부 결제 API 호출 시 일시적인 네트워크 오류가 발생할 수 있습니다.
한 번 실패했다고 포기하면 사용자 경험이 나빠집니다.

**해결책**: Retry 메커니즘으로 일시적 오류를 극복

### 실제 코드

```java
// 📁 RetryMechanismExample.java

import java.util.Random;

class NetworkException extends Exception {
    public NetworkException(String message) {
        super(message);
    }
}

class PaymentGateway {
    private Random random = new Random();
    private int attemptCount = 0;

    // 시뮬레이션: 70% 확률로 성공
    public String processPayment(String orderId, int amount) throws NetworkException {
        attemptCount++;
        System.out.println("\n  🌐 [외부 API] 결제 요청 #" + attemptCount);
        System.out.println("    주문 ID: " + orderId);
        System.out.println("    금액: " + amount + "원");

        // 랜덤으로 네트워크 오류 발생
        if (random.nextDouble() < 0.3) {  // 30% 확률로 실패
            throw new NetworkException("일시적 네트워크 오류");
        }

        String transactionId = "TXN-" + System.currentTimeMillis();
        System.out.println("    ✅ 결제 성공: " + transactionId);
        return transactionId;
    }

    public int getAttemptCount() {
        return attemptCount;
    }

    public void resetAttemptCount() {
        attemptCount = 0;
    }
}

class OrderService {
    private PaymentGateway paymentGateway = new PaymentGateway();

    // ✅ Retry 메커니즘 적용
    public String placeOrder(String orderId, int amount) throws Exception {
        System.out.println("📦 [주문 서비스] 주문 처리 시작: " + orderId);

        int maxRetries = 3;
        int retryDelay = 1000;  // 1초

        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                System.out.println("\n🔄 시도 " + attempt + "/" + maxRetries);

                // 결제 처리
                String transactionId = paymentGateway.processPayment(orderId, amount);

                System.out.println("\n✅ [주문 완료] 거래 ID: " + transactionId);
                return transactionId;

            } catch (NetworkException e) {
                System.out.println("  ❌ 실패: " + e.getMessage());

                if (attempt < maxRetries) {
                    System.out.println("  ⏳ " + (retryDelay / 1000) + "초 후 재시도...");
                    try {
                        Thread.sleep(retryDelay);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new Exception("재시도 중단됨", ie);
                    }
                } else {
                    System.out.println("  ❌ 최대 재시도 횟수 초과");
                    throw new Exception("결제 처리 실패: 최대 재시도 횟수 초과", e);
                }
            }
        }

        throw new Exception("예상치 못한 오류");
    }
}

public class RetryMechanismExample {
    public static void main(String[] args) {
        System.out.println("=== Retry 메커니즘 - 쿠팡 주문 시스템 사례 ===\n");

        OrderService orderService = new OrderService();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오: 3번의 주문 시도
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        for (int i = 1; i <= 3; i++) {
            System.out.println("=".repeat(60));
            System.out.println("주문 #" + i);
            System.out.println("=".repeat(60));

            try {
                String transactionId = orderService.placeOrder("ORDER-" + i, 50000 * i);
                System.out.println("\n🎉 주문 성공!");
            } catch (Exception e) {
                System.out.println("\n💔 주문 실패: " + e.getMessage());
            }

            System.out.println("\n");
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(60));
        System.out.println("\n💡 Retry 메커니즘 핵심:");

        System.out.println("\n1️⃣ 일시적 오류 vs 영구적 오류:");
        System.out.println("   ✅ Retry 가능: 네트워크 타임아웃, 일시적 서버 과부하");
        System.out.println("   ❌ Retry 불가: 잘못된 파라미터, 인증 실패, 비즈니스 규칙 위반");

        System.out.println("\n2️⃣ Retry 전략:");
        System.out.println("   - Fixed Delay: 고정 시간 대기");
        System.out.println("   - Exponential Backoff: 점진적으로 대기 시간 증가 (1초, 2초, 4초...)");
        System.out.println("   - Jitter: 랜덤 지연 추가 (동시 요청 분산)");

        System.out.println("\n3️⃣ 주의사항:");
        System.out.println("   ⚠️ Idempotent (멱등성) 보장 필요");
        System.out.println("   ⚠️ 무한 재시도 방지 (최대 횟수 설정)");
        System.out.println("   ⚠️ Circuit Breaker 패턴 함께 사용");

        System.out.println("\n4️⃣ 실무 라이브러리:");
        System.out.println("   - Spring Retry");
        System.out.println("   - Resilience4j");
        System.out.println("   - Hystrix (Netflix)");
    }
}
```

**실행 결과 (예시):**
```
=== Retry 메커니즘 - 쿠팡 주문 시스템 사례 ===

============================================================
주문 #1
============================================================
📦 [주문 서비스] 주문 처리 시작: ORDER-1

🔄 시도 1/3

  🌐 [외부 API] 결제 요청 #1
    주문 ID: ORDER-1
    금액: 50000원
  ❌ 실패: 일시적 네트워크 오류
  ⏳ 1초 후 재시도...

🔄 시도 2/3

  🌐 [외부 API] 결제 요청 #2
    주문 ID: ORDER-1
    금액: 50000원
    ✅ 결제 성공: TXN-1699012345678

✅ [주문 완료] 거래 ID: TXN-1699012345678

🎉 주문 성공!

============================================================
주문 #2
============================================================
📦 [주문 서비스] 주문 처리 시작: ORDER-2

🔄 시도 1/3

  🌐 [외부 API] 결제 요청 #3
    주문 ID: ORDER-2
    금액: 100000원
    ✅ 결제 성공: TXN-1699012346789

✅ [주문 완료] 거래 ID: TXN-1699012346789

🎉 주문 성공!

============================================================
주문 #3
============================================================
📦 [주문 서비스] 주문 처리 시작: ORDER-3

🔄 시도 1/3

  🌐 [외부 API] 결제 요청 #4
    주문 ID: ORDER-3
    금액: 150000원
  ❌ 실패: 일시적 네트워크 오류
  ⏳ 1초 후 재시도...

🔄 시도 2/3

  🌐 [외부 API] 결제 요청 #5
    주문 ID: ORDER-3
    금액: 150000원
  ❌ 실패: 일시적 네트워크 오류
  ⏳ 1초 후 재시도...

🔄 시도 3/3

  🌐 [외부 API] 결제 요청 #6
    주문 ID: ORDER-3
    금액: 150000원
  ❌ 실패: 일시적 네트워크 오류
  ❌ 최대 재시도 횟수 초과

💔 주문 실패: 결제 처리 실패: 최대 재시도 횟수 초과

============================================================

💡 Retry 메커니즘 핵심:

1️⃣ 일시적 오류 vs 영구적 오류:
   ✅ Retry 가능: 네트워크 타임아웃, 일시적 서버 과부하
   ❌ Retry 불가: 잘못된 파라미터, 인증 실패, 비즈니스 규칙 위반

2️⃣ Retry 전략:
   - Fixed Delay: 고정 시간 대기
   - Exponential Backoff: 점진적으로 대기 시간 증가 (1초, 2초, 4초...)
   - Jitter: 랜덤 지연 추가 (동시 요청 분산)

3️⃣ 주의사항:
   ⚠️ Idempotent (멱등성) 보장 필요
   ⚠️ 무한 재시도 방지 (최대 횟수 설정)
   ⚠️ Circuit Breaker 패턴 함께 사용

4️⃣ 실무 라이브러리:
   - Spring Retry
   - Resilience4j
   - Hystrix (Netflix)
```

---

## 👨‍💻 주니어 개발자 시나리오

---

## ❓ Scenario 1: 예외를 무시하는 빈 catch 블록

### 문제 상황
주니어 개발자가 컴파일 에러를 피하기 위해 catch 블록을 비워두었습니다.

```java
// ❌ 잘못된 코드
try {
    dangerousOperation();
} catch (Exception e) {
    // 아무것도 하지 않음 - 예외 무시!
}
```

**문제점:**
- 예외가 발생해도 아무도 모름
- 디버깅 불가능
- 데이터 손실 위험

**해결 방법:**
```java
// ✅ 올바른 코드
try {
    dangerousOperation();
} catch (Exception e) {
    // 최소한 로깅이라도!
    System.err.println("오류 발생: " + e.getMessage());
    e.printStackTrace();

    // 또는 적절한 처리
    // - 기본값 반환
    // - 사용자에게 알림
    // - 상위로 예외 전파
}
```

---

## ❓ Scenario 2: Exception을 지나치게 광범위하게 잡기

### 문제 상황
주니어 개발자가 모든 예외를 `Exception`으로 잡아버렸습니다.

```java
// ❌ 잘못된 코드
try {
    readFile();
    parseData();
    saveToDatabase();
} catch (Exception e) {  // 너무 광범위!
    System.out.println("오류 발생");
}
```

**문제점:**
- 어떤 예외인지 알 수 없음
- NullPointerException 같은 버그도 숨김
- 각 예외에 맞는 처리 불가능

**해결 방법:**
```java
// ✅ 올바른 코드
try {
    readFile();
    parseData();
    saveToDatabase();
} catch (IOException e) {
    System.out.println("파일 읽기 실패: " + e.getMessage());
    // 파일 경로 확인 안내
} catch (ParseException e) {
    System.out.println("데이터 파싱 실패: " + e.getMessage());
    // 데이터 형식 확인 안내
} catch (SQLException e) {
    System.out.println("DB 저장 실패: " + e.getMessage());
    // DB 연결 확인 안내
}
```

---

## ❓ Scenario 3: finally 블록에서 return 사용

### 문제 상황
주니어 개발자가 finally 블록에서 return을 사용했습니다.

```java
// ❌ 잘못된 코드
public int calculate() {
    try {
        return 10 / 0;  // ArithmeticException 발생
    } catch (Exception e) {
        return -1;  // 에러 코드 반환
    } finally {
        return 0;  // ← 이게 항상 반환됨!
    }
}
```

**문제점:**
- finally의 return이 try/catch의 return을 덮어씀
- 예외 정보 손실
- 예상치 못한 동작

**해결 방법:**
```java
// ✅ 올바른 코드
public int calculate() {
    int result = 0;
    try {
        result = 10 / 0;
    } catch (Exception e) {
        result = -1;
        System.err.println("계산 오류: " + e.getMessage());
    } finally {
        // 리소스 정리만!
        // return 사용 금지
    }
    return result;
}
```

---

## ❓ Scenario 4: throws와 throw 혼동

### 문제 상황
주니어 개발자가 throws와 throw를 혼동했습니다.

```java
// ❌ 잘못된 코드
public void method1() throw Exception {  // 문법 오류!
    // ...
}

public void method2() throws Exception {
    // 예외를 던지지 않음 - throws만 선언
}

public void method3() {
    throw new Exception();  // 컴파일 에러! (throws 선언 없음)
}
```

**해결 방법:**
```java
// ✅ 올바른 코드

// throws: 메서드가 예외를 던질 수 있음을 선언
public void method1() throws IOException {
    // IOException을 던질 수 있음
}

// throw: 실제로 예외를 던짐
public void method2() throws IllegalArgumentException {
    if (condition) {
        throw new IllegalArgumentException("잘못된 인자");
    }
}

// throws 없이 throw (Unchecked Exception만 가능)
public void method3() {
    throw new RuntimeException("런타임 에러");  // OK
}
```

**정리:**
- `throws`: 메서드 시그니처에 선언 (예외 가능성 알림)
- `throw`: 실제로 예외 객체를 던짐

---

## 🎓 전체 요약

### 계층별 예외 처리
- Repository: 데이터 접근 예외
- Service: 비즈니스 로직 예외
- Controller: HTTP 응답 변환

### Transaction Rollback
- ACID 원칙 준수
- 예외 발생 시 원래 상태로 복구
- 데이터 정합성 보장

### Retry 메커니즘
- 일시적 오류 극복
- 최대 재시도 횟수 설정
- Exponential Backoff 전략

### 주니어 실수 방지
1. 빈 catch 블록 금지
2. 구체적인 예외 타입 사용
3. finally에서 return 금지
4. throws vs throw 구분

---

**📌 다음 Part 3에서는**
실전 프로젝트, FAQ, 면접 질문을 통해 예외 처리를 완전히 마스터합니다!
