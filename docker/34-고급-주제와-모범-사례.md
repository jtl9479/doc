# 34. 고급 주제와 모범 사례

> **학습 목표**: Docker의 고급 기능과 프로덕션 환경 모범 사례를 익혀 실무에서 안정적이고 효율적인 컨테이너 시스템을 구축할 수 있습니다.

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐⭐ (5개/5개)

---

## 목차
1. [왜 고급 주제가 필요한가](#-왜-고급-주제가-필요한가)
2. [실생활 비유로 이해하기](#-실생활-비유로-이해하기)
3. [멀티스테이지 빌드 마스터하기](#1-멀티스테이지-빌드-마스터하기)
4. [BuildKit과 빌드 최적화](#2-buildkit과-빌드-최적화)
5. [멀티 아키텍처 이미지](#3-멀티-아키텍처-이미지)
6. [보안 스캔과 자동화](#4-보안-스캔과-자동화)
7. [컨테이너 디자인 패턴](#5-컨테이너-디자인-패턴)
8. [헬스체크 및 그레이스풀 셧다운](#6-헬스체크-및-그레이스풀-셧다운)
9. [리소스 관리 모범 사례](#7-리소스-관리-모범-사례)
10. [보안 모범 사례](#8-보안-모범-사례)
11. [모니터링 및 로깅](#9-모니터링-및-로깅)
12. [프로덕션 체크리스트](#10-프로덕션-체크리스트)
13. [주니어 개발자 시나리오](#-주니어-개발자-시나리오)
14. [FAQ](#-faq)
15. [면접 질문](#-면접-질문)

---

## 💡 왜 고급 주제가 필요한가?

### 실무 배경

**"기본만 알면 되지, 고급 기능까지 배워야 하나요?"**

#### ❌ 고급 기능 없이 운영하면 발생하는 문제

```
문제 1: 비대한 이미지로 인한 비용 증가
- 증상: Docker 이미지 크기 2GB
- 대응: "그냥 돌아가니까 괜찮지 않나요?"
- 영향: 빌드 10분, 배포 15분, 디스크 낭비
- 비용: 월 클라우드 스토리지 비용 200만원

문제 2: 느린 빌드 시간으로 생산성 저하
- 증상: 코드 한 줄 수정에 빌드 5분
- 대응: "커피 마시면서 기다리면 되죠"
- 영향: 개발자 1명 하루 1시간 낭비
- 비용: 연간 개발 시간 250시간 손실 (약 500만원)

문제 3: 보안 취약점 노출
- 증상: 프로덕션에서 보안 경고
- 대응: "저희는 해킹 안 당해요"
- 영향: 개인정보 유출 사고 발생
- 비용: GDPR 벌금 최대 2천만 유로 (약 280억원)
```

#### ✅ 고급 기능을 익히면

```
해결책 1: 멀티스테이지 빌드로 이미지 90% 축소
- 방법: 빌드 도구 분리, 프로덕션 이미지 최소화
- 효과: 2GB → 200MB (10배 감소)
- 절감: 빌드 2분, 배포 3분, 스토리지 비용 90% 감소

해결책 2: BuildKit으로 빌드 시간 70% 단축
- 방법: 캐시 최적화, 병렬 빌드
- 효과: 5분 → 1.5분
- 절감: 개발자당 연간 175시간 절약 (약 350만원)

해결책 3: 자동 보안 스캔으로 사전 차단
- 방법: CI/CD에 Trivy 통합
- 효과: 배포 전 취약점 100% 차단
- 절감: 보안 사고 방지 = 수백억원 손실 방지
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 이미지 크기 | 2GB | 200MB | **90%↓** |
| 빌드 시간 | 5분 | 1.5분 | **70%↓** |
| 배포 시간 | 15분 | 3분 | **80%↓** |
| 보안 취약점 | 평균 15개 | 0개 | **100%↓** |
| 클라우드 비용 | 월 200만원 | 월 40만원 | **80%↓** |

### 경력 발전 로드맵

```
주니어 (0-2년)
├─ Docker 기본 명령어
├─ Dockerfile 작성
└─ docker-compose 사용

중급 (2-4년)
├─ 멀티스테이지 빌드      ← 여기부터 고급!
├─ 이미지 최적화
├─ 보안 모범 사례
└─ CI/CD 통합

시니어 (4년+)
├─ 멀티 아키텍처 빌드
├─ 커스텀 빌더 구축
├─ 보안 자동화
└─ 성능 튜닝 전문가

아키텍트 (7년+)
├─ 컨테이너 전략 수립
├─ 클라우드 네이티브 설계
├─ 조직 전체 DevOps 리드
└─ 기술 의사결정권자

💰 연봉 차이:
- 주니어: 4,000만원
- 중급: 6,000만원 (+50%)
- 시니어: 9,000만원 (+125%)
- 아키텍트: 1.2억원 (+200%)
```

---

## 🔍 실생활 비유로 이해하기

### 비유 1: 운전 면허 vs 레이싱 드라이버

```
기본 Docker 지식 = 운전 면허증 🚗
고급 Docker 지식 = 레이싱 드라이버 🏎️

┌──────────────────────────────────────────────┐
│ 운전 면허 (기본)                              │
├──────────────────────────────────────────────┤
│ ✓ 시동 걸고 출발 (docker run)                 │
│ ✓ 직진, 좌회전, 우회전 (기본 명령어)          │
│ ✓ 주차하기 (docker stop)                     │
│ → 목적지에 도착은 하지만 느림                 │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│ 레이싱 드라이버 (고급)                        │
├──────────────────────────────────────────────┤
│ ✓ 차량 튜닝 (이미지 최적화)                   │
│   - 불필요한 무게 제거 → 멀티스테이지 빌드   │
│   - 공기저항 감소 → 레이어 최소화             │
│                                               │
│ ✓ 코너링 기술 (빌드 캐시 활용)                │
│   - 최적 경로 선택 → 종속성 먼저 설치         │
│   - 브레이킹 포인트 → .dockerignore           │
│                                               │
│ ✓ 타이어 교체 타이밍 (보안 업데이트)          │
│   - 마모 감지 → 취약점 스캔                   │
│   - 교체 전략 → 자동 패치                     │
│                                               │
│ ✓ 텔레메트리 분석 (모니터링)                  │
│   - 실시간 데이터 → 메트릭 수집               │
│   - 성능 최적화 → 리소스 튜닝                 │
│                                               │
│ → 같은 거리를 절반 시간에 도착!               │
└──────────────────────────────────────────────┘

실무 예시:
- 주니어: "docker run하면 되는 거 아니에요?"
- 시니어: "이미지를 90% 줄이고, 빌드를 70% 빠르게 하고,
          보안 취약점 0개로 만들 수 있어요"
```

### 비유 2: 요리사 vs 셰프

```
기본 Docker = 레시피대로 요리하는 요리사 👨‍🍳
고급 Docker = 레시피를 창조하는 셰프 👨‍🍳⭐

┌──────────────────────────────────────────────┐
│ 요리사 (Recipe Follower)                      │
├──────────────────────────────────────────────┤
│ FROM ubuntu                                   │
│ RUN apt-get update                            │
│ RUN apt-get install -y nodejs                 │
│ COPY . /app                                   │
│ RUN npm install                               │
│ CMD ["npm", "start"]                          │
│                                               │
│ → 맛은 있지만 비효율적 (2GB 이미지)          │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│ 셰프 (Optimizer)                              │
├──────────────────────────────────────────────┤
│ # 1단계: 재료 준비 (빌드 스테이지)            │
│ FROM node:18-alpine AS builder                │
│ WORKDIR /app                                  │
│ COPY package*.json ./                         │
│ RUN npm ci --only=production                  │
│ COPY . .                                      │
│ RUN npm run build                             │
│                                               │
│ # 2단계: 플레이팅 (프로덕션 스테이지)         │
│ FROM node:18-alpine                           │
│ WORKDIR /app                                  │
│ COPY --from=builder /app/dist ./dist          │
│ COPY --from=builder /app/node_modules ./node_modules │
│ USER node                                     │
│ CMD ["node", "dist/main.js"]                  │
│                                               │
│ → 같은 맛, 10배 빠른 서빙 (200MB 이미지)     │
└──────────────────────────────────────────────┘

셰프가 하는 고급 기술:
1. 미장플라스 (Mise en place) → .dockerignore
   - 필요한 재료만 준비
   - 쓰레기는 미리 제거

2. 레이어링 (Layering) → 멀티스테이지
   - 맛의 층 쌓기
   - 불필요한 층은 버림

3. 타이밍 (Timing) → 빌드 캐시
   - 각 단계 최적 시간
   - 미리 준비 가능한 건 미리

4. 품질 관리 (QC) → 보안 스캔
   - 상한 재료 검사
   - 위생 검증
```

### 비유 3: 개발자 vs 아키텍트

```
기본 Docker = 코드 작성하는 개발자 💻
고급 Docker = 시스템 설계하는 아키텍트 🏛️

┌──────────────────────────────────────────────┐
│ 개발자 관점                                   │
├──────────────────────────────────────────────┤
│ "일단 돌아가게 만들자"                        │
│                                               │
│ ❌ 문제점:                                     │
│ - 이미지 크기? "상관없어요"                   │
│ - 빌드 시간? "커피 마시면 돼요"               │
│ - 보안? "해킹 안 당하면 되죠"                 │
│ - 비용? "회사 돈이잖아요"                     │
│                                               │
│ → 기술 부채 누적, 장기적 문제 발생            │
└──────────────────────────────────────────────┘

┌──────────────────────────────────────────────┐
│ 아키텍트 관점                                 │
├──────────────────────────────────────────────┤
│ "확장 가능하고 유지보수 가능하게 설계하자"    │
│                                               │
│ ✅ 고려사항:                                   │
│                                               │
│ 1. 효율성 (Efficiency)                        │
│    - 멀티스테이지: 이미지 크기 90% 감소       │
│    - BuildKit: 빌드 시간 70% 단축             │
│    → 비용 절감 + 개발 속도 향상               │
│                                               │
│ 2. 확장성 (Scalability)                       │
│    - 멀티 아키텍처: ARM/AMD64 지원            │
│    - 리소스 제한: 예측 가능한 성능            │
│    → 글로벌 서비스 가능                       │
│                                               │
│ 3. 보안 (Security)                            │
│    - 자동 스캔: 취약점 0개                    │
│    - Non-root: 권한 최소화                    │
│    → 규제 준수 + 리스크 최소화                │
│                                               │
│ 4. 신뢰성 (Reliability)                       │
│    - 헬스체크: 자동 복구                      │
│    - 그레이스풀 셧다운: 데이터 손실 방지      │
│    → 99.99% 가동률                            │
│                                               │
│ 5. 관찰성 (Observability)                     │
│    - 구조화된 로깅: 빠른 문제 파악            │
│    - 메트릭 수집: 사전 대응                   │
│    → 장애 시간 최소화                         │
│                                               │
│ → 장기적 성공, 경쟁 우위 확보                 │
└──────────────────────────────────────────────┘

경력 단계별 목표:
┌─────────────────────────────────────────┐
│ 주니어 → 중급 (2년)                      │
│ "돌아간다" → "잘 돌아간다"               │
│ 학습: 멀티스테이지, 최적화 기초          │
├─────────────────────────────────────────┤
│ 중급 → 시니어 (2년)                      │
│ "잘 돌아간다" → "효율적으로 돌아간다"    │
│ 학습: BuildKit, 멀티 아키텍처, 보안      │
├─────────────────────────────────────────┤
│ 시니어 → 아키텍트 (3년)                  │
│ "효율적" → "전략적으로 설계한다"         │
│ 학습: 시스템 설계, 비용 최적화, 거버넌스 │
└─────────────────────────────────────────┘
```

---

## 1. 멀티스테이지 빌드 마스터하기

### 1.1 기본 개념

멀티스테이지 빌드는 **빌드 도구와 프로덕션 환경을 분리**하는 기법입니다.

```dockerfile
# ❌ 단일 스테이지 (안 좋은 예)
FROM gradle:8.5-jdk17
WORKDIR /app
COPY . .
RUN gradle build --no-daemon
CMD ["java", "-jar", "build/libs/app.jar"]

# 문제점:
# 1. Gradle 포함 → 800MB
# 2. 빌드 캐시 포함 → 추가 200MB
# 3. 소스 코드 포함 → 보안 위험
# 4. JDK 포함 (JRE만 필요) → 불필요한 용량
```

```dockerfile
# ✅ 멀티 스테이지 (좋은 예)
# 1단계: 빌드 스테이지
FROM gradle:8.5-jdk17 AS builder
WORKDIR /app

# 의존성 캐싱
COPY build.gradle.kts settings.gradle.kts ./
COPY gradle ./gradle
RUN gradle dependencies --no-daemon

# 소스 빌드
COPY src ./src
RUN gradle build --no-daemon -x test

# 2단계: 프로덕션 스테이지
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# 빌드된 JAR만 복사
COPY --from=builder /app/build/libs/*.jar app.jar

# 보안: non-root 사용자
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser && \
    chown -R appuser:appuser /app
USER appuser

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]

# 결과:
# - 이미지 크기: 800MB → 200MB (75% 감소)
# - 빌드 도구 제거
# - 소스 코드 제거 (보안 향상)
# - JRE만 포함 (경량화)
```

### 1.2 언어별 멀티스테이지 예시

#### Node.js

```dockerfile
# 빌드 스테이지
FROM node:18-alpine AS builder
WORKDIR /app

# 의존성 설치 (package.json 변경 시에만 재실행)
COPY package*.json ./
RUN npm ci --only=production

# 소스 복사 및 빌드
COPY . .
RUN npm run build

# 프로덕션 스테이지
FROM node:18-alpine
WORKDIR /app

# 빌드 결과물만 복사
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY package*.json ./

# non-root 사용자
USER node

EXPOSE 3000
CMD ["node", "dist/main.js"]

# Before: 1.2GB → After: 150MB (87% 감소)
```

#### Go

```dockerfile
# 빌드 스테이지
FROM golang:1.21-alpine AS builder
WORKDIR /app

# 모듈 다운로드 (go.mod 변경 시에만 재실행)
COPY go.mod go.sum ./
RUN go mod download

# 빌드 (정적 링킹)
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# 프로덕션 스테이지 (Distroless)
FROM gcr.io/distroless/static-debian11
WORKDIR /

# 바이너리만 복사
COPY --from=builder /app/main .

# non-root
USER nonroot:nonroot

EXPOSE 8080
ENTRYPOINT ["/main"]

# Before: 500MB → After: 15MB (97% 감소!)
```

#### Python

```dockerfile
# 빌드 스테이지
FROM python:3.11-slim AS builder
WORKDIR /app

# 의존성 설치
COPY requirements.txt .
RUN pip install --user --no-cache-dir -r requirements.txt

# 프로덕션 스테이지
FROM python:3.11-slim
WORKDIR /app

# 설치된 패키지만 복사
COPY --from=builder /root/.local /root/.local
COPY . .

# PATH 설정
ENV PATH=/root/.local/bin:$PATH

# non-root 사용자
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /app
USER appuser

EXPOSE 8000
CMD ["python", "app.py"]

# Before: 900MB → After: 180MB (80% 감소)
```

### 1.3 고급 패턴

#### 공통 베이스 활용

```dockerfile
# 공통 베이스
FROM node:18-alpine AS base
WORKDIR /app
COPY package*.json ./

# 개발 의존성 포함
FROM base AS development
RUN npm install
COPY . .
CMD ["npm", "run", "dev"]

# 빌드
FROM base AS builder
RUN npm ci --only=production
COPY . .
RUN npm run build

# 프로덕션
FROM node:18-alpine AS production
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
USER node
CMD ["node", "dist/main.js"]

# 사용:
# 개발: docker build --target development -t app:dev .
# 프로덕션: docker build --target production -t app:prod .
```

---

## 2. BuildKit과 빌드 최적화

### 2.1 BuildKit 활성화

BuildKit은 Docker의 **차세대 빌드 엔진**으로 빌드 속도를 크게 향상시킵니다.

```bash
# 일회성 활성화
DOCKER_BUILDKIT=1 docker build -t myapp:latest .

# 영구 활성화 (Linux/Mac)
echo 'export DOCKER_BUILDKIT=1' >> ~/.bashrc
source ~/.bashrc

# 영구 활성화 (Windows PowerShell)
[Environment]::SetEnvironmentVariable("DOCKER_BUILDKIT", "1", "User")

# daemon.json 설정 (Docker Desktop)
{
  "features": {
    "buildkit": true
  }
}
```

### 2.2 캐시 마운트

```dockerfile
# syntax=docker/dockerfile:1

FROM node:18-alpine

WORKDIR /app

# 캐시 마운트로 npm 캐시 재사용
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production

# 빌드 캐시 재사용
RUN --mount=type=cache,target=/app/.cache \
    npm run build

# 효과:
# - 첫 빌드: 300초
# - 두 번째 빌드: 60초 (5배 빠름!)
```

### 2.3 시크릿 마운트

```dockerfile
# syntax=docker/dockerfile:1

FROM alpine

# ❌ 나쁜 예: 시크릿이 이미지에 포함됨
ARG NPM_TOKEN
RUN echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc && \
    npm install && \
    rm ~/.npmrc
# 하지만 이미지 히스토리에는 남아있음!

# ✅ 좋은 예: 시크릿 마운트 (이미지에 포함 안됨)
RUN --mount=type=secret,id=npm_token \
    echo "//registry.npmjs.org/:_authToken=$(cat /run/secrets/npm_token)" > ~/.npmrc && \
    npm install
```

```bash
# 빌드 시 시크릿 전달
docker build \
    --secret id=npm_token,src=$HOME/.npmrc \
    -t myapp:latest .
```

### 2.4 병렬 빌드

```dockerfile
# syntax=docker/dockerfile:1

FROM node:18-alpine AS frontend-builder
WORKDIR /app/frontend
COPY frontend/package*.json ./
RUN npm ci
COPY frontend .
RUN npm run build

FROM node:18-alpine AS backend-builder
WORKDIR /app/backend
COPY backend/package*.json ./
RUN npm ci
COPY backend .
RUN npm run build

# 최종 이미지
FROM node:18-alpine
COPY --from=frontend-builder /app/frontend/dist /app/public
COPY --from=backend-builder /app/backend/dist /app
CMD ["node", "server.js"]

# BuildKit이 frontend와 backend를 병렬로 빌드!
# Before: 10분 (순차)
# After: 6분 (병렬)
```

---

## 3. 멀티 아키텍처 이미지

### 3.1 왜 필요한가?

```
시나리오: Apple M1/M2 (ARM64) Mac 사용자가 증가

개발자 A (Mac M1):
$ docker run myapp:latest
WARNING: The requested image's platform (linux/amd64) does not match
the detected host platform (linux/arm64/v8)

→ 느린 에뮬레이션 모드로 실행 (10배 느림!)
```

### 3.2 Docker Buildx 사용

```bash
# Buildx 설치 확인
docker buildx version

# 새 빌더 생성
docker buildx create --name mybuilder --use
docker buildx inspect --bootstrap

# 멀티 아키텍처 빌드
docker buildx build \
    --platform linux/amd64,linux/arm64 \
    -t username/myapp:latest \
    --push \
    .

# 결과:
# - linux/amd64 이미지 (Intel/AMD CPU용)
# - linux/arm64 이미지 (Apple Silicon, AWS Graviton용)
#
# Docker가 자동으로 올바른 이미지 선택!
```

### 3.3 아키텍처별 최적화

```dockerfile
# syntax=docker/dockerfile:1

FROM --platform=$BUILDPLATFORM golang:1.21-alpine AS builder

ARG TARGETPLATFORM
ARG BUILDPLATFORM
ARG TARGETOS
ARG TARGETARCH

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .

# 아키텍처별 최적화 빌드
RUN GOOS=$TARGETOS GOARCH=$TARGETARCH \
    go build -o /app/main .

FROM alpine:latest
COPY --from=builder /app/main /main
ENTRYPOINT ["/main"]
```

---

## 4. 보안 스캔과 자동화

### 4.1 Trivy로 취약점 스캔

```bash
# Trivy 설치
# Mac
brew install aquasecurity/trivy/trivy

# Linux
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy

# 이미지 스캔
trivy image myapp:latest

# 출력 예시:
┌─────────────────────────────────────────────────┐
│ Total: 45 (CRITICAL: 3, HIGH: 12, MEDIUM: 30)   │
├─────────────────────────────────────────────────┤
│ CRITICAL: CVE-2023-12345                        │
│ Package: openssl                                │
│ Version: 1.1.1k                                 │
│ Fixed Version: 1.1.1w                           │
└─────────────────────────────────────────────────┘

# 심각도별 필터링
trivy image --severity CRITICAL,HIGH myapp:latest

# 특정 취약점 무시
trivy image --ignore-unfixed myapp:latest

# JSON 출력 (CI/CD 통합용)
trivy image --format json --output results.json myapp:latest
```

### 4.2 CI/CD 통합

#### GitHub Actions

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [main]
  pull_request:

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: docker build -t myapp:${{ github.sha }} .

      - name: Run Trivy scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Fail on CRITICAL
        run: |
          trivy image --exit-code 1 --severity CRITICAL \
            myapp:${{ github.sha }}
```

#### GitLab CI

```yaml
# .gitlab-ci.yml
stages:
  - build
  - scan

build:
  stage: build
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA

security-scan:
  stage: scan
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  script:
    - trivy image --exit-code 1 --severity CRITICAL \
        $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  allow_failure: false
```

### 4.3 자동 수정

```bash
# Dockerfile 자동 개선 (hadolint)
docker run --rm -i hadolint/hadolint < Dockerfile

# 출력:
DL3008 Pin versions in apt get install
DL3009 Delete the apt-get lists after installing
DL3015 Avoid additional packages by specifying --no-install-recommends

# 수정 후:
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        curl=7.68.0-1ubuntu2.14 && \
    rm -rf /var/lib/apt/lists/*
```

---

## 5. 컨테이너 디자인 패턴

### 5.1 사이드카 패턴 (Sidecar)

**목적**: 메인 컨테이너에 부가 기능 추가

```yaml
# docker-compose.yml
services:
  # 메인 애플리케이션
  app:
    image: myapp:latest
    volumes:
      - logs:/var/log/app

  # 사이드카: 로그 수집
  log-forwarder:
    image: fluentd:latest
    volumes:
      - logs:/var/log/app:ro  # 읽기 전용
    environment:
      - FLUENTD_CONF=fluent.conf

volumes:
  logs:

# 사용 사례:
# - 로그 수집 및 전송
# - 설정 파일 동기화
# - 프록시 (Envoy, Linkerd)
# - 모니터링 에이전트
```

### 5.2 앰배서더 패턴 (Ambassador)

**목적**: 외부 서비스 연결 추상화

```yaml
services:
  # 메인 애플리케이션
  app:
    image: myapp:latest
    environment:
      - DB_HOST=localhost  # 앰배서더를 통해 접근
      - DB_PORT=5432
    network_mode: "service:db-proxy"

  # 앰배서더: DB 프록시
  db-proxy:
    image: haproxy:latest
    volumes:
      - ./haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro

# 장점:
# - 연결 풀링
# - 로드 밸런싱
# - 재시도 로직
# - 서킷 브레이커
```

### 5.3 어댑터 패턴 (Adapter)

**목적**: 레거시 시스템 통합

```yaml
services:
  # 레거시 애플리케이션 (자체 메트릭 포맷)
  legacy-app:
    image: legacy:1.0
    ports:
      - "8080:8080"

  # 어댑터: Prometheus 포맷으로 변환
  metrics-adapter:
    image: prometheus-adapter:latest
    environment:
      - LEGACY_ENDPOINT=http://legacy-app:8080/stats
    ports:
      - "9090:9090"  # Prometheus가 스크랩

# 사용 사례:
# - 메트릭 포맷 변환
# - 로그 포맷 표준화
# - API 버전 변환
```

---

## 6. 헬스체크 및 그레이스풀 셧다운

### 6.1 올바른 헬스체크 구현

```kotlin
// Spring Boot Actuator
@RestController
class HealthController {

    // Liveness: "컨테이너가 살아있는가?"
    @GetMapping("/actuator/health/liveness")
    fun liveness(): ResponseEntity<Map<String, Any>> {
        // 간단한 체크만 (데드락, 무한 루프 감지)
        return ResponseEntity.ok(mapOf(
            "status" to "UP",
            "timestamp" to Instant.now()
        ))
    }

    // Readiness: "트래픽을 받을 준비가 되었는가?"
    @GetMapping("/actuator/health/readiness")
    fun readiness(): ResponseEntity<Map<String, Any>> {
        val checks = mapOf(
            "database" to checkDatabase(),
            "redis" to checkRedis(),
            "externalApi" to checkExternalApi()
        )

        val allHealthy = checks.values.all { it }

        return if (allHealthy) {
            ResponseEntity.ok(mapOf("status" to "UP", "checks" to checks))
        } else {
            ResponseEntity.status(503)
                .body(mapOf("status" to "DOWN", "checks" to checks))
        }
    }

    private fun checkDatabase(): Boolean {
        return try {
            dataSource.connection.use { it.isValid(2) }
        } catch (e: Exception) {
            false
        }
    }
}
```

```yaml
# Kubernetes Deployment
apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
      - name: app
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60  # 시작 후 60초 대기
          periodSeconds: 10         # 10초마다 체크
          timeoutSeconds: 3         # 3초 내 응답
          failureThreshold: 3       # 3번 실패 시 재시작

        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3       # 3번 실패 시 트래픽 차단
```

### 6.2 그레이스풀 셧다운

```kotlin
// application.yml
server:
  shutdown: graceful

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s

// 커스텀 셧다운 훅
@Component
class GracefulShutdown : DisposableBean {
    private val logger = LoggerFactory.getLogger(javaClass)

    override fun destroy() {
        logger.info("Graceful shutdown initiated")

        // 1. 새 요청 거부
        logger.info("Stopping new requests")

        // 2. 진행 중인 요청 완료 대기
        logger.info("Waiting for in-flight requests")
        waitForRequestsToComplete()

        // 3. 리소스 정리
        logger.info("Cleaning up resources")
        cleanupResources()

        logger.info("Graceful shutdown completed")
    }

    private fun waitForRequestsToComplete() {
        // 실제 구현: 요청 카운터 확인
        Thread.sleep(5000)
    }

    private fun cleanupResources() {
        // DB 연결 풀 종료
        // 캐시 플러시
        // 백그라운드 작업 종료
    }
}
```

---

## 7. 리소스 관리 모범 사례

### 7.1 적절한 리소스 설정

```yaml
# ❌ 나쁜 예: 리소스 제한 없음
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    image: myapp:latest
    # requests/limits 없음 → 무한 리소스 사용 가능
    # → 다른 Pod 영향, 노드 불안정

# ✅ 좋은 예: 적절한 리소스 설정
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        cpu: "500m"       # 0.5 CPU 예약
        memory: "512Mi"   # 512MB 예약
      limits:
        cpu: "1000m"      # 최대 1 CPU
        memory: "1Gi"     # 최대 1GB

# 가이드라인:
# requests = 평균 사용량의 80%
# limits = 피크 사용량의 120%
```

### 7.2 JVM 메모리 설정

```dockerfile
FROM eclipse-temurin:17-jre-alpine

ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:InitialRAMPercentage=50.0 \
               -XX:+UseG1GC \
               -XX:MaxGCPauseMillis=200"

COPY app.jar /app.jar

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app.jar"]
```

```yaml
# Kubernetes
spec:
  containers:
  - name: app
    resources:
      requests:
        memory: "1Gi"
      limits:
        memory: "1Gi"  # requests == limits (guaranteed QoS)
    env:
    - name: JAVA_OPTS
      value: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"
    # 1GB 컨테이너 → JVM 750MB 사용
```

---

## 8. 보안 모범 사례

### 8.1 체크리스트

```bash
# ✅ 이미지 보안 체크리스트
□ 신뢰할 수 있는 베이스 이미지 (공식 이미지)
□ 특정 버전 태그 (latest 금지)
□ 이미지 스캔 (Trivy, Clair)
□ 멀티스테이지 빌드
□ non-root 사용자
□ 읽기 전용 루트 파일시스템
□ 불필요한 패키지 제거
□ .dockerignore 설정

# ✅ 컨테이너 런타임 보안
□ SecurityContext 설정
□ capabilities 최소화
□ seccomp 프로필
□ AppArmor/SELinux

# ✅ Secret 관리
□ 환경 변수로 시크릿 전달 금지
□ Docker Secret 또는 Kubernetes Secret 사용
□ 볼트 (Vault) 통합
```

### 8.2 SecurityContext 예시

```yaml
apiVersion: v1
kind: Pod
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  containers:
  - name: app
    image: myapp:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE  # 포트 80 바인딩만 허용

    volumeMounts:
    - name: tmp
      mountPath: /tmp  # 쓰기 가능한 임시 디렉토리

  volumes:
  - name: tmp
    emptyDir: {}
```

---

## 9. 모니터링 및 로깅

### 9.1 구조화된 로깅

```kotlin
// ❌ 나쁜 예
logger.info("User login: ${user.email}")

// ✅ 좋은 예
logger.info(
    "User login",
    kv("userId", user.id),
    kv("email", user.email.maskEmail()),
    kv("ip", request.remoteAddr),
    kv("userAgent", request.getHeader("User-Agent")),
    kv("correlationId", MDC.get("correlationId"))
)

// JSON 출력:
{
  "timestamp": "2025-09-30T10:15:32.123Z",
  "level": "INFO",
  "message": "User login",
  "userId": 123,
  "email": "te**@example.com",
  "ip": "203.0.113.1",
  "userAgent": "Mozilla/5.0...",
  "correlationId": "abc-123-def",
  "service": "user-service",
  "environment": "production"
}
```

### 9.2 메트릭 수집

```kotlin
import io.micrometer.core.instrument.MeterRegistry

@Service
class OrderService(
    private val meterRegistry: MeterRegistry
) {
    private val orderCounter = meterRegistry.counter("orders.created")
    private val orderTimer = meterRegistry.timer("orders.processing.time")

    fun createOrder(request: OrderRequest): Order {
        return orderTimer.record {
            val order = processOrder(request)

            orderCounter.increment()

            meterRegistry.counter(
                "orders.created",
                "type", request.type,
                "status", "success"
            ).increment()

            order
        }
    }
}
```

---

## 10. 프로덕션 체크리스트

### 10.1 배포 전

```
□ 이미지
  □ 이미지 크기 <500MB
  □ 보안 스캔 (HIGH/CRITICAL 없음)
  □ 멀티스테이지 빌드
  □ non-root 사용자
  □ 헬스체크 구현

□ 설정
  □ 환경별 설정 분리
  □ Secret 암호화
  □ 리소스 requests/limits
  □ 레플리카 수 설정

□ 네트워킹
  □ 서비스 디스커버리
  □ 로드 밸런서
  □ Ingress 규칙
  □ 네트워크 정책

□ 모니터링
  □ 메트릭 수집
  □ 로그 집계
  □ 알림 규칙
  □ 대시보드

□ 보안
  □ RBAC
  □ NetworkPolicy
  □ PodSecurityPolicy
  □ 이미지 스캔 자동화
```

---

## 👨‍💻 주니어 개발자 시나리오

### 시나리오 1: 멀티스테이지 빌드로 이미지 90% 축소

**상황**:
```
주니어 A: "Docker 이미지가 2GB인데 괜찮나요?"
시니어: "2GB?! 그거 줄일 수 있어요. 멀티스테이지 빌드 해봤어요?"
주니어 A: "그게 뭔가요?"
```

**Before (단일 스테이지)**:
```dockerfile
FROM gradle:8.5-jdk17
WORKDIR /app
COPY . .
RUN gradle build --no-daemon
CMD ["java", "-jar", "build/libs/app.jar"]
```

```bash
$ docker images
REPOSITORY    TAG       SIZE
myapp         latest    2.1GB  # 😱
```

**After (멀티스테이지)**:
```dockerfile
# 빌드 스테이지
FROM gradle:8.5-jdk17 AS builder
WORKDIR /app
COPY build.gradle.kts settings.gradle.kts ./
COPY gradle ./gradle
RUN gradle dependencies --no-daemon
COPY src ./src
RUN gradle build --no-daemon -x test

# 프로덕션 스테이지
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser && \
    chown -R appuser:appuser /app
USER appuser
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

```bash
$ docker images
REPOSITORY    TAG       SIZE
myapp         latest    210MB  # 🎉 90% 감소!

$ docker history myapp:latest
IMAGE          CREATED BY                                      SIZE
...
<missing>      COPY --from=builder /app/build/libs/*.jar...    45MB
<missing>      /bin/sh -c addgroup -g 1000 appuser...          5KB
eclipse-temurin:17-jre-alpine                                   165MB
```

**결과**:
- 이미지 크기: 2.1GB → 210MB (90% 감소)
- 빌드 시간: 8분 → 3분 (첫 빌드), 1분 (캐시 활용)
- 배포 시간: 15분 → 2분 (빠른 다운로드)
- 클라우드 비용: 월 80만원 → 월 15만원

**주니어 A의 반응**:
```
"와, 이미지가 10분의 1로 줄었어요!
 배포도 훨씬 빨라졌고요.
 이제 왜 멀티스테이지를 쓰는지 알겠어요!"
```

---

### 시나리오 2: BuildKit으로 빌드 시간 70% 단축

**상황**:
```
주니어 B: "코드 한 줄만 수정해도 빌드에 5분이나 걸려요..."
시니어: "BuildKit과 캐시 최적화 해봤어요?"
주니어 B: "BuildKit이 뭔가요?"
```

**Before (기본 빌드)**:
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install
RUN npm run build
CMD ["npm", "start"]
```

```bash
$ time docker build -t myapp:latest .
...
real    5m 23s  # 😫 매번 5분

# 문제점:
# 1. 소스 변경 시마다 npm install 재실행
# 2. 캐시 활용 안됨
# 3. 순차 빌드 (느림)
```

**After (BuildKit + 캐시 최적화)**:
```dockerfile
# syntax=docker/dockerfile:1

FROM node:18-alpine
WORKDIR /app

# 1. 의존성 파일만 먼저 복사
COPY package*.json ./

# 2. 캐시 마운트로 npm 캐시 재사용
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production

# 3. 소스 코드 복사 (자주 변경됨)
COPY . .

# 4. 빌드 캐시 활용
RUN --mount=type=cache,target=/app/.cache \
    npm run build

CMD ["npm", "start"]
```

```bash
# BuildKit 활성화
$ export DOCKER_BUILDKIT=1

# 첫 빌드
$ time docker build -t myapp:latest .
real    3m 10s  # 조금 빨라짐

# 두 번째 빌드 (소스만 변경)
$ time docker build -t myapp:latest .
real    1m 32s  # 🎉 70% 단축!

# package.json 변경 안 하면 npm install 캐시 사용!
```

**비교**:
| 상황 | Before | After | 개선 |
|------|--------|-------|------|
| 첫 빌드 | 5분 23초 | 3분 10초 | 41%↓ |
| 소스만 변경 | 5분 23초 | 1분 32초 | **71%↓** |
| 의존성 변경 | 5분 23초 | 3분 15초 | 40%↓ |

**일일 개발 시간 계산**:
```
주니어 B의 하루:
- 빌드 횟수: 20회
- Before: 20 × 5분 = 100분 (1시간 40분)
- After: 20 × 1.5분 = 30분
- 절약: 1시간 10분 / 일

월 절약 시간:
- 1시간 10분 × 20일 = 23시간 20분
- 거의 3일치 작업 시간!
```

**주니어 B의 반응**:
```
"와, 빌드가 진짜 빨라졌어요!
 이제 커피 마실 시간도 없네요 (좋은 의미로)
 하루에 1시간 이상 절약되니까 개발에 집중할 수 있어요!"
```

---

### 시나리오 3: 멀티 아키텍처 이미지 빌드

**상황**:
```
주니어 C: "M1 Mac에서 도커가 엄청 느린데요?"
시니어: "멀티 아키텍처 이미지로 빌드했어요?"
주니어 C: "그게 뭔가요?"
```

**문제 상황**:
```bash
# Intel Mac에서 빌드한 이미지
$ docker build -t myapp:latest .
$ docker push myorg/myapp:latest

# M1 Mac에서 실행
$ docker run myorg/myapp:latest
WARNING: The requested image's platform (linux/amd64)
does not match the detected host platform (linux/arm64/v8)

# 결과: 에뮬레이션 모드로 실행 (10배 느림!)
```

**해결: Docker Buildx 사용**:
```bash
# 1. 빌더 생성
$ docker buildx create --name multiarch --use
$ docker buildx inspect --bootstrap

[+] Building 2.0s (1/1) FINISHED
 => [internal] booting buildkit
multiarch

Name:   multiarch
Driver: docker-container

Platforms: linux/amd64, linux/arm64, linux/arm/v7, ...

# 2. 멀티 아키텍처 빌드
$ docker buildx build \
    --platform linux/amd64,linux/arm64 \
    -t myorg/myapp:latest \
    --push \
    .

[+] Building 125.3s (20/20) FINISHED
 => [linux/amd64 1/5] FROM docker.io/library/node:18-alpine
 => [linux/arm64 1/5] FROM docker.io/library/node:18-alpine
 ...
 => => pushing layers
 => => pushing manifest for myorg/myapp:latest

# 3. 확인
$ docker buildx imagetools inspect myorg/myapp:latest

Name:      myorg/myapp:latest
MediaType: application/vnd.docker.distribution.manifest.list.v2+json
Digest:    sha256:abc123...

Manifests:
  Name:      myorg/myapp:latest@sha256:def456...
  MediaType: application/vnd.docker.distribution.manifest.v2+json
  Platform:  linux/amd64

  Name:      myorg/myapp:latest@sha256:ghi789...
  MediaType: application/vnd.docker.distribution.manifest.v2+json
  Platform:  linux/arm64
```

**테스트**:
```bash
# Intel Mac
$ docker run myorg/myapp:latest
→ linux/amd64 이미지 자동 선택 ✅

# M1 Mac
$ docker run myorg/myapp:latest
→ linux/arm64 이미지 자동 선택 ✅ (10배 빠름!)

# AWS Graviton (ARM)
$ docker run myorg/myapp:latest
→ linux/arm64 이미지 자동 선택 ✅ (저렴함!)
```

**성능 비교 (M1 Mac)**:
| 상황 | 응답 시간 | CPU 사용 |
|------|-----------|----------|
| AMD64 (에뮬레이션) | 500ms | 80% |
| ARM64 (네이티브) | 50ms | 8% |
| **개선** | **90%↓** | **90%↓** |

**주니어 C의 반응**:
```
"이제 M1 Mac에서도 빠르게 돌아가요!
 AWS Graviton도 지원되니까 클라우드 비용도 절약되고요.
 한 번 빌드로 모든 플랫폼 지원이라니 신기해요!"
```

---

### 시나리오 4: 보안 스캔 자동화 구현

**상황**:
```
주니어 D: "배포했는데 보안팀에서 취약점 있다고 연락왔어요..."
시니어: "배포 전에 보안 스캔 안 했어요?"
주니어 D: "어떻게 하는 건가요?"
```

**문제 상황**:
```bash
# 배포 후 발견된 취약점
CVE-2023-12345: OpenSSL Critical Vulnerability
CVE-2023-67890: Node.js High Vulnerability
CVE-2023-11111: npm Medium Vulnerability

→ 긴급 패치 작업 필요
→ 서비스 다운타임 발생
→ 보안팀 미팅, 경영진 보고...
```

**해결: Trivy + CI/CD 통합**:

**Step 1: 로컬 스캔**:
```bash
# Trivy 설치
$ brew install aquasecurity/trivy/trivy

# 이미지 스캔
$ trivy image myapp:latest

myapp:latest (alpine 3.18.3)
===========================
Total: 15 (CRITICAL: 3, HIGH: 5, MEDIUM: 7)

┌─────────────┬────────────────┬──────────┬───────────────────┬───────────────┐
│   Library   │ Vulnerability  │ Severity │ Installed Version │ Fixed Version │
├─────────────┼────────────────┼──────────┼───────────────────┼───────────────┤
│ openssl     │ CVE-2023-12345 │ CRITICAL │ 1.1.1k            │ 1.1.1w        │
│ libcurl     │ CVE-2023-67890 │ HIGH     │ 7.79.1            │ 7.88.1        │
└─────────────┴────────────────┴──────────┴───────────────────┴───────────────┘

# 😱 배포 전에 발견 못했어요!
```

**Step 2: Dockerfile 수정**:
```dockerfile
# Before
FROM node:18-alpine

# After
FROM node:18-alpine3.18

# 특정 버전 명시 + 최신 패치
RUN apk update && apk upgrade
```

**Step 3: GitHub Actions 통합**:
```yaml
# .github/workflows/security.yml
name: Security Scan

on:
  push:
    branches: [main]
  pull_request:

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: docker build -t myapp:${{ github.sha }} .

      - name: Run Trivy scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'myapp:${{ github.sha }}'
          format: 'table'
          exit-code: '1'  # CRITICAL 발견 시 빌드 실패
          severity: 'CRITICAL,HIGH'

      - name: Upload results
        if: always()
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

**결과**:
```bash
# PR 생성
$ git push origin feature/new-api

# GitHub Actions 실행
Run Trivy scanner
  ✓ Scanning image...
  ✗ Found CRITICAL vulnerabilities
  ✗ Build failed!

# PR에 코멘트 자동 생성:
┌──────────────────────────────────────────┐
│ ⚠️ Security vulnerabilities found        │
├──────────────────────────────────────────┤
│ CRITICAL: 1                              │
│ HIGH: 2                                  │
│                                          │
│ Please fix before merging                │
└──────────────────────────────────────────┘

# 수정 후 재시도
$ docker build -t myapp:latest .
$ trivy image myapp:latest

myapp:latest (alpine 3.18.4)
===========================
Total: 0 (CRITICAL: 0, HIGH: 0, MEDIUM: 0)

✅ No vulnerabilities found

# 이제 PR 승인 가능!
```

**장기적 효과**:
```
Before (수동 관리):
├─ 배포 후 취약점 발견: 월 3회
├─ 긴급 패치: 월 3회 × 4시간 = 12시간
├─ 보안 사고: 연 1회
└─ 비용: 수억원 손실 위험

After (자동 스캔):
├─ 배포 전 차단: 100%
├─ 긴급 패치: 0회
├─ 보안 사고: 0회
└─ 비용: 안심 😌
```

**주니어 D의 반응**:
```
"이제 배포 전에 자동으로 체크해주니까 안심이에요!
 PR마다 보안 스캔 결과가 나오니까
 문제를 미리미리 고칠 수 있어요.
 더 이상 보안팀한테 혼나지 않아요!"
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: 고급 기능은 언제부터 배워야 하나요?</strong></summary>

**A**: **Docker 기본 (docker run, Dockerfile)을 익힌 직후부터** 시작하세요!

**상세 설명**:

**학습 단계별 로드맵**:

```
┌─────────────────────────────────────────────────────────┐
│ 1단계: 기본 (1-2주)                                      │
├─────────────────────────────────────────────────────────┤
│ □ docker run, stop, rm                                  │
│ □ 간단한 Dockerfile 작성                                │
│ □ docker-compose 기본 사용                              │
│                                                         │
│ → "일단 돌아가게" 만들 수 있음                          │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 2단계: 최적화 (2-3주) ← 여기서 고급 기능 시작!          │
├─────────────────────────────────────────────────────────┤
│ ✅ 멀티스테이지 빌드 (필수!)                             │
│ ✅ .dockerignore                                        │
│ ✅ 레이어 캐싱 최적화                                    │
│ ✅ 이미지 크기 줄이기                                    │
│                                                         │
│ → "효율적으로" 만들 수 있음                             │
│ → 실무에서 바로 적용 가능                               │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 3단계: 고급 (1-2개월)                                    │
├─────────────────────────────────────────────────────────┤
│ □ BuildKit 활용                                         │
│ □ 멀티 아키텍처 빌드                                     │
│ □ 보안 스캔 자동화                                       │
│ □ 컨테이너 디자인 패턴                                   │
│                                                         │
│ → "전문가처럼" 만들 수 있음                             │
│ → 시니어 레벨 역량                                       │
└─────────────────────────────────────────────────────────┘
```

**왜 빨리 배워야 하나?**

```
이유 1: 기술 부채 방지
- 처음부터 잘 만들면 나중에 리팩토링 불필요
- "나중에 최적화하자" → 영원히 안 함

이유 2: 시간 절약
- 멀티스테이지 익히는 시간: 2시간
- 평생 절약하는 빌드 시간: 수백 시간

이유 3: 경력 발전
- 주니어: "Docker 쓸 줄 압니다"
- 중급: "Docker 최적화할 줄 압니다" ← 차별화!
- 연봉 차이: 1,000-2,000만원

이유 4: 실무 필수
- 대부분의 회사에서 멀티스테이지 사용
- 모르면 코드 리뷰에서 지적받음
```

**효율적인 학습 방법**:

```bash
# 1. 기존 Dockerfile 개선하기
# Before
FROM node:18
COPY . .
RUN npm install
CMD ["npm", "start"]

# After (2시간 학습 후)
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
USER node
CMD ["node", "dist/main.js"]

# 효과: 즉시 체감!
# - 이미지 크기: 1.2GB → 150MB
# - 빌드 시간: 5분 → 2분
```

**💡 핵심**: 기본을 익히자마자 고급 기능을 배우세요.
나중으로 미루면 레거시 코드가 쌓여서 더 힘듭니다!

</details>

<details>
<summary><strong>Q2: 실무에서 가장 많이 쓰는 고급 기능은 무엇인가요?</strong></summary>

**A**: **멀티스테이지 빌드 (95% 사용) > BuildKit (80%) > 보안 스캔 (70%)**

**상세 설명**:

**실무 사용 빈도 통계**:

| 기능 | 사용률 | 필수도 | 학습 우선순위 |
|------|--------|--------|---------------|
| 멀티스테이지 빌드 | 95% | ⭐⭐⭐⭐⭐ | 1순위 |
| .dockerignore | 90% | ⭐⭐⭐⭐⭐ | 1순위 |
| BuildKit 캐시 | 80% | ⭐⭐⭐⭐ | 2순위 |
| 보안 스캔 (Trivy) | 70% | ⭐⭐⭐⭐ | 2순위 |
| non-root 사용자 | 85% | ⭐⭐⭐⭐ | 2순위 |
| 헬스체크 | 75% | ⭐⭐⭐⭐ | 3순위 |
| 멀티 아키텍처 | 40% | ⭐⭐⭐ | 3순위 |
| 컨테이너 패턴 | 30% | ⭐⭐⭐ | 4순위 |

**1순위: 멀티스테이지 빌드 (필수!)**

```dockerfile
# 모든 프로덕션 Dockerfile에서 사용
FROM <build-image> AS builder
# 빌드 작업
...

FROM <runtime-image>
COPY --from=builder ...
# 프로덕션 실행
```

**사용 이유**:
- 이미지 크기 70-90% 감소 (비용 절감)
- 빌드 도구 제거 (보안 향상)
- 소스 코드 숨김 (IP 보호)

**2순위: BuildKit 캐시**

```dockerfile
# syntax=docker/dockerfile:1
RUN --mount=type=cache,target=/root/.npm \
    npm ci
```

**사용 이유**:
- 빌드 시간 50-70% 단축
- 개발 생산성 향상
- CI/CD 파이프라인 속도 향상

**3순위: 보안 스캔**

```bash
# CI/CD에 통합
trivy image --exit-code 1 --severity CRITICAL myapp:latest
```

**사용 이유**:
- 규제 준수 (GDPR, HIPAA)
- 보안 사고 방지
- 자동화된 품질 관리

**회사 규모별 사용 패턴**:

```
스타트업 (5-20명):
├─ 멀티스테이지: 100%
├─ .dockerignore: 80%
├─ BuildKit: 60%
└─ 보안 스캔: 40%

중견기업 (50-200명):
├─ 멀티스테이지: 100%
├─ .dockerignore: 95%
├─ BuildKit: 85%
├─ 보안 스캔: 80%
└─ 멀티 아키텍처: 50%

대기업 (500명+):
├─ 멀티스테이지: 100%
├─ .dockerignore: 100%
├─ BuildKit: 95%
├─ 보안 스캔: 100% (필수)
├─ 멀티 아키텍처: 80%
└─ 컨테이너 패턴: 60%
```

**학습 로드맵**:

```
Week 1: 멀티스테이지 빌드 + .dockerignore
→ 즉시 실무 적용 가능

Week 2-3: BuildKit + 레이어 캐싱 최적화
→ 빌드 속도 대폭 향상

Week 4: 보안 스캔 (Trivy) + non-root 사용자
→ 프로덕션 준비 완료

Month 2: 멀티 아키텍처 + 컨테이너 패턴
→ 고급 개발자 수준
```

**💡 핵심**: 멀티스테이지는 무조건 익히세요.
나머지는 필요에 따라 점진적으로!

</details>

<details>
<summary><strong>Q3: Docker 전문가가 되려면 얼마나 걸리나요?</strong></summary>

**A**: **기본 → 중급 (3개월) → 고급 (6개월) → 전문가 (1-2년)**

**상세 설명**:

**단계별 학습 로드맵**:

```
┌─────────────────────────────────────────────────────────┐
│ 주니어 (0-3개월)                                         │
├─────────────────────────────────────────────────────────┤
│ 목표: 기본 명령어 익히기                                 │
│                                                         │
│ Week 1-2: Docker 기초                                   │
│ □ docker run, stop, rm, ps                              │
│ □ 기본 Dockerfile 작성                                  │
│ □ 이미지 빌드 및 푸시                                    │
│                                                         │
│ Week 3-4: docker-compose                                │
│ □ 멀티 컨테이너 애플리케이션                             │
│ □ 네트워크, 볼륨 기초                                    │
│                                                         │
│ Week 5-8: 실전 프로젝트                                  │
│ □ 간단한 웹 앱 컨테이너화                                │
│ □ 데이터베이스 연동                                      │
│ □ 로컬 개발 환경 구축                                    │
│                                                         │
│ 📊 평가: 기본 앱을 Docker로 실행 가능                    │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 중급 (3-6개월)                                           │
├─────────────────────────────────────────────────────────┤
│ 목표: 최적화 및 모범 사례 적용                           │
│                                                         │
│ Month 4: 이미지 최적화                                   │
│ ✅ 멀티스테이지 빌드 마스터                              │
│ ✅ .dockerignore 활용                                   │
│ ✅ 레이어 캐싱 최적화                                    │
│ → 이미지 크기 70% 감소 달성                             │
│                                                         │
│ Month 5: 빌드 최적화                                     │
│ ✅ BuildKit 활용                                        │
│ ✅ 캐시 마운트                                           │
│ ✅ 병렬 빌드                                             │
│ → 빌드 시간 50% 단축 달성                               │
│                                                         │
│ Month 6: 보안 및 프로덕션 준비                           │
│ ✅ 보안 스캔 (Trivy)                                    │
│ ✅ non-root 사용자                                       │
│ ✅ 헬스체크 구현                                         │
│ → 프로덕션 배포 가능                                     │
│                                                         │
│ 📊 평가: 최적화되고 안전한 이미지 빌드 가능              │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 고급 (6-12개월)                                          │
├─────────────────────────────────────────────────────────┤
│ 목표: 복잡한 시스템 설계 및 문제 해결                    │
│                                                         │
│ Month 7-9: 고급 기능                                     │
│ □ 멀티 아키텍처 빌드                                     │
│ □ 컨테이너 디자인 패턴                                   │
│ □ 커스텀 빌더 구축                                       │
│ □ 네트워크 고급 설정                                     │
│                                                         │
│ Month 10-12: 프로덕션 운영                               │
│ □ 모니터링 및 로깅 시스템                                │
│ □ 성능 튜닝                                              │
│ □ 트러블슈팅 능력                                        │
│ □ CI/CD 파이프라인 구축                                  │
│                                                         │
│ 📊 평가: 복잡한 마이크로서비스 설계 가능                 │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 전문가 (1-2년)                                           │
├─────────────────────────────────────────────────────────┤
│ 목표: 아키텍처 설계 및 조직 리드                         │
│                                                         │
│ Year 2: 전문 영역                                        │
│ □ Kubernetes 마스터                                     │
│ □ 서비스 메시 (Istio, Linkerd)                          │
│ □ 보안 전문가 (런타임 보안)                              │
│ □ 성능 최적화 전문가                                     │
│ □ 클라우드 네이티브 아키텍처                             │
│                                                         │
│ 추가 활동:                                               │
│ □ 기술 블로그 작성                                       │
│ □ 오픈소스 기여                                          │
│ □ 컨퍼런스 발표                                          │
│ □ 팀 교육 및 멘토링                                      │
│                                                         │
│ 📊 평가: 조직의 Docker/K8s 전략 수립 가능                │
└─────────────────────────────────────────────────────────┘
```

**효율적 학습 방법**:

```
1. 매일 실습 (1-2시간)
   - 이론 30분
   - 실습 60-90분

2. 실전 프로젝트
   - 토이 프로젝트 Docker화
   - 기존 앱 마이그레이션

3. 커뮤니티 활동
   - Stack Overflow 답변
   - GitHub 이슈 참여
   - 블로그 작성

4. 자격증 준비
   - Docker Certified Associate (DCA)
   - Certified Kubernetes Administrator (CKA)
```

**시간 단축 팁**:

```
❌ 비효율적:
- 책만 읽기 (실습 없음)
- 튜토리얼만 따라하기
- 혼자서만 공부

✅ 효율적:
- 실제 프로젝트에 적용
- 동료와 코드 리뷰
- 온라인 커뮤니티 활용
- 멘토 찾기

결과:
- 비효율적: 2년
- 효율적: 1년 (2배 빠름!)
```

**💡 핵심**: 매일 조금씩 실습하면 1년 안에 전문가 수준 도달 가능!

</details>

<details>
<summary><strong>Q4: Docker 자격증(DCA)이 도움되나요?</strong></summary>

**A**: **취업/이직 시 유리하지만, 실무 능력이 더 중요합니다.**

**상세 설명**:

**Docker Certified Associate (DCA) 개요**:

```
시험 정보:
- 문제 수: 55문항
- 시간: 90분
- 합격 점수: 65% (약 36문제)
- 비용: $195 USD (약 26만원)
- 유효 기간: 2년
- 형식: 객관식 + 실습형

출제 영역:
1. Orchestration (25%)
   - 스웜 모드
   - 서비스, 스택, 네트워크

2. Image Creation (20%)
   - Dockerfile
   - 이미지 최적화
   - 레지스트리

3. Installation & Configuration (15%)
   - Docker 설치
   - 스토리지 드라이버
   - 로깅 드라이버

4. Networking (15%)
   - 네트워크 유형
   - 서비스 디스커버리

5. Security (15%)
   - RBAC
   - Secret 관리
   - Content Trust

6. Storage & Volumes (10%)
   - 볼륨 유형
   - 바인드 마운트
```

**장점**:

```
✅ 취업/이직 시 유리
- 이력서 차별화 (5% 미만 보유)
- 기술 면접 일부 면제
- 우대사항 충족

✅ 체계적 학습
- 전체 영역 커버
- 약점 발견
- 기초 탄탄

✅ 연봉 협상
- 자격증 수당: 월 10-30만원
- 초봉 협상력 향상

✅ 글로벌 인정
- Docker 공식 자격증
- 전 세계 통용
```

**단점**:

```
❌ 비용
- 시험: 26만원
- 준비 교재: 5-10만원
- 재시험 (불합격 시): 추가 26만원

❌ 시간 투자
- 준비 기간: 1-2개월
- 실무 경험 부족 시 어려움

❌ 실무와 괴리
- 스웜 모드 출제 (실무는 K8s)
- 실습보다 이론 위주
- 최신 기능 반영 느림
```

**추천 대상**:

```
🎯 자격증 추천:
1. 취업 준비생
   - 이력서 경쟁력 필요
   - 실무 경험 부족

2. 신입 개발자 (0-1년)
   - 기초 다지기
   - 회사 지원 가능

3. 이직 준비자
   - 기술 증명 필요
   - 연봉 협상

🚫 비추천:
1. 시니어 개발자 (5년+)
   - 실무 경력이 더 중요
   - 자격증 효과 미미

2. 실무 바쁜 경우
   - 시간 대비 효율 낮음
   - 프로젝트가 더 가치 있음
```

**실제 효과 (설문 조사)**:

| 상황 | 자격증 있음 | 자격증 없음 | 차이 |
|------|------------|------------|------|
| 서류 통과율 | 40% | 30% | +10%p |
| 초봉 (신입) | 4,200만원 | 4,000만원 | +200만원 |
| 면접 질문 수 | 8개 | 12개 | -4개 |
| 기술 증명 | 쉬움 | 어려움 | - |

**대안**:

```
자격증 대신 추천:

1. 실전 프로젝트
   - GitHub 포트폴리오
   - 기여한 오픈소스
   → 실무 능력 증명

2. 기술 블로그
   - Docker 관련 글 작성
   - 문제 해결 사례
   → 전문성 증명

3. 기여 활동
   - Stack Overflow 답변
   - GitHub 이슈 해결
   → 커뮤니티 활동

4. 회사 프로젝트
   - 실제 성과 (이미지 90% 축소)
   - 비용 절감 사례
   → 비즈니스 가치 증명
```

**결론**:

```
신입 (0-2년):
→ 자격증 + 프로젝트 (둘 다 준비)
→ 자격증으로 서류 통과, 프로젝트로 면접 통과

중급 (2-5년):
→ 프로젝트 > 자격증
→ 실무 경력이 더 중요

시니어 (5년+):
→ 자격증 불필요
→ 실적과 리더십이 중요
```

**💡 핵심**:
- 신입: 자격증 도움됨 (서류 통과율 +10%)
- 경력: 실무 프로젝트가 훨씬 중요!

</details>

<details>
<summary><strong>Q5: 다음에는 무엇을 학습해야 하나요?</strong></summary>

**A**: **Kubernetes → 클라우드 네이티브 → 서비스 메시 순서로 학습하세요.**

**상세 설명**:

**학습 로드맵**:

```
┌─────────────────────────────────────────────────────────┐
│ 현재: Docker 마스터 ✅                                    │
├─────────────────────────────────────────────────────────┤
│ □ Docker 기본 명령어                                     │
│ □ Dockerfile 작성                                       │
│ □ docker-compose                                        │
│ □ 멀티스테이지 빌드                                      │
│ □ 이미지 최적화                                          │
│ □ 보안 모범 사례                                         │
└─────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────┐
│ 다음: Kubernetes (3-6개월)                               │
├─────────────────────────────────────────────────────────┤
│ 왜 필요한가?                                             │
│ - Docker는 단일 호스트                                   │
│ - Kubernetes는 클러스터 관리                             │
│ - 프로덕션 표준 (95% 채택률)                             │
│                                                         │
│ Month 1-2: 기본                                          │
│ □ Pod, Deployment, Service                              │
│ □ ConfigMap, Secret                                     │
│ □ Namespace, Labels                                     │
│                                                         │
│ Month 3-4: 중급                                          │
│ □ StatefulSet, DaemonSet                                │
│ □ Ingress, NetworkPolicy                                │
│ □ PersistentVolume                                      │
│                                                         │
│ Month 5-6: 고급                                          │
│ □ Helm 차트                                              │
│ □ 커스텀 리소스 (CRD)                                    │
│ □ Operator 패턴                                          │
│                                                         │
│ 📚 학습 자료:                                            │
│ - "Kubernetes in Action" (책)                           │
│ - Kubernetes 공식 문서                                   │
│ - CKA 자격증 준비                                        │
│                                                         │
│ 🎯 목표: 마이크로서비스 클러스터 운영 가능                │
└─────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────┐
│ 그 다음: 클라우드 네이티브 (3-6개월)                     │
├─────────────────────────────────────────────────────────┤
│ 왜 필요한가?                                             │
│ - 클라우드 환경에서 최적화                               │
│ - 확장성, 탄력성, 관찰성                                 │
│ - 업계 표준 아키텍처                                     │
│                                                         │
│ Month 1-2: 관찰성 (Observability)                        │
│ □ Prometheus (메트릭)                                   │
│ □ Grafana (시각화)                                      │
│ □ Loki (로그)                                           │
│ □ Jaeger (분산 추적)                                    │
│                                                         │
│ Month 3-4: CI/CD                                         │
│ □ GitOps (ArgoCD, Flux)                                 │
│ □ 파이프라인 자동화                                      │
│ □ 카나리/블루-그린 배포                                  │
│                                                         │
│ Month 5-6: 클라우드 플랫폼                               │
│ □ AWS EKS / GCP GKE / Azure AKS                         │
│ □ 관리형 서비스 활용                                     │
│ □ 비용 최적화                                            │
│                                                         │
│ 🎯 목표: 클라우드에서 프로덕션 운영 가능                  │
└─────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────┐
│ 고급: 서비스 메시 (2-3개월, 선택)                        │
├─────────────────────────────────────────────────────────┤
│ 왜 필요한가?                                             │
│ - 복잡한 마이크로서비스 통신 관리                        │
│ - 트래픽 제어, 보안, 관찰성                              │
│ - 대규모 시스템 (100+ 서비스)                            │
│                                                         │
│ Month 1-2: Istio / Linkerd                               │
│ □ 트래픽 관리                                            │
│ □ mTLS (서비스 간 암호화)                                │
│ □ 서킷 브레이커                                          │
│ □ 카나리 배포 고급                                       │
│                                                         │
│ 🎯 목표: 엔터프라이즈급 아키텍처 설계 가능                │
└─────────────────────────────────────────────────────────┘
```

**학습 우선순위**:

```
필수 (모두 배워야 함):
1. Kubernetes ⭐⭐⭐⭐⭐
   - 프로덕션 표준
   - 모든 회사에서 사용

2. CI/CD (GitOps) ⭐⭐⭐⭐⭐
   - 자동화 필수
   - 생산성 향상

3. 모니터링 (Prometheus/Grafana) ⭐⭐⭐⭐⭐
   - 운영 필수
   - 장애 대응

권장 (중급 이상):
4. Helm ⭐⭐⭐⭐
   - K8s 패키지 관리
   - 재사용성

5. 클라우드 (AWS/GCP/Azure) ⭐⭐⭐⭐
   - 실무 환경
   - 관리형 서비스

선택 (고급):
6. 서비스 메시 (Istio) ⭐⭐⭐
   - 대규모 시스템
   - 복잡한 요구사항

7. Serverless ⭐⭐⭐
   - 특정 워크로드
   - 비용 최적화
```

**경력별 추천**:

```
주니어 (0-2년):
→ Docker → Kubernetes 기본 → CI/CD
→ 목표: K8s에 앱 배포 가능

중급 (2-5년):
→ Kubernetes 고급 → Helm → 모니터링 → 클라우드
→ 목표: 프로덕션 운영 가능

시니어 (5년+):
→ 아키텍처 설계 → 서비스 메시 → 플랫폼 엔지니어링
→ 목표: 전사 플랫폼 설계
```

**학습 자료**:

```
Kubernetes:
📘 "Kubernetes in Action" by Marko Luksa
🎓 Udemy - "Kubernetes for Absolute Beginners"
🏆 CKA (Certified Kubernetes Administrator)

클라우드 네이티브:
📘 "Cloud Native DevOps with Kubernetes"
🎓 CNCF 공식 교육
🏆 AWS Solutions Architect

모니터링:
📘 "Prometheus Up & Running"
🎓 Grafana 공식 튜토리얼
🏆 Prometheus Certified Associate (PCA)
```

**실전 프로젝트 아이디어**:

```
1. 개인 블로그를 K8s에 배포
   - Deployment, Service, Ingress
   - Prometheus로 모니터링
   - GitOps로 자동 배포

2. 마이크로서비스 앱 구축
   - 3-5개 서비스
   - 서비스 간 통신
   - 분산 추적

3. 클라우드 마이그레이션
   - 로컬 → AWS EKS
   - 비용 최적화
   - 고가용성 구성
```

**타임라인 예시**:

```
Month 0: Docker 마스터 (지금!)

Month 1-3: Kubernetes 기본
- Minikube로 실습
- 간단한 앱 배포

Month 4-6: Kubernetes 고급 + Helm
- StatefulSet으로 DB 배포
- Helm 차트 작성

Month 7-9: 모니터링 + CI/CD
- Prometheus/Grafana 구축
- ArgoCD로 GitOps

Month 10-12: 클라우드 + 프로젝트
- AWS EKS 배포
- 실전 프로젝트 완성

📊 1년 후: 클라우드 네이티브 엔지니어!
```

**💡 핵심**:
- Docker 다음은 무조건 Kubernetes!
- 순서대로 차근차근 학습하면 1-2년 안에 전문가!

</details>

---

## 📝 면접 질문

### 주니어 레벨

**Q1: 멀티스테이지 빌드가 무엇이고, 왜 사용하나요?**

**A**: 빌드 환경과 런타임 환경을 분리하여 **이미지 크기를 줄이고 보안을 향상**시키는 기법입니다.

**상세 답변**:

```dockerfile
# 멀티스테이지 빌드 예시
# 1단계: 빌드 스테이지
FROM gradle:8.5-jdk17 AS builder
WORKDIR /app
COPY . .
RUN gradle build --no-daemon

# 2단계: 런타임 스테이지
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar
USER appuser
ENTRYPOINT ["java", "-jar", "app.jar"]
```

**장점**:

1. **이미지 크기 대폭 감소**
   - Before: 2GB (Gradle + JDK + 소스 코드 포함)
   - After: 200MB (JRE + JAR만 포함)
   - 90% 감소!

2. **보안 향상**
   - 빌드 도구 제거 (공격 표면 감소)
   - 소스 코드 숨김 (IP 보호)
   - 빌드 캐시 제거

3. **비용 절감**
   - 스토리지 비용 감소
   - 네트워크 전송 비용 감소
   - 배포 시간 단축

**핵심 포인트**:
- 첫 번째 FROM = 빌드 스테이지
- 두 번째 FROM = 프로덕션 스테이지
- COPY --from=builder로 빌드 결과물만 복사

---

**Q2: .dockerignore 파일의 역할은 무엇인가요?**

**A**: **빌드 컨텍스트에서 불필요한 파일을 제외**하여 빌드 속도를 높이고 이미지 크기를 줄입니다.

**상세 답변**:

```bash
# .dockerignore 예시
.git
.gitignore
node_modules/
npm-debug.log
README.md
.env
*.md
.vscode/
.idea/
test/
*.test.js
```

**효과**:

**Before (.dockerignore 없음)**:
```bash
$ docker build -t myapp:latest .
Sending build context to Docker daemon  1.2GB  # 😱
Step 1/5 : FROM node:18-alpine
...
```

**After (.dockerignore 사용)**:
```bash
$ docker build -t myapp:latest .
Sending build context to Docker daemon  45MB  # 🎉 96% 감소!
Step 1/5 : FROM node:18-alpine
...
```

**장점**:

1. **빌드 속도 향상**
   - 전송 데이터 96% 감소
   - 빌드 시간 50% 단축

2. **이미지 크기 감소**
   - 불필요한 파일 제외
   - node_modules, .git 제외

3. **보안**
   - .env, secrets/ 제외
   - 민감 정보 유출 방지

**실전 팁**:
```bash
# 현재 빌드 컨텍스트 크기 확인
$ tar -czf - . | wc -c
1258291200  # 1.2GB

# .dockerignore 추가 후
$ tar -czf - . | wc -c
47185920  # 45MB (96% 감소!)
```

---

### 중급 레벨

**Q3: BuildKit의 캐시 마운트는 어떻게 동작하며, 언제 사용하나요?**

**A**: **빌드 간에 캐시를 공유**하여 의존성 다운로드 시간을 대폭 단축하는 기능입니다.

**상세 답변**:

**일반 빌드 (캐시 마운트 없음)**:
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install  # 매번 전체 다운로드 (5분)
```

**캐시 마운트 사용**:
```dockerfile
# syntax=docker/dockerfile:1
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN --mount=type=cache,target=/root/.npm \
    npm install  # 첫 빌드: 5분, 이후: 30초!
```

**동작 원리**:

```
┌─────────────────────────────────────────────┐
│ 호스트 머신                                  │
├─────────────────────────────────────────────┤
│ /var/lib/docker/buildkit/cache/             │
│ └─ npm/                                     │
│    ├─ lodash-4.17.21.tgz                    │
│    ├─ express-4.18.2.tgz                    │
│    └─ ... (다운로드된 패키지 캐시)           │
└─────────────────────────────────────────────┘
           ↕ (재사용)
┌─────────────────────────────────────────────┐
│ 빌드 컨테이너                                │
├─────────────────────────────────────────────┤
│ /root/.npm/ (마운트됨)                       │
│ └─ 캐시 재사용!                             │
└─────────────────────────────────────────────┘
```

**성능 비교**:

| 상황 | 일반 빌드 | 캐시 마운트 | 개선 |
|------|----------|------------|------|
| 첫 빌드 | 5분 | 5분 | 동일 |
| package.json 동일 | 5분 | 30초 | **90%↓** |
| 일부 의존성 변경 | 5분 | 1분 30초 | 70%↓ |

**사용 사례**:

```dockerfile
# 1. npm/yarn 캐시
RUN --mount=type=cache,target=/root/.npm \
    npm ci

# 2. pip 캐시
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.txt

# 3. Go 모듈 캐시
RUN --mount=type=cache,target=/go/pkg/mod \
    go mod download

# 4. Maven/Gradle 캐시
RUN --mount=type=cache,target=/root/.gradle \
    gradle build --no-daemon
```

**핵심 포인트**:
- 첫 빌드: 캐시 생성
- 이후 빌드: 캐시 재사용
- package.json 변경 안 하면 다운로드 스킵!

---

**Q4: 멀티 아키텍처 이미지가 필요한 이유와 빌드 방법을 설명하세요.**

**A**: **다양한 CPU 아키텍처(ARM/AMD64)에서 최적 성능**을 내기 위해 필요합니다.

**상세 답변**:

**배경**:
```
CPU 아키텍처의 다양화:
- Intel/AMD: x86_64 (amd64)
- Apple M1/M2: ARM64
- AWS Graviton: ARM64
- Raspberry Pi: ARM32

문제:
- AMD64 이미지를 ARM64에서 실행 → 에뮬레이션 (10배 느림)
- ARM64 이미지를 AMD64에서 실행 → 에러
```

**해결: 멀티 아키텍처 이미지**:

```bash
# Docker Buildx로 멀티 아키텍처 빌드
$ docker buildx create --name multiarch --use
$ docker buildx build \
    --platform linux/amd64,linux/arm64 \
    -t username/myapp:latest \
    --push \
    .

# 결과: 하나의 태그에 여러 아키텍처
username/myapp:latest
├─ Manifest (linux/amd64)
└─ Manifest (linux/arm64)

# Docker가 자동으로 올바른 이미지 선택!
```

**Dockerfile 최적화**:
```dockerfile
# syntax=docker/dockerfile:1
FROM --platform=$BUILDPLATFORM golang:1.21-alpine AS builder

ARG TARGETOS
ARG TARGETARCH

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN GOOS=$TARGETOS GOARCH=$TARGETARCH \
    go build -o /app/main .

FROM alpine:latest
COPY --from=builder /app/main /main
ENTRYPOINT ["/main"]
```

**성능 비교 (M1 Mac)**:

| 이미지 유형 | 시작 시간 | CPU 사용 | 응답 시간 |
|------------|----------|----------|----------|
| AMD64 (에뮬레이션) | 10초 | 80% | 500ms |
| ARM64 (네이티브) | 1초 | 8% | 50ms |
| **개선** | **90%↓** | **90%↓** | **90%↓** |

**사용 사례**:

1. **팀 내 다양한 개발 환경**
   - Intel Mac + M1 Mac
   - Linux 서버 + Apple Silicon

2. **클라우드 비용 절감**
   - AWS Graviton (ARM): AMD64 대비 40% 저렴
   - 성능도 동등 이상

3. **엣지 컴퓨팅**
   - IoT 기기 (ARM)
   - Raspberry Pi

**핵심 포인트**:
- 멀티 아키텍처 = 하나의 이미지 태그, 여러 플랫폼 지원
- Docker가 자동으로 올바른 아키텍처 선택
- 성능 향상 + 비용 절감

---

**Q5: 프로덕션 배포 전 필수 체크리스트는 무엇인가요?**

**A**: **보안, 성능, 안정성 3가지 영역을 체계적으로 검증**해야 합니다.

**상세 답변**:

**1. 보안 체크리스트**:
```bash
□ 이미지 보안 스캔 (Trivy)
  $ trivy image --severity CRITICAL,HIGH myapp:latest
  → 취약점 0개 확인

□ non-root 사용자
  $ docker inspect myapp:latest | jq '.[0].Config.User'
  → "1000:1000" (root 아님)

□ 읽기 전용 루트 파일시스템
  readOnlyRootFilesystem: true

□ Secret 관리
  $ grep -r "password" .  # 하드코딩 확인
  → 환경 변수 또는 Secret으로 관리

□ 최소 권한
  capabilities:
    drop: [ALL]
```

**2. 성능 체크리스트**:
```bash
□ 이미지 크기
  $ docker images myapp:latest
  → 500MB 이하 목표

□ 레이어 수
  $ docker history myapp:latest | wc -l
  → 20개 이하 권장

□ 리소스 제한
  resources:
    requests:
      cpu: "500m"
      memory: "512Mi"
    limits:
      cpu: "1000m"
      memory: "1Gi"

□ 빌드 시간
  $ time docker build -t myapp:latest .
  → 5분 이내 목표
```

**3. 안정성 체크리스트**:
```bash
□ 헬스체크 구현
  healthcheck:
    test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
    interval: 30s
    timeout: 3s
    retries: 3

□ 그레이스풀 셧다운
  server:
    shutdown: graceful
  terminationGracePeriodSeconds: 30

□ 로그 구조화
  {
    "timestamp": "2025-09-30T10:15:32Z",
    "level": "INFO",
    "message": "User login",
    "userId": 123
  }

□ 메트릭 수집
  /actuator/prometheus
  → Prometheus 스크랩 가능

□ 재시작 정책
  restart: always
  또는
  restart_policy:
    condition: on-failure
    max_attempts: 3
```

**4. 문서 체크리스트**:
```bash
□ README.md
  - 빌드 방법
  - 실행 방법
  - 환경 변수 설명

□ docker-compose.yml 주석
  - 각 서비스 역할
  - 포트 매핑 이유
  - 볼륨 사용 목적

□ 트러블슈팅 가이드
  - 일반적인 문제와 해결법
  - 로그 확인 방법
```

**자동화된 체크**:

```yaml
# .github/workflows/pre-deploy.yml
name: Pre-Deploy Checks

on: [push]

jobs:
  checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build image
        run: docker build -t myapp:${{ github.sha }} .

      - name: Security scan
        run: |
          trivy image --exit-code 1 --severity CRITICAL \
            myapp:${{ github.sha }}

      - name: Image size check
        run: |
          SIZE=$(docker images myapp:${{ github.sha }} --format "{{.Size}}")
          echo "Image size: $SIZE"
          # 500MB 초과 시 경고

      - name: Healthcheck test
        run: |
          docker run -d --name test myapp:${{ github.sha }}
          sleep 10
          docker inspect test --format='{{.State.Health.Status}}'
          # "healthy" 확인

      - name: All checks passed ✅
        run: echo "Ready for production!"
```

**실전 예시**:

```bash
# 배포 전 최종 체크
$ ./scripts/pre-deploy-check.sh myapp:latest

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Pre-Deploy Checklist
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[✅] Security scan: No vulnerabilities
[✅] Image size: 210MB (OK)
[✅] Non-root user: 1000:1000
[✅] Healthcheck: Implemented
[✅] Resources: Limits set
[✅] Graceful shutdown: Configured
[✅] Structured logging: Enabled
[✅] Metrics: /actuator/prometheus

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
All checks passed! ✅
Ready for production deployment! 🚀
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

**핵심 포인트**:
- 배포 전 체크리스트는 CI/CD에 통합
- 자동화로 휴먼 에러 방지
- 하나라도 실패하면 배포 차단

---

## 다음 단계

### 35. 실전 예제 및 사례 연구
- 대규모 마이크로서비스 아키텍처
- 레거시 시스템 마이그레이션
- 멀티 클라우드 전략

### 학습 자료

**공식 문서**:
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Dockerfile 모범 사례](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [BuildKit 문서](https://docs.docker.com/build/buildkit/)

**도구**:
- [Trivy](https://github.com/aquasecurity/trivy) - 보안 스캔
- [hadolint](https://github.com/hadolint/hadolint) - Dockerfile 린터
- [dive](https://github.com/wagoodman/dive) - 이미지 분석

**커뮤니티**:
- [Docker Community](https://www.docker.com/community/)
- [CNCF Slack](https://slack.cncf.io/)

---

**축하합니다! 🎉** Docker 고급 주제와 모범 사례 마스터!
