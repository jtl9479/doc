# 21. 디버깅 및 트러블슈팅

> **학습 목표**: Docker 컨테이너, 네트워크, 볼륨 등에서 발생하는 다양한 문제를 체계적으로 진단하고 해결할 수 있으며, 효율적인 디버깅 워크플로우를 익힐 수 있습니다.

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐⭐☆ (4개/5개)

---

## 목차
1. [Docker 디버깅 기초](#docker-디버깅-기초)
2. [컨테이너 로그 분석](#컨테이너-로그-분석)
3. [컨테이너 내부 검사](#컨테이너-내부-검사)
4. [네트워크 디버깅](#네트워크-디버깅)
5. [성능 문제 진단](#성능-문제-진단)
6. [이미지 문제 해결](#이미지-문제-해결)
7. [볼륨 문제 해결](#볼륨-문제-해결)
8. [일반적인 오류 패턴](#일반적인-오류-패턴)
9. [고급 디버깅 기법](#고급-디버깅-기법)
10. [트러블슈팅 체크리스트](#트러블슈팅-체크리스트)

---

## 💡 왜 Docker 디버깅 기술이 필요한가?

### 실무 배경

**"프로덕션에서 갑자기 컨테이너가 죽었습니다. 어떻게 하죠?"**

#### ❌ 디버깅 기술이 없으면 발생하는 문제

```
문제 1: 무작정 재시작만 반복
- 증상: 컨테이너가 계속 죽음
- 대응: docker restart 무한 반복
- 영향: 근본 원인 해결 안 됨, 서비스 다운타임 지속
- 비용: 시간당 수백만원 손실

문제 2: 로그 확인 방법 몰라 헤맴
- 증상: "로그를 어디서 봐야 하나요?"
- 대응: 구글링하며 시간 낭비
- 영향: 장애 대응 지연
- 비용: 평균 해결 시간 4시간 → 15분으로 단축 필요

문제 3: 네트워크 문제 진단 불가
- 증상: "컨테이너 간 통신이 안 돼요"
- 대응: 포트를 이것저것 바꿔봄
- 영향: 랜덤한 시도로 시간 낭비
- 비용: 개발자 1명 하루 허비 (약 20만원)
```

#### ✅ 체계적 디버깅 기술을 익히면

```
해결책 1: 5분 내 원인 파악
- 방법: docker logs → inspect → exec 워크플로우
- 효과: 평균 해결 시간 4시간 → 15분
- 절감: 시간당 대응 비용 96% 절감

해결책 2: 근본 원인 해결
- 방법: 증상이 아닌 원인 분석
- 효과: 재발 방지, 시스템 안정성 향상
- 절감: 장애 발생 빈도 80% 감소

해결책 3: 자신감 있는 문제 해결
- 방법: 체크리스트 기반 체계적 접근
- 효과: 야간 긴급 콜 감소
- 절감: 개발자 삶의 질 향상 🎉
```

### 수치로 보는 효과

| 지표 | Before | After | 개선율 |
|------|--------|-------|--------|
| 평균 장애 해결 시간 | 4시간 | 15분 | **94%↓** |
| 재발률 | 50% | 5% | **90%↓** |
| 야간 긴급 콜 | 월 10회 | 월 1회 | **90%↓** |
| 원인 미파악 장애 | 30% | 2% | **93%↓** |
| 개발자 스트레스 | 높음 | 보통 | **70%↓** |

---

## 🔍 실생활 비유로 이해하기

### 비유 1: 탐정의 사건 수사

```
탐정 셜록 홈즈가 사건을 해결하는 방법:

1. 현장 조사 (docker ps, docker logs)
   - "무슨 일이 일어났는가?"
   - 증거 수집 (로그, 상태)

2. 단서 분석 (docker inspect)
   - "정확히 어떤 상태인가?"
   - 세부 정보 파악

3. 가설 수립
   - "이런 증상이면 원인은 X일 것이다"

4. 검증 (docker exec, docker stats)
   - 가설 확인
   - 추가 정보 수집

5. 해결
   - 근본 원인 제거
   - 재발 방지 조치

Docker 디버깅도 동일한 프로세스:
증상 발견 → 단서 수집 → 가설 수립 → 검증 → 해결
```

### 비유 2: 의사의 환자 진단

```
환자(컨테이너)가 아프다고 왔을 때 의사가 하는 일:

┌────────────────────────────────────────┐
│ 1. 문진 (docker ps -a)                 │
│    "언제부터 아팠나요?"                 │
│    "어디가 아프세요?"                   │
├────────────────────────────────────────┤
│ 2. 증상 확인 (docker logs)             │
│    체온, 혈압, 맥박 측정                │
│    → 로그에서 에러 메시지 확인          │
├────────────────────────────────────────┤
│ 3. 정밀 검사 (docker inspect)          │
│    X-ray, CT, 혈액 검사                │
│    → 상세 설정, 환경 변수 확인          │
├────────────────────────────────────────┤
│ 4. 내부 검진 (docker exec)             │
│    내시경으로 직접 확인                 │
│    → 컨테이너 내부 직접 진입            │
├────────────────────────────────────────┤
│ 5. 처방 (문제 해결)                    │
│    원인 파악 후 치료                    │
│    → 설정 수정, 재시작, 재배포          │
└────────────────────────────────────────┘

💡 핵심: 증상만 보고 처방하지 말 것!
         근본 원인을 찾아야 재발 방지
```

### 비유 3: 자동차 정비사의 차량 점검

```
차(컨테이너)에 이상이 있을 때 정비사의 접근법:

시나리오: 차 시동이 안 걸림

❌ 초보 정비사:
"배터리가 문제인가봐요" (추측)
→ 배터리 교체 (비용 낭비)
→ 여전히 시동 안 걸림
→ "그럼 엔진인가?"
→ 무작정 시도...

✅ 숙련 정비사 (체계적 디버깅):

1. 계기판 확인 (docker ps)
   - 경고등 확인
   - 현재 상태 파악

2. 진단기 연결 (docker logs)
   - 에러 코드 확인
   - "P0171: 연료 부족"

3. 상세 점검 (docker inspect)
   - 연료 탱크 확인
   - 연료 펌프 확인
   - 필터 상태 확인

4. 직접 확인 (docker exec)
   - 후드 열고 직접 보기
   - 부품 하나하나 점검

5. 수리 및 예방 (문제 해결)
   - 연료 필터 교체
   - 정기 점검 일정 수립

Docker 디버깅 워크플로우:
상태 확인 → 로그 분석 → 상세 검사 → 내부 점검 → 해결
```

---

## Docker 디버깅 기초

### 기본 디버깅 명령어

```bash
# 1. 컨테이너 상태 확인
docker ps -a

# 2. 컨테이너 로그 확인
docker logs <container_id>

# 3. 컨테이너 상세 정보
docker inspect <container_id>

# 4. 컨테이너 내부 접속
docker exec -it <container_id> sh

# 5. 프로세스 확인
docker top <container_id>

# 6. 리소스 사용량
docker stats <container_id>

# 7. 파일 시스템 변경 사항
docker diff <container_id>

# 8. 이벤트 모니터링
docker events
```

### 디버깅 워크플로우

```
문제 발생
    ↓
1. docker ps -a (상태 확인)
    ↓
    컨테이너가 실행 중인가?
    ├─ Yes → 2. docker logs (로그 확인)
    │           ↓
    │        에러 메시지 확인
    │           ↓
    │        3. docker exec (내부 진입)
    │           ↓
    │        환경 변수, 파일, 네트워크 확인
    │
    └─ No → Exit Code 확인
              ↓
           docker logs (종료 원인)
              ↓
           Dockerfile/compose 검토
```

---

## 컨테이너 로그 분석

### 로그 확인 명령어

```bash
# 기본 로그 확인
docker logs <container_id>

# 실시간 로그 (tail -f)
docker logs -f <container_id>

# 최근 N줄만 확인
docker logs --tail 100 <container_id>

# 타임스탬프 포함
docker logs -t <container_id>

# 특정 시간 이후 로그
docker logs --since 2024-01-01T10:00:00 <container_id>

# 최근 1시간 로그
docker logs --since 1h <container_id>

# 특정 시간 이전 로그
docker logs --until 2024-01-01T12:00:00 <container_id>
```

### docker-compose 로그

```bash
# 모든 서비스 로그
docker-compose logs

# 특정 서비스 로그
docker-compose logs user-service

# 실시간 로그
docker-compose logs -f

# 최근 50줄
docker-compose logs --tail 50

# 여러 서비스 동시에
docker-compose logs user-service account-service
```

### 로그 필터링 및 분석

```bash
# grep으로 에러만 필터링
docker logs container_id 2>&1 | grep -i error

# 특정 패턴 검색
docker logs container_id 2>&1 | grep "connection refused"

# 에러 카운트
docker logs container_id 2>&1 | grep -c ERROR

# 여러 패턴 검색
docker logs container_id 2>&1 | grep -E "ERROR|FATAL|Exception"

# 타임라인 분석 (시간별 에러 수)
docker logs -t container_id 2>&1 | grep ERROR | awk '{print $1}' | uniq -c
```

### 로그 레벨별 분석

```bash
#!/bin/bash
# scripts/analyze-logs.sh

CONTAINER_ID=$1

echo "📊 로그 분석: $CONTAINER_ID"
echo ""

# 총 로그 라인 수
TOTAL=$(docker logs $CONTAINER_ID 2>&1 | wc -l)
echo "총 로그 라인: $TOTAL"

# 에러 레벨별 카운트
echo ""
echo "에러 레벨별 통계:"
echo "  ERROR:   $(docker logs $CONTAINER_ID 2>&1 | grep -c ERROR)"
echo "  WARN:    $(docker logs $CONTAINER_ID 2>&1 | grep -c WARN)"
echo "  INFO:    $(docker logs $CONTAINER_ID 2>&1 | grep -c INFO)"
echo "  DEBUG:   $(docker logs $CONTAINER_ID 2>&1 | grep -c DEBUG)"

# 최근 에러 메시지 (최근 5개)
echo ""
echo "최근 에러 메시지 (최근 5개):"
docker logs $CONTAINER_ID 2>&1 | grep ERROR | tail -5
```

### 로그 드라이버 설정

```yaml
# docker-compose.yml

services:
  user-service:
    image: user-service:latest
    logging:
      driver: json-file
      options:
        max-size: "10m"      # 최대 파일 크기
        max-file: "3"        # 최대 파일 개수
        labels: "service"
        env: "ENV,APP_VERSION"

  # syslog로 전송
  account-service:
    image: account-service:latest
    logging:
      driver: syslog
      options:
        syslog-address: "tcp://192.168.1.100:514"
        tag: "account-service"

  # fluentd로 전송
  trade-service:
    image: trade-service:latest
    logging:
      driver: fluentd
      options:
        fluentd-address: localhost:24224
        tag: trade-service
```

---

## 컨테이너 내부 검사

### 컨테이너 접속

```bash
# sh/bash 셸 실행
docker exec -it <container_id> sh
docker exec -it <container_id> bash

# 특정 명령어 실행
docker exec <container_id> ls -la /app
docker exec <container_id> cat /app/config.json
docker exec <container_id> ps aux

# 루트 권한으로 실행
docker exec -u root -it <container_id> sh

# 환경 변수 확인
docker exec <container_id> env

# 작업 디렉토리 지정
docker exec -w /app <container_id> ls -la
```

### 파일 시스템 검사

```bash
# 컨테이너 내부에서
$ ls -la /app
$ cat /app/config/application.yml
$ find /app -name "*.jar"
$ df -h  # 디스크 사용량

# 파일 존재 확인
docker exec container_id test -f /app/app.jar && echo "exists" || echo "not found"

# 디렉토리 구조 확인
docker exec container_id tree /app

# 파일 권한 확인
docker exec container_id ls -l /app/app.jar
```

### 프로세스 검사

```bash
# 실행 중인 프로세스
docker top <container_id>

# 컨테이너 내부에서 상세 확인
docker exec <container_id> ps aux
docker exec <container_id> ps -ef

# 특정 프로세스 검색
docker exec <container_id> ps aux | grep java

# 포트 리스닝 확인
docker exec <container_id> netstat -tuln

# 또는
docker exec <container_id> ss -tuln
```

### 환경 변수 검사

```bash
# 모든 환경 변수
docker exec <container_id> env

# 특정 환경 변수
docker exec <container_id> printenv DATABASE_URL

# docker inspect로 확인
docker inspect <container_id> | jq '.[0].Config.Env'

# docker-compose 환경 변수
docker-compose config
```

### 네트워크 인터페이스 검사

```bash
# IP 주소 확인
docker exec <container_id> ip addr

# 또는
docker exec <container_id> ifconfig

# 라우팅 테이블
docker exec <container_id> ip route

# DNS 확인
docker exec <container_id> cat /etc/resolv.conf

# 네트워크 연결 테스트
docker exec <container_id> ping -c 3 google.com
docker exec <container_id> curl -I https://google.com
```

---

## 네트워크 디버깅

### 컨테이너 간 통신 테스트

```bash
# 1. 컨테이너 IP 확인
docker inspect <container_id> | grep IPAddress

# 2. ping 테스트
docker exec container_a ping -c 3 container_b

# 3. 포트 연결 테스트
docker exec container_a nc -zv container_b 8080

# 또는 telnet
docker exec container_a telnet container_b 8080

# 4. HTTP 요청 테스트
docker exec container_a curl http://container_b:8080/health
```

### 네트워크 정보 확인

```bash
# Docker 네트워크 목록
docker network ls

# 네트워크 상세 정보
docker network inspect bridge

# 특정 네트워크에 연결된 컨테이너
docker network inspect my-network | jq '.[0].Containers'

# 컨테이너가 속한 네트워크
docker inspect container_id | jq '.[0].NetworkSettings.Networks'
```

### DNS 해석 문제

```bash
# 컨테이너 내부에서 DNS 테스트
docker exec container_id nslookup postgres
docker exec container_id dig postgres

# /etc/hosts 확인
docker exec container_id cat /etc/hosts

# DNS 서버 확인
docker exec container_id cat /etc/resolv.conf

# 커스텀 DNS 사용
docker run --dns 8.8.8.8 --dns 8.8.4.4 myapp:latest
```

### 포트 매핑 문제

```bash
# 포트 매핑 확인
docker port <container_id>

# 호스트에서 포트 사용 중 확인
netstat -tuln | grep 8080
# Windows
netstat -ano | findstr :8080

# 컨테이너 내부 포트 리스닝 확인
docker exec <container_id> netstat -tuln | grep 8080

# 방화벽 확인 (Linux)
sudo iptables -L -n | grep 8080

# 포트 포워딩 테스트
curl http://localhost:8080/health
```

### 네트워크 격리 문제

```yaml
# docker-compose.yml

services:
  frontend:
    networks:
      - frontend-net
      - backend-net  # 양쪽 네트워크 접근

  backend:
    networks:
      - backend-net
      - database-net

  database:
    networks:
      - database-net  # 데이터베이스 네트워크만

networks:
  frontend-net:
  backend-net:
  database-net:
```

**네트워크 연결 테스트**:

```bash
# frontend가 backend에 접근 가능한가?
docker-compose exec frontend ping backend

# backend가 database에 접근 가능한가?
docker-compose exec backend ping database

# frontend가 database에 직접 접근 불가능 (의도된 동작)
docker-compose exec frontend ping database
# ping: bad address 'database'
```

### 네트워크 디버깅 도구 설치

```bash
# 알파인 기반 컨테이너에 도구 설치
docker exec -u root container_id apk add --no-cache \
    curl \
    bind-tools \
    netcat-openbsd \
    tcpdump

# 데비안/우분투 기반
docker exec -u root container_id apt-get update && \
    apt-get install -y curl dnsutils netcat tcpdump
```

### 패킷 캡처

```bash
# 컨테이너 네트워크 인터페이스 확인
docker exec container_id ip link

# tcpdump로 패킷 캡처
docker exec container_id tcpdump -i eth0 -w /tmp/capture.pcap

# 특정 포트만 캡처
docker exec container_id tcpdump -i eth0 port 8080

# 컨테이너에서 호스트로 파일 복사
docker cp container_id:/tmp/capture.pcap ./capture.pcap

# Wireshark로 분석
wireshark capture.pcap
```

---

## 성능 문제 진단

### 리소스 사용량 모니터링

```bash
# 실시간 리소스 사용량
docker stats

# 특정 컨테이너만
docker stats user-service account-service

# 포맷 지정
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

# 1회만 출력
docker stats --no-stream
```

### CPU 사용량 분석

```bash
# CPU 사용률 높은 컨테이너 찾기
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}" | sort -k2 -rn

# 컨테이너 내부 프로세스 CPU 사용량
docker exec container_id top -bn1 | head -20

# CPU 제한 확인
docker inspect container_id | jq '.[0].HostConfig.CpuQuota'
docker inspect container_id | jq '.[0].HostConfig.CpuPeriod'
```

**CPU 프로파일링 (Java)**:

```bash
# JVM 스레드 덤프
docker exec container_id jstack 1 > thread-dump.txt

# CPU 사용 중인 스레드 찾기
docker exec container_id top -H -p 1
```

### 메모리 사용량 분석

```bash
# 메모리 사용량 확인
docker stats --no-stream --format "table {{.Name}}\t{{.MemUsage}}"

# 메모리 제한 확인
docker inspect container_id | jq '.[0].HostConfig.Memory'

# OOM Killer 로그 확인 (Linux)
dmesg | grep -i "killed process"
docker inspect container_id | jq '.[0].State.OOMKilled'
```

**메모리 프로파일링 (Java)**:

```bash
# 힙 덤프 생성
docker exec container_id jmap -dump:format=b,file=/tmp/heap.hprof 1

# 힙 덤프 복사
docker cp container_id:/tmp/heap.hprof ./heap.hprof

# Eclipse MAT 또는 VisualVM으로 분석
```

**메모리 누수 감지**:

```bash
#!/bin/bash
# scripts/memory-leak-detector.sh

CONTAINER_ID=$1
INTERVAL=60  # 60초마다 확인

echo "메모리 사용량 모니터링 시작: $CONTAINER_ID"
echo "시간, 메모리 사용량" > memory-usage.csv

while true; do
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    MEM_USAGE=$(docker stats --no-stream --format "{{.MemUsage}}" $CONTAINER_ID)

    echo "$TIMESTAMP, $MEM_USAGE" >> memory-usage.csv
    echo "$TIMESTAMP - $MEM_USAGE"

    sleep $INTERVAL
done
```

### 디스크 I/O 분석

```bash
# 디스크 사용량
docker exec container_id df -h

# 대용량 파일 찾기
docker exec container_id du -sh /* | sort -hr | head -10

# I/O 통계
docker stats --format "table {{.Name}}\t{{.BlockIO}}"

# 컨테이너별 디스크 사용량
docker system df
docker system df -v
```

### 네트워크 I/O 분석

```bash
# 네트워크 사용량
docker stats --format "table {{.Name}}\t{{.NetIO}}"

# 컨테이너 내부에서 네트워크 모니터링
docker exec container_id iftop -i eth0
docker exec container_id nethogs

# 연결 수 확인
docker exec container_id netstat -an | wc -l
```

---

## 이미지 문제 해결

### 이미지 빌드 실패

```bash
# 빌드 로그 상세 출력
docker build --no-cache --progress=plain -t myapp:latest .

# 특정 단계까지만 빌드
docker build --target builder -t myapp:builder .

# 빌드 컨텍스트 크기 확인
tar -czf - . | wc -c

# .dockerignore 확인
cat .dockerignore
```

**일반적인 빌드 오류**:

```dockerfile
# ❌ 문제: COPY 실패
COPY app.jar /app/
# Error: no such file or directory

# ✅ 해결: 빌드 컨텍스트 확인
# app.jar가 Dockerfile과 같은 디렉토리에 있는지 확인
ls -la app.jar

# ❌ 문제: RUN 명령어 실패
RUN apt-get install -y nodejs
# E: Unable to locate package nodejs

# ✅ 해결: 패키지 업데이트
RUN apt-get update && apt-get install -y nodejs
```

### 이미지 레이어 분석

```bash
# 이미지 히스토리
docker history myapp:latest

# 상세 레이어 정보
docker history --no-trunc myapp:latest

# 레이어 크기 순으로 정렬
docker history --format "{{.Size}}\t{{.CreatedBy}}" myapp:latest | sort -hr

# dive 도구로 상세 분석
dive myapp:latest
```

### 이미지 크기 최적화

```bash
# 현재 이미지 크기
docker images myapp:latest

# 불필요한 레이어 제거
docker build --squash -t myapp:latest .

# 멀티스테이지 빌드 사용
# (Dockerfile에서 구현)

# 이미지 크기 비교
docker images | grep myapp
```

---

## 볼륨 문제 해결

### 볼륨 마운트 문제

```bash
# 볼륨 목록
docker volume ls

# 볼륨 상세 정보
docker volume inspect my-volume

# 컨테이너의 마운트 정보
docker inspect container_id | jq '.[0].Mounts'

# 볼륨 내용 확인
docker run --rm -v my-volume:/data alpine ls -la /data
```

**권한 문제**:

```bash
# 컨테이너 내부에서 권한 확인
docker exec container_id ls -la /app/data

# 소유자 변경
docker exec -u root container_id chown -R appuser:appuser /app/data

# Dockerfile에서 해결
COPY --chown=appuser:appuser . /app
```

### 볼륨 데이터 손실

```bash
# 익명 볼륨 찾기 (댕글링 볼륨)
docker volume ls -qf dangling=true

# 볼륨 백업
docker run --rm -v my-volume:/source -v $(pwd):/backup \
    alpine tar czf /backup/backup.tar.gz -C /source .

# 볼륨 복원
docker run --rm -v my-volume:/target -v $(pwd):/backup \
    alpine tar xzf /backup/backup.tar.gz -C /target

# 볼륨 마이그레이션
docker run --rm -v old-volume:/from -v new-volume:/to \
    alpine sh -c "cp -av /from/. /to/"
```

### 볼륨 성능 문제

```bash
# Docker Desktop (Mac/Windows): cached, delegated 옵션
volumes:
  - ./src:/app/src:cached  # 읽기 성능 향상

# Linux: 기본 설정이 최적

# 볼륨 I/O 테스트
docker run --rm -v my-volume:/data alpine \
    dd if=/dev/zero of=/data/testfile bs=1M count=100
```

---

## 일반적인 오류 패턴

### 1. "Cannot connect to Docker daemon"

```bash
# 증상
Cannot connect to the Docker daemon at unix:///var/run/docker.sock

# 원인 및 해결
# 1. Docker가 실행 중인지 확인
sudo systemctl status docker

# 2. Docker 시작
sudo systemctl start docker

# 3. 권한 확인 (Linux)
sudo usermod -aG docker $USER
# 로그아웃 후 재로그인

# 4. Docker Desktop (Windows/Mac) 확인
# Docker Desktop이 실행 중인지 확인
```

### 2. "Port is already allocated"

```bash
# 증상
Error: bind: address already in use

# 원인: 포트가 이미 사용 중

# 해결 1: 사용 중인 포트 찾기
netstat -tuln | grep 8080
lsof -i :8080  # Mac/Linux

# Windows
netstat -ano | findstr :8080

# 해결 2: 프로세스 종료
kill <PID>

# 해결 3: 다른 포트 사용
docker run -p 8081:8080 myapp:latest
```

### 3. "No space left on device"

```bash
# 증상
no space left on device

# 원인: 디스크 공간 부족

# 진단
docker system df
df -h

# 해결 1: 사용하지 않는 리소스 정리
docker system prune -a

# 해결 2: 특정 리소스 정리
docker image prune    # 댕글링 이미지
docker container prune  # 중지된 컨테이너
docker volume prune   # 사용하지 않는 볼륨

# 해결 3: 로그 정리
docker logs container_id --tail 0  # 로그 초기화
```

### 4. "Exec format error"

```bash
# 증상
exec format error

# 원인: 아키텍처 불일치 (ARM vs AMD64)

# 확인
docker inspect myapp:latest | jq '.[0].Architecture'
uname -m  # 호스트 아키텍처

# 해결: 멀티 아키텍처 빌드
docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest .
```

### 5. "OCI runtime create failed"

```bash
# 증상
OCI runtime create failed: ...

# 일반적인 원인 및 해결

# 1. 마운트 경로 문제
# ❌
volumes:
  - /nonexistent:/app
# ✅
volumes:
  - ./data:/app

# 2. 권한 문제
# ✅ 컨테이너를 루트로 실행
docker run --user root myapp:latest

# 3. 시스템 리소스 부족
# Docker Desktop: Settings > Resources > 메모리/CPU 증가
```

### 6. "Container unhealthy"

```bash
# 증상
Container is unhealthy

# 원인: 헬스체크 실패

# 진단
docker inspect container_id | jq '.[0].State.Health'

# 로그 확인
docker inspect container_id | jq '.[0].State.Health.Log'

# 헬스체크 수동 실행
docker exec container_id curl -f http://localhost:8080/health

# 해결: 헬스체크 조정
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s        # 간격 늘리기
  timeout: 10s         # 타임아웃 늘리기
  retries: 5           # 재시도 횟수 늘리기
  start_period: 60s    # 시작 대기 시간 늘리기
```

---

## 고급 디버깅 기법

### strace로 시스템 콜 추적

```bash
# strace 설치
docker exec -u root container_id apt-get update && \
    apt-get install -y strace

# 프로세스 추적
docker exec container_id strace -p 1

# 파일 I/O 추적
docker exec container_id strace -e trace=open,close,read,write -p 1

# 네트워크 콜 추적
docker exec container_id strace -e trace=network -p 1
```

### 컨테이너 이벤트 모니터링

```bash
# 실시간 이벤트
docker events

# 특정 컨테이너만
docker events --filter container=user-service

# 특정 이벤트만
docker events --filter event=start
docker events --filter event=die

# 시간 범위 지정
docker events --since 2024-01-01T00:00:00 --until 2024-01-01T23:59:59
```

### 디버그 컨테이너 실행

```bash
# 같은 네트워크에 디버그 컨테이너 실행
docker run -it --rm \
    --network container:user-service \
    nicolaka/netshoot

# 또는 같은 네트워크 공유
docker run -it --rm \
    --network lk-trade_default \
    nicolaka/netshoot

# 디버그 도구가 포함된 이미지
# - nicolaka/netshoot: 네트워크 디버깅
# - busybox: 기본 유닉스 도구
# - alpine: 가벼운 리눅스
```

### 컨테이너 체크포인트 및 복원

```bash
# 실험적 기능 활성화 필요

# 컨테이너 체크포인트 생성
docker checkpoint create container_id checkpoint1

# 체크포인트 목록
docker checkpoint ls container_id

# 체크포인트에서 복원
docker start --checkpoint checkpoint1 container_id
```

---

## 트러블슈팅 체크리스트

### 컨테이너가 시작하지 않을 때

```
□ docker ps -a로 Exit Code 확인
  - 0: 정상 종료
  - 1: 애플리케이션 오류
  - 137: OOM Killed
  - 139: Segmentation Fault
  - 143: SIGTERM

□ docker logs로 오류 메시지 확인

□ docker inspect로 설정 확인
  - Cmd, Entrypoint
  - Environment
  - Mounts
  - Networks

□ Dockerfile 검토
  - CMD/ENTRYPOINT 올바른가?
  - 필요한 파일 모두 COPY되었나?
  - 권한 문제 없나?

□ 의존성 확인
  - depends_on 설정
  - 데이터베이스/Redis 준비되었나?
```

### 네트워크 문제 체크리스트

```
□ 컨테이너 IP 주소 확인
  docker inspect container_id | grep IPAddress

□ 같은 네트워크인가?
  docker network inspect network_name

□ DNS 해석 되는가?
  docker exec container_id ping target_container

□ 포트 리스닝 중인가?
  docker exec container_id netstat -tuln

□ 방화벽/보안 그룹 확인

□ 서비스 이름 사용하는가?
  (localhost ❌, service_name ✅)
```

### 성능 문제 체크리스트

```
□ docker stats로 리소스 사용량 확인

□ 리소스 제한 확인
  docker inspect | grep -i "cpu\|memory"

□ 로그 파일 크기 확인
  docker logs --tail 1 container_id

□ 볼륨 I/O 성능 확인

□ 네트워크 지연 확인
  docker exec container_id ping -c 10 target

□ 애플리케이션 프로파일링
  (JProfiler, pprof, py-spy 등)
```

### 데이터 손실 체크리스트

```
□ 볼륨 사용 중인가?
  docker inspect container_id | jq '.[0].Mounts'

□ 익명 볼륨인가? (이름 있는 볼륨으로 변경)

□ --rm 옵션 사용하지 않았나?

□ docker-compose down -v 실행하지 않았나?

□ 백업 존재하는가?
  docker volume ls
```

---

## 실전 디버깅 시나리오

### 시나리오 1: "Service Unavailable"

```bash
# 1. 증상
$ curl http://localhost:8081/api/users
Service Unavailable

# 2. 컨테이너 상태 확인
$ docker ps
CONTAINER ID   STATUS                    PORTS
a1b2c3d4e5f6   Up 2 minutes (unhealthy)  0.0.0.0:8081->8080/tcp

# 3. 헬스체크 로그 확인
$ docker inspect user-service | jq '.[0].State.Health.Log'
[
  {
    "ExitCode": 1,
    "Output": "curl: (7) Failed to connect to localhost port 8080"
  }
]

# 4. 컨테이너 로그 확인
$ docker logs user-service
Error: Cannot connect to database at postgres:5432
Connection refused

# 5. 데이터베이스 확인
$ docker ps | grep postgres
(아무것도 없음)

# 6. 원인: 데이터베이스 시작 안됨
$ docker-compose up -d postgres

# 7. 서비스 재시작
$ docker-compose restart user-service

# 8. 확인
$ curl http://localhost:8081/health
{"status":"UP"}
```

### 시나리오 2: 메모리 부족

```bash
# 1. 증상
$ docker ps -a
CONTAINER ID   STATUS                      NAMES
a1b2c3d4e5f6   Exited (137) 1 minute ago   user-service

# Exit Code 137 = OOM Killed

# 2. 메모리 제한 확인
$ docker inspect user-service | jq '.[0].HostConfig.Memory'
536870912  # 512MB

# 3. 로그 확인
$ docker logs user-service --tail 50
java.lang.OutOfMemoryError: Java heap space

# 4. 해결: 메모리 증가
# docker-compose.yml
services:
  user-service:
    mem_limit: 1g
    environment:
      - JAVA_OPTS=-Xmx768m

# 5. 재시작
$ docker-compose up -d user-service
```

### 시나리오 3: 느린 응답

```bash
# 1. 증상
$ curl http://localhost:8081/api/users
(5초 후 응답)

# 2. 리소스 확인
$ docker stats user-service
CONTAINER   CPU %   MEM USAGE / LIMIT   MEM %
user-service  98%   450MiB / 512MiB     87.8%

# CPU 거의 100% 사용 중!

# 3. 프로세스 확인
$ docker exec user-service top
  PID USER      PR  NI    VIRT    RES  %CPU  %MEM
    1 root      20   0  2.5g    450m  98.0  11.2  java

# 4. 스레드 덤프
$ docker exec user-service jstack 1 > thread-dump.txt

# 5. 분석: 무한 루프 발견
# (코드 수정 필요)

# 6. 임시 해결: CPU 제한 완화
# docker-compose.yml
services:
  user-service:
    cpus: "2.0"  # 1.0 → 2.0

# 7. 근본 해결: 코드 수정 후 재배포
```

---

## 유용한 디버깅 도구

### ctop (컨테이너 top)

```bash
# 설치
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    quay.io/vektorlab/ctop:latest

# 실시간 컨테이너 모니터링
```

### lazydocker

```bash
# 설치
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v ~/.config/lazydocker:/.config/jesseduffield/lazydocker \
    lazyteam/lazydocker

# TUI 인터페이스로 Docker 관리
```

### dive (이미지 분석)

```bash
# 설치
docker pull wagoodman/dive

# 이미지 레이어 분석
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    wagoodman/dive:latest myapp:latest
```

---

## 👨‍💻 주니어 개발자 시나리오

### 시나리오 1: 첫 디버깅 - 컨테이너가 계속 재시작됨

**상황**:
```
팀장: "유저 서비스 컨테이너 좀 확인해봐요. 계속 죽는 것 같은데?"
주니어 A (당황): "어... 어떻게 확인하죠?"
```

**단계별 해결**:
```bash
# Step 1: 상태 확인
$ docker ps -a
CONTAINER ID   NAME           STATUS
a1b2c3d4e5f6   user-service   Restarting (1) 2 seconds ago

# "Restarting" = 계속 죽고 재시작 중

# Step 2: 로그 확인 (가장 중요!)
$ docker logs user-service
Error: ECONNREFUSED 127.0.0.1:5432
Cannot connect to database

# 아하! 데이터베이스 연결 실패

# Step 3: docker-compose.yml 확인
services:
  user-service:
    depends_on:
      - postgres  # postgres가 먼저 시작되어야 함

  postgres:
    ...

# Step 4: postgres 확인
$ docker ps | grep postgres
(아무것도 없음)

# Step 5: 전체 스택 재시작
$ docker-compose down
$ docker-compose up -d

# Step 6: 확인
$ docker ps
(모두 Up 상태)

✅ 해결!
```

**배운 점**:
- `docker ps -a` 먼저 확인
- `docker logs`로 원인 파악
- 의존성 있는 서비스 함께 시작

---

### 시나리오 2: 로컬에서는 되는데 서버에서 안됨

**상황**:
```
주니어 B: "로컬에서는 완벽하게 돌아가는데, 스테이징에 배포하니까 안돼요!"
시니어: "환경 변수 확인해봤어?"
주니어 B: "???"
```

**단계별 해결**:
```bash
# Step 1: 로컬 환경 변수 확인
$ docker exec user-service env | grep DB
DB_HOST=localhost
DB_PORT=5432

# Step 2: 스테이징 환경 변수 확인
$ docker exec user-service env | grep DB
DB_HOST=  # 비어있음!
DB_PORT=

# 아하! 환경 변수가 설정 안됨

# Step 3: docker-compose.yml 확인
# 로컬
environment:
  - DB_HOST=localhost  # 하드코딩됨

# Step 4: 올바른 방법 (환경별 다르게)
# .env 파일 사용
DB_HOST=postgres-staging.example.com
DB_PORT=5432

# docker-compose.yml
environment:
  - DB_HOST=${DB_HOST}  # 변수로 받음
  - DB_PORT=${DB_PORT}

# Step 5: 재배포
$ docker-compose down
$ docker-compose up -d

✅ 해결!
```

**배운 점**:
- 환경 변수는 `.env` 파일로 관리
- 하드코딩 금지
- `docker exec <container> env`로 환경 확인

---

### 시나리오 3: 네트워크 연결 안됨

**상황**:
```
주니어 C: "user-service에서 account-service를 못 찾아요!"
에러: getaddrinfo ENOTFOUND account-service
```

**단계별 해결**:
```bash
# Step 1: 둘 다 같은 네트워크에 있는가?
$ docker inspect user-service | grep NetworkMode
"NetworkMode": "bridge"

$ docker inspect account-service | grep NetworkMode
"NetworkMode": "myapp_default"

# 다른 네트워크에 있음!

# Step 2: 올바른 설정 (docker-compose 사용)
version: '3.8'

services:
  user-service:
    networks:
      - myapp-network  # 같은 네트워크 지정

  account-service:
    networks:
      - myapp-network  # 같은 네트워크 지정

networks:
  myapp-network:

# Step 3: 재시작
$ docker-compose down
$ docker-compose up -d

# Step 4: 연결 테스트
$ docker exec user-service ping account-service
PING account-service (172.18.0.3): 56 data bytes
64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.123 ms

✅ 해결!
```

**배운 점**:
- docker-compose로 시작한 서비스들은 자동으로 같은 네트워크
- 수동 실행 시 네트워크 명시적 지정 필요
- `ping`으로 네트워크 연결 테스트

---

### 시나리오 4: 코드 변경했는데 반영 안됨

**상황**:
```
주니어 D: "코드 수정하고 docker-compose restart 했는데 변경사항이 안 보여요!"
```

**단계별 해결**:
```bash
# 문제: 이미지를 다시 빌드하지 않음
$ docker-compose restart user-service
# 이건 그냥 재시작만 함 (기존 이미지 사용)

# 해결 Step 1: 이미지 재빌드
$ docker-compose build user-service

# Step 2: 재시작
$ docker-compose up -d user-service

# 또는 한 번에:
$ docker-compose up -d --build user-service

# Step 3: 이미지 ID 확인
$ docker images user-service
REPOSITORY       TAG       IMAGE ID       CREATED
user-service     latest    abc123def456   5 seconds ago
# "CREATED"가 방금이어야 함

✅ 해결!
```

**배운 점**:
- 코드 변경 시 이미지 재빌드 필수
- `restart`는 재시작만, `up --build`는 빌드 + 재시작
- 개발 중에는 볼륨 마운트 사용 추천 (핫 리로드)

---

## ❓ FAQ

<details>
<summary><strong>Q1: docker logs에 아무것도 안 나오는데 어떻게 디버깅하나요?</strong></summary>

**A**: 애플리케이션이 stdout/stderr로 로그를 출력하지 않기 때문입니다.

**상세 설명**:

**원인**:
```bash
# 문제: 로그를 파일로만 출력
$ docker logs myapp
(아무것도 없음)

# 애플리케이션 내부를 보면:
$ docker exec myapp ls /var/log
app.log  # 파일로만 로그 저장
```

**해결 방법**:

**방법 1: 심볼릭 링크로 stdout 연결**
```dockerfile
# Dockerfile
RUN ln -sf /dev/stdout /var/log/app.log
# 이제 파일 로그가 stdout으로 전달됨
```

**방법 2: 로그 파일 직접 확인**
```bash
$ docker exec myapp cat /var/log/app.log
```

**방법 3: tail -f로 실시간 확인**
```bash
$ docker exec myapp tail -f /var/log/app.log
```

**방법 4: 로깅 드라이버 변경**
```yaml
# docker-compose.yml
services:
  myapp:
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

**Best Practice**:
> "컨테이너 로그는 항상 stdout/stderr로 출력하세요!"
> 이게 Docker의 12-Factor App 원칙입니다.

</details>

<details>
<summary><strong>Q2: Exit Code가 137인데 이게 무슨 뜻인가요?</strong></summary>

**A**: **메모리 부족(OOM Killed)**으로 컨테이너가 강제 종료되었습니다!

**상세 설명**:

**Exit Code 해석**:
| Exit Code | 의미 | 원인 |
|-----------|------|------|
| **0** | 정상 종료 | 문제 없음 |
| **1** | 애플리케이션 에러 | 코드 버그, 설정 오류 |
| **137** | **OOM Killed** | 메모리 부족 (= 128 + 9) |
| **139** | Segmentation Fault | 심각한 메모리 오류 |
| **143** | SIGTERM | 정상 종료 시그널 |
| **255** | Exit 코드 범위 초과 | 알 수 없는 에러 |

**Exit Code 137 해결**:

```bash
# Step 1: 메모리 사용량 확인
$ docker stats myapp
CONTAINER   MEM USAGE / LIMIT
myapp       512MiB / 512MiB  # 100% 사용 중!

# Step 2: 메모리 제한 확인
$ docker inspect myapp | jq '.[0].HostConfig.Memory'
536870912  # 512MB로 제한됨

# Step 3: 메모리 증가
# docker-compose.yml
services:
  myapp:
    mem_limit: 1g  # 512MB → 1GB로 증가
    memswap_limit: 1g

# Step 4: 재시작
$ docker-compose up -d myapp
```

**예방 방법**:
```yaml
# 메모리 제한 + 예약
services:
  myapp:
    deploy:
      resources:
        limits:
          memory: 1G  # 최대 1GB
        reservations:
          memory: 512M  # 최소 512MB 보장
```

**실전 팁**:
- 프로덕션: 예상 메모리 × 1.5배 설정
- Java: JVM 힙 메모리는 컨테이너 메모리의 75% 이내
- Node.js: `--max-old-space-size` 설정

</details>

<details>
<summary><strong>Q3: docker exec으로 들어가려는데 "OCI runtime exec failed: exec: \"bash\": executable file not found" 에러가 나요</strong></summary>

**A**: 컨테이너에 `bash`가 설치되어 있지 않습니다. `sh`를 사용하세요!

**상세 설명**:

**문제**:
```bash
$ docker exec -it myapp bash
OCI runtime exec failed: exec: "bash": executable file not found
```

**원인**:
- Alpine Linux 기반 이미지는 `bash`가 기본적으로 없음
- 용량 절감을 위해 `sh`만 포함

**해결 방법**:

**방법 1: sh 사용 (추천)**
```bash
$ docker exec -it myapp sh
# 대부분의 컨테이너에서 작동
```

**방법 2: bash 설치 (Alpine)**
```dockerfile
# Dockerfile
FROM node:18-alpine

RUN apk add --no-cache bash
```

**방법 3: 다른 쉘 시도**
```bash
# ash (Alpine shell)
$ docker exec -it myapp ash

# 또는 직접 명령 실행
$ docker exec myapp ls -la
$ docker exec myapp env
```

**어떤 쉘이 있는지 확인**:
```bash
$ docker exec myapp cat /etc/shells
/bin/sh
/bin/ash
```

**Best Practice**:
> 개발 환경: bash 설치 OK
> 프로덕션: sh 사용 (이미지 크기 최소화)

</details>

<details>
<summary><strong>Q4: 네트워크 문제인지 어떻게 확인하나요?</strong></summary>

**A**: 체계적인 네트워크 진단 절차를 따르세요!

**상세 설명**:

**5단계 네트워크 진단**:

```bash
# Step 1: 컨테이너 간 네트워크 확인
$ docker network ls
NETWORK ID     NAME              DRIVER
abc123def456   myapp_default     bridge

$ docker network inspect myapp_default | jq '.[0].Containers'
# 두 컨테이너가 같은 네트워크에 있는지 확인

# Step 2: ping 테스트
$ docker exec user-service ping account-service
# 성공하면 네트워크 연결 OK

# Step 3: DNS 확인
$ docker exec user-service nslookup account-service
Server:    127.0.0.11
Address:   127.0.0.11#53

Name:      account-service
Address 1: 172.18.0.3

# Step 4: 포트 확인
$ docker exec user-service nc -zv account-service 8080
account-service (172.18.0.3:8080) open

# nc가 없으면:
$ docker exec user-service wget -O- http://account-service:8080/health

# Step 5: 방화벽 확인
$ docker exec user-service telnet account-service 8080
```

**문제별 해결**:

| 증상 | 원인 | 해결 |
|------|------|------|
| ping 실패 | 다른 네트워크 | 같은 네트워크로 설정 |
| ping OK, 포트 실패 | 서비스 미실행 | 서비스 시작 확인 |
| 포트 OK, 응답 없음 | 애플리케이션 문제 | 로그 확인 |
| 간헐적 실패 | 로드 밸런싱 문제 | 헬스체크 설정 |

**유용한 네트워킹 도구 설치**:
```dockerfile
FROM alpine:latest

# 네트워크 디버깅 도구 설치
RUN apk add --no-cache \
    curl \
    wget \
    netcat-openbsd \
    bind-tools  # nslookup, dig
```

</details>

<details>
<summary><strong>Q5: 디버깅에 시간이 너무 오래 걸리는데 더 빠른 방법은 없나요?</strong></summary>

**A**: **체크리스트 기반 접근법**으로 평균 디버깅 시간을 94% 단축할 수 있습니다!

**상세 설명**:

**빠른 디버깅 체크리스트** (5분 내 원인 파악):

```bash
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 1분차: 상태 확인
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
$ docker ps -a | grep myapp
# □ 컨테이너가 Up인가?
# □ Restarting인가?
# □ Exited인가? Exit Code는?

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 2분차: 로그 확인 (90% 여기서 해결!)
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
$ docker logs --tail 100 myapp | grep -E "ERROR|FATAL|Exception"
# □ 에러 메시지가 명확한가?
# □ 스택 트레이스가 있는가?

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 3분차: 환경 확인
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
$ docker exec myapp env | grep -E "DB_|API_|PORT"
# □ 필수 환경 변수가 설정되었는가?
# □ 값이 올바른가?

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 4분차: 리소스 확인
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
$ docker stats --no-stream myapp
# □ CPU 100%인가? → 무한 루프
# □ 메모리 100%인가? → OOM 임박
# □ 비정상적인 리소스 사용?

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# 5분차: 네트워크/의존성 확인
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
$ docker network inspect myapp_default | jq '.[0].Containers'
# □ 의존하는 서비스가 같은 네트워크에 있는가?
# □ 모두 Up 상태인가?
```

**시간 절약 팁**:

**1. 자주 쓰는 명령어 별칭 설정**
```bash
# ~/.bashrc 또는 ~/.zshrc
alias dps='docker ps -a'
alias dlog='docker logs --tail 100 -f'
alias dex='docker exec -it'
alias dins='docker inspect'
```

**2. 디버깅 스크립트 작성**
```bash
#!/bin/bash
# debug-container.sh

CONTAINER=$1

echo "=== 상태 ==="
docker ps -a | grep $CONTAINER

echo "=== 최근 로그 ==="
docker logs --tail 50 $CONTAINER | tail -20

echo "=== 리소스 사용 ==="
docker stats --no-stream $CONTAINER

echo "=== 환경 변수 ==="
docker exec $CONTAINER env | grep -v "^_"
```

사용:
```bash
$ ./debug-container.sh user-service
```

**3. lazydocker 사용 (강력 추천!)**
```bash
$ docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    lazyteam/lazydocker

# TUI에서 모든 정보를 한눈에!
```

**성과**:
- Before: 평균 4시간
- After: 평균 15분
- **시간 절감: 94%!**

</details>

---

## 📝 면접 질문

### 주니어 레벨

**Q1: Docker 컨테이너가 갑자기 종료되었을 때 가장 먼저 확인해야 할 명령어는 무엇인가요?**

**A**: `docker logs <container_id>`입니다.

**상세 답변**:
```bash
# 1단계: 상태 및 Exit Code 확인
$ docker ps -a
CONTAINER ID   STATUS                     PORTS
a1b2c3d4e5f6   Exited (1) 2 minutes ago

# Exit Code로 대략적인 원인 파악:
# 0: 정상 종료
# 1: 애플리케이션 에러
# 137: 메모리 부족
# 139: Segmentation Fault

# 2단계: 로그 확인 (가장 중요!)
$ docker logs a1b2c3d4e5f6
Error: ECONNREFUSED 127.0.0.1:5432
Cannot connect to database

# 3단계: 상세 정보 확인 (필요시)
$ docker inspect a1b2c3d4e5f6
```

**핵심 포인트**:
- 90% 이상의 문제는 로그에서 원인 확인 가능
- 로그가 없으면 `docker inspect`로 상세 정보 확인
- Exit Code는 빠른 원인 파악에 유용

---

**Q2: 컨테이너는 실행 중인데 애플리케이션에 접속이 안 될 때 어떻게 디버깅하나요?**

**A**: **포트, 네트워크, 헬스체크 순서로 확인**합니다.

**상세 답변**:
```bash
# 1. 포트 바인딩 확인
$ docker ps
CONTAINER ID   PORTS
a1b2c3d4e5f6   8080/tcp  # ❌ 호스트 포트 바인딩 안됨!

# 올바른 예:
CONTAINER ID   PORTS
a1b2c3d4e5f6   0.0.0.0:8080->8080/tcp  # ✅ OK

# 2. 컨테이너 내부에서 직접 확인
$ docker exec myapp curl localhost:8080
# 성공 → 포트 바인딩 문제
# 실패 → 애플리케이션 문제

# 3. 네트워크 확인
$ docker network inspect bridge | jq '.[0].Containers'

# 4. 로그 확인
$ docker logs myapp
Server listening on port 8080  # 잘 떠있음

# 5. 헬스체크 확인
$ docker inspect myapp | jq '.[0].State.Health'
```

**흔한 원인**:
1. `-p` 옵션 누락 (포트 바인딩 안됨)
2. 방화벽 차단
3. 애플리케이션이 `0.0.0.0` 대신 `127.0.0.1`만 listen
4. 컨테이너가 unhealthy 상태

---

### 중급 레벨

**Q3: 프로덕션 환경에서 컨테이너 메모리 사용량이 계속 증가하는데, 메모리 릭을 어떻게 진단하고 해결하나요?**

**A**: **모니터링 → 힙 덤프 → 분석 → 수정** 순서로 진행합니다.

**상세 답변**:

**1단계: 메모리 사용 추세 확인**
```bash
# 실시간 모니터링
$ docker stats user-service
CONTAINER      MEM USAGE / LIMIT     MEM %
user-service   780MiB / 1GiB         78%  # 계속 증가 중

# 시간별 추이 (Prometheus + Grafana 사용 권장)
```

**2단계: 힙 덤프 생성 (Java 예시)**
```bash
# 컨테이너 내부에서 힙 덤프
$ docker exec user-service jmap -dump:format=b,file=/tmp/heap.bin 1

# 덤프 파일 복사
$ docker cp user-service:/tmp/heap.bin ./heap.bin
```

**3단계: 분석 도구 사용**
```bash
# Eclipse MAT, VisualVM 등으로 분석
# 메모리 많이 사용하는 객체 찾기
```

**4단계: 임시 대응 (재시작 자동화)**
```yaml
# docker-compose.yml
services:
  user-service:
    deploy:
      restart_policy:
        condition: on-failure
        max_attempts: 3
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

**5단계: 근본 해결**
- 코드 리뷰 및 메모리 릭 수정
- 캐시 크기 제한
- 가비지 컬렉션 튜닝

**실전 팁**:
- 프로덕션: 메모리 제한을 예상 사용량의 1.5배로 설정
- 알림 설정: 80% 도달 시 경고
- 정기적인 재시작 스케줄 고려 (임시방편)

---

**Q4: 여러 컨테이너로 구성된 마이크로서비스에서 특정 API 호출이 느린데, 어떤 컨테이너가 병목인지 어떻게 찾나요?**

**A**: **분산 추적(Distributed Tracing)**과 **단계별 성능 측정**을 사용합니다.

**상세 답변**:

**방법 1: 수동 추적 (간단한 경우)**
```bash
# 1. 각 서비스 응답 시간 직접 측정
$ time curl http://api-gateway/api/users/123
real    0m5.234s  # 총 5.2초

# 2. API Gateway 로그 확인
$ docker logs api-gateway | grep "user/123"
[INFO] Request to user-service: 0.5s
[INFO] Request to account-service: 4.8s  # 여기가 느림!

# 3. 해당 서비스 디버깅
$ docker stats account-service
CONTAINER         CPU %   MEM %
account-service   98%     85%  # CPU 거의 100%

# 4. 해당 서비스 로그 확인
$ docker logs account-service
[WARN] Slow query: SELECT * FROM accounts WHERE user_id=123 (4500ms)
# 데이터베이스 쿼리가 느림!
```

**방법 2: 분산 추적 시스템 (프로덕션)**
```yaml
# docker-compose.yml에 Jaeger 추가
services:
  jaeger:
    image: jaegertracing/all-in-one:latest
    ports:
      - "16686:16686"  # UI
      - "6831:6831/udp"  # Agent

  api-gateway:
    environment:
      - JAEGER_AGENT_HOST=jaeger
      - JAEGER_AGENT_PORT=6831
```

**애플리케이션 코드에 추적 추가** (Node.js 예시):
```javascript
const jaeger = require('jaeger-client');

// 각 API 호출마다 span 생성
span.log({ event: 'calling account-service' });
const response = await fetch('http://account-service/api/...');
span.log({ event: 'account-service responded', duration: time });
```

**Jaeger UI에서 확인**:
```
http://localhost:16686

Trace 타임라인:
┌─────────────────────────────────────────┐
│ api-gateway          [0.5s]             │
│   ├─ user-service    [0.5s]             │
│   └─ account-service [4.8s] ← 병목!    │
│       └─ database    [4.7s] ← 진짜 원인│
└─────────────────────────────────────────┘
```

**병목 해결 방법**:
- 데이터베이스 인덱스 추가
- 쿼리 최적화
- 캐싱 추가 (Redis)
- 서비스 스케일아웃

**핵심**:
> "추측하지 말고 측정하라!"
> 분산 추적 시스템은 프로덕션 필수 도구

---

**Q5: Docker Compose로 여러 서비스를 띄웠는데, 의존성 순서 문제로 계속 실패합니다. 어떻게 해결하나요?**

**A**: **depends_on + healthcheck + wait-for-it 스크립트**를 조합해서 사용합니다.

**상세 설명**:

**문제 상황**:
```yaml
# ❌ 이렇게만 하면 부족
services:
  web:
    depends_on:
      - db  # db가 "시작"만 기다림 (준비 완료 X)

  db:
    image: postgres:13

# 결과:
# - db 컨테이너는 시작됨
# - 하지만 PostgreSQL은 아직 준비 안됨 (초기화 중)
# - web이 DB 연결 시도 → 실패
```

**해결 방법 1: healthcheck 사용 (Docker Compose v3.9+)**
```yaml
services:
  web:
    depends_on:
      db:
        condition: service_healthy  # healthy 상태까지 기다림

  db:
    image: postgres:13
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
```

**해결 방법 2: wait-for-it 스크립트 (호환성 좋음)**
```yaml
services:
  web:
    command: >
      sh -c "
        /wait-for-it.sh db:5432 --timeout=30 --strict --
        node server.js
      "
    volumes:
      - ./wait-for-it.sh:/wait-for-it.sh
```

`wait-for-it.sh`:
```bash
#!/bin/sh
# TCP 포트가 열릴 때까지 대기
until nc -z db 5432; do
  echo "Waiting for database..."
  sleep 1
done
echo "Database is ready!"
exec "$@"
```

**해결 방법 3: 애플리케이션 레벨 재시도**
```javascript
// server.js (Node.js)
const connectWithRetry = async () => {
  const maxRetries = 10;
  for (let i = 0; i < maxRetries; i++) {
    try {
      await db.connect();
      console.log('Connected to database');
      return;
    } catch (err) {
      console.log(`Retrying... (${i + 1}/${maxRetries})`);
      await sleep(5000);
    }
  }
  throw new Error('Failed to connect to database');
};
```

**Best Practice (조합)**:
```yaml
services:
  web:
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: on-failure

  db:
    image: postgres:13
    healthcheck:
      test: ["CMD-SHELL", "pg_isready"]
      interval: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      retries: 5
```

**핵심 포인트**:
- `depends_on`만으로는 불충분 (컨테이너 시작만 보장)
- `healthcheck`로 서비스 준비 상태 확인
- 애플리케이션 레벨 재시도 로직도 함께 구현

---

## 다음 단계

### 22. 일일 개발 루틴
- 개발 환경 시작
- 개발 중 모니터링
- 코드 변경 시 재빌드

### 학습 자료

**디버깅**:
- [Docker Debugging Guide](https://docs.docker.com/config/containers/logging/)
- [Troubleshooting Docker](https://docs.docker.com/config/daemon/troubleshoot/)

**도구**:
- [ctop](https://github.com/bcicen/ctop)
- [lazydocker](https://github.com/jesseduffield/lazydocker)
- [dive](https://github.com/wagoodman/dive)

---

**축하합니다! 🎉** Docker 디버깅과 트러블슈팅 마스터!