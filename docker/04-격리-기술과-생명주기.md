# 4. 격리 기술과 컨테이너 생명주기 🔒

> **학습 목표**: 이 장을 완료하면 Docker가 컨테이너를 격리하는 7가지 네임스페이스와 5가지 Cgroups를 이해하고, 컨테이너의 생명주기를 완벽하게 관리할 수 있습니다.

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐☆ (4개/5개)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [네임스페이스 (Namespace)](#네임스페이스-namespace)
- [컨트롤 그룹 (cgroups)](#컨트롤-그룹-cgroups)
- [컨테이너 생명주기](#컨테이너-생명주기)
- [주니어 시나리오](#주니어-시나리오)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)
- [축하합니다](#축하합니다)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경
**컨테이너 격리는 Docker의 핵심 메커니즘입니다.**

#### ❌ 격리 기술을 모르면 발생하는 문제
```
문제 1: 리소스 무한 사용
- 증상: 한 컨테이너가 호스트 메모리를 전부 사용
- 영향: 다른 모든 컨테이너와 호스트 시스템이 먹통
- 비용: 서비스 장애로 시간당 수백만 원 손실

문제 2: 보안 취약점
- 증상: 컨테이너가 호스트 파일 시스템에 접근
- 영향: 데이터 유출, 악의적 공격 가능
- 비용: 데이터 침해 사고, 법적 책임

문제 3: 프로세스 간섭
- 증상: 컨테이너 A가 컨테이너 B의 프로세스를 종료
- 영향: 예측 불가능한 시스템 동작
- 비용: 디버깅에 수십 시간 소요
```

#### ✅ 격리 기술을 사용하면
```
해결책 1: 리소스 제한
- 방법: Cgroups로 CPU/메모리 제한
- 효과: 한 컨테이너가 전체 시스템을 마비시킬 수 없음
- 절감: 장애 예방으로 연간 수억 원 절감

해결책 2: 완벽한 격리
- 방법: 네임스페이스로 각 컨테이너 독립
- 효과: 보안 침해 시에도 다른 컨테이너 안전
- 절감: 보안 사고 예방

해결책 3: 예측 가능한 동작
- 방법: 생명주기 관리로 컨테이너 상태 제어
- 효과: 안정적인 배포와 운영
- 절감: 디버깅 시간 80% 단축
```

### 📊 수치로 보는 효과

| 지표 | Before (격리 없음) | After (격리 적용) | 개선율 |
|------|-------------------|------------------|--------|
| 메모리 장애 | 주 3-4회 | 월 0-1회 | **95%↓** |
| 보안 침해 위험 | 높음 | 매우 낮음 | **90%↓** |
| 장애 복구 시간 | 평균 4시간 | 평균 10분 | **95%↓** |
| 리소스 효율성 | 60% | 85% | **42%↑** |
| 운영 안정성 | 3-nines (99.9%) | 4-nines (99.99%) | **10배↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 아파트 단지 (전체 개념)
```
Linux 시스템 = 아파트 건물
컨테이너 = 각 호실 (101호, 102호, 103호...)

네임스페이스 없이 (옛날 방식):
┌─────────────────────────────────────┐
│          하나의 큰 방               │
│                                      │
│  프로세스 A  프로세스 B  프로세스 C  │
│  (서로 다 보임, 간섭 가능)          │
│                                      │
│  공유 리소스:                        │
│  - 같은 프로세스 ID 공간             │
│  - 같은 네트워크                     │
│  - 같은 파일 시스템                  │
└─────────────────────────────────────┘

문제점:
❌ 프로세스 A가 B를 kill 할 수 있음
❌ 네트워크 포트 충돌
❌ 파일 시스템 간섭


네임스페이스 사용 (Docker):
┌─────────────────────────────────────┐
│          아파트 건물                │
├───────────┬───────────┬─────────────┤
│ 101호     │ 102호     │ 103호       │
│           │           │             │
│ 프로세스 A│ 프로세스 B│ 프로세스 C  │
│ (독립)    │ (독립)    │ (독립)      │
│           │           │             │
│ 독립 리소스│ 독립 리소스│ 독립 리소스 │
│ - PID 1   │ - PID 1   │ - PID 1     │
│ - 네트워크│ - 네트워크│ - 네트워크  │
│ - 파일    │ - 파일    │ - 파일      │
└───────────┴───────────┴─────────────┘

장점:
✅ 각 호실(컨테이너)은 서로 보이지 않음
✅ 독립적인 PID, 네트워크, 파일 시스템
✅ 보안성 향상
```

### 비유 2: 전기/수도 계량기 (Cgroups)
```
Cgroups = 각 호실의 전기/수도 계량기 + 차단기

네임스페이스 (격리):
"각 호실은 다른 호실을 볼 수 없다"

Cgroups (리소스 제한):
"각 호실은 최대 10A 전기, 1톤 수도 사용 가능"

┌─────────────────────────────────────┐
│         아파트 건물                 │
├───────────┬───────────┬─────────────┤
│ 101호     │ 102호     │ 103호       │
│           │           │             │
│ 전기: 8A  │ 전기: 10A │ 전기: 5A    │
│ 수도: 0.5t│ 수도: 0.9t│ 수도: 0.3t  │
│ (제한 준수)│ (한계 도달)│ (여유 있음)│
│           │⚠️ 차단기  │             │
│           │작동 준비  │             │
└───────────┴───────────┴─────────────┘

효과:
✅ 102호가 전기를 많이 써도 101호는 영향 없음
✅ 한계 도달 시 자동 차단 (OOM Killer)
✅ 공정한 리소스 분배
```

### 비유 3: 배달앱 주문 상태 (생명주기)
```
컨테이너 생명주기 = 배달앱 주문 상태

주문 접수 (Created)
    ↓
조리 시작 (Starting)
    ↓
배달 중 (Running)
    ↓
[일시정지] (Paused) → [재개] (Running)
    ↓
배달 완료 (Stopped)
    ↓
주문 내역 삭제 (Removed)

실제 명령어:
docker create   → 주문 접수
docker start    → 조리 시작 + 배달 시작
docker pause    → 배달 잠시 멈춤 (신호등)
docker unpause  → 배달 재개
docker stop     → 배달 완료
docker rm       → 주문 내역 삭제
```

### 비유 4: 카페 좌석 예약 시스템 (네임스페이스 종류)
```
카페 = Linux 시스템
좌석 = 컨테이너

7가지 격리 유형:

1. PID Namespace = 좌석 번호 독립
   - A좌석: 1번, 2번, 3번...
   - B좌석: 1번, 2번, 3번... (각자 독립)

2. Network Namespace = Wi-Fi 독립
   - A좌석: 192.168.1.2
   - B좌석: 192.168.1.3

3. Mount Namespace = 개인 사물함
   - A좌석: 1번 사물함 (타인 접근 불가)
   - B좌석: 2번 사물함

4. UTS Namespace = 좌석 이름표
   - A좌석: "개발자석"
   - B좌석: "디자이너석"

5. IPC Namespace = 개인 메모장
   - A좌석: A 전용 메모장
   - B좌석: B 전용 메모장

6. User Namespace = 손님 등급
   - A좌석 손님: VIP → 실제로는 일반
   - B좌석 손님: VIP → 실제로는 일반
   (보안: 각자 VIP라고 느끼지만 실제론 제한됨)

7. Cgroup Namespace = 전기 사용량 표시기
   - 각 좌석은 자기 사용량만 봄
```

### 비유 5: 게임 캐릭터 상태 (컨테이너 상태)
```
게임 캐릭터 = 컨테이너

캐릭터 생성 (Created)
- 외형, 능력치 설정 완료
- 아직 게임 접속 안 함

게임 중 (Running)
- 활발히 활동
- 리소스(MP) 사용
- 다른 플레이어와 상호작용

AFK 상태 (Paused)
- 잠시 자리 비움
- 캐릭터는 그대로 있지만 움직이지 않음
- 리소스 사용 최소

로그아웃 (Stopped)
- 게임에서 나감
- 진행 상황은 저장됨
- 언제든 재접속 가능

캐릭터 삭제 (Removed)
- 영구적으로 삭제
- 복구 불가능

자동 재접속 (Restart Policy)
- 강제 종료 시 자동 재접속
- always: 항상 재접속
- on-failure: 에러일 때만 재접속
```

### 🎯 종합 비교표
```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ 기술 개념    │ 아파트       │ 카페         │ 게임         │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 네임스페이스 │ 각 호실 분리 │ 좌석 독립    │ 캐릭터 격리  │
│ Cgroups      │ 계량기/차단기│ 사용량 제한  │ MP/스태미나  │
│ 생명주기     │ 입주→퇴거    │ 입장→퇴장    │ 접속→로그아웃│
│ Created      │ 입주 계약    │ 예약 완료    │ 캐릭터 생성  │
│ Running      │ 거주 중      │ 이용 중      │ 게임 플레이  │
│ Stopped      │ 일시 퇴거    │ 퇴장         │ 로그아웃     │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📖 네임스페이스 (Namespace)

### 🎯 핵심 질문: "컨테이너는 어떻게 격리될까?"

네임스페이스(Namespace)는 **Linux 커널의 기능으로, 프로세스들을 서로 격리시키는 기술**입니다.

### 🔍 Linux 네임스페이스의 7가지 종류

Docker는 다음 7가지 네임스페이스를 사용합니다:

#### 1️⃣ PID Namespace (프로세스 격리)

**각 컨테이너가 독립적인 프로세스 ID 공간을 가집니다.**

```
호스트 시스템:
PID 1: systemd (init)
PID 100: docker daemon
PID 500: container A (bash)
PID 501: container A (nginx)
PID 600: container B (bash)
PID 601: container B (postgres)

Container A 내부에서 보는 PID:
PID 1: bash         ← 호스트에서는 PID 500
PID 2: nginx        ← 호스트에서는 PID 501

Container B 내부에서 보는 PID:
PID 1: bash         ← 호스트에서는 PID 600
PID 2: postgres     ← 호스트에서는 PID 601
```

**실제 테스트:**
```bash
# 컨테이너 A 실행
$ docker run -it --name container-a ubuntu bash
root@abc123:/# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  18504  3360 pts/0    Ss   10:00   0:00 bash
root        12  0.0  0.0  34400  2880 pts/0    R+   10:01   0:00 ps aux

# 컨테이너 내부에서 PID 1은 bash!

# 호스트에서 확인
$ ps aux | grep bash
root      5432  0.0  0.0  18504  3360 pts/0    Ss   10:00   0:00 bash

# 호스트에서는 PID 5432!
```

#### 2️⃣ Network Namespace (네트워크 격리)

**각 컨테이너가 독립적인 네트워크 스택을 가집니다.**

```
호스트:
┌─────────────────────────────┐
│ Host Network                │
│ IP: 192.168.1.100           │
│ eth0: 물리 네트워크          │
└─────────────────────────────┘
         │
         ├─── docker0 (bridge)
         │
    ┌────┴─────┬─────────┬─────────┐
    │          │         │         │
┌───┴────┐ ┌──┴───┐ ┌───┴───┐ ┌───┴───┐
│veth-A  │ │veth-B│ │veth-C │ │veth-D │
│        │ │      │ │       │ │       │
│Container│ │Container│ │Container│ │Container│
│   A    │ │   B  │ │   C   │ │   D   │
│        │ │      │ │       │ │       │
│eth0    │ │eth0  │ │eth0   │ │eth0   │
│172.17. │ │172.17│ │172.17 │ │172.17 │
│0.2     │ │0.3   │ │0.4    │ │0.5    │
└────────┘ └──────┘ └───────┘ └───────┘
```

#### 3️⃣ Mount Namespace (파일 시스템 격리)

**각 컨테이너가 독립적인 파일 시스템 마운트를 가집니다.**

```
호스트 파일 시스템:
/
├── bin/
├── etc/
├── home/
├── var/
│   └── lib/
│       └── docker/
│           └── overlay2/
│               ├── abc123.../    ← Container A
│               └── def456.../    ← Container B
└── ...

Container A가 보는 파일 시스템:
/
├── bin/           (Container A 전용)
├── etc/           (Container A 전용)
├── app/           (애플리케이션 코드)
└── ...

서로 완전히 다른 파일 시스템!
```

#### 4️⃣ UTS Namespace (호스트명/도메인명 격리)

**각 컨테이너가 독립적인 호스트명과 도메인명을 가집니다.**

```bash
# 호스트 확인
$ hostname
my-laptop

# 컨테이너 A
$ docker run -it --name web --hostname web-server ubuntu bash
root@web-server:/# hostname
web-server

# 컨테이너 B
$ docker run -it --name db --hostname database ubuntu bash
root@database:/# hostname
database

# 모두 다른 호스트명!
```

#### 5️⃣ IPC Namespace (프로세스 간 통신 격리)

**각 컨테이너가 독립적인 IPC 리소스를 가집니다.**

```
IPC (Inter-Process Communication) 리소스:
- 공유 메모리 (Shared Memory)
- 세마포어 (Semaphore)
- 메시지 큐 (Message Queue)

Container A의 IPC:
┌─────────────────────┐
│ Shared Memory: /shm │
│ Semaphore: sem_A    │
│ Message Queue: mq_A │
└─────────────────────┘

Container B의 IPC:
┌─────────────────────┐
│ Shared Memory: /shm │
│ Semaphore: sem_B    │
│ Message Queue: mq_B │
└─────────────────────┘

같은 이름이지만 완전히 다른 리소스!
```

#### 6️⃣ User Namespace (사용자/그룹 격리)

**컨테이너 내부의 root와 호스트의 사용자를 매핑합니다.**

```
문제 상황 (User Namespace 없이):
┌──────────────────────────────────┐
│ Container (root)                 │
│ UID 0 (root)                     │
└──────────────────────────────────┘
           ║
           ║ 같은 UID!
           ║
┌──────────────────────────────────┐
│ Host (root)                      │
│ UID 0 (root)                     │
└──────────────────────────────────┘

위험:
- 컨테이너가 탈출하면 호스트 root 권한 획득!


해결 (User Namespace 사용):
┌──────────────────────────────────┐
│ Container (root처럼 보임)        │
│ UID 0 (root)                     │
└──────────────────────────────────┘
           ║
           ║ 매핑
           ↓
┌──────────────────────────────────┐
│ Host (일반 사용자)               │
│ UID 100000 (nobody)              │
└──────────────────────────────────┘

보안:
- 컨테이너 root = 호스트 일반 사용자
- 탈출해도 권한 없음!
```

#### 7️⃣ Cgroup Namespace (리소스 제어 그룹 격리)

**각 컨테이너가 독립적인 cgroup 뷰를 가집니다.**

```
Cgroup Namespace가 하는 일:
- 컨테이너가 자신의 cgroup을 루트(/)로 봄
- 호스트의 cgroup 구조를 숨김

호스트에서 보는 cgroup:
/sys/fs/cgroup/
├── cpu/
│   ├── docker/
│   │   ├── container-a/
│   │   └── container-b/
│   └── system/
└── memory/
    └── docker/
        ├── container-a/
        └── container-b/

Container A에서 보는 cgroup:
/sys/fs/cgroup/
├── cpu/           (자신의 루트)
└── memory/        (자신의 루트)

호스트의 다른 cgroup이 보이지 않음!
```

### 🎓 네임스페이스 정리

```
┌─────────────────┬──────────────────┬────────────────────┐
│  Namespace      │   격리 대상      │    주요 용도       │
├─────────────────┼──────────────────┼────────────────────┤
│ PID             │ 프로세스 ID      │ 프로세스 격리      │
│ Network         │ 네트워크 스택    │ 네트워크 격리      │
│ Mount           │ 파일 시스템      │ 파일 격리          │
│ UTS             │ 호스트명         │ 식별              │
│ IPC             │ 프로세스 간 통신 │ IPC 격리          │
│ User            │ 사용자/그룹      │ 보안 강화         │
│ Cgroup          │ 리소스 제어      │ 리소스 뷰 격리    │
└─────────────────┴──────────────────┴────────────────────┘
```

---

## 📖 컨트롤 그룹 (cgroups)

### 🎯 핵심 질문: "컨테이너의 리소스 사용을 어떻게 제한할까?"

Cgroups(Control Groups)는 **프로세스 그룹의 리소스 사용을 제한하고 모니터링하는 Linux 커널 기능**입니다.

### 🔍 Cgroups의 주요 서브시스템

Docker는 다음 cgroup 서브시스템을 사용합니다:

#### 1️⃣ CPU Cgroup (CPU 사용량 제한)

**컨테이너가 사용할 수 있는 CPU를 제한합니다.**

```bash
# 1. CPU Shares (상대적)
$ docker run -d --name cpu-low --cpu-shares 512 stress
$ docker run -d --name cpu-high --cpu-shares 2048 stress

# CPU가 부족할 때:
# cpu-high가 cpu-low보다 4배 많은 CPU 할당
# (2048 / 512 = 4)

# 2. CPU Quota (절대적)
$ docker run -d --cpus="0.5" nginx
# 최대 0.5 CPU (50%) 사용 가능

$ docker run -d --cpus="2" postgres
# 최대 2 CPU (200%) 사용 가능

# 3. CPUSet (특정 코어)
$ docker run -d --cpuset-cpus="0,1" nginx
# CPU 0번, 1번 코어만 사용
```

#### 2️⃣ Memory Cgroup (메모리 사용량 제한)

**컨테이너가 사용할 수 있는 메모리를 제한합니다.**

```bash
# 1. 기본 메모리 제한
$ docker run -d --name mem-limit --memory="512m" nginx
# 최대 512MB RAM 사용 가능
# 초과 시 컨테이너 종료 (OOM Killed)

# 2. 메모리 + 스왑
$ docker run -d --memory="512m" --memory-swap="1g" nginx
# RAM: 512MB
# Swap: 512MB (1g - 512m)
# 총: 1GB 사용 가능

# 3. 소프트 제한
$ docker run -d \
  --memory="1g" \
  --memory-reservation="512m" \
  nginx
# 일반적으로: 512MB 사용 권장
# 필요시: 1GB까지 사용 가능
```

**OOM (Out of Memory) 테스트:**
```bash
# 메모리 제한 컨테이너 실행
$ docker run -it --memory="100m" ubuntu bash

# 컨테이너 내부에서 메모리 폭주
root@abc123:/# stress --vm 1 --vm-bytes 200m

# 곧 컨테이너 종료됨 (OOM Killed)

# 호스트에서 확인
$ docker ps -a
CONTAINER ID   STATUS
abc123         Exited (137)   # 137 = OOM Killed

$ docker inspect abc123 | grep OOMKilled
"OOMKilled": true
```

#### 3️⃣ Block I/O Cgroup (디스크 I/O 제한)

**컨테이너의 디스크 읽기/쓰기 속도를 제한합니다.**

```bash
# 1. 읽기 속도 제한
$ docker run -it \
  --device-read-bps /dev/sda:10mb \
  ubuntu bash

# /dev/sda에서 최대 10MB/s 읽기

root@abc123:/# dd if=/dev/zero of=/tmp/test bs=1M count=100
100+0 records in
100+0 records out
104857600 bytes (105 MB) copied, 10.5 s, 10.0 MB/s

# 정확히 10MB/s!
```

#### 4️⃣ PIDs Cgroup (프로세스 개수 제한)

**컨테이너가 생성할 수 있는 프로세스 수를 제한합니다.**

```bash
# 프로세스 수 제한
$ docker run -it --pids-limit=10 ubuntu bash

root@abc123:/# :(){ :|:& };:    # Fork Bomb!

bash: fork: retry: Resource temporarily unavailable
bash: fork: retry: Resource temporarily unavailable

# 10개 이상 프로세스 생성 불가!
# 시스템 보호됨!
```

### 🎓 Cgroups 베스트 프랙티스

```
✅ 권장 사항:

1. 항상 메모리 제한 설정
   --memory="512m"
   → OOM으로 인한 호스트 영향 방지

2. CPU 제한은 필요시에만
   --cpus="1.0"
   → CPU는 공유 가능하므로 제한 덜 중요

3. PIDs 제한 설정
   --pids-limit=200
   → Fork Bomb 공격 방지

4. 프로덕션에서는 보수적으로
   메모리 사용량의 150% 할당
   → 여유 공간 확보

5. 모니터링 필수
   docker stats 또는 Prometheus 사용
   → 실제 사용량 파악

❌ 피해야 할 것:

1. 메모리 제한 없이 실행
   → 호스트 메모리 고갈 위험

2. 너무 타이트한 제한
   --memory="10m" (너무 작음)
   → 컨테이너가 제대로 작동 안 함

3. Swap 무제한 허용
   --memory-swap="-1"
   → 디스크 I/O 폭주

4. OOM Killer 비활성화
   --oom-kill-disable
   → 시스템 전체 위험
```

---

## 📖 컨테이너 생명주기

### 🎯 컨테이너의 생명주기란?

컨테이너는 **생성부터 삭제까지 여러 상태를 거칩니다.**

### 🔄 생명주기 다이어그램

```
                    docker create
    (없음) ─────────────────────────→ Created
                                           │
                                           │ docker start
                                           ↓
                                      Starting...
                                           │
                                           ↓
    ┌─────────────────────────────────  Running  ───────────────┐
    │                                      │                     │
    │ docker unpause            docker pause                     │
    │                                      ↓                     │
    └─────────────────────────────────  Paused                  │
                                                                 │
                 docker stop / docker kill                       │
                 프로세스 종료 / 에러 발생                        │
                                           ↓                     │
                                       Stopped  ◄────────────────┘
                                           │
                                           │ docker start (재시작)
                                           ↓
                                      Running
                                           │
                                           │ docker rm
                                           ↓
                                       (삭제됨)
```

### 📖 각 상태 상세 설명

#### 1️⃣ Created (생성됨)

**컨테이너가 생성되었지만 아직 시작되지 않은 상태**

```bash
# 컨테이너 생성 (시작하지 않음)
$ docker create --name my-nginx nginx

abc123def456...

# 상태 확인
$ docker ps -a
CONTAINER ID   STATUS
abc123         Created

# 아직 실행되지 않음!
# 설정만 완료된 상태
```

#### 2️⃣ Running (실행 중)

**컨테이너가 정상적으로 실행 중인 상태**

```bash
# 컨테이너 시작
$ docker start my-nginx

# 또는 생성과 동시에 시작
$ docker run -d --name my-nginx nginx

# 상태 확인
$ docker ps
CONTAINER ID   STATUS          PORTS
abc123         Up 2 minutes    80/tcp

# 실행 중!
```

#### 3️⃣ Paused (일시정지)

**컨테이너의 모든 프로세스가 일시정지된 상태**

```bash
# 컨테이너 일시정지
$ docker pause my-nginx

# 상태 확인
$ docker ps
CONTAINER ID   STATUS
abc123         Up 5 minutes (Paused)

# 재개
$ docker unpause my-nginx
```

**Pause vs Stop:**
```
Pause:
- 프로세스 freeze
- 메모리 유지
- 재개 매우 빠름 (밀리초)
- 네트워크 연결 유지됨 (응답 안 함)

Stop:
- 프로세스 종료 (SIGTERM)
- 메모리 해제
- 재시작 느림 (초 단위)
- 네트워크 연결 해제
```

#### 4️⃣ Stopped (중지됨)

**컨테이너가 중지된 상태 (프로세스 종료)**

```bash
# 컨테이너 중지 (정상 종료)
$ docker stop my-nginx
# SIGTERM 전송 → 10초 대기 → SIGKILL

# 강제 종료
$ docker kill my-nginx
# 즉시 SIGKILL 전송

# 상태 확인
$ docker ps -a
CONTAINER ID   STATUS
abc123         Exited (0) 1 minute ago    # 정상 종료
def456         Exited (137) 2 minutes ago # Kill됨
```

**종료 코드 (Exit Code):**
```
Exit 0:   정상 종료
Exit 1:   애플리케이션 에러
Exit 137: SIGKILL (killed)
          137 = 128 + 9 (SIGKILL)
Exit 139: Segmentation Fault
Exit 143: SIGTERM
          143 = 128 + 15 (SIGTERM)
```

#### 5️⃣ Restarting (재시작 중)

**컨테이너가 재시작 정책에 따라 재시작되는 중**

```bash
# 재시작 정책 설정
$ docker run -d \
  --name my-app \
  --restart=on-failure:3 \
  myapp:latest

# 컨테이너가 실패하면 자동으로 재시작
# 최대 3번 시도
```

**재시작 정책:**
```
no (기본값):
- 재시작 안 함
- 수동으로만 시작 가능

always:
- 항상 재시작
- Docker daemon 시작 시에도 재시작

unless-stopped:
- 명시적으로 stop하지 않는 한 재시작
- Docker daemon 재시작 시에도 재시작

on-failure[:max-retries]:
- 에러 종료 시에만 재시작 (Exit Code ≠ 0)
- 최대 재시도 횟수 지정 가능
```

### 🔧 생명주기 관리 명령어

#### 기본 명령어

```bash
# 생성 (시작 안 함)
$ docker create nginx

# 생성 + 시작
$ docker run nginx

# 시작 (중지된 컨테이너)
$ docker start my-nginx

# 재시작
$ docker restart my-nginx

# 일시정지
$ docker pause my-nginx

# 재개
$ docker unpause my-nginx

# 중지 (정상)
$ docker stop my-nginx

# 강제 종료
$ docker kill my-nginx

# 삭제
$ docker rm my-nginx

# 실행 중인 컨테이너 강제 삭제
$ docker rm -f my-nginx
```

### 🎓 베스트 프랙티스

```
✅ 권장 사항:

1. 재시작 정책 항상 설정
   --restart=unless-stopped
   → 예기치 않은 종료에 대비

2. Graceful Shutdown 구현
   SIGTERM 신호 처리
   → 데이터 손실 방지

3. 헬스체크 설정
   HEALTHCHECK 명령어 사용
   → 자동 복구 가능

4. 로그 확인 습관화
   docker logs 정기 확인
   → 문제 조기 발견

5. 정기적인 정리
   docker system prune
   → 디스크 공간 확보


❌ 피해야 할 것:

1. kill 남용
   → stop 사용 권장

2. 재시작 정책 없이 운영
   → 장애 시 수동 복구 필요

3. 컨테이너에 중요 데이터 저장
   → 볼륨 사용

4. Exit Code 무시
   → 에러 원인 파악 어려움

5. 오래된 컨테이너 방치
   → 디스크 낭비
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 메모리 제한 없이 실행하여 호스트 장애 발생

**상황**: 주니어 개발자가 메모리 제한 없이 데이터베이스 컨테이너를 실행했고, 메모리 누수로 인해 호스트 전체가 먹통이 되었습니다.

```bash
# ❌ 주니어 개발자가 실행한 명령
$ docker run -d --name postgres postgres:13

# 메모리 제한이 없음!
# PostgreSQL이 메모리를 계속 사용
# 호스트 메모리 고갈 → 시스템 전체 느려짐
```

**문제점**:
- 문제 1: 메모리 제한이 없어 무한대로 사용 가능
- 문제 2: OOM Killer가 무작위로 프로세스 종료
- 문제 3: 호스트의 다른 컨테이너도 영향받음
- 왜 이 문제가 발생하는가: Cgroups 메모리 제한을 설정하지 않음

**해결책**:
```bash
# ✅ 올바른 코드
$ docker run -d \
  --name postgres \
  --memory="2g" \
  --memory-swap="2g" \
  --oom-kill-disable=false \
  postgres:13

# 설명
# --memory="2g": 최대 2GB RAM 사용
# --memory-swap="2g": 스왑 사용 안 함 (같은 값)
# --oom-kill-disable=false: OOM 시 컨테이너만 종료 (기본값)
```

**배운 점**:
- 프로덕션에서는 항상 메모리 제한 설정
- 메모리 사용량의 150% 정도로 여유있게 설정
- `docker stats`로 실제 사용량 모니터링 필수

### 시나리오 2: Docker stop vs kill 차이를 몰라 데이터 손실

**상황**: 주니어 개발자가 `docker kill`로 데이터베이스를 강제 종료하여 데이터가 손상되었습니다.

```bash
# ❌ 주니어 개발자가 실행한 명령
$ docker kill my-database

# SIGKILL 즉시 전송
# 데이터베이스가 진행 중인 트랜잭션 롤백 못함
# 데이터 손상 발생!
```

**문제점**:
- 문제 1: SIGKILL은 프로세스를 즉시 종료 (정리 작업 불가)
- 문제 2: 데이터베이스 연결이 깔끔하게 종료되지 않음
- 문제 3: 임시 파일, 잠금 파일이 남아있을 수 있음
- 왜 이 문제가 발생하는가: `kill`과 `stop`의 차이를 모름

**해결책**:
```bash
# ✅ 올바른 코드
$ docker stop my-database

# 설명
# 1. SIGTERM 전송 (정상 종료 요청)
#    → 데이터베이스가 진행 중인 작업 완료
#    → 연결 정리
#    → 데이터 플러시
# 2. 10초 대기 (타임아웃)
# 3. 타임아웃 후에도 종료 안 되면 SIGKILL
```

**타임아웃 조정:**
```bash
# 데이터베이스처럼 정리 시간이 오래 걸리는 경우
$ docker stop --time=30 my-database

# 30초 대기 후 SIGKILL
```

**배운 점**:
- `docker stop`: 정상 종료 (권장)
- `docker kill`: 강제 종료 (비상시만)
- 데이터베이스는 반드시 `stop` 사용
- 긴급 상황이 아니면 `kill` 사용 금지

### 시나리오 3: 재시작 정책 없이 운영하여 야간 장애

**상황**: 주니어 개발자가 재시작 정책 없이 웹 서버를 실행했고, 야간에 크래시가 발생했지만 자동 복구되지 않아 서비스가 중단되었습니다.

```bash
# ❌ 주니어 개발자가 실행한 명령
$ docker run -d --name webapp -p 80:80 myapp:latest

# 재시작 정책이 없음 (기본값: no)
# 크래시 발생 시 수동으로 재시작해야 함

# 야간 2시에 메모리 부족으로 크래시
# 아침까지 서비스 중단!
```

**문제점**:
- 문제 1: 재시작 정책이 없어 수동 복구 필요
- 문제 2: 야간/주말에는 즉시 대응 불가
- 문제 3: 서비스 가용성 저하
- 왜 이 문제가 발생하는가: 재시작 정책을 설정하지 않음

**해결책**:
```bash
# ✅ 올바른 코드 - 프로덕션 웹 서버
$ docker run -d \
  --name webapp \
  --restart=always \
  -p 80:80 \
  myapp:latest

# 설명
# --restart=always: 항상 재시작
# - 크래시 시 즉시 재시작
# - 호스트 재부팅 시에도 자동 시작
# - 수동으로 stop하지 않는 한 계속 실행

# ✅ 대안 - 실패 시에만 재시작 (최대 5번)
$ docker run -d \
  --name webapp \
  --restart=on-failure:5 \
  -p 80:80 \
  myapp:latest

# 설명
# --restart=on-failure:5
# - Exit Code가 0이 아닐 때만 재시작
# - 최대 5번 재시도
# - 정상 종료(Exit 0)는 재시작 안 함
```

**재시작 횟수 확인:**
```bash
$ docker inspect webapp | grep RestartCount
"RestartCount": 3
```

**배운 점**:
- 프로덕션에서는 항상 재시작 정책 설정
- 웹 서버/API: `--restart=always`
- 배치 작업: `--restart=on-failure:N`
- 개발 환경: `--restart=no` (직접 제어)

### 시나리오 4: PID 1 문제로 시그널 처리 안 됨

**상황**: 주니어 개발자가 셸 스크립트를 PID 1로 실행했고, `docker stop`이 제대로 작동하지 않아 항상 10초 타임아웃이 발생합니다.

```bash
# ❌ 주니어 개발자의 Dockerfile
FROM node:16
WORKDIR /app
COPY . .

# 문제: 셸 스크립트가 PID 1
CMD ["sh", "-c", "node app.js"]

# 또는
ENTRYPOINT ["/bin/sh"]
CMD ["-c", "node app.js"]
```

**문제점**:
- 문제 1: `sh`가 PID 1이 되어 시그널을 `node`에 전달 안 함
- 문제 2: `docker stop` 시 10초 대기 후 강제 종료
- 문제 3: Graceful Shutdown 불가능
- 왜 이 문제가 발생하는가: PID 1은 시그널 전달 책임이 있지만 `sh`는 이를 안 함

**해결책 1: 직접 실행**
```dockerfile
# ✅ 올바른 Dockerfile
FROM node:16
WORKDIR /app
COPY . .

# Node.js를 PID 1로 직접 실행
CMD ["node", "app.js"]

# 설명
# node 프로세스가 PID 1
# SIGTERM을 직접 받아 처리 가능
```

**해결책 2: tini 사용**
```dockerfile
# ✅ init 프로세스 사용
FROM node:16

# tini 설치
RUN apt-get update && apt-get install -y tini

WORKDIR /app
COPY . .

# tini를 PID 1로, node를 자식 프로세스로
ENTRYPOINT ["/usr/bin/tini", "--"]
CMD ["node", "app.js"]

# 설명
# tini가 PID 1
# 시그널을 올바르게 자식에게 전달
# 좀비 프로세스 제거
```

**해결책 3: --init 플래그**
```bash
# ✅ docker run 시 init 사용
$ docker run -d \
  --name myapp \
  --init \
  myapp:latest

# 설명
# Docker가 tini를 자동으로 PID 1로 주입
# Dockerfile 수정 불필요
```

**테스트:**
```bash
# 정상적으로 종료되는지 확인
$ time docker stop myapp

# 10초가 아닌 1-2초 내 종료되면 성공!
```

**배운 점**:
- PID 1은 특별한 책임이 있음 (시그널 처리, 좀비 프로세스 제거)
- 셸 스크립트를 PID 1로 사용하지 말 것
- `--init` 플래그 또는 `tini` 사용 권장
- Graceful Shutdown을 위해 시그널 처리 필수

---

## ❓ FAQ

<details>
<summary><strong>Q1: 네임스페이스와 Cgroups의 차이는 무엇인가요?</strong></summary>

**A**: 네임스페이스는 "격리(isolation)"를, Cgroups는 "제한(limitation)"을 담당합니다.

**상세 설명**:
- **네임스페이스**: "무엇을 볼 수 있는가" 제어
  - 각 컨테이너가 독립된 PID, 네트워크, 파일 시스템 등을 가짐
  - 서로 보이지 않게 격리

- **Cgroups**: "얼마나 사용할 수 있는가" 제어
  - CPU, 메모리, 디스크 I/O 사용량 제한
  - 리소스 독점 방지

**예시**:
```bash
# 네임스페이스: 격리
$ docker run --name A nginx
$ docker run --name B nginx
# A와 B는 서로의 프로세스를 볼 수 없음 (PID Namespace)
# A와 B는 각자의 IP 주소를 가짐 (Network Namespace)

# Cgroups: 제한
$ docker run --memory="512m" --cpus="0.5" nginx
# 메모리 512MB 이상 사용 불가
# CPU 0.5코어 이상 사용 불가
```

**실무 팁**:
네임스페이스는 보안을, Cgroups는 안정성을 제공합니다. 둘 다 설정해야 완벽한 멀티테넌시 환경을 구축할 수 있습니다.

</details>

<details>
<summary><strong>Q2: docker stop과 docker kill의 차이는 무엇이고 언제 사용해야 하나요?</strong></summary>

**A**: `stop`은 정상 종료(SIGTERM → SIGKILL), `kill`은 즉시 강제 종료(SIGKILL)입니다.

**상세 설명**:

**docker stop**:
1. SIGTERM(15) 전송 → 애플리케이션에 "종료 준비하세요" 신호
2. 10초 대기 (타임아웃 조정 가능: `--time=30`)
3. 타임아웃 후 SIGKILL(9) 전송 → 강제 종료

**docker kill**:
1. SIGKILL(9) 즉시 전송
2. 정리 작업 없이 즉시 종료

**예시**:
```bash
# 정상 종료 (권장)
$ docker stop my-database
# 데이터베이스가 다음을 수행:
# - 진행 중인 쿼리 완료
# - 트랜잭션 커밋/롤백
# - 연결 정리
# - 캐시 플러시
# - 임시 파일 삭제

# 강제 종료 (비상시)
$ docker kill my-database
# 아무 정리 작업 없이 즉시 종료
# 데이터 손실 위험!
```

**언제 사용하나**:
- **stop**: 99%의 경우 (기본)
- **kill**: 컨테이너가 응답 없을 때, stop이 안 될 때

**실무 팁**:
데이터베이스나 중요한 상태를 가진 컨테이너는 반드시 `stop`을 사용하세요. `kill`은 정말 급할 때만!

</details>

<details>
<summary><strong>Q3: --restart=always와 --restart=unless-stopped의 차이는?</strong></summary>

**A**: 둘 다 자동 재시작하지만, `unless-stopped`는 수동 stop을 존중합니다.

**상세 설명**:

**--restart=always**:
- 컨테이너가 중지되면 항상 재시작
- Docker daemon 재시작 시에도 자동 시작
- `docker stop`으로 중지해도 daemon 재시작 시 다시 시작

**--restart=unless-stopped**:
- 컨테이너가 중지되면 재시작
- Docker daemon 재시작 시에도 자동 시작
- 단, `docker stop`으로 수동 중지한 경우는 재시작 안 함

**예시**:
```bash
# always 테스트
$ docker run -d --name test1 --restart=always nginx
$ docker stop test1
$ sudo systemctl restart docker
$ docker ps
# test1이 다시 실행 중! (수동 stop 무시)

# unless-stopped 테스트
$ docker run -d --name test2 --restart=unless-stopped nginx
$ docker stop test2
$ sudo systemctl restart docker
$ docker ps
# test2는 중지 상태 유지 (수동 stop 존중)
```

**언제 사용하나**:
- **always**: 항상 실행되어야 하는 인프라 서비스 (모니터링, 로그 수집)
- **unless-stopped**: 일반 애플리케이션 (수동 제어 필요 시)

**실무 팁**:
대부분의 경우 `unless-stopped`를 권장합니다. 유지보수 시 수동으로 중지한 것을 존중하기 때문입니다.

</details>

<details>
<summary><strong>Q4: 메모리 제한을 설정했는데 컨테이너가 계속 종료됩니다. 왜 그럴까요?</strong></summary>

**A**: 메모리 제한이 너무 작거나, 애플리케이션에 메모리 누수가 있을 수 있습니다.

**상세 설명**:

**진단 방법**:
```bash
# 1. OOM으로 종료되었는지 확인
$ docker inspect my-container | grep OOMKilled
"OOMKilled": true

# 2. 종료 코드 확인
$ docker ps -a
CONTAINER ID   STATUS
abc123         Exited (137)  # 137 = OOM Killed

# 3. 실제 메모리 사용량 확인
$ docker stats --no-stream my-container
CONTAINER ID   MEM USAGE / LIMIT
abc123         510MB / 512MB  # 한계에 근접!

# 4. 로그 확인
$ docker logs my-container
...
Error: JavaScript heap out of memory
```

**해결책**:

**1. 메모리 제한 증가**:
```bash
# 기존
$ docker run --memory="512m" myapp

# 수정 (2배로)
$ docker run --memory="1g" myapp
```

**2. 애플리케이션 메모리 설정 조정**:
```bash
# Node.js 예시
$ docker run -e NODE_OPTIONS="--max-old-space-size=900" \
  --memory="1g" \
  myapp

# Java 예시
$ docker run -e JAVA_OPTS="-Xmx768m" \
  --memory="1g" \
  myapp
```

**3. 메모리 누수 조사**:
```bash
# 힙 덤프 수집
$ docker exec myapp kill -USR2 1

# 프로파일링 도구 사용
# - Node.js: node --inspect
# - Java: VisualVM, JProfiler
```

**베스트 프랙티스**:
- 컨테이너 메모리 제한 > 애플리케이션 힙 크기 + 200MB
- 예: 애플리케이션 768MB → 컨테이너 1GB
- 여유 공간: 운영체제, 버퍼, 캐시용

**실무 팁**:
프로덕션 배포 전 부하 테스트로 실제 메모리 사용량을 측정하세요. 측정값의 150%를 제한으로 설정하는 것이 안전합니다.

</details>

<details>
<summary><strong>Q5: User Namespace를 사용하면 보안이 얼마나 향상되나요?</strong></summary>

**A**: 컨테이너 탈출 공격 시에도 호스트 root 권한을 얻을 수 없게 되어 보안이 크게 향상됩니다.

**상세 설명**:

**User Namespace 없이**:
```bash
# 컨테이너 내부
root@container:/# id
uid=0(root) gid=0(root)

# 호스트에서 확인
$ ps aux | grep container-process
root  12345  ... /bin/bash

# 문제: 컨테이너 root = 호스트 root (UID 0)
# 컨테이너 탈출 시 호스트 전체 장악 가능!
```

**User Namespace 사용**:
```bash
# Docker Daemon 설정
$ cat /etc/docker/daemon.json
{
  "userns-remap": "default"
}

$ sudo systemctl restart docker

# 컨테이너 내부 (변화 없어 보임)
root@container:/# id
uid=0(root) gid=0(root)

# 호스트에서 확인
$ ps aux | grep container-process
100000  12345  ... /bin/bash

# 해결: 컨테이너 root(0) → 호스트 nobody(100000)
# 컨테이너 탈출해도 권한 없음!
```

**실제 공격 시나리오**:
```bash
# User Namespace 없이
# 1. 컨테이너에서 취약점 발견
# 2. 컨테이너 탈출
# 3. 호스트에서 root 권한 획득 ← 위험!
# 4. 모든 컨테이너/데이터 접근 가능

# User Namespace 사용
# 1. 컨테이너에서 취약점 발견
# 2. 컨테이너 탈출
# 3. 호스트에서 UID 100000 권한 획득 ← 제한됨
# 4. 아무것도 할 수 없음 (권한 부족)
```

**주의사항**:
- 볼륨 권한 문제 발생 가능
- 기존 이미지와 호환성 이슈
- 파일 시스템 재생성 필요

**실무 팁**:
보안이 중요한 프로덕션 환경에서는 User Namespace 사용을 적극 권장합니다. 단, 테스트 환경에서 충분히 검증 후 적용하세요.

</details>

<details>
<summary><strong>Q6: docker pause는 언제 사용하나요?</strong></summary>

**A**: 컨테이너를 빠르게 일시정지/재개하거나, 체크포인트를 생성할 때 사용합니다.

**상세 설명**:

**pause의 특징**:
- 모든 프로세스를 즉시 freeze (cgroup freezer)
- 메모리 내용 그대로 유지
- 재개가 매우 빠름 (밀리초 단위)
- CPU 사용 0%

**사용 사례**:

**1. 긴급 리소스 회수**:
```bash
# 갑자기 CPU/메모리가 부족할 때
$ docker pause low-priority-job
# 즉시 리소스 사용 중지

# 여유 생기면 재개
$ docker unpause low-priority-job
```

**2. 체크포인트/스냅샷**:
```bash
# 실행 중인 상태를 저장하고 싶을 때
$ docker pause my-app
# 이 상태에서 파일 시스템 백업
$ docker commit my-app my-app:snapshot
$ docker unpause my-app
```

**3. 디버깅**:
```bash
# 문제 발생 시 현장 보존
$ docker pause problematic-app
# 메모리 덤프, 네트워크 상태 등 조사
# 조사 완료 후 재개 또는 종료
```

**4. 마이그레이션 준비**:
```bash
# 컨테이너를 다른 호스트로 옮길 때
$ docker pause my-app
$ docker commit my-app my-app:migrate
$ docker save my-app:migrate > app.tar
# 다른 호스트로 전송 후 복원
```

**pause vs stop 비교**:
```bash
# Pause (순간적)
$ time docker pause my-app
real  0.05s  # 50ms

$ time docker unpause my-app
real  0.03s  # 30ms

# Stop (시간 소요)
$ time docker stop my-app
real  10.5s  # 10초 이상

$ time docker start my-app
real  3.2s   # 3초 이상
```

**실무 팁**:
`pause`는 일시적인 조치에 적합합니다. 장기간 중지하려면 `stop`을 사용하세요.

</details>

<details>
<summary><strong>Q7: 프로덕션에서 권장하는 리소스 제한 설정은?</strong></summary>

**A**: 애플리케이션 유형별로 다르지만, 기본 원칙은 "측정 후 여유있게 설정"입니다.

**상세 설명**:

**기본 원칙**:
1. 실제 사용량 측정 (부하 테스트)
2. 피크 사용량의 150% 할당
3. 메모리는 반드시 제한, CPU는 선택적

**애플리케이션 유형별 권장 설정**:

**1. 경량 웹 서버 (Nginx, Apache)**:
```bash
$ docker run -d \
  --name nginx \
  --cpus="0.5" \
  --memory="256m" \
  --memory-swap="256m" \
  --pids-limit=100 \
  --restart=unless-stopped \
  nginx
```

**2. 중형 애플리케이션 서버 (Node.js, Python Flask)**:
```bash
$ docker run -d \
  --name webapp \
  --cpus="1.5" \
  --memory="1g" \
  --memory-swap="1g" \
  --pids-limit=200 \
  --restart=unless-stopped \
  myapp:latest
```

**3. 중량 데이터베이스 (PostgreSQL, MySQL)**:
```bash
$ docker run -d \
  --name database \
  --cpus="4" \
  --memory="4g" \
  --memory-swap="4g" \
  --pids-limit=500 \
  --restart=unless-stopped \
  --stop-timeout=30 \
  postgres:13
```

**4. 메모리 집약적 (Java, Elasticsearch)**:
```bash
$ docker run -d \
  --name elasticsearch \
  --cpus="2" \
  --memory="2g" \
  --memory-swap="2g" \
  --pids-limit=300 \
  --restart=unless-stopped \
  -e "ES_JAVA_OPTS=-Xms1g -Xmx1g" \
  elasticsearch:7.10
```

**5. 배치/백그라운드 작업**:
```bash
$ docker run -d \
  --name batch-job \
  --cpus="0.25" \
  --cpu-shares=256 \
  --memory="512m" \
  --pids-limit=50 \
  --restart=on-failure:3 \
  mybatch:latest
```

**모니터링 및 조정**:
```bash
# 1. 실제 사용량 측정 (1주일)
$ docker stats --format "{{.Container}},{{.CPUPerc}},{{.MemUsage}}" >> stats.log

# 2. 최대값 확인
$ cat stats.log | sort -t, -k3 -rn | head -1

# 3. 여유 추가 (1.5배)
# 최대 사용량이 600MB였다면 → 900MB 할당
```

**베스트 프랙티스**:
- 메모리: 항상 제한 (OOM 방지)
- CPU: 중요 서비스만 제한 (공유 가능)
- PIDs: 항상 제한 (Fork Bomb 방지)
- Swap: 비활성화 권장 (성능)
- 재시작: unless-stopped 또는 always

**실무 팁**:
처음에는 넉넉하게 설정하고, 모니터링 데이터를 바탕으로 점진적으로 최적화하세요.

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용 (5-7개)

<details>
<summary><strong>1. Docker 컨테이너 격리의 핵심 기술 두 가지는 무엇이고, 각각 어떤 역할을 하나요?</strong></summary>

**모범 답안 포인트**
- 네임스페이스(Namespace): 격리(isolation) 담당
- Cgroups(Control Groups): 리소스 제한(limitation) 담당
- 네임스페이스는 "무엇을 볼 수 있는가"를 제어
- Cgroups는 "얼마나 사용할 수 있는가"를 제어

**예시 답변**
> "Docker 컨테이너 격리는 네임스페이스와 Cgroups 두 가지 핵심 기술로 구현됩니다.
>
> 네임스페이스는 각 컨테이너가 독립된 PID, 네트워크, 파일 시스템 등을 가지도록 격리하는 역할을 합니다. 예를 들어 PID Namespace를 통해 각 컨테이너는 자신의 PID 1을 가지며 다른 컨테이너의 프로세스를 볼 수 없습니다.
>
> Cgroups는 컨테이너의 CPU, 메모리, 디스크 I/O 등 리소스 사용량을 제한합니다. 예를 들어 --memory 옵션으로 메모리를 512MB로 제한하면 해당 컨테이너는 그 이상 사용할 수 없습니다."

**꼬리 질문**
- Q: 7가지 네임스페이스를 말씀해보세요.
- A: PID, Network, Mount, UTS, IPC, User, Cgroup Namespace입니다.

- Q: 메모리 제한을 초과하면 어떻게 되나요?
- A: OOM Killer가 컨테이너를 종료시킵니다 (Exit Code 137).

**실무 연관**
프로덕션 환경에서 메모리 제한 없이 컨테이너를 실행하면 한 컨테이너의 메모리 누수가 호스트 전체를 마비시킬 수 있습니다. 따라서 항상 적절한 리소스 제한을 설정해야 합니다.

</details>

<details>
<summary><strong>2. docker stop과 docker kill의 차이를 설명하고, 언제 각각 사용해야 하나요?</strong></summary>

**모범 답안 포인트**
- docker stop: SIGTERM → 10초 대기 → SIGKILL (정상 종료)
- docker kill: 즉시 SIGKILL (강제 종료)
- stop은 애플리케이션이 정리 작업을 할 시간을 줌
- 데이터베이스 등은 반드시 stop 사용

**예시 답변**
> "docker stop은 먼저 SIGTERM 신호를 보내 애플리케이션에게 정상 종료를 요청하고, 10초 대기 후에도 종료되지 않으면 SIGKILL로 강제 종료합니다. 반면 docker kill은 즉시 SIGKILL을 보내 프로세스를 강제로 종료합니다.
>
> docker stop을 사용하면 애플리케이션이 진행 중인 작업을 완료하고, 데이터베이스 연결을 정리하며, 임시 파일을 삭제하는 등 정리 작업을 수행할 수 있습니다. 따라서 99%의 경우 docker stop을 사용해야 하고, kill은 컨테이너가 응답하지 않을 때 등 비상 상황에서만 사용해야 합니다."

**꼬리 질문**
- Q: SIGTERM과 SIGKILL의 차이는?
- A: SIGTERM(15)은 정상 종료 요청으로 프로세스가 무시할 수 있지만, SIGKILL(9)은 강제 종료로 무시할 수 없습니다.

**실무 연관**
PostgreSQL 같은 데이터베이스를 docker kill로 종료하면 트랜잭션이 롤백되지 않아 데이터가 손상될 수 있습니다. 실무에서는 --stop-timeout을 30초 이상으로 설정하여 충분한 정리 시간을 제공합니다.

</details>

<details>
<summary><strong>3. 컨테이너 생명주기의 주요 상태들을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- Created: 생성됨, 아직 시작 안 함
- Running: 실행 중
- Paused: 일시정지 (메모리 유지)
- Stopped: 중지됨 (프로세스 종료)
- 각 상태 간 전환 명령어

**예시 답변**
> "컨테이너는 다음과 같은 생명주기를 가집니다.
>
> 1. Created: docker create로 컨테이너가 생성되었지만 아직 시작되지 않은 상태입니다. 설정은 완료되었지만 프로세스는 실행되지 않습니다.
>
> 2. Running: docker start 또는 docker run으로 컨테이너가 실행 중인 상태입니다. 프로세스가 동작하고 리소스를 사용합니다.
>
> 3. Paused: docker pause로 모든 프로세스가 일시정지된 상태입니다. 메모리는 그대로 유지되고 CPU 사용은 0%가 됩니다. docker unpause로 즉시 재개할 수 있습니다.
>
> 4. Stopped: docker stop으로 프로세스가 종료된 상태입니다. 컨테이너 레이어와 로그는 보존되며 docker start로 재시작할 수 있습니다."

**꼬리 질문**
- Q: Paused와 Stopped의 차이는?
- A: Paused는 프로세스를 freeze하여 메모리를 유지하고 재개가 빠릅니다. Stopped는 프로세스를 종료하여 메모리를 해제하고 재시작이 느립니다.

**실무 연관**
프로덕션에서는 재시작 정책(--restart)을 설정하여 컨테이너가 Stopped 상태가 되면 자동으로 Running으로 복귀하도록 합니다. 이를 통해 장애 시 수동 개입 없이 자동 복구가 가능합니다.

</details>

<details>
<summary><strong>4. 재시작 정책(restart policy)의 종류와 각각의 용도를 설명해주세요.</strong></summary>

**모범 답안 포인트**
- no: 재시작 안 함 (기본값)
- always: 항상 재시작
- unless-stopped: 수동 stop 제외하고 재시작
- on-failure: 에러 시에만 재시작
- 프로덕션에서는 unless-stopped 권장

**예시 답변**
> "Docker는 4가지 재시작 정책을 제공합니다.
>
> 1. no (기본값): 자동 재시작하지 않습니다. 개발 환경에서 직접 제어할 때 사용합니다.
>
> 2. always: 컨테이너가 중지되면 항상 재시작합니다. Docker daemon이 재시작될 때도 자동으로 시작됩니다. 수동으로 docker stop을 실행해도 daemon 재시작 시 다시 시작됩니다.
>
> 3. unless-stopped: always와 비슷하지만 docker stop으로 수동 중지한 경우는 재시작하지 않습니다. 대부분의 프로덕션 서비스에 권장됩니다.
>
> 4. on-failure[:max-retries]: 에러로 종료된 경우(Exit Code ≠ 0)에만 재시작합니다. 최대 재시도 횟수를 지정할 수 있습니다."

**꼬리 질문**
- Q: 웹 서버와 배치 작업에는 어떤 정책을 사용해야 하나요?
- A: 웹 서버는 unless-stopped 또는 always, 배치 작업은 on-failure:N을 사용합니다.

**실무 연관**
프로덕션에서 재시작 정책 없이 운영하면 야간에 크래시가 발생했을 때 아침까지 서비스가 중단될 수 있습니다. unless-stopped를 사용하면 자동 복구되면서도 유지보수 시 수동 제어가 가능합니다.

</details>

<details>
<summary><strong>5. 메모리 제한(--memory) 설정 시 주의할 점은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 항상 설정해야 함 (호스트 보호)
- 애플리케이션 힙 크기 + 여유 공간 필요
- OOM Killer 발동 시 컨테이너 종료
- Swap 설정 고려
- 실제 사용량 모니터링 필수

**예시 답변**
> "메모리 제한 설정 시 다음 사항을 주의해야 합니다.
>
> 1. 프로덕션에서는 반드시 메모리 제한을 설정해야 합니다. 제한이 없으면 한 컨테이너의 메모리 누수가 호스트 전체를 마비시킬 수 있습니다.
>
> 2. 컨테이너 메모리 제한은 애플리케이션 힙 크기보다 커야 합니다. 예를 들어 Node.js에서 --max-old-space-size=900이면 컨테이너는 최소 1GB로 설정해야 합니다. 운영체제와 버퍼를 위한 여유 공간이 필요하기 때문입니다.
>
> 3. 메모리 제한을 초과하면 OOM Killer가 컨테이너를 종료시킵니다(Exit Code 137). docker inspect로 OOMKilled 플래그를 확인할 수 있습니다.
>
> 4. --memory-swap 설정으로 스왑 사용을 제어할 수 있습니다. 프로덕션에서는 스왑을 비활성화(--memory-swap과 --memory를 같게)하는 것이 성능상 유리합니다."

**꼬리 질문**
- Q: 메모리 제한을 어떻게 결정하나요?
- A: 부하 테스트로 피크 사용량을 측정하고, 그 값의 150% 정도로 설정합니다.

**실무 연관**
실무에서는 docker stats나 Prometheus로 지속적으로 메모리 사용량을 모니터링하고, 사용량이 80%를 넘으면 제한을 늘리거나 애플리케이션을 최적화합니다.

</details>

<details>
<summary><strong>6. PID Namespace가 없다면 어떤 보안 문제가 발생할 수 있나요?</strong></summary>

**모범 답안 포인트**
- 컨테이너끼리 프로세스가 보임
- 다른 컨테이너의 프로세스를 kill 할 수 있음
- 호스트 프로세스 조작 가능
- 프로세스 격리가 Docker의 핵심

**예시 답변**
> "PID Namespace가 없다면 심각한 보안 문제가 발생합니다.
>
> 1. 컨테이너 A에서 ps 명령어를 실행하면 컨테이너 B와 호스트의 모든 프로세스가 보입니다. 이는 정보 노출 문제입니다.
>
> 2. 컨테이너 A에서 kill 명령어로 다른 컨테이너나 호스트의 프로세스를 종료시킬 수 있습니다. 악의적으로 전체 시스템을 마비시킬 수 있습니다.
>
> 3. 프로세스 간섭으로 예측 불가능한 동작이 발생할 수 있습니다.
>
> PID Namespace를 통해 각 컨테이너는 자신만의 PID 공간을 가지며, 다른 컨테이너나 호스트의 프로세스를 볼 수도, 조작할 수도 없습니다. 이것이 Docker 격리의 핵심입니다."

**꼬리 질문**
- Q: 컨테이너 내부에서 PID 1이 특별한 이유는?
- A: PID 1은 init 프로세스로 시그널 처리와 좀비 프로세스 제거 책임이 있습니다.

**실무 연관**
실무에서는 --pid=host 옵션으로 호스트 PID Namespace를 공유할 수 있지만, 이는 디버깅 목적으로만 사용하고 프로덕션에서는 절대 사용하면 안 됩니다.

</details>

<details>
<summary><strong>7. docker stats 명령어로 확인할 수 있는 정보와 그 활용 방법은?</strong></summary>

**모범 답안 포인트**
- CPU 사용률 (%)
- 메모리 사용량 / 제한
- 네트워크 I/O
- 블록 I/O
- 실시간 모니터링 도구

**예시 답변**
> "docker stats는 컨테이너의 리소스 사용량을 실시간으로 모니터링하는 명령어입니다.
>
> 확인할 수 있는 정보:
> 1. CPU %: CPU 사용률 (--cpus 제한 대비)
> 2. MEM USAGE / LIMIT: 메모리 사용량과 제한
> 3. MEM %: 메모리 사용 비율
> 4. NET I/O: 네트워크 입출력 누적량
> 5. BLOCK I/O: 디스크 입출력 누적량
> 6. PIDS: 현재 프로세스 수
>
> 활용 방법:
> - 메모리 사용량이 제한에 근접하면 제한 증가 또는 최적화
> - CPU 사용률이 계속 100%면 CPU 제한 증가 고려
> - 프로덕션에서는 결과를 로그로 저장하여 추세 분석
> - docker stats --no-stream으로 현재 시점 측정
> - --format으로 JSON 형식 출력하여 자동화"

**꼬리 질문**
- Q: docker stats의 한계는 무엇인가요?
- A: 기본 모니터링만 제공하므로 프로덕션에서는 Prometheus + Grafana 같은 전문 도구가 필요합니다.

**실무 연관**
실무에서는 docker stats의 출력을 주기적으로 수집하여 리소스 사용 추세를 파악하고, 이를 바탕으로 리소스 제한을 최적화합니다. 또한 알림 시스템과 연동하여 사용량이 임계값을 넘으면 자동으로 알림을 받습니다.

</details>

---

### 📗 중급 개발자용 (3-5개)

<details>
<summary><strong>1. User Namespace의 동작 원리와 보안상 이점을 상세히 설명해주세요.</strong></summary>

**모범 답안 포인트**
- UID/GID 매핑 메커니즘
- 컨테이너 root → 호스트 nobody
- /etc/subuid, /etc/subgid 설정
- 컨테이너 탈출 공격 방어
- 볼륨 권한 문제 해결 방법

**예시 답변**
> "User Namespace는 컨테이너 내부의 UID/GID를 호스트의 다른 UID/GID로 매핑하는 기술입니다.
>
> 동작 원리:
> 1. /etc/subuid와 /etc/subgid에 매핑 규칙 정의
>    예: dockremap:100000:65536
>    의미: dockremap 사용자가 100000부터 65536개의 UID 사용
>
> 2. 컨테이너 내부 UID 0(root) → 호스트 UID 100000으로 매핑
>    컨테이너 내부 UID 1 → 호스트 UID 100001
>    컨테이너 내부 UID 1000 → 호스트 UID 101000
>
> 3. 컨테이너는 자신이 root라고 생각하지만, 호스트에서는 일반 사용자 권한만 가짐
>
> 보안 이점:
> - 컨테이너 탈출 공격이 성공해도 호스트에서는 UID 100000의 제한된 권한만 획득
> - 호스트 파일 시스템 조작 불가
> - 다른 컨테이너 간섭 불가
>
> 볼륨 권한 문제:
> - 호스트의 파일이 UID 1000 소유라면, 컨테이너에서는 UID 101000으로 보임
> - 해결: 볼륨 생성 시 --userns-remap 고려하여 권한 설정
> - 또는 컨테이너 내에서 적절한 UID 사용"

**예시 코드**:
```bash
# User Namespace 활성화
$ cat /etc/docker/daemon.json
{
  "userns-remap": "default"
}

$ sudo systemctl restart docker

# 확인
$ docker run -it ubuntu bash
root@container:/# id
uid=0(root) gid=0(root)

# 호스트에서
$ ps aux | grep bash
100000  12345  /bin/bash

# 컨테이너 root(0) = 호스트 100000
```

**꼬리 질문**
- Q: 모든 컨테이너에 User Namespace를 적용해야 하나요?
- A: 보안이 중요하면 적용하되, 호환성 문제가 있을 수 있어 테스트 후 단계적으로 적용합니다.

**실무 연관**
금융, 의료 등 보안이 중요한 산업에서는 User Namespace를 필수로 적용합니다. 다만 레거시 이미지와의 호환성 문제가 있을 수 있어 충분한 테스트가 필요합니다.

</details>

<details>
<summary><strong>2. PID 1 문제(PID 1 problem)가 무엇이고, 어떻게 해결하나요?</strong></summary>

**모범 답안 포인트**
- PID 1의 특별한 책임 (시그널, 좀비 프로세스)
- 셸 스크립트를 PID 1로 사용 시 문제
- tini, dumb-init 같은 init 시스템
- --init 플래그
- exec 명령어 사용

**예시 답변**
> "PID 1 문제는 컨테이너의 메인 프로세스(PID 1)가 init 프로세스의 책임을 제대로 수행하지 못할 때 발생합니다.
>
> PID 1의 책임:
> 1. 시그널 처리: SIGTERM을 받아 자식 프로세스에 전파
> 2. 좀비 프로세스 제거: 고아 프로세스를 wait()로 수거
>
> 문제 상황:
> - 셸 스크립트(sh, bash)를 PID 1로 사용하면 시그널을 자식에게 전달하지 않음
> - docker stop 실행 시 SIGTERM이 셸에게 가지만, 셸은 자식 프로세스에 전달 안 함
> - 10초 타임아웃 후 SIGKILL로 강제 종료 → Graceful Shutdown 불가
>
> 해결 방법:
>
> 1. 프로세스를 직접 실행 (권장):
> ```dockerfile
> # 나쁜 예
> CMD [\"sh\", \"-c\", \"node app.js\"]
>
> # 좋은 예
> CMD [\"node\", \"app.js\"]
> ```
>
> 2. tini 사용:
> ```dockerfile
> RUN apt-get install -y tini
> ENTRYPOINT [\"/usr/bin/tini\", \"--\"]
> CMD [\"node\", \"app.js\"]
> ```
>
> 3. docker run --init:
> ```bash
> docker run --init myapp
> ```
>
> 4. exec 명령어 사용 (스크립트 내):
> ```bash
> #!/bin/sh
> # 초기화 작업
> ...
> # exec로 현재 프로세스를 대체
> exec node app.js
> ```"

**실무 예시**:
```bash
# 문제 확인
$ docker run -d --name test myapp
$ time docker stop test
# 10초 걸림 → 문제 있음

# 해결 후
$ docker run -d --name test --init myapp
$ time docker stop test
# 1-2초 걸림 → 정상
```

**꼬리 질문**
- Q: 좀비 프로세스가 많으면 어떤 문제가 발생하나요?
- A: 프로세스 테이블을 소진하여 새 프로세스를 생성할 수 없게 됩니다.

**실무 연관**
프로덕션에서 Graceful Shutdown이 작동하지 않으면 롤링 업데이트 시 연결이 끊기고, 데이터가 손실될 수 있습니다. 모든 컨테이너에 --init을 적용하는 것이 안전합니다.

</details>

<details>
<summary><strong>3. Cgroups v1과 v2의 차이점과 마이그레이션 시 고려사항은?</strong></summary>

**모범 답안 포인트**
- v1: 계층 구조, 다중 계층
- v2: 통합 계층, 단순화
- 성능 개선
- 호환성 문제
- systemd 의존성

**예시 답변**
> "Cgroups v1과 v2는 구조와 기능에서 차이가 있습니다.
>
> Cgroups v1:
> - 각 서브시스템(cpu, memory, blkio 등)이 독립적인 계층 구조
> - 한 프로세스가 여러 cgroup에 동시 속할 수 있음
> - 설정이 복잡하고 일관성 없음
> - 대부분의 레거시 시스템에서 사용
>
> Cgroups v2:
> - 통합된 단일 계층 구조
> - 한 프로세스는 하나의 cgroup에만 속함
> - 설정이 단순하고 일관적
> - 성능 개선 (특히 메모리 제어)
> - systemd와 긴밀히 통합
> - 새로운 기능: PSI (Pressure Stall Information)
>
> 마이그레이션 고려사항:
>
> 1. 커널 지원 확인:
> ```bash
> # v2 지원 확인
> $ grep cgroup2 /proc/filesystems
> nodev   cgroup2
> ```
>
> 2. systemd 버전:
> - systemd 226+ 필요
> - 대부분의 최신 배포판은 지원
>
> 3. 호환성:
> - 일부 도구가 v1에만 동작
> - Docker는 v2를 자동 감지하고 사용
> - Kubernetes는 1.25+에서 v2 GA
>
> 4. 단계적 마이그레이션:
> - 테스트 환경에서 먼저 검증
> - 모니터링 도구 호환성 확인
> - 롤백 계획 수립
>
> 5. 성능 테스트:
> - v2에서 메모리 제어가 더 정확
> - CPU 제어 알고리즘 개선"

**실무 예시**:
```bash
# 현재 사용 중인 cgroup 버전 확인
$ stat -fc %T /sys/fs/cgroup/
cgroup2fs  # v2 사용 중
tmpfs      # v1 사용 중

# Docker에서 cgroup 버전 확인
$ docker info | grep -i cgroup
Cgroup Driver: systemd
Cgroup Version: 2

# v2 기능 활용 (PSI - Pressure Stall Information)
$ cat /sys/fs/cgroup/memory.pressure
some avg10=0.00 avg60=0.00 avg300=0.00 total=0
full avg10=0.00 avg60=0.00 avg300=0.00 total=0
```

**꼬리 질문**
- Q: 프로덕션에서 v1에서 v2로 언제 마이그레이션해야 하나요?
- A: 레거시 시스템이 없다면 v2를 권장하지만, 급하지 않으면 생태계가 더 성숙해질 때까지 기다려도 됩니다.

**실무 연관**
Kubernetes 1.25부터 Cgroups v2가 정식 지원되면서 대규모 클러스터의 성능이 개선되었습니다. 특히 메모리 누수 감지와 CPU 쓰로틀링이 더 정확해졌습니다.

</details>

<details>
<summary><strong>4. 프로덕션에서 컨테이너 리소스 최적화 전략을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 측정 기반 접근
- 단계적 최적화
- 모니터링 및 알림
- 수평 확장 vs 수직 확장
- 리소스 예약 및 제한

**예시 답변**
> "프로덕션 환경에서 컨테이너 리소스 최적화는 측정, 분석, 조정의 반복 과정입니다.
>
> 1단계: 측정 (Measure)
> - 부하 테스트로 실제 사용량 측정
> - docker stats로 실시간 모니터링
> - Prometheus + Grafana로 장기 추세 분석
> - 최소, 평균, 최대, 99퍼센타일 측정
>
> ```bash
> # 1주일간 통계 수집
> while true; do
>   docker stats --no-stream --format \"{{.Container}},{{.CPUPerc}},{{.MemUsage}}\" >> stats.csv
>   sleep 300  # 5분마다
> done
>
> # 분석
> cat stats.csv | awk -F, '{print $3}' | sort -rn | head -1  # 최대 메모리
> ```
>
> 2단계: 초기 설정 (Conservative Start)
> - 피크 사용량의 150% 할당
> - 예: 최대 메모리 600MB → 900MB 할당
> - 메모리는 반드시 제한, CPU는 선택적
>
> 3단계: 최적화 (Optimization)
>
> 애플리케이션 수준:
> - 메모리 누수 수정
> - 불필요한 의존성 제거
> - 캐시 크기 조정
> - Connection pool 최적화
>
> 인프라 수준:
> - 리소스 요청(request)과 제한(limit) 분리
> - 우선순위별 QoS 클래스 설정
> - Node affinity로 리소스 격리
>
> 4단계: 확장 전략 (Scaling)
>
> 수직 확장 (Scale Up):
> - 장점: 단순, 빠름
> - 단점: 상한선 있음
> - 언제: 리소스 부족이 일시적
>
> 수평 확장 (Scale Out):
> - 장점: 무한 확장 가능, 고가용성
> - 단점: 복잡, 상태 관리 필요
> - 언제: 지속적인 부하 증가
>
> 5단계: 모니터링 및 알림 (Monitor & Alert)
> ```yaml
> # Prometheus 알림 규칙
> groups:
>   - name: container
>     rules:
>       - alert: HighMemoryUsage
>         expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.8
>         for: 5m
>         annotations:
>           summary: \"Container {{ $labels.name }} memory usage > 80%\"
> ```
>
> 6단계: 지속적 개선 (Continuous Improvement)
> - 월별 리소스 사용 리포트
> - 비용 최적화 기회 파악
> - 새로운 패턴 적용
> - A/B 테스트로 효과 검증"

**실무 사례**:
```bash
# Before: 과도한 할당
$ docker run -d --memory="4g" --cpus="4" webapp
# 실제 사용: 600MB, 0.5 CPU
# 낭비: 3.4GB, 3.5 CPU

# After: 최적화
$ docker run -d \
  --memory="1g" \
  --memory-reservation="600m" \
  --cpus="1" \
  --cpu-shares=512 \
  webapp

# 결과:
# - 같은 성능 유지
# - 리소스 활용률 60% → 85%
# - 비용 50% 절감
```

**꼬리 질문**
- Q: 메모리 사용률이 90%를 넘으면 어떻게 해야 하나요?
- A: 먼저 메모리 누수를 확인하고, 없다면 제한을 20-30% 증가시킵니다. 근본적으로는 애플리케이션 최적화가 필요합니다.

**실무 연관**
Netflix는 Titus(컨테이너 플랫폼)에서 자동 리소스 조정(auto-tuning)을 구현하여 비용을 30% 절감했습니다. 머신러닝으로 사용 패턴을 학습하여 최적의 리소스를 자동 할당합니다.

</details>

<details>
<summary><strong>5. 컨테이너 격리의 한계와 보안 강화 방법을 설명해주세요.</strong></summary>

**모범 답안 포인트**
- 네임스페이스 탈출 취약점
- 커널 공유로 인한 위험
- 보안 강화 기술 (AppArmor, SELinux, Seccomp)
- rootless 컨테이너
- gVisor, Kata Containers 같은 대안

**예시 답변**
> "Docker의 네임스페이스와 Cgroups 격리는 강력하지만 완벽하지 않습니다.
>
> 격리의 한계:
>
> 1. 커널 공유:
> - 모든 컨테이너가 호스트 커널 공유
> - 커널 취약점 발견 시 전체 시스템 위험
> - 커널 버전 업그레이드 필요 시 모든 컨테이너 영향
>
> 2. 네임스페이스 탈출:
> - CVE-2019-5736 (runc 취약점): 컨테이너에서 호스트 탈출 가능
> - Privileged 컨테이너: 모든 격리 무력화
> - CAP_SYS_ADMIN: 위험한 권한
>
> 3. 리소스 공유:
> - CPU 캐시 타이밍 공격 (Spectre, Meltdown)
> - Side-channel 공격
>
> 보안 강화 방법:
>
> 1. User Namespace 활성화:
> ```bash
> # /etc/docker/daemon.json
> {
>   \"userns-remap\": \"default\"
> }
> ```
>
> 2. Seccomp 프로파일:
> ```bash
> # 시스템 콜 제한
> $ docker run --security-opt seccomp=/path/to/seccomp.json myapp
> ```
>
> 3. AppArmor / SELinux:
> ```bash
> # AppArmor 프로파일 적용
> $ docker run --security-opt apparmor=docker-default myapp
> ```
>
> 4. Capability 최소화:
> ```bash
> # 모든 capability 제거 후 필요한 것만 추가
> $ docker run \
>   --cap-drop=ALL \
>   --cap-add=NET_BIND_SERVICE \
>   myapp
> ```
>
> 5. Read-only 파일 시스템:
> ```bash
> $ docker run --read-only --tmpfs /tmp myapp
> ```
>
> 6. Rootless 컨테이너:
> ```bash
> # Docker daemon을 root 없이 실행
> $ dockerd-rootless-setuptool.sh install
> $ docker run myapp  # root 권한 없이 실행
> ```
>
> 7. 강화된 런타임 (gVisor, Kata):
> ```bash
> # gVisor: 커널 시스템 콜을 사용자 공간에서 처리
> $ docker run --runtime=runsc myapp
>
> # Kata Containers: 경량 VM으로 격리
> $ docker run --runtime=kata-runtime myapp
> ```
>
> 프로덕션 보안 체크리스트:
> ```bash
> # 1. User Namespace
> ✅ userns-remap 설정
>
> # 2. 최소 권한
> ✅ --cap-drop=ALL
> ✅ non-root 사용자
>
> # 3. 리소스 제한
> ✅ --memory, --cpus 설정
>
> # 4. 읽기 전용
> ✅ --read-only
>
> # 5. 보안 스캔
> ✅ 이미지 취약점 스캔 (Trivy, Clair)
>
> # 6. 모니터링
> ✅ 런타임 보안 모니터링 (Falco)
>
> # 7. 네트워크 격리
> ✅ 사용자 정의 네트워크
> ✅ 최소 포트 노출
> ```"

**실무 예시**:
```bash
# 일반 컨테이너 (보안 취약)
$ docker run -d nginx

# 강화된 컨테이너 (프로덕션)
$ docker run -d \
  --read-only \
  --tmpfs /tmp \
  --tmpfs /var/run \
  --tmpfs /var/cache/nginx \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --cap-add=CHOWN \
  --cap-add=SETGID \
  --cap-add=SETUID \
  --security-opt=no-new-privileges \
  --user 1000:1000 \
  nginx
```

**꼬리 질문**
- Q: gVisor와 Kata Containers의 차이는?
- A: gVisor는 시스템 콜을 사용자 공간에서 에뮬레이션하고, Kata는 경량 VM을 사용합니다. gVisor가 더 가볍지만 Kata가 더 강한 격리를 제공합니다.

**실무 연관**
Google은 gVisor를 개발하여 자사 서비스에 적용했고, AWS Lambda는 Firecracker(경량 VM)를 사용하여 멀티테넌시 보안을 강화했습니다. 금융권에서는 Kata Containers를 선호합니다.

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 네임스페이스 | 컨테이너 격리 기술 | PID, Network, Mount, UTS, IPC, User, Cgroup |
| Cgroups | 리소스 제한 기술 | CPU, Memory, I/O, PIDs |
| 생명주기 | 컨테이너 상태 관리 | Created, Running, Paused, Stopped |
| 재시작 정책 | 자동 복구 메커니즘 | no, always, unless-stopped, on-failure |
| 격리 vs 제한 | 네임스페이스는 격리, Cgroups는 제한 | isolation vs limitation |

### 필수 명령어/코드 정리

| 명령어/옵션 | 용도 | 예시 |
|-------------|------|------|
| `--memory` | 메모리 제한 | `docker run --memory="512m" nginx` |
| `--cpus` | CPU 제한 | `docker run --cpus="1.5" nginx` |
| `--restart` | 재시작 정책 | `docker run --restart=unless-stopped nginx` |
| `docker stop` | 정상 종료 | `docker stop my-container` |
| `docker kill` | 강제 종료 | `docker kill my-container` |
| `docker pause` | 일시정지 | `docker pause my-container` |
| `docker stats` | 리소스 모니터링 | `docker stats` |
| `--pids-limit` | 프로세스 수 제한 | `docker run --pids-limit=100 nginx` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [x] 항상 메모리 제한 설정 (`--memory`)
- [x] 프로덕션에서 재시작 정책 설정 (`--restart=unless-stopped`)
- [x] PIDs 제한으로 Fork Bomb 방지 (`--pids-limit`)
- [x] `docker stop` 사용 (정상 종료)
- [x] `docker stats`로 정기 모니터링
- [x] User Namespace로 보안 강화 (가능하면)
- [x] 부하 테스트로 리소스 사용량 측정 후 설정

#### ❌ 하지 말아야 할 것
- [x] 메모리 제한 없이 프로덕션 운영
- [x] `docker kill` 남용 (데이터 손실 위험)
- [x] 재시작 정책 없이 운영 (야간 장애 위험)
- [x] 셸 스크립트를 PID 1로 사용 (시그널 처리 문제)
- [x] Privileged 컨테이너 사용 (보안 취약)
- [x] OOM Killer 비활성화 (`--oom-kill-disable`)
- [x] 무제한 Swap 허용

### 성능/보안 체크리스트

#### 성능
- [x] 메모리 제한: 피크 사용량의 150%
- [x] CPU 제한: 중요 서비스만 설정
- [x] Swap 비활성화: `--memory-swap`과 `--memory` 동일하게
- [x] 리소스 모니터링: Prometheus + Grafana
- [x] 정기적인 통계 수집 및 최적화

#### 보안
- [x] User Namespace 활성화 (`userns-remap`)
- [x] 최소 권한 원칙 (`--cap-drop=ALL`)
- [x] Read-only 파일 시스템 (`--read-only`)
- [x] Seccomp 프로파일 적용
- [x] Non-root 사용자 실행
- [x] 이미지 취약점 스캔 (Trivy, Clair)
- [x] 런타임 보안 모니터링 (Falco)

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Linux Kernel | 네임스페이스와 Cgroups의 기반 | ⭐⭐⭐ |
| systemd | Cgroups v2와 긴밀히 통합 | ⭐⭐ |
| Kubernetes | 컨테이너 오케스트레이션에서 활용 | ⭐⭐⭐⭐⭐ |
| Prometheus | 컨테이너 리소스 모니터링 | ⭐⭐⭐⭐ |
| Grafana | 리소스 사용량 시각화 | ⭐⭐⭐ |
| AppArmor/SELinux | 보안 강화 | ⭐⭐⭐ |
| gVisor/Kata | 강화된 격리 | ⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: 5장 - Docker 이미지와 레지스트리

- **배울 내용 1**: 이미지 레이어 구조와 동작 원리
- **배울 내용 2**: Dockerfile 최적화 기법
- **배울 내용 3**: 프라이빗 레지스트리 구축
- **실전 프로젝트**: 멀티 스테이지 빌드로 이미지 크기 80% 줄이기

### 이 장과의 연결점
```
이번 장에서 배운 격리 기술
    ↓
다음 장에서 이미지 레이어와 격리의 관계
    ↓
최종적으로 효율적인 컨테이너 이미지 설계
```

### 준비하면 좋을 것들
```bash
# 다음 장 실습을 위한 준비
# 1. 이미지 확인
$ docker images

# 2. 레이어 확인 명령어 익히기
$ docker history nginx:latest

# 3. 디스크 공간 확보
$ docker system prune -a
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Docker 네임스페이스 공식 문서](https://docs.docker.com/engine/security/userns-remap/)
- [Linux Cgroups 문서](https://www.kernel.org/doc/Documentation/cgroup-v2.txt)
- [Docker 보안 가이드](https://docs.docker.com/engine/security/)

### 추천 블로그/아티클
- [Linux 네임스페이스 심화 (한글)](https://www.44bits.io/ko/keyword/linux-namespace)
- [Container Security Best Practices](https://snyk.io/blog/10-docker-image-security-best-practices/)

### 영상 강의
- [Docker Deep Dive - Nigel Poulton](https://www.pluralsight.com/courses/docker-deep-dive-update)
- [Kubernetes와 컨테이너 기술 (한글)](https://www.inflearn.com/course/kubernetes-docker)

### 컨퍼런스 발표
- [DockerCon: Container Isolation Deep Dive](https://www.youtube.com/dockercon)
- [KubeCon: Secure Container Runtime](https://www.youtube.com/kubecon)

### 오픈소스 프로젝트
- [runc - Docker의 컨테이너 런타임](https://github.com/opencontainers/runc)
- [gVisor - Google의 보안 강화 런타임](https://github.com/google/gvisor)
- [Kata Containers - 경량 VM 기반 컨테이너](https://github.com/kata-containers/kata-containers)

---

## 🎉 축하합니다!

**학습 완료 후 메시지**

**이제 여러분은**:
✅ Docker 컨테이너 격리의 핵심인 7가지 네임스페이스를 이해하고 설명할 수 있습니다
✅ Cgroups로 컨테이너 리소스를 제한하고 모니터링할 수 있습니다
✅ 컨테이너 생명주기를 완벽하게 관리하고 재시작 정책을 설정할 수 있습니다
✅ 프로덕션 환경에서 안전하고 효율적인 컨테이너를 운영할 수 있습니다
✅ 보안 취약점을 이해하고 강화 방법을 적용할 수 있습니다

**다음 단계**:
- [x] 5장: Docker 이미지와 레지스트리로 진행
- [x] 실전 프로젝트: 멀티 스테이지 빌드 도전
- [x] 면접 질문 복습 (주니어 7개 + 중급 5개)
- [x] FAQ 7개 재독하여 깊이 있는 이해

**🌟 여러분은 이제 Docker 격리 기술의 전문가입니다!**

---

**다음 장으로 이동**: [다음: 5장 - Docker 이미지와 레지스트리 →](05-이미지와-레지스트리.md)

**이전 장으로 돌아가기**: [← 이전: 3장 - Docker 아키텍처](03-아키텍처.md)

**목차로 돌아가기**: [📚 전체 목차](../README.md)
