# 44장 모듈 시스템 (Java 9) - Part 1: 실생활 비유로 이해하기

## 📚 목차
1. [모듈 시스템이란?](#모듈-시스템이란)
2. [비유로 이해하기](#비유로-이해하기)
3. [기본 문법](#기본-문법)
4. [실전 예제](#실전-예제)

---

## 🎯 모듈 시스템이란?

### Java 9의 혁명적 변화

**Project Jigsaw** - Java를 모듈화하여 더 작고, 빠르고, 안전하게!

```java
// Before Java 9 - JAR 파일
myapp.jar (모든 것이 하나의 덩어리)

// After Java 9 - 모듈
com.myapp.core
com.myapp.api
com.myapp.service
```

---

## 📖 비유 1: 레고 블록

**모듈은 레고 블록과 같습니다.**

```
🧱 레고 블록 (모듈)
├── 각 블록은 독립적
├── 조립 방법이 명확 (requires, exports)
├── 필요한 블록만 사용
└── 숨겨진 부분은 접근 불가
```

```java
// module-info.java
module com.myapp.user {
    requires com.myapp.core;      // 다른 블록 필요
    exports com.myapp.user.api;   // 이 부분만 노출
}
```

---

## 📖 비유 2: 아파트 구조

**모듈은 아파트 건물과 같습니다.**

```
🏢 아파트 (애플리케이션)
├── 101호 (user 모듈)
│   ├── 거실 (api 패키지) - 공개
│   └── 침실 (internal 패키지) - 비공개
├── 102호 (order 모듈)
│   ├── 거실 (api 패키지) - 공개
│   └── 침실 (internal 패키지) - 비공개
└── 103호 (payment 모듈)
    ├── 거실 (api 패키지) - 공개
    └── 침실 (internal 패키지) - 비공개
```

**특징**:
- **각 호는 독립적** - 모듈
- **거실은 방문 가능** - exports
- **침실은 비공개** - internal
- **다른 호 이용 시 허가 필요** - requires

---

## 📖 비유 3: 도서관 시스템

**모듈은 도서관의 대출 시스템과 같습니다.**

```java
// 도서관 (모듈)
module library.system {
    // 대출 가능한 책 (exports)
    exports library.api;

    // 서고에 있는 책 (비공개)
    // library.internal은 exports 안 함
}

// 이용자 (다른 모듈)
module user.app {
    // 도서관 이용 신청 (requires)
    requires library.system;
}
```

---

## 🔑 기본 문법

### 1. module-info.java

**모듈의 설정 파일 (각 모듈마다 하나)**

```java
// src/com.myapp.core/module-info.java
module com.myapp.core {
    // 다른 모듈에서 사용할 패키지 공개
    exports com.myapp.core.api;

    // 특정 모듈에만 공개
    exports com.myapp.core.internal to com.myapp.service;

    // 다른 모듈 의존
    requires java.sql;
    requires java.logging;
}
```

---

### 2. 주요 키워드

```java
module com.example.myapp {
    // 1. exports - 패키지 공개
    exports com.example.api;

    // 2. requires - 다른 모듈 필요
    requires java.sql;

    // 3. requires transitive - 전이 의존성
    requires transitive java.logging;

    // 4. opens - 리플렉션 허용
    opens com.example.model to com.fasterxml.jackson.databind;

    // 5. provides - 서비스 제공
    provides java.sql.Driver with com.mysql.jdbc.Driver;

    // 6. uses - 서비스 사용
    uses java.sql.Driver;
}
```

---

### 3. 프로젝트 구조

```
myapp/
├── src/
│   ├── com.myapp.core/
│   │   ├── module-info.java
│   │   └── com/myapp/core/
│   │       ├── api/
│   │       │   └── CoreApi.java
│   │       └── internal/
│   │           └── CoreImpl.java
│   │
│   ├── com.myapp.service/
│   │   ├── module-info.java
│   │   └── com/myapp/service/
│   │       ├── api/
│   │       │   └── ServiceApi.java
│   │       └── internal/
│   │           └── ServiceImpl.java
│   │
│   └── com.myapp.app/
│       ├── module-info.java
│       └── com/myapp/app/
│           └── Main.java
```

---

## 💡 실전 예제

### 예제 1: 간단한 3-Tier 아키텍처

```java
// ========== 모듈 1: Core (공통) ==========
// src/com.myapp.core/module-info.java
module com.myapp.core {
    exports com.myapp.core.model;
    exports com.myapp.core.util;
}

// src/com.myapp.core/com/myapp/core/model/User.java
package com.myapp.core.model;

public class User {
    private Long id;
    private String name;
    private String email;

    // getters, setters, constructor
}

// ========== 모듈 2: Service ==========
// src/com.myapp.service/module-info.java
module com.myapp.service {
    requires com.myapp.core;
    requires java.sql;

    exports com.myapp.service.api;
    // internal 패키지는 exports 안 함
}

// src/com.myapp.service/com/myapp/service/api/UserService.java
package com.myapp.service.api;

import com.myapp.core.model.User;
import java.util.Optional;

public interface UserService {
    Optional<User> findById(Long id);
    User save(User user);
    void delete(Long id);
}

// src/com.myapp.service/com/myapp/service/internal/UserServiceImpl.java
package com.myapp.service.internal;

import com.myapp.service.api.UserService;
import com.myapp.core.model.User;
import java.util.*;

public class UserServiceImpl implements UserService {
    private Map<Long, User> users = new HashMap<>();

    @Override
    public Optional<User> findById(Long id) {
        return Optional.ofNullable(users.get(id));
    }

    @Override
    public User save(User user) {
        users.put(user.getId(), user);
        return user;
    }

    @Override
    public void delete(Long id) {
        users.remove(id);
    }
}

// ========== 모듈 3: Application ==========
// src/com.myapp.app/module-info.java
module com.myapp.app {
    requires com.myapp.core;
    requires com.myapp.service;
}

// src/com.myapp.app/com/myapp/app/Main.java
package com.myapp.app;

import com.myapp.core.model.User;
import com.myapp.service.api.UserService;
// import com.myapp.service.internal.UserServiceImpl; // ❌ 컴파일 에러!

public class Main {
    public static void main(String[] args) {
        // UserService만 접근 가능
        UserService service = ServiceFactory.createUserService();

        User user = new User(1L, "Alice", "alice@example.com");
        service.save(user);

        service.findById(1L)
            .ifPresent(u -> System.out.println("Found: " + u.getName()));
    }
}
```

---

### 예제 2: 전이 의존성 (requires transitive)

```java
// ========== 모듈 1: API ==========
module com.myapp.api {
    requires transitive java.sql;  // 전이 의존성
    exports com.myapp.api;
}

// ========== 모듈 2: Implementation ==========
module com.myapp.impl {
    requires com.myapp.api;
    // java.sql을 requires 안 해도 됨! (transitive로 전달)
}
```

**전이 의존성 사용 시기**:
- API 모듈이 다른 모듈의 타입을 public API에 노출할 때

---

### 예제 3: 서비스 로더 패턴

```java
// ========== 서비스 인터페이스 모듈 ==========
// module-info.java
module com.myapp.api {
    exports com.myapp.api;
}

// ServiceProvider.java
package com.myapp.api;

public interface ServiceProvider {
    String provide();
}

// ========== 서비스 구현 모듈 1 ==========
// module-info.java
module com.myapp.impl1 {
    requires com.myapp.api;
    provides com.myapp.api.ServiceProvider
        with com.myapp.impl1.ServiceProviderImpl1;
}

// ServiceProviderImpl1.java
package com.myapp.impl1;

import com.myapp.api.ServiceProvider;

public class ServiceProviderImpl1 implements ServiceProvider {
    @Override
    public String provide() {
        return "Implementation 1";
    }
}

// ========== 서비스 구현 모듈 2 ==========
// module-info.java
module com.myapp.impl2 {
    requires com.myapp.api;
    provides com.myapp.api.ServiceProvider
        with com.myapp.impl2.ServiceProviderImpl2;
}

// ========== 애플리케이션 모듈 ==========
// module-info.java
module com.myapp.app {
    requires com.myapp.api;
    uses com.myapp.api.ServiceProvider;
}

// Main.java
package com.myapp.app;

import com.myapp.api.ServiceProvider;
import java.util.ServiceLoader;

public class Main {
    public static void main(String[] args) {
        ServiceLoader<ServiceProvider> loader =
            ServiceLoader.load(ServiceProvider.class);

        loader.forEach(provider ->
            System.out.println(provider.provide())
        );
        // 출력:
        // Implementation 1
        // Implementation 2
    }
}
```

---

## 🎯 모듈 시스템의 장점

### 1. 강력한 캡슐화

```java
// ❌ Java 8 이전 - 모든 public 클래스 접근 가능
// com.myapp.internal.SecretClass 접근 가능

// ✅ Java 9+ - exports 하지 않으면 접근 불가
module com.myapp {
    exports com.myapp.api;  // api만 공개
    // internal 패키지는 숨김
}
```

---

### 2. 명확한 의존성

```java
// module-info.java를 보면 의존성이 한눈에!
module com.myapp.service {
    requires com.myapp.core;
    requires java.sql;
    requires java.logging;
}
```

---

### 3. 안정적인 API

```java
// 공개 API를 명시적으로 선언
module com.myapp {
    exports com.myapp.api;  // 이것만 공개 API
    // 내부 구현은 자유롭게 변경 가능
}
```

---

### 4. 더 작은 런타임

```bash
# 필요한 모듈만 포함하여 작은 이미지 생성
jlink --module-path $JAVA_HOME/jmods:mods \
      --add-modules com.myapp.app \
      --output myapp-runtime
```

---

## 🎓 핵심 요약

### 모듈 시스템 4대 개념

1. **module-info.java**
   - 모듈 선언 파일
   - 각 모듈의 루트에 위치

2. **exports**
   - 패키지 공개
   - 다른 모듈에서 사용 가능

3. **requires**
   - 다른 모듈 의존
   - 명확한 의존성 선언

4. **강력한 캡슐화**
   - exports 안 한 패키지는 완전히 숨김
   - 리플렉션으로도 접근 불가 (opens 제외)

### 주요 키워드

```java
exports      // 패키지 공개
requires     // 모듈 의존
opens        // 리플렉션 허용
provides     // 서비스 제공
uses         // 서비스 사용
transitive   // 전이 의존성
```

**다음 Part 2**: 기업 사례 & 주니어 실수
