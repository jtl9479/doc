# 34ì¥ ë™ì‹œì„± í”„ë¡œê·¸ë˜ë° - Part 3: ë©´ì ‘ ì§ˆë¬¸

## ğŸ¤ ë©´ì ‘ ì§ˆë¬¸ TOP 3

### Q1. synchronized vs Lock ì°¨ì´ëŠ”?

**ë‹µë³€**:
```
synchronized:
- ìë°” í‚¤ì›Œë“œ
- ìë™ ë½ í•´ì œ
- ê°„ë‹¨í•œ ì‚¬ìš©
- íƒ€ì„ì•„ì›ƒ ë¶ˆê°€
- ê³µì •ì„± ì œì–´ ë¶ˆê°€

Lock (ReentrantLock):
- ì¸í„°í˜ì´ìŠ¤
- ìˆ˜ë™ ë½ í•´ì œ (unlock í•„ìˆ˜)
- ìœ ì—°í•œ ì œì–´
- tryLock(timeout) ê°€ëŠ¥
- ê³µì •ì„± ì„¤ì • ê°€ëŠ¥

ì˜ˆì‹œ:
// synchronized
synchronized(obj) {
    // ìë™ í•´ì œ
}

// Lock
Lock lock = new ReentrantLock();
lock.lock();
try {
    // ì‘ì—…
} finally {
    lock.unlock();  // ë°˜ë“œì‹œ í•´ì œ
}
```

### Q2. ConcurrentHashMapì˜ ë™ì‘ ì›ë¦¬ëŠ”?

**ë‹µë³€**:
```
ì„¸ê·¸ë¨¼íŠ¸ ê¸°ë°˜ ì ê¸ˆ:
- Mapì„ ì—¬ëŸ¬ ì„¸ê·¸ë¨¼íŠ¸ë¡œ ë¶„í• 
- ê° ì„¸ê·¸ë¨¼íŠ¸ì— ë…ë¦½ì ì¸ ë½
- ë‹¤ë¥¸ ì„¸ê·¸ë¨¼íŠ¸ ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥

vs Hashtable/Collections.synchronizedMap:
- ì „ì²´ Mapì— í•˜ë‚˜ì˜ ë½
- ë™ì‹œì„± ë‚®ìŒ

ì¥ì :
- ë†’ì€ ë™ì‹œì„±
- ì½ê¸°ëŠ” ë½ ì—†ìŒ
- putIfAbsent, computeIfAbsent ë“± atomic ë©”ì„œë“œ

ì‚¬ìš©:
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();
map.computeIfAbsent(key, k -> createValue());
```

### Q3. CompletableFutureì˜ ì¥ì ì€?

**ë‹µë³€**:
```
Futureì˜ í•œê³„:
- get()ìœ¼ë¡œë§Œ ê²°ê³¼ í™•ì¸ (ë¸”ë¡œí‚¹)
- ì—¬ëŸ¬ Future ì¡°í•© ì–´ë ¤ì›€
- ì˜ˆì™¸ ì²˜ë¦¬ ë³µì¡

CompletableFuture ì¥ì :
- ë¹„ë¸”ë¡œí‚¹ ì½œë°±
- ì²´ì´ë‹ ê°€ëŠ¥
- ì—¬ëŸ¬ ì‘ì—… ì¡°í•© ì‰¬ì›€
- ì˜ˆì™¸ ì²˜ë¦¬ ëª…í™•

ì˜ˆì‹œ:
// Future (êµ¬ì‹)
Future<String> future = executor.submit(() -> "ê²°ê³¼");
String result = future.get();  // ë¸”ë¡œí‚¹!

// CompletableFuture (ì‹ ì‹)
CompletableFuture.supplyAsync(() -> "ê²°ê³¼")
    .thenApply(s -> s.toUpperCase())
    .thenAccept(System.out::println)
    .exceptionally(ex -> {
        System.err.println("ì˜¤ë¥˜: " + ex);
        return null;
    });
```

---

## ğŸ“ Best Practices

```java
// âœ… ExecutorService ì‚¬ìš©
ExecutorService executor = Executors.newFixedThreadPool(10);
try {
    executor.submit(() -> {});
} finally {
    executor.shutdown();
}

// âœ… Concurrent ì»¬ë ‰ì…˜
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();

// âœ… Atomic í´ë˜ìŠ¤
AtomicInteger count = new AtomicInteger();

// âœ… CompletableFuture
CompletableFuture.supplyAsync(() -> {})
    .thenApply(...)
    .thenAccept(...);
```

**ì‹œë¦¬ì¦ˆ ì™„ë£Œ**: 34ì¥ ë™ì‹œì„± í”„ë¡œê·¸ë˜ë° ë§ˆìŠ¤í„°! ğŸŠ
