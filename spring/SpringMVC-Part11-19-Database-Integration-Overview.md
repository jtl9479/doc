# 19ì¥: ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ ê°œìš”

> **í•™ìŠµ ëª©í‘œ**: Springì—ì„œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì—°ë™í•˜ëŠ” ë‹¤ì–‘í•œ ë°©ë²•ì„ ì´í•´í•˜ê³ , ê° ê¸°ìˆ ì˜ íŠ¹ì§•ê³¼ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**â±ï¸ ì˜ˆìƒ í•™ìŠµ ì‹œê°„**: 2-3ì‹œê°„
**ë‚œì´ë„**: â­â­â­â˜†â˜† (3ê°œ/5ê°œ)

---

## ğŸ“š ëª©ì°¨
- [ì™œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ì´ í•„ìš”í•œê°€](#ì™œ-ë°ì´í„°ë² ì´ìŠ¤-ì—°ë™ì´-í•„ìš”í•œê°€)
- [ì‹¤ìƒí™œ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°](#ì‹¤ìƒí™œ-ë¹„ìœ ë¡œ-ì´í•´í•˜ê¸°)
- [í•µì‹¬ ê°œë…](#í•µì‹¬-ê°œë…)
- [ê¸°ë³¸ ì‹¤ìŠµ](#ê¸°ë³¸-ì‹¤ìŠµ)
- [ì‹¤ë¬´ í™œìš© ì‚¬ë¡€](#ì‹¤ë¬´-í™œìš©-ì‚¬ë¡€)
- [ì£¼ë‹ˆì–´ ì‹œë‚˜ë¦¬ì˜¤](#ì£¼ë‹ˆì–´-ì‹œë‚˜ë¦¬ì˜¤)
- [ì‹¤ì „ í”„ë¡œì íŠ¸](#ì‹¤ì „-í”„ë¡œì íŠ¸)
- [FAQ](#faq)
- [ë©´ì ‘ ì§ˆë¬¸](#ë©´ì ‘-ì§ˆë¬¸)
- [í•µì‹¬ ì •ë¦¬](#í•µì‹¬-ì •ë¦¬)

---

## ğŸ¤” ì™œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ì´ í•„ìš”í•œê°€?

### ì‹¤ë¬´ ë°°ê²½

**ëª¨ë“  ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í•µì‹¬ì€ ë°ì´í„°**:
- íšŒì› ì •ë³´, ì£¼ë¬¸ ë‚´ì—­, ìƒí’ˆ ë°ì´í„° ë“± ì˜êµ¬ ì €ì¥ í•„ìš”
- ì„œë²„ ì¬ì‹œì‘ í›„ì—ë„ ë°ì´í„° ìœ ì§€
- ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œì— ì•ˆì „í•˜ê²Œ ì ‘ê·¼
- ë¹ ë¥¸ ê²€ìƒ‰, ì •ë ¬, ì§‘ê³„ ê¸°ëŠ¥
- ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥ (íŠ¸ëœì­ì…˜)

### âŒ ë°ì´í„°ë² ì´ìŠ¤ ì—†ì´ ë©”ëª¨ë¦¬ë§Œ ì‚¬ìš©í•˜ë©´ ë°œìƒí•˜ëŠ” ë¬¸ì œ

```
ë¬¸ì œ 1: ë°ì´í„° ì†Œì‹¤
- ì¦ìƒ: ì„œë²„ ì¬ì‹œì‘ ì‹œ ëª¨ë“  ë°ì´í„° ì‚¬ë¼ì§
- ì˜í–¥: íšŒì› ì •ë³´, ì£¼ë¬¸ ë‚´ì—­ ëª¨ë‘ ì‚­ì œ
- ë¹„ìš©: ë¹„ì¦ˆë‹ˆìŠ¤ ì¤‘ë‹¨

ë¬¸ì œ 2: ë™ì‹œì„± ë¬¸ì œ
- ì¦ìƒ: ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œì— ìˆ˜ì • ì‹œ ì¶©ëŒ
- ì˜í–¥: ë°ì´í„° ë¶ˆì¼ì¹˜, ì¬ê³  ì˜¤ë¥˜
- ë¹„ìš©: ê³ ê° ë¶ˆë§Œ, ê¸ˆì „ì  ì†ì‹¤

ë¬¸ì œ 3: í™•ì¥ì„± ë¶€ì¡±
- ì¦ìƒ: ë©”ëª¨ë¦¬ í•œê³„ë¡œ ë°ì´í„° ì €ì¥ ì œí•œ
- ì˜í–¥: ì„œë¹„ìŠ¤ ì„±ì¥ ë¶ˆê°€ëŠ¥
- ë¹„ìš©: ê¸°íšŒ ë¹„ìš©

ë¬¸ì œ 4: ê²€ìƒ‰ ì„±ëŠ¥ ì €í•˜
- ì¦ìƒ: ë°ì´í„° ë§ì•„ì§€ë©´ ì„ í˜• ê²€ìƒ‰ìœ¼ë¡œ ëŠë ¤ì§
- ì˜í–¥: ì‚¬ìš©ì ê²½í—˜ ì•…í™”
- ë¹„ìš©: ì´íƒˆë¥  ì¦ê°€
```

### âœ… Springì˜ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ì„ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•˜ë©´

```
í•´ê²°ì±… 1: ì˜êµ¬ ì €ì¥ì†Œ
- ë°©ë²•: RDBMS (MySQL, PostgreSQL, Oracle)
- íš¨ê³¼: ë°ì´í„° ì˜êµ¬ ë³´ì¡´
- ì ˆê°: ë°ì´í„° ì†ì‹¤ ìœ„í—˜ 0%

í•´ê²°ì±… 2: íŠ¸ëœì­ì…˜ ì§€ì›
- ë°©ë²•: ACID ë³´ì¥
- íš¨ê³¼: ë°ì´í„° ë¬´ê²°ì„± ìœ ì§€
- ì ˆê°: ë°ì´í„° ë¶ˆì¼ì¹˜ 99% ê°ì†Œ

í•´ê²°ì±… 3: ê³ ì„±ëŠ¥ ê²€ìƒ‰
- ë°©ë²•: ì¸ë±ìŠ¤, ì¿¼ë¦¬ ìµœì í™”
- íš¨ê³¼: ë°€ë¦¬ì´ˆ ë‹¨ìœ„ ì‘ë‹µ
- ì ˆê°: ê²€ìƒ‰ ì‹œê°„ 99% ë‹¨ì¶•

í•´ê²°ì±… 4: ë™ì‹œì„± ì œì–´
- ë°©ë²•: ë½, ê²©ë¦¬ ìˆ˜ì¤€
- íš¨ê³¼: ì•ˆì „í•œ ë™ì‹œ ì ‘ê·¼
- ì ˆê°: ì¶©ëŒ 98% ê°ì†Œ
```

### ğŸ“Š ìˆ˜ì¹˜ë¡œ ë³´ëŠ” íš¨ê³¼

| ì§€í‘œ | Before (ë©”ëª¨ë¦¬) | After (DB) | ê°œì„ ìœ¨ |
|------|----------------|-----------|--------|
| ë°ì´í„° ì†ì‹¤ ìœ„í—˜ | 100% (ì¬ì‹œì‘ ì‹œ) | 0% | **100%â†“** |
| ë™ì‹œ ì‚¬ìš©ì ì²˜ë¦¬ | 100ëª… | 10,000ëª… | **100ë°°â†‘** |
| ê²€ìƒ‰ ì†ë„ (100ë§Œê±´) | 10ì´ˆ | 10ms | **1000ë°°â†‘** |
| ë°ì´í„° ìš©ëŸ‰ | 8GB (ë©”ëª¨ë¦¬) | ë¬´ì œí•œ (ë””ìŠ¤í¬) | **ë¬´í•œëŒ€** |

---

## ğŸŒŸ ì‹¤ìƒí™œ ë¹„ìœ ë¡œ ì´í•´í•˜ê¸°

### ë¹„ìœ  1: ë„ì„œê´€ vs ì±…ìƒ

**ìƒí™©**: ì±…ì„ ë³´ê´€í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë„ì„œê´€       â”‚ ë°ì´í„°ë² ì´ìŠ¤    â”‚ ì—­í•              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ì±…           â”‚ ë°ì´í„° (Row)    â”‚ ì €ì¥ ë‹¨ìœ„        â”‚
â”‚ ì±…ì¥         â”‚ í…Œì´ë¸” (Table)  â”‚ ë°ì´í„° ë¶„ë¥˜      â”‚
â”‚ ì¹´íƒˆë¡œê·¸     â”‚ ì¸ë±ìŠ¤ (Index)  â”‚ ë¹ ë¥¸ ê²€ìƒ‰        â”‚
â”‚ ì‚¬ì„œ         â”‚ DBMS            â”‚ ê´€ë¦¬ì           â”‚
â”‚ ëŒ€ì¶œ ê¸°ë¡    â”‚ íŠ¸ëœì­ì…˜ ë¡œê·¸   â”‚ ë³€ê²½ ì´ë ¥        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ì±…ìƒ (ë©”ëª¨ë¦¬):
âœ… ë¹ ë¥¸ ì ‘ê·¼
âŒ í•œì •ëœ ê³µê°„
âŒ ì •ë¦¬ ì•ˆ í•˜ë©´ ë¶„ì‹¤

ë„ì„œê´€ (ë°ì´í„°ë² ì´ìŠ¤):
âœ… ë¬´ì œí•œ ë³´ê´€
âœ… ì²´ê³„ì  ë¶„ë¥˜
âœ… ì˜êµ¬ ë³´ì¡´
âœ… ì—¬ëŸ¬ ì‚¬ëŒ ë™ì‹œ ì´ìš©
```

**ì½”ë“œë¡œ ë³´ë©´**:
```java
// âŒ ë©”ëª¨ë¦¬ (ì±…ìƒ)
Map<Long, User> users = new HashMap<>();  // ì„œë²„ ì¬ì‹œì‘ ì‹œ ì†Œì‹¤

// âœ… ë°ì´í„°ë² ì´ìŠ¤ (ë„ì„œê´€)
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // ì˜êµ¬ ì €ì¥, ë¹ ë¥¸ ê²€ìƒ‰, ë™ì‹œì„± ì§€ì›
}
```

---

### ë¹„ìœ  2: ì€í–‰ ê¸ˆê³  vs ì§€ê°‘

**ìƒí™©**: ëˆì„ ë³´ê´€í•˜ëŠ” ë‘ ê°€ì§€ ë°©ë²•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ì€í–‰         â”‚ ë°ì´í„°ë² ì´ìŠ¤    â”‚ ì—­í•              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ê³„ì¢Œ         â”‚ ë ˆì½”ë“œ (Record) â”‚ ê°œë³„ ë°ì´í„°      â”‚
â”‚ ì…ì¶œê¸ˆ ë‚´ì—­  â”‚ íŠ¸ëœì­ì…˜        â”‚ ë³€ê²½ ì‘ì—…        â”‚
â”‚ ì”ì•¡ í™•ì¸    â”‚ SELECT ì¿¼ë¦¬     â”‚ ì¡°íšŒ             â”‚
â”‚ ì´ì²´         â”‚ UPDATE ì¿¼ë¦¬     â”‚ ìˆ˜ì •             â”‚
â”‚ CCTV/ë³´ì•ˆ    â”‚ ê²©ë¦¬ ìˆ˜ì¤€/ë½    â”‚ ë™ì‹œì„± ì œì–´      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì˜ˆì‹œ (ì€í–‰ ì´ì²´)**:
```java
@Transactional  // ì€í–‰ì˜ "ì…ì¶œê¸ˆ ë™ì‹œ ì²˜ë¦¬"ì™€ ë™ì¼
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    // 1. ì¶œê¸ˆ ê³„ì¢Œì—ì„œ ì°¨ê°
    Account from = accountRepository.findById(fromId).orElseThrow();
    from.withdraw(amount);

    // 2. ì…ê¸ˆ ê³„ì¢Œì— ì¶”ê°€
    Account to = accountRepository.findById(toId).orElseThrow();
    to.deposit(amount);

    // ë‘˜ ë‹¤ ì„±ê³µí•˜ê±°ë‚˜, ë‘˜ ë‹¤ ì‹¤íŒ¨ (All or Nothing)
    // ì¤‘ê°„ì— ì‹¤íŒ¨í•˜ë©´ ìë™ ë¡¤ë°± (ì…ê¸ˆë§Œ ë˜ëŠ” ì¼ ì—†ìŒ!)
}
```

---

### ë¹„ìœ  3: ë°±ê³¼ì‚¬ì „ vs ë©”ëª¨ì¥

**ìƒí™©**: ì •ë³´ë¥¼ ê¸°ë¡í•˜ê³  ì°¾ëŠ” ë‘ ê°€ì§€ ë°©ë²•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë°±ê³¼ì‚¬ì „     â”‚ RDBMS           â”‚ ì—­í•              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ê°€ë‚˜ë‹¤ìˆœ ì •ë ¬â”‚ ORDER BY        â”‚ ì •ë ¬             â”‚
â”‚ ìƒ‰ì¸         â”‚ INDEX           â”‚ ë¹ ë¥¸ ê²€ìƒ‰        â”‚
â”‚ êµì°¨ ì°¸ì¡°    â”‚ JOIN            â”‚ ê´€ê³„ ì—°ê²°        â”‚
â”‚ ë¶„ë¥˜ ì²´ê³„    â”‚ Schema          â”‚ ë°ì´í„° êµ¬ì¡°      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì˜ˆì‹œ (ê²€ìƒ‰)**:
```sql
-- âŒ ë©”ëª¨ì¥: ì²˜ìŒë¶€í„° ëê¹Œì§€ ì½ê¸° (ì„ í˜• ê²€ìƒ‰, O(n))
-- 1,000,000ê°œ ì¤‘ 1ê°œ ì°¾ëŠ”ë° 1ì´ˆ ì†Œìš”

-- âœ… ë°±ê³¼ì‚¬ì „: ìƒ‰ì¸ìœ¼ë¡œ ë°”ë¡œ ì°¾ê¸° (ì¸ë±ìŠ¤ ê²€ìƒ‰, O(log n))
SELECT * FROM users WHERE email = 'user@example.com';
-- 1,000,000ê°œ ì¤‘ 1ê°œ ì°¾ëŠ”ë° 10ms ì†Œìš”
```

---

### ë¹„ìœ  4: ë ˆê³  ë¸”ë¡

**ìƒí™©**: Springì˜ ë‹¤ì–‘í•œ ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ ê¸°ìˆ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ë ˆê³  ì„¸íŠ¸    â”‚ Spring ê¸°ìˆ      â”‚ íŠ¹ì§•             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ê¸°ë³¸ ë¸”ë¡    â”‚ JDBC            â”‚ ê°€ì¥ ê¸°ì´ˆ, ìœ ì—°  â”‚
â”‚ í…Œí¬ë‹‰       â”‚ Spring JDBC     â”‚ JDBC ê°„ì†Œí™”      â”‚
â”‚ ë ˆê³  ë“€í”Œë¡œ  â”‚ JPA/Hibernate   â”‚ ì‰¬ìš´ ì‚¬ìš©        â”‚
â”‚ ë ˆê³  ë§ˆì¸ë“œ  â”‚ QueryDSL        â”‚ íƒ€ì… ì•ˆì „ ì¿¼ë¦¬   â”‚
â”‚ ì»¤ìŠ¤í…€       â”‚ MyBatis         â”‚ SQL ì§ì ‘ ì œì–´    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

í•„ìš”ì— ë”°ë¼ ì„ íƒ:
- ë‹¨ìˆœí•œ ê±´ë¬¼ (ê°„ë‹¨í•œ CRUD) â†’ JPA
- ë³µì¡í•œ êµ¬ì¡°ë¬¼ (ë³µì¡í•œ ì¿¼ë¦¬) â†’ MyBatis
- ì •ë°€ ì œì–´ (ì„±ëŠ¥ ìµœì í™”) â†’ JDBC
```

---

### ë¹„ìœ  5: ìŒì‹ì  ì£¼ë¬¸ ì‹œìŠ¤í…œ

**ìƒí™©**: ì£¼ë¬¸ì„ ì²˜ë¦¬í•˜ëŠ” ê³¼ì •

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ìŒì‹ì        â”‚ Spring DB       â”‚ ì—­í•              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ë©”ë‰´íŒ       â”‚ Entity/DTO      â”‚ ë°ì´í„° êµ¬ì¡°      â”‚
â”‚ ì£¼ë¬¸ì„œ       â”‚ SQL ì¿¼ë¦¬        â”‚ ìš”ì²­             â”‚
â”‚ ì£¼ë°©         â”‚ DBMS            â”‚ ì²˜ë¦¬ ì—”ì§„        â”‚
â”‚ ì›¨ì´í„°       â”‚ Repository      â”‚ ì¤‘ê°œì           â”‚
â”‚ ì˜ìˆ˜ì¦       â”‚ Result Set      â”‚ ê²°ê³¼             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ì½”ë“œë¡œ ë³´ë©´**:
```java
// ê³ ê°: Controller
@PostMapping("/orders")
public Order createOrder(@RequestBody OrderRequest request) {
    // ì›¨ì´í„°: Service
    return orderService.createOrder(request);
}

// ì›¨ì´í„°: Service
@Transactional
public Order createOrder(OrderRequest request) {
    // ì£¼ë¬¸ì„œ ì‘ì„±: Entity ìƒì„±
    Order order = new Order(request);

    // ì£¼ë°©ì— ì „ë‹¬: Repository í˜¸ì¶œ
    return orderRepository.save(order);
}

// ì£¼ë°©: Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    // DBMSê°€ ì‹¤ì œ ì‘ì—… ìˆ˜í–‰
}
```

---

## ğŸ“– í•µì‹¬ ê°œë…

### 1ï¸âƒ£ ì´ˆë³´ì ìˆ˜ì¤€ ì„¤ëª…

**ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™ì´ë€?**

Spring ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°ì´í„°ë² ì´ìŠ¤ì— ë°ì´í„°ë¥¼ ì €ì¥í•˜ê³  ì¡°íšŒí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

**ê°„ë‹¨í•œ ì˜ˆì‹œ**:
```java
// âŒ Before (ë©”ëª¨ë¦¬): ì¬ì‹œì‘ ì‹œ ì†Œì‹¤
public class UserService {
    private List<User> users = new ArrayList<>();

    public void saveUser(User user) {
        users.add(user);  // ë©”ëª¨ë¦¬ì—ë§Œ ì €ì¥
    }
}

// âœ… After (ë°ì´í„°ë² ì´ìŠ¤): ì˜êµ¬ ì €ì¥
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public void saveUser(User user) {
        userRepository.save(user);  // DBì— ì˜êµ¬ ì €ì¥
    }
}
```

**í•µì‹¬ êµ¬ì„± ìš”ì†Œ**:
1. **DataSource**: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì •ë³´
2. **Entity**: í…Œì´ë¸”ê³¼ ë§¤í•‘ë˜ëŠ” Java í´ë˜ìŠ¤
3. **Repository**: ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ
4. **Service**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê³„ì¸µ

**ì„¤ì • ì˜ˆì‹œ (application.yml)**:
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
```

---

### 2ï¸âƒ£ ì¤‘ê¸‰ì ìˆ˜ì¤€ ì„¤ëª…

**Springì˜ ë°ì´í„° ì ‘ê·¼ ê¸°ìˆ  ë¹„êµ**

| ê¸°ìˆ  | ì¶”ìƒí™” ìˆ˜ì¤€ | SQL ì œì–´ | ë‚œì´ë„ | ì‚¬ìš© ì‚¬ë¡€ |
|------|-----------|---------|--------|----------|
| **JDBC** | ë‚®ìŒ | ì™„ì „ ì œì–´ | ì–´ë ¤ì›€ | ë ˆê±°ì‹œ, ì„±ëŠ¥ ìµœì í™” |
| **Spring JDBC** | ì¤‘ê°„ | ì§ì ‘ ì‘ì„± | ë³´í†µ | ê°„ë‹¨í•œ ì¿¼ë¦¬, ë¹ ë¥¸ êµ¬í˜„ |
| **JPA/Hibernate** | ë†’ìŒ | ìë™ ìƒì„± | ì‰¬ì›€ | CRUD ì¤‘ì‹¬, ë„ë©”ì¸ ëª¨ë¸ |
| **MyBatis** | ì¤‘ê°„ | ì§ì ‘ ì‘ì„± | ë³´í†µ | ë³µì¡í•œ ì¿¼ë¦¬, SQL ì¤‘ì‹¬ |
| **QueryDSL** | ë†’ìŒ | íƒ€ì… ì•ˆì „ | ë³´í†µ | ë™ì  ì¿¼ë¦¬, JPA ë³´ì™„ |

**1. JDBC (Java Database Connectivity)**
```java
// Low-level, ëª¨ë“  ê²ƒì„ ì§ì ‘ ì œì–´
public List<User> findAll() {
    List<User> users = new ArrayList<>();

    try (Connection conn = dataSource.getConnection();
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery("SELECT * FROM users")) {

        while (rs.next()) {
            User user = new User();
            user.setId(rs.getLong("id"));
            user.setName(rs.getString("name"));
            user.setEmail(rs.getString("email"));
            users.add(user);
        }
    } catch (SQLException e) {
        throw new RuntimeException(e);
    }

    return users;
}
```

**ì¥ì **:
- ì™„ì „í•œ ì œì–´ ê°€ëŠ¥
- ì„±ëŠ¥ ìµœì í™” ìš©ì´
- í‘œì¤€ API

**ë‹¨ì **:
- ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œ ë§ìŒ
- SQLException ì²˜ë¦¬ í•„ìš”
- ë°˜ë³µ ì‘ì—… ë§ìŒ

---

**2. Spring JDBC (JdbcTemplate)**
```java
// JDBCë¥¼ ê°„ì†Œí™”í•œ ë²„ì „
@Repository
public class UserRepository {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public List<User> findAll() {
        String sql = "SELECT * FROM users";

        return jdbcTemplate.query(sql, (rs, rowNum) -> {
            User user = new User();
            user.setId(rs.getLong("id"));
            user.setName(rs.getString("name"));
            user.setEmail(rs.getString("email"));
            return user;
        });
    }

    public void save(User user) {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        jdbcTemplate.update(sql, user.getName(), user.getEmail());
    }
}
```

**ì¥ì **:
- JDBCë³´ë‹¤ ê°„ê²°í•œ ì½”ë“œ
- ìë™ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ (Connection, Statement ìë™ close)
- Exception ë³€í™˜ (SQLException â†’ DataAccessException)

**ë‹¨ì **:
- SQLì„ ì§ì ‘ ì‘ì„±í•´ì•¼ í•¨
- ê°ì²´-í…Œì´ë¸” ë§¤í•‘ ìˆ˜ë™

---

**3. JPA/Hibernate (ORM)**
```java
// ê°ì²´ ì¤‘ì‹¬, SQL ìë™ ìƒì„±
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // ë©”ì„œë“œ ì´ë¦„ìœ¼ë¡œ ì¿¼ë¦¬ ìë™ ìƒì„±
    List<User> findByName(String name);
    List<User> findByEmailContaining(String keyword);
}

// ì‚¬ìš©
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public List<User> getAllUsers() {
        return userRepository.findAll();  // SQL ìë™ ìƒì„±
    }
}
```

**ì¥ì **:
- SQL ì‘ì„± ë¶ˆí•„ìš” (ëŒ€ë¶€ë¶„)
- ê°ì²´ ì§€í–¥ì  ê°œë°œ
- ìƒì‚°ì„± ë†’ìŒ
- ë°ì´í„°ë² ì´ìŠ¤ ë…ë¦½ì 

**ë‹¨ì **:
- í•™ìŠµ ê³¡ì„  ë†’ìŒ
- ë³µì¡í•œ ì¿¼ë¦¬ëŠ” ì–´ë ¤ì›€
- ì„±ëŠ¥ íŠœë‹ ì–´ë ¤ì›€ (N+1 ë¬¸ì œ ë“±)

---

**4. MyBatis (SQL Mapper)**
```java
// SQL ì§ì ‘ ì œì–´, ê°ì²´ ë§¤í•‘ ìë™
@Mapper
public interface UserMapper {
    @Select("SELECT * FROM users WHERE name = #{name}")
    List<User> findByName(@Param("name") String name);

    @Insert("INSERT INTO users (name, email) VALUES (#{name}, #{email})")
    void insert(User user);
}
```

**XML ë°©ì‹**:
```xml
<!-- UserMapper.xml -->
<mapper namespace="com.example.UserMapper">
    <select id="findByName" resultType="User">
        SELECT * FROM users
        WHERE name = #{name}
    </select>

    <insert id="insert">
        INSERT INTO users (name, email)
        VALUES (#{name}, #{email})
    </insert>
</mapper>
```

**ì¥ì **:
- SQL ì™„ì „ ì œì–´
- ë³µì¡í•œ ì¿¼ë¦¬ ì‘ì„± ìš©ì´
- ê¸°ì¡´ SQL ì¬ì‚¬ìš© ê°€ëŠ¥
- ë™ì  ì¿¼ë¦¬ ì§€ì›

**ë‹¨ì **:
- SQLì„ ì§ì ‘ ì‘ì„±í•´ì•¼ í•¨
- XML ì„¤ì • í•„ìš” (ë˜ëŠ” Annotation)
- JPAë³´ë‹¤ ìƒì‚°ì„± ë‚®ìŒ

---

**5. QueryDSL (íƒ€ì… ì•ˆì „ ì¿¼ë¦¬)**
```java
// JPA + íƒ€ì… ì•ˆì „ ì¿¼ë¦¬
@Repository
@RequiredArgsConstructor
public class UserRepositoryCustom {

    private final JPAQueryFactory queryFactory;

    public List<User> findByConditions(String name, String email) {
        QUser user = QUser.user;

        return queryFactory
            .selectFrom(user)
            .where(
                nameEq(name),
                emailContains(email)
            )
            .fetch();
    }

    private BooleanExpression nameEq(String name) {
        return name != null ? QUser.user.name.eq(name) : null;
    }

    private BooleanExpression emailContains(String email) {
        return email != null ? QUser.user.email.contains(email) : null;
    }
}
```

**ì¥ì **:
- ì»´íŒŒì¼ íƒ€ì„ ì˜¤ë¥˜ ê²€ì¶œ
- IDE ìë™ì™„ì„± ì§€ì›
- ë™ì  ì¿¼ë¦¬ ì‘ì„± ìš©ì´
- ë¦¬íŒ©í† ë§ ì•ˆì „

**ë‹¨ì **:
- ì´ˆê¸° ì„¤ì • ë³µì¡ (Qí´ë˜ìŠ¤ ìƒì„±)
- í•™ìŠµ ê³¡ì„ 
- JPA ì˜ì¡´ì„±

---

### 3ï¸âƒ£ ê³ ê¸‰ì ìˆ˜ì¤€ ì„¤ëª…

**Springì˜ ë°ì´í„° ì ‘ê·¼ ì•„í‚¤í…ì²˜**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Controller                      â”‚
â”‚              (Presentation Layer)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Service                         â”‚
â”‚              (Business Layer)                    â”‚
â”‚              @Transactional                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Repository                        â”‚
â”‚            (Data Access Layer)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   JDBC   â”‚  JdbcT.. â”‚   JPA    â”‚   MyBatis      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              DataSource                          â”‚
â”‚          (Connection Pool)                       â”‚
â”‚         HikariCP, Tomcat JDBC                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Database                           â”‚
â”‚      MySQL, PostgreSQL, Oracle                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**DataSourceì™€ Connection Pool**

```java
// HikariCP ì„¤ì • (Spring Boot ê¸°ë³¸)
@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.hikari")
    public HikariConfig hikariConfig() {
        HikariConfig config = new HikariConfig();

        // Connection Pool ì„¤ì •
        config.setMaximumPoolSize(20);         // ìµœëŒ€ ì—°ê²° ìˆ˜
        config.setMinimumIdle(5);              // ìµœì†Œ ìœ íœ´ ì—°ê²°
        config.setConnectionTimeout(30000);    // ì—°ê²° ëŒ€ê¸° ì‹œê°„ (30ì´ˆ)
        config.setIdleTimeout(600000);         // ìœ íœ´ ì—°ê²° ìœ ì§€ ì‹œê°„ (10ë¶„)
        config.setMaxLifetime(1800000);        // ì—°ê²° ìµœëŒ€ ìˆ˜ëª… (30ë¶„)

        // ì„±ëŠ¥ ìµœì í™”
        config.setAutoCommit(true);
        config.setConnectionTestQuery("SELECT 1");
        config.setPoolName("HikariPool");

        return config;
    }

    @Bean
    public DataSource dataSource(HikariConfig hikariConfig) {
        return new HikariDataSource(hikariConfig);
    }
}
```

**application.yml**:
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb?useUnicode=true&characterEncoding=utf8
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver

    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      auto-commit: true
      pool-name: HikariPool
```

**Connection Pool ë™ì‘ ì›ë¦¬**:
```
ìš”ì²­ 1: DB ì—°ê²° ìš”ì²­
    â†’ Poolì—ì„œ Connection ê°€ì ¸ì˜´ (ë¹ ë¦„, ~1ms)
    â†’ ì¿¼ë¦¬ ì‹¤í–‰
    â†’ Connectionì„ Poolì— ë°˜í™˜ (ì¬ì‚¬ìš©)

ìš”ì²­ 2: DB ì—°ê²° ìš”ì²­
    â†’ ì´ë¯¸ ìˆëŠ” Connection ì¬ì‚¬ìš© (ìƒˆë¡œ ì—°ê²° ì•ˆ í•¨)
    â†’ ì¿¼ë¦¬ ì‹¤í–‰
    â†’ Connectionì„ Poolì— ë°˜í™˜

âŒ Pool ì—†ì´:
    ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œìš´ Connection ìƒì„± (~100ms)
    â†’ ëŠë¦¼, ë¦¬ì†ŒìŠ¤ ë‚­ë¹„

âœ… Pool ì‚¬ìš©:
    ë¯¸ë¦¬ ìƒì„±ëœ Connection ì¬ì‚¬ìš© (~1ms)
    â†’ ë¹ ë¦„, íš¨ìœ¨ì 
```

**íŠ¸ëœì­ì…˜ ê´€ë¦¬**

```java
@Service
@RequiredArgsConstructor
public class OrderService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final PointRepository pointRepository;

    // âœ… ì„ ì–¸ì  íŠ¸ëœì­ì…˜ (Declarative)
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 1. ì¬ê³  í™•ì¸ ë° ì°¨ê°
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow();
        product.decreaseStock(request.getQuantity());

        // 2. ì£¼ë¬¸ ìƒì„±
        Order order = new Order(request);
        orderRepository.save(order);

        // 3. í¬ì¸íŠ¸ ì°¨ê°
        Point point = pointRepository.findByUserId(request.getUserId())
            .orElseThrow();
        point.use(request.getUsePoints());

        // ëª¨ë‘ ì„±ê³µ â†’ COMMIT
        // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨ â†’ ROLLBACK (ìë™)

        return order;
    }

    // âœ… í”„ë¡œê·¸ë˜ë° ë°©ì‹ íŠ¸ëœì­ì…˜ (Programmatic)
    @Autowired
    private TransactionTemplate transactionTemplate;

    public Order createOrderProgrammatic(OrderRequest request) {
        return transactionTemplate.execute(status -> {
            try {
                // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
                Order order = new Order(request);
                orderRepository.save(order);
                return order;
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
    }
}
```

**íŠ¸ëœì­ì…˜ ì „íŒŒ (Propagation)**

```java
@Service
public class UserService {

    @Autowired
    private PointService pointService;

    // REQUIRED (ê¸°ë³¸ê°’): ê¸°ì¡´ íŠ¸ëœì­ì…˜ ì°¸ì—¬, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
    @Transactional(propagation = Propagation.REQUIRED)
    public void registerUser(User user) {
        userRepository.save(user);
        pointService.giveWelcomePoints(user.getId());  // ê°™ì€ íŠ¸ëœì­ì…˜
    }

    // REQUIRES_NEW: í•­ìƒ ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ ìƒì„±
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logActivity(String message) {
        activityRepository.save(new Activity(message));
        // ë¶€ëª¨ íŠ¸ëœì­ì…˜ê³¼ ë…ë¦½ì  (ë¶€ëª¨ê°€ ë¡¤ë°±ë˜ì–´ë„ ë¡œê·¸ëŠ” ì €ì¥ë¨)
    }

    // MANDATORY: ê¸°ì¡´ íŠ¸ëœì­ì…˜ í•„ìˆ˜ (ì—†ìœ¼ë©´ ì˜ˆì™¸)
    @Transactional(propagation = Propagation.MANDATORY)
    public void updateUserPoints(Long userId, int points) {
        // ë°˜ë“œì‹œ íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ í˜¸ì¶œë˜ì–´ì•¼ í•¨
    }
}
```

**ê²©ë¦¬ ìˆ˜ì¤€ (Isolation Level)**

```java
@Service
public class AccountService {

    // READ_UNCOMMITTED: ê°€ì¥ ë‚®ì€ ê²©ë¦¬ ìˆ˜ì¤€ (Dirty Read ë°œìƒ ê°€ëŠ¥)
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public BigDecimal getBalance(Long accountId) {
        // ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì˜ ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë„ ì½ìŒ
    }

    // READ_COMMITTED: Oracle ê¸°ë³¸ê°’ (Dirty Read ë°©ì§€)
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
        // ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ìŒ
        // Non-Repeatable Read ë°œìƒ ê°€ëŠ¥
    }

    // REPEATABLE_READ: MySQL ê¸°ë³¸ê°’ (Non-Repeatable Read ë°©ì§€)
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void processOrder(Long orderId) {
        // ê°™ì€ ì¿¼ë¦¬ë¥¼ ì—¬ëŸ¬ ë²ˆ ì‹¤í–‰í•´ë„ ê°™ì€ ê²°ê³¼
        // Phantom Read ë°œìƒ ê°€ëŠ¥ (MySQLì€ Next-Key Lockìœ¼ë¡œ ë°©ì§€)
    }

    // SERIALIZABLE: ê°€ì¥ ë†’ì€ ê²©ë¦¬ ìˆ˜ì¤€ (ì™„ì „í•œ ê²©ë¦¬)
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void criticalOperation() {
        // ì™„ì „í•œ ê²©ë¦¬, ë™ì‹œì„± ê°€ì¥ ë‚®ìŒ
    }
}
```

---

## ğŸ’» ê¸°ë³¸ ì‹¤ìŠµ

### ì‹¤ìŠµ 1: Spring JDBC ê¸°ë³¸ ì„¤ì •

**ë‚œì´ë„**: â­â­â˜†â˜†â˜†

#### 1. ì˜ì¡´ì„± ì¶”ê°€ (build.gradle)

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    runtimeOnly 'com.mysql:mysql-connector-j'

    // Connection Pool (Spring Boot ê¸°ë³¸ í¬í•¨)
    // implementation 'com.zaxxer:HikariCP'
}
```

#### 2. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (application.yml)

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb?useUnicode=true&characterEncoding=utf8
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver

    # HikariCP ì„¤ì • (ì˜µì…˜)
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
```

#### 3. í…Œì´ë¸” ìƒì„± (schema.sql)

**src/main/resources/schema.sql**:
```sql
CREATE TABLE IF NOT EXISTS users (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 4. Repository êµ¬í˜„

```java
@Repository
@RequiredArgsConstructor
public class UserRepository {

    private final JdbcTemplate jdbcTemplate;

    public void save(User user) {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        jdbcTemplate.update(sql, user.getName(), user.getEmail());
    }

    public User findById(Long id) {
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, this::mapRow, id);
    }

    public List<User> findAll() {
        String sql = "SELECT * FROM users";
        return jdbcTemplate.query(sql, this::mapRow);
    }

    public void update(User user) {
        String sql = "UPDATE users SET name = ?, email = ? WHERE id = ?";
        jdbcTemplate.update(sql, user.getName(), user.getEmail(), user.getId());
    }

    public void deleteById(Long id) {
        String sql = "DELETE FROM users WHERE id = ?";
        jdbcTemplate.update(sql, id);
    }

    // RowMapper
    private User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
        return user;
    }
}
```

#### 5. Service êµ¬í˜„

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    @Transactional
    public void createUser(String name, String email) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);

        userRepository.save(user);
    }

    public User getUser(Long id) {
        return userRepository.findById(id);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

#### 6. Controller êµ¬í˜„

```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    @PostMapping
    public ResponseEntity<Void> createUser(@RequestBody UserRequest request) {
        userService.createUser(request.getName(), request.getEmail());
        return ResponseEntity.status(HttpStatus.CREATED).build();
    }

    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.getUser(id);
        return ResponseEntity.ok(user);
    }

    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
}
```

#### 7. í…ŒìŠ¤íŠ¸

```bash
# ì‚¬ìš©ì ìƒì„±
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"í™ê¸¸ë™","email":"hong@example.com"}'

# ì‚¬ìš©ì ì¡°íšŒ
curl http://localhost:8080/api/users/1

# ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ
curl http://localhost:8080/api/users
```

---

### ì‹¤ìŠµ 2: JPA ê¸°ë³¸ ì„¤ì •

**ë‚œì´ë„**: â­â­â˜†â˜†â˜†

#### 1. ì˜ì¡´ì„± ì¶”ê°€

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.mysql:mysql-connector-j'
}
```

#### 2. ì„¤ì • (application.yml)

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/testdb
    username: root
    password: password

  jpa:
    hibernate:
      ddl-auto: update  # create, update, validate, none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
```

#### 3. Entity ì •ì˜

```java
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}
```

#### 4. Repository ì •ì˜

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // ë©”ì„œë“œ ì´ë¦„ìœ¼ë¡œ ì¿¼ë¦¬ ìë™ ìƒì„±
    Optional<User> findByEmail(String email);

    List<User> findByNameContaining(String keyword);

    @Query("SELECT u FROM User u WHERE u.email LIKE %:keyword%")
    List<User> searchByEmail(@Param("keyword") String keyword);
}
```

#### 5. Service êµ¬í˜„

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;

    @Transactional
    public User createUser(String name, String email) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);

        return userRepository.save(user);
    }

    public User getUser(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    @Transactional
    public User updateUser(Long id, String name, String email) {
        User user = getUser(id);
        user.setName(name);
        user.setEmail(email);

        return userRepository.save(user);
    }

    @Transactional
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

---

## ğŸ¢ ì‹¤ë¬´ í™œìš© ì‚¬ë¡€

### ì‚¬ë¡€ 1: ë°°ë‹¬ì˜ë¯¼ì¡± - í•˜ì´ë¸Œë¦¬ë“œ ë°ì´í„° ì ‘ê·¼ ì „ëµ

**ë°°ê²½**:
ë°°ë‹¬ì˜ë¯¼ì¡±ì´ ìˆ˜ë°±ë§Œ ì£¼ë¬¸ì„ ì²˜ë¦¬í•˜ë©´ì„œ JPAì™€ MyBatisë¥¼ í•¨ê»˜ ì‚¬ìš©í•˜ì—¬ ì„±ëŠ¥ê³¼ ìƒì‚°ì„±ì„ ëª¨ë‘ ì¡ì€ ì‚¬ë¡€

**ìš”êµ¬ì‚¬í•­**:
- ì¼ë°˜ CRUD: ë¹ ë¥¸ ê°œë°œ ì†ë„
- ë³µì¡í•œ í†µê³„ ì¿¼ë¦¬: ë†’ì€ ì„±ëŠ¥
- ëŒ€ìš©ëŸ‰ ë°°ì¹˜ ì²˜ë¦¬: ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±
- ì‹¤ì‹œê°„ ì£¼ë¬¸ ì²˜ë¦¬: íŠ¸ëœì­ì…˜ ì•ˆì •ì„±

**êµ¬í˜„ ì½”ë“œ**:

```java
// 1. JPAë¡œ ê°„ë‹¨í•œ CRUD (ìƒì‚°ì„± ìš°ì„ )
@Entity
@Table(name = "orders")
@Getter
@Setter
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long userId;

    @Column(nullable = false)
    private Long restaurantId;

    @Enumerated(EnumType.STRING)
    private OrderStatus status;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "created_at")
    private LocalDateTime createdAt;
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    List<Order> findByUserId(Long userId);
    List<Order> findByStatus(OrderStatus status);
}

// 2. MyBatisë¡œ ë³µì¡í•œ í†µê³„ ì¿¼ë¦¬ (ì„±ëŠ¥ ìš°ì„ )
@Mapper
public interface OrderStatisticsMapper {

    // ìŒì‹ì ë³„ ì¼ì¼ ë§¤ì¶œ í†µê³„ (ë³µì¡í•œ GROUP BY, JOIN)
    @Select("""
        SELECT
            r.id as restaurant_id,
            r.name as restaurant_name,
            DATE(o.created_at) as order_date,
            COUNT(o.id) as order_count,
            SUM(o.total_amount) as total_sales,
            AVG(o.total_amount) as avg_order_amount
        FROM orders o
        JOIN restaurants r ON o.restaurant_id = r.id
        WHERE o.created_at >= #{startDate}
          AND o.created_at < #{endDate}
          AND o.status = 'COMPLETED'
        GROUP BY r.id, r.name, DATE(o.created_at)
        ORDER BY total_sales DESC
    """)
    List<RestaurantDailySales> getDailySalesStatistics(
        @Param("startDate") LocalDateTime startDate,
        @Param("endDate") LocalDateTime endDate
    );

    // ì‹œê°„ëŒ€ë³„ ì£¼ë¬¸ ë¶„í¬ (ë™ì  ì¿¼ë¦¬)
    List<HourlyOrderDistribution> getHourlyDistribution(
        @Param("restaurantId") Long restaurantId,
        @Param("dayOfWeek") String dayOfWeek
    );
}
```

**MyBatis XML (ë™ì  ì¿¼ë¦¬)**:
```xml
<!-- OrderStatisticsMapper.xml -->
<mapper namespace="com.baemin.mapper.OrderStatisticsMapper">

    <select id="getHourlyDistribution" resultType="HourlyOrderDistribution">
        SELECT
            HOUR(created_at) as hour,
            COUNT(*) as order_count,
            AVG(total_amount) as avg_amount
        FROM orders
        WHERE 1=1
            <if test="restaurantId != null">
                AND restaurant_id = #{restaurantId}
            </if>
            <if test="dayOfWeek != null">
                AND DAYNAME(created_at) = #{dayOfWeek}
            </if>
            AND status = 'COMPLETED'
            AND created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        GROUP BY HOUR(created_at)
        ORDER BY hour
    </select>

</mapper>
```

**Service ê³„ì¸µ (ë‘ ê°€ì§€ í˜¼í•© ì‚¬ìš©)**:
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderService {

    private final OrderRepository orderRepository;  // JPA
    private final OrderStatisticsMapper statisticsMapper;  // MyBatis

    // âœ… ê°„ë‹¨í•œ CRUDëŠ” JPA (ë¹ ë¥¸ ê°œë°œ)
    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = new Order();
        order.setUserId(request.getUserId());
        order.setRestaurantId(request.getRestaurantId());
        order.setTotalAmount(request.getTotalAmount());
        order.setStatus(OrderStatus.PENDING);
        order.setCreatedAt(LocalDateTime.now());

        return orderRepository.save(order);
    }

    public List<Order> getUserOrders(Long userId) {
        return orderRepository.findByUserId(userId);
    }

    // âœ… ë³µì¡í•œ í†µê³„ëŠ” MyBatis (ê³ ì„±ëŠ¥)
    public List<RestaurantDailySales> getDailySalesReport(
            LocalDate startDate, LocalDate endDate) {

        LocalDateTime start = startDate.atStartOfDay();
        LocalDateTime end = endDate.plusDays(1).atStartOfDay();

        return statisticsMapper.getDailySalesStatistics(start, end);
    }

    public Map<Integer, OrderStatistics> getHourlyOrderPattern(
            Long restaurantId, String dayOfWeek) {

        List<HourlyOrderDistribution> distribution =
            statisticsMapper.getHourlyDistribution(restaurantId, dayOfWeek);

        return distribution.stream()
            .collect(Collectors.toMap(
                HourlyOrderDistribution::getHour,
                d -> new OrderStatistics(d.getOrderCount(), d.getAvgAmount())
            ));
    }
}
```

**ëŒ€ìš©ëŸ‰ ë°°ì¹˜ ì²˜ë¦¬ (MyBatisë¡œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ìœ¼ë¡œ)**:
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OrderBatchProcessor {

    private final OrderStatisticsMapper statisticsMapper;
    private final SqlSessionFactory sqlSessionFactory;

    @Scheduled(cron = "0 0 2 * * *")  // ë§¤ì¼ ìƒˆë²½ 2ì‹œ
    public void processMonthlyStatistics() {
        log.info("Starting monthly statistics batch job");

        LocalDateTime startOfMonth = LocalDateTime.now()
            .withDayOfMonth(1)
            .withHour(0)
            .withMinute(0)
            .withSecond(0);

        // âœ… MyBatisì˜ Cursorë¥¼ ì‚¬ìš©í•œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ëŒ€ëŸ‰ ì²˜ë¦¬
        try (SqlSession session = sqlSessionFactory.openSession();
             Cursor<Order> cursor = session.selectCursor(
                 "com.baemin.mapper.OrderMapper.selectAllForMonth",
                 startOfMonth)) {

            int count = 0;
            for (Order order : cursor) {
                processOrder(order);

                if (++count % 1000 == 0) {
                    log.info("Processed {} orders", count);
                }
            }

            log.info("Monthly statistics completed. Total: {} orders", count);
        }
    }

    private void processOrder(Order order) {
        // í†µê³„ ì²˜ë¦¬ ë¡œì§
    }
}
```

**ì„±ê³¼**:
- JPA ì‚¬ìš©ìœ¼ë¡œ ê°œë°œ ì†ë„ **50% í–¥ìƒ**
- MyBatisë¡œ ë³µì¡í•œ ì¿¼ë¦¬ ì„±ëŠ¥ **300% ê°œì„ **
- ë°°ì¹˜ ì²˜ë¦¬ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ **90% ê°ì†Œ** (Cursor ì‚¬ìš©)
- ì „ì²´ ì‹œìŠ¤í…œ ì•ˆì •ì„± **í–¥ìƒ** (íŠ¸ëœì­ì…˜ ê´€ë¦¬ ì¼ì›í™”)

---

### ì‚¬ë¡€ 2: í† ìŠ¤ - Multi-DataSource ì „ëµ

**ë°°ê²½**:
í† ìŠ¤ê°€ ì½ê¸°/ì“°ê¸° ë¶„ë¦¬(Read/Write Splitting)ë¡œ ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ë¥¼ ë¶„ì‚°í•œ ì‚¬ë¡€

**ìš”êµ¬ì‚¬í•­**:
- Master DB: ì“°ê¸° ì‘ì—… (INSERT, UPDATE, DELETE)
- Slave DB (ë³µì œë³¸): ì½ê¸° ì‘ì—… (SELECT)
- íŠ¸ëœì­ì…˜ ë‚´ ì“°ê¸° â†’ Masterë¡œ ë¼ìš°íŒ…
- ì½ê¸° ì „ìš© â†’ Slaveë¡œ ë¼ìš°íŒ…
- Slave ì¥ì•  ì‹œ Masterë¡œ Failover

**êµ¬í˜„ ì½”ë“œ**:

```java
// 1. DataSource ì„¤ì •
@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DataSource routingDataSource(
            @Qualifier("masterDataSource") DataSource master,
            @Qualifier("slaveDataSource") DataSource slave) {

        ReplicationRoutingDataSource routingDataSource =
            new ReplicationRoutingDataSource();

        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.MASTER, master);
        dataSourceMap.put(DataSourceType.SLAVE, slave);

        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(master);

        return routingDataSource;
    }
}

// 2. ë™ì  DataSource ë¼ìš°íŒ…
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        // í˜„ì¬ ìš”ì²­ì´ ì½ê¸° ì „ìš©ì¸ì§€ í™•ì¸
        boolean isReadOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();

        if (isReadOnly) {
            log.debug("Routing to SLAVE DataSource");
            return DataSourceType.SLAVE;
        } else {
            log.debug("Routing to MASTER DataSource");
            return DataSourceType.MASTER;
        }
    }
}

enum DataSourceType {
    MASTER, SLAVE
}

// 3. Service ê³„ì¸µì—ì„œ ì‚¬ìš©
@Service
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final PaymentRepository paymentRepository;

    // âœ… ì“°ê¸° ì‘ì—…: Master DB ì‚¬ìš©
    @Transactional
    public Payment createPayment(PaymentRequest request) {
        log.info("Creating payment - will use MASTER DB");

        Payment payment = new Payment();
        payment.setUserId(request.getUserId());
        payment.setAmount(request.getAmount());
        payment.setStatus(PaymentStatus.PENDING);

        return paymentRepository.save(payment);
    }

    // âœ… ì½ê¸° ì „ìš©: Slave DB ì‚¬ìš©
    @Transactional(readOnly = true)
    public Payment getPayment(Long id) {
        log.info("Fetching payment - will use SLAVE DB");

        return paymentRepository.findById(id)
            .orElseThrow(() -> new PaymentNotFoundException(id));
    }

    // âœ… ì½ê¸° ì „ìš© í†µê³„: Slave DB ì‚¬ìš©
    @Transactional(readOnly = true)
    public PaymentStatistics getMonthlyStatistics(Long userId) {
        log.info("Fetching statistics - will use SLAVE DB");

        LocalDateTime startOfMonth = LocalDateTime.now()
            .withDayOfMonth(1)
            .withHour(0);

        List<Payment> payments = paymentRepository
            .findByUserIdAndCreatedAtAfter(userId, startOfMonth);

        return PaymentStatistics.from(payments);
    }

    // âœ… ì“°ê¸° ì‘ì—…ì´ í¬í•¨ë˜ë©´ Master DB ì‚¬ìš©
    @Transactional
    public void processPayment(Long paymentId) {
        log.info("Processing payment - will use MASTER DB");

        Payment payment = paymentRepository.findById(paymentId)
            .orElseThrow();

        // ìƒíƒœ ë³€ê²½ (ì“°ê¸° ì‘ì—…)
        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setCompletedAt(LocalDateTime.now());

        paymentRepository.save(payment);
    }
}
```

**application.yml**:
```yaml
spring:
  datasource:
    master:
      jdbc-url: jdbc:mysql://master-db:3306/toss
      username: toss_master
      password: master_password
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5

    slave:
      jdbc-url: jdbc:mysql://slave-db:3306/toss
      username: toss_slave
      password: slave_password
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 30  # SlaveëŠ” ë” ë§ì€ ì—°ê²° í—ˆìš©
        minimum-idle: 10
```

**Slave ì¥ì•  ì‹œ Failover**:
```java
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    private final DataSource masterDataSource;
    private final DataSource slaveDataSource;
    private boolean slaveAvailable = true;

    @Override
    protected Object determineCurrentLookupKey() {
        boolean isReadOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();

        if (isReadOnly && slaveAvailable) {
            try {
                // Slave ìƒíƒœ í™•ì¸
                testSlaveConnection();
                return DataSourceType.SLAVE;
            } catch (Exception e) {
                log.error("Slave DB is not available. Falling back to Master", e);
                slaveAvailable = false;
                scheduleSlaveHealthCheck();
                return DataSourceType.MASTER;
            }
        }

        return DataSourceType.MASTER;
    }

    private void testSlaveConnection() throws SQLException {
        try (Connection conn = slaveDataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute("SELECT 1");
        }
    }

    @Scheduled(fixedDelay = 10000)  // 10ì´ˆë§ˆë‹¤ í™•ì¸
    public void scheduleSlaveHealthCheck() {
        if (!slaveAvailable) {
            try {
                testSlaveConnection();
                slaveAvailable = true;
                log.info("Slave DB is back online");
            } catch (Exception e) {
                log.debug("Slave DB still unavailable");
            }
        }
    }
}
```

**ì„±ê³¼**:
- Master DB ë¶€í•˜ **70% ê°ì†Œ** (ì½ê¸°ë¥¼ Slaveë¡œ ë¶„ì‚°)
- ì „ì²´ ì‹œìŠ¤í…œ ì²˜ë¦¬ëŸ‰ **2ë°° í–¥ìƒ**
- Slave ì¥ì•  ì‹œì—ë„ **ë¬´ì¤‘ë‹¨ ì„œë¹„ìŠ¤** (ìë™ Failover)
- í”¼í¬ ì‹œê°„ëŒ€ ì‘ë‹µ ì‹œê°„ **50% ê°œì„ **

---

## ğŸ¯ ì£¼ë‹ˆì–´ ì‹œë‚˜ë¦¬ì˜¤

### ì‹œë‚˜ë¦¬ì˜¤ 1: "DB ì—°ê²°ì´ ì•ˆ ë¼ìš”!"

**ìƒí™©**:
ì£¼ë‹ˆì–´ ê°œë°œì ê¹€ì½”ë”©ì´ Spring Bootë¥¼ ì‹¤í–‰í–ˆëŠ”ë° DB ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**ì—ëŸ¬ ë©”ì‹œì§€**:
```
com.mysql.cj.jdbc.exceptions.CommunicationsException:
Communications link failure

The last packet sent successfully to the server was 0 milliseconds ago.
The driver has not received any packets from the server.
```

**ì›ì¸ ë¶„ì„**:

**ì›ì¸ 1: MySQL ì„œë²„ê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ**
```bash
# MySQL ìƒíƒœ í™•ì¸
sudo systemctl status mysql

# ì‹¤í–‰ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì‹œì‘
sudo systemctl start mysql
```

**ì›ì¸ 2: í¬íŠ¸ ë²ˆí˜¸ í‹€ë¦¼**
```yaml
# âŒ ì˜ëª»ëœ í¬íŠ¸
spring:
  datasource:
    url: jdbc:mysql://localhost:3307/mydb  # MySQL ê¸°ë³¸ í¬íŠ¸ëŠ” 3306

# âœ… ì˜¬ë°”ë¥¸ í¬íŠ¸
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
```

**ì›ì¸ 3: ë°ì´í„°ë² ì´ìŠ¤ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŒ**
```sql
-- MySQLì— ì ‘ì†í•˜ì—¬ ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±
CREATE DATABASE mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

**ì›ì¸ 4: ì‚¬ìš©ì ê¶Œí•œ ë¬¸ì œ**
```sql
-- ì‚¬ìš©ì ìƒì„± ë° ê¶Œí•œ ë¶€ì—¬
CREATE USER 'myuser'@'localhost' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON mydb.* TO 'myuser'@'localhost';
FLUSH PRIVILEGES;
```

**ì›ì¸ 5: ë°©í™”ë²½ ì°¨ë‹¨**
```bash
# ë°©í™”ë²½ ìƒíƒœ í™•ì¸
sudo ufw status

# MySQL í¬íŠ¸ í—ˆìš©
sudo ufw allow 3306/tcp
```

**í•´ê²°ì±… ì²´í¬ë¦¬ìŠ¤íŠ¸**:
```
âœ… MySQL ì„œë²„ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
âœ… í¬íŠ¸ ë²ˆí˜¸ í™•ì¸ (ê¸°ë³¸: 3306)
âœ… ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± ì—¬ë¶€ í™•ì¸
âœ… ì‚¬ìš©ì ì´ë¦„/ë¹„ë°€ë²ˆí˜¸ í™•ì¸
âœ… ì‚¬ìš©ì ê¶Œí•œ í™•ì¸
âœ… ë°©í™”ë²½ ì„¤ì • í™•ì¸
âœ… application.yml ì„¤ì • í™•ì¸
```

**ê²€ì¦ ë°©ë²•**:
```bash
# MySQL ì§ì ‘ ì ‘ì† í…ŒìŠ¤íŠ¸
mysql -h localhost -P 3306 -u myuser -p

# ì—°ê²°ë˜ë©´ ë°ì´í„°ë² ì´ìŠ¤ ì„ íƒ
USE mydb;

# í…Œì´ë¸” ëª©ë¡ í™•ì¸
SHOW TABLES;
```

---

### ì‹œë‚˜ë¦¬ì˜¤ 2: "íŠ¸ëœì­ì…˜ì´ ë¡¤ë°± ì•ˆ ë¼ìš”!"

**ìƒí™©**:
ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ë°ì´í„°ê°€ ê·¸ëŒ€ë¡œ ì €ì¥ë©ë‹ˆë‹¤.

**ë¬¸ì œ ì½”ë“œ**:
```java
@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private PointService pointService;

    // âŒ @Transactional ëˆ„ë½!
    public void createOrder(OrderRequest request) {
        // 1. ì£¼ë¬¸ ìƒì„±
        Order order = new Order(request);
        orderRepository.save(order);

        // 2. í¬ì¸íŠ¸ ì°¨ê° (ì—¬ê¸°ì„œ ì˜ˆì™¸ ë°œìƒ)
        pointService.deductPoints(request.getUserId(), request.getUsePoints());
        // â†’ ì˜ˆì™¸ê°€ ë°œìƒí•´ë„ ì£¼ë¬¸ì€ ê·¸ëŒ€ë¡œ ì €ì¥ë¨!
    }
}
```

**ì¦ìƒ**:
```
1. ì£¼ë¬¸ ìƒì„±: âœ… ì„±ê³µ (DBì— ì €ì¥ë¨)
2. í¬ì¸íŠ¸ ì°¨ê°: âŒ ì‹¤íŒ¨ (ì˜ˆì™¸ ë°œìƒ)

ê²°ê³¼: ì£¼ë¬¸ì€ ì €ì¥ë˜ì—ˆì§€ë§Œ í¬ì¸íŠ¸ëŠ” ì°¨ê° ì•ˆ ë¨ â†’ ë°ì´í„° ë¶ˆì¼ì¹˜!
```

**í•´ê²°ì±… 1: @Transactional ì¶”ê°€**:
```java
@Service
public class OrderService {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private PointService pointService;

    // âœ… @Transactional ì¶”ê°€
    @Transactional
    public void createOrder(OrderRequest request) {
        // 1. ì£¼ë¬¸ ìƒì„±
        Order order = new Order(request);
        orderRepository.save(order);

        // 2. í¬ì¸íŠ¸ ì°¨ê°
        pointService.deductPoints(request.getUserId(), request.getUsePoints());

        // ì˜ˆì™¸ ë°œìƒ ì‹œ ë‘˜ ë‹¤ ë¡¤ë°±ë¨!
    }
}
```

**ì£¼ì˜ì‚¬í•­**:
```java
// âŒ Checked Exceptionì€ ê¸°ë³¸ì ìœ¼ë¡œ ë¡¤ë°± ì•ˆ ë¨
@Transactional
public void createOrder(OrderRequest request) throws Exception {
    orderRepository.save(new Order(request));
    throw new Exception("Error");  // ë¡¤ë°± ì•ˆ ë¨!
}

// âœ… RuntimeExceptionì€ ìë™ ë¡¤ë°±
@Transactional
public void createOrder(OrderRequest request) {
    orderRepository.save(new Order(request));
    throw new RuntimeException("Error");  // ìë™ ë¡¤ë°±ë¨
}

// âœ… Checked Exceptionë„ ë¡¤ë°±í•˜ë ¤ë©´ ëª…ì‹œ
@Transactional(rollbackFor = Exception.class)
public void createOrder(OrderRequest request) throws Exception {
    orderRepository.save(new Order(request));
    throw new Exception("Error");  // ë¡¤ë°±ë¨
}
```

---

### ì‹œë‚˜ë¦¬ì˜¤ 3: "N+1 ë¬¸ì œê°€ ë­”ê°€ìš”?"

**ìƒí™©**:
íšŒì› ëª©ë¡ê³¼ ê° íšŒì›ì˜ ì£¼ë¬¸ì„ ì¡°íšŒí•˜ëŠ”ë° ì¿¼ë¦¬ê°€ ìˆ˜ì²œ ê°œ ì‹¤í–‰ë©ë‹ˆë‹¤.

**ë¬¸ì œ ì½”ë“œ**:
```java
@Entity
public class User {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Service
public class UserService {

    public List<UserDTO> getAllUsersWithOrders() {
        List<User> users = userRepository.findAll();  // 1ë²ˆ ì¿¼ë¦¬

        return users.stream()
            .map(user -> {
                UserDTO dto = new UserDTO(user);
                dto.setOrderCount(user.getOrders().size());  // Në²ˆ ì¶”ê°€ ì¿¼ë¦¬!
                return dto;
            })
            .collect(Collectors.toList());
    }
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆ: ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ
SELECT * FROM users;  -- ê²°ê³¼: 100ëª…

-- Në²ˆ: ê° ì‚¬ìš©ìì˜ ì£¼ë¬¸ ì¡°íšŒ (100ë²ˆ!)
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 2;
SELECT * FROM orders WHERE user_id = 3;
...
SELECT * FROM orders WHERE user_id = 100;

-- ì´ 101ë²ˆì˜ ì¿¼ë¦¬ ì‹¤í–‰! (1 + N)
```

**í•´ê²°ì±… 1: Fetch Join**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    // âœ… Fetch Joinìœ¼ë¡œ í•œ ë²ˆì— ì¡°íšŒ
    @Query("SELECT u FROM User u JOIN FETCH u.orders")
    List<User> findAllWithOrders();
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ
SELECT u.*, o.*
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

**í•´ê²°ì±… 2: @EntityGraph**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @EntityGraph(attributePaths = "orders")
    List<User> findAll();
}
```

**í•´ê²°ì±… 3: Batch Size ì„¤ì •**:
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

**ì´ë ‡ê²Œ í•˜ë©´**:
```sql
-- Ordersë¥¼ IN ì ˆë¡œ í•œ ë²ˆì— ì¡°íšŒ (100ê°œì”©)
SELECT * FROM orders WHERE user_id IN (1, 2, 3, ..., 100);

-- 101ë²ˆ â†’ 2ë²ˆìœ¼ë¡œ ê°ì†Œ!
```

---

### ì‹œë‚˜ë¦¬ì˜¤ 4: "LazyInitializationExceptionì´ ë°œìƒí•´ìš”!"

**ìƒí™©**:
Controllerì—ì„œ ì—°ê´€ ì—”í‹°í‹°ë¥¼ ì¡°íšŒí•˜ë ¤ê³  í•˜ë‹ˆ ì˜ˆì™¸ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**ë¬¸ì œ ì½”ë“œ**:
```java
@Entity
public class User {
    @Id
    private Long id;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY)  // Lazy Loading
    private List<Order> orders;
}

@Service
public class UserService {

    public User getUser(Long id) {
        return userRepository.findById(id).orElseThrow();
        // Service ë©”ì„œë“œ ì¢…ë£Œ â†’ íŠ¸ëœì­ì…˜ ì¢…ë£Œ â†’ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì¢…ë£Œ
    }
}

@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        User user = userService.getUser(id);

        // âŒ ì—¬ê¸°ì„œ orders ì ‘ê·¼ ì‹œ LazyInitializationException!
        return new UserDTO(user, user.getOrders());
    }
}
```

**ì—ëŸ¬ ë©”ì‹œì§€**:
```
org.hibernate.LazyInitializationException:
failed to lazily initialize a collection of role: User.orders,
could not initialize proxy - no Session
```

**ì›ì¸**:
```
1. Service ë©”ì„œë“œ ì¢…ë£Œ â†’ @Transactional ì¢…ë£Œ
2. ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸(Session) ì¢…ë£Œ
3. Controllerì—ì„œ orders ì ‘ê·¼ ì‹œë„
4. ì´ë¯¸ Sessionì´ ì—†ì–´ì„œ Lazy Loading ë¶ˆê°€ëŠ¥
5. Exception ë°œìƒ!
```

**í•´ê²°ì±… 1: Serviceì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ë¡œë“œ**:
```java
@Service
public class UserService {

    @Transactional(readOnly = true)
    public User getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();

        // âœ… íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ë¡œë“œ
        user.getOrders().size();  // Lazy Loading ê°•ì œ ì‹¤í–‰

        return user;
    }
}
```

**í•´ê²°ì±… 2: Fetch Join**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.id = :id")
    Optional<User> findByIdWithOrders(@Param("id") Long id);
}

@Service
public class UserService {

    public User getUser(Long id) {
        return userRepository.findByIdWithOrders(id).orElseThrow();
    }
}
```

**í•´ê²°ì±… 3: DTO ë³€í™˜ (ê°€ì¥ ê¶Œì¥)**:
```java
@Service
public class UserService {

    @Transactional(readOnly = true)
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();

        // âœ… íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ DTO ë³€í™˜
        return new UserDTO(user, user.getOrders());
    }
}

@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        return userService.getUser(id);  // ì´ë¯¸ DTOë¡œ ë³€í™˜ë¨
    }
}
```

**ë°°ìš´ ì **:
- Lazy Loadingì€ íŠ¸ëœì­ì…˜ ì•ˆì—ì„œë§Œ ì‘ë™
- Controllerì—ì„œëŠ” ì—”í‹°í‹° ëŒ€ì‹  DTO ì‚¬ìš©
- í•„ìš”í•œ ë°ì´í„°ëŠ” Serviceì—ì„œ ë¯¸ë¦¬ ë¡œë“œ

---

## ğŸš€ ì‹¤ì „ í”„ë¡œì íŠ¸: ì´ì»¤ë¨¸ìŠ¤ ì£¼ë¬¸ ì‹œìŠ¤í…œ

### í”„ë¡œì íŠ¸ ê°œìš”

**ëª©í‘œ**: ì‹¤ë¬´ ìˆ˜ì¤€ì˜ ì£¼ë¬¸ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•

**ì£¼ìš” ê¸°ëŠ¥**:
1. íšŒì› ê´€ë¦¬ (CRUD)
2. ìƒí’ˆ ê´€ë¦¬ (ì¬ê³  ê´€ë¦¬)
3. ì£¼ë¬¸ ì²˜ë¦¬ (íŠ¸ëœì­ì…˜)
4. ê²°ì œ ì—°ë™
5. ì£¼ë¬¸ í†µê³„ (ë³µì¡í•œ ì¿¼ë¦¬)
6. ë°°ì¹˜ ì²˜ë¦¬ (ì •ì‚°)

**ê¸°ìˆ  ìŠ¤íƒ**:
- Spring Boot 3.2
- JPA + QueryDSL
- MySQL 8.0
- Redis (ìºì‹œ)
- HikariCP (Connection Pool)

---

### 1ë‹¨ê³„: í”„ë¡œì íŠ¸ ì„¤ì •

**build.gradle**:
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'

    // QueryDSL
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'

    runtimeOnly 'com.mysql:mysql-connector-j'

    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'

    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

**application.yml**:
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/ecommerce?useUnicode=true&characterEncoding=utf8mb4
    username: ecommerce_user
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver

    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
        default_batch_fetch_size: 100

  sql:
    init:
      mode: never  # ìš´ì˜ì—ì„œëŠ” Flyway/Liquibase ì‚¬ìš©
```

---

### 2ë‹¨ê³„: Domain ì„¤ê³„

**User Entity**:
```java
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 100)
    private String password;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
```

**Product Entity**:
```java
@Entity
@Table(name = "products")
@Getter
@Setter
@NoArgsConstructor
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String name;

    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal price;

    @Column(nullable = false)
    private Integer stockQuantity;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }

    // ì¬ê³  ì°¨ê°
    public void decreaseStock(int quantity) {
        if (this.stockQuantity < quantity) {
            throw new InsufficientStockException(
                "ì¬ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤. í˜„ì¬ ì¬ê³ : " + this.stockQuantity);
        }
        this.stockQuantity -= quantity;
    }

    // ì¬ê³  ì¦ê°€
    public void increaseStock(int quantity) {
        this.stockQuantity += quantity;
    }
}
```

**Order Entity**:
```java
@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private OrderStatus status;

    @Column(name = "total_amount", nullable = false, precision = 10, scale = 2)
    private BigDecimal totalAmount;

    @Column(name = "order_date", nullable = false)
    private LocalDateTime orderDate;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        if (orderDate == null) {
            orderDate = LocalDateTime.now();
        }
        if (status == null) {
            status = OrderStatus.PENDING;
        }
    }

    // ì—°ê´€ê´€ê³„ í¸ì˜ ë©”ì„œë“œ
    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    // ì´ ê¸ˆì•¡ ê³„ì‚°
    public void calculateTotalAmount() {
        this.totalAmount = orderItems.stream()
            .map(OrderItem::getTotalPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

enum OrderStatus {
    PENDING,      // ëŒ€ê¸°
    CONFIRMED,    // í™•ì¸
    SHIPPED,      // ë°°ì†¡ì¤‘
    DELIVERED,    // ë°°ì†¡ì™„ë£Œ
    CANCELLED     // ì·¨ì†Œ
}
```

**OrderItem Entity**:
```java
@Entity
@Table(name = "order_items")
@Getter
@Setter
@NoArgsConstructor
public class OrderItem {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id", nullable = false)
    private Product product;

    @Column(nullable = false)
    private Integer quantity;

    @Column(name = "unit_price", nullable = false, precision = 10, scale = 2)
    private BigDecimal unitPrice;

    // ì´ ê°€ê²© ê³„ì‚°
    public BigDecimal getTotalPrice() {
        return unitPrice.multiply(BigDecimal.valueOf(quantity));
    }
}
```

---

### 3ë‹¨ê³„: Repository êµ¬í˜„

**UserRepository**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
```

**ProductRepository**:
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") Long id);

    List<Product> findByStockQuantityLessThan(Integer threshold);
}
```

**OrderRepository**:
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {

    @Query("SELECT o FROM Order o JOIN FETCH o.user WHERE o.id = :id")
    Optional<Order> findByIdWithUser(@Param("id") Long id);

    @Query("SELECT o FROM Order o " +
           "JOIN FETCH o.user " +
           "JOIN FETCH o.orderItems oi " +
           "JOIN FETCH oi.product " +
           "WHERE o.id = :id")
    Optional<Order> findByIdWithDetails(@Param("id") Long id);

    List<Order> findByUserIdOrderByOrderDateDesc(Long userId);

    List<Order> findByStatus(OrderStatus status);
}
```

---

### 4ë‹¨ê³„: Service êµ¬í˜„

**OrderService**:
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class OrderService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final UserRepository userRepository;

    @Transactional
    public Order createOrder(Long userId, List<OrderItemRequest> items) {
        log.info("Creating order for user: {}", userId);

        // 1. ì‚¬ìš©ì ì¡°íšŒ
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException("ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + userId));

        // 2. ì£¼ë¬¸ ìƒì„±
        Order order = new Order();
        order.setUser(user);
        order.setStatus(OrderStatus.PENDING);
        order.setOrderDate(LocalDateTime.now());

        // 3. ì£¼ë¬¸ í•­ëª© ì¶”ê°€ ë° ì¬ê³  ì°¨ê°
        for (OrderItemRequest itemRequest : items) {
            // ë¹„ê´€ì  ë½ìœ¼ë¡œ ì¬ê³  í™•ë³´
            Product product = productRepository.findByIdWithLock(itemRequest.getProductId())
                .orElseThrow(() -> new ProductNotFoundException(
                    "ìƒí’ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + itemRequest.getProductId()));

            // ì¬ê³  ì°¨ê° (ë¶€ì¡±í•˜ë©´ ì˜ˆì™¸ ë°œìƒ)
            product.decreaseStock(itemRequest.getQuantity());

            // ì£¼ë¬¸ í•­ëª© ìƒì„±
            OrderItem orderItem = new OrderItem();
            orderItem.setProduct(product);
            orderItem.setQuantity(itemRequest.getQuantity());
            orderItem.setUnitPrice(product.getPrice());

            order.addOrderItem(orderItem);
        }

        // 4. ì´ ê¸ˆì•¡ ê³„ì‚°
        order.calculateTotalAmount();

        // 5. ì£¼ë¬¸ ì €ì¥
        Order savedOrder = orderRepository.save(order);

        log.info("Order created successfully: {}", savedOrder.getId());

        return savedOrder;
    }

    @Transactional(readOnly = true)
    public Order getOrderDetails(Long orderId) {
        return orderRepository.findByIdWithDetails(orderId)
            .orElseThrow(() -> new OrderNotFoundException("ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + orderId));
    }

    @Transactional(readOnly = true)
    public List<Order> getUserOrders(Long userId) {
        return orderRepository.findByUserIdOrderByOrderDateDesc(userId);
    }

    @Transactional
    public Order cancelOrder(Long orderId) {
        Order order = orderRepository.findByIdWithDetails(orderId)
            .orElseThrow(() -> new OrderNotFoundException("ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: " + orderId));

        // ì·¨ì†Œ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        if (order.getStatus() == OrderStatus.SHIPPED ||
            order.getStatus() == OrderStatus.DELIVERED) {
            throw new OrderCancellationException("ë°°ì†¡ ì¤‘ì´ê±°ë‚˜ ì™„ë£Œëœ ì£¼ë¬¸ì€ ì·¨ì†Œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }

        // ì¬ê³  ë³µêµ¬
        for (OrderItem item : order.getOrderItems()) {
            Product product = item.getProduct();
            product.increaseStock(item.getQuantity());
        }

        // ì£¼ë¬¸ ìƒíƒœ ë³€ê²½
        order.setStatus(OrderStatus.CANCELLED);

        return orderRepository.save(order);
    }
}
```

---

### 5ë‹¨ê³„: Controller êµ¬í˜„

**OrderController**:
```java
@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    @PostMapping
    public ResponseEntity<OrderResponse> createOrder(
            @RequestBody @Valid CreateOrderRequest request) {

        Order order = orderService.createOrder(
            request.getUserId(),
            request.getItems()
        );

        OrderResponse response = OrderResponse.from(order);

        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{orderId}")
    public ResponseEntity<OrderDetailResponse> getOrder(
            @PathVariable Long orderId) {

        Order order = orderService.getOrderDetails(orderId);

        return ResponseEntity.ok(OrderDetailResponse.from(order));
    }

    @GetMapping("/user/{userId}")
    public ResponseEntity<List<OrderResponse>> getUserOrders(
            @PathVariable Long userId) {

        List<Order> orders = orderService.getUserOrders(userId);

        List<OrderResponse> responses = orders.stream()
            .map(OrderResponse::from)
            .collect(Collectors.toList());

        return ResponseEntity.ok(responses);
    }

    @PostMapping("/{orderId}/cancel")
    public ResponseEntity<OrderResponse> cancelOrder(
            @PathVariable Long orderId) {

        Order order = orderService.cancelOrder(orderId);

        return ResponseEntity.ok(OrderResponse.from(order));
    }
}
```

---

### 6ë‹¨ê³„: í…ŒìŠ¤íŠ¸

**í†µí•© í…ŒìŠ¤íŠ¸**:
```java
@SpringBootTest
@Transactional
class OrderServiceTest {

    @Autowired
    private OrderService orderService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ProductRepository productRepository;

    @Test
    @DisplayName("ì£¼ë¬¸ ìƒì„± - ì„±ê³µ")
    void createOrder_Success() {
        // Given
        User user = createUser("í™ê¸¸ë™", "hong@example.com");
        Product product = createProduct("ë…¸íŠ¸ë¶", BigDecimal.valueOf(1000000), 10);

        List<OrderItemRequest> items = List.of(
            new OrderItemRequest(product.getId(), 2)
        );

        // When
        Order order = orderService.createOrder(user.getId(), items);

        // Then
        assertThat(order).isNotNull();
        assertThat(order.getTotalAmount()).isEqualTo(BigDecimal.valueOf(2000000));
        assertThat(order.getOrderItems()).hasSize(1);

        // ì¬ê³  í™•ì¸
        Product updatedProduct = productRepository.findById(product.getId()).orElseThrow();
        assertThat(updatedProduct.getStockQuantity()).isEqualTo(8);
    }

    @Test
    @DisplayName("ì£¼ë¬¸ ìƒì„± - ì¬ê³  ë¶€ì¡± ì‹œ ì‹¤íŒ¨")
    void createOrder_InsufficientStock() {
        // Given
        User user = createUser("í™ê¸¸ë™", "hong@example.com");
        Product product = createProduct("ë…¸íŠ¸ë¶", BigDecimal.valueOf(1000000), 5);

        List<OrderItemRequest> items = List.of(
            new OrderItemRequest(product.getId(), 10)  // ì¬ê³ ë³´ë‹¤ ë§ì´ ì£¼ë¬¸
        );

        // When & Then
        assertThatThrownBy(() -> orderService.createOrder(user.getId(), items))
            .isInstanceOf(InsufficientStockException.class);

        // ì¬ê³ ê°€ ë³€ê²½ë˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸ (ë¡¤ë°±)
        Product unchangedProduct = productRepository.findById(product.getId()).orElseThrow();
        assertThat(unchangedProduct.getStockQuantity()).isEqualTo(5);
    }

    @Test
    @DisplayName("ì£¼ë¬¸ ì·¨ì†Œ - ì¬ê³  ë³µêµ¬ í™•ì¸")
    void cancelOrder_StockRestored() {
        // Given
        User user = createUser("í™ê¸¸ë™", "hong@example.com");
        Product product = createProduct("ë…¸íŠ¸ë¶", BigDecimal.valueOf(1000000), 10);

        List<OrderItemRequest> items = List.of(
            new OrderItemRequest(product.getId(), 3)
        );

        Order order = orderService.createOrder(user.getId(), items);

        // When
        orderService.cancelOrder(order.getId());

        // Then
        Product restoredProduct = productRepository.findById(product.getId()).orElseThrow();
        assertThat(restoredProduct.getStockQuantity()).isEqualTo(10);  // ì¬ê³  ë³µêµ¬ë¨
    }

    private User createUser(String name, String email) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        user.setPassword("password");
        return userRepository.save(user);
    }

    private Product createProduct(String name, BigDecimal price, int stock) {
        Product product = new Product();
        product.setName(name);
        product.setPrice(price);
        product.setStockQuantity(stock);
        return productRepository.save(product);
    }
}
```

---

### í”„ë¡œì íŠ¸ ì™„ì„±ë„ ì²´í¬ë¦¬ìŠ¤íŠ¸

```
âœ… Entity ì„¤ê³„ (User, Product, Order, OrderItem)
âœ… ì—°ê´€ê´€ê³„ ë§¤í•‘ (@ManyToOne, @OneToMany)
âœ… Repository êµ¬í˜„ (JPQL, Fetch Join)
âœ… Service ê³„ì¸µ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
âœ… ë™ì‹œì„± ì œì–´ (ë¹„ê´€ì  ë½)
âœ… ì¬ê³  ê´€ë¦¬ ë¡œì§
âœ… ì˜ˆì™¸ ì²˜ë¦¬
âœ… DTO ë³€í™˜
âœ… í†µí•© í…ŒìŠ¤íŠ¸
```

---

## â“ FAQ

### Q1: JDBCì™€ JPA ì¤‘ ë¬´ì—‡ì„ ì„ íƒí•´ì•¼ í•˜ë‚˜ìš”?

**A**: í”„ë¡œì íŠ¸ íŠ¹ì„±ì— ë”°ë¼ ê²°ì •í•©ë‹ˆë‹¤.

**JPA ì„ íƒí•˜ëŠ” ê²½ìš°**:
- ì¼ë°˜ì ì¸ CRUD ì¤‘ì‹¬ ì• í”Œë¦¬ì¼€ì´ì…˜
- ë¹ ë¥¸ ê°œë°œ ì†ë„ í•„ìš”
- ë„ë©”ì¸ ëª¨ë¸ ì¤‘ì‹¬ ì„¤ê³„
- ë°ì´í„°ë² ì´ìŠ¤ ë…ë¦½ì„± í•„ìš”
- ì˜ˆ: ê´€ë¦¬ì í˜ì´ì§€, ì¼ë°˜ì ì¸ ì›¹ ì„œë¹„ìŠ¤

**JDBC/MyBatis ì„ íƒí•˜ëŠ” ê²½ìš°**:
- ë³µì¡í•œ í†µê³„ ì¿¼ë¦¬ ë§ìŒ
- ì„±ëŠ¥ ìµœì í™”ê°€ ì¤‘ìš”
- SQL ì§ì ‘ ì œì–´ í•„ìš”
- ë ˆê±°ì‹œ DB ìŠ¤í‚¤ë§ˆ ì‚¬ìš©
- ì˜ˆ: ë¦¬í¬íŒ… ì‹œìŠ¤í…œ, ë°°ì¹˜ ì²˜ë¦¬, ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬

**í•˜ì´ë¸Œë¦¬ë“œ ì ‘ê·¼** (ê¶Œì¥):
```java
@Service
public class OrderService {
    private final OrderRepository orderRepository;  // JPA: ì¼ë°˜ CRUD
    private final OrderStatisticsMapper statisticsMapper;  // MyBatis: ë³µì¡í•œ í†µê³„

    @Transactional
    public Order createOrder(OrderRequest request) {
        return orderRepository.save(new Order(request));  // JPA
    }

    public SalesReport getDailySalesReport(LocalDate date) {
        return statisticsMapper.getDailySalesStatistics(date);  // MyBatis
    }
}
```

---

### Q2: Connection Pool í¬ê¸°ëŠ” ì–´ë–»ê²Œ ì„¤ì •í•´ì•¼ í•˜ë‚˜ìš”?

**A**: ê³µì‹ê³¼ ëª¨ë‹ˆí„°ë§ì„ í†µí•´ ê²°ì •í•©ë‹ˆë‹¤.

**HikariCP ê¶Œì¥ ê³µì‹**:
```
ìµœì  Connection Pool í¬ê¸° = (CPU ì½”ì–´ ìˆ˜ Ã— 2) + ë””ìŠ¤í¬ ìˆ˜
```

**ì˜ˆì‹œ**:
```yaml
spring:
  datasource:
    hikari:
      # 4ì½”ì–´ CPU, SSD 1ê°œ â†’ (4 Ã— 2) + 1 = 9
      maximum-pool-size: 10
      minimum-idle: 5
```

**ì‹¤ë¬´ ê°€ì´ë“œ**:

1. **ì´ˆê¸° ì„¤ì •**: 10-20ê°œë¡œ ì‹œì‘
2. **ëª¨ë‹ˆí„°ë§ ì§€í‘œ**:
   - Connection ëŒ€ê¸° ì‹œê°„ (`hikaricp.connections.pending`)
   - í™œì„± Connection ìˆ˜ (`hikaricp.connections.active`)
   - Connection timeout ë°œìƒ íšŸìˆ˜
3. **íŠœë‹**:
   - Connection ë¶€ì¡± ì‹œ â†’ `maximum-pool-size` ì¦ê°€
   - Connection ë‚¨ì„ ì‹œ â†’ ê°ì†Œ (ë¦¬ì†ŒìŠ¤ ì ˆì•½)

**ì£¼ì˜ì‚¬í•­**:
```
âŒ Poolì„ ë„ˆë¬´ í¬ê²Œ ì„¤ì •í•˜ë©´:
   - ë°ì´í„°ë² ì´ìŠ¤ ë¶€í•˜ ì¦ê°€
   - ë©”ëª¨ë¦¬ ë‚­ë¹„
   - Context Switching ì¦ê°€

âœ… ì ì ˆí•œ í¬ê¸°:
   - ì‹¤ì œ ë™ì‹œ ìš”ì²­ ìˆ˜ì— ë§ì¶¤
   - DB ì„œë²„ Connection limit ê³ ë ¤
   - ëª¨ë‹ˆí„°ë§ í›„ ì¡°ì •
```

---

### Q3: @Transactionalì˜ readOnly ì˜µì…˜ì€ ì™œ ì‚¬ìš©í•˜ë‚˜ìš”?

**A**: ì„±ëŠ¥ ìµœì í™”ì™€ ë°ì´í„° ì•ˆì •ì„±ì„ ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤.

**readOnly = true íš¨ê³¼**:

1. **ì„±ëŠ¥ ìµœì í™”**:
```java
@Transactional(readOnly = true)
public List<User> getAllUsers() {
    return userRepository.findAll();
}
```
- Dirty Checking (ë³€ê²½ ê°ì§€) ë¹„í™œì„±í™”
- Flush ëª¨ë“œ ìµœì í™”
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ê°ì†Œ

2. **Read/Write Splitting**:
```java
@Transactional(readOnly = true)
public User getUser(Long id) {
    // Slave DBë¡œ ìë™ ë¼ìš°íŒ…
    return userRepository.findById(id).orElseThrow();
}

@Transactional
public User createUser(User user) {
    // Master DBë¡œ ìë™ ë¼ìš°íŒ…
    return userRepository.save(user);
}
```

3. **ë°ì´í„° ë¬´ê²°ì„±**:
```java
@Transactional(readOnly = true)
public User getUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();
    user.setName("ë³€ê²½");  // âŒ readOnlyì´ë¯€ë¡œ DBì— ë°˜ì˜ ì•ˆ ë¨ (ì•ˆì „)
    return user;
}
```

**ì‚¬ìš© ê°€ì´ë“œ**:
```
âœ… readOnly = true ì‚¬ìš©:
   - ì¡°íšŒ ì „ìš© ë©”ì„œë“œ
   - í†µê³„, ë¦¬í¬íŒ…
   - ê²€ìƒ‰ ê¸°ëŠ¥

âŒ readOnly ì‚¬ìš©í•˜ì§€ ì•ŠìŒ:
   - ìƒì„±, ìˆ˜ì •, ì‚­ì œ ì‘ì—…
   - ìƒíƒœ ë³€ê²½ì´ í•„ìš”í•œ ê²½ìš°
```

---

### Q4: N+1 ë¬¸ì œëŠ” ì–´ë–»ê²Œ í•´ê²°í•˜ë‚˜ìš”?

**A**: Fetch Join, EntityGraph, Batch Size ë“±ìœ¼ë¡œ í•´ê²°í•©ë‹ˆë‹¤.

**ë¬¸ì œ ìƒí™©**:
```java
// N+1 ì¿¼ë¦¬ ë°œìƒ!
List<User> users = userRepository.findAll();  // 1ë²ˆ ì¿¼ë¦¬
for (User user : users) {
    user.getOrders().size();  // Në²ˆ ì¿¼ë¦¬ (ê° ì‚¬ìš©ìë§ˆë‹¤)
}
```

**í•´ê²°ì±… 1: Fetch Join**:
```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllWithOrders();

// 1ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ
List<User> users = userRepository.findAllWithOrders();
```

**í•´ê²°ì±… 2: @EntityGraph**:
```java
@EntityGraph(attributePaths = "orders")
List<User> findAll();

// Fetch Joinê³¼ ë™ì¼í•œ íš¨ê³¼
```

**í•´ê²°ì±… 3: Batch Fetch Size**:
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```
```java
List<User> users = userRepository.findAll();  // 1ë²ˆ
// Ordersë¥¼ IN ì ˆë¡œ í•œ ë²ˆì— ì¡°íšŒ (100ê°œì”©)
// SELECT * FROM orders WHERE user_id IN (1,2,3,...,100)
```

**í•´ê²°ì±… 4: DTO í”„ë¡œì ì…˜**:
```java
@Query("SELECT new com.example.dto.UserOrderDTO(u.id, u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o " +
       "GROUP BY u.id, u.name")
List<UserOrderDTO> findAllWithOrderCount();
```

**ì„ íƒ ê°€ì´ë“œ**:
```
Fetch Join: ì—°ê´€ ì—”í‹°í‹° ì „ì²´ í•„ìš”
EntityGraph: Annotationìœ¼ë¡œ ê°„ë‹¨íˆ ì„¤ì •
Batch Size: ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì„¤ì •
DTO í”„ë¡œì ì…˜: íŠ¹ì • í•„ë“œë§Œ í•„ìš”í•  ë•Œ
```

---

### Q5: LazyInitializationExceptionì€ ì™œ ë°œìƒí•˜ë‚˜ìš”?

**A**: íŠ¸ëœì­ì…˜ì´ ì¢…ë£Œëœ í›„ Lazy Loadingì„ ì‹œë„í•´ì„œ ë°œìƒí•©ë‹ˆë‹¤.

**ë°œìƒ ì›ì¸**:
```java
@Service
public class UserService {

    @Transactional
    public User getUser(Long id) {
        return userRepository.findById(id).orElseThrow();
        // ë©”ì„œë“œ ì¢…ë£Œ â†’ íŠ¸ëœì­ì…˜ ì¢…ë£Œ â†’ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì¢…ë£Œ
    }
}

@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        User user = userService.getUser(id);

        // âŒ ì—¬ê¸°ì„œ Lazy Loading ì‹œë„ â†’ ì˜ˆì™¸ ë°œìƒ!
        return new UserDTO(user, user.getOrders());
    }
}
```

**í•´ê²°ì±… 1: Serviceì—ì„œ DTO ë³€í™˜** (ê¶Œì¥):
```java
@Service
public class UserService {

    @Transactional(readOnly = true)
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();

        // íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ DTO ë³€í™˜
        return new UserDTO(user, user.getOrders());
    }
}
```

**í•´ê²°ì±… 2: Fetch Join**:
```java
@Query("SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.id = :id")
Optional<User> findByIdWithOrders(@Param("id") Long id);
```

**í•´ê²°ì±… 3: OSIV (ê¶Œì¥í•˜ì§€ ì•ŠìŒ)**:
```yaml
spring:
  jpa:
    open-in-view: true  # ê¸°ë³¸ê°’, ì„±ëŠ¥ ë¬¸ì œ ê°€ëŠ¥
```

**ê¶Œì¥ íŒ¨í„´**:
```
1. Serviceì—ì„œ í•„ìš”í•œ ë°ì´í„° ëª¨ë‘ ë¡œë“œ
2. DTOë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜
3. ControllerëŠ” DTOë§Œ ì‚¬ìš©
```

---

### Q6: ë™ì‹œì„± ë¬¸ì œëŠ” ì–´ë–»ê²Œ í•´ê²°í•˜ë‚˜ìš”?

**A**: ë‚™ê´€ì  ë½, ë¹„ê´€ì  ë½, ë¶„ì‚° ë½ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

**ë¬¸ì œ ìƒí™©**:
```java
// ë™ì‹œì— ë‘ ì‚¬ìš©ìê°€ ê°™ì€ ìƒí’ˆ ì£¼ë¬¸
// ì¬ê³ : 1ê°œ
User A: ì¬ê³  í™•ì¸ (1ê°œ) â†’ ì£¼ë¬¸ â†’ ì¬ê³  ì°¨ê°
User B: ì¬ê³  í™•ì¸ (1ê°œ) â†’ ì£¼ë¬¸ â†’ ì¬ê³  ì°¨ê°
// ê²°ê³¼: ì¬ê³  -1ê°œ (ì˜¤ë¥˜!)
```

**í•´ê²°ì±… 1: ë¹„ê´€ì  ë½** (Pessimistic Lock):
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithLock(@Param("id") Long id);

@Transactional
public Order createOrder(Long productId, int quantity) {
    // DB ë ˆë²¨ì—ì„œ ë½ íšë“ (ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì€ ëŒ€ê¸°)
    Product product = productRepository.findByIdWithLock(productId)
        .orElseThrow();

    product.decreaseStock(quantity);
    // ...
}
```

**í•´ê²°ì±… 2: ë‚™ê´€ì  ë½** (Optimistic Lock):
```java
@Entity
public class Product {
    @Id
    private Long id;

    @Version
    private Long version;  // ë²„ì „ ê´€ë¦¬

    private Integer stockQuantity;
}

@Transactional
public Order createOrder(Long productId, int quantity) {
    Product product = productRepository.findById(productId).orElseThrow();
    product.decreaseStock(quantity);

    // ì €ì¥ ì‹œ version ì²´í¬
    // ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ë³€ê²½í–ˆìœ¼ë©´ OptimisticLockException ë°œìƒ
    productRepository.save(product);
}
```

**í•´ê²°ì±… 3: ë¶„ì‚° ë½** (Redis):
```java
@Transactional
public Order createOrder(Long productId, int quantity) {
    String lockKey = "product:" + productId;

    try (RLock lock = redissonClient.getLock(lockKey)) {
        boolean acquired = lock.tryLock(10, 3, TimeUnit.SECONDS);

        if (!acquired) {
            throw new LockAcquisitionException("ë½ íšë“ ì‹¤íŒ¨");
        }

        Product product = productRepository.findById(productId).orElseThrow();
        product.decreaseStock(quantity);
        // ...
    }
}
```

**ì„ íƒ ê°€ì´ë“œ**:
```
ë¹„ê´€ì  ë½: ì¶©ëŒ ë§ì„ ë•Œ, ë‹¨ì¼ DB
ë‚™ê´€ì  ë½: ì¶©ëŒ ì ì„ ë•Œ, ì¬ì‹œë„ ê°€ëŠ¥
ë¶„ì‚° ë½: ë©€í‹° ì„œë²„ í™˜ê²½, ë³µì¡í•œ ë¡œì§
```

---

### Q7: íŠ¸ëœì­ì…˜ ì „íŒŒ(Propagation)ëŠ” ì–´ë–»ê²Œ ë™ì‘í•˜ë‚˜ìš”?

**A**: ë©”ì„œë“œ ê°„ íŠ¸ëœì­ì…˜ ê²½ê³„ë¥¼ ì–´ë–»ê²Œ ì„¤ì •í• ì§€ ê²°ì •í•©ë‹ˆë‹¤.

**REQUIRED (ê¸°ë³¸ê°’)**:
```java
@Service
public class UserService {
    @Autowired
    private PointService pointService;

    @Transactional  // Propagation.REQUIRED (ê¸°ë³¸ê°’)
    public void registerUser(User user) {
        userRepository.save(user);

        // ê°™ì€ íŠ¸ëœì­ì…˜ ì°¸ì—¬
        pointService.giveWelcomePoints(user.getId());

        // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨í•˜ë©´ ë‘˜ ë‹¤ ë¡¤ë°±
    }
}

@Service
public class PointService {
    @Transactional
    public void giveWelcomePoints(Long userId) {
        // registerUserì˜ íŠ¸ëœì­ì…˜ì— ì°¸ì—¬
        // ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ ìƒì„± ì•ˆ í•¨
    }
}
```

**REQUIRES_NEW**:
```java
@Service
public class UserService {
    @Autowired
    private LogService logService;

    @Transactional
    public void registerUser(User user) {
        userRepository.save(user);

        // ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë¡œê·¸ ì €ì¥
        logService.saveLog("User registered: " + user.getId());

        // ì‚¬ìš©ì ë“±ë¡ ì‹¤íŒ¨í•´ë„ ë¡œê·¸ëŠ” ì €ì¥ë¨
    }
}

@Service
public class LogService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveLog(String message) {
        // í•­ìƒ ìƒˆë¡œìš´ íŠ¸ëœì­ì…˜ ìƒì„±
        // ë¶€ëª¨ íŠ¸ëœì­ì…˜ê³¼ ë…ë¦½ì 
    }
}
```

**MANDATORY**:
```java
@Transactional(propagation = Propagation.MANDATORY)
public void updatePoints(Long userId, int points) {
    // ë°˜ë“œì‹œ ê¸°ì¡´ íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ í˜¸ì¶œë˜ì–´ì•¼ í•¨
    // íŠ¸ëœì­ì…˜ ì—†ì´ í˜¸ì¶œí•˜ë©´ ì˜ˆì™¸ ë°œìƒ
}
```

**ì‚¬ìš© ì˜ˆì‹œ**:
```
REQUIRED: ì¼ë°˜ì ì¸ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (ê¸°ë³¸ê°’)
REQUIRES_NEW: ë¡œê·¸, ê°ì‚¬ ê¸°ë¡ (ë…ë¦½ì  ì €ì¥)
MANDATORY: ë°˜ë“œì‹œ íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ í˜¸ì¶œë˜ì–´ì•¼ í•˜ëŠ” ë©”ì„œë“œ
SUPPORTS: íŠ¸ëœì­ì…˜ ìˆìœ¼ë©´ ì°¸ì—¬, ì—†ìœ¼ë©´ ì—†ì´ ì‹¤í–‰
NOT_SUPPORTED: íŠ¸ëœì­ì…˜ ì—†ì´ ì‹¤í–‰
```

---

## ğŸ“ ë©´ì ‘ ì§ˆë¬¸

### ì£¼ë‹ˆì–´ ë ˆë²¨ (5-7ê°œ)

1. **JDBCì™€ JPAì˜ ì°¨ì´ì ì„ ì„¤ëª…í•˜ê³ , ê°ê° ì–´ë–¤ ìƒí™©ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì„ê¹Œìš”?**

2. **Springì—ì„œ DataSourceë€ ë¬´ì—‡ì´ë©°, Connection Poolì€ ì™œ í•„ìš”í•œê°€ìš”?**

3. **@Transactional ì–´ë…¸í…Œì´ì…˜ì˜ ì—­í• ì€ ë¬´ì—‡ì´ê³ , ì–´ë–¤ ì›ë¦¬ë¡œ ë™ì‘í•˜ë‚˜ìš”?**

4. **JPAì—ì„œ N+1 ë¬¸ì œê°€ ë¬´ì—‡ì¸ì§€ ì„¤ëª…í•˜ê³ , í•´ê²° ë°©ë²•ì„ ì œì‹œí•´ì£¼ì„¸ìš”.**

5. **LazyInitializationExceptionì€ ì™œ ë°œìƒí•˜ë©°, ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆë‚˜ìš”?**

6. **@Transactionalì—ì„œ readOnly = true ì˜µì…˜ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€ìš”?**

7. **Checked Exceptionê³¼ Unchecked Exception ì¤‘ ì–´ë–¤ ì˜ˆì™¸ê°€ íŠ¸ëœì­ì…˜ ë¡¤ë°±ì„ ë°œìƒì‹œí‚¤ë‚˜ìš”?**

---

### ì¤‘ê¸‰ ë ˆë²¨ (3-5ê°œ)

1. **ë‚™ê´€ì  ë½(Optimistic Lock)ê³¼ ë¹„ê´€ì  ë½(Pessimistic Lock)ì˜ ì°¨ì´ì ì„ ì„¤ëª…í•˜ê³ , ê°ê°ì˜ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì œì‹œí•´ì£¼ì„¸ìš”.**

2. **íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€(Isolation Level)ì˜ ì¢…ë¥˜ì™€ ê° ìˆ˜ì¤€ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œ(Dirty Read, Non-Repeatable Read, Phantom Read)ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

3. **JPAì˜ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸(Persistence Context)ëŠ” ë¬´ì—‡ì´ë©°, 1ì°¨ ìºì‹œì™€ Dirty Checkingì˜ ë™ì‘ ì›ë¦¬ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

4. **ëŒ€ìš©ëŸ‰ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ JPAë¥¼ ì‚¬ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•ì„ ì œì‹œí•´ì£¼ì„¸ìš”.**

5. **ë©€í‹° DataSource í™˜ê²½ì—ì„œ ì½ê¸°/ì“°ê¸° ë¶„ë¦¬(Read/Write Splitting)ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

---

## ğŸ’¡ ë©´ì ‘ ì§ˆë¬¸ ë‹µì•ˆ

### ì£¼ë‹ˆì–´ ë ˆë²¨ ë‹µì•ˆ

**Q1: JDBCì™€ JPAì˜ ì°¨ì´ì ì„ ì„¤ëª…í•˜ê³ , ê°ê° ì–´ë–¤ ìƒí™©ì—ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì„ê¹Œìš”?**

**A**:

**ì°¨ì´ì **:
- **JDBC**:
  - Low-level APIë¡œ SQLì„ ì§ì ‘ ì‘ì„±í•˜ê³  ì‹¤í–‰
  - ResultSetì„ ìˆ˜ë™ìœ¼ë¡œ ê°ì²´ë¡œ ë§¤í•‘
  - ëª¨ë“  ë¦¬ì†ŒìŠ¤(Connection, Statement, ResultSet)ë¥¼ ìˆ˜ë™ ê´€ë¦¬
  - ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ì½”ë“œê°€ ë§ìŒ

- **JPA**:
  - High-level ORM ê¸°ìˆ ë¡œ ê°ì²´ ì¤‘ì‹¬ ê°œë°œ
  - SQLì„ ìë™ ìƒì„± (ëŒ€ë¶€ë¶„ì˜ ê²½ìš°)
  - ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ê°€ ìë™ìœ¼ë¡œ ê°ì²´ ê´€ë¦¬
  - ìƒì‚°ì„±ì´ ë†’ê³  ì½”ë“œê°€ ê°„ê²°

**ì‚¬ìš© ìƒí™©**:
```
JDBC ì‚¬ìš©:
âœ… ë³µì¡í•œ í†µê³„ ì¿¼ë¦¬ (GROUP BY, ë³µì¡í•œ JOIN)
âœ… ì„±ëŠ¥ ìµœì í™”ê°€ ë§¤ìš° ì¤‘ìš”
âœ… ë ˆê±°ì‹œ DB ìŠ¤í‚¤ë§ˆ
âœ… ë°°ì¹˜ ì²˜ë¦¬ (ëŒ€ìš©ëŸ‰ ë°ì´í„°)

JPA ì‚¬ìš©:
âœ… ì¼ë°˜ì ì¸ CRUD ì• í”Œë¦¬ì¼€ì´ì…˜
âœ… ë¹ ë¥¸ ê°œë°œ ì†ë„ í•„ìš”
âœ… ë„ë©”ì¸ ëª¨ë¸ ì¤‘ì‹¬ ì„¤ê³„
âœ… ë°ì´í„°ë² ì´ìŠ¤ ë…ë¦½ì„±
```

**ì‹¤ë¬´ ì˜ˆì‹œ**:
```java
// ì¼ë°˜ CRUD â†’ JPA
@Service
public class UserService {
    public User createUser(User user) {
        return userRepository.save(user);  // ê°„ë‹¨!
    }
}

// ë³µì¡í•œ í†µê³„ â†’ JDBC/MyBatis
@Mapper
public interface SalesMapper {
    @Select("""
        SELECT r.name, DATE(o.created_at) as date,
               SUM(o.total_amount) as sales
        FROM orders o JOIN restaurants r ON o.restaurant_id = r.id
        WHERE o.created_at >= #{startDate}
        GROUP BY r.id, DATE(o.created_at)
        ORDER BY sales DESC
    """)
    List<DailySales> getDailySales(@Param("startDate") LocalDate startDate);
}
```

---

**Q2: Springì—ì„œ DataSourceë€ ë¬´ì—‡ì´ë©°, Connection Poolì€ ì™œ í•„ìš”í•œê°€ìš”?**

**A**:

**DataSource**:
- ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì •ë³´ë¥¼ ê´€ë¦¬í•˜ëŠ” ê°ì²´
- JDBC Connectionì„ ìƒì„±í•˜ëŠ” íŒ©í† ë¦¬
- Springì—ì„œëŠ” `javax.sql.DataSource` ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©

**Connection Pool**:
ë§¤ë²ˆ ìƒˆë¡œìš´ Connectionì„ ìƒì„±í•˜ëŠ” ëŒ€ì‹ , ë¯¸ë¦¬ ìƒì„±í•´ë‘” Connectionì„ ì¬ì‚¬ìš©í•˜ëŠ” ê¸°ìˆ 

**í•„ìš”í•œ ì´ìœ **:
```
âŒ Connection Pool ì—†ì´:
ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œìš´ Connection ìƒì„±
â†’ DB ì—°ê²° ì‹œê°„ ~100ms
â†’ 100 req/s â†’ 10ì´ˆ ì†Œìš”
â†’ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„

âœ… Connection Pool ì‚¬ìš©:
ë¯¸ë¦¬ ìƒì„±ëœ Connection ì¬ì‚¬ìš©
â†’ Poolì—ì„œ ê°€ì ¸ì˜¤ëŠ” ì‹œê°„ ~1ms
â†’ 100 req/s â†’ 0.1ì´ˆ ì†Œìš”
â†’ 100ë°° ë¹ ë¦„!
```

**ì‹¤ë¬´ ì„¤ì •**:
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
    password: password
    hikari:
      maximum-pool-size: 20      # ìµœëŒ€ Connection ìˆ˜
      minimum-idle: 5            # ìµœì†Œ ìœ íœ´ Connection
      connection-timeout: 30000  # ì—°ê²° ëŒ€ê¸° ì‹œê°„ (30ì´ˆ)
      max-lifetime: 1800000      # Connection ìµœëŒ€ ìˆ˜ëª… (30ë¶„)
```

**ë™ì‘ ì›ë¦¬**:
```
1. ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ Connection Pool ìƒì„±
   â†’ minimum-idleë§Œí¼ Connection ë¯¸ë¦¬ ìƒì„±

2. ìš”ì²­ ì²˜ë¦¬:
   - Connection í•„ìš” â†’ Poolì—ì„œ ê°€ì ¸ì˜´ (ë¹ ë¦„)
   - ì‘ì—… ì™„ë£Œ â†’ Connectionì„ Poolì— ë°˜í™˜ (ì¬ì‚¬ìš©)

3. Poolì´ ê°€ë“ ì°¬ ê²½ìš°:
   - connection-timeoutë§Œí¼ ëŒ€ê¸°
   - ì‹œê°„ ì´ˆê³¼ â†’ SQLException
```

---

**Q3: @Transactional ì–´ë…¸í…Œì´ì…˜ì˜ ì—­í• ì€ ë¬´ì—‡ì´ê³ , ì–´ë–¤ ì›ë¦¬ë¡œ ë™ì‘í•˜ë‚˜ìš”?**

**A**:

**ì—­í• **:
ë°ì´í„°ë² ì´ìŠ¤ íŠ¸ëœì­ì…˜ì„ ì„ ì–¸ì ìœ¼ë¡œ ê´€ë¦¬í•˜ì—¬ ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´ì¥

**í•µì‹¬ ê¸°ëŠ¥**:
1. **ì›ìì„±(Atomicity)**: ëª¨ë‘ ì„±ê³µ ë˜ëŠ” ëª¨ë‘ ì‹¤íŒ¨
2. **ì¼ê´€ì„±(Consistency)**: ë°ì´í„° ë¬´ê²°ì„± ìœ ì§€
3. **ê²©ë¦¬ì„±(Isolation)**: ë™ì‹œ íŠ¸ëœì­ì…˜ ê°„ ê°„ì„­ ë°©ì§€
4. **ì§€ì†ì„±(Durability)**: ì»¤ë°‹ëœ ë°ì´í„°ëŠ” ì˜êµ¬ ë³´ì¡´

**ë™ì‘ ì›ë¦¬**:
```
1. Spring AOP í”„ë¡ì‹œ ìƒì„±
   â†’ UserServiceì˜ í”„ë¡ì‹œ ê°ì²´ ìƒì„±

2. ë©”ì„œë“œ í˜¸ì¶œ ì‹œ:
   â‘  í”„ë¡ì‹œê°€ íŠ¸ëœì­ì…˜ ì‹œì‘ (TransactionManager.begin())
   â‘¡ ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
   â‘¢ ì„±ê³µí•˜ë©´ COMMIT
   â‘£ ì˜ˆì™¸ ë°œìƒí•˜ë©´ ROLLBACK
```

**ì½”ë“œ ì˜ˆì‹œ**:
```java
@Service
public class OrderService {

    @Transactional  // â† íŠ¸ëœì­ì…˜ ê²½ê³„ ì„¤ì •
    public Order createOrder(OrderRequest request) {
        // 1. ì£¼ë¬¸ ìƒì„±
        Order order = new Order(request);
        orderRepository.save(order);

        // 2. ì¬ê³  ì°¨ê°
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow();
        product.decreaseStock(request.getQuantity());

        // 3. í¬ì¸íŠ¸ ì°¨ê°
        Point point = pointRepository.findByUserId(request.getUserId())
            .orElseThrow();
        point.use(request.getUsePoints());

        // ëª¨ë‘ ì„±ê³µ â†’ COMMIT
        // í•˜ë‚˜ë¼ë„ ì‹¤íŒ¨ â†’ ROLLBACK (ìë™)

        return order;
    }
}
```

**ë‚´ë¶€ ë™ì‘**:
```java
// Spring AOPê°€ ìƒì„±í•œ í”„ë¡ì‹œ (ê°œë…ì  ì½”ë“œ)
public class OrderServiceProxy extends OrderService {

    private TransactionManager txManager;
    private OrderService target;

    @Override
    public Order createOrder(OrderRequest request) {
        TransactionStatus status = txManager.getTransaction();

        try {
            // ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
            Order order = target.createOrder(request);

            // ì„±ê³µ â†’ COMMIT
            txManager.commit(status);

            return order;
        } catch (RuntimeException e) {
            // ì‹¤íŒ¨ â†’ ROLLBACK
            txManager.rollback(status);
            throw e;
        }
    }
}
```

**ì£¼ì˜ì‚¬í•­**:
```java
// âŒ ê°™ì€ í´ë˜ìŠ¤ ë‚´ë¶€ í˜¸ì¶œì€ íŠ¸ëœì­ì…˜ ì ìš© ì•ˆ ë¨
@Service
public class UserService {

    public void registerUser(User user) {
        this.saveUser(user);  // âŒ í”„ë¡ì‹œë¥¼ ê±°ì¹˜ì§€ ì•ŠìŒ!
    }

    @Transactional
    private void saveUser(User user) {
        // íŠ¸ëœì­ì…˜ ì ìš© ì•ˆ ë¨
    }
}

// âœ… ì™¸ë¶€ì—ì„œ í˜¸ì¶œí•´ì•¼ í”„ë¡ì‹œ ì‘ë™
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void registerUser(User user) {
        userRepository.save(user);  // âœ… íŠ¸ëœì­ì…˜ ì ìš©ë¨
    }
}
```

---

**Q4: JPAì—ì„œ N+1 ë¬¸ì œê°€ ë¬´ì—‡ì¸ì§€ ì„¤ëª…í•˜ê³ , í•´ê²° ë°©ë²•ì„ ì œì‹œí•´ì£¼ì„¸ìš”.**

**A**:

**N+1 ë¬¸ì œë€**:
ì—°ê´€ëœ ì—”í‹°í‹°ë¥¼ ì¡°íšŒí•  ë•Œ ì¶”ê°€ ì¿¼ë¦¬ê°€ Në²ˆ ë” ì‹¤í–‰ë˜ëŠ” ë¬¸ì œ

**ë°œìƒ ìƒí™©**:
```java
@Entity
public class User {
    @Id
    private Long id;

    @OneToMany(mappedBy = "user")
    private List<Order> orders;  // Lazy Loading
}

// ì„œë¹„ìŠ¤ ì½”ë“œ
List<User> users = userRepository.findAll();  // 1ë²ˆ ì¿¼ë¦¬

for (User user : users) {
    int orderCount = user.getOrders().size();  // Në²ˆ ì¿¼ë¦¬!
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆ: ëª¨ë“  ì‚¬ìš©ì ì¡°íšŒ
SELECT * FROM users;  -- ê²°ê³¼: 100ëª…

-- Në²ˆ: ê° ì‚¬ìš©ìì˜ ì£¼ë¬¸ ì¡°íšŒ
SELECT * FROM orders WHERE user_id = 1;
SELECT * FROM orders WHERE user_id = 2;
...
SELECT * FROM orders WHERE user_id = 100;

-- ì´ 101ë²ˆ ì¿¼ë¦¬ ì‹¤í–‰! (1 + N)
```

**ì„±ëŠ¥ ì˜í–¥**:
```
100ëª…ì˜ ì‚¬ìš©ì ì¡°íšŒ:
- ì¿¼ë¦¬ íšŸìˆ˜: 101ë²ˆ
- ì‘ë‹µ ì‹œê°„: ~1ì´ˆ (ê° ì¿¼ë¦¬ 10ms)

1000ëª…ì˜ ì‚¬ìš©ì ì¡°íšŒ:
- ì¿¼ë¦¬ íšŸìˆ˜: 1001ë²ˆ
- ì‘ë‹µ ì‹œê°„: ~10ì´ˆ
â†’ ì‚¬ìš©ì ê²½í—˜ ì•…í™”!
```

**í•´ê²°ì±… 1: Fetch Join**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u JOIN FETCH u.orders")
    List<User> findAllWithOrders();
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëª¨ë“  ë°ì´í„° ì¡°íšŒ
SELECT u.*, o.*
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

**í•´ê²°ì±… 2: @EntityGraph**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @EntityGraph(attributePaths = "orders")
    List<User> findAll();
}
```

**í•´ê²°ì±… 3: Batch Fetch Size**:
```yaml
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆ: ì‚¬ìš©ì ì¡°íšŒ
SELECT * FROM users;

-- 1ë²ˆ: Ordersë¥¼ IN ì ˆë¡œ í•œ ë²ˆì— ì¡°íšŒ
SELECT * FROM orders WHERE user_id IN (1, 2, 3, ..., 100);

-- 101ë²ˆ â†’ 2ë²ˆìœ¼ë¡œ ê°ì†Œ!
```

**í•´ê²°ì±… 4: DTO í”„ë¡œì ì…˜**:
```java
@Query("SELECT new com.example.dto.UserOrderCountDTO(u.id, u.name, COUNT(o)) " +
       "FROM User u LEFT JOIN u.orders o " +
       "GROUP BY u.id, u.name")
List<UserOrderCountDTO> findAllWithOrderCount();
```

**ì„ íƒ ê¸°ì¤€**:
```
Fetch Join: ì—°ê´€ ì—”í‹°í‹° ì „ì²´ ë°ì´í„° í•„ìš”
EntityGraph: Annotation ë°©ì‹ ì„ í˜¸
Batch Size: ì• í”Œë¦¬ì¼€ì´ì…˜ ì „ì—­ ì ìš©
DTO í”„ë¡œì ì…˜: íŠ¹ì • í•„ë“œë§Œ í•„ìš”
```

---

**Q5: LazyInitializationExceptionì€ ì™œ ë°œìƒí•˜ë©°, ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆë‚˜ìš”?**

**A**:

**ë°œìƒ ì›ì¸**:
íŠ¸ëœì­ì…˜(ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸)ì´ ì¢…ë£Œëœ í›„ Lazy Loadingì„ ì‹œë„í•  ë•Œ ë°œìƒ

**êµ¬ì²´ì  ìƒí™©**:
```java
@Service
public class UserService {

    @Transactional
    public User getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();
        return user;
        // â† ë©”ì„œë“œ ì¢…ë£Œ
        // â†’ @Transactional ì¢…ë£Œ
        // â†’ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸(Session) ì¢…ë£Œ
    }
}

@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        User user = userService.getUser(id);

        // âŒ ì—¬ê¸°ì„œ orders ì ‘ê·¼ ì‹œ ì˜ˆì™¸ ë°œìƒ!
        // â†’ ì´ë¯¸ Sessionì´ ì—†ì–´ì„œ Lazy Loading ë¶ˆê°€ëŠ¥
        return new UserDTO(user, user.getOrders());
    }
}
```

**ì—ëŸ¬ ë©”ì‹œì§€**:
```
org.hibernate.LazyInitializationException:
failed to lazily initialize a collection of role: User.orders,
could not initialize proxy - no Session
```

**ì™œ ë°œìƒí•˜ëŠ”ê°€**:
```
1. Service ë©”ì„œë“œ ì¢…ë£Œ â†’ @Transactional ì¢…ë£Œ
2. ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸(Session) ì¢…ë£Œ
3. User ì—”í‹°í‹°ëŠ” Detached ìƒíƒœ
4. Controllerì—ì„œ user.getOrders() í˜¸ì¶œ
5. Lazy Loading ì‹œë„ â†’ Session ì—†ìŒ â†’ ì˜ˆì™¸!
```

**í•´ê²°ì±… 1: Serviceì—ì„œ DTO ë³€í™˜** (ê¶Œì¥):
```java
@Service
public class UserService {

    @Transactional(readOnly = true)
    public UserDTO getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();

        // âœ… íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ DTO ë³€í™˜
        // â†’ Lazy Loading ì •ìƒ ì‘ë™
        return new UserDTO(user, user.getOrders());
    }
}

@RestController
public class UserController {

    @GetMapping("/users/{id}")
    public UserDTO getUser(@PathVariable Long id) {
        return userService.getUser(id);  // ì´ë¯¸ DTO
    }
}
```

**í•´ê²°ì±… 2: Fetch Join**:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u LEFT JOIN FETCH u.orders WHERE u.id = :id")
    Optional<User> findByIdWithOrders(@Param("id") Long id);
}

@Service
public class UserService {

    public User getUser(Long id) {
        // âœ… Ordersê°€ ì´ë¯¸ ë¡œë“œë˜ì–´ ìˆìŒ
        return userRepository.findByIdWithOrders(id).orElseThrow();
    }
}
```

**í•´ê²°ì±… 3: Serviceì—ì„œ ëª…ì‹œì  ì´ˆê¸°í™”**:
```java
@Service
public class UserService {

    @Transactional(readOnly = true)
    public User getUser(Long id) {
        User user = userRepository.findById(id).orElseThrow();

        // âœ… íŠ¸ëœì­ì…˜ ì•ˆì—ì„œ ê°•ì œ ë¡œë“œ
        user.getOrders().size();

        return user;
    }
}
```

**í•´ê²°ì±… 4: OSIV í™œì„±í™”** (ê¶Œì¥í•˜ì§€ ì•ŠìŒ):
```yaml
spring:
  jpa:
    open-in-view: true  # View ë Œë”ë§ê¹Œì§€ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ìœ ì§€
```

**OSIV ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì´ìœ **:
```
âŒ OSIV (Open Session In View):
- DB Connectionì„ Viewê¹Œì§€ ìœ ì§€
- Connection Pool ê³ ê°ˆ ìœ„í—˜
- ì„±ëŠ¥ ì €í•˜
- ì˜ˆìƒì¹˜ ëª»í•œ ì¿¼ë¦¬ ë°œìƒ

âœ… ê¶Œì¥ íŒ¨í„´:
- Serviceì—ì„œ í•„ìš”í•œ ë°ì´í„° ëª¨ë‘ ë¡œë“œ
- DTOë¡œ ë³€í™˜í•˜ì—¬ ë°˜í™˜
- ControllerëŠ” DTOë§Œ ì‚¬ìš©
```

---

**Q6: @Transactionalì—ì„œ readOnly = true ì˜µì…˜ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¸ê°€ìš”?**

**A**:

**ì‚¬ìš© ì´ìœ **:
ì„±ëŠ¥ ìµœì í™”ì™€ ë°ì´í„° ì•ˆì •ì„±ì„ ìœ„í•´ ì¡°íšŒ ì „ìš© íŠ¸ëœì­ì…˜ì„ì„ ëª…ì‹œ

**íš¨ê³¼ 1: Dirty Checking ë¹„í™œì„±í™”**:
```java
@Transactional(readOnly = true)
public User getUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();

    // readOnly = trueì´ë¯€ë¡œ Dirty Checking ì•ˆ í•¨
    // â†’ ë³€ê²½ ê°ì§€ë¥¼ ìœ„í•œ ìŠ¤ëƒ…ìƒ· ìƒì„± ì•ˆ í•¨
    // â†’ ë©”ëª¨ë¦¬ ì ˆì•½

    return user;
}
```

**ì¼ë°˜ íŠ¸ëœì­ì…˜ì˜ Dirty Checking**:
```
1. ì—”í‹°í‹° ì¡°íšŒ ì‹œ ìŠ¤ëƒ…ìƒ· ìƒì„±
2. íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì „ ìŠ¤ëƒ…ìƒ·ê³¼ í˜„ì¬ ìƒíƒœ ë¹„êµ
3. ë³€ê²½ ì‚¬í•­ ìˆìœ¼ë©´ UPDATE ì¿¼ë¦¬ ì‹¤í–‰

readOnly = true:
1. ìŠ¤ëƒ…ìƒ· ìƒì„± ì•ˆ í•¨ â†’ ë©”ëª¨ë¦¬ ì ˆì•½
2. ë³€ê²½ ê°ì§€ ì•ˆ í•¨ â†’ CPU ì ˆì•½
```

**íš¨ê³¼ 2: Flush ëª¨ë“œ ìµœì í™”**:
```java
@Transactional(readOnly = true)
public List<User> searchUsers(String keyword) {
    // Flush ëª¨ë“œê°€ MANUALë¡œ ì„¤ì •ë¨
    // â†’ ë¶ˆí•„ìš”í•œ Flush ë°œìƒ ì•ˆ í•¨
    return userRepository.findByNameContaining(keyword);
}
```

**íš¨ê³¼ 3: Read/Write Splitting**:
```java
@Service
public class PaymentService {

    // âœ… readOnly = true â†’ Slave DBë¡œ ë¼ìš°íŒ…
    @Transactional(readOnly = true)
    public Payment getPayment(Long id) {
        return paymentRepository.findById(id).orElseThrow();
    }

    // âœ… readOnly = false (ê¸°ë³¸ê°’) â†’ Master DBë¡œ ë¼ìš°íŒ…
    @Transactional
    public Payment createPayment(PaymentRequest request) {
        return paymentRepository.save(new Payment(request));
    }
}
```

**DataSource ë¼ìš°íŒ… ì„¤ì •**:
```java
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        boolean isReadOnly = TransactionSynchronizationManager
            .isCurrentTransactionReadOnly();

        if (isReadOnly) {
            return DataSourceType.SLAVE;  // ì½ê¸° â†’ Slave
        } else {
            return DataSourceType.MASTER;  // ì“°ê¸° â†’ Master
        }
    }
}
```

**íš¨ê³¼ 4: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥**:
```java
@Transactional(readOnly = true)
public User getUser(Long id) {
    User user = userRepository.findById(id).orElseThrow();

    // ì‹¤ìˆ˜ë¡œ ìˆ˜ì •í•´ë„ DBì— ë°˜ì˜ ì•ˆ ë¨
    user.setName("ë³€ê²½");  // âŒ readOnlyì´ë¯€ë¡œ ë¬´ì‹œë¨

    return user;
}
```

**ì‚¬ìš© ê°€ì´ë“œ**:
```
âœ… readOnly = true ì‚¬ìš©:
- ì¡°íšŒ ì „ìš© ë©”ì„œë“œ (findById, findAll, search ë“±)
- í†µê³„, ë¦¬í¬íŒ…
- ëŒ€ì‹œë³´ë“œ, ê²€ìƒ‰ ê¸°ëŠ¥

âŒ readOnly ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (ê¸°ë³¸ê°’):
- ìƒì„±, ìˆ˜ì •, ì‚­ì œ ì‘ì—…
- ìƒíƒœ ë³€ê²½ì´ í•„ìš”í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
```

**ì„±ëŠ¥ ê°œì„  íš¨ê³¼**:
```
readOnly = false (ê¸°ë³¸):
- 100ëª… ì¡°íšŒ ì‹œ 100ê°œì˜ ìŠ¤ëƒ…ìƒ· ìƒì„±
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ~1MB
- Flush ì‹œê°„: ~50ms

readOnly = true:
- ìŠ¤ëƒ…ìƒ· ìƒì„± ì•ˆ í•¨
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ~100KB (90% ì ˆê°)
- Flush ìƒëµ: ~5ms (90% ê°œì„ )
```

---

**Q7: Checked Exceptionê³¼ Unchecked Exception ì¤‘ ì–´ë–¤ ì˜ˆì™¸ê°€ íŠ¸ëœì­ì…˜ ë¡¤ë°±ì„ ë°œìƒì‹œí‚¤ë‚˜ìš”?**

**A**:

**ê¸°ë³¸ ë™ì‘**:
- **Unchecked Exception (RuntimeException)**: ìë™ ë¡¤ë°± âœ…
- **Checked Exception (Exception)**: ë¡¤ë°± ì•ˆ ë¨ âŒ

**Unchecked Exception - ìë™ ë¡¤ë°±**:
```java
@Service
public class OrderService {

    @Transactional
    public Order createOrder(OrderRequest request) {
        Order order = new Order(request);
        orderRepository.save(order);

        // âœ… RuntimeException â†’ ìë™ ë¡¤ë°±
        throw new IllegalArgumentException("ì˜ëª»ëœ ìš”ì²­");

        // ê²°ê³¼: ì£¼ë¬¸ ì €ì¥ ì•ˆ ë¨ (ë¡¤ë°±)
    }
}
```

**Checked Exception - ë¡¤ë°± ì•ˆ ë¨**:
```java
@Service
public class OrderService {

    @Transactional
    public Order createOrder(OrderRequest request) throws Exception {
        Order order = new Order(request);
        orderRepository.save(order);

        // âŒ Checked Exception â†’ ë¡¤ë°± ì•ˆ ë¨!
        throw new Exception("ì—ëŸ¬ ë°œìƒ");

        // ê²°ê³¼: ì£¼ë¬¸ ì €ì¥ë¨! (ì»¤ë°‹)
    }
}
```

**ì´ìœ **:
```
Springì˜ ê¸°ë³¸ ì •ì±…:
- RuntimeException: í”„ë¡œê·¸ë˜ë° ì˜¤ë¥˜ â†’ ë¡¤ë°± í•„ìš”
- Checked Exception: ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ â†’ ì²˜ë¦¬ ê°€ëŠ¥ â†’ ë¡¤ë°± ë¶ˆí•„ìš”

ì˜ˆ:
RuntimeException:
  - NullPointerException (ë²„ê·¸)
  - IllegalArgumentException (ë²„ê·¸)
  â†’ ë°ì´í„° ì €ì¥í•˜ë©´ ì•ˆ ë¨

Checked Exception:
  - IOException (íŒŒì¼ ì—†ìŒ - ì²˜ë¦¬ ê°€ëŠ¥)
  - SQLException (ì¼ì‹œì  ì˜¤ë¥˜ - ì¬ì‹œë„ ê°€ëŠ¥)
  â†’ ì¼ë¶€ ë°ì´í„°ëŠ” ì €ì¥í•  ìˆ˜ ìˆìŒ
```

**Checked Exceptionë„ ë¡¤ë°±í•˜ë ¤ë©´**:
```java
// ë°©ë²• 1: rollbackFor ì†ì„± ì‚¬ìš©
@Transactional(rollbackFor = Exception.class)
public Order createOrder(OrderRequest request) throws Exception {
    orderRepository.save(new Order(request));
    throw new Exception("ì—ëŸ¬");  // âœ… ë¡¤ë°±ë¨
}

// ë°©ë²• 2: noRollbackForë¡œ ì œì™¸ (ë°˜ëŒ€)
@Transactional(noRollbackFor = IllegalArgumentException.class)
public Order createOrder(OrderRequest request) {
    orderRepository.save(new Order(request));
    throw new IllegalArgumentException("ì—ëŸ¬");  // âŒ ë¡¤ë°± ì•ˆ ë¨
}
```

**ì‹¤ë¬´ íŒ¨í„´**:
```java
// âœ… ê¶Œì¥: RuntimeException ìƒì†í•œ ì»¤ìŠ¤í…€ ì˜ˆì™¸ ì‚¬ìš©
public class InsufficientStockException extends RuntimeException {
    public InsufficientStockException(String message) {
        super(message);
    }
}

@Service
public class OrderService {

    @Transactional
    public Order createOrder(OrderRequest request) {
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow();

        if (product.getStockQuantity() < request.getQuantity()) {
            // âœ… RuntimeException â†’ ìë™ ë¡¤ë°±
            throw new InsufficientStockException("ì¬ê³  ë¶€ì¡±");
        }

        product.decreaseStock(request.getQuantity());
        return orderRepository.save(new Order(request));
    }
}
```

**ì •ë¦¬**:
```
Unchecked Exception (RuntimeException):
âœ… ìë™ ë¡¤ë°±
âœ… ì‹¤ë¬´ì—ì„œ ì£¼ë¡œ ì‚¬ìš©
âœ… ì˜ˆ: IllegalArgumentException, NullPointerException

Checked Exception (Exception):
âŒ ê¸°ë³¸ì ìœ¼ë¡œ ë¡¤ë°± ì•ˆ ë¨
âœ… rollbackFor ì†ì„±ìœ¼ë¡œ ë¡¤ë°± ê°€ëŠ¥
âŒ ì‹¤ë¬´ì—ì„œ ê¶Œì¥í•˜ì§€ ì•ŠìŒ

ê¶Œì¥ íŒ¨í„´:
â†’ RuntimeException ìƒì†í•œ ì»¤ìŠ¤í…€ ì˜ˆì™¸ ì‚¬ìš©
â†’ ë¹„ì¦ˆë‹ˆìŠ¤ ì˜ˆì™¸ë„ RuntimeExceptionìœ¼ë¡œ ì •ì˜
```

---

### ì¤‘ê¸‰ ë ˆë²¨ ë‹µì•ˆ

**Q1: ë‚™ê´€ì  ë½(Optimistic Lock)ê³¼ ë¹„ê´€ì  ë½(Pessimistic Lock)ì˜ ì°¨ì´ì ì„ ì„¤ëª…í•˜ê³ , ê°ê°ì˜ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì œì‹œí•´ì£¼ì„¸ìš”.**

**A**:

**ì°¨ì´ì **:

| êµ¬ë¶„ | ë‚™ê´€ì  ë½ | ë¹„ê´€ì  ë½ |
|-----|----------|----------|
| **ê°€ì •** | ì¶©ëŒì´ ê±°ì˜ ì—†ì„ ê²ƒ | ì¶©ëŒì´ ìì£¼ ë°œìƒí•  ê²ƒ |
| **ë½ ì‹œì ** | ì»¤ë°‹ ì‹œì  | ì¡°íšŒ ì‹œì  |
| **êµ¬í˜„** | Version ì»¬ëŸ¼ | DB ë½ (SELECT FOR UPDATE) |
| **ë™ì‹œì„±** | ë†’ìŒ | ë‚®ìŒ |
| **ì„±ëŠ¥** | ì½ê¸° ë§ì„ ë•Œ ìœ ë¦¬ | ì“°ê¸° ë§ì„ ë•Œ ìœ ë¦¬ |
| **ì‹¤íŒ¨ ì²˜ë¦¬** | ì¬ì‹œë„ í•„ìš” | ëŒ€ê¸° í›„ ì²˜ë¦¬ |

**ë‚™ê´€ì  ë½ (Optimistic Lock)**:

**êµ¬í˜„**:
```java
@Entity
public class Product {
    @Id
    private Long id;

    @Version  // â† ë‚™ê´€ì  ë½ í™œì„±í™”
    private Long version;

    private String name;
    private Integer stockQuantity;
}

@Service
public class ProductService {

    @Transactional
    public void decreaseStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId)
            .orElseThrow();

        product.decreaseStock(quantity);

        // ì €ì¥ ì‹œ version ì²´í¬
        // versionì´ ë‹¤ë¥´ë©´ OptimisticLockException ë°œìƒ
        productRepository.save(product);
    }
}
```

**ë™ì‘ ì›ë¦¬**:
```
ì‹œë‚˜ë¦¬ì˜¤: ë‘ ì‚¬ìš©ìê°€ ë™ì‹œì— ì¬ê³  ì°¨ê°

ì‚¬ìš©ì A:
1. Product ì¡°íšŒ (id=1, version=5, stock=10)
2. ì¬ê³  ì°¨ê° (stock=9)
3. ì €ì¥ ì‹œë„:
   UPDATE product
   SET stock=9, version=6
   WHERE id=1 AND version=5  â† ì„±ê³µ!

ì‚¬ìš©ì B:
1. Product ì¡°íšŒ (id=1, version=5, stock=10)
2. ì¬ê³  ì°¨ê° (stock=8)
3. ì €ì¥ ì‹œë„:
   UPDATE product
   SET stock=8, version=6
   WHERE id=1 AND version=5  â† ì‹¤íŒ¨! (Aê°€ versionì„ 6ìœ¼ë¡œ ë³€ê²½í•¨)
   â†’ OptimisticLockException ë°œìƒ
```

**ì¬ì‹œë„ ë¡œì§**:
```java
@Service
public class ProductService {

    private static final int MAX_RETRIES = 3;

    public void decreaseStockWithRetry(Long productId, int quantity) {
        int attempts = 0;

        while (attempts < MAX_RETRIES) {
            try {
                decreaseStock(productId, quantity);
                return;  // ì„±ê³µ
            } catch (OptimisticLockException e) {
                attempts++;
                if (attempts >= MAX_RETRIES) {
                    throw new StockUpdateFailedException("ì¬ê³  ì—…ë°ì´íŠ¸ ì‹¤íŒ¨");
                }
                // ì ì‹œ ëŒ€ê¸° í›„ ì¬ì‹œë„
                try {
                    Thread.sleep(100);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    @Transactional
    private void decreaseStock(Long productId, int quantity) {
        Product product = productRepository.findById(productId).orElseThrow();
        product.decreaseStock(quantity);
        productRepository.save(product);
    }
}
```

**ë¹„ê´€ì  ë½ (Pessimistic Lock)**:

**êµ¬í˜„**:
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT p FROM Product p WHERE p.id = :id")
    Optional<Product> findByIdWithLock(@Param("id") Long id);
}

@Service
public class ProductService {

    @Transactional
    public void decreaseStock(Long productId, int quantity) {
        // DB ë ˆë²¨ì—ì„œ ë½ íšë“ (ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì€ ëŒ€ê¸°)
        Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow();

        product.decreaseStock(quantity);

        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œ ë½ í•´ì œ
    }
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- MySQL
SELECT * FROM product WHERE id = 1 FOR UPDATE;

-- PostgreSQL
SELECT * FROM product WHERE id = 1 FOR UPDATE;

-- Oracle
SELECT * FROM product WHERE id = 1 FOR UPDATE;
```

**ë™ì‘ ì›ë¦¬**:
```
ì‹œë‚˜ë¦¬ì˜¤: ë‘ ì‚¬ìš©ìê°€ ë™ì‹œì— ì¬ê³  ì°¨ê°

ì‚¬ìš©ì A:
1. Product ì¡°íšŒ + ë½ íšë“ (FOR UPDATE)
2. ì¬ê³  ì°¨ê°
3. ì €ì¥
4. íŠ¸ëœì­ì…˜ ì»¤ë°‹ â†’ ë½ í•´ì œ

ì‚¬ìš©ì B:
1. Product ì¡°íšŒ ì‹œë„ (FOR UPDATE)
   â†’ Aê°€ ë½ì„ ë³´ìœ  ì¤‘ì´ë¯€ë¡œ ëŒ€ê¸°
2. Aì˜ íŠ¸ëœì­ì…˜ ì»¤ë°‹ í›„ ë½ íšë“
3. ì¬ê³  ì°¨ê° (ì´ë¯¸ Aê°€ ì°¨ê°í•œ ì¬ê³  ê¸°ì¤€)
4. ì €ì¥
5. íŠ¸ëœì­ì…˜ ì»¤ë°‹ â†’ ë½ í•´ì œ
```

**ì‚¬ìš© ì‚¬ë¡€**:

**ë‚™ê´€ì  ë½ ì‚¬ìš©**:
```
âœ… ì¶©ëŒì´ ë“œë¬¸ ê²½ìš°
âœ… ì½ê¸°ê°€ ë§ê³  ì“°ê¸°ê°€ ì ì€ ê²½ìš°
âœ… ì‘ë‹µ ì‹œê°„ì´ ì¤‘ìš”í•œ ê²½ìš°
âœ… ëŒ€ê¸° ì‹œê°„ì„ ìµœì†Œí™”í•˜ê³  ì‹¶ì€ ê²½ìš°

ì˜ˆ:
- ê²Œì‹œê¸€ ìˆ˜ì • (í•œ ì‚¬ìš©ìë§Œ ìˆ˜ì •)
- ì‚¬ìš©ì í”„ë¡œí•„ ì—…ë°ì´íŠ¸
- ì„¤ì • ë³€ê²½
- ì¡°íšŒìˆ˜ ì—…ë°ì´íŠ¸
```

**ë¹„ê´€ì  ë½ ì‚¬ìš©**:
```
âœ… ì¶©ëŒì´ ìì£¼ ë°œìƒí•˜ëŠ” ê²½ìš°
âœ… ë°ì´í„° ì •í•©ì„±ì´ ë§¤ìš° ì¤‘ìš”í•œ ê²½ìš°
âœ… ì¬ì‹œë„ ë¡œì§ êµ¬í˜„ì´ ì–´ë ¤ìš´ ê²½ìš°
âœ… ìˆœì°¨ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°

ì˜ˆ:
- ì¬ê³  ì°¨ê° (ì—¬ëŸ¬ ì‚¬ìš©ìê°€ ë™ì‹œ ì£¼ë¬¸)
- ì˜ˆì•½ ì‹œìŠ¤í…œ (ì¢Œì„, í˜¸í…”)
- ê³„ì¢Œ ì´ì²´
- í¬ì¸íŠ¸ ì°¨ê°
```

**ì‹¤ë¬´ ì˜ˆì‹œ**:
```java
// âœ… ë‚™ê´€ì  ë½: ê²Œì‹œê¸€ ìˆ˜ì •
@Transactional
public Post updatePost(Long postId, PostUpdateRequest request) {
    Post post = postRepository.findById(postId).orElseThrow();
    post.update(request);
    return postRepository.save(post);  // version ì²´í¬
}

// âœ… ë¹„ê´€ì  ë½: í‹°ì¼“ ì˜ˆë§¤
@Transactional
public Reservation reserveTicket(Long eventId, int quantity) {
    Event event = eventRepository.findByIdWithLock(eventId).orElseThrow();

    if (event.getAvailableTickets() < quantity) {
        throw new InsufficientTicketsException("í‹°ì¼“ ë¶€ì¡±");
    }

    event.decreaseTickets(quantity);
    return reservationRepository.save(new Reservation(event, quantity));
}
```

**ì„±ëŠ¥ ë¹„êµ**:
```
ë‚™ê´€ì  ë½:
- 100 req/s â†’ í‰ê·  ì‘ë‹µ ì‹œê°„: 10ms
- ì¶©ëŒë¥  1% â†’ ì¬ì‹œë„ í•„ìš”
- ë™ì‹œì„± ë†’ìŒ

ë¹„ê´€ì  ë½:
- 100 req/s â†’ í‰ê·  ì‘ë‹µ ì‹œê°„: 50ms
- ì¶©ëŒ ì—†ìŒ (ìˆœì°¨ ì²˜ë¦¬)
- ë™ì‹œì„± ë‚®ìŒ
```

---

**Q2: íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€(Isolation Level)ì˜ ì¢…ë¥˜ì™€ ê° ìˆ˜ì¤€ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë¬¸ì œ(Dirty Read, Non-Repeatable Read, Phantom Read)ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

**A**:

**ê²©ë¦¬ ìˆ˜ì¤€ ì¢…ë¥˜**:

| ê²©ë¦¬ ìˆ˜ì¤€ | Dirty Read | Non-Repeatable Read | Phantom Read |
|---------|-----------|---------------------|--------------|
| **READ_UNCOMMITTED** | â­• ë°œìƒ | â­• ë°œìƒ | â­• ë°œìƒ |
| **READ_COMMITTED** | âœ… ë°©ì§€ | â­• ë°œìƒ | â­• ë°œìƒ |
| **REPEATABLE_READ** | âœ… ë°©ì§€ | âœ… ë°©ì§€ | â­• ë°œìƒ |
| **SERIALIZABLE** | âœ… ë°©ì§€ | âœ… ë°©ì§€ | âœ… ë°©ì§€ |

**1. Dirty Read (ë”í‹° ë¦¬ë“œ)**:

**ë¬¸ì œ**:
ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì½ëŠ” ë¬¸ì œ

**ì˜ˆì‹œ**:
```
ì‹œê°„ | íŠ¸ëœì­ì…˜ A | íŠ¸ëœì­ì…˜ B
-----|-----------|------------
T1   | BEGIN     |
T2   | ê³„ì¢Œ ì”ì•¡ = 1000ì›
T3   | UPDATE account SET balance = 500  (ì»¤ë°‹ ì•ˆ í•¨)
T4   |           | BEGIN
T5   |           | SELECT balance â†’ 500ì› ì½ìŒ (Dirty Read!)
T6   | ROLLBACK  |
T7   |           | 500ì› ê¸°ì¤€ìœ¼ë¡œ ì‘ì—… â†’ ì˜ëª»ëœ ë°ì´í„°!
```

**ì½”ë“œ**:
```java
// íŠ¸ëœì­ì…˜ A
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void transferMoney() {
    Account account = accountRepository.findById(1L).orElseThrow();
    account.setBalance(500);  // ì»¤ë°‹ ì•ˆ í•¨
    // ...
    throw new RuntimeException();  // ë¡¤ë°±!
}

// íŠ¸ëœì­ì…˜ B
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void checkBalance() {
    Account account = accountRepository.findById(1L).orElseThrow();
    System.out.println(account.getBalance());  // 500ì› (Dirty Read!)
}
```

---

**2. Non-Repeatable Read (ë°˜ë³µ ë¶ˆê°€ëŠ¥ ì½ê¸°)**:

**ë¬¸ì œ**:
ê°™ì€ ì¿¼ë¦¬ë¥¼ ë‘ ë²ˆ ì‹¤í–‰í–ˆì„ ë•Œ ë‹¤ë¥¸ ê²°ê³¼ê°€ ë‚˜ì˜¤ëŠ” ë¬¸ì œ

**ì˜ˆì‹œ**:
```
ì‹œê°„ | íŠ¸ëœì­ì…˜ A | íŠ¸ëœì­ì…˜ B
-----|-----------|------------
T1   | BEGIN     |
T2   | SELECT balance â†’ 1000ì›
T3   |           | BEGIN
T4   |           | UPDATE account SET balance = 500
T5   |           | COMMIT
T6   | SELECT balance â†’ 500ì› (ë‹¤ë¥¸ ê²°ê³¼!)
```

**ì½”ë“œ**:
```java
// íŠ¸ëœì­ì…˜ A
@Transactional(isolation = Isolation.READ_COMMITTED)
public void processOrder() {
    Product product = productRepository.findById(1L).orElseThrow();
    int stock1 = product.getStockQuantity();  // 100

    // ... ë‹¤ë¥¸ ì‘ì—… ...

    // ë‹¤ì‹œ ì¡°íšŒ
    product = productRepository.findById(1L).orElseThrow();
    int stock2 = product.getStockQuantity();  // 50 (Non-Repeatable Read!)

    if (stock1 != stock2) {
        // ì¬ê³ ê°€ ë³€ê²½ë¨!
    }
}

// íŠ¸ëœì­ì…˜ B
@Transactional
public void decreaseStock() {
    Product product = productRepository.findById(1L).orElseThrow();
    product.decreaseStock(50);
}
```

---

**3. Phantom Read (íŒ¬í…€ ë¦¬ë“œ)**:

**ë¬¸ì œ**:
ê°™ì€ ì¡°ê±´ì˜ ì¿¼ë¦¬ë¥¼ ë‘ ë²ˆ ì‹¤í–‰í–ˆì„ ë•Œ ìƒˆë¡œìš´ í–‰ì´ ë‚˜íƒ€ë‚˜ê±°ë‚˜ ì‚¬ë¼ì§€ëŠ” ë¬¸ì œ

**ì˜ˆì‹œ**:
```
ì‹œê°„ | íŠ¸ëœì­ì…˜ A | íŠ¸ëœì­ì…˜ B
-----|-----------|------------
T1   | BEGIN     |
T2   | SELECT COUNT(*) WHERE age >= 20 â†’ 10ëª…
T3   |           | BEGIN
T4   |           | INSERT INTO users (age=25)
T5   |           | COMMIT
T6   | SELECT COUNT(*) WHERE age >= 20 â†’ 11ëª… (Phantom Read!)
```

**ì½”ë“œ**:
```java
// íŠ¸ëœì­ì…˜ A
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void calculateStatistics() {
    List<User> users1 = userRepository.findByAgeGreaterThanEqual(20);
    int count1 = users1.size();  // 10ëª…

    // ... ë‹¤ë¥¸ ì‘ì—… ...

    List<User> users2 = userRepository.findByAgeGreaterThanEqual(20);
    int count2 = users2.size();  // 11ëª… (Phantom Read!)
}

// íŠ¸ëœì­ì…˜ B
@Transactional
public void createUser() {
    User user = new User("í™ê¸¸ë™", 25);
    userRepository.save(user);
}
```

---

**ê²©ë¦¬ ìˆ˜ì¤€ë³„ ì„¤ëª…**:

**1. READ_UNCOMMITTED (ë ˆë²¨ 0)**:
```java
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public void example() {
    // ì»¤ë°‹ë˜ì§€ ì•Šì€ ë°ì´í„°ë„ ì½ìŒ
    // ê°€ì¥ ë‚®ì€ ê²©ë¦¬ ìˆ˜ì¤€, ê°€ì¥ ë†’ì€ ë™ì‹œì„±
}
```

**íŠ¹ì§•**:
- Dirty Read, Non-Repeatable Read, Phantom Read ëª¨ë‘ ë°œìƒ
- ê±°ì˜ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
- ë°ì´í„° ì •í•©ì„± ë³´ì¥ ì•ˆ ë¨

---

**2. READ_COMMITTED (ë ˆë²¨ 1)** - Oracle, PostgreSQL ê¸°ë³¸ê°’:
```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void example() {
    // ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ìŒ
}
```

**íŠ¹ì§•**:
- Dirty Read ë°©ì§€
- Non-Repeatable Read, Phantom Read ë°œìƒ ê°€ëŠ¥
- ì‹¤ë¬´ì—ì„œ ë§ì´ ì‚¬ìš©

**ë™ì‘**:
```sql
-- íŠ¸ëœì­ì…˜ A
BEGIN;
UPDATE account SET balance = 500 WHERE id = 1;
-- ì•„ì§ ì»¤ë°‹ ì•ˆ í•¨

-- íŠ¸ëœì­ì…˜ B (READ_COMMITTED)
SELECT balance FROM account WHERE id = 1;
-- â†’ 1000ì› ë°˜í™˜ (ì»¤ë°‹ ì•ˆ ëœ 500ì›ì€ ì•ˆ ì½ìŒ)

-- íŠ¸ëœì­ì…˜ A
COMMIT;

-- íŠ¸ëœì­ì…˜ B
SELECT balance FROM account WHERE id = 1;
-- â†’ 500ì› ë°˜í™˜ (ì»¤ë°‹ëœ ë°ì´í„° ì½ìŒ)
```

---

**3. REPEATABLE_READ (ë ˆë²¨ 2)** - MySQL ê¸°ë³¸ê°’:
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void example() {
    // ê°™ì€ ë°ì´í„°ë¥¼ ì—¬ëŸ¬ ë²ˆ ì½ì–´ë„ ë™ì¼í•œ ê²°ê³¼
}
```

**íŠ¹ì§•**:
- Dirty Read, Non-Repeatable Read ë°©ì§€
- Phantom ReadëŠ” ë°œìƒ ê°€ëŠ¥ (MySQLì€ Next-Key Lockìœ¼ë¡œ ë°©ì§€)
- íŠ¸ëœì­ì…˜ ì‹œì‘ ì‹œì ì˜ ìŠ¤ëƒ…ìƒ· ì‚¬ìš©

**ë™ì‘**:
```sql
-- íŠ¸ëœì­ì…˜ A (REPEATABLE_READ)
BEGIN;
SELECT balance FROM account WHERE id = 1;  -- 1000ì›

-- íŠ¸ëœì­ì…˜ B
UPDATE account SET balance = 500 WHERE id = 1;
COMMIT;

-- íŠ¸ëœì­ì…˜ A
SELECT balance FROM account WHERE id = 1;  -- ì—¬ì „íˆ 1000ì›!
-- (ìŠ¤ëƒ…ìƒ· ì‚¬ìš©, Non-Repeatable Read ë°©ì§€)
COMMIT;
```

---

**4. SERIALIZABLE (ë ˆë²¨ 3)**:
```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void example() {
    // ì™„ì „í•œ ê²©ë¦¬, ìˆœì°¨ ì‹¤í–‰ê³¼ ë™ì¼
}
```

**íŠ¹ì§•**:
- Dirty Read, Non-Repeatable Read, Phantom Read ëª¨ë‘ ë°©ì§€
- ê°€ì¥ ë†’ì€ ê²©ë¦¬ ìˆ˜ì¤€, ê°€ì¥ ë‚®ì€ ë™ì‹œì„±
- ì„±ëŠ¥ ì €í•˜ ì‹¬ê°

**ë™ì‘**:
```sql
-- íŠ¸ëœì­ì…˜ A (SERIALIZABLE)
BEGIN;
SELECT * FROM account WHERE balance > 1000;

-- íŠ¸ëœì­ì…˜ B
INSERT INTO account (balance) VALUES (2000);
-- â†’ ëŒ€ê¸°! (Aê°€ ëë‚  ë•Œê¹Œì§€)

-- íŠ¸ëœì­ì…˜ A
SELECT * FROM account WHERE balance > 1000;
-- ë™ì¼í•œ ê²°ê³¼ (Phantom Read ë°©ì§€)
COMMIT;

-- íŠ¸ëœì­ì…˜ B
-- ì´ì œ INSERT ì‹¤í–‰ë¨
COMMIT;
```

---

**ì‹¤ë¬´ ì„ íƒ ê°€ì´ë“œ**:

```java
// âœ… ì¼ë°˜ì ì¸ ì¡°íšŒ: READ_COMMITTED
@Transactional(isolation = Isolation.READ_COMMITTED, readOnly = true)
public List<User> getUsers() {
    return userRepository.findAll();
}

// âœ… í†µê³„, ë¦¬í¬íŠ¸: REPEATABLE_READ
@Transactional(isolation = Isolation.REPEATABLE_READ, readOnly = true)
public SalesReport generateReport() {
    // ì¼ê´€ëœ ë°ì´í„°ë¡œ í†µê³„ ìƒì„±
}

// âœ… ê¸ˆìœµ ê±°ë˜: SERIALIZABLE (ë˜ëŠ” ë¹„ê´€ì  ë½)
@Transactional(isolation = Isolation.SERIALIZABLE)
public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
    // ì™„ì „í•œ ê²©ë¦¬ ë³´ì¥
}
```

**ì„±ëŠ¥ vs ì •í•©ì„±**:
```
READ_UNCOMMITTED: ë™ì‹œì„± ìµœê³ , ì •í•©ì„± ìµœì € (ì‚¬ìš© ë¹„ê¶Œì¥)
READ_COMMITTED: ë™ì‹œì„± ë†’ìŒ, ì •í•©ì„± ë³´í†µ (ì¼ë°˜ì  ì‚¬ìš©)
REPEATABLE_READ: ë™ì‹œì„± ë³´í†µ, ì •í•©ì„± ë†’ìŒ (í†µê³„, ë¦¬í¬íŠ¸)
SERIALIZABLE: ë™ì‹œì„± ìµœì €, ì •í•©ì„± ìµœê³  (ê¸ˆìœµ, ì¤‘ìš” ê±°ë˜)
```

---

**Q3: JPAì˜ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸(Persistence Context)ëŠ” ë¬´ì—‡ì´ë©°, 1ì°¨ ìºì‹œì™€ Dirty Checkingì˜ ë™ì‘ ì›ë¦¬ë¥¼ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

**A**:

**ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ë€**:
ì—”í‹°í‹°ë¥¼ ì˜êµ¬ ì €ì¥í•˜ëŠ” í™˜ê²½ìœ¼ë¡œ, ì—”í‹°í‹°ì™€ DB ì‚¬ì´ì˜ ì¤‘ê°„ ê³„ì¸µ ì—­í• 

**êµ¬ì¡°**:
```
Application â†” EntityManager â†” Persistence Context â†” Database
                                     â†“
                            - 1ì°¨ ìºì‹œ
                            - ì“°ê¸° ì§€ì—° SQL ì €ì¥ì†Œ
                            - ë³€ê²½ ê°ì§€ (Dirty Checking)
                            - ì§€ì—° ë¡œë”©
```

**ì—”í‹°í‹° ìƒëª…ì£¼ê¸°**:
```
ë¹„ì˜ì† (New/Transient)
    â†“ persist()
ì˜ì† (Managed) â† ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ì—ì„œ ê´€ë¦¬
    â†“ detach(), clear(), close()
ì¤€ì˜ì† (Detached)
    â†“ remove()
ì‚­ì œ (Removed)
```

---

**1ì°¨ ìºì‹œ (First Level Cache)**:

**êµ¬ì¡°**:
```
ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ë‚´ë¶€:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1ì°¨ ìºì‹œ (Map<ID, Entity>)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  @Id(1) â†’ User(id=1, name="í™ê¸¸ë™") â”‚
â”‚  @Id(2) â†’ User(id=2, name="ê¹€ì² ìˆ˜") â”‚
â”‚  @Id(3) â†’ User(id=3, name="ì´ì˜í¬") â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ë™ì‘ ì›ë¦¬**:
```java
@Transactional
public void example() {
    // 1. ìµœì´ˆ ì¡°íšŒ: DBì—ì„œ ì¡°íšŒ í›„ 1ì°¨ ìºì‹œì— ì €ì¥
    User user1 = userRepository.findById(1L).orElseThrow();
    // SELECT * FROM users WHERE id = 1;

    // 2. ê°™ì€ ID ì¬ì¡°íšŒ: 1ì°¨ ìºì‹œì—ì„œ ì¡°íšŒ (DB ì ‘ê·¼ ì•ˆ í•¨!)
    User user2 = userRepository.findById(1L).orElseThrow();
    // ì¿¼ë¦¬ ì‹¤í–‰ ì•ˆ ë¨!

    // 3. ë™ì¼ì„± ë³´ì¥
    System.out.println(user1 == user2);  // true
}
```

**ì‹¤ì œ ì˜ˆì‹œ**:
```java
@Service
@Transactional
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public void processUser(Long userId) {
        // 1ì°¨ ì¡°íšŒ: DB ì ‘ê·¼
        User user = userRepository.findById(userId).orElseThrow();
        System.out.println(user.getName());

        // 2ì°¨ ì¡°íšŒ: 1ì°¨ ìºì‹œì—ì„œ ì¡°íšŒ (DB ì ‘ê·¼ X)
        User sameUser = userRepository.findById(userId).orElseThrow();
        System.out.println(sameUser.getName());

        // 3ì°¨ ì¡°íšŒ: 1ì°¨ ìºì‹œì—ì„œ ì¡°íšŒ (DB ì ‘ê·¼ X)
        User againUser = userRepository.findById(userId).orElseThrow();
        System.out.println(againUser.getName());

        // ë™ì¼í•œ ì¸ìŠ¤í„´ìŠ¤
        System.out.println(user == sameUser);  // true
        System.out.println(user == againUser);  // true
    }
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1ë²ˆë§Œ ì‹¤í–‰ë¨
SELECT * FROM users WHERE id = 1;
```

**ì¥ì **:
```
1. ì„±ëŠ¥ ìµœì í™”:
   - ê°™ì€ ì—”í‹°í‹° ì—¬ëŸ¬ ë²ˆ ì¡°íšŒ ì‹œ DB ì ‘ê·¼ 1ë²ˆë§Œ
   - ë„¤íŠ¸ì›Œí¬ ë¹„ìš© ì ˆê°

2. ë™ì¼ì„± ë³´ì¥:
   - ê°™ì€ IDì˜ ì—”í‹°í‹°ëŠ” ê°™ì€ ì¸ìŠ¤í„´ìŠ¤
   - == ë¹„êµ ê°€ëŠ¥

3. íŠ¸ëœì­ì…˜ ê²©ë¦¬:
   - íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ì¼ê´€ëœ ë°ì´í„°
```

**í•œê³„**:
```
âŒ íŠ¸ëœì­ì…˜ ë²”ìœ„:
   - íŠ¸ëœì­ì…˜ ì¢…ë£Œ ì‹œ 1ì°¨ ìºì‹œ ì‚­ì œ
   - ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ê³¼ ê³µìœ  ì•ˆ ë¨

âŒ ì• í”Œë¦¬ì¼€ì´ì…˜ ë²”ìœ„:
   - ê°™ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ ì¸ìŠ¤í„´ìŠ¤ ë‚´ì—ì„œë§Œ
   - ë¶„ì‚° í™˜ê²½ì—ì„œëŠ” íš¨ê³¼ ì—†ìŒ
```

---

**Dirty Checking (ë³€ê²½ ê°ì§€)**:

**ë™ì‘ ì›ë¦¬**:
```
1. ì—”í‹°í‹° ìµœì´ˆ ë¡œë“œ ì‹œ ìŠ¤ëƒ…ìƒ· ìƒì„±
2. íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì „ ìŠ¤ëƒ…ìƒ·ê³¼ í˜„ì¬ ìƒíƒœ ë¹„êµ
3. ë³€ê²½ ì‚¬í•­ ìˆìœ¼ë©´ UPDATE ì¿¼ë¦¬ ìë™ ìƒì„±
4. ì¿¼ë¦¬ ì‹¤í–‰ í›„ ì»¤ë°‹
```

**ì½”ë“œ ì˜ˆì‹œ**:
```java
@Transactional
public void updateUser(Long userId, String newName) {
    // 1. User ì¡°íšŒ â†’ ì˜ì† ìƒíƒœ + ìŠ¤ëƒ…ìƒ· ìƒì„±
    User user = userRepository.findById(userId).orElseThrow();
    // ìŠ¤ëƒ…ìƒ·: User(id=1, name="í™ê¸¸ë™", email="hong@example.com")

    // 2. ì—”í‹°í‹° ë³€ê²½ (setter í˜¸ì¶œ)
    user.setName(newName);
    // í˜„ì¬ ìƒíƒœ: User(id=1, name="ê¹€ì² ìˆ˜", email="hong@example.com")

    // 3. ëª…ì‹œì  save() í˜¸ì¶œ ë¶ˆí•„ìš”!
    // userRepository.save(user);  // í•„ìš” ì—†ìŒ

    // 4. íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œ:
    //    - ìŠ¤ëƒ…ìƒ·ê³¼ í˜„ì¬ ìƒíƒœ ë¹„êµ
    //    - nameì´ ë³€ê²½ë¨ ê°ì§€
    //    - UPDATE ì¿¼ë¦¬ ìë™ ìƒì„± ë° ì‹¤í–‰
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1. ì¡°íšŒ
SELECT * FROM users WHERE id = 1;

-- 2. ë³€ê²½ ê°ì§€ í›„ ìë™ UPDATE
UPDATE users
SET name = 'ê¹€ì² ìˆ˜', updated_at = '2025-10-19 10:30:00'
WHERE id = 1;
```

**ë‚´ë¶€ ë™ì‘ (ê°œë…ì  ì½”ë“œ)**:
```java
// EntityManager ë‚´ë¶€
public class PersistenceContext {

    // 1ì°¨ ìºì‹œ
    private Map<Object, Object> entityCache = new HashMap<>();

    // ìŠ¤ëƒ…ìƒ·
    private Map<Object, Object> snapshots = new HashMap<>();

    public <T> T find(Class<T> entityClass, Object id) {
        // 1ì°¨ ìºì‹œ í™•ì¸
        if (entityCache.containsKey(id)) {
            return (T) entityCache.get(id);
        }

        // DBì—ì„œ ì¡°íšŒ
        T entity = loadFromDatabase(entityClass, id);

        // 1ì°¨ ìºì‹œì— ì €ì¥
        entityCache.put(id, entity);

        // ìŠ¤ëƒ…ìƒ· ì €ì¥
        snapshots.put(id, clone(entity));

        return entity;
    }

    public void flush() {
        // ë³€ê²½ ê°ì§€
        for (Object id : entityCache.keySet()) {
            Object entity = entityCache.get(id);
            Object snapshot = snapshots.get(id);

            if (!equals(entity, snapshot)) {
                // ë³€ê²½ ê°ì§€ë¨ â†’ UPDATE ì¿¼ë¦¬ ìƒì„±
                generateUpdateQuery(entity);
            }
        }
    }
}
```

**ë³µì¡í•œ ì˜ˆì‹œ**:
```java
@Transactional
public void updateMultipleFields(Long userId) {
    User user = userRepository.findById(userId).orElseThrow();
    // ìŠ¤ëƒ…ìƒ·: User(id=1, name="í™ê¸¸ë™", email="hong@example.com", age=20)

    // ì—¬ëŸ¬ í•„ë“œ ë³€ê²½
    user.setName("ê¹€ì² ìˆ˜");
    user.setEmail("kim@example.com");
    user.setAge(25);

    // íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œ:
    // UPDATE users
    // SET name='ê¹€ì² ìˆ˜', email='kim@example.com', age=25
    // WHERE id=1;
}
```

**Dirty Checking ë¹„í™œì„±í™”**:
```java
// readOnly = true â†’ Dirty Checking ì•ˆ í•¨
@Transactional(readOnly = true)
public User getUser(Long userId) {
    User user = userRepository.findById(userId).orElseThrow();

    // ë³€ê²½í•´ë„ DBì— ë°˜ì˜ ì•ˆ ë¨ (ìŠ¤ëƒ…ìƒ· ìƒì„± ì•ˆ í•¨)
    user.setName("ë³€ê²½");

    return user;
}
```

---

**ì“°ê¸° ì§€ì—° (Transactional Write-Behind)**:

**ë™ì‘**:
```java
@Transactional
public void saveMultipleUsers() {
    User user1 = new User("í™ê¸¸ë™");
    userRepository.save(user1);
    // INSERT ì¿¼ë¦¬ ì¦‰ì‹œ ì‹¤í–‰ ì•ˆ í•¨!

    User user2 = new User("ê¹€ì² ìˆ˜");
    userRepository.save(user2);
    // INSERT ì¿¼ë¦¬ ì¦‰ì‹œ ì‹¤í–‰ ì•ˆ í•¨!

    User user3 = new User("ì´ì˜í¬");
    userRepository.save(user3);
    // INSERT ì¿¼ë¦¬ ì¦‰ì‹œ ì‹¤í–‰ ì•ˆ í•¨!

    // íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œ í•œ ë²ˆì— ì‹¤í–‰
    // INSERT INTO users ... (user1)
    // INSERT INTO users ... (user2)
    // INSERT INTO users ... (user3)
}
```

**ì¥ì **:
```
1. ì„±ëŠ¥ ìµœì í™”:
   - ì¿¼ë¦¬ë¥¼ ëª¨ì•„ì„œ í•œ ë²ˆì— ì‹¤í–‰
   - ë°°ì¹˜ ì²˜ë¦¬ ê°€ëŠ¥

2. íŠ¸ëœì­ì…˜ ë¬´ê²°ì„±:
   - ëª¨ë‘ ì„±ê³µ ë˜ëŠ” ëª¨ë‘ ì‹¤íŒ¨
```

---

**ì‹¤ë¬´ í™œìš©**:

```java
@Service
@Transactional
public class OrderService {

    public Order createOrder(OrderRequest request) {
        // 1. User ì¡°íšŒ (1ì°¨ ìºì‹œ í™œìš©)
        User user = userRepository.findById(request.getUserId())
            .orElseThrow();

        // 2. Order ìƒì„± (ì“°ê¸° ì§€ì—°)
        Order order = new Order(user, request);
        orderRepository.save(order);  // ì¿¼ë¦¬ ì¦‰ì‹œ ì‹¤í–‰ ì•ˆ í•¨

        // 3. ì¬ê³  ì°¨ê° (Dirty Checking)
        Product product = productRepository.findById(request.getProductId())
            .orElseThrow();
        product.decreaseStock(request.getQuantity());  // save() ë¶ˆí•„ìš”

        // 4. í¬ì¸íŠ¸ ì°¨ê° (Dirty Checking)
        Point point = pointRepository.findByUserId(user.getId())
            .orElseThrow();
        point.use(request.getUsePoints());  // save() ë¶ˆí•„ìš”

        // 5. User ì¬ì¡°íšŒ (1ì°¨ ìºì‹œì—ì„œ ì¡°íšŒ, DB ì ‘ê·¼ ì•ˆ í•¨)
        User sameUser = userRepository.findById(request.getUserId())
            .orElseThrow();
        System.out.println(user == sameUser);  // true

        // íŠ¸ëœì­ì…˜ ì»¤ë°‹ ì‹œ:
        // - INSERT order (ì“°ê¸° ì§€ì—°)
        // - UPDATE product (Dirty Checking)
        // - UPDATE point (Dirty Checking)

        return order;
    }
}
```

**ì •ë¦¬**:
```
ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸:
â†’ ì—”í‹°í‹°ì™€ DB ì‚¬ì´ì˜ ì¤‘ê°„ ê³„ì¸µ

1ì°¨ ìºì‹œ:
â†’ ê°™ì€ ì—”í‹°í‹° ì—¬ëŸ¬ ë²ˆ ì¡°íšŒ ì‹œ ì„±ëŠ¥ ìµœì í™”
â†’ ë™ì¼ì„± ë³´ì¥ (== ë¹„êµ ê°€ëŠ¥)
â†’ íŠ¸ëœì­ì…˜ ë²”ìœ„

Dirty Checking:
â†’ ì—”í‹°í‹° ë³€ê²½ ì‹œ ìë™ UPDATE
â†’ save() í˜¸ì¶œ ë¶ˆí•„ìš”
â†’ ìŠ¤ëƒ…ìƒ·ê³¼ í˜„ì¬ ìƒíƒœ ë¹„êµ

ì“°ê¸° ì§€ì—°:
â†’ ì¿¼ë¦¬ë¥¼ ëª¨ì•„ì„œ í•œ ë²ˆì— ì‹¤í–‰
â†’ ë°°ì¹˜ ì²˜ë¦¬, íŠ¸ëœì­ì…˜ ë¬´ê²°ì„±
```

---

**Q4: ëŒ€ìš©ëŸ‰ ë°ì´í„°ë¥¼ ì²˜ë¦¬í•  ë•Œ JPAë¥¼ ì‚¬ìš©í•˜ë©´ ë©”ëª¨ë¦¬ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë°©ë²•ì„ ì œì‹œí•´ì£¼ì„¸ìš”.**

**A**:

**ë¬¸ì œ ìƒí™©**:
```java
// âŒ 100ë§Œ ê±´ ì¡°íšŒ ì‹œ OutOfMemoryError!
@Transactional
public void processAllUsers() {
    List<User> users = userRepository.findAll();  // 100ë§Œ ê±´

    for (User user : users) {
        processUser(user);
    }
    // ë©”ëª¨ë¦¬: 100ë§Œ ê°œ ê°ì²´ + 100ë§Œ ê°œ ìŠ¤ëƒ…ìƒ· = OutOfMemoryError!
}
```

**ì›ì¸**:
```
1. JPAëŠ” ëª¨ë“  ì—”í‹°í‹°ë¥¼ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ì— ë³´ê´€
2. Dirty Checkingì„ ìœ„í•œ ìŠ¤ëƒ…ìƒ· ìƒì„±
3. ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ = (ì—”í‹°í‹° í¬ê¸° Ã— 2) Ã— ê°œìˆ˜

100ë§Œ ê±´ Ã— 2KB = 2GB
```

---

**í•´ê²°ì±… 1: í˜ì´ì§• (Pagination)**:

```java
@Service
public class UserBatchService {

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void processAllUsers() {
        int pageSize = 1000;
        int pageNumber = 0;

        Page<User> page;
        do {
            // 1000ê±´ì”© ì²˜ë¦¬
            Pageable pageable = PageRequest.of(pageNumber, pageSize);
            page = userRepository.findAll(pageable);

            for (User user : page.getContent()) {
                processUser(user);
            }

            pageNumber++;

            // ì¤‘ìš”: ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            entityManager.clear();

        } while (page.hasNext());
    }

    private void processUser(User user) {
        // ì²˜ë¦¬ ë¡œì§
    }
}
```

**ì¥ì **:
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¼ì •í•˜ê²Œ ìœ ì§€
- ê°„ë‹¨í•œ êµ¬í˜„

**ë‹¨ì **:
- í˜ì´ì§€ ë²ˆí˜¸ ì¦ê°€ ì‹œ OFFSET ì„±ëŠ¥ ì €í•˜
- `OFFSET 999000 LIMIT 1000` â†’ ëŠë¦¼

---

**í•´ê²°ì±… 2: Cursor ê¸°ë°˜ í˜ì´ì§•**:

```java
@Service
public class UserBatchService {

    @Autowired
    private UserRepository userRepository;

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public void processAllUsers() {
        Long lastId = 0L;
        int batchSize = 1000;

        while (true) {
            // Cursor ë°©ì‹: id > lastId ORDER BY id LIMIT 1000
            List<User> users = userRepository.findUsersAfter(lastId, batchSize);

            if (users.isEmpty()) {
                break;
            }

            for (User user : users) {
                processUser(user);
            }

            // ë§ˆì§€ë§‰ ID ì €ì¥
            lastId = users.get(users.size() - 1).getId();

            // ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
            entityManager.flush();
            entityManager.clear();
        }
    }
}

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Query("SELECT u FROM User u WHERE u.id > :lastId ORDER BY u.id")
    List<User> findUsersAfter(@Param("lastId") Long lastId,
                              @Param("limit") int limit);
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- 1íšŒì°¨
SELECT * FROM users WHERE id > 0 ORDER BY id LIMIT 1000;

-- 2íšŒì°¨
SELECT * FROM users WHERE id > 1000 ORDER BY id LIMIT 1000;

-- 3íšŒì°¨
SELECT * FROM users WHERE id > 2000 ORDER BY id LIMIT 1000;
```

**ì¥ì **:
- OFFSET ì—†ì´ ì¸ë±ìŠ¤ë§Œ ì‚¬ìš© â†’ ë¹ ë¦„
- í˜ì´ì§€ ë²ˆí˜¸ì™€ ë¬´ê´€í•˜ê²Œ ì¼ì •í•œ ì„±ëŠ¥

---

**í•´ê²°ì±… 3: Scroll (Stream) API**:

```java
@Service
public class UserBatchService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional(readOnly = true)
    public void processAllUsers() {
        Session session = entityManager.unwrap(Session.class);

        ScrollableResults scroll = session.createQuery(
            "SELECT u FROM User u", User.class)
            .setFetchSize(1000)  // DBì—ì„œ ê°€ì ¸ì˜¬ í¬ê¸°
            .scroll(ScrollMode.FORWARD_ONLY);

        int count = 0;
        while (scroll.next()) {
            User user = (User) scroll.get(0);
            processUser(user);

            if (++count % 1000 == 0) {
                // 1000ê±´ë§ˆë‹¤ ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                entityManager.flush();
                entityManager.clear();
            }
        }

        scroll.close();
    }
}
```

---

**í•´ê²°ì±… 4: Native Query + JDBC Batch**:

```java
@Service
public class UserBatchService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void processAllUsers() {
        jdbcTemplate.query(
            "SELECT * FROM users",
            rs -> {
                while (rs.next()) {
                    User user = mapRowToUser(rs);
                    processUser(user);
                }
            }
        );
    }

    private User mapRowToUser(ResultSet rs) throws SQLException {
        User user = new User();
        user.setId(rs.getLong("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        return user;
    }
}
```

**ì¥ì **:
- JPA ì—†ì´ ìˆœìˆ˜ JDBC â†’ ë©”ëª¨ë¦¬ íš¨ìœ¨ì 
- ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš© ì•ˆ í•¨

**ë‹¨ì **:
- ìˆ˜ë™ ë§¤í•‘ í•„ìš”
- JPA ê¸°ëŠ¥ ì‚¬ìš© ë¶ˆê°€ (Dirty Checking ë“±)

---

**í•´ê²°ì±… 5: @Modifying with Bulk Update**:

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    @Modifying
    @Query("UPDATE User u SET u.status = :status WHERE u.lastLoginDate < :date")
    int bulkUpdateStatus(@Param("status") UserStatus status,
                         @Param("date") LocalDateTime date);
}

@Service
public class UserBatchService {

    @Transactional
    public void deactivateInactiveUsers() {
        LocalDateTime threshold = LocalDateTime.now().minusMonths(6);

        // í•œ ë²ˆì˜ ì¿¼ë¦¬ë¡œ ëŒ€ëŸ‰ ì—…ë°ì´íŠ¸
        int count = userRepository.bulkUpdateStatus(
            UserStatus.INACTIVE,
            threshold
        );

        log.info("Deactivated {} users", count);
    }
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:
```sql
-- í•œ ë²ˆì— ìˆ˜ë°±ë§Œ ê±´ UPDATE
UPDATE users
SET status = 'INACTIVE'
WHERE last_login_date < '2024-04-19';
```

**ì£¼ì˜ì‚¬í•­**:
```java
@Modifying(clearAutomatically = true)  // ì˜ì†ì„± ì»¨í…ìŠ¤íŠ¸ ìë™ ì´ˆê¸°í™”
@Query("UPDATE User u SET u.status = :status WHERE u.id = :id")
int updateStatus(@Param("id") Long id, @Param("status") UserStatus status);
```

---

**í•´ê²°ì±… 6: ë°°ì¹˜ ì²˜ë¦¬ + ë©€í‹° ìŠ¤ë ˆë“œ**:

```java
@Service
public class UserBatchService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ThreadPoolTaskExecutor taskExecutor;

    public void processAllUsersInParallel() {
        long totalCount = userRepository.count();
        int batchSize = 10000;
        int threads = 10;
        int partitionSize = (int) (totalCount / threads);

        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (int i = 0; i < threads; i++) {
            final int start = i * partitionSize;
            final int end = (i == threads - 1) ?
                (int) totalCount : (i + 1) * partitionSize;

            CompletableFuture<Void> future = CompletableFuture.runAsync(
                () -> processBatch(start, end, batchSize),
                taskExecutor
            );

            futures.add(future);
        }

        // ëª¨ë“  ìŠ¤ë ˆë“œ ì™„ë£Œ ëŒ€ê¸°
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .join();
    }

    @Transactional
    public void processBatch(int start, int end, int batchSize) {
        for (int offset = start; offset < end; offset += batchSize) {
            List<User> users = userRepository.findUsers(offset, batchSize);

            for (User user : users) {
                processUser(user);
            }

            entityManager.flush();
            entityManager.clear();
        }
    }
}
```

---

**ì„±ëŠ¥ ë¹„êµ**:

| ë°©ë²• | 100ë§Œ ê±´ ì²˜ë¦¬ ì‹œê°„ | ë©”ëª¨ë¦¬ ì‚¬ìš© | ë‚œì´ë„ |
|-----|-------------------|-----------|--------|
| **findAll()** | 60ì´ˆ | 2GB | ì‰¬ì›€ |
| **Pagination** | 45ì´ˆ | 20MB | ì‰¬ì›€ |
| **Cursor** | 30ì´ˆ | 10MB | ë³´í†µ |
| **Scroll API** | 25ì´ˆ | 10MB | ë³´í†µ |
| **JDBC Batch** | 20ì´ˆ | 5MB | ì–´ë ¤ì›€ |
| **Bulk Update** | 5ì´ˆ | 1MB | ì‰¬ì›€ |
| **ë©€í‹° ìŠ¤ë ˆë“œ** | 10ì´ˆ | 50MB | ì–´ë ¤ì›€ |

---

**ì‹¤ë¬´ ê¶Œì¥ íŒ¨í„´**:

```java
@Service
public class UserBatchService {

    // âœ… ëŒ€ëŸ‰ ì¡°íšŒ + ì²˜ë¦¬: Cursor ë°©ì‹
    @Transactional(readOnly = true)
    public void exportAllUsers() {
        Long lastId = 0L;
        int batchSize = 1000;

        while (true) {
            List<User> users = userRepository.findUsersAfter(lastId, batchSize);
            if (users.isEmpty()) break;

            exportToFile(users);

            lastId = users.get(users.size() - 1).getId();
            entityManager.clear();  // ë©”ëª¨ë¦¬ ì •ë¦¬
        }
    }

    // âœ… ëŒ€ëŸ‰ ì—…ë°ì´íŠ¸: Bulk Update
    @Transactional
    public void deactivateInactiveUsers() {
        userRepository.bulkUpdateInactiveUsers();
    }

    // âœ… ë³µì¡í•œ ì²˜ë¦¬: í˜ì´ì§• + ëª…ì‹œì  ì´ˆê¸°í™”
    @Transactional
    public void processComplexLogic() {
        int pageNumber = 0;
        int pageSize = 100;
        Page<User> page;

        do {
            page = userRepository.findAll(PageRequest.of(pageNumber++, pageSize));

            for (User user : page) {
                // ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
                complexProcessing(user);
            }

            entityManager.flush();
            entityManager.clear();

        } while (page.hasNext());
    }
}
```

---

**Q5: ë©€í‹° DataSource í™˜ê²½ì—ì„œ ì½ê¸°/ì“°ê¸° ë¶„ë¦¬(Read/Write Splitting)ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•´ì£¼ì„¸ìš”.**

**A**:

**ì•„í‚¤í…ì²˜**:
```
Application
    â†“
RoutingDataSource (ë™ì  ë¼ìš°íŒ…)
    â†“
    â”œâ”€â†’ Master DB (ì“°ê¸°)
    â””â”€â†’ Slave DB (ì½ê¸°)
```

**êµ¬í˜„ ë‹¨ê³„**:

**1ë‹¨ê³„: DataSource ì„¤ì •**:

```yaml
# application.yml
spring:
  datasource:
    master:
      jdbc-url: jdbc:mysql://master-db:3306/mydb
      username: master_user
      password: master_password
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 20
        minimum-idle: 5

    slave:
      jdbc-url: jdbc:mysql://slave-db:3306/mydb
      username: slave_user
      password: slave_password
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 30  # SlaveëŠ” ì½ê¸°ê°€ ë§ìœ¼ë¯€ë¡œ Pool í¬ê¸° í¬ê²Œ
        minimum-idle: 10
```

**2ë‹¨ê³„: DataSource Configuration**:

```java
@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DataSource routingDataSource(
            @Qualifier("masterDataSource") DataSource master,
            @Qualifier("slaveDataSource") DataSource slave) {

        ReplicationRoutingDataSource routingDataSource =
            new ReplicationRoutingDataSource();

        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.MASTER, master);
        dataSourceMap.put(DataSourceType.SLAVE, slave);

        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(master);

        return routingDataSource;
    }

    @Bean
    public DataSource dataSource(
            @Qualifier("routingDataSource") DataSource routingDataSource) {

        // LazyConnectionDataSourceProxyë¡œ ë˜í•‘
        // â†’ íŠ¸ëœì­ì…˜ ì‹œì‘ í›„ ì‹¤ì œ Connection íšë“ ì‹œì ì— ë¼ìš°íŒ… ê²°ì •
        return new LazyConnectionDataSourceProxy(routingDataSource);
    }
}
```

**3ë‹¨ê³„: ë™ì  ë¼ìš°íŒ… DataSource**:

```java
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    @Override
    protected Object determineCurrentLookupKey() {
        // í˜„ì¬ íŠ¸ëœì­ì…˜ì´ readOnlyì¸ì§€ í™•ì¸
        boolean isReadOnly = TransactionSynchronizationManager
            .isCurrentTransactionReadOnly();

        if (isReadOnly) {
            log.debug("Routing to SLAVE DataSource (readOnly=true)");
            return DataSourceType.SLAVE;
        } else {
            log.debug("Routing to MASTER DataSource (readOnly=false)");
            return DataSourceType.MASTER;
        }
    }
}

enum DataSourceType {
    MASTER,
    SLAVE
}
```

**4ë‹¨ê³„: Service ê³„ì¸µì—ì„œ ì‚¬ìš©**:

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class UserService {

    private final UserRepository userRepository;

    // âœ… ì“°ê¸° ì‘ì—… â†’ Master DB
    @Transactional
    public User createUser(UserRequest request) {
        log.info("Creating user - will use MASTER DB");

        User user = new User();
        user.setName(request.getName());
        user.setEmail(request.getEmail());

        return userRepository.save(user);
    }

    // âœ… ì½ê¸° ì‘ì—… â†’ Slave DB
    @Transactional(readOnly = true)
    public User getUser(Long id) {
        log.info("Fetching user - will use SLAVE DB");

        return userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
    }

    // âœ… ì½ê¸° ì‘ì—… â†’ Slave DB
    @Transactional(readOnly = true)
    public List<User> searchUsers(String keyword) {
        log.info("Searching users - will use SLAVE DB");

        return userRepository.findByNameContaining(keyword);
    }

    // âœ… ì“°ê¸° ì‘ì—… â†’ Master DB
    @Transactional
    public User updateUser(Long id, UserUpdateRequest request) {
        log.info("Updating user - will use MASTER DB");

        User user = userRepository.findById(id).orElseThrow();
        user.setName(request.getName());
        user.setEmail(request.getEmail());

        return userRepository.save(user);
    }

    // âœ… ì“°ê¸° í¬í•¨ â†’ Master DB
    @Transactional
    public void processOrder(OrderRequest request) {
        log.info("Processing order - will use MASTER DB");

        // ì½ê¸° ì‘ì—…ë„ Masterì—ì„œ ìˆ˜í–‰ (ê°™ì€ íŠ¸ëœì­ì…˜)
        User user = userRepository.findById(request.getUserId())
            .orElseThrow();

        // ì“°ê¸° ì‘ì—…
        Order order = new Order(user, request);
        orderRepository.save(order);
    }
}
```

**ì‹¤í–‰ë˜ëŠ” ì¿¼ë¦¬**:

```sql
-- @Transactional(readOnly = true) â†’ Slave DB
SELECT * FROM users WHERE id = 1;

-- @Transactional â†’ Master DB
INSERT INTO users (name, email) VALUES ('í™ê¸¸ë™', 'hong@example.com');
UPDATE users SET name = 'ê¹€ì² ìˆ˜' WHERE id = 1;
DELETE FROM users WHERE id = 1;
```

---

**ê³ ê¸‰ ê¸°ëŠ¥: Slave ì¥ì•  ì‹œ Failover**:

```java
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    private final DataSource masterDataSource;
    private final DataSource slaveDataSource;
    private volatile boolean slaveAvailable = true;

    @Override
    protected Object determineCurrentLookupKey() {
        boolean isReadOnly = TransactionSynchronizationManager
            .isCurrentTransactionReadOnly();

        if (isReadOnly && slaveAvailable) {
            try {
                testSlaveConnection();
                return DataSourceType.SLAVE;
            } catch (Exception e) {
                log.error("Slave DB is unavailable. Falling back to Master", e);
                slaveAvailable = false;
                scheduleHealthCheck();
                return DataSourceType.MASTER;
            }
        }

        return DataSourceType.MASTER;
    }

    private void testSlaveConnection() throws SQLException {
        try (Connection conn = slaveDataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute("SELECT 1");
        }
    }

    @Scheduled(fixedDelay = 10000)  // 10ì´ˆë§ˆë‹¤ í™•ì¸
    public void healthCheck() {
        if (!slaveAvailable) {
            try {
                testSlaveConnection();
                slaveAvailable = true;
                log.info("Slave DB is back online");
            } catch (Exception e) {
                log.debug("Slave DB still unavailable");
            }
        }
    }
}
```

---

**ë‹¤ì¤‘ Slave ì§€ì› (Round-Robin)**:

```java
public class ReplicationRoutingDataSource extends AbstractRoutingDataSource {

    private final List<DataSource> slaveDataSources;
    private final AtomicInteger counter = new AtomicInteger(0);

    @Override
    protected Object determineCurrentLookupKey() {
        boolean isReadOnly = TransactionSynchronizationManager
            .isCurrentTransactionReadOnly();

        if (isReadOnly) {
            // Round-Robinìœ¼ë¡œ Slave ì„ íƒ
            int index = counter.getAndIncrement() % slaveDataSources.size();
            return "SLAVE_" + index;
        }

        return DataSourceType.MASTER;
    }
}

@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource routingDataSource() {
        ReplicationRoutingDataSource routingDataSource =
            new ReplicationRoutingDataSource();

        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.MASTER, masterDataSource());
        dataSourceMap.put("SLAVE_0", slave1DataSource());
        dataSourceMap.put("SLAVE_1", slave2DataSource());
        dataSourceMap.put("SLAVE_2", slave3DataSource());

        routingDataSource.setTargetDataSources(dataSourceMap);
        routingDataSource.setDefaultTargetDataSource(masterDataSource());

        return routingDataSource;
    }
}
```

---

**ëª¨ë‹ˆí„°ë§**:

```java
@Component
@Slf4j
public class DataSourceMonitor {

    @Autowired
    @Qualifier("masterDataSource")
    private HikariDataSource masterDataSource;

    @Autowired
    @Qualifier("slaveDataSource")
    private HikariDataSource slaveDataSource;

    @Scheduled(fixedDelay = 60000)  // 1ë¶„ë§ˆë‹¤
    public void logConnectionPoolStats() {
        HikariPoolMXBean masterPool = masterDataSource.getHikariPoolMXBean();
        HikariPoolMXBean slavePool = slaveDataSource.getHikariPoolMXBean();

        log.info("Master - Active: {}, Idle: {}, Total: {}, Waiting: {}",
            masterPool.getActiveConnections(),
            masterPool.getIdleConnections(),
            masterPool.getTotalConnections(),
            masterPool.getThreadsAwaitingConnection());

        log.info("Slave - Active: {}, Idle: {}, Total: {}, Waiting: {}",
            slavePool.getActiveConnections(),
            slavePool.getIdleConnections(),
            slavePool.getTotalConnections(),
            slavePool.getThreadsAwaitingConnection());
    }
}
```

---

**ì£¼ì˜ì‚¬í•­**:

```java
// âŒ ì˜ëª»ëœ ì‚¬ìš©: readOnly ì—†ì´ ì½ê¸°ë§Œ
@Transactional  // readOnly = false (ê¸°ë³¸ê°’)
public User getUser(Long id) {
    // Master DB ì‚¬ìš©! (Slave ì‚¬ìš© ì•ˆ ë¨)
    return userRepository.findById(id).orElseThrow();
}

// âœ… ì˜¬ë°”ë¥¸ ì‚¬ìš©: readOnly = true
@Transactional(readOnly = true)
public User getUser(Long id) {
    // Slave DB ì‚¬ìš© âœ…
    return userRepository.findById(id).orElseThrow();
}
```

**Replication Lag ê³ ë ¤**:

```java
@Service
public class OrderService {

    // âŒ ë¬¸ì œ: Replication Lagìœ¼ë¡œ ì¸í•œ ë°ì´í„° ë¶ˆì¼ì¹˜
    @Transactional
    public void createOrder(OrderRequest request) {
        // Masterì— ì €ì¥
        Order order = orderRepository.save(new Order(request));
    }

    @Transactional(readOnly = true)
    public Order getRecentOrder(Long orderId) {
        // Slaveì—ì„œ ì¡°íšŒ â†’ ì•„ì§ ë³µì œ ì•ˆ ë¨! (Replication Lag)
        return orderRepository.findById(orderId).orElseThrow();
    }

    // âœ… í•´ê²°: ìµœì‹  ë°ì´í„° í•„ìš” ì‹œ Masterì—ì„œ ì¡°íšŒ
    @Transactional  // readOnly = false â†’ Master ì‚¬ìš©
    public Order getRecentOrderFromMaster(Long orderId) {
        return orderRepository.findById(orderId).orElseThrow();
    }
}
```

---

## ğŸ“ í•µì‹¬ ì •ë¦¬

### ë°ì´í„° ì ‘ê·¼ ê¸°ìˆ  ë¹„êµ

| ê¸°ìˆ  | ì¶”ìƒí™” | SQL ì œì–´ | ë‚œì´ë„ | ì‚¬ìš© ì‚¬ë¡€ |
|------|--------|---------|--------|----------|
| JDBC | ë‚®ìŒ | ì™„ì „ | ì–´ë ¤ì›€ | ë ˆê±°ì‹œ, ì„±ëŠ¥ ìµœì í™” |
| Spring JDBC | ì¤‘ê°„ | ì§ì ‘ | ë³´í†µ | ê°„ë‹¨í•œ ì¿¼ë¦¬ |
| JPA | ë†’ìŒ | ìë™ | ì‰¬ì›€ | CRUD ì¤‘ì‹¬ |
| MyBatis | ì¤‘ê°„ | ì§ì ‘ | ë³´í†µ | ë³µì¡í•œ ì¿¼ë¦¬ |
| QueryDSL | ë†’ìŒ | íƒ€ì… ì•ˆì „ | ë³´í†µ | ë™ì  ì¿¼ë¦¬ |

### ì£¼ìš” ê°œë…

**DataSource**: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ê´€ë¦¬
**Transaction**: ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥
**Connection Pool**: ì„±ëŠ¥ ìµœì í™”
**Repository**: ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ ì¶”ìƒí™”

---

**ë‹¤ìŒ ì¥ìœ¼ë¡œ**: [â†’ ë‹¤ìŒ: 20ì¥ - Spring JDBC](SpringMVC-Part12-20-Spring-JDBC.md)

**ëª©ì°¨ë¡œ ëŒì•„ê°€ê¸°**: [ğŸ“š ì „ì²´ ëª©ì°¨](README.md)
