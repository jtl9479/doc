# Chapter 13-3: 생성자 (Constructor) - Part 3

## 목차
1. [실전 프로젝트](#실전-프로젝트)
2. [자주 묻는 질문 (FAQ)](#자주-묻는-질문-faq)
3. [면접 질문](#면접-질문)

---

## 실전 프로젝트

### 프로젝트: 온라인 서점 시스템 (Online Bookstore)

**프로젝트 목표:**
생성자를 활용하여 온라인 서점의 회원 관리, 도서 관리, 주문 처리 시스템을 구현합니다.

**핵심 요구사항:**
1. 다양한 타입의 회원 (일반, 프리미엄, 학생)
2. 도서 등록 (일반 도서, 전자책, 오디오북)
3. 주문 생성 및 처리
4. 리뷰 시스템

---

#### 파일 1: Customer.java (회원 클래스)

```java
public class Customer {
    String customerId;
    String name;
    String email;
    String password;
    String membershipType;  // 일반, 프리미엄, 학생
    int points;
    int purchaseCount;
    double discountRate;
    String registeredDate;

    // 생성자 1: 기본 회원가입
    public Customer(String name, String email, String password) {
        this.customerId = generateCustomerId();
        this.name = name;
        this.email = email;
        this.password = encryptPassword(password);
        this.membershipType = "일반";
        this.points = 1000;  // 가입 축하 포인트
        this.purchaseCount = 0;
        this.discountRate = 0.0;
        this.registeredDate = getCurrentDate();

        System.out.println("✓ 일반 회원가입 완료: " + name);
        System.out.println("  가입 축하 포인트 1,000점 지급!");
    }

    // 생성자 2: 프리미엄 회원가입
    public Customer(String name, String email, String password, String membershipType) {
        this(name, email, password);  // 기본 설정 먼저
        this.membershipType = membershipType;

        if (membershipType.equals("프리미엄")) {
            this.points += 5000;
            this.discountRate = 0.1;  // 10% 할인
            System.out.println("  🌟 프리미엄 회원 혜택: +5,000 포인트, 10% 할인");
        } else if (membershipType.equals("학생")) {
            this.points += 2000;
            this.discountRate = 0.05;  // 5% 할인
            System.out.println("  🎓 학생 회원 혜택: +2,000 포인트, 5% 할인");
        }
    }

    // 생성자 3: 기존 회원 복원 (로그인)
    public Customer(String customerId, String email, String membershipType,
                    int points, int purchaseCount) {
        this.customerId = customerId;
        this.name = null;  // 나중에 DB에서 로드
        this.email = email;
        this.password = null;  // 이미 인증됨
        this.membershipType = membershipType;
        this.points = points;
        this.purchaseCount = purchaseCount;
        this.discountRate = membershipType.equals("프리미엄") ? 0.1 :
                           (membershipType.equals("학생") ? 0.05 : 0.0);
        this.registeredDate = "기존 회원";

        System.out.println("✓ 기존 회원 로그인: " + email);
    }

    private String generateCustomerId() {
        return "C" + System.currentTimeMillis();
    }

    private String encryptPassword(String password) {
        return "encrypted_" + password;
    }

    private String getCurrentDate() {
        return "2024-01-15";
    }

    void addPoints(int amount) {
        this.points += amount;
        System.out.println("💰 " + amount + "점 적립 (총 " + points + "점)");
    }

    void displayCustomerInfo() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("고객 ID: " + customerId);
        System.out.println("이름: " + name);
        System.out.println("이메일: " + email);
        System.out.println("회원 등급: " + membershipType);
        System.out.println("포인트: " + points + "점");
        System.out.println("구매 횟수: " + purchaseCount + "회");
        System.out.println("할인율: " + (discountRate * 100) + "%");
        System.out.println("가입일: " + registeredDate);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━\n");
    }
}
```

---

#### 파일 2: Book.java (도서 클래스)

```java
public class Book {
    String bookId;
    String title;
    String author;
    String publisher;
    int price;
    String bookType;  // 일반, 전자책, 오디오북
    int stock;
    String isbn;
    int pageCount;
    double rating;
    int reviewCount;

    // 생성자 1: 기본 도서 등록
    public Book(String title, String author, String publisher, int price) {
        this.bookId = generateBookId();
        this.title = title;
        this.author = author;
        this.publisher = publisher;
        this.price = price;
        this.bookType = "일반";
        this.stock = 10;  // 기본 재고
        this.isbn = null;
        this.pageCount = 0;
        this.rating = 0.0;
        this.reviewCount = 0;

        System.out.println("✓ 도서 등록: " + title);
    }

    // 생성자 2: ISBN 포함 도서 등록
    public Book(String title, String author, String publisher, int price,
                String isbn, int pageCount) {
        this(title, author, publisher, price);
        this.isbn = isbn;
        this.pageCount = pageCount;

        System.out.println("  📚 ISBN: " + isbn + " (" + pageCount + " 페이지)");
    }

    // 생성자 3: 전자책/오디오북 등록
    public Book(String title, String author, String publisher, int price,
                String bookType) {
        this(title, author, publisher, price);
        this.bookType = bookType;
        this.stock = 999999;  // 전자책은 재고 무제한

        if (bookType.equals("전자책")) {
            System.out.println("  📱 전자책 (재고 무제한)");
        } else if (bookType.equals("오디오북")) {
            System.out.println("  🎧 오디오북 (재고 무제한)");
        }
    }

    // 생성자 4: 완전 맞춤 도서
    public Book(String title, String author, String publisher, int price,
                String bookType, int stock, String isbn, int pageCount) {
        this.bookId = generateBookId();
        this.title = title;
        this.author = author;
        this.publisher = publisher;
        this.price = price;
        this.bookType = bookType;
        this.stock = stock;
        this.isbn = isbn;
        this.pageCount = pageCount;
        this.rating = 0.0;
        this.reviewCount = 0;

        System.out.println("✓ 맞춤 도서 등록: " + title);
    }

    private String generateBookId() {
        return "B" + System.currentTimeMillis();
    }

    boolean purchase(int quantity) {
        if (bookType.equals("전자책") || bookType.equals("오디오북")) {
            return true;  // 디지털 상품은 항상 구매 가능
        }

        if (quantity > stock) {
            System.out.println("❌ 재고 부족: 요청 " + quantity + "권, 재고 " + stock + "권");
            return false;
        }

        stock -= quantity;
        System.out.println("✅ 구매 성공: " + title + " " + quantity + "권");
        return true;
    }

    void addReview(double rating) {
        this.rating = (this.rating * reviewCount + rating) / (reviewCount + 1);
        this.reviewCount++;
        System.out.println("⭐ 리뷰 등록: " + rating + "점 (평균: " +
                          String.format("%.1f", this.rating) + "점)");
    }

    void displayBookInfo() {
        System.out.println("\n┌─────────────────────────────────");
        System.out.println("│ 도서 ID: " + bookId);
        System.out.println("│ 제목: " + title);
        System.out.println("│ 저자: " + author);
        System.out.println("│ 출판사: " + publisher);
        System.out.println("│ 가격: " + price + "원");
        System.out.println("│ 타입: " + bookType);
        if (!bookType.equals("전자책") && !bookType.equals("오디오북")) {
            System.out.println("│ 재고: " + stock + "권");
        }
        if (isbn != null) {
            System.out.println("│ ISBN: " + isbn);
        }
        if (pageCount > 0) {
            System.out.println("│ 페이지 수: " + pageCount);
        }
        if (reviewCount > 0) {
            System.out.println("│ 평점: " + String.format("%.1f", rating) +
                              "점 (" + reviewCount + "개 리뷰)");
        }
        System.out.println("└─────────────────────────────────\n");
    }
}
```

---

#### 파일 3: Order.java (주문 클래스)

```java
public class Order {
    String orderId;
    String customerId;
    String[] bookIds;
    int[] quantities;
    int totalPrice;
    int discountAmount;
    int pointsUsed;
    int finalPrice;
    String orderStatus;  // 주문완료, 배송중, 배송완료
    String orderDate;

    // 생성자 1: 단일 도서 주문
    public Order(String customerId, String bookId, int quantity, int bookPrice) {
        this.orderId = generateOrderId();
        this.customerId = customerId;
        this.bookIds = new String[]{bookId};
        this.quantities = new int[]{quantity};
        this.totalPrice = bookPrice * quantity;
        this.discountAmount = 0;
        this.pointsUsed = 0;
        this.finalPrice = this.totalPrice;
        this.orderStatus = "주문완료";
        this.orderDate = getCurrentDate();

        System.out.println("✓ 주문 생성: " + orderId);
        System.out.println("  총 금액: " + finalPrice + "원");
    }

    // 생성자 2: 다중 도서 주문 (장바구니)
    public Order(String customerId, String[] bookIds, int[] quantities, int totalPrice) {
        this.orderId = generateOrderId();
        this.customerId = customerId;
        this.bookIds = bookIds;
        this.quantities = quantities;
        this.totalPrice = totalPrice;
        this.discountAmount = 0;
        this.pointsUsed = 0;
        this.finalPrice = this.totalPrice;
        this.orderStatus = "주문완료";
        this.orderDate = getCurrentDate();

        System.out.println("✓ 장바구니 주문: " + orderId);
        System.out.println("  도서 " + bookIds.length + "권, 총 " + finalPrice + "원");
    }

    // 생성자 3: 할인 적용 주문
    public Order(String customerId, String[] bookIds, int[] quantities,
                 int totalPrice, double discountRate) {
        this(customerId, bookIds, quantities, totalPrice);
        this.discountAmount = (int)(totalPrice * discountRate);
        this.finalPrice = this.totalPrice - this.discountAmount;

        System.out.println("  🏷️ 회원 할인: -" + discountAmount + "원");
        System.out.println("  최종 금액: " + finalPrice + "원");
    }

    // 생성자 4: 할인 + 포인트 사용 주문
    public Order(String customerId, String[] bookIds, int[] quantities,
                 int totalPrice, double discountRate, int pointsUsed) {
        this(customerId, bookIds, quantities, totalPrice, discountRate);
        this.pointsUsed = pointsUsed;
        this.finalPrice -= pointsUsed;

        System.out.println("  💰 포인트 사용: -" + pointsUsed + "점");
        System.out.println("  최종 결제: " + finalPrice + "원");
    }

    private String generateOrderId() {
        return "ORD" + System.currentTimeMillis();
    }

    private String getCurrentDate() {
        return "2024-01-15";
    }

    void ship() {
        if (!orderStatus.equals("주문완료")) {
            System.out.println("❌ 이미 배송 중이거나 완료된 주문입니다");
            return;
        }

        this.orderStatus = "배송중";
        System.out.println("📦 배송 시작: " + orderId);
    }

    void complete() {
        if (!orderStatus.equals("배송중")) {
            System.out.println("❌ 배송 중인 주문만 완료할 수 있습니다");
            return;
        }

        this.orderStatus = "배송완료";
        System.out.println("✅ 배송 완료: " + orderId);
    }

    int calculateEarnedPoints() {
        return finalPrice / 100;  // 결제 금액의 1% 적립
    }

    void displayOrderInfo() {
        System.out.println("\n╔════════════════════════════════════╗");
        System.out.println("║          주문 상세 정보            ║");
        System.out.println("╠════════════════════════════════════╣");
        System.out.println("║ 주문번호: " + orderId);
        System.out.println("║ 고객 ID: " + customerId);
        System.out.println("║ 주문 상태: " + orderStatus);
        System.out.println("║");
        System.out.println("║ [주문 상품]");
        for (int i = 0; i < bookIds.length; i++) {
            System.out.println("║   " + (i+1) + ". " + bookIds[i] +
                              " (수량: " + quantities[i] + ")");
        }
        System.out.println("║");
        System.out.println("║ [결제 정보]");
        System.out.println("║ 상품 금액: " + totalPrice + "원");
        if (discountAmount > 0) {
            System.out.println("║ 회원 할인: -" + discountAmount + "원");
        }
        if (pointsUsed > 0) {
            System.out.println("║ 포인트 사용: -" + pointsUsed + "점");
        }
        System.out.println("║ 최종 결제: " + finalPrice + "원");
        System.out.println("║ 적립 예정: " + calculateEarnedPoints() + "점");
        System.out.println("║");
        System.out.println("║ 주문일: " + orderDate);
        System.out.println("╚════════════════════════════════════╝\n");
    }
}
```

---

#### 파일 4: BookstoreSystem.java (메인 시스템)

```java
public class BookstoreSystem {
    public static void main(String[] args) {
        System.out.println("╔════════════════════════════════════════╗");
        System.out.println("║     온라인 서점 시스템 v1.0            ║");
        System.out.println("╚════════════════════════════════════════╝\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 1: 회원가입
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("【 시나리오 1: 회원가입 】");
        System.out.println("─".repeat(50));

        Customer customer1 = new Customer("김철수", "kim@email.com", "pass123");
        customer1.displayCustomerInfo();

        Customer customer2 = new Customer("이영희", "lee@email.com", "pass456", "프리미엄");
        customer2.displayCustomerInfo();

        Customer customer3 = new Customer("박학생", "park@email.com", "pass789", "학생");
        customer3.displayCustomerInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 2: 도서 등록
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 2: 도서 등록 】");
        System.out.println("─".repeat(50));

        Book book1 = new Book("자바의 정석", "남궁성", "도우출판", 30000,
                              "978-89-6626-235-7", 1058);
        book1.displayBookInfo();

        Book book2 = new Book("클린 코드", "로버트 마틴", "인사이트", 29000);
        book2.displayBookInfo();

        Book book3 = new Book("이펙티브 자바", "조슈아 블로크", "인사이트", 36000, "전자책");
        book3.displayBookInfo();

        Book book4 = new Book("코딩 인터뷰 완전 분석", "게일 맥도웰", "프로그래밍인사이트",
                              28000, "오디오북");
        book4.displayBookInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 3: 리뷰 작성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 3: 리뷰 작성 】");
        System.out.println("─".repeat(50));

        book1.addReview(5.0);
        book1.addReview(4.5);
        book1.addReview(4.0);
        book1.displayBookInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 4: 일반 회원 주문 (할인 없음)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 4: 일반 회원 주문 】");
        System.out.println("─".repeat(50));

        // 단일 도서 구매
        boolean purchased1 = book1.purchase(1);
        if (purchased1) {
            Order order1 = new Order(customer1.customerId, book1.bookId, 1, book1.price);
            order1.displayOrderInfo();

            // 포인트 적립
            int earnedPoints = order1.calculateEarnedPoints();
            customer1.addPoints(earnedPoints);
            customer1.purchaseCount++;
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 5: 프리미엄 회원 다중 주문 (할인 적용)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 5: 프리미엄 회원 장바구니 주문 】");
        System.out.println("─".repeat(50));

        String[] cartBooks = {book2.bookId, book3.bookId};
        int[] cartQuantities = {1, 1};
        int cartTotal = book2.price + book3.price;

        boolean purchased2 = book2.purchase(1);
        boolean purchased3 = book3.purchase(1);

        if (purchased2 && purchased3) {
            // 프리미엄 회원 10% 할인 적용
            Order order2 = new Order(customer2.customerId, cartBooks, cartQuantities,
                                     cartTotal, customer2.discountRate);
            order2.displayOrderInfo();

            int earnedPoints = order2.calculateEarnedPoints();
            customer2.addPoints(earnedPoints);
            customer2.purchaseCount++;
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 6: 학생 회원 주문 (할인 + 포인트 사용)
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 6: 학생 회원 주문 (포인트 사용) 】");
        System.out.println("─".repeat(50));

        boolean purchased4 = book4.purchase(1);
        if (purchased4) {
            // 학생 할인 5% + 포인트 2000점 사용
            String[] orderBooks = {book4.bookId};
            int[] orderQuantities = {1};

            Order order3 = new Order(customer3.customerId, orderBooks, orderQuantities,
                                     book4.price, customer3.discountRate, 2000);
            order3.displayOrderInfo();

            int earnedPoints = order3.calculateEarnedPoints();
            customer3.addPoints(earnedPoints - 2000);  // 사용한 포인트 차감
            customer3.purchaseCount++;
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 7: 주문 배송 처리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 7: 주문 배송 처리 】");
        System.out.println("─".repeat(50));

        String[] deliveryBooks = {book1.bookId};
        int[] deliveryQuantities = {2};
        book1.purchase(2);

        Order order4 = new Order(customer1.customerId, deliveryBooks,
                                 deliveryQuantities, book1.price * 2);
        order4.displayOrderInfo();

        order4.ship();
        System.out.println();
        order4.complete();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시나리오 8: 재고 부족 처리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시나리오 8: 재고 부족 처리 】");
        System.out.println("─".repeat(50));

        book2.displayBookInfo();
        System.out.println("재고보다 많은 수량 구매 시도...");
        boolean purchased5 = book2.purchase(20);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 최종 회원 정보 확인
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 최종 회원 정보 】");
        System.out.println("─".repeat(50));

        customer1.displayCustomerInfo();
        customer2.displayCustomerInfo();
        customer3.displayCustomerInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 시스템 통계
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        System.out.println("\n【 시스템 통계 】");
        System.out.println("─".repeat(50));
        System.out.println("총 회원 수: 3명");
        System.out.println("총 도서 수: 4권");
        System.out.println("총 주문 수: 4건");
        System.out.println("─".repeat(50));
    }
}
```

**프로젝트 핵심 포인트:**

1. **생성자 오버로딩 활용**
   - 회원: 일반/프리미엄/학생 등급별 생성자
   - 도서: 일반/전자책/오디오북 타입별 생성자
   - 주문: 단일/다중/할인/포인트 사용 생성자

2. **this() 체이닝으로 코드 재사용**
   - 간단한 생성자가 복잡한 생성자 호출
   - 중복 코드 제거

3. **비즈니스 로직 구현**
   - 프리미엄 회원 자동 할인율 적용
   - 전자책 무제한 재고 처리
   - 포인트 자동 적립

---

## 자주 묻는 질문 (FAQ)

### FAQ 1: 생성자와 메서드의 차이는 무엇인가요?

**답변:**

```java
public class User {
    String name;

    // 생성자
    public User(String name) {  // 클래스 이름과 동일
        this.name = name;       // 반환 타입 없음
    }                           // new 키워드와 함께 자동 호출

    // 메서드
    public void setName(String name) {  // 메서드 이름 자유
        this.name = name;               // 반환 타입 필요 (void)
    }                                   // 명시적으로 호출
}

// 사용
User user = new User("김철수");  // 생성자 호출
user.setName("이영희");         // 메서드 호출
```

**핵심 차이:**

| 특성 | 생성자 | 메서드 |
|------|--------|--------|
| 이름 | 클래스 이름과 동일 | 자유롭게 작명 |
| 반환 타입 | 없음 (void도 안 씀) | 반드시 있어야 함 |
| 호출 시점 | 객체 생성 시 자동 | 명시적으로 호출 |
| 용도 | 초기화 | 동작 수행 |
| 상속 | 상속 안 됨 | 상속 됨 |

---

### FAQ 2: 기본 생성자는 언제 자동으로 생성되나요?

**답변:**

```java
// 케이스 1: 생성자를 하나도 정의하지 않은 경우
public class Student {
    String name;
    int grade;
}

// 컴파일러가 자동으로 추가:
// public Student() { }

// 사용 가능:
Student s = new Student();  // ✅ 정상


// 케이스 2: 생성자를 하나라도 정의한 경우
public class Teacher {
    String name;

    public Teacher(String name) {
        this.name = name;
    }
}

// 컴파일러가 기본 생성자를 추가하지 않음!

// 사용 불가:
Teacher t = new Teacher();  // ❌ 컴파일 에러
```

**규칙:**
- ✅ 생성자를 **하나도** 정의하지 않으면 → 기본 생성자 자동 생성
- ❌ 생성자를 **하나라도** 정의하면 → 기본 생성자 자동 생성 안 됨

**해결책:**
```java
public class Teacher {
    String name;

    // 기본 생성자 명시적 추가
    public Teacher() {
        this.name = "미정";
    }

    public Teacher(String name) {
        this.name = name;
    }
}

// 이제 둘 다 가능:
Teacher t1 = new Teacher();          // ✅ 정상
Teacher t2 = new Teacher("김선생");   // ✅ 정상
```

---

### FAQ 3: this()는 왜 첫 번째 줄에만 와야 하나요?

**답변:**

**이유: 객체 초기화 순서를 보장하기 위해**

```java
// ❌ 잘못된 예시
public class Book {
    String title;
    int price;

    public Book(String title, int price) {
        this.title = title;
        this.price = price;
    }

    public Book(String title) {
        this.title = title + " (특별판)";  // 필드 수정
        this(title, 10000);  // ❌ this()가 첫 줄이 아님
                             // this()가 title을 덮어쓸 수 있음!
    }
}
```

**만약 this()를 중간에 허용하면:**
```
1. this.title = title + " (특별판)" → title = "자바의 정석 (특별판)"
2. this(title, 10000) 호출 → title = "자바의 정석" (원래 값으로 되돌림!)
```

**올바른 사용:**
```java
public class Book {
    String title;
    int price;

    public Book(String title, int price) {
        this.title = title;
        this.price = price;
    }

    public Book(String title) {
        this(title, 10000);  // ✅ 첫 번째 줄
        // 이후에 추가 로직 가능
        System.out.println("기본 가격으로 설정됨");
    }
}
```

**핵심:**
- this()는 다른 생성자를 호출 → 전체 초기화 수행
- 초기화 전에 필드를 수정하면 혼란 발생
- 첫 번째 줄 규칙으로 명확한 초기화 순서 보장

---

### FAQ 4: 생성자에서 메서드를 호출해도 되나요?

**답변:**

**일반 메서드 호출은 가능하지만 주의 필요**

```java
public class User {
    String username;
    String email;

    public User(String username, String email) {
        this.username = username;
        this.email = email;

        // ✅ 일반 메서드 호출 가능
        validateEmail();
        sendWelcomeEmail();
    }

    private void validateEmail() {
        if (!email.contains("@")) {
            throw new IllegalArgumentException("잘못된 이메일 형식");
        }
    }

    private void sendWelcomeEmail() {
        System.out.println("환영 이메일 발송: " + email);
    }
}
```

**주의사항: 상속 시 문제 발생 가능**

```java
class Animal {
    public Animal() {
        makeSound();  // ⚠️ 위험!
    }

    void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String breed) {
        super();  // Animal 생성자 호출
        this.breed = breed;
    }

    @Override
    void makeSound() {
        System.out.println(breed + "가 짖습니다");  // ❌ breed가 아직 null!
    }
}

// 실행:
Dog dog = new Dog("진돗개");
// 출력: null가 짖습니다 (breed가 초기화 전!)
```

**권장 사항:**
- ✅ 생성자에서 **private final 메서드** 호출은 안전
- ✅ **유효성 검사** 메서드는 OK
- ⚠️ **오버라이드 가능한 메서드** 호출은 위험
- ⚠️ **외부 의존성 있는 메서드** 주의

---

### FAQ 5: 생성자를 private으로 만들 수 있나요?

**답변:**

**가능하며, 특정 디자인 패턴에서 사용됨**

**용도 1: 싱글톤 패턴**
```java
public class DatabaseConnection {
    private static DatabaseConnection instance;

    // private 생성자 → 외부에서 new 불가
    private DatabaseConnection() {
        System.out.println("DB 연결 생성");
    }

    // 유일한 인스턴스 반환
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}

// 사용:
DatabaseConnection db1 = DatabaseConnection.getInstance();
DatabaseConnection db2 = DatabaseConnection.getInstance();
// db1과 db2는 같은 객체!
```

**용도 2: 정적 팩토리 메서드**
```java
public class User {
    private String username;
    private String role;

    // private 생성자
    private User(String username, String role) {
        this.username = username;
        this.role = role;
    }

    // 정적 팩토리 메서드
    public static User createAdmin(String username) {
        return new User(username, "ADMIN");
    }

    public static User createGuest(String username) {
        return new User(username, "GUEST");
    }
}

// 사용:
User admin = User.createAdmin("admin123");
User guest = User.createGuest("guest456");
```

**용도 3: 유틸리티 클래스**
```java
public class MathUtils {
    // private 생성자 → 인스턴스화 방지
    private MathUtils() {
        throw new AssertionError("유틸리티 클래스는 인스턴스화할 수 없습니다");
    }

    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }
}

// 사용:
int result = MathUtils.add(5, 3);  // ✅ 정적 메서드 사용
// MathUtils util = new MathUtils();  // ❌ 컴파일 에러
```

**핵심:**
- private 생성자 = 외부에서 객체 생성 차단
- 인스턴스 생성을 클래스 내부에서만 제어
- 싱글톤, 팩토리, 유틸리티 클래스에 활용

---

### FAQ 6: 생성자에서 예외를 던져도 되나요?

**답변:**

**가능하며, 유효성 검사에 자주 사용됨**

```java
public class BankAccount {
    String accountNumber;
    long balance;

    public BankAccount(String accountNumber, long initialBalance) {
        // 유효성 검사
        if (accountNumber == null || accountNumber.isEmpty()) {
            throw new IllegalArgumentException("계좌번호는 필수입니다");
        }

        if (initialBalance < 0) {
            throw new IllegalArgumentException("초기 잔액은 0 이상이어야 합니다");
        }

        if (initialBalance > 10000000) {
            throw new IllegalArgumentException("초기 잔액은 1천만원을 초과할 수 없습니다");
        }

        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }
}

// 사용:
try {
    BankAccount acc1 = new BankAccount("1234", 5000);     // ✅ 정상
    BankAccount acc2 = new BankAccount("", 5000);         // ❌ 예외 발생
    BankAccount acc3 = new BankAccount("1234", -1000);    // ❌ 예외 발생
    BankAccount acc4 = new BankAccount("1234", 20000000); // ❌ 예외 발생
} catch (IllegalArgumentException e) {
    System.out.println("오류: " + e.getMessage());
}
```

**장점:**
- 잘못된 상태의 객체 생성 방지
- 객체 생성 시점에 오류 조기 발견
- 불변 객체 만들 때 필수

**주의사항:**
```java
public class Resource {
    public Resource() throws IOException {
        // 파일 열기, DB 연결 등
        // ⚠️ 예외 발생 시 객체가 불완전한 상태로 남을 수 있음
    }

    // 권장: 별도의 초기화 메서드 사용
    public void initialize() throws IOException {
        // 리소스 초기화
    }

    public void close() {
        // 리소스 정리
    }
}

// 사용:
Resource res = new Resource();
try {
    res.initialize();
    // 사용...
} finally {
    res.close();
}
```

---

### FAQ 7: 생성자를 여러 개 만들면 성능에 문제가 있나요?

**답변:**

**아니요, 성능 문제 없습니다**

```java
public class Product {
    String name;
    int price;
    int stock;

    // 생성자 10개를 만들어도 성능 문제 없음
    public Product(String name) { ... }
    public Product(String name, int price) { ... }
    public Product(String name, int price, int stock) { ... }
    // ... 더 많은 생성자
}
```

**이유:**
1. **컴파일 시점에 결정**
   - 어떤 생성자를 호출할지 컴파일 시 결정됨
   - 런타임 오버헤드 없음

2. **메모리 효율적**
   - 생성자는 코드 영역에 저장됨
   - 객체마다 복사되지 않음

3. **this() 체이닝 활용**
   - 중복 코드 없이 효율적으로 재사용

```java
public class Example {
    // 메인 생성자 (모든 초기화 로직)
    public Example(int a, int b, int c) {
        // 초기화...
    }

    // 나머지는 this()로 메인 호출
    public Example(int a) {
        this(a, 0, 0);  // 빠르게 메인 생성자 호출
    }

    public Example(int a, int b) {
        this(a, b, 0);
    }
}
```

**실제 성능 측정:**
```java
// 100만 번 객체 생성
long start = System.currentTimeMillis();
for (int i = 0; i < 1000000; i++) {
    Product p = new Product("상품", 1000, 10);
}
long end = System.currentTimeMillis();
System.out.println("소요 시간: " + (end - start) + "ms");
// 결과: 생성자 개수와 무관하게 매우 빠름 (수십 ms)
```

**결론:**
- ✅ 생성자 개수 ≠ 성능 저하
- ✅ 오히려 사용성 향상
- ✅ this() 체이닝으로 유지보수성 향상

---

## 면접 질문

### 주니어 레벨 (1-7)

#### Q1. 생성자란 무엇이며, 일반 메서드와 어떻게 다른가요?

**모범 답변:**

생성자는 객체가 생성될 때 자동으로 호출되는 특별한 메서드로, 객체의 초기 상태를 설정하는 역할을 합니다.

**일반 메서드와의 차이점:**

1. **이름**: 생성자는 클래스 이름과 동일해야 하지만, 메서드는 자유롭게 작명 가능합니다.

2. **반환 타입**: 생성자는 반환 타입이 없지만 (void도 쓰지 않음), 메서드는 반드시 반환 타입을 명시해야 합니다.

3. **호출 방식**: 생성자는 new 키워드와 함께 객체 생성 시 자동으로 호출되지만, 메서드는 명시적으로 호출해야 합니다.

```java
public class User {
    String name;

    // 생성자
    public User(String name) {
        this.name = name;
    }

    // 메서드
    public void setName(String name) {
        this.name = name;
    }
}

User user = new User("김철수");  // 생성자 호출
user.setName("이영희");         // 메서드 호출
```

---

#### Q2. 기본 생성자는 언제 자동으로 생성되나요?

**모범 답변:**

기본 생성자는 클래스에 **생성자를 하나도 정의하지 않은 경우**에만 컴파일러가 자동으로 추가합니다.

```java
// 케이스 1: 생성자 없음 → 기본 생성자 자동 생성
public class Student {
    String name;
}
// 컴파일러가 추가: public Student() { }

// 케이스 2: 생성자 있음 → 기본 생성자 자동 생성 안 됨
public class Teacher {
    String name;

    public Teacher(String name) {
        this.name = name;
    }
}
// 기본 생성자 없음! new Teacher() 사용 불가
```

따라서 매개변수가 있는 생성자를 추가하면서도 기본 생성자를 사용하고 싶다면, 명시적으로 기본 생성자를 작성해야 합니다.

---

#### Q3. this 키워드와 this() 메서드의 차이는 무엇인가요?

**모범 답변:**

**this 키워드**는 현재 객체 자신을 가리키는 참조 변수이고,
**this() 메서드**는 같은 클래스의 다른 생성자를 호출하는 문법입니다.

```java
public class Book {
    String title;
    int price;

    public Book(String title, int price) {
        this.title = title;  // this 키워드: 현재 객체의 title 필드
        this.price = price;  // this 키워드: 현재 객체의 price 필드
    }

    public Book(String title) {
        this(title, 10000);  // this() 메서드: 다른 생성자 호출
    }
}
```

**차이점:**
- **this**: 필드와 매개변수를 구분, 메서드 체이닝 등에 사용
- **this()**: 생성자 오버로딩 시 코드 재사용, 반드시 첫 줄에 위치

---

#### Q4. 생성자 오버로딩이란 무엇이며, 어떻게 구분하나요?

**모범 답변:**

생성자 오버로딩은 같은 클래스에서 매개변수의 **타입, 개수, 순서**가 다른 여러 개의 생성자를 정의하는 것입니다.

```java
public class Account {
    String accountNumber;
    String owner;
    long balance;

    // 생성자 1: 매개변수 1개
    public Account(String accountNumber) {
        this.accountNumber = accountNumber;
        this.owner = "미정";
        this.balance = 0;
    }

    // 생성자 2: 매개변수 2개
    public Account(String accountNumber, String owner) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.balance = 0;
    }

    // 생성자 3: 매개변수 3개
    public Account(String accountNumber, String owner, long balance) {
        this.accountNumber = accountNumber;
        this.owner = owner;
        this.balance = balance;
    }
}
```

**구분 기준:**
- ✅ 매개변수 개수
- ✅ 매개변수 타입
- ✅ 매개변수 순서 (타입이 다를 때)
- ❌ 매개변수 이름 (구분 불가)

---

#### Q5. 생성자에서 다른 생성자를 호출할 때 주의할 점은?

**모범 답변:**

**this()를 사용해 다른 생성자를 호출할 때 반드시 첫 번째 줄에 위치해야 합니다.**

```java
// ❌ 잘못된 예시
public class Product {
    String name;
    int price;

    public Product(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public Product(String name) {
        this.name = name;  // ❌ 에러!
        this(name, 0);     // this()가 첫 줄이 아님
    }
}

// ✅ 올바른 예시
public class Product {
    String name;
    int price;

    public Product(String name, int price) {
        this.name = name;
        this.price = price;
    }

    public Product(String name) {
        this(name, 0);  // ✅ 첫 번째 줄
        // 이후에 추가 로직 가능
    }
}
```

**추가 주의사항:**
- this()와 super()는 동시에 사용 불가 (둘 다 첫 줄이어야 하므로)
- 순환 참조 금지 (A가 B 호출, B가 A 호출)

---

#### Q6. 왜 생성자 매개변수와 필드 이름을 같게 하고 this를 사용하나요?

**모범 답변:**

**코드 가독성과 의미 명확성을 위해서입니다.**

```java
// ❌ 매개변수 이름을 다르게
public class User {
    String name;
    String email;

    public User(String n, String e) {  // n, e가 무엇인지 불명확
        name = n;
        email = e;
    }
}

// ✅ 매개변수 이름을 같게 + this 사용
public class User {
    String name;
    String email;

    public User(String name, String email) {  // 의미가 명확
        this.name = name;
        this.email = email;
    }
}
```

**장점:**
1. **가독성**: 매개변수가 어떤 필드를 초기화하는지 명확
2. **일관성**: 필드 이름과 매개변수 이름이 동일해 혼란 방지
3. **IDE 지원**: 자동 완성, 리팩토링 등 IDE 기능 향상
4. **표준 관행**: 자바 커뮤니티의 일반적인 코딩 스타일

---

#### Q7. 생성자를 private으로 만드는 이유는 무엇인가요?

**모범 답변:**

**객체 생성을 클래스 내부에서만 제어하고, 외부에서의 직접적인 인스턴스화를 방지하기 위해서입니다.**

**주요 사용 사례:**

**1. 싱글톤 패턴**
```java
public class DatabaseConnection {
    private static DatabaseConnection instance;

    private DatabaseConnection() {
        // 외부에서 new 불가
    }

    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```

**2. 유틸리티 클래스**
```java
public class MathUtils {
    private MathUtils() {
        // 인스턴스화 방지
    }

    public static int add(int a, int b) {
        return a + b;
    }
}
```

**3. 정적 팩토리 메서드**
```java
public class User {
    private User(String name, String role) {
        // ...
    }

    public static User createAdmin(String name) {
        return new User(name, "ADMIN");
    }

    public static User createGuest(String name) {
        return new User(name, "GUEST");
    }
}
```

---

### 중급 레벨 (8-12)

#### Q8. 생성자에서 오버라이드 가능한 메서드를 호출하면 안 되는 이유는?

**모범 답변:**

**하위 클래스의 필드가 아직 초기화되지 않은 상태에서 오버라이드된 메서드가 호출될 수 있기 때문입니다.**

```java
class Animal {
    public Animal() {
        System.out.println("Animal 생성자 시작");
        makeSound();  // ⚠️ 위험!
        System.out.println("Animal 생성자 끝");
    }

    void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    private String breed;

    public Dog(String breed) {
        super();  // Animal 생성자 호출
        this.breed = breed;  // 이 시점에 breed 초기화
        System.out.println("Dog 생성자 끝");
    }

    @Override
    void makeSound() {
        // breed가 아직 null인 상태에서 호출됨!
        System.out.println(breed + "가 짖습니다");
    }
}

// 실행
Dog dog = new Dog("진돗개");
```

**출력:**
```
Animal 생성자 시작
null가 짖습니다  // ❌ breed가 아직 null!
Animal 생성자 끝
Dog 생성자 끝
```

**객체 생성 순서:**
```
1. Dog 객체 생성 시작
2. super() 호출 → Animal 생성자 실행
3. Animal 생성자 안에서 makeSound() 호출
4. Dog의 오버라이드된 makeSound() 실행 (breed는 아직 null!)
5. Animal 생성자 종료
6. Dog의 breed 필드 초기화
7. Dog 생성자 종료
```

**해결 방법:**
```java
class Animal {
    public Animal() {
        // 오버라이드 가능한 메서드 대신 final 메서드 호출
        initializeSound();
    }

    private final void initializeSound() {
        System.out.println("초기화 중...");
    }
}
```

**핵심 원칙:**
- 생성자에서는 **private, final, static 메서드만** 호출
- 오버라이드 가능한 메서드는 객체 완전 초기화 후에 호출

---

#### Q9. 생성자 체이닝(Constructor Chaining)의 장점은 무엇인가요?

**모범 답변:**

**생성자 체이닝은 코드 중복을 제거하고, 초기화 로직을 한 곳에 집중시켜 유지보수성을 높입니다.**

**장점:**

**1. 코드 중복 제거**
```java
// ❌ 중복 코드 많음
public class Product {
    String name;
    int price;
    int stock;

    public Product(String name) {
        this.name = name;
        this.price = 0;
        this.stock = 0;
        System.out.println("상품 등록 완료");  // 중복
    }

    public Product(String name, int price) {
        this.name = name;
        this.price = price;
        this.stock = 0;
        System.out.println("상품 등록 완료");  // 중복
    }

    public Product(String name, int price, int stock) {
        this.name = name;
        this.price = price;
        this.stock = stock;
        System.out.println("상품 등록 완료");  // 중복
    }
}

// ✅ 체이닝으로 중복 제거
public class Product {
    String name;
    int price;
    int stock;

    public Product(String name, int price, int stock) {
        this.name = name;
        this.price = price;
        this.stock = stock;
        System.out.println("상품 등록 완료");
    }

    public Product(String name, int price) {
        this(name, price, 0);
    }

    public Product(String name) {
        this(name, 0, 0);
    }
}
```

**2. 초기화 로직 중앙화**
- 하나의 메인 생성자에서 모든 초기화 수행
- 로직 변경 시 한 곳만 수정하면 됨

**3. 유효성 검사 일관성**
```java
public class BankAccount {
    String accountNumber;
    long balance;

    // 메인 생성자: 유효성 검사
    public BankAccount(String accountNumber, long balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("잔액은 0 이상이어야 합니다");
        }
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    // 다른 생성자들은 자동으로 유효성 검사 통과
    public BankAccount(String accountNumber) {
        this(accountNumber, 0);
    }
}
```

**4. 유지보수성 향상**
- 초기화 로직 변경 시 한 곳만 수정
- 버그 발생 가능성 감소

---

#### Q10. 불변 객체(Immutable Object)를 만들 때 생성자의 역할은?

**모범 답변:**

**불변 객체는 생성자를 통해서만 초기화되며, 이후 상태 변경이 불가능합니다. 생성자는 모든 필드를 final로 초기화하는 유일한 방법입니다.**

```java
public final class ImmutablePerson {
    private final String name;
    private final int age;
    private final String address;

    // 생성자: 모든 필드 초기화 (유일한 초기화 지점)
    public ImmutablePerson(String name, int age, String address) {
        // 유효성 검사
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("이름은 필수입니다");
        }
        if (age < 0) {
            throw new IllegalArgumentException("나이는 0 이상이어야 합니다");
        }

        this.name = name;
        this.age = age;
        this.address = address;
    }

    // Getter만 제공 (Setter 없음)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getAddress() {
        return address;
    }

    // 값 변경이 필요하면 새 객체 생성
    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge, this.address);
    }
}

// 사용
ImmutablePerson person = new ImmutablePerson("김철수", 30, "서울");
// person.name = "이영희";  // ❌ 컴파일 에러 (final)
// person.setAge(31);       // ❌ 메서드 없음

ImmutablePerson older = person.withAge(31);  // ✅ 새 객체 생성
```

**불변 객체의 생성자 설계 원칙:**

1. **모든 필드를 final로 선언**
   - 생성자에서 한 번만 초기화 가능
   - 이후 변경 불가

2. **생성자에서 유효성 검사**
   - 잘못된 상태의 객체 생성 방지
   - 예외 던지기

3. **방어적 복사 (Defensive Copy)**
```java
public final class ImmutableList {
    private final int[] values;

    public ImmutableList(int[] values) {
        // 외부 배열 복사 (방어적 복사)
        this.values = new int[values.length];
        for (int i = 0; i < values.length; i++) {
            this.values[i] = values[i];
        }
    }

    public int[] getValues() {
        // 복사본 반환 (원본 보호)
        return values.clone();
    }
}
```

**불변 객체의 장점:**
- 스레드 안전 (Thread-Safe)
- 캐싱 가능
- 해시맵 키로 안전하게 사용
- 예측 가능한 동작

---

#### Q11. 정적 팩토리 메서드 vs 생성자, 각각 언제 사용하나요?

**모범 답변:**

**정적 팩토리 메서드는 생성자보다 유연하고 의미가 명확하지만, 상황에 따라 적절히 선택해야 합니다.**

**생성자 사용:**
```java
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

User user = new User("김철수", 25);
```

**정적 팩토리 메서드 사용:**
```java
public class User {
    private String name;
    private String role;

    private User(String name, String role) {
        this.name = name;
        this.role = role;
    }

    // 정적 팩토리 메서드
    public static User createAdmin(String name) {
        return new User(name, "ADMIN");
    }

    public static User createGuest(String name) {
        return new User(name, "GUEST");
    }

    public static User createModerator(String name) {
        return new User(name, "MODERATOR");
    }
}

User admin = User.createAdmin("관리자");
User guest = User.createGuest("게스트");
```

**비교표:**

| 특성 | 생성자 | 정적 팩토리 메서드 |
|------|--------|-------------------|
| **이름** | 클래스 이름으로 고정 | 의미 있는 이름 사용 가능 |
| **반환 타입** | 항상 해당 클래스 | 하위 타입 반환 가능 |
| **객체 생성** | 항상 새 인스턴스 | 캐싱, 싱글톤 가능 |
| **가독성** | 매개변수로만 구분 | 메서드 이름으로 의도 표현 |

**정적 팩토리 메서드의 장점:**

**1. 의미 있는 이름**
```java
// ❌ 생성자: 무엇을 만드는지 불명확
User user1 = new User("김철수", "ADMIN");
User user2 = new User("이영희", "GUEST");

// ✅ 팩토리: 의도가 명확
User admin = User.createAdmin("김철수");
User guest = User.createGuest("이영희");
```

**2. 같은 시그니처의 여러 생성 방법**
```java
public class Point {
    private int x, y;

    private Point(int a, int b) {
        this.x = a;
        this.y = b;
    }

    // 직교 좌표계
    public static Point fromCartesian(int x, int y) {
        return new Point(x, y);
    }

    // 극좌표계
    public static Point fromPolar(int r, int theta) {
        int x = (int)(r * Math.cos(theta));
        int y = (int)(r * Math.sin(theta));
        return new Point(x, y);
    }
}

Point p1 = Point.fromCartesian(3, 4);
Point p2 = Point.fromPolar(5, 45);
```

**3. 객체 캐싱**
```java
public class Boolean {
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    public static Boolean valueOf(boolean b) {
        return b ? TRUE : FALSE;  // 캐싱된 객체 반환
    }
}
```

**언제 무엇을 사용할까?**

**생성자 사용:**
- 간단한 객체 생성
- 항상 새 인스턴스 필요
- 단순한 데이터 클래스

**정적 팩토리 메서드 사용:**
- 의미 있는 이름이 필요한 경우
- 객체 캐싱이 필요한 경우
- 하위 타입 반환이 필요한 경우
- 같은 매개변수로 다른 방식의 생성이 필요한 경우

---

#### Q12. 생성자에서 발생할 수 있는 메모리 누수를 방지하는 방법은?

**모범 답변:**

**생성자에서 리소스를 할당하고 제대로 해제하지 않으면 메모리 누수가 발생할 수 있습니다.**

**문제 상황 1: 예외 발생 시 리소스 미해제**
```java
// ❌ 잘못된 예시
public class DatabaseConnection {
    private Connection conn;
    private Statement stmt;

    public DatabaseConnection() throws SQLException {
        conn = DriverManager.getConnection("jdbc:mysql://localhost/test");
        stmt = conn.createStatement();  // ⚠️ 여기서 예외 발생 시 conn이 닫히지 않음!
    }
}
```

**해결책 1: try-catch로 리소스 정리**
```java
// ✅ 올바른 예시
public class DatabaseConnection {
    private Connection conn;
    private Statement stmt;

    public DatabaseConnection() throws SQLException {
        try {
            conn = DriverManager.getConnection("jdbc:mysql://localhost/test");
            stmt = conn.createStatement();
        } catch (SQLException e) {
            // 예외 발생 시 리소스 정리
            if (stmt != null) stmt.close();
            if (conn != null) conn.close();
            throw e;
        }
    }

    public void close() throws SQLException {
        if (stmt != null) stmt.close();
        if (conn != null) conn.close();
    }
}
```

**문제 상황 2: 순환 참조**
```java
// ❌ 메모리 누수 가능
public class Parent {
    private Child child;

    public Parent() {
        this.child = new Child(this);  // 자식이 부모 참조
    }
}

public class Child {
    private Parent parent;  // 부모 참조 보관

    public Child(Parent parent) {
        this.parent = parent;
    }
}
```

**해결책 2: WeakReference 사용**
```java
import java.lang.ref.WeakReference;

public class Child {
    private WeakReference<Parent> parentRef;  // 약한 참조

    public Child(Parent parent) {
        this.parentRef = new WeakReference<>(parent);
    }

    public Parent getParent() {
        return parentRef.get();  // null일 수 있음
    }
}
```

**모범 사례: 빌더 패턴으로 안전한 객체 생성**
```java
public class Resource {
    private final String name;
    private final Connection conn;

    private Resource(Builder builder) throws SQLException {
        this.name = builder.name;
        this.conn = builder.conn;
    }

    public static class Builder {
        private String name;
        private Connection conn;

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setConnection(String url) throws SQLException {
            this.conn = DriverManager.getConnection(url);
            return this;
        }

        public Resource build() throws SQLException {
            // 유효성 검사
            if (name == null || conn == null) {
                // 실패 시 리소스 정리
                if (conn != null) conn.close();
                throw new IllegalStateException("필수 값 누락");
            }
            return new Resource(this);
        }
    }
}

// 사용
try {
    Resource res = new Resource.Builder()
        .setName("MyDB")
        .setConnection("jdbc:mysql://localhost/test")
        .build();
} catch (SQLException e) {
    // 예외 발생 시 Builder가 리소스 정리
}
```

**핵심 원칙:**
1. 생성자에서 예외 발생 시 할당한 리소스 반드시 해제
2. 순환 참조 주의 (필요시 WeakReference 사용)
3. 복잡한 리소스 관리는 빌더 패턴 활용
4. AutoCloseable 인터페이스 구현으로 try-with-resources 지원

---

## 마무리

### 생성자 완전 정복 체크리스트

**기본 개념:**
- ✅ 생성자의 정의와 역할 이해
- ✅ 생성자와 메서드의 차이 이해
- ✅ 기본 생성자 자동 생성 규칙 숙지
- ✅ this 키워드와 this() 메서드 구분

**중급 개념:**
- ✅ 생성자 오버로딩 활용
- ✅ this() 체이닝으로 코드 재사용
- ✅ private 생성자의 활용 (싱글톤, 팩토리)
- ✅ 생성자에서 예외 처리

**고급 개념:**
- ✅ 불변 객체와 생성자
- ✅ 정적 팩토리 메서드 vs 생성자
- ✅ 빌더 패턴
- ✅ 메모리 누수 방지

**실무 적용:**
- ✅ 비즈니스 로직을 생성자에 구현
- ✅ 유효성 검사를 생성자에서 수행
- ✅ 생성자 체이닝으로 유지보수성 향상
- ✅ 다양한 생성 패턴 활용

**다음 단계:**
Chapter 14에서는 **메서드 오버로딩**을 다룹니다!
