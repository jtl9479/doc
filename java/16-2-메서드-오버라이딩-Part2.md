# 16-2. 메서드 오버라이딩 (Method Overriding) - Part 2

## 📋 목차
1. [기업 사례 1: Netflix - 영상 재생 시스템](#기업-사례-1-netflix)
2. [기업 사례 2: Spotify - 음악 재생 시스템](#기업-사례-2-spotify)
3. [기업 사례 3: 토스 - 결제 시스템](#기업-사례-3-토스)
4. [주니어 개발자 시나리오](#주니어-개발자-시나리오)

---

## 🎬 기업 사례 1: Netflix - 영상 재생 시스템 {#기업-사례-1-netflix}

### 비즈니스 요구사항
Netflix는 영화, 드라마, 다큐멘터리 등 다양한 콘텐츠를 제공합니다. 각 콘텐츠 타입마다 재생 방식이 다르며, 시청 이력 저장 방식도 달라야 합니다.

### 메서드 오버라이딩을 활용한 설계

```java
/**
 * 모든 Netflix 콘텐츠의 부모 클래스
 */
public abstract class NetflixContent {
    protected String contentId;
    protected String title;
    protected int duration;  // 분 단위
    protected double rating;
    protected int viewCount;
    protected boolean isWatched;

    public NetflixContent(String contentId, String title, int duration) {
        this.contentId = contentId;
        this.title = title;
        this.duration = duration;
        this.rating = 0.0;
        this.viewCount = 0;
        this.isWatched = false;
    }

    // ✅ 재생 메서드 - 각 콘텐츠 타입마다 오버라이딩
    public void play() {
        System.out.println("\n▶️ 재생 중: " + title);
        System.out.println("⏱️ 재생 시간: " + duration + "분");
        viewCount++;
    }

    // ✅ 시청 이력 저장 - 각 타입마다 다르게 저장
    public void saveWatchHistory(String userId, int watchedMinutes) {
        System.out.println("📊 시청 이력 저장");
        System.out.println("사용자: " + userId);
        System.out.println("시청 시간: " + watchedMinutes + "분");

        if (watchedMinutes >= duration * 0.9) {
            isWatched = true;
            System.out.println("✅ 시청 완료로 표시됨");
        }
    }

    // ✅ 추천 알고리즘 - 각 타입마다 다른 기준
    public void recommend(String userId) {
        System.out.println("💡 추천: " + title);
    }

    public void showInfo() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📺 " + title);
        System.out.println("ID: " + contentId);
        System.out.println("⏱️ 길이: " + duration + "분");
        System.out.println("⭐ 평점: " + String.format("%.1f", rating));
        System.out.println("👁️ 조회수: " + String.format("%,d", viewCount));
        System.out.println("✓ 시청 완료: " + (isWatched ? "예" : "아니오"));
    }

    public String getTitle() { return title; }
}

/**
 * 영화 클래스
 */
public class Movie extends NetflixContent {
    private String director;
    private String[] cast;
    private String genre;
    private boolean hasPostCredit;  // 쿠키 영상 여부

    public Movie(String contentId, String title, int duration,
                 String director, String[] cast, String genre) {
        super(contentId, title, duration);
        this.director = director;
        this.cast = cast;
        this.genre = genre;
        this.hasPostCredit = false;
    }

    @Override
    public void play() {
        System.out.println("\n🎬 ═══════════════════════════");
        System.out.println("   영화 재생 시작");
        System.out.println("═══════════════════════════");
        System.out.println("제목: " + title);
        System.out.println("감독: " + director);
        System.out.print("출연: ");
        for (int i = 0; i < cast.length; i++) {
            System.out.print(cast[i]);
            if (i < cast.length - 1) System.out.print(", ");
        }
        System.out.println("\n장르: " + genre);
        System.out.println("러닝타임: " + duration + "분");

        super.play();  // 부모의 기본 재생 로직 호출

        // 영화 특화 기능
        System.out.println("\n🎥 영화 플레이어 설정:");
        System.out.println("  - 자막: 한국어");
        System.out.println("  - 화질: 4K Ultra HD");
        System.out.println("  - 사운드: Dolby Atmos");

        if (hasPostCredit) {
            System.out.println("\n⚠️ 엔딩 크레딧 후 쿠키 영상이 있습니다!");
        }
    }

    @Override
    public void saveWatchHistory(String userId, int watchedMinutes) {
        System.out.println("\n💾 영화 시청 이력 저장");
        super.saveWatchHistory(userId, watchedMinutes);

        // 영화 특화: 중단 지점 저장
        int progress = (watchedMinutes * 100) / duration;
        System.out.println("📍 재생 위치: " + progress + "%");

        if (watchedMinutes < duration && watchedMinutes > 5) {
            System.out.println("🔖 이어보기 목록에 추가됨");
        }
    }

    @Override
    public void recommend(String userId) {
        System.out.println("\n🎯 영화 추천 알고리즘");
        System.out.println("기준: 장르, 감독, 출연진 기반");
        System.out.println("💡 " + title + "을(를) 보신 분께 추천:");
        System.out.println("  - 같은 감독: " + director + " 작품");
        System.out.println("  - 같은 장르: " + genre);
    }

    public void setPostCredit(boolean has) {
        this.hasPostCredit = has;
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("🎬 감독: " + director);
        System.out.println("🎭 장르: " + genre);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 드라마(시리즈) 클래스
 */
public class Series extends NetflixContent {
    private int totalEpisodes;
    private int currentEpisode;
    private int currentSeason;
    private int totalSeasons;
    private String creator;

    public Series(String contentId, String title, int episodeDuration,
                  int totalSeasons, int totalEpisodes, String creator) {
        super(contentId, title, episodeDuration);
        this.totalSeasons = totalSeasons;
        this.totalEpisodes = totalEpisodes;
        this.currentSeason = 1;
        this.currentEpisode = 1;
        this.creator = creator;
    }

    @Override
    public void play() {
        System.out.println("\n📺 ═══════════════════════════");
        System.out.println("   드라마 재생 시작");
        System.out.println("═══════════════════════════");
        System.out.println("시리즈: " + title);
        System.out.println("제작: " + creator);
        System.out.println("재생: S" + currentSeason + "E" + currentEpisode);
        System.out.println("에피소드 길이: " + duration + "분");

        super.play();

        // 시리즈 특화 기능
        System.out.println("\n📊 시리즈 진행도:");
        int totalWatched = ((currentSeason - 1) * 10 + currentEpisode);
        int progress = (totalWatched * 100) / totalEpisodes;
        System.out.println("  - 현재: " + totalWatched + "/" + totalEpisodes + " 에피소드");
        System.out.println("  - 진행률: " + progress + "%");

        // 자동 다음 에피소드 예고
        if (currentEpisode < 10) {  // 시즌당 10개 에피소드 가정
            System.out.println("\n⏭️ 다음 에피소드 예고:");
            System.out.println("   S" + currentSeason + "E" + (currentEpisode + 1) +
                             " - 10초 후 자동 재생");
        }
    }

    @Override
    public void saveWatchHistory(String userId, int watchedMinutes) {
        System.out.println("\n💾 드라마 시청 이력 저장");
        System.out.println("시즌: " + currentSeason + ", 에피소드: " + currentEpisode);
        super.saveWatchHistory(userId, watchedMinutes);

        // 시리즈 특화: 다음 에피소드 자동 재생 설정
        if (isWatched) {
            System.out.println("✅ 에피소드 " + currentEpisode + " 시청 완료");
            if (currentEpisode < 10) {
                currentEpisode++;
                System.out.println("📺 다음 에피소드 준비됨: E" + currentEpisode);
            } else if (currentSeason < totalSeasons) {
                currentSeason++;
                currentEpisode = 1;
                System.out.println("🎊 시즌 " + currentSeason + " 잠금 해제!");
            }
            isWatched = false;  // 다음 에피소드는 미시청 상태
        }
    }

    @Override
    public void recommend(String userId) {
        System.out.println("\n🎯 드라마 추천 알고리즘");
        System.out.println("기준: 시청 패턴, 몰아보기 경향 기반");
        System.out.println("💡 " + title + "을(를) 보신 분께 추천:");
        System.out.println("  - 같은 제작자: " + creator + " 작품");
        System.out.println("  - 비슷한 몰아보기 패턴의 시리즈");
    }

    public void playNextEpisode() {
        if (currentEpisode < 10) {
            currentEpisode++;
        } else if (currentSeason < totalSeasons) {
            currentSeason++;
            currentEpisode = 1;
        }
        play();
    }

    public void binge() {
        System.out.println("\n🍿 몰아보기 모드 활성화!");
        System.out.println("시즌 " + currentSeason + " 전체 재생 시작...");
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("📺 제작: " + creator);
        System.out.println("📊 시즌: " + totalSeasons + "개");
        System.out.println("📋 에피소드: " + totalEpisodes + "개");
        System.out.println("▶️ 현재: S" + currentSeason + "E" + currentEpisode);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 다큐멘터리 클래스
 */
public class Documentary extends NetflixContent {
    private String topic;
    private String narrator;
    private boolean isEducational;

    public Documentary(String contentId, String title, int duration,
                      String topic, String narrator, boolean isEducational) {
        super(contentId, title, duration);
        this.topic = topic;
        this.narrator = narrator;
        this.isEducational = isEducational;
    }

    @Override
    public void play() {
        System.out.println("\n🎓 ═══════════════════════════");
        System.out.println("   다큐멘터리 재생 시작");
        System.out.println("═══════════════════════════");
        System.out.println("제목: " + title);
        System.out.println("주제: " + topic);
        System.out.println("내레이션: " + narrator);
        System.out.println("러닝타임: " + duration + "분");

        if (isEducational) {
            System.out.println("📚 교육용 콘텐츠");
        }

        super.play();

        // 다큐멘터리 특화 기능
        System.out.println("\n🎬 다큐멘터리 플레이어:");
        System.out.println("  - 정보 오버레이: ON");
        System.out.println("  - 챕터 네비게이션: 활성화");
        System.out.println("  - 학습 모드: " + (isEducational ? "ON" : "OFF"));
    }

    @Override
    public void saveWatchHistory(String userId, int watchedMinutes) {
        System.out.println("\n💾 다큐멘터리 시청 이력 저장");
        super.saveWatchHistory(userId, watchedMinutes);

        // 다큐멘터리 특화: 학습 진도 저장
        if (isEducational) {
            System.out.println("📚 학습 진도 기록됨");
            System.out.println("🎓 관심 주제: " + topic);

            if (isWatched) {
                System.out.println("🏆 " + topic + " 학습 완료 배지 획득!");
            }
        }
    }

    @Override
    public void recommend(String userId) {
        System.out.println("\n🎯 다큐멘터리 추천 알고리즘");
        System.out.println("기준: 관심 주제, 학습 이력 기반");
        System.out.println("💡 " + title + "을(를) 보신 분께 추천:");
        System.out.println("  - 같은 주제: " + topic);
        System.out.println("  - 같은 내레이터: " + narrator);

        if (isEducational) {
            System.out.println("  - 관련 교육 콘텐츠");
        }
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("🎓 주제: " + topic);
        System.out.println("🎙️ 내레이터: " + narrator);
        System.out.println("📚 교육용: " + (isEducational ? "예" : "아니오"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 실행 테스트

```java
public class NetflixPlaybackSystem {
    public static void main(String[] args) {
        System.out.println("🎬 ═══════════════════════════════");
        System.out.println("   Netflix 재생 시스템");
        System.out.println("═══════════════════════════════\n");

        String userId = "user123@netflix.com";

        // 1. 영화 재생
        String[] parasitecast = {"송강호", "이선균", "조여정"};
        Movie movie = new Movie(
            "MOV001",
            "기생충",
            132,
            "봉준호",
            parasitecast,
            "드라마/스릴러"
        );

        movie.showInfo();
        movie.play();
        movie.saveWatchHistory(userId, 130);
        movie.recommend(userId);

        // 2. 드라마 재생
        System.out.println("\n\n");
        Series series = new Series(
            "SER001",
            "오징어 게임",
            60,
            1,
            9,
            "황동혁"
        );

        series.showInfo();
        series.play();
        series.saveWatchHistory(userId, 58);
        series.binge();

        // 3. 다큐멘터리 재생
        System.out.println("\n\n");
        Documentary doc = new Documentary(
            "DOC001",
            "우리의 지구",
            50,
            "자연/환경",
            "데이비드 아텐버러",
            true
        );

        doc.showInfo();
        doc.play();
        doc.saveWatchHistory(userId, 50);
        doc.recommend(userId);

        // 4. 다형성 활용 - 시청 목록
        System.out.println("\n\n📋 ═══════════════════════════════");
        System.out.println("   내가 찜한 콘텐츠");
        System.out.println("═══════════════════════════════\n");

        NetflixContent[] myList = {movie, series, doc};

        for (NetflixContent content : myList) {
            System.out.println("✓ " + content.getTitle());
        }

        // 5. 일괄 재생 테스트
        System.out.println("\n\n▶️ ═══════════════════════════════");
        System.out.println("   전체 콘텐츠 재생 테스트");
        System.out.println("═══════════════════════════════");

        for (NetflixContent content : myList) {
            content.play();
            // 각 콘텐츠 타입에 맞는 play() 메서드가 호출됨!
        }

        System.out.println("\n\n💡 핵심 포인트:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ play() 메서드를 각 타입마다 오버라이딩");
        System.out.println("✅ 영화/드라마/다큐는 각자 다른 방식으로 재생");
        System.out.println("✅ 시청 이력도 각 타입에 맞게 다르게 저장");
        System.out.println("✅ 추천 알고리즘도 타입별로 다름");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **다층 오버라이딩**: `play()`, `saveWatchHistory()`, `recommend()` 모두 오버라이딩
2. **super 활용**: 자식에서 부모의 기본 로직을 호출한 후 추가 로직 실행
3. **타입별 특화**: 각 콘텐츠 타입의 특성에 맞는 재생 방식 구현
4. **실무 반영**: 실제 Netflix의 콘텐츠 재생 방식을 모델링

---

## 🎵 기업 사례 2: Spotify - 음악 재생 시스템 {#기업-사례-2-spotify}

### 비즈니스 요구사항
Spotify는 일반 트랙, 팟캐스트, 오디오북 등 다양한 오디오 콘텐츠를 제공합니다. 각 타입마다 재생 방식과 추천 알고리즘이 다릅니다.

### 메서드 오버라이딩을 활용한 설계

```java
/**
 * 모든 Spotify 오디오 콘텐츠의 부모 클래스
 */
public abstract class SpotifyAudio {
    protected String audioId;
    protected String title;
    protected int durationSeconds;
    protected long playCount;
    protected boolean isLiked;

    public SpotifyAudio(String audioId, String title, int durationSeconds) {
        this.audioId = audioId;
        this.title = title;
        this.durationSeconds = durationSeconds;
        this.playCount = 0;
        this.isLiked = false;
    }

    // ✅ 재생 메서드 - 오버라이딩 대상
    public void play() {
        System.out.println("\n▶️ 재생: " + title);
        System.out.println("⏱️ " + formatDuration(durationSeconds));
        playCount++;
    }

    // ✅ 다음 트랙 선택 - 각 타입마다 다른 로직
    public void selectNext() {
        System.out.println("🔀 다음 트랙 선택 중...");
    }

    // ✅ 플레이리스트 추가 - 타입별로 다른 플레이리스트
    public void addToPlaylist(String playlistName) {
        System.out.println("➕ '" + playlistName + "'에 추가됨");
    }

    protected String formatDuration(int seconds) {
        int minutes = seconds / 60;
        int secs = seconds % 60;
        return String.format("%d:%02d", minutes, secs);
    }

    public void like() {
        isLiked = true;
        System.out.println("❤️ 좋아요!");
    }

    public String getTitle() { return title; }
}

/**
 * 음악 트랙
 */
public class MusicTrack extends SpotifyAudio {
    private String artist;
    private String album;
    private String genre;
    private int bpm;  // Beats Per Minute

    public MusicTrack(String audioId, String title, int durationSeconds,
                     String artist, String album, String genre, int bpm) {
        super(audioId, title, durationSeconds);
        this.artist = artist;
        this.album = album;
        this.genre = genre;
        this.bpm = bpm;
    }

    @Override
    public void play() {
        System.out.println("\n🎵 ═══════════════════════════");
        System.out.println("   음악 재생");
        System.out.println("═══════════════════════════");
        System.out.println("🎤 " + title);
        System.out.println("👤 " + artist);
        System.out.println("💿 " + album);
        System.out.println("🎸 " + genre);
        System.out.println("⏱️ " + formatDuration(durationSeconds));
        System.out.println("💓 BPM: " + bpm);

        super.play();

        // 음악 특화 기능
        System.out.println("\n🎧 오디오 설정:");
        System.out.println("  - 이퀄라이저: Pop");
        System.out.println("  - 크로스페이드: 5초");
        System.out.println("  - 가사 표시: ON");

        showLyrics();
    }

    private void showLyrics() {
        System.out.println("\n📝 가사 동기화 중...");
        System.out.println("♪ 실시간 가사 표시 활성화");
    }

    @Override
    public void selectNext() {
        System.out.println("\n🎵 다음 트랙 선택 알고리즘");
        System.out.println("기준: 같은 아티스트, 장르, BPM 유사도");
        System.out.println("💡 추천:");
        System.out.println("  - " + artist + "의 다른 곡");
        System.out.println("  - 같은 " + genre + " 장르");
        System.out.println("  - BPM " + (bpm - 10) + "-" + (bpm + 10) + " 범위");
    }

    @Override
    public void addToPlaylist(String playlistName) {
        System.out.println("\n🎶 플레이리스트에 추가");
        System.out.println("트랙: " + title + " - " + artist);
        super.addToPlaylist(playlistName);
        System.out.println("🔀 플레이리스트 순서 최적화됨");
    }

    public void addToQueue() {
        System.out.println("🔜 대기열에 추가: " + title);
    }

    public void showSimilarSongs() {
        System.out.println("\n🎯 비슷한 노래:");
        System.out.println("  - 같은 아티스트 곡");
        System.out.println("  - 같은 앨범 곡");
        System.out.println("  - 같은 장르: " + genre);
    }
}

/**
 * 팟캐스트 에피소드
 */
public class PodcastEpisode extends SpotifyAudio {
    private String podcastName;
    private String host;
    private int episodeNumber;
    private String releaseDate;
    private int lastPosition;  // 마지막 재생 위치 (초)

    public PodcastEpisode(String audioId, String title, int durationSeconds,
                         String podcastName, String host, int episodeNumber) {
        super(audioId, title, durationSeconds);
        this.podcastName = podcastName;
        this.host = host;
        this.episodeNumber = episodeNumber;
        this.lastPosition = 0;
    }

    @Override
    public void play() {
        System.out.println("\n🎙️ ═══════════════════════════");
        System.out.println("   팟캐스트 재생");
        System.out.println("═══════════════════════════");
        System.out.println("📻 " + podcastName);
        System.out.println("🎬 에피소드 " + episodeNumber + ": " + title);
        System.out.println("👤 진행자: " + host);
        System.out.println("⏱️ " + formatDuration(durationSeconds));

        super.play();

        // 팟캐스트 특화 기능
        if (lastPosition > 0) {
            System.out.println("\n🔖 이어듣기:");
            System.out.println("  마지막 위치: " + formatDuration(lastPosition));
            System.out.println("  " + formatDuration(lastPosition) + "부터 재생");
        }

        System.out.println("\n⏩ 재생 속도: 1.0x");
        System.out.println("⏭️ 15초 건너뛰기 활성화");
        System.out.println("⏮️ 15초 되감기 활성화");
    }

    @Override
    public void selectNext() {
        System.out.println("\n📻 다음 에피소드 선택");
        System.out.println("💡 자동 재생:");
        System.out.println("  - " + podcastName + " 에피소드 " + (episodeNumber + 1));
        System.out.println("  - 구독한 다른 팟캐스트");
    }

    @Override
    public void addToPlaylist(String playlistName) {
        System.out.println("\n📚 팟캐스트는 '저장한 에피소드'에 추가됩니다");
        System.out.println("에피소드: " + podcastName + " - " + title);
        System.out.println("✅ 라이브러리에 저장됨");
    }

    public void setPlaybackSpeed(double speed) {
        System.out.println("⏩ 재생 속도 변경: " + speed + "x");
    }

    public void savePosition(int seconds) {
        this.lastPosition = seconds;
        System.out.println("💾 재생 위치 저장: " + formatDuration(seconds));
    }

    public void downloadForOffline() {
        System.out.println("📥 오프라인 다운로드 시작");
        System.out.println("에피소드: " + title);
        System.out.println("크기: " + (durationSeconds / 60) + " MB (예상)");
    }

    public void subscribeShow() {
        System.out.println("🔔 '" + podcastName + "' 구독 완료!");
        System.out.println("새 에피소드 알림이 활성화됩니다.");
    }
}

/**
 * 오디오북
 */
public class AudioBook extends SpotifyAudio {
    private String author;
    private String narrator;
    private int chapterCount;
    private int currentChapter;
    private String publisher;

    public AudioBook(String audioId, String title, int durationSeconds,
                    String author, String narrator, int chapterCount) {
        super(audioId, title, durationSeconds);
        this.author = author;
        this.narrator = narrator;
        this.chapterCount = chapterCount;
        this.currentChapter = 1;
    }

    @Override
    public void play() {
        System.out.println("\n📖 ═══════════════════════════");
        System.out.println("   오디오북 재생");
        System.out.println("═══════════════════════════");
        System.out.println("📚 " + title);
        System.out.println("✍️ 저자: " + author);
        System.out.println("🎙️ 낭독: " + narrator);
        System.out.println("📑 챕터 " + currentChapter + "/" + chapterCount);
        System.out.println("⏱️ 총 길이: " + formatDuration(durationSeconds));

        super.play();

        // 오디오북 특화 기능
        System.out.println("\n📖 오디오북 플레이어:");
        System.out.println("  - 수면 타이머: 30분");
        System.out.println("  - 재생 속도: 1.0x");
        System.out.println("  - 챕터 네비게이션: 활성화");
        System.out.println("  - 북마크: 가능");

        showProgress();
    }

    private void showProgress() {
        int progress = (currentChapter * 100) / chapterCount;
        System.out.println("\n📊 진행도: " + progress + "%");
        System.out.print("Progress: [");
        for (int i = 0; i < 20; i++) {
            if (i < progress / 5) {
                System.out.print("█");
            } else {
                System.out.print("░");
            }
        }
        System.out.println("] " + currentChapter + "/" + chapterCount + " 챕터");
    }

    @Override
    public void selectNext() {
        System.out.println("\n📖 다음 챕터 선택");
        if (currentChapter < chapterCount) {
            System.out.println("💡 자동 재생:");
            System.out.println("  - 챕터 " + (currentChapter + 1) + " (5초 후)");
        } else {
            System.out.println("✅ 오디오북 완독!");
            System.out.println("💡 추천: " + author + "의 다른 작품");
        }
    }

    @Override
    public void addToPlaylist(String playlistName) {
        System.out.println("\n📚 오디오북은 '내 라이브러리'에 추가됩니다");
        System.out.println("도서: " + title + " - " + author);
        System.out.println("✅ 라이브러리에 저장됨");
        System.out.println("🔖 읽던 위치 동기화 활성화");
    }

    public void nextChapter() {
        if (currentChapter < chapterCount) {
            currentChapter++;
            System.out.println("▶️ 챕터 " + currentChapter + " 재생");
        }
    }

    public void setSleepTimer(int minutes) {
        System.out.println("😴 수면 타이머 설정: " + minutes + "분 후 정지");
    }

    public void addBookmark(int position) {
        System.out.println("🔖 북마크 추가: " + formatDuration(position));
    }
}
```

### 실행 테스트

```java
public class SpotifyPlaybackSystem {
    public static void main(String[] args) {
        System.out.println("🎵 ═══════════════════════════════");
        System.out.println("   Spotify 재생 시스템");
        System.out.println("═══════════════════════════════\n");

        // 1. 음악 트랙
        MusicTrack music = new MusicTrack(
            "TRK001",
            "Dynamite",
            199,
            "BTS",
            "BE",
            "K-Pop",
            114
        );

        music.play();
        music.like();
        music.addToPlaylist("My Favorites");
        music.showSimilarSongs();
        music.selectNext();

        // 2. 팟캐스트
        System.out.println("\n\n");
        PodcastEpisode podcast = new PodcastEpisode(
            "POD001",
            "자바 개발자가 알아야 할 모든 것",
            3600,
            "개발자 토크",
            "김코딩",
            42
        );

        podcast.play();
        podcast.setPlaybackSpeed(1.5);
        podcast.savePosition(1800);
        podcast.subscribeShow();
        podcast.selectNext();

        // 3. 오디오북
        System.out.println("\n\n");
        AudioBook audiobook = new AudioBook(
            "BOOK001",
            "이펙티브 자바",
            36000,
            "조슈아 블로크",
            "김성우",
            90
        );

        audiobook.play();
        audiobook.setSleepTimer(30);
        audiobook.addBookmark(1500);
        audiobook.nextChapter();
        audiobook.selectNext();

        // 4. 다형성 활용
        System.out.println("\n\n🎶 ═══════════════════════════════");
        System.out.println("   재생 목록 통합 관리");
        System.out.println("═══════════════════════════════\n");

        SpotifyAudio[] queue = {music, podcast, audiobook};

        System.out.println("▶️ 대기열:");
        for (int i = 0; i < queue.length; i++) {
            System.out.println((i + 1) + ". " + queue[i].getTitle());
        }

        System.out.println("\n\n🔀 순차 재생:");
        for (SpotifyAudio audio : queue) {
            audio.play();
            // 각 타입에 맞는 play() 메서드가 호출됨!
        }

        System.out.println("\n\n💡 핵심 포인트:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 음악/팟캐스트/오디오북 모두 play() 메서드 보유");
        System.out.println("✅ 하지만 각각 완전히 다른 방식으로 재생");
        System.out.println("✅ selectNext()도 타입별로 다른 로직");
        System.out.println("✅ 통합 대기열로 모든 타입 관리 가능");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **타입별 특화**: 음악/팟캐스트/오디오북마다 다른 재생 경험
2. **플레이어 차별화**: 각 타입에 맞는 플레이어 기능 제공
3. **다음 콘텐츠 추천**: `selectNext()` 메서드도 타입별로 다르게 오버라이딩
4. **실무 활용**: Spotify의 실제 기능을 모델링

---

## 💳 기업 사례 3: 토스 - 결제 시스템 {#기업-사례-3-토스}

### 비즈니스 요구사항
토스는 계좌이체, 카드결제, 간편송금 등 다양한 결제 수단을 제공합니다. 각 결제 수단마다 처리 방식과 수수료 계산이 다릅니다.

### 메서드 오버라이딩을 활용한 설계

```java
/**
 * 모든 결제 수단의 부모 클래스
 */
public abstract class TossPayment {
    protected String paymentId;
    protected String userName;
    protected long amount;
    protected String status;  // pending, processing, completed, failed
    protected String createdAt;

    public TossPayment(String paymentId, String userName, long amount) {
        this.paymentId = paymentId;
        this.userName = userName;
        this.amount = amount;
        this.status = "pending";
        this.createdAt = java.time.LocalDateTime.now().toString();
    }

    // ✅ 결제 처리 - 각 수단마다 다른 프로세스
    public void processPayment() {
        System.out.println("\n💳 결제 처리 중...");
        System.out.println("사용자: " + userName);
        System.out.println("금액: " + String.format("%,d", amount) + "원");
        status = "processing";
    }

    // ✅ 수수료 계산 - 각 수단마다 다른 수수료
    public long calculateFee() {
        return 0;  // 기본 무료
    }

    // ✅ 결제 확인 - 각 수단마다 다른 확인 방법
    public void verify() {
        System.out.println("🔐 결제 확인 중...");
    }

    // ✅ 환불 처리 - 각 수단마다 다른 환불 정책
    public void refund() {
        System.out.println("💸 환불 처리 중...");
        status = "refunded";
    }

    public void showReceipt() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📄 토스 결제 영수증");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제번호: " + paymentId);
        System.out.println("사용자: " + userName);
        System.out.println("금액: " + String.format("%,d", amount) + "원");
        System.out.println("상태: " + status);
        System.out.println("일시: " + createdAt);
    }

    public String getStatus() { return status; }
}

/**
 * 계좌 이체
 */
public class BankTransfer extends TossPayment {
    private String senderBank;
    private String senderAccount;
    private String receiverBank;
    private String receiverAccount;
    private String receiverName;

    public BankTransfer(String paymentId, String userName, long amount,
                       String senderBank, String senderAccount,
                       String receiverBank, String receiverAccount,
                       String receiverName) {
        super(paymentId, userName, amount);
        this.senderBank = senderBank;
        this.senderAccount = senderAccount;
        this.receiverBank = receiverBank;
        this.receiverAccount = receiverAccount;
        this.receiverName = receiverName;
    }

    @Override
    public void processPayment() {
        System.out.println("\n🏦 ═══════════════════════════");
        System.out.println("   계좌 이체 처리");
        System.out.println("═══════════════════════════");

        super.processPayment();

        // 계좌 이체 특화 프로세스
        System.out.println("\n📤 송금 정보:");
        System.out.println("  보내는 분: " + userName);
        System.out.println("  은행: " + senderBank);
        System.out.println("  계좌: " + maskAccount(senderAccount));

        System.out.println("\n📥 받는 분:");
        System.out.println("  이름: " + receiverName);
        System.out.println("  은행: " + receiverBank);
        System.out.println("  계좌: " + maskAccount(receiverAccount));

        // 이체 단계
        System.out.println("\n🔄 처리 단계:");
        System.out.println("1️⃣ 잔액 확인 중... ✅");
        System.out.println("2️⃣ 보안 인증 중... ✅");
        System.out.println("3️⃣ 타행 조회 중... ✅");
        System.out.println("4️⃣ 이체 실행 중... ✅");

        long fee = calculateFee();
        long totalAmount = amount + fee;

        System.out.println("\n💰 금액 정산:");
        System.out.println("  송금액: " + String.format("%,d", amount) + "원");
        if (fee > 0) {
            System.out.println("  수수료: " + String.format("%,d", fee) + "원");
            System.out.println("  총액: " + String.format("%,d", totalAmount) + "원");
        }

        status = "completed";
        System.out.println("\n✅ 이체 완료!");
    }

    @Override
    public long calculateFee() {
        // 토스는 기본적으로 무료이지만, 조건에 따라 수수료 발생
        if (amount >= 100_000 && !senderBank.equals(receiverBank)) {
            return 500;  // 타행 이체 10만원 이상 시 500원
        }
        return 0;
    }

    @Override
    public void verify() {
        System.out.println("\n🔐 계좌 이체 보안 인증");
        System.out.println("1️⃣ 계좌 소유주 확인");
        System.out.println("2️⃣ 비밀번호 확인");
        System.out.println("3️⃣ SMS 인증 번호 발송");
        System.out.println("✅ 인증 완료");
    }

    @Override
    public void refund() {
        System.out.println("\n💸 계좌 이체 환불");
        System.out.println("원계좌로 자동 반환합니다.");
        System.out.println("은행: " + senderBank);
        System.out.println("계좌: " + maskAccount(senderAccount));

        super.refund();

        System.out.println("✅ 환불 완료 (1-2 영업일 소요)");
    }

    private String maskAccount(String account) {
        if (account.length() <= 4) return account;
        return account.substring(0, 3) + "****" +
               account.substring(account.length() - 2);
    }

    @Override
    public void showReceipt() {
        super.showReceipt();
        System.out.println("송금인: " + senderBank + " " + maskAccount(senderAccount));
        System.out.println("수취인: " + receiverName + " (" + receiverBank + ")");
        System.out.println("수수료: " + String.format("%,d", calculateFee()) + "원");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 신용/체크 카드 결제
 */
public class CardPayment extends TossPayment {
    private String cardCompany;
    private String cardNumber;
    private String cardType;  // credit, debit
    private int installmentMonths;  // 할부 개월 수

    public CardPayment(String paymentId, String userName, long amount,
                      String cardCompany, String cardNumber, String cardType) {
        super(paymentId, userName, amount);
        this.cardCompany = cardCompany;
        this.cardNumber = cardNumber;
        this.cardType = cardType;
        this.installmentMonths = 0;  // 일시불
    }

    @Override
    public void processPayment() {
        System.out.println("\n💳 ═══════════════════════════");
        System.out.println("   카드 결제 처리");
        System.out.println("═══════════════════════════");

        super.processPayment();

        // 카드 결제 특화 프로세스
        System.out.println("\n💳 카드 정보:");
        System.out.println("  카드사: " + cardCompany);
        System.out.println("  카드번호: " + maskCardNumber(cardNumber));
        System.out.println("  카드종류: " + (cardType.equals("credit") ? "신용카드" : "체크카드"));

        if (installmentMonths > 0) {
            System.out.println("  할부: " + installmentMonths + "개월");
            long monthlyPayment = amount / installmentMonths;
            System.out.println("  월 납입액: " + String.format("%,d", monthlyPayment) + "원");
        } else {
            System.out.println("  결제: 일시불");
        }

        // 결제 단계
        System.out.println("\n🔄 처리 단계:");
        System.out.println("1️⃣ 카드 유효성 검증... ✅");
        System.out.println("2️⃣ 한도 확인... ✅");
        System.out.println("3️⃣ VAN사 승인 요청... ✅");
        System.out.println("4️⃣ 승인번호 발급... ✅");

        status = "completed";
        System.out.println("\n✅ 카드 결제 승인!");
        System.out.println("승인번호: " + generateApprovalNumber());
    }

    @Override
    public long calculateFee() {
        // 카드사 수수료 (가맹점 부담, 고객은 무료)
        // 실제로는 가맹점이 부담하지만 예시를 위해 표시
        double feeRate = cardType.equals("credit") ? 0.025 : 0.015;
        return (long)(amount * feeRate);
    }

    @Override
    public void verify() {
        System.out.println("\n🔐 카드 결제 보안 인증");
        System.out.println("1️⃣ 카드 비밀번호 입력 (앞 2자리)");
        System.out.println("2️⃣ CVC 번호 확인");
        System.out.println("3️⃣ 3D Secure 인증");

        if (amount >= 300_000) {
            System.out.println("4️⃣ ARS 추가 인증 (30만원 이상)");
        }

        System.out.println("✅ 인증 완료");
    }

    @Override
    public void refund() {
        System.out.println("\n💸 카드 결제 취소");
        System.out.println("카드사: " + cardCompany);
        System.out.println("카드번호: " + maskCardNumber(cardNumber));

        super.refund();

        System.out.println("✅ 취소 완료");
        System.out.println("💡 카드사 정책에 따라 2-3일 소요될 수 있습니다.");
    }

    private String maskCardNumber(String cardNum) {
        return cardNum.substring(0, 4) + "-****-****-" + cardNum.substring(12);
    }

    private String generateApprovalNumber() {
        return "AP" + System.currentTimeMillis() % 100000000;
    }

    public void setInstallment(int months) {
        this.installmentMonths = months;
        System.out.println("할부 설정: " + months + "개월");
    }

    @Override
    public void showReceipt() {
        super.showReceipt();
        System.out.println("카드사: " + cardCompany);
        System.out.println("카드번호: " + maskCardNumber(cardNumber));
        System.out.println("할부: " + (installmentMonths == 0 ? "일시불" : installmentMonths + "개월"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 간편 송금 (토스 머니)
 */
public class TossMoney extends TossPayment {
    private long tossBalance;  // 토스 머니 잔액
    private String phoneNumber;
    private int bonusPoint;

    public TossMoney(String paymentId, String userName, long amount,
                    long tossBalance, String phoneNumber) {
        super(paymentId, userName, amount);
        this.tossBalance = tossBalance;
        this.phoneNumber = phoneNumber;
        this.bonusPoint = 0;
    }

    @Override
    public void processPayment() {
        System.out.println("\n💙 ═══════════════════════════");
        System.out.println("   토스 머니 결제");
        System.out.println("═══════════════════════════");

        super.processPayment();

        // 토스 머니 특화 프로세스
        System.out.println("\n💙 토스 머니 정보:");
        System.out.println("  전화번호: " + maskPhone(phoneNumber));
        System.out.println("  현재 잔액: " + String.format("%,d", tossBalance) + "원");
        System.out.println("  결제 금액: " + String.format("%,d", amount) + "원");

        // 잔액 확인
        if (tossBalance >= amount) {
            System.out.println("\n✅ 잔액 충분");

            // 즉시 결제
            System.out.println("\n🔄 처리 단계:");
            System.out.println("1️⃣ 본인 인증... ✅");
            System.out.println("2️⃣ 잔액 차감... ✅");

            tossBalance -= amount;

            // 보너스 포인트 적립
            bonusPoint = (int)(amount * 0.001);  // 0.1% 적립
            System.out.println("3️⃣ 포인트 적립... +" + bonusPoint + "P ✅");

            System.out.println("\n💰 결제 후 잔액: " + String.format("%,d", tossBalance) + "원");
            System.out.println("💎 적립 포인트: " + bonusPoint + "P");

            status = "completed";
            System.out.println("\n✅ 토스 머니 결제 완료!");
        } else {
            status = "failed";
            long shortage = amount - tossBalance;
            System.out.println("\n❌ 잔액 부족");
            System.out.println("부족 금액: " + String.format("%,d", shortage) + "원");
            System.out.println("💡 충전 후 다시 시도해주세요.");
        }
    }

    @Override
    public long calculateFee() {
        // 토스 머니는 수수료 무료
        return 0;
    }

    @Override
    public void verify() {
        System.out.println("\n🔐 토스 간편 인증");
        System.out.println("1️⃣ 지문 인증 또는");
        System.out.println("2️⃣ 6자리 비밀번호 입력");
        System.out.println("✅ 인증 완료 (0.5초 소요)");
    }

    @Override
    public void refund() {
        System.out.println("\n💸 토스 머니 환불");
        System.out.println("토스 머니 잔액으로 즉시 반환됩니다.");

        tossBalance += amount;
        super.refund();

        System.out.println("현재 잔액: " + String.format("%,d", tossBalance) + "원");
        System.out.println("✅ 환불 즉시 완료!");
    }

    private String maskPhone(String phone) {
        return phone.substring(0, 3) + "-****-" + phone.substring(9);
    }

    public void chargeMoney(long chargeAmount) {
        System.out.println("\n💵 토스 머니 충전");
        System.out.println("충전 금액: " + String.format("%,d", chargeAmount) + "원");
        tossBalance += chargeAmount;
        System.out.println("✅ 충전 완료!");
        System.out.println("현재 잔액: " + String.format("%,d", tossBalance) + "원");
    }

    @Override
    public void showReceipt() {
        super.showReceipt();
        System.out.println("결제 수단: 토스 머니");
        System.out.println("전화번호: " + maskPhone(phoneNumber));
        System.out.println("포인트 적립: " + bonusPoint + "P");
        System.out.println("수수료: 0원 (무료)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 실행 테스트

```java
public class TossPaymentSystem {
    public static void main(String[] args) {
        System.out.println("💙 ═══════════════════════════════");
        System.out.println("   토스 결제 시스템");
        System.out.println("═══════════════════════════════\n");

        // 1. 계좌 이체
        BankTransfer transfer = new BankTransfer(
            "PAY001",
            "김민수",
            150_000,
            "토스뱅크",
            "1234567890",
            "국민은행",
            "9876543210",
            "이영희"
        );

        transfer.verify();
        transfer.processPayment();
        transfer.showReceipt();

        // 2. 카드 결제
        System.out.println("\n\n");
        CardPayment card = new CardPayment(
            "PAY002",
            "박철수",
            500_000,
            "삼성카드",
            "1234567812345678",
            "credit"
        );

        card.setInstallment(3);  // 3개월 할부
        card.verify();
        card.processPayment();
        card.showReceipt();

        // 3. 토스 머니
        System.out.println("\n\n");
        TossMoney tossMoney = new TossMoney(
            "PAY003",
            "최다은",
            30_000,
            100_000,
            "01012345678"
        );

        tossMoney.verify();
        tossMoney.processPayment();
        tossMoney.showReceipt();

        // 4. 다형성 활용 - 결제 통합 관리
        System.out.println("\n\n💳 ═══════════════════════════════");
        System.out.println("   오늘의 결제 내역");
        System.out.println("═══════════════════════════════\n");

        TossPayment[] payments = {transfer, card, tossMoney};

        long totalAmount = 0;
        long totalFee = 0;

        for (int i = 0; i < payments.length; i++) {
            System.out.println((i + 1) + ". " + payments[i].userName +
                             " - " + String.format("%,d", payments[i].amount) + "원");
            totalAmount += payments[i].amount;
            totalFee += payments[i].calculateFee();
        }

        System.out.println("\n📊 결제 통계:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("총 결제 건수: " + payments.length + "건");
        System.out.println("총 결제 금액: " + String.format("%,d", totalAmount) + "원");
        System.out.println("총 수수료: " + String.format("%,d", totalFee) + "원");

        System.out.println("\n\n💡 핵심 포인트:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 모든 결제 수단이 processPayment() 메서드 보유");
        System.out.println("✅ 하지만 각 수단마다 완전히 다른 처리 프로세스");
        System.out.println("✅ 수수료 계산도 각 수단마다 다름");
        System.out.println("✅ verify()와 refund()도 각각 오버라이딩됨");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **다중 메서드 오버라이딩**: `processPayment()`, `calculateFee()`, `verify()`, `refund()` 모두 오버라이딩
2. **비즈니스 로직 반영**: 실제 토스의 결제 프로세스를 반영
3. **수수료 차별화**: 각 결제 수단마다 다른 수수료 정책
4. **통합 관리**: 다형성으로 모든 결제 수단을 통합 관리

---

## 👨‍💻 주니어 개발자가 자주 하는 실수 {#주니어-개발자-시나리오}

### 시나리오 1: @Override 어노테이션을 빼먹어서 오타 발생

```java
/**
 * ❌ 잘못된 코드 - @Override 없이 오버라이딩 시도
 */
public class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

public class Dog extends Animal {
    // ❌ @Override 없이 메서드 이름을 잘못 작성
    public void makesound() {  // 's'가 소문자! (오타)
        System.out.println("멍멍!");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // "동물 소리" 출력 (의도와 다름!)
        // ❌ makesound()는 새로운 메서드가 되어버림
    }
}
```

**문제점:**
- `makeSound()`를 오버라이딩하려 했지만 `makesound()`로 오타
- 컴파일러가 에러를 잡아주지 않음 (새로운 메서드로 인식)
- 실행 시 부모의 `makeSound()`가 호출되어 예상과 다른 결과

**해결책:**

```java
/**
 * ✅ 올바른 코드 - @Override 사용
 */
public class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

public class Dog extends Animal {
    @Override  // ✅ 어노테이션 추가
    public void makesound() {  // ❌ 오타!
        System.out.println("멍멍!");
    }
}

// 컴파일 에러 발생:
// Method does not override method from its superclass
```

**올바르게 수정:**

```java
public class Dog extends Animal {
    @Override  // ✅ 어노테이션으로 검증
    public void makeSound() {  // ✅ 정확한 이름
        System.out.println("멍멍!");
    }
}

public class OverrideAnnotationTest {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound();  // "멍멍!" 출력 ✅

        System.out.println("\n💡 @Override의 장점:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 메서드 이름 오타 방지");
        System.out.println("✅ 매개변수 타입 불일치 감지");
        System.out.println("✅ 리턴 타입 오류 감지");
        System.out.println("✅ 코드 가독성 향상");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

**교훈:**
1. **항상 @Override 어노테이션을 사용**하라
2. 컴파일 타임에 오류를 잡을 수 있음
3. 코드의 의도를 명확하게 표현
4. IDE의 자동완성 기능 활용

---

### 시나리오 2: 접근 제어자를 더 좁게 변경

```java
/**
 * ❌ 잘못된 코드 - 접근 제어자를 좁게 변경
 */
public class Parent {
    public void display() {  // public
        System.out.println("부모 클래스");
    }
}

public class Child extends Parent {
    @Override
    protected void display() {  // ❌ public → protected로 변경
        System.out.println("자식 클래스");
    }
}

// 컴파일 에러:
// Cannot reduce the visibility of the inherited method from Parent
```

**문제점:**
- 부모의 `public` 메서드를 자식에서 `protected`로 변경 시도
- 리스코프 치환 원칙 위반: 자식 객체가 부모를 대체할 수 없게 됨
- 다형성 사용 시 문제 발생

**접근 제어자 변경 규칙:**

```java
// ✅ 가능: 같거나 더 넓게
public    → public ✅
protected → protected ✅
protected → public ✅

// ❌ 불가능: 더 좁게
public    → protected ❌
public    → private ❌
protected → private ❌
```

**올바른 코드:**

```java
/**
 * ✅ 올바른 코드 - 접근 제어자 확대는 가능
 */
public class Parent {
    protected void display() {  // protected
        System.out.println("부모 클래스");
    }
}

public class Child extends Parent {
    @Override
    public void display() {  // ✅ protected → public (확대 가능)
        System.out.println("자식 클래스");
    }
}

public class AccessModifierTest {
    public static void main(String[] args) {
        Parent parent = new Parent();
        parent.display();  // protected이므로 같은 패키지에서만 접근

        Child child = new Child();
        child.display();  // public으로 확대되어 어디서나 접근 가능

        // 다형성 테스트
        Parent polymorphic = new Child();
        polymorphic.display();  // "자식 클래스" 출력 ✅

        System.out.println("\n💡 접근 제어자 오버라이딩 규칙:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 같거나 더 넓게 변경 가능");
        System.out.println("  - protected → public ✅");
        System.out.println("  - default → protected ✅");
        System.out.println("  - default → public ✅");
        System.out.println("\n❌ 더 좁게 변경 불가능");
        System.out.println("  - public → protected ❌");
        System.out.println("  - public → private ❌");
        System.out.println("  - protected → private ❌");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

**교훈:**
1. 접근 제어자는 **같거나 더 넓게**만 변경 가능
2. 리스코프 치환 원칙을 준수해야 함
3. 다형성 사용 시 문제가 없어야 함

---

### 시나리오 3: static 메서드 오버라이딩 시도

```java
/**
 * ❌ 잘못된 이해 - static 메서드는 오버라이딩되지 않음
 */
public class Parent {
    public static void display() {
        System.out.println("부모 클래스의 static 메서드");
    }
}

public class Child extends Parent {
    public static void display() {  // ❌ 오버라이딩이 아님! (메서드 숨김)
        System.out.println("자식 클래스의 static 메서드");
    }
}

public class StaticMethodTest {
    public static void main(String[] args) {
        Parent.display();  // "부모 클래스의 static 메서드"
        Child.display();   // "자식 클래스의 static 메서드"

        // ❌ 주의: 다형성이 적용되지 않음!
        Parent polymorphic = new Child();
        polymorphic.display();  // "부모 클래스의 static 메서드" 출력!
        // → 참조 타입(Parent)의 메서드가 호출됨
    }
}
```

**문제점:**
- static 메서드는 **메서드 오버라이딩이 아닌 메서드 숨김(Method Hiding)**
- 다형성이 적용되지 않음
- 참조 변수의 타입에 따라 메서드가 결정됨 (동적 바인딩 X)

**static 메서드 vs 인스턴스 메서드:**

```java
/**
 * ✅ 올바른 이해
 */
public class MethodBindingTest {
    public static void main(String[] args) {
        System.out.println("═══ 인스턴스 메서드 (오버라이딩) ═══");

        Parent1 p1 = new Child1();
        p1.instanceMethod();  // "Child1의 인스턴스 메서드"
        // → 동적 바인딩: 실제 객체 타입(Child1)의 메서드 호출

        System.out.println("\n═══ static 메서드 (메서드 숨김) ═══");

        Parent2 p2 = new Child2();
        p2.staticMethod();  // "Parent2의 static 메서드"
        // → 정적 바인딩: 참조 타입(Parent2)의 메서드 호출

        System.out.println("\n💡 핵심 차이:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("인스턴스 메서드:");
        System.out.println("  - 오버라이딩 가능 ✅");
        System.out.println("  - 동적 바인딩 (런타임에 결정)");
        System.out.println("  - 실제 객체 타입의 메서드 호출");
        System.out.println("\nstatic 메서드:");
        System.out.println("  - 오버라이딩 불가 ❌");
        System.out.println("  - 정적 바인딩 (컴파일타임에 결정)");
        System.out.println("  - 참조 변수 타입의 메서드 호출");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}

class Parent1 {
    public void instanceMethod() {
        System.out.println("Parent1의 인스턴스 메서드");
    }
}

class Child1 extends Parent1 {
    @Override
    public void instanceMethod() {
        System.out.println("Child1의 인스턴스 메서드");
    }
}

class Parent2 {
    public static void staticMethod() {
        System.out.println("Parent2의 static 메서드");
    }
}

class Child2 extends Parent2 {
    // ❌ @Override 사용 불가 (컴파일 에러)
    public static void staticMethod() {
        System.out.println("Child2의 static 메서드");
    }
}
```

**교훈:**
1. **static 메서드는 오버라이딩되지 않음**
2. static 메서드는 클래스에 속하므로 객체와 무관
3. 다형성이 필요하면 인스턴스 메서드를 사용
4. @Override를 static 메서드에 사용하면 컴파일 에러

---

### 시나리오 4: 부모 메서드를 완전히 무시

```java
/**
 * ❌ 잘못된 패턴 - 부모의 중요한 로직을 무시
 */
public class BankAccount {
    protected long balance;

    public BankAccount(long initialBalance) {
        this.balance = initialBalance;
    }

    public void withdraw(long amount) {
        // 중요한 검증 로직
        if (amount > balance) {
            System.out.println("❌ 잔액 부족!");
            return;
        }

        if (amount <= 0) {
            System.out.println("❌ 출금액은 0보다 커야 합니다!");
            return;
        }

        balance -= amount;
        System.out.println("✅ 출금 완료: " + amount + "원");
        System.out.println("💰 잔액: " + balance + "원");
    }
}

public class SavingsAccount extends BankAccount {
    private double interestRate;

    public SavingsAccount(long initialBalance, double interestRate) {
        super(initialBalance);
        this.interestRate = interestRate;
    }

    @Override
    public void withdraw(long amount) {
        // ❌ 부모의 검증 로직을 완전히 무시!
        balance -= amount;  // 직접 차감
        System.out.println("적금 출금: " + amount + "원");
        // → 잔액 부족 체크 없음!
        // → 음수 금액 체크 없음!
    }
}

public class Test {
    public static void main(String[] args) {
        SavingsAccount account = new SavingsAccount(10_000, 0.03);

        // ❌ 잔액보다 많은 금액 출금 시도
        account.withdraw(20_000);
        // → 부모의 검증 로직이 없어서 잔액이 -10,000원이 됨!

        System.out.println("잔액: " + account.balance);  // -10,000원 ❌
    }
}
```

**문제점:**
1. 부모의 중요한 검증 로직을 무시
2. 잔액이 마이너스가 되는 버그 발생
3. 음수 금액 출금 가능
4. 비즈니스 로직 일관성 깨짐

**올바른 코드:**

```java
/**
 * ✅ 올바른 코드 - super 활용
 */
public class BankAccount {
    protected long balance;
    protected int withdrawCount;  // 출금 횟수

    public BankAccount(long initialBalance) {
        this.balance = initialBalance;
        this.withdrawCount = 0;
    }

    public void withdraw(long amount) {
        System.out.println("\n🏦 일반 계좌 출금");

        // 중요한 검증 로직
        if (amount > balance) {
            System.out.println("❌ 잔액 부족!");
            System.out.println("요청 금액: " + String.format("%,d", amount) + "원");
            System.out.println("현재 잔액: " + String.format("%,d", balance) + "원");
            return;
        }

        if (amount <= 0) {
            System.out.println("❌ 출금액은 0보다 커야 합니다!");
            return;
        }

        // 출금 실행
        balance -= amount;
        withdrawCount++;

        System.out.println("✅ 출금 완료: " + String.format("%,d", amount) + "원");
        System.out.println("💰 현재 잔액: " + String.format("%,d", balance) + "원");
    }

    public void showInfo() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("잔액: " + String.format("%,d", balance) + "원");
        System.out.println("출금 횟수: " + withdrawCount + "회");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

public class SavingsAccount extends BankAccount {
    private double interestRate;
    private int freeWithdrawCount;  // 무료 출금 횟수
    private long withdrawFee;       // 출금 수수료

    public SavingsAccount(long initialBalance, double interestRate) {
        super(initialBalance);
        this.interestRate = interestRate;
        this.freeWithdrawCount = 3;  // 월 3회 무료
        this.withdrawFee = 1000;     // 수수료 1,000원
    }

    @Override
    public void withdraw(long amount) {
        System.out.println("\n💰 적금 계좌 출금");

        // ✅ 적금 특화 검증
        long totalAmount = amount;

        if (withdrawCount >= freeWithdrawCount) {
            System.out.println("⚠️ 무료 출금 횟수 초과 (수수료 발생)");
            totalAmount += withdrawFee;
            System.out.println("수수료: " + String.format("%,d", withdrawFee) + "원");
            System.out.println("총 출금액: " + String.format("%,d", totalAmount) + "원");
        }

        // ✅ 부모의 검증 로직 재사용
        super.withdraw(totalAmount);

        // ✅ 추가 로직
        if (balance > 0) {
            System.out.println("💡 적금 이율: " + (interestRate * 100) + "%");
            System.out.println("💡 무료 출금: " + (freeWithdrawCount - withdrawCount) + "회 남음");
        }
    }

    @Override
    public void showInfo() {
        super.showInfo();
        System.out.println("이자율: " + (interestRate * 100) + "%");
        System.out.println("무료 출금: " + (freeWithdrawCount - withdrawCount) + "회 남음");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

public class SuperUsageTest {
    public static void main(String[] args) {
        System.out.println("🏦 ═══════════════════════════════");
        System.out.println("   은행 계좌 시스템");
        System.out.println("═══════════════════════════════");

        SavingsAccount account = new SavingsAccount(100_000, 0.03);
        account.showInfo();

        // 1. 정상 출금
        account.withdraw(10_000);

        // 2. 두 번째 출금
        account.withdraw(20_000);

        // 3. 세 번째 출금
        account.withdraw(15_000);

        // 4. 네 번째 출금 (수수료 발생)
        account.withdraw(5_000);

        // 5. 잔액 초과 출금 시도
        account.withdraw(100_000);

        // 6. 음수 금액 출금 시도
        account.withdraw(-10_000);

        // 최종 정보
        account.showInfo();

        System.out.println("\n\n💡 super 활용의 장점:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 부모의 검증 로직 재사용");
        System.out.println("✅ 코드 중복 방지");
        System.out.println("✅ 일관성 유지");
        System.out.println("✅ 유지보수 용이");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

**실행 결과:**

```
🏦 ═══════════════════════════════
   은행 계좌 시스템
═══════════════════════════════

━━━━━━━━━━━━━━━━━━━━
잔액: 100,000원
출금 횟수: 0회
━━━━━━━━━━━━━━━━━━━━
이자율: 3.0%
무료 출금: 3회 남음
━━━━━━━━━━━━━━━━━━━━

💰 적금 계좌 출금

🏦 일반 계좌 출금
✅ 출금 완료: 10,000원
💰 현재 잔액: 90,000원
💡 적금 이율: 3.0%
💡 무료 출금: 2회 남음

[... 계속 ...]

💰 적금 계좌 출금
⚠️ 무료 출금 횟수 초과 (수수료 발생)
수수료: 1,000원
총 출금액: 6,000원

🏦 일반 계좌 출금
✅ 출금 완료: 6,000원
💰 현재 잔액: 49,000원
💡 적금 이율: 3.0%
💡 무료 출금: 0회 남음

💰 적금 계좌 출금
⚠️ 무료 출금 횟수 초과 (수수료 발생)
수수료: 1,000원
총 출금액: 101,000원

🏦 일반 계좌 출금
❌ 잔액 부족!
요청 금액: 101,000원
현재 잔액: 49,000원
```

**교훈:**
1. **super를 활용**하여 부모의 로직 재사용
2. 부모의 검증 로직을 절대 무시하지 말 것
3. 자식에서는 **추가 로직만** 구현
4. 코드 중복을 피하고 일관성 유지

---

## 📚 다음 단계

Part 3에서는 다음 내용을 다룹니다:
- **실전 프로젝트**: 메서드 오버라이딩을 활용한 게임 전투 시스템
- **FAQ**: 오버라이딩 관련 자주 묻는 질문 7개
- **면접 질문**: 주니어 7문제 + 중급 5문제

---

**작성일**: 2025-01-10
**챕터**: 16. 메서드 오버라이딩 (Method Overriding) - Part 2
