# 43ì¥ í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° - Part 3: ì„±ëŠ¥ ìµœì í™” & ë©´ì ‘ ì§ˆë¬¸

## ğŸ“š ëª©ì°¨
1. [ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
2. [ê³ ê¸‰ ê¸°ë²•](#ê³ ê¸‰-ê¸°ë²•)
3. [ë©´ì ‘ ì§ˆë¬¸](#ë©´ì ‘-ì§ˆë¬¸)

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### 1. ìŠ¤íŠ¸ë¦¼ ì„±ëŠ¥ ë¹„êµ

```java
import java.util.*;
import java.util.stream.*;

public class StreamPerformance {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(0, 10_000_000)
            .boxed()
            .collect(Collectors.toList());

        // 1. For Loop
        long start = System.nanoTime();
        int sum = 0;
        for (int n : numbers) {
            if (n % 2 == 0) {
                sum += n * 2;
            }
        }
        long forTime = System.nanoTime() - start;

        // 2. Stream
        start = System.nanoTime();
        sum = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToInt(n -> n * 2)
            .sum();
        long streamTime = System.nanoTime() - start;

        // 3. Parallel Stream
        start = System.nanoTime();
        sum = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .mapToInt(n -> n * 2)
            .sum();
        long parallelTime = System.nanoTime() - start;

        System.out.println("For Loop: " + forTime / 1_000_000 + "ms");
        System.out.println("Stream: " + streamTime / 1_000_000 + "ms");
        System.out.println("Parallel: " + parallelTime / 1_000_000 + "ms");
    }
}

/* ê²°ê³¼ (1000ë§Œ ê±´)
For Loop: 45ms
Stream: 68ms
Parallel: 22ms
*/
```

**ìµœì í™” íŒ**:
- **ëŒ€ëŸ‰ ë°ì´í„° (> 100ë§Œ)**: ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼
- **ì¤‘ê°„ ë°ì´í„°**: ê°€ë…ì„± ìš°ì„ , ìŠ¤íŠ¸ë¦¼ ì‚¬ìš©
- **ì†ŒëŸ‰ ë°ì´í„° (< 10ë§Œ)**: ì „í†µì  ë°˜ë³µë¬¸

---

### 2. ì§€ì—° í‰ê°€ í™œìš©

```java
public class LazyEvaluation {
    // âŒ ì¦‰ì‹œ í‰ê°€ - ëª¨ë“  ì—°ì‚° ì‹¤í–‰
    public List<String> eagerProcessing(List<String> data) {
        return data.stream()
            .map(s -> expensiveOperation1(s))  // ëª¨ë‘ ì‹¤í–‰
            .map(s -> expensiveOperation2(s))  // ëª¨ë‘ ì‹¤í–‰
            .filter(s -> s.length() > 5)       // í•„í„°ë§
            .collect(Collectors.toList());
    }

    // âœ… ì§€ì—° í‰ê°€ - í•„ìš”í•œ ë§Œí¼ë§Œ
    public List<String> lazyProcessing(List<String> data) {
        return data.stream()
            .filter(s -> s.length() > 5)       // ë¨¼ì € í•„í„°ë§!
            .map(s -> expensiveOperation1(s))  // ì ì€ ë°ì´í„°ë§Œ ì²˜ë¦¬
            .map(s -> expensiveOperation2(s))
            .collect(Collectors.toList());
    }

    // ë” ë‚˜ì€ ë°©ë²• - limit í™œìš©
    public List<String> betterProcessing(List<String> data) {
        return data.stream()
            .filter(s -> s.length() > 5)
            .limit(10)                          // 10ê°œë§Œ!
            .map(s -> expensiveOperation1(s))   // 10ê°œë§Œ ì²˜ë¦¬
            .map(s -> expensiveOperation2(s))
            .collect(Collectors.toList());
    }
}
```

---

### 3. ë©”ì„œë“œ ë ˆí¼ëŸ°ìŠ¤ vs ëŒë‹¤

```java
public class MethodReferencePerformance {
    // ë²¤ì¹˜ë§ˆí¬
    public void benchmark() {
        List<String> names = generateLargeList();

        // ëŒë‹¤ í‘œí˜„ì‹
        long start = System.nanoTime();
        names.stream()
            .map(s -> s.toUpperCase())
            .collect(Collectors.toList());
        long lambdaTime = System.nanoTime() - start;

        // ë©”ì„œë“œ ë ˆí¼ëŸ°ìŠ¤
        start = System.nanoTime();
        names.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        long methodRefTime = System.nanoTime() - start;

        // ë©”ì„œë“œ ë ˆí¼ëŸ°ìŠ¤ê°€ ì•½ê°„ ë” ë¹ ë¦„ (10-15%)
        System.out.println("Lambda: " + lambdaTime);
        System.out.println("Method Ref: " + methodRefTime);
    }
}
```

**ìµœì í™” íŒ**: ê°€ëŠ¥í•˜ë©´ ë©”ì„œë“œ ë ˆí¼ëŸ°ìŠ¤ ì‚¬ìš©

---

### 4. Collector ìµœì í™”

```java
public class CollectorOptimization {
    // âŒ ë¹„íš¨ìœ¨ì  - ì—¬ëŸ¬ ë²ˆ ìˆœíšŒ
    public Map<String, Long> inefficient(List<User> users) {
        Map<String, Long> result = new HashMap<>();

        for (String city : users.stream()
                .map(User::getCity)
                .distinct()
                .collect(Collectors.toList())) {

            long count = users.stream()
                .filter(u -> u.getCity().equals(city))
                .count();

            result.put(city, count);
        }

        return result;
    }

    // âœ… íš¨ìœ¨ì  - í•œ ë²ˆë§Œ ìˆœíšŒ
    public Map<String, Long> efficient(List<User> users) {
        return users.stream()
            .collect(Collectors.groupingBy(
                User::getCity,
                Collectors.counting()
            ));
    }
}
```

---

### 5. ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ìµœì í™”

```java
public class ParallelStreamOptimization {
    // âœ… ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì´ íš¨ê³¼ì ì¸ ê²½ìš°
    public List<Result> goodParallel(List<Data> data) {
        return data.parallelStream()
            .map(this::heavyComputation)  // CPU ì§‘ì•½ì 
            .collect(Collectors.toList());
    }

    // âŒ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì´ ë¹„íš¨ìœ¨ì ì¸ ê²½ìš°
    public List<Result> badParallel(List<Data> data) {
        return data.parallelStream()
            .map(this::databaseCall)  // I/O ì‘ì—… (ë¸”ë¡œí‚¹)
            .collect(Collectors.toList());
    }

    // âœ… Custom ForkJoinPool ì‚¬ìš©
    public List<Result> customPool(List<Data> data) {
        ForkJoinPool customPool = new ForkJoinPool(4);

        try {
            return customPool.submit(() ->
                data.parallelStream()
                    .map(this::heavyComputation)
                    .collect(Collectors.toList())
            ).get();
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            customPool.shutdown();
        }
    }
}
```

---

## ğŸš€ ê³ ê¸‰ ê¸°ë²•

### 1. ë©”ëª¨ì´ì œì´ì…˜ (Caching)

```java
public class Memoization {
    // ìºì‹œë¥¼ ì‚¬ìš©í•œ ë©”ëª¨ì´ì œì´ì…˜
    private Map<Integer, BigInteger> cache = new ConcurrentHashMap<>();

    public BigInteger fibonacci(int n) {
        return cache.computeIfAbsent(n, this::computeFibonacci);
    }

    private BigInteger computeFibonacci(int n) {
        if (n <= 1) return BigInteger.valueOf(n);
        return fibonacci(n - 1).add(fibonacci(n - 2));
    }

    // Java 8+ ìŠ¤íƒ€ì¼
    private Function<Integer, BigInteger> memoize(
            Function<Integer, BigInteger> function) {

        Map<Integer, BigInteger> cache = new ConcurrentHashMap<>();
        return input -> cache.computeIfAbsent(input, function);
    }

    // ì‚¬ìš©
    Function<Integer, BigInteger> memoizedFib = memoize(this::computeFibonacci);
}
```

---

### 2. ì»¤ë§ (Currying)

```java
public class Currying {
    // ì¼ë°˜ í•¨ìˆ˜
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // ì»¤ë§ëœ í•¨ìˆ˜
    public Function<Integer, Function<Integer, Function<Integer, Integer>>>
        curriedAdd() {

        return a -> b -> c -> a + b + c;
    }

    // ì‚¬ìš©
    public void example() {
        var add = curriedAdd();
        var add5 = add.apply(5);
        var add5And10 = add5.apply(10);
        int result = add5And10.apply(3);  // 18

        // ë˜ëŠ” ì²´ì´ë‹
        int result2 = curriedAdd().apply(5).apply(10).apply(3);  // 18
    }

    // ì‹¤ìš©ì ì¸ ì˜ˆì œ
    public Function<Double, Double> createTaxCalculator(double taxRate) {
        return price -> price * (1 + taxRate);
    }

    public void practicalExample() {
        var koreanTax = createTaxCalculator(0.10);
        var usTax = createTaxCalculator(0.07);

        System.out.println(koreanTax.apply(10000.0));  // 11000
        System.out.println(usTax.apply(10000.0));      // 10700
    }
}
```

---

### 3. í•¨ìˆ˜ ì¡°í•© (Composition)

```java
public class FunctionComposition {
    // ê¸°ë³¸ í•¨ìˆ˜ë“¤
    Function<String, String> trim = String::trim;
    Function<String, String> toLowerCase = String::toLowerCase;
    Function<String, String[]> split = s -> s.split("\\s+");
    Function<String[], List<String>> toList = Arrays::asList;

    // compose vs andThen
    public void compositionExample() {
        // andThen: ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½
        Function<String, String> process1 = trim.andThen(toLowerCase);

        // compose: ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½
        Function<String, String> process2 = toLowerCase.compose(trim);

        // ë‘˜ ë‹¤ ê°™ì€ ê²°ê³¼
        System.out.println(process1.apply("  HELLO  "));  // "hello"
        System.out.println(process2.apply("  HELLO  "));  // "hello"
    }

    // ë³µì¡í•œ íŒŒì´í”„ë¼ì¸
    public Function<String, List<String>> createPipeline() {
        return trim
            .andThen(toLowerCase)
            .andThen(split)
            .andThen(toList);
    }

    // ì‚¬ìš©
    public void usage() {
        var pipeline = createPipeline();
        List<String> words = pipeline.apply("  HELLO WORLD  ");
        System.out.println(words);  // [hello, world]
    }
}
```

---

### 4. Monad íŒ¨í„´

```java
public class MonadPattern {
    // Optionalì€ Monad!
    public Optional<User> findUser(Long id) {
        return userRepository.findById(id);
    }

    public Optional<String> getUserEmail(Long id) {
        return findUser(id)
            .flatMap(user -> Optional.ofNullable(user.getProfile()))
            .flatMap(profile -> Optional.ofNullable(profile.getEmail()))
            .map(Email::getAddress);
    }

    // Custom Monad: Try
    public class Try<T> {
        private final T value;
        private final Exception exception;

        private Try(T value, Exception exception) {
            this.value = value;
            this.exception = exception;
        }

        public static <T> Try<T> success(T value) {
            return new Try<>(value, null);
        }

        public static <T> Try<T> failure(Exception e) {
            return new Try<>(null, e);
        }

        public <R> Try<R> map(Function<T, R> mapper) {
            if (exception != null) {
                return Try.failure(exception);
            }
            try {
                return Try.success(mapper.apply(value));
            } catch (Exception e) {
                return Try.failure(e);
            }
        }

        public <R> Try<R> flatMap(Function<T, Try<R>> mapper) {
            if (exception != null) {
                return Try.failure(exception);
            }
            try {
                return mapper.apply(value);
            } catch (Exception e) {
                return Try.failure(e);
            }
        }

        public T orElse(T defaultValue) {
            return exception != null ? defaultValue : value;
        }
    }

    // ì‚¬ìš©
    public Try<Integer> divide(int a, int b) {
        return Try.success(a / b);
    }

    public void example() {
        int result = divide(10, 2)
            .map(n -> n * 2)
            .map(n -> n + 1)
            .orElse(0);  // 21
    }
}
```

---

## ğŸ’¡ ë©´ì ‘ ì§ˆë¬¸

### Q1. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ í•µì‹¬ ê°œë…ì€?

**ë‹µë³€**:
```
í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ 4ëŒ€ í•µì‹¬ ê°œë…:

1. ìˆœìˆ˜ í•¨ìˆ˜ (Pure Function)
   - ê°™ì€ ì…ë ¥ â†’ ê°™ì€ ì¶œë ¥
   - ë¶€ì‘ìš© ì—†ìŒ
   - ì˜ˆì¸¡ ê°€ëŠ¥, í…ŒìŠ¤íŠ¸ ìš©ì´

2. ë¶ˆë³€ì„± (Immutability)
   - ë°ì´í„° ë³€ê²½ ê¸ˆì§€
   - ìƒˆ ê°ì²´ ìƒì„±
   - Thread-safe

3. ê³ ì°¨ í•¨ìˆ˜ (Higher-Order Function)
   - í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ë°›ìŒ
   - í•¨ìˆ˜ë¥¼ ë°˜í™˜
   - í•¨ìˆ˜ ì¡°í•© ê°€ëŠ¥

4. ì„ ì–¸í˜• í”„ë¡œê·¸ë˜ë°
   - "ë¬´ì—‡ì„" í• ì§€ ì„ ì–¸
   - "ì–´ë–»ê²Œ"ê°€ ì•„ë‹Œ "ë¬´ì—‡ì„"
```

---

### Q2. ìˆœìˆ˜ í•¨ìˆ˜ì™€ ë¹„ìˆœìˆ˜ í•¨ìˆ˜ì˜ ì°¨ì´ëŠ”?

**ë‹µë³€**:
```java
// ìˆœìˆ˜ í•¨ìˆ˜
public int add(int a, int b) {
    return a + b;  // í•­ìƒ ê°™ì€ ê²°ê³¼
}

// ë¹„ìˆœìˆ˜ í•¨ìˆ˜
private int counter = 0;
public int addWithCounter(int a, int b) {
    counter++;  // ì™¸ë¶€ ìƒíƒœ ë³€ê²½ (ë¶€ì‘ìš©)
    return a + b + counter;  // ë§¤ë²ˆ ë‹¤ë¥¸ ê²°ê³¼
}
```

**ì°¨ì´ì **:
- **ìˆœìˆ˜ í•¨ìˆ˜**: ì°¸ì¡° íˆ¬ëª…ì„±, í…ŒìŠ¤íŠ¸ ìš©ì´, ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥
- **ë¹„ìˆœìˆ˜ í•¨ìˆ˜**: ìƒíƒœ ì˜ì¡´, ì˜ˆì¸¡ ë¶ˆê°€, Thread-unsafe

---

### Q3. ìŠ¤íŠ¸ë¦¼ì˜ ì§€ì—° í‰ê°€ë€?

**ë‹µë³€**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// ì§€ì—° í‰ê°€
Stream<Integer> stream = numbers.stream()
    .filter(n -> {
        System.out.println("filter: " + n);
        return n % 2 == 0;
    })
    .map(n -> {
        System.out.println("map: " + n);
        return n * 2;
    });

// ì—¬ê¸°ê¹Œì§€ëŠ” ì•„ë¬´ê²ƒë„ ì¶œë ¥ ì•ˆ ë¨!

// ìµœì¢… ì—°ì‚°ì´ í˜¸ì¶œë  ë•Œ ì‹¤í–‰
List<Integer> result = stream.collect(Collectors.toList());

/* ì¶œë ¥:
filter: 1
filter: 2
map: 2
filter: 3
filter: 4
map: 4
filter: 5
*/
```

**ì¥ì **:
- í•„ìš”í•œ ë§Œí¼ë§Œ ì²˜ë¦¬
- ì„±ëŠ¥ ìµœì í™”
- ë¬´í•œ ìŠ¤íŠ¸ë¦¼ ê°€ëŠ¥

---

### Q4. mapê³¼ flatMapì˜ ì°¨ì´ëŠ”?

**ë‹µë³€**:
```java
// map - 1:1 ë³€í™˜
List<String> names = Arrays.asList("Alice", "Bob");
List<Integer> lengths = names.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 3]

// flatMap - 1:N ë³€í™˜ í›„ í‰íƒ„í™”
List<String> words = Arrays.asList("Hello World", "Java Stream");
List<String> allWords = words.stream()
    .flatMap(line -> Arrays.stream(line.split(" ")))
    .collect(Collectors.toList());
// [Hello, World, Java, Stream]

// map vs flatMap
List<List<Integer>> nested = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);

// map - ê·¸ëŒ€ë¡œ
List<Stream<Integer>> mapped = nested.stream()
    .map(List::stream)
    .collect(Collectors.toList());
// [Stream, Stream]

// flatMap - í‰íƒ„í™”
List<Integer> flattened = nested.stream()
    .flatMap(List::stream)
    .collect(Collectors.toList());
// [1, 2, 3, 4]
```

---

### Q5. ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•  ë•Œ ì£¼ì˜ì‚¬í•­ì€?

**ë‹µë³€**:
```java
// âŒ ì˜ëª»ëœ ì‚¬ìš©
List<Integer> list = new ArrayList<>();
IntStream.range(0, 1000).parallel()
    .forEach(list::add);  // ConcurrentModificationException!

// âœ… ì˜¬ë°”ë¥¸ ì‚¬ìš©
List<Integer> list = IntStream.range(0, 1000)
    .parallel()
    .boxed()
    .collect(Collectors.toList());
```

**ì£¼ì˜ì‚¬í•­**:
1. **ê³µìœ  ìƒíƒœ ìˆ˜ì • ê¸ˆì§€** - Thread-unsafe
2. **ëŒ€ëŸ‰ ë°ì´í„°ì—ë§Œ ì‚¬ìš©** - ì˜¤ë²„í—¤ë“œ ê³ ë ¤
3. **ìˆœì„œ ë³´ì¥ ì•ˆ ë¨** - forEach ëŒ€ì‹  forEachOrdered
4. **ë¸”ë¡œí‚¹ I/O í”¼í•˜ê¸°** - ForkJoinPool ê³ ê°ˆ

---

### Q6. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì˜ ì¥ë‹¨ì ì€?

**ë‹µë³€**:

**ì¥ì **:
```
âœ… ì½”ë“œ ê°„ê²°ì„± - ë³´ì¼ëŸ¬í”Œë ˆì´íŠ¸ ê°ì†Œ
âœ… ê°€ë…ì„± - ì„ ì–¸ì  ì½”ë“œ
âœ… í…ŒìŠ¤íŠ¸ ìš©ì´ì„± - ìˆœìˆ˜ í•¨ìˆ˜
âœ… ë³‘ë ¬ ì²˜ë¦¬ - Thread-safe
âœ… ë²„ê·¸ ê°ì†Œ - ë¶ˆë³€ì„±
```

**ë‹¨ì **:
```
âŒ í•™ìŠµ ê³¡ì„  - ê°œë… ì´í•´ í•„ìš”
âŒ ì„±ëŠ¥ ì˜¤ë²„í—¤ë“œ - ì‘ì€ ë°ì´í„°ëŠ” ëŠë¦¼
âŒ ë””ë²„ê¹… ì–´ë ¤ì›€ - ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë³µì¡
âŒ ê³¼ë„í•œ ê°ì²´ ìƒì„± - GC ë¶€í•˜
```

---

### Q7. Collectorì˜ ë‚´ë¶€ ë™ì‘ ì›ë¦¬ëŠ”?

**ë‹µë³€**:
```java
// Collector êµ¬ì¡°
public interface Collector<T, A, R> {
    Supplier<A> supplier();        // ì»¨í…Œì´ë„ˆ ìƒì„±
    BiConsumer<A, T> accumulator(); // ìš”ì†Œ ì¶”ê°€
    BinaryOperator<A> combiner();  // ë³‘ë ¬ ì²˜ë¦¬ ì‹œ ê²°í•©
    Function<A, R> finisher();     // ìµœì¢… ë³€í™˜
}

// Custom Collector ì˜ˆì œ
public static Collector<String, StringBuilder, String> joining() {
    return Collector.of(
        StringBuilder::new,              // supplier
        StringBuilder::append,           // accumulator
        StringBuilder::append,           // combiner
        StringBuilder::toString          // finisher
    );
}

// ì‚¬ìš©
String result = Stream.of("a", "b", "c")
    .collect(joining());  // "abc"
```

---

## ğŸ“ ìµœì¢… ì •ë¦¬

### í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì²´í¬ë¦¬ìŠ¤íŠ¸

```
âœ… ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ì‘ì„±
âœ… ë¶ˆë³€ ê°ì²´ ì‚¬ìš©
âœ… ì™¸ë¶€ ìƒíƒœ ë³€ê²½ ê¸ˆì§€
âœ… ì„ ì–¸ì  ì½”ë“œ ì‘ì„±
âœ… í•¨ìˆ˜ ì¡°í•© í™œìš©
âœ… ì§€ì—° í‰ê°€ ê³ ë ¤
âœ… ì ì ˆí•œ ì»¬ë ‰í„° ì‚¬ìš©
âœ… ë³‘ë ¬ ì²˜ë¦¬ ì‹œ ì£¼ì˜
```

### ì„±ëŠ¥ ìµœì í™” íŒ

```
ğŸš€ í•„í„°ë§ ë¨¼ì €, ë³€í™˜ ë‚˜ì¤‘
ğŸš€ ë©”ì„œë“œ ë ˆí¼ëŸ°ìŠ¤ ìš°ì„ 
ğŸš€ ëŒ€ëŸ‰ ë°ì´í„°ëŠ” ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼
ğŸš€ ì ì ˆí•œ ì»¬ë ‰í„° ì„ íƒ
ğŸš€ ë¬´í•œ ìŠ¤íŠ¸ë¦¼ì€ limit
```

**ì¶•í•˜í•©ë‹ˆë‹¤! í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ì„ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤!** ğŸ‰
