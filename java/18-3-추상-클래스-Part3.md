# 18-3. 추상 클래스 Part 3: 실전 프로젝트 및 면접 대비

## 🚀 실전 프로젝트: 전자상거래 결제 시스템

이번 프로젝트에서는 추상 클래스를 활용하여 실제 전자상거래 사이트에서 사용할 수 있는 통합 결제 시스템을 구현해보겠습니다.

### 📋 프로젝트 요구사항

**비즈니스 요구사항:**
1. 다양한 결제 수단 지원 (신용카드, 계좌이체, 간편결제, 가상계좌)
2. 모든 결제는 동일한 프로세스를 따라야 함 (검증 → 결제 → 영수증 발행)
3. 각 결제 수단마다 고유한 검증 및 처리 로직 필요
4. 결제 이력 자동 저장
5. 환불 지원
6. 결제 실패 시 재시도 메커니즘

**기술 요구사항:**
1. 추상 클래스를 사용하여 공통 로직과 개별 로직 분리
2. 템플릿 메서드 패턴 적용
3. 확장 가능한 구조 (새로운 결제 수단 추가 용이)
4. 예외 처리 및 로깅

### 💻 전체 코드 구현

```java
// ========== 기본 엔티티 클래스들 ==========

import java.time.LocalDateTime;
import java.util.*;

/**
 * 결제 정보
 */
class PaymentInfo {
    private String orderId;           // 주문 ID
    private String userId;            // 사용자 ID
    private int amount;               // 결제 금액
    private String productName;       // 상품명
    private LocalDateTime createdAt;  // 생성 시각

    public PaymentInfo(String orderId, String userId, int amount, String productName) {
        this.orderId = orderId;
        this.userId = userId;
        this.amount = amount;
        this.productName = productName;
        this.createdAt = LocalDateTime.now();
    }

    // Getters
    public String getOrderId() { return orderId; }
    public String getUserId() { return userId; }
    public int getAmount() { return amount; }
    public String getProductName() { return productName; }
    public LocalDateTime getCreatedAt() { return createdAt; }
}

/**
 * 결제 결과
 */
class PaymentResult {
    private boolean success;
    private String transactionId;
    private String message;
    private LocalDateTime completedAt;
    private PaymentInfo paymentInfo;

    public PaymentResult(boolean success, String transactionId, String message, PaymentInfo paymentInfo) {
        this.success = success;
        this.transactionId = transactionId;
        this.message = message;
        this.completedAt = LocalDateTime.now();
        this.paymentInfo = paymentInfo;
    }

    // Getters
    public boolean isSuccess() { return success; }
    public String getTransactionId() { return transactionId; }
    public String getMessage() { return message; }
    public LocalDateTime getCompletedAt() { return completedAt; }
    public PaymentInfo getPaymentInfo() { return paymentInfo; }

    @Override
    public String toString() {
        return String.format("[결제 결과] 성공: %s | 거래ID: %s | 메시지: %s",
            success ? "✓" : "✗", transactionId, message);
    }
}

/**
 * 결제 이력
 */
class PaymentHistory {
    private String transactionId;
    private String paymentMethod;
    private PaymentInfo paymentInfo;
    private boolean success;
    private LocalDateTime timestamp;

    public PaymentHistory(String transactionId, String paymentMethod,
                         PaymentInfo paymentInfo, boolean success) {
        this.transactionId = transactionId;
        this.paymentMethod = paymentMethod;
        this.paymentInfo = paymentInfo;
        this.success = success;
        this.timestamp = LocalDateTime.now();
    }

    @Override
    public String toString() {
        return String.format("[%s] %s | %s | 금액: %,d원 | 상태: %s",
            timestamp, paymentMethod, paymentInfo.getProductName(),
            paymentInfo.getAmount(), success ? "성공" : "실패");
    }
}

/**
 * 결제 예외 클래스
 */
class PaymentException extends Exception {
    public PaymentException(String message) {
        super(message);
    }

    public PaymentException(String message, Throwable cause) {
        super(message, cause);
    }
}

// ========== 추상 결제 프로세서 ==========

/**
 * 추상 결제 프로세서 - 모든 결제 수단의 부모 클래스
 */
abstract class AbstractPaymentProcessor {

    // 공통 필드
    protected String processorName;
    protected int maxRetryCount = 3;
    protected List<PaymentHistory> historyList = new ArrayList<>();

    public AbstractPaymentProcessor(String processorName) {
        this.processorName = processorName;
    }

    /**
     * 템플릿 메서드: 결제 처리의 전체 흐름을 정의 (final로 보호)
     */
    public final PaymentResult processPayment(PaymentInfo paymentInfo) {
        System.out.println("\n========================================");
        System.out.println("결제 프로세서: " + processorName);
        System.out.println("주문 ID: " + paymentInfo.getOrderId());
        System.out.println("상품명: " + paymentInfo.getProductName());
        System.out.println("금액: " + String.format("%,d", paymentInfo.getAmount()) + "원");
        System.out.println("========================================");

        try {
            // 1단계: 결제 정보 검증
            System.out.println("\n[1단계] 결제 정보 검증 중...");
            validatePaymentInfo(paymentInfo);
            System.out.println("✓ 검증 완료");

            // 2단계: 결제 수단별 검증
            System.out.println("\n[2단계] " + processorName + " 검증 중...");
            validatePaymentMethod(paymentInfo);
            System.out.println("✓ 결제 수단 검증 완료");

            // 3단계: 결제 전처리
            System.out.println("\n[3단계] 결제 전처리 중...");
            preProcess(paymentInfo);
            System.out.println("✓ 전처리 완료");

            // 4단계: 실제 결제 처리 (재시도 메커니즘 포함)
            System.out.println("\n[4단계] 결제 처리 중...");
            boolean paymentSuccess = executePaymentWithRetry(paymentInfo);

            if (!paymentSuccess) {
                throw new PaymentException("결제 처리 실패");
            }

            System.out.println("✓ 결제 처리 완료");

            // 5단계: 결제 후처리
            System.out.println("\n[5단계] 결제 후처리 중...");
            postProcess(paymentInfo);
            System.out.println("✓ 후처리 완료");

            // 6단계: 영수증 발행
            System.out.println("\n[6단계] 영수증 발행 중...");
            String transactionId = generateTransactionId();
            issueReceipt(transactionId, paymentInfo);
            System.out.println("✓ 영수증 발행 완료");

            // 7단계: 이력 저장
            saveHistory(transactionId, paymentInfo, true);

            System.out.println("\n========================================");
            System.out.println("결제가 성공적으로 완료되었습니다!");
            System.out.println("========================================\n");

            return new PaymentResult(true, transactionId, "결제 성공", paymentInfo);

        } catch (PaymentException e) {
            System.err.println("\n✗ 결제 실패: " + e.getMessage());

            // 실패 이력 저장
            String transactionId = generateTransactionId();
            saveHistory(transactionId, paymentInfo, false);

            // 실패 후처리
            onPaymentFailure(paymentInfo, e);

            return new PaymentResult(false, transactionId, e.getMessage(), paymentInfo);
        }
    }

    /**
     * 재시도 메커니즘을 포함한 결제 실행
     */
    private boolean executePaymentWithRetry(PaymentInfo paymentInfo) throws PaymentException {
        for (int attempt = 1; attempt <= maxRetryCount; attempt++) {
            try {
                System.out.println("  시도 " + attempt + "/" + maxRetryCount);
                boolean result = executePayment(paymentInfo);

                if (result) {
                    return true;
                }

                System.out.println("  → 결제 실패, 재시도 중...");

            } catch (Exception e) {
                System.out.println("  → 오류 발생: " + e.getMessage());

                if (attempt == maxRetryCount) {
                    throw new PaymentException("최대 재시도 횟수 초과", e);
                }
            }

            // 재시도 전 대기 (exponential backoff)
            try {
                int waitTime = attempt * 100;
                Thread.sleep(waitTime);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        throw new PaymentException("결제 처리 실패: 최대 재시도 횟수 초과");
    }

    /**
     * 환불 처리 (템플릿 메서드)
     */
    public final PaymentResult refund(String transactionId, int refundAmount) {
        System.out.println("\n========== 환불 처리 시작 ==========");
        System.out.println("거래 ID: " + transactionId);
        System.out.println("환불 금액: " + String.format("%,d", refundAmount) + "원");

        try {
            // 1. 거래 내역 조회
            System.out.println("\n[1단계] 거래 내역 조회 중...");
            validateTransaction(transactionId);
            System.out.println("✓ 거래 확인 완료");

            // 2. 환불 가능 여부 확인
            System.out.println("\n[2단계] 환불 가능 여부 확인 중...");
            validateRefund(transactionId, refundAmount);
            System.out.println("✓ 환불 가능");

            // 3. 실제 환불 처리
            System.out.println("\n[3단계] 환불 처리 중...");
            boolean refundSuccess = executeRefund(transactionId, refundAmount);

            if (!refundSuccess) {
                throw new PaymentException("환불 처리 실패");
            }

            System.out.println("✓ 환불 완료");
            System.out.println("\n========== 환불 성공 ==========\n");

            return new PaymentResult(true, transactionId + "-REFUND", "환불 완료", null);

        } catch (PaymentException e) {
            System.err.println("\n✗ 환불 실패: " + e.getMessage());
            return new PaymentResult(false, transactionId + "-REFUND", e.getMessage(), null);
        }
    }

    // ========== 공통 메서드 (모든 하위 클래스에서 사용) ==========

    /**
     * 결제 정보 기본 검증
     */
    private void validatePaymentInfo(PaymentInfo paymentInfo) throws PaymentException {
        if (paymentInfo == null) {
            throw new PaymentException("결제 정보가 없습니다");
        }
        if (paymentInfo.getAmount() <= 0) {
            throw new PaymentException("결제 금액이 올바르지 않습니다");
        }
        if (paymentInfo.getUserId() == null || paymentInfo.getUserId().isEmpty()) {
            throw new PaymentException("사용자 ID가 없습니다");
        }
    }

    /**
     * 거래 ID 생성
     */
    protected String generateTransactionId() {
        return "TXN-" + System.currentTimeMillis() + "-" + (int)(Math.random() * 10000);
    }

    /**
     * 영수증 발행
     */
    private void issueReceipt(String transactionId, PaymentInfo paymentInfo) {
        System.out.println("\n┌────────────── 영수증 ──────────────┐");
        System.out.println("│ 거래 ID: " + transactionId);
        System.out.println("│ 결제 수단: " + processorName);
        System.out.println("│ 상품명: " + paymentInfo.getProductName());
        System.out.println("│ 금액: " + String.format("%,d", paymentInfo.getAmount()) + "원");
        System.out.println("│ 일시: " + LocalDateTime.now());
        System.out.println("└────────────────────────────────────┘");
    }

    /**
     * 이력 저장
     */
    private void saveHistory(String transactionId, PaymentInfo paymentInfo, boolean success) {
        PaymentHistory history = new PaymentHistory(transactionId, processorName, paymentInfo, success);
        historyList.add(history);
        System.out.println("  → 이력 저장됨: " + history);
    }

    /**
     * 이력 조회
     */
    public List<PaymentHistory> getHistory() {
        return new ArrayList<>(historyList);
    }

    // ========== 추상 메서드 (하위 클래스에서 반드시 구현) ==========

    /**
     * 결제 수단별 검증 (예: 카드 유효성, 계좌 잔액 등)
     */
    protected abstract void validatePaymentMethod(PaymentInfo paymentInfo) throws PaymentException;

    /**
     * 실제 결제 처리
     */
    protected abstract boolean executePayment(PaymentInfo paymentInfo) throws PaymentException;

    /**
     * 거래 내역 검증
     */
    protected abstract void validateTransaction(String transactionId) throws PaymentException;

    /**
     * 실제 환불 처리
     */
    protected abstract boolean executeRefund(String transactionId, int refundAmount) throws PaymentException;

    // ========== Hook 메서드 (하위 클래스에서 선택적 오버라이드) ==========

    /**
     * 결제 전처리 (선택적)
     */
    protected void preProcess(PaymentInfo paymentInfo) throws PaymentException {
        // 기본 구현 없음
    }

    /**
     * 결제 후처리 (선택적)
     */
    protected void postProcess(PaymentInfo paymentInfo) throws PaymentException {
        // 기본 구현 없음
    }

    /**
     * 환불 가능 여부 확인 (선택적)
     */
    protected void validateRefund(String transactionId, int refundAmount) throws PaymentException {
        // 기본 구현: 모든 환불 허용
    }

    /**
     * 결제 실패 시 호출 (선택적)
     */
    protected void onPaymentFailure(PaymentInfo paymentInfo, PaymentException e) {
        System.err.println("  → 결제 실패 알림 발송: " + paymentInfo.getUserId());
    }
}

// ========== 구체적인 결제 프로세서 구현 ==========

/**
 * 신용카드 결제 프로세서
 */
class CreditCardPaymentProcessor extends AbstractPaymentProcessor {

    private Map<String, String> cardDatabase = new HashMap<>();
    private Map<String, Integer> transactionAmounts = new HashMap<>();

    public CreditCardPaymentProcessor() {
        super("신용카드");

        // 테스트용 카드 등록
        cardDatabase.put("1234-5678-9012-3456", "김철수");
        cardDatabase.put("9876-5432-1098-7654", "이영희");
    }

    @Override
    protected void validatePaymentMethod(PaymentInfo paymentInfo) throws PaymentException {
        // 실제로는 카드 번호를 받아야 하지만, 여기서는 시뮬레이션
        String cardNumber = "1234-5678-9012-3456"; // 테스트용

        if (!cardDatabase.containsKey(cardNumber)) {
            throw new PaymentException("유효하지 않은 카드입니다");
        }

        System.out.println("  → 카드 소유자: " + cardDatabase.get(cardNumber));
        System.out.println("  → 카드 유효성 확인 완료");
    }

    @Override
    protected boolean executePayment(PaymentInfo paymentInfo) throws PaymentException {
        // 신용카드 결제 시뮬레이션
        System.out.println("  → 카드사 승인 요청 중...");

        // 90% 확률로 성공 (시뮬레이션)
        boolean approved = Math.random() < 0.9;

        if (approved) {
            String txnId = generateTransactionId();
            transactionAmounts.put(txnId, paymentInfo.getAmount());
            System.out.println("  → 카드사 승인 완료");
            return true;
        }

        throw new PaymentException("카드사 승인 거부");
    }

    @Override
    protected void validateTransaction(String transactionId) throws PaymentException {
        if (!transactionAmounts.containsKey(transactionId)) {
            throw new PaymentException("존재하지 않는 거래입니다");
        }
    }

    @Override
    protected boolean executeRefund(String transactionId, int refundAmount) throws PaymentException {
        String originalTxnId = transactionId.replace("-REFUND", "");

        if (!transactionAmounts.containsKey(originalTxnId)) {
            throw new PaymentException("원 거래를 찾을 수 없습니다");
        }

        int originalAmount = transactionAmounts.get(originalTxnId);

        if (refundAmount > originalAmount) {
            throw new PaymentException("환불 금액이 원 거래 금액을 초과합니다");
        }

        System.out.println("  → 카드사 환불 처리 중...");
        transactionAmounts.remove(originalTxnId);
        System.out.println("  → 카드사 환불 완료");

        return true;
    }

    @Override
    protected void postProcess(PaymentInfo paymentInfo) {
        // 신용카드 포인트 적립
        int points = paymentInfo.getAmount() / 100;
        System.out.println("  → 포인트 적립: " + points + "P");
    }
}

/**
 * 계좌이체 결제 프로세서
 */
class BankTransferPaymentProcessor extends AbstractPaymentProcessor {

    private Map<String, Integer> accountBalances = new HashMap<>();
    private Map<String, Integer> transactionAmounts = new HashMap<>();

    public BankTransferPaymentProcessor() {
        super("계좌이체");

        // 테스트용 계좌 등록
        accountBalances.put("110-123-456789", 1000000);
        accountBalances.put("220-987-654321", 500000);
    }

    @Override
    protected void validatePaymentMethod(PaymentInfo paymentInfo) throws PaymentException {
        String accountNumber = "110-123-456789"; // 테스트용

        if (!accountBalances.containsKey(accountNumber)) {
            throw new PaymentException("존재하지 않는 계좌입니다");
        }

        int balance = accountBalances.get(accountNumber);
        System.out.println("  → 계좌 잔액: " + String.format("%,d", balance) + "원");

        if (balance < paymentInfo.getAmount()) {
            throw new PaymentException("잔액이 부족합니다");
        }
    }

    @Override
    protected boolean executePayment(PaymentInfo paymentInfo) throws PaymentException {
        String accountNumber = "110-123-456789"; // 테스트용

        System.out.println("  → 계좌 출금 중...");

        int balance = accountBalances.get(accountNumber);
        balance -= paymentInfo.getAmount();
        accountBalances.put(accountNumber, balance);

        String txnId = generateTransactionId();
        transactionAmounts.put(txnId, paymentInfo.getAmount());

        System.out.println("  → 출금 완료, 남은 잔액: " + String.format("%,d", balance) + "원");

        return true;
    }

    @Override
    protected void validateTransaction(String transactionId) throws PaymentException {
        if (!transactionAmounts.containsKey(transactionId)) {
            throw new PaymentException("존재하지 않는 거래입니다");
        }
    }

    @Override
    protected boolean executeRefund(String transactionId, int refundAmount) throws PaymentException {
        String originalTxnId = transactionId.replace("-REFUND", "");

        if (!transactionAmounts.containsKey(originalTxnId)) {
            throw new PaymentException("원 거래를 찾을 수 없습니다");
        }

        String accountNumber = "110-123-456789"; // 테스트용

        System.out.println("  → 계좌 입금 중...");

        int balance = accountBalances.get(accountNumber);
        balance += refundAmount;
        accountBalances.put(accountNumber, balance);

        transactionAmounts.remove(originalTxnId);

        System.out.println("  → 입금 완료, 현재 잔액: " + String.format("%,d", balance) + "원");

        return true;
    }

    @Override
    protected void preProcess(PaymentInfo paymentInfo) {
        // 이체 한도 확인
        System.out.println("  → 1회 이체 한도: 1,000,000원");
        System.out.println("  → 이체 가능");
    }
}

/**
 * 간편결제 프로세서 (예: 카카오페이, 네이버페이)
 */
class SimplePaymentProcessor extends AbstractPaymentProcessor {

    private Map<String, Boolean> userAuthenticated = new HashMap<>();
    private Map<String, Integer> transactionAmounts = new HashMap<>();

    public SimplePaymentProcessor(String serviceName) {
        super(serviceName);

        // 테스트용 사용자 등록
        userAuthenticated.put("user001", true);
        userAuthenticated.put("user002", true);
    }

    @Override
    protected void validatePaymentMethod(PaymentInfo paymentInfo) throws PaymentException {
        String userId = paymentInfo.getUserId();

        if (!userAuthenticated.containsKey(userId)) {
            throw new PaymentException("간편결제에 등록되지 않은 사용자입니다");
        }

        if (!userAuthenticated.get(userId)) {
            throw new PaymentException("사용자 인증이 필요합니다");
        }

        System.out.println("  → 사용자 인증 확인 완료");
    }

    @Override
    protected void preProcess(PaymentInfo paymentInfo) throws PaymentException {
        // 생체 인증 시뮬레이션
        System.out.println("  → 생체 인증 요청 중...");

        boolean bioAuthSuccess = Math.random() < 0.95;

        if (!bioAuthSuccess) {
            throw new PaymentException("생체 인증 실패");
        }

        System.out.println("  → 생체 인증 성공");
    }

    @Override
    protected boolean executePayment(PaymentInfo paymentInfo) throws PaymentException {
        System.out.println("  → " + processorName + " 결제 처리 중...");

        // 95% 확률로 성공
        boolean success = Math.random() < 0.95;

        if (success) {
            String txnId = generateTransactionId();
            transactionAmounts.put(txnId, paymentInfo.getAmount());
            System.out.println("  → 결제 완료");
            return true;
        }

        throw new PaymentException("간편결제 처리 실패");
    }

    @Override
    protected void validateTransaction(String transactionId) throws PaymentException {
        if (!transactionAmounts.containsKey(transactionId)) {
            throw new PaymentException("존재하지 않는 거래입니다");
        }
    }

    @Override
    protected boolean executeRefund(String transactionId, int refundAmount) throws PaymentException {
        String originalTxnId = transactionId.replace("-REFUND", "");

        if (!transactionAmounts.containsKey(originalTxnId)) {
            throw new PaymentException("원 거래를 찾을 수 없습니다");
        }

        System.out.println("  → " + processorName + " 환불 처리 중...");
        transactionAmounts.remove(originalTxnId);
        System.out.println("  → 환불 완료");

        return true;
    }

    @Override
    protected void postProcess(PaymentInfo paymentInfo) {
        // 캐시백 적립
        int cashback = (int) (paymentInfo.getAmount() * 0.01); // 1% 캐시백
        System.out.println("  → 캐시백 적립: " + cashback + "원");
    }
}

/**
 * 가상계좌 결제 프로세서
 */
class VirtualAccountPaymentProcessor extends AbstractPaymentProcessor {

    private Map<String, String> virtualAccounts = new HashMap<>();
    private Map<String, Integer> deposits = new HashMap<>();

    public VirtualAccountPaymentProcessor() {
        super("가상계좌");
    }

    @Override
    protected void validatePaymentMethod(PaymentInfo paymentInfo) throws PaymentException {
        // 가상계좌는 항상 생성 가능
        System.out.println("  → 가상계좌 생성 가능");
    }

    @Override
    protected void preProcess(PaymentInfo paymentInfo) {
        // 가상계좌 발급
        String virtualAccount = "9999-" + (int)(Math.random() * 100000000);
        virtualAccounts.put(paymentInfo.getOrderId(), virtualAccount);

        System.out.println("  → 가상계좌 발급: " + virtualAccount);
        System.out.println("  → 입금 대기 중 (실제로는 비동기 처리)");
    }

    @Override
    protected boolean executePayment(PaymentInfo paymentInfo) throws PaymentException {
        // 실제로는 비동기로 입금을 기다리지만, 여기서는 즉시 입금된 것으로 시뮬레이션
        String virtualAccount = virtualAccounts.get(paymentInfo.getOrderId());

        System.out.println("  → 입금 확인됨");

        String txnId = generateTransactionId();
        deposits.put(txnId, paymentInfo.getAmount());

        return true;
    }

    @Override
    protected void validateTransaction(String transactionId) throws PaymentException {
        if (!deposits.containsKey(transactionId)) {
            throw new PaymentException("존재하지 않는 거래입니다");
        }
    }

    @Override
    protected boolean executeRefund(String transactionId, int refundAmount) throws PaymentException {
        String originalTxnId = transactionId.replace("-REFUND", "");

        if (!deposits.containsKey(originalTxnId)) {
            throw new PaymentException("원 거래를 찾을 수 없습니다");
        }

        System.out.println("  → 환불 계좌로 송금 중...");
        deposits.remove(originalTxnId);
        System.out.println("  → 송금 완료 (영업일 기준 1-2일 소요)");

        return true;
    }
}

// ========== 결제 서비스 (Facade) ==========

/**
 * 통합 결제 서비스
 */
class PaymentService {

    private Map<String, AbstractPaymentProcessor> processors = new HashMap<>();

    public PaymentService() {
        // 결제 프로세서 등록
        processors.put("CREDIT_CARD", new CreditCardPaymentProcessor());
        processors.put("BANK_TRANSFER", new BankTransferPaymentProcessor());
        processors.put("KAKAO_PAY", new SimplePaymentProcessor("카카오페이"));
        processors.put("NAVER_PAY", new SimplePaymentProcessor("네이버페이"));
        processors.put("VIRTUAL_ACCOUNT", new VirtualAccountPaymentProcessor());
    }

    /**
     * 결제 처리
     */
    public PaymentResult pay(String paymentMethod, PaymentInfo paymentInfo) {
        AbstractPaymentProcessor processor = processors.get(paymentMethod);

        if (processor == null) {
            return new PaymentResult(false, "N/A",
                "지원하지 않는 결제 수단입니다: " + paymentMethod, paymentInfo);
        }

        return processor.processPayment(paymentInfo);
    }

    /**
     * 환불 처리
     */
    public PaymentResult refund(String paymentMethod, String transactionId, int refundAmount) {
        AbstractPaymentProcessor processor = processors.get(paymentMethod);

        if (processor == null) {
            return new PaymentResult(false, "N/A",
                "지원하지 않는 결제 수단입니다: " + paymentMethod, null);
        }

        return processor.refund(transactionId, refundAmount);
    }

    /**
     * 결제 이력 조회
     */
    public void printHistory(String paymentMethod) {
        AbstractPaymentProcessor processor = processors.get(paymentMethod);

        if (processor == null) {
            System.out.println("지원하지 않는 결제 수단입니다: " + paymentMethod);
            return;
        }

        List<PaymentHistory> history = processor.getHistory();

        System.out.println("\n========== " + paymentMethod + " 결제 이력 ==========");

        if (history.isEmpty()) {
            System.out.println("이력이 없습니다.");
        } else {
            for (PaymentHistory h : history) {
                System.out.println(h);
            }
        }

        System.out.println("=========================================\n");
    }
}
```

### 🧪 프로젝트 테스트 코드

```java
/**
 * 전자상거래 결제 시스템 테스트
 */
public class ECommercePaymentSystemTest {

    public static void main(String[] args) {

        PaymentService paymentService = new PaymentService();

        System.out.println("╔════════════════════════════════════════════╗");
        System.out.println("║   전자상거래 통합 결제 시스템 테스트      ║");
        System.out.println("╚════════════════════════════════════════════╝\n");

        // 테스트 1: 신용카드 결제
        test1_CreditCardPayment(paymentService);

        // 테스트 2: 계좌이체 결제
        test2_BankTransferPayment(paymentService);

        // 테스트 3: 간편결제 (카카오페이)
        test3_SimplePayment(paymentService);

        // 테스트 4: 가상계좌 결제
        test4_VirtualAccountPayment(paymentService);

        // 테스트 5: 결제 실패 시나리오
        test5_PaymentFailure(paymentService);

        // 테스트 6: 환불 처리
        test6_Refund(paymentService);

        // 테스트 7: 결제 이력 조회
        test7_PaymentHistory(paymentService);

        System.out.println("\n╔════════════════════════════════════════════╗");
        System.out.println("║        모든 테스트가 완료되었습니다!       ║");
        System.out.println("╚════════════════════════════════════════════╝");
    }

    /**
     * 테스트 1: 신용카드 결제
     */
    static void test1_CreditCardPayment(PaymentService service) {
        System.out.println("\n### 테스트 1: 신용카드 결제 ###");

        PaymentInfo payment = new PaymentInfo(
            "ORDER-001",
            "user001",
            50000,
            "맥북 프로 16인치"
        );

        PaymentResult result = service.pay("CREDIT_CARD", payment);
        printResult(result);

        waitForUser();
    }

    /**
     * 테스트 2: 계좌이체 결제
     */
    static void test2_BankTransferPayment(PaymentService service) {
        System.out.println("\n### 테스트 2: 계좌이체 결제 ###");

        PaymentInfo payment = new PaymentInfo(
            "ORDER-002",
            "user002",
            120000,
            "아이패드 에어"
        );

        PaymentResult result = service.pay("BANK_TRANSFER", payment);
        printResult(result);

        waitForUser();
    }

    /**
     * 테스트 3: 간편결제
     */
    static void test3_SimplePayment(PaymentService service) {
        System.out.println("\n### 테스트 3: 카카오페이 결제 ###");

        PaymentInfo payment = new PaymentInfo(
            "ORDER-003",
            "user001",
            35000,
            "에어팟 프로"
        );

        PaymentResult result = service.pay("KAKAO_PAY", payment);
        printResult(result);

        waitForUser();
    }

    /**
     * 테스트 4: 가상계좌 결제
     */
    static void test4_VirtualAccountPayment(PaymentService service) {
        System.out.println("\n### 테스트 4: 가상계좌 결제 ###");

        PaymentInfo payment = new PaymentInfo(
            "ORDER-004",
            "user002",
            80000,
            "갤럭시 버즈"
        );

        PaymentResult result = service.pay("VIRTUAL_ACCOUNT", payment);
        printResult(result);

        waitForUser();
    }

    /**
     * 테스트 5: 결제 실패 시나리오
     */
    static void test5_PaymentFailure(PaymentService service) {
        System.out.println("\n### 테스트 5: 결제 실패 시나리오 ###");

        // 재시도 메커니즘 테스트를 위한 결제
        // (executePayment가 랜덤으로 실패할 수 있음)

        PaymentInfo payment = new PaymentInfo(
            "ORDER-005",
            "user001",
            25000,
            "무선 키보드"
        );

        PaymentResult result = service.pay("CREDIT_CARD", payment);
        printResult(result);

        waitForUser();
    }

    /**
     * 테스트 6: 환불 처리
     */
    static void test6_Refund(PaymentService service) {
        System.out.println("\n### 테스트 6: 환불 처리 ###");

        // 먼저 결제 진행
        PaymentInfo payment = new PaymentInfo(
            "ORDER-006",
            "user001",
            60000,
            "무선 마우스"
        );

        PaymentResult paymentResult = service.pay("CREDIT_CARD", payment);

        if (paymentResult.isSuccess()) {
            // 결제 성공 시 환불 진행
            System.out.println("\n고객이 환불을 요청했습니다...");

            PaymentResult refundResult = service.refund(
                "CREDIT_CARD",
                paymentResult.getTransactionId(),
                60000
            );

            printResult(refundResult);
        }

        waitForUser();
    }

    /**
     * 테스트 7: 결제 이력 조회
     */
    static void test7_PaymentHistory(PaymentService service) {
        System.out.println("\n### 테스트 7: 결제 이력 조회 ###");

        service.printHistory("CREDIT_CARD");
        service.printHistory("BANK_TRANSFER");
        service.printHistory("KAKAO_PAY");
    }

    /**
     * 결과 출력
     */
    static void printResult(PaymentResult result) {
        System.out.println("\n" + result);
    }

    /**
     * 사용자 입력 대기 (가독성을 위한 일시 정지)
     */
    static void waitForUser() {
        try {
            Thread.sleep(500); // 0.5초 대기
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

### 🎯 프로젝트 핵심 포인트

1. **템플릿 메서드 패턴 완벽 구현**
   - `processPayment()`: 전체 결제 흐름을 7단계로 정의
   - 각 단계가 명확하게 분리되고 순서가 보장됨

2. **추상 메서드와 Hook 메서드의 조화**
   - 필수 구현: `validatePaymentMethod()`, `executePayment()`, etc.
   - 선택적 구현: `preProcess()`, `postProcess()`, `onPaymentFailure()`

3. **final 키워드로 핵심 로직 보호**
   - `processPayment()`, `refund()`: 전체 흐름 보호
   - 하위 클래스는 세부 구현만 제공

4. **재시도 메커니즘**
   - `executePaymentWithRetry()`: 실패 시 자동 재시도
   - Exponential backoff 적용

5. **확장성**
   - 새로운 결제 수단 추가가 매우 쉬움
   - `AbstractPaymentProcessor`를 상속받고 4개의 추상 메서드만 구현

6. **실전 적용 가능**
   - 실제 전자상거래 시스템에서 바로 적용 가능한 구조
   - 예외 처리, 로깅, 이력 관리 등 실무 요소 포함

---

## ❓ FAQ (자주 묻는 질문)

### Q1. 추상 클래스와 인터페이스, 어떤 것을 선택해야 하나요?

**A:** 다음 기준으로 선택하세요:

**추상 클래스를 선택해야 할 때:**
- ✅ 공통 필드(상태)를 가져야 할 때
- ✅ 공통 메서드 구현을 공유해야 할 때
- ✅ 생성자 로직을 공유해야 할 때
- ✅ IS-A 관계가 명확할 때 (예: "신용카드 결제는 결제 프로세서다")
- ✅ 템플릿 메서드 패턴을 사용하고 싶을 때

**인터페이스를 선택해야 할 때:**
- ✅ 다중 상속이 필요할 때
- ✅ 서로 관련 없는 클래스들이 같은 동작을 해야 할 때
- ✅ 구현을 전혀 공유하지 않을 때
- ✅ CAN-DO 관계를 나타낼 때 (예: "새는 날 수 있다")

```java
// 추상 클래스: 공통 로직이 많을 때
abstract class Animal {
    protected String name;  // 공통 필드

    public Animal(String name) {  // 공통 생성자
        this.name = name;
    }

    public void breathe() {  // 공통 메서드
        System.out.println(name + "이(가) 숨을 쉽니다");
    }

    public abstract void makeSound();  // 추상 메서드
}

// 인터페이스: 능력(행위)만 정의
interface Flyable {
    void fly();  // 구현 없음
}

interface Swimmable {
    void swim();  // 구현 없음
}

// 다중 상속 예제
class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("꽥꽥!");
    }

    @Override
    public void fly() {
        System.out.println(name + "이(가) 날아갑니다");
    }

    @Override
    public void swim() {
        System.out.println(name + "이(가) 수영합니다");
    }
}
```

---

### Q2. 추상 클래스에도 생성자가 필요한가요?

**A:** 네, 추상 클래스도 생성자를 가질 수 있고, 대부분의 경우 필요합니다!

```java
abstract class Vehicle {
    protected String manufacturer;
    protected String model;
    protected int year;

    // 추상 클래스의 생성자
    public Vehicle(String manufacturer, String model, int year) {
        this.manufacturer = manufacturer;
        this.model = model;
        this.year = year;

        System.out.println("Vehicle 생성자 호출");
    }

    public abstract void start();
}

class Car extends Vehicle {
    private int doors;

    public Car(String manufacturer, String model, int year, int doors) {
        // 부모 생성자 호출 (필수!)
        super(manufacturer, model, year);
        this.doors = doors;

        System.out.println("Car 생성자 호출");
    }

    @Override
    public void start() {
        System.out.println("자동차 시동을 겁니다");
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        Car car = new Car("현대", "소나타", 2024, 4);
        // 출력:
        // Vehicle 생성자 호출
        // Car 생성자 호출
    }
}
```

**핵심:**
- 추상 클래스는 직접 인스턴스화할 수 없지만, 생성자는 가질 수 있음
- 하위 클래스의 생성자에서 `super()`로 부모 생성자를 반드시 호출해야 함
- 부모 클래스의 필드를 초기화하는 데 사용됨

---

### Q3. 추상 메서드는 왜 private일 수 없나요?

**A:** 추상 메서드의 목적은 "하위 클래스에서 구현하라"는 것인데, private이면 하위 클래스에서 접근할 수 없기 때문입니다!

```java
abstract class Example_Wrong {
    // 컴파일 에러!
    // private abstract void doSomething();
    // Error: Illegal combination of modifiers: 'abstract' and 'private'
}

abstract class Example_Correct {
    // ✅ public: 어디서든 오버라이드 가능
    public abstract void publicMethod();

    // ✅ protected: 하위 클래스와 같은 패키지에서 오버라이드 가능
    protected abstract void protectedMethod();

    // ✅ default (package-private): 같은 패키지 내에서 오버라이드 가능
    abstract void defaultMethod();

    // ❌ private: 불가능 (하위 클래스에서 접근 불가)
}
```

**가능한 조합:**
- ✅ `public abstract`
- ✅ `protected abstract`
- ✅ `abstract` (default)
- ❌ `private abstract` (불가능!)
- ❌ `static abstract` (불가능!)
- ❌ `final abstract` (불가능! - final은 오버라이드 금지, abstract는 오버라이드 강제)

---

### Q4. 추상 클래스에 추상 메서드가 하나도 없어도 되나요?

**A:** 네, 가능합니다! 추상 메서드가 없어도 `abstract` 키워드만 있으면 추상 클래스입니다.

```java
// 추상 메서드가 없는 추상 클래스
abstract class BaseConfig {
    protected String appName;
    protected String version;

    public BaseConfig(String appName, String version) {
        this.appName = appName;
        this.version = version;
    }

    public void printInfo() {
        System.out.println("앱 이름: " + appName);
        System.out.println("버전: " + version);
    }

    // 추상 메서드가 하나도 없음!
}

// 하위 클래스
class ProductionConfig extends BaseConfig {
    public ProductionConfig() {
        super("MyApp", "1.0.0");
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // BaseConfig config = new BaseConfig("test", "1.0");  // 컴파일 에러!
        BaseConfig config = new ProductionConfig();  // ✅ OK
        config.printInfo();
    }
}
```

**왜 이렇게 사용하나요?**
- 직접 인스턴스화를 방지하고 싶을 때
- 하위 클래스를 통해서만 사용하도록 강제하고 싶을 때
- 공통 로직은 제공하되, 직접 사용은 막고 싶을 때

---

### Q5. 추상 클래스를 상속받은 클래스가 또 다른 추상 클래스일 수 있나요?

**A:** 네, 가능합니다! 추상 클래스가 추상 클래스를 상속받을 수 있고, 부모의 추상 메서드를 구현하지 않아도 됩니다.

```java
// 최상위 추상 클래스
abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    public abstract double getArea();
    public abstract double getPerimeter();
    public abstract void draw();
}

// 중간 추상 클래스 - Shape를 상속받지만 일부만 구현
abstract class Polygon extends Shape {
    protected int sides;

    public Polygon(String color, int sides) {
        super(color);
        this.sides = sides;
    }

    // getArea()와 draw()는 구현하지 않음 (여전히 추상)

    // getPerimeter()만 구현
    @Override
    public double getPerimeter() {
        System.out.println(sides + "각형의 둘레 계산");
        return 0; // 단순화
    }
}

// 구체 클래스 - 모든 추상 메서드를 구현
class Triangle extends Polygon {
    private double base;
    private double height;

    public Triangle(String color, double base, double height) {
        super(color, 3);
        this.base = base;
        this.height = height;
    }

    @Override
    public double getArea() {
        return (base * height) / 2;
    }

    @Override
    public void draw() {
        System.out.println(color + " 삼각형을 그립니다");
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // Shape shape = new Shape("red");       // 컴파일 에러!
        // Polygon polygon = new Polygon("blue", 4);  // 컴파일 에러!

        Triangle triangle = new Triangle("green", 10, 5);  // ✅ OK
        System.out.println("넓이: " + triangle.getArea());
        triangle.draw();
    }
}
```

**언제 유용한가요?**
- 상속 계층이 깊을 때
- 일부 메서드만 중간에서 구현하고 싶을 때
- 점진적으로 추상화를 구체화하고 싶을 때

---

### Q6. final 메서드와 추상 메서드를 같은 클래스에 사용할 수 있나요?

**A:** 네, 가능합니다! 이것이 템플릿 메서드 패턴의 핵심입니다.

```java
abstract class DataProcessor {

    /**
     * 템플릿 메서드 - final로 보호
     * 전체 알고리즘의 흐름을 정의
     */
    public final void process() {
        System.out.println("=== 데이터 처리 시작 ===");

        // 1. 데이터 로드 (추상 메서드 - 하위 클래스가 구현)
        loadData();

        // 2. 데이터 검증 (공통 메서드)
        validateData();

        // 3. 데이터 변환 (추상 메서드 - 하위 클래스가 구현)
        transformData();

        // 4. 데이터 저장 (추상 메서드 - 하위 클래스가 구현)
        saveData();

        // 5. 로그 기록 (공통 메서드)
        logCompletion();

        System.out.println("=== 데이터 처리 완료 ===\n");
    }

    // 추상 메서드들
    protected abstract void loadData();
    protected abstract void transformData();
    protected abstract void saveData();

    // 공통 메서드
    private void validateData() {
        System.out.println("  [공통] 데이터 검증 중...");
    }

    private void logCompletion() {
        System.out.println("  [공통] 로그 기록 완료");
    }
}

class CsvDataProcessor extends DataProcessor {
    @Override
    protected void loadData() {
        System.out.println("  CSV 파일 로드");
    }

    @Override
    protected void transformData() {
        System.out.println("  CSV 데이터 변환");
    }

    @Override
    protected void saveData() {
        System.out.println("  CSV 데이터 저장");
    }

    // process() 메서드는 final이므로 오버라이드 불가!
}

// 테스트
public class Test {
    public static void main(String[] args) {
        DataProcessor processor = new CsvDataProcessor();
        processor.process();

        // 출력:
        // === 데이터 처리 시작 ===
        //   CSV 파일 로드
        //   [공통] 데이터 검증 중...
        //   CSV 데이터 변환
        //   CSV 데이터 저장
        //   [공통] 로그 기록 완료
        // === 데이터 처리 완료 ===
    }
}
```

**핵심 원칙:**
- **final 메서드**: 전체 흐름을 정의하고 보호 (템플릿)
- **추상 메서드**: 세부 구현을 하위 클래스에 위임
- **일반 메서드**: 공통 로직 제공

---

### Q7. 추상 클래스에서 static 메서드를 사용할 수 있나요?

**A:** 네, 가능합니다! 추상 클래스도 일반 클래스처럼 static 메서드를 가질 수 있습니다.

```java
abstract class MathOperation {

    // static 메서드 - 유틸리티 메서드로 사용
    public static int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }

    // 추상 메서드
    public abstract int calculate(int x, int y);

    // static과 abstract를 함께 사용할 수 없음!
    // public static abstract int wrong();  // 컴파일 에러!
}

class Addition extends MathOperation {
    @Override
    public int calculate(int x, int y) {
        return x + y;
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // static 메서드는 클래스 이름으로 직접 호출 가능
        int sum = MathOperation.add(10, 20);
        System.out.println("합: " + sum);

        // 추상 메서드는 인스턴스를 통해서만 호출 가능
        MathOperation op = new Addition();
        int result = op.calculate(10, 20);
        System.out.println("결과: " + result);
    }
}
```

**주의사항:**
- ✅ `public static void method() { }` - 가능
- ❌ `public static abstract void method();` - 불가능!
- static 메서드는 오버라이드되지 않으므로 abstract와 함께 사용할 수 없음

---

## 🎤 면접 질문 및 답변

### 주니어 레벨 (Junior Level)

#### Q1. 추상 클래스란 무엇이며, 일반 클래스와 어떤 차이가 있나요?

**모범 답변:**

추상 클래스는 `abstract` 키워드로 선언된 불완전한 클래스로, 직접 인스턴스화할 수 없고 반드시 상속을 통해서만 사용할 수 있습니다.

**주요 차이점:**

1. **인스턴스화 불가**
   - 일반 클래스: `new ClassName()`로 객체 생성 가능
   - 추상 클래스: 직접 객체 생성 불가, 하위 클래스를 통해서만 사용

2. **추상 메서드 포함 가능**
   - 일반 클래스: 모든 메서드가 구현을 가져야 함
   - 추상 클래스: 구현이 없는 추상 메서드를 가질 수 있음

3. **목적**
   - 일반 클래스: 직접 사용 가능한 완전한 클래스
   - 추상 클래스: 공통 기능을 정의하고 하위 클래스가 세부 구현을 완성하도록 강제

```java
// 일반 클래스
class Dog {
    public void bark() {
        System.out.println("멍멍!");
    }
}

// 추상 클래스
abstract class Animal {
    public abstract void makeSound();  // 추상 메서드

    public void breathe() {  // 일반 메서드
        System.out.println("숨을 쉽니다");
    }
}

// 사용
Dog dog = new Dog();  // ✅ 가능
// Animal animal = new Animal();  // ❌ 불가능 (컴파일 에러)
```

---

#### Q2. 추상 메서드는 무엇이며, 왜 사용하나요?

**모범 답변:**

추상 메서드는 선언만 있고 구현(메서드 본문)이 없는 메서드로, `abstract` 키워드로 선언됩니다. 하위 클래스에서 반드시 구현해야 합니다.

**사용 이유:**

1. **구현 강제**: 하위 클래스가 특정 메서드를 반드시 구현하도록 강제
2. **다형성 보장**: 부모 타입으로 참조해도 각 하위 클래스의 고유한 동작 호출 가능
3. **설계 일관성**: 모든 하위 클래스가 동일한 인터페이스를 제공

```java
abstract class Shape {
    // 추상 메서드 - 구현 없음
    public abstract double getArea();
    public abstract double getPerimeter();
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    // 반드시 구현해야 함!
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}
```

---

#### Q3. 추상 클래스와 인터페이스의 차이점을 설명해주세요.

**모범 답변:**

| 구분 | 추상 클래스 | 인터페이스 |
|------|-------------|-----------|
| **상속** | 단일 상속만 가능 | 다중 구현 가능 |
| **필드** | 인스턴스 변수 가능 | 상수만 가능 (public static final) |
| **메서드** | 추상/일반/static/final 모두 가능 | 추상/default/static 가능 (Java 8+) |
| **생성자** | 가질 수 있음 | 가질 수 없음 |
| **접근 제어자** | 모든 접근 제어자 가능 | public만 가능 |
| **관계** | IS-A (상속 관계) | CAN-DO (능력/행위) |

```java
// 추상 클래스
abstract class Animal {
    protected String name;  // 인스턴스 변수

    public Animal(String name) {  // 생성자
        this.name = name;
    }

    public void sleep() {  // 일반 메서드
        System.out.println(name + "이(가) 잠을 잡니다");
    }

    public abstract void makeSound();  // 추상 메서드
}

// 인터페이스
interface Flyable {
    // 상수만 가능
    int MAX_ALTITUDE = 10000;

    // 추상 메서드
    void fly();
    void land();

    // default 메서드 (Java 8+)
    default void takeOff() {
        System.out.println("이륙합니다");
    }
}

// 사용
class Bird extends Animal implements Flyable {
    public Bird(String name) {
        super(name);
    }

    @Override
    public void makeSound() {
        System.out.println("짹짹!");
    }

    @Override
    public void fly() {
        System.out.println(name + "이(가) 날아갑니다");
    }

    @Override
    public void land() {
        System.out.println(name + "이(가) 착륙합니다");
    }
}
```

**선택 기준:**
- 공통 상태(필드)와 로직을 공유해야 한다면 → **추상 클래스**
- 다중 상속이 필요하거나 행위만 정의한다면 → **인터페이스**

---

#### Q4. 추상 클래스를 왜 인스턴스화할 수 없나요?

**모범 답변:**

추상 클래스는 "불완전한 클래스"이기 때문에 인스턴스화할 수 없습니다.

**이유:**

1. **구현되지 않은 메서드 존재**
   - 추상 메서드는 메서드 본문(구현)이 없음
   - 만약 객체를 만들 수 있다면, 구현이 없는 메서드를 호출하는 문제 발생

2. **설계 의도**
   - 추상 클래스는 "설계도" 역할
   - 실제 사용 가능한 "완제품"은 하위 클래스에서 만들어야 함

3. **다형성을 위한 타입으로 사용**
   - 추상 클래스는 타입으로는 사용 가능
   - 실제 객체는 하위 클래스의 인스턴스

```java
abstract class Vehicle {
    public abstract void start();  // 구현 없음!
}

class Car extends Vehicle {
    @Override
    public void start() {
        System.out.println("자동차 시동");
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // Vehicle v = new Vehicle();  // ❌ 컴파일 에러!
        // start() 메서드를 호출하면 어떻게 동작해야 할까? 구현이 없으니 불가능!

        Vehicle v = new Car();  // ✅ OK
        v.start();  // "자동차 시동" 출력
    }
}
```

---

#### Q5. 추상 클래스에도 생성자가 필요한가요?

**모범 답변:**

네, 추상 클래스도 생성자를 가질 수 있고, 대부분의 경우 유용합니다.

**생성자가 필요한 이유:**

1. **부모 클래스의 필드 초기화**
   - 추상 클래스도 필드를 가질 수 있음
   - 이 필드들을 초기화하기 위해 생성자 필요

2. **하위 클래스에서 호출**
   - 하위 클래스의 생성자에서 `super()`로 호출
   - 부모의 초기화 로직 실행

3. **공통 초기화 로직**
   - 모든 하위 클래스에 공통으로 필요한 초기화를 한 곳에서 처리

```java
abstract class Employee {
    protected String name;
    protected String id;
    protected int baseSalary;

    // 추상 클래스의 생성자
    public Employee(String name, String id, int baseSalary) {
        this.name = name;
        this.id = id;
        this.baseSalary = baseSalary;

        System.out.println("직원 등록: " + name);
    }

    public abstract int calculateSalary();
}

class FullTimeEmployee extends Employee {
    private int bonus;

    public FullTimeEmployee(String name, String id, int baseSalary, int bonus) {
        super(name, id, baseSalary);  // 부모 생성자 호출 (필수!)
        this.bonus = bonus;
    }

    @Override
    public int calculateSalary() {
        return baseSalary + bonus;
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        Employee emp = new FullTimeEmployee("김철수", "EMP001", 3000000, 500000);
        // 출력: 직원 등록: 김철수

        System.out.println("급여: " + emp.calculateSalary());
        // 출력: 급여: 3500000
    }
}
```

**핵심:**
- 추상 클래스는 직접 인스턴스화할 수 없지만, 생성자는 가질 수 있음
- 하위 클래스 객체가 생성될 때 부모 생성자가 먼저 실행됨

---

#### Q6. final 메서드와 추상 메서드의 차이는 무엇인가요?

**모범 답변:**

final 메서드와 추상 메서드는 정반대의 개념입니다.

| 구분 | final 메서드 | 추상 메서드 |
|------|-------------|------------|
| **구현** | 반드시 구현이 있어야 함 | 구현이 없음 (선언만) |
| **오버라이드** | 오버라이드 불가능 (금지) | 오버라이드 필수 (강제) |
| **목적** | 메서드 변경 방지 | 하위 클래스에서 구현 강제 |
| **위치** | 일반/추상 클래스 모두 가능 | 추상 클래스에만 가능 |

```java
abstract class Game {

    /**
     * final 메서드 - 게임의 전체 흐름 (변경 불가)
     */
    public final void play() {
        start();
        playTurn();
        end();
    }

    /**
     * 추상 메서드 - 하위 클래스에서 구현 필수
     */
    public abstract void start();
    public abstract void playTurn();
    public abstract void end();
}

class ChessGame extends Game {

    // play() 메서드는 final이므로 오버라이드 불가!
    // @Override
    // public void play() { }  // 컴파일 에러!

    // 추상 메서드는 반드시 구현해야 함
    @Override
    public void start() {
        System.out.println("체스 게임 시작");
    }

    @Override
    public void playTurn() {
        System.out.println("체스 턴 진행");
    }

    @Override
    public void end() {
        System.out.println("체스 게임 종료");
    }
}
```

**언제 사용하나요?**
- **final 메서드**: 핵심 로직을 보호하고 싶을 때 (템플릿 메서드 패턴)
- **추상 메서드**: 하위 클래스마다 다른 구현이 필요할 때

---

#### Q7. 추상 클래스를 상속받으면 반드시 모든 추상 메서드를 구현해야 하나요?

**모범 답변:**

일반적으로는 **예**이지만, 예외가 있습니다.

**경우 1: 구체 클래스 (Concrete Class)**
- 추상 클래스를 상속받는 클래스가 일반 클래스라면, 모든 추상 메서드를 반드시 구현해야 함
- 하나라도 구현하지 않으면 컴파일 에러

**경우 2: 또 다른 추상 클래스**
- 추상 클래스를 상속받는 클래스가 또 다른 추상 클래스라면, 구현하지 않아도 됨
- 추상 메서드를 그대로 물려받음

```java
// 최상위 추상 클래스
abstract class Animal {
    public abstract void eat();
    public abstract void sleep();
    public abstract void makeSound();
}

// 경우 1: 일반 클래스 - 모든 추상 메서드를 구현해야 함
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("개가 먹이를 먹습니다");
    }

    @Override
    public void sleep() {
        System.out.println("개가 잠을 잡니다");
    }

    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}

// 경우 2: 추상 클래스 - 일부만 구현해도 됨
abstract class Mammal extends Animal {
    // eat()과 sleep()만 구현
    @Override
    public void eat() {
        System.out.println("포유류가 먹이를 먹습니다");
    }

    @Override
    public void sleep() {
        System.out.println("포유류가 잠을 잡니다");
    }

    // makeSound()는 구현하지 않음 (여전히 추상)
}

// Mammal을 상속받는 구체 클래스
class Cat extends Mammal {
    // eat()과 sleep()은 이미 구현되어 있음
    // makeSound()만 구현하면 됨
    @Override
    public void makeSound() {
        System.out.println("야옹!");
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // Animal animal = new Animal();  // ❌ 불가능
        // Mammal mammal = new Mammal();  // ❌ 불가능

        Animal dog = new Dog();  // ✅ OK
        dog.eat();
        dog.sleep();
        dog.makeSound();

        Animal cat = new Cat();  // ✅ OK
        cat.eat();      // Mammal의 구현 사용
        cat.sleep();    // Mammal의 구현 사용
        cat.makeSound();  // Cat의 구현 사용
    }
}
```

---

### 중급 레벨 (Intermediate Level)

#### Q8. 템플릿 메서드 패턴을 설명하고, 추상 클래스와 어떤 관련이 있나요?

**모범 답변:**

템플릿 메서드 패턴은 알고리즘의 구조(골격)를 부모 클래스에서 정의하고, 세부 구현은 하위 클래스에 위임하는 디자인 패턴입니다. 추상 클래스를 사용하여 구현합니다.

**핵심 구성 요소:**

1. **템플릿 메서드** (final 메서드)
   - 알고리즘의 전체 흐름을 정의
   - 하위 클래스에서 변경할 수 없도록 final로 선언

2. **추상 메서드**
   - 하위 클래스에서 반드시 구현해야 하는 단계

3. **Hook 메서드**
   - 선택적으로 오버라이드할 수 있는 메서드
   - 기본 구현을 제공하거나 비어 있음

```java
abstract class CaffeineBeverage {

    /**
     * 템플릿 메서드 - 음료를 만드는 전체 알고리즘 정의
     * final로 선언하여 하위 클래스에서 변경 불가
     */
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();

        if (customerWantsCondiments()) {  // Hook 메서드 호출
            addCondiments();
        }
    }

    // 공통 메서드
    private void boilWater() {
        System.out.println("물을 끓입니다");
    }

    private void pourInCup() {
        System.out.println("컵에 따릅니다");
    }

    // 추상 메서드 - 하위 클래스에서 구현 필수
    protected abstract void brew();
    protected abstract void addCondiments();

    // Hook 메서드 - 선택적 오버라이드
    protected boolean customerWantsCondiments() {
        return true;  // 기본값: 첨가물 추가
    }
}

class Coffee extends CaffeineBeverage {
    @Override
    protected void brew() {
        System.out.println("필터를 통해 커피를 우려냅니다");
    }

    @Override
    protected void addCondiments() {
        System.out.println("설탕과 우유를 추가합니다");
    }
}

class Tea extends CaffeineBeverage {
    @Override
    protected void brew() {
        System.out.println("차를 우려냅니다");
    }

    @Override
    protected void addCondiments() {
        System.out.println("레몬을 추가합니다");
    }

    // Hook 메서드 오버라이드
    @Override
    protected boolean customerWantsCondiments() {
        return false;  // 레몬을 추가하지 않음
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        System.out.println("=== 커피 제조 ===");
        CaffeineBeverage coffee = new Coffee();
        coffee.prepareRecipe();

        System.out.println("\n=== 차 제조 ===");
        CaffeineBeverage tea = new Tea();
        tea.prepareRecipe();
    }
}
```

**장점:**
- 알고리즘의 구조를 재사용
- 중복 코드 제거
- 확장에는 열려있고 수정에는 닫혀있음 (Open-Closed Principle)

---

#### Q9. 추상 클래스를 사용할 때의 장단점은 무엇인가요?

**모범 답변:**

**장점:**

1. **코드 재사용성**
   - 공통 필드와 메서드를 부모 클래스에서 한 번만 구현
   - 하위 클래스에서 중복 코드 제거

2. **일관된 인터페이스 제공**
   - 모든 하위 클래스가 동일한 메서드를 제공하도록 강제
   - 다형성을 통해 동일한 방식으로 처리 가능

3. **템플릿 메서드 패턴 구현**
   - 알고리즘의 구조를 정의하고 세부 구현은 위임
   - final 메서드로 핵심 로직 보호 가능

4. **부분적인 구현 제공**
   - 인터페이스와 달리 일부 메서드는 구현을 제공할 수 있음
   - 하위 클래스는 필요한 부분만 오버라이드

5. **생성자와 필드 사용 가능**
   - 공통 초기화 로직을 생성자에서 처리
   - 상태를 가질 수 있음

**단점:**

1. **단일 상속만 가능**
   - Java는 다중 상속을 지원하지 않음
   - 이미 다른 클래스를 상속받고 있다면 추상 클래스를 상속받을 수 없음

2. **강한 결합도**
   - 부모 클래스 변경 시 모든 하위 클래스에 영향
   - 상속 계층이 깊어질수록 복잡도 증가

3. **유연성 감소**
   - 인터페이스에 비해 유연성이 떨어짐
   - 설계 변경이 어려울 수 있음

4. **테스트 어려움**
   - 추상 클래스는 직접 테스트할 수 없음
   - 테스트용 하위 클래스를 만들어야 함

```java
// 장점 예시: 코드 재사용
abstract class DatabaseConnection {
    protected String url;
    protected String username;
    protected String password;

    // 공통 필드와 생성자
    public DatabaseConnection(String url, String username, String password) {
        this.url = url;
        this.username = username;
        this.password = password;
    }

    // 공통 메서드 (모든 DB 연결에서 사용)
    public void connect() {
        System.out.println("연결 중: " + url);
        authenticate();
        openConnection();
    }

    protected void authenticate() {
        System.out.println("인증 중: " + username);
    }

    // 추상 메서드 (DB마다 다름)
    protected abstract void openConnection();
    public abstract void executeQuery(String query);
}

// MySQL 구현
class MySQLConnection extends DatabaseConnection {
    public MySQLConnection(String url, String username, String password) {
        super(url, username, password);
    }

    @Override
    protected void openConnection() {
        System.out.println("MySQL 연결 열기");
    }

    @Override
    public void executeQuery(String query) {
        System.out.println("MySQL 쿼리 실행: " + query);
    }
}

// 단점 예시: 단일 상속 제한
class LoggableConnection {
    public void log(String message) {
        System.out.println("[LOG] " + message);
    }
}

// 컴파일 에러! 두 클래스를 동시에 상속받을 수 없음
// class PostgreSQLConnection extends DatabaseConnection, LoggableConnection {
// }

// 해결책: 인터페이스 사용
interface Loggable {
    void log(String message);
}

class PostgreSQLConnection extends DatabaseConnection implements Loggable {
    public PostgreSQLConnection(String url, String username, String password) {
        super(url, username, password);
    }

    @Override
    protected void openConnection() {
        System.out.println("PostgreSQL 연결 열기");
    }

    @Override
    public void executeQuery(String query) {
        log("쿼리 실행: " + query);
        System.out.println("PostgreSQL 쿼리 실행: " + query);
    }

    @Override
    public void log(String message) {
        System.out.println("[PostgreSQL LOG] " + message);
    }
}
```

---

#### Q10. 추상 클래스와 인터페이스를 함께 사용하는 경우가 있나요? 언제 사용하나요?

**모범 답변:**

네, 추상 클래스와 인터페이스를 함께 사용하는 것은 매우 일반적이고 권장되는 패턴입니다.

**함께 사용하는 이유:**

1. **추상 클래스의 장점 + 인터페이스의 장점**
   - 추상 클래스: 공통 구현 제공
   - 인터페이스: 다중 상속, 유연한 설계

2. **역할 분리**
   - 인터페이스: "무엇을 할 수 있는가" (능력)
   - 추상 클래스: "어떻게 하는가" (구현)

```java
// 인터페이스: 능력 정의
interface Drawable {
    void draw();
}

interface Clickable {
    void onClick();
}

interface Draggable {
    void onDrag(int x, int y);
}

// 추상 클래스: 공통 구현 제공
abstract class UIComponent implements Drawable, Clickable {
    protected int x, y, width, height;
    protected String name;
    protected boolean visible = true;

    public UIComponent(String name, int x, int y, int width, int height) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    // 공통 메서드
    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    public boolean isVisible() {
        return visible;
    }

    // 일부 인터페이스 메서드의 기본 구현
    @Override
    public void onClick() {
        System.out.println(name + " 클릭됨 (" + x + ", " + y + ")");
    }

    // draw()는 여전히 추상 메서드 (하위 클래스에서 구현 필수)
}

// 구체 클래스들
class Button extends UIComponent {
    private String label;

    public Button(String name, int x, int y, int width, int height, String label) {
        super(name, x, y, width, height);
        this.label = label;
    }

    @Override
    public void draw() {
        if (visible) {
            System.out.println("[버튼 그리기] " + label + " at (" + x + ", " + y + ")");
        }
    }

    @Override
    public void onClick() {
        super.onClick();
        System.out.println("→ 버튼 동작 실행: " + label);
    }
}

class Panel extends UIComponent implements Draggable {
    private java.util.List<UIComponent> children = new java.util.ArrayList<>();

    public Panel(String name, int x, int y, int width, int height) {
        super(name, x, y, width, height);
    }

    public void addChild(UIComponent child) {
        children.add(child);
    }

    @Override
    public void draw() {
        if (visible) {
            System.out.println("[패널 그리기] " + name + " at (" + x + ", " + y + ")");
            for (UIComponent child : children) {
                child.draw();
            }
        }
    }

    @Override
    public void onDrag(int newX, int newY) {
        System.out.println(name + " 드래그: (" + x + ", " + y + ") → (" + newX + ", " + newY + ")");
        this.x = newX;
        this.y = newY;
    }
}

class Image extends UIComponent implements Draggable {
    private String imagePath;

    public Image(String name, int x, int y, int width, int height, String imagePath) {
        super(name, x, y, width, height);
        this.imagePath = imagePath;
    }

    @Override
    public void draw() {
        if (visible) {
            System.out.println("[이미지 그리기] " + imagePath + " at (" + x + ", " + y + ")");
        }
    }

    @Override
    public void onDrag(int newX, int newY) {
        System.out.println("이미지 드래그: " + imagePath);
        this.x = newX;
        this.y = newY;
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // UI 컴포넌트 생성
        Button button = new Button("btn1", 10, 10, 100, 30, "확인");
        Panel panel = new Panel("panel1", 50, 50, 300, 200);
        Image image = new Image("img1", 100, 100, 50, 50, "/images/logo.png");

        panel.addChild(button);
        panel.addChild(image);

        // 모든 UI 컴포넌트를 그리기
        System.out.println("=== UI 렌더링 ===");
        panel.draw();

        // 클릭 이벤트
        System.out.println("\n=== 클릭 이벤트 ===");
        button.onClick();
        panel.onClick();

        // 드래그 이벤트 (Draggable 인터페이스를 구현한 컴포넌트만)
        System.out.println("\n=== 드래그 이벤트 ===");
        panel.onDrag(100, 100);
        image.onDrag(150, 150);
    }
}
```

**패턴:**
- 인터페이스로 "계약"을 정의 (`Drawable`, `Clickable`, `Draggable`)
- 추상 클래스로 "기본 구현"과 "공통 상태"를 제공 (`UIComponent`)
- 구체 클래스에서 세부 구현 완성 (`Button`, `Panel`, `Image`)

---

#### Q11. Java 8 이후 인터페이스에 default 메서드가 추가되면서 추상 클래스의 필요성이 줄어들었나요?

**모범 답변:**

Java 8에서 인터페이스에 default 메서드가 추가되면서 인터페이스와 추상 클래스의 경계가 모호해진 것은 사실이지만, 추상 클래스는 여전히 중요하고 필요합니다.

**추상 클래스만 할 수 있는 것:**

1. **인스턴스 필드 (상태) 보유**
   - 인터페이스: 상수(public static final)만 가능
   - 추상 클래스: 일반 인스턴스 변수 가능

2. **생성자 제공**
   - 인터페이스: 생성자 없음
   - 추상 클래스: 생성자로 초기화 로직 제공

3. **protected/private 메서드**
   - 인터페이스: public만 가능 (Java 9+ private 가능하지만 제한적)
   - 추상 클래스: 모든 접근 제어자 사용 가능

4. **final 메서드**
   - 인터페이스: final 메서드 선언 불가
   - 추상 클래스: final 메서드로 변경 방지 가능

```java
// 인터페이스의 한계
interface Shape {
    // ❌ 인스턴스 필드 불가능
    // private String color;  // 컴파일 에러!

    // ✅ 상수만 가능
    String DEFAULT_COLOR = "BLACK";

    // ❌ 생성자 불가능
    // Shape() { }  // 컴파일 에러!

    // ✅ default 메서드
    default void printInfo() {
        System.out.println("도형입니다");
    }

    // ❌ final 메서드 불가능
    // public final void validate() { }  // 컴파일 에러!

    // 추상 메서드
    double getArea();
}

// 추상 클래스의 장점
abstract class AbstractShape {
    // ✅ 인스턴스 필드
    protected String color;
    protected int id;
    private static int nextId = 1;

    // ✅ 생성자
    public AbstractShape(String color) {
        this.color = color;
        this.id = nextId++;
        System.out.println("도형 생성 (ID: " + id + ", 색상: " + color + ")");
    }

    // ✅ final 메서드 - 하위 클래스에서 변경 불가
    public final int getId() {
        return id;
    }

    // ✅ protected 메서드 - 하위 클래스에서만 접근 가능
    protected void validate() {
        if (color == null || color.isEmpty()) {
            throw new IllegalStateException("색상이 설정되지 않았습니다");
        }
    }

    // ✅ private 메서드 - 내부에서만 사용
    private void log(String message) {
        System.out.println("[LOG] " + message);
    }

    // 공통 메서드
    public void printInfo() {
        validate();
        log("도형 정보 출력");
        System.out.println("ID: " + id + ", 색상: " + color);
    }

    // 추상 메서드
    public abstract double getArea();
}

// 구체 클래스
class Circle extends AbstractShape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);  // 부모 생성자 호출
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    // getId()는 final이므로 오버라이드 불가!
}

// 테스트
public class Test {
    public static void main(String[] args) {
        Circle circle = new Circle("RED", 5.0);
        circle.printInfo();
        System.out.println("넓이: " + circle.getArea());
        System.out.println("ID: " + circle.getId());

        Circle circle2 = new Circle("BLUE", 3.0);
        circle2.printInfo();
        System.out.println("ID: " + circle2.getId());
    }
}
```

**결론:**
- Java 8+에서도 추상 클래스는 여전히 필요
- 상태를 가져야 하거나 생성자가 필요하면 추상 클래스
- 다중 상속이 필요하거나 행위만 정의하면 인터페이스
- 둘 다 사용하는 것이 최선인 경우가 많음

---

#### Q12. 추상 클래스 설계 시 주의해야 할 사항은 무엇인가요?

**모범 답변:**

추상 클래스는 강력한 도구이지만, 잘못 설계하면 유지보수가 어려워질 수 있습니다.

**주의사항:**

1. **너무 많은 책임을 부여하지 말 것**
   - 단일 책임 원칙(Single Responsibility Principle) 준수
   - 한 가지 개념/역할만 다루도록 설계

2. **추상 메서드를 과도하게 만들지 말 것**
   - 하위 클래스의 부담이 커짐
   - 공통 구현을 최대한 제공

3. **final과 abstract의 균형**
   - 핵심 로직은 final로 보호
   - 확장이 필요한 부분은 Hook 메서드로 제공

4. **인터페이스와의 역할 분리**
   - 추상 클래스: 구현 공유
   - 인터페이스: 계약 정의

5. **상속 깊이를 깊게 하지 말 것**
   - 3단계 이상 깊어지면 복잡도 증가
   - 구성(Composition)을 고려

6. **protected 필드보다 protected 메서드를 선호**
   - 캡슐화 유지
   - 나중에 구현 변경 용이

```java
// ❌ 나쁜 예: 너무 많은 책임
abstract class Employee_Bad {
    protected String name;
    protected int salary;

    // 급여 계산 관련
    public abstract int calculateSalary();
    public abstract int calculateBonus();
    public abstract int calculateTax();

    // 근태 관리 관련
    public abstract void checkIn();
    public abstract void checkOut();
    public abstract int getWorkHours();

    // 성과 평가 관련
    public abstract void evaluate();
    public abstract double getPerformanceScore();

    // 교육 관련
    public abstract void attendTraining();
    public abstract List<String> getCompletedTrainings();

    // 너무 많은 추상 메서드! 하위 클래스의 부담이 큼
}

// ✅ 좋은 예: 단일 책임, 공통 구현 제공
abstract class Employee_Good {
    protected String name;
    protected int id;
    protected int baseSalary;

    public Employee_Good(String name, int id, int baseSalary) {
        this.name = name;
        this.id = id;
        this.baseSalary = baseSalary;
    }

    /**
     * 템플릿 메서드: 급여 계산 프로세스 정의
     */
    public final int calculateTotalSalary() {
        int salary = baseSalary;
        salary += calculateBonus();
        salary -= calculateTax(salary);

        logSalaryCalculation(salary);

        return salary;
    }

    // 추상 메서드: 최소한만 정의
    protected abstract int calculateBonus();

    // 공통 메서드: 세금 계산 (모든 직원 동일)
    protected int calculateTax(int totalSalary) {
        return (int) (totalSalary * 0.1);  // 10% 세금
    }

    // Hook 메서드: 선택적 오버라이드
    protected void logSalaryCalculation(int salary) {
        System.out.println(name + "의 급여: " + salary + "원");
    }

    // protected 메서드로 필드 접근 제공 (직접 필드 노출 방지)
    protected int getBaseSalary() {
        return baseSalary;
    }

    // public getter
    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }
}

// 정규직
class FullTimeEmployee extends Employee_Good {
    private int performanceBonus;

    public FullTimeEmployee(String name, int id, int baseSalary, int performanceBonus) {
        super(name, id, baseSalary);
        this.performanceBonus = performanceBonus;
    }

    @Override
    protected int calculateBonus() {
        return performanceBonus;
    }
}

// 계약직
class ContractEmployee extends Employee_Good {
    public ContractEmployee(String name, int id, int baseSalary) {
        super(name, id, baseSalary);
    }

    @Override
    protected int calculateBonus() {
        return 0;  // 계약직은 보너스 없음
    }

    @Override
    protected int calculateTax(int totalSalary) {
        // 계약직은 세금이 다름
        return (int) (totalSalary * 0.033);  // 3.3% 세금
    }
}

// ✅ 좋은 예: 구성(Composition) 활용
interface AttendanceManager {
    void checkIn();
    void checkOut();
    int getWorkHours();
}

interface PerformanceEvaluator {
    void evaluate();
    double getPerformanceScore();
}

class EnhancedEmployee extends Employee_Good {
    private AttendanceManager attendanceManager;
    private PerformanceEvaluator performanceEvaluator;

    public EnhancedEmployee(String name, int id, int baseSalary,
                          AttendanceManager attendanceManager,
                          PerformanceEvaluator performanceEvaluator) {
        super(name, id, baseSalary);
        this.attendanceManager = attendanceManager;
        this.performanceEvaluator = performanceEvaluator;
    }

    @Override
    protected int calculateBonus() {
        // 성과 점수에 따라 보너스 계산
        double score = performanceEvaluator.getPerformanceScore();
        return (int) (getBaseSalary() * score * 0.1);
    }

    public void checkIn() {
        attendanceManager.checkIn();
    }

    public void checkOut() {
        attendanceManager.checkOut();
    }

    public void evaluate() {
        performanceEvaluator.evaluate();
    }
}

// 테스트
public class Test {
    public static void main(String[] args) {
        // 정규직
        Employee_Good fullTime = new FullTimeEmployee("김철수", 1, 3000000, 500000);
        System.out.println("정규직 총 급여: " + fullTime.calculateTotalSalary() + "원\n");

        // 계약직
        Employee_Good contract = new ContractEmployee("이영희", 2, 2500000);
        System.out.println("계약직 총 급여: " + contract.calculateTotalSalary() + "원");
    }
}
```

**핵심 원칙:**
- 추상 클래스는 "구현 상속"을 위한 도구
- 너무 많은 것을 강요하지 말 것
- 공통 부분을 최대한 구현하여 하위 클래스의 부담 줄이기
- 필요하다면 구성(Composition)을 함께 사용

---

## 🎓 학습 완료!

이것으로 **추상 클래스 Part 3**를 완료했습니다!

### 다룬 내용:
- ✅ 실전 프로젝트: 전자상거래 결제 시스템 (완전한 구현)
- ✅ 7가지 FAQ
- ✅ 12가지 면접 질문 (주니어 7개 + 중급 5개)

### 다음 단계:
- Chapter 19: 인터페이스
- Chapter 20: Enum
- Chapter 21: Annotation
- Chapter 22: 내부 클래스
- Chapter 23: 예외 처리
