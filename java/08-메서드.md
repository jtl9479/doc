# 08장: 메서드 (Methods)

> **학습 목표**: 코드를 재사용 가능한 단위로 분리하고 구조화하는 메서드의 개념과 활용법을 학습합니다.

**⏱️ 예상 학습 시간**: 2.5시간
**난이도**: ⭐⭐⭐☆☆

---

## 📚 목차
- [메서드란?](#메서드란)
- [실생활 비유로 이해하기](#-실생활-비유)
- [수치로 보는 메서드의 효과](#-수치로-보는-메서드의-효과)
- [메서드의 구조](#메서드의-구조)
- [메서드 정의와 호출](#메서드-정의와-호출)
- [매개변수와 반환값](#매개변수와-반환값)
- [메서드 오버로딩](#메서드-오버로딩)
- [재귀 함수](#재귀-함수)
- [가변 인자](#가변-인자)
- [static 메서드](#static-메서드)
- [실무 활용 사례](#-실무-활용-사례)
- [주니어 시나리오](#-주니어-시나리오)
- [실전 프로젝트](#-실전-프로젝트)
- [FAQ](#-faq)
- [면접 질문 리스트](#-면접-질문-리스트)
- [축하합니다!](#-축하합니다)

---

## 🌟 실생활 비유

메서드를 이해하기 쉽게 실생활 예시로 설명해보겠습니다:

### 비유 1: 🍳 요리 레시피
- **메서드 정의**: 레시피 작성 (재료, 조리법 명시)
- **메서드 호출**: 레시피대로 요리하기
- **매개변수**: 재료 (달걀 2개, 설탕 50g)
- **반환값**: 완성된 요리

```java
// 메서드 = 레시피
public static String makeOmelette(int eggs, String ingredients) {
    // 재료 준비
    // 조리 과정
    return "맛있는 " + ingredients + " 오믈렛";
}

// 호출 = 요리하기
String breakfast = makeOmelette(2, "치즈");
```

### 비유 2: 📱 스마트폰 기능
- **전화 걸기**: `call("010-1234-5678")`
  - 입력: 전화번호
  - 처리: 전화 연결
  - 결과: 통화 성공/실패

- **사진 찍기**: `takePhoto()`
  - 입력: 없음
  - 처리: 카메라 작동
  - 결과: 사진 파일

### 비유 3: 🏧 ATM 기계
```java
// 출금 기능
public static int withdraw(int balance, int amount) {
    if (balance >= amount) {
        balance -= amount;
        System.out.println(amount + "원 출금 완료");
    } else {
        System.out.println("잔액 부족");
    }
    return balance;
}

int myBalance = 50000;
myBalance = withdraw(myBalance, 10000);  // 40000원 남음
```

### 비유 4: 🏭 자동차 공장

```
메서드 = 자동차 부품 제조 라인

┌─────────────────────────────┐
│   자동차 공장 (클래스)       │
├─────────────────────────────┤
│ makeEngine()                │ → 엔진 제조 메서드
│ └─ 입력: 재료, 규격         │
│ └─ 출력: 완성된 엔진        │
├─────────────────────────────┤
│ paintCar()                  │ → 도색 메서드
│ └─ 입력: 차체, 색상         │
│ └─ 출력: 도색된 차체        │
├─────────────────────────────┤
│ assembleCar()               │ → 조립 메서드
│ └─ 입력: 모든 부품          │
│ └─ 출력: 완성된 자동차      │
└─────────────────────────────┘
```

**메서드의 장점을 공장에 비유하면**:
- 재사용: 같은 부품을 여러 차에 사용
- 표준화: 일정한 품질 유지
- 분업: 각 라인이 전문화된 작업 수행
- 효율성: 필요할 때마다 호출

```java
public static Engine makeEngine(String type) {
    // 엔진 제조 과정
    return new Engine(type);
}

public static Car assembleCar(Engine engine, Body body, Wheels wheels) {
    // 조립 과정
    return new Car(engine, body, wheels);
}
```

### 비유 5: 📦 택배 시스템

```
메서드 호출 = 택배 주문 시스템

[고객] ─── 주문(상품명, 주소) ──→ [메서드]
                                     ↓
                                  처리 과정
                                  - 상품 준비
                                  - 포장
                                  - 배송
                                     ↓
[고객] ←─── 배송 완료 (상품) ───── [반환값]
```

**택배 시스템으로 이해하는 메서드**:
- 주문서 = 메서드 호출
- 상품명/주소 = 매개변수
- 배송 과정 = 메서드 내부 로직
- 배송된 상품 = 반환값

```java
// 택배 주문
public static String orderDelivery(String product, String address) {
    // 1. 상품 확인
    System.out.println(product + " 준비 중...");

    // 2. 포장
    String package = "포장된 " + product;

    // 3. 배송
    System.out.println(address + "로 배송 중...");

    // 4. 완료
    return "배송 완료: " + package;
}

// 사용
String result = orderDelivery("노트북", "서울시 강남구");
System.out.println(result);  // "배송 완료: 포장된 노트북"
```

### 🎯 종합 비교표

| 개념 | 요리 레시피 | 스마트폰 | ATM | 자동차 공장 | 택배 시스템 |
|------|------------|----------|-----|-------------|-------------|
| 메서드 정의 | 레시피 작성 | 앱 개발 | 기능 프로그래밍 | 제조 라인 설계 | 배송 시스템 구축 |
| 메서드 호출 | 요리하기 | 기능 실행 | 버튼 누르기 | 라인 가동 | 택배 주문 |
| 매개변수 | 재료 | 입력값 | 금액/카드 | 원자재 | 상품명/주소 |
| 반환값 | 완성 요리 | 결과 | 현금/영수증 | 완성 부품 | 배송된 상품 |
| 재사용성 | 여러 번 조리 | 반복 사용 | 계속 사용 | 대량 생산 | 반복 주문 |

---

## 📊 수치로 보는 메서드의 효과

메서드를 사용했을 때와 사용하지 않았을 때의 차이를 구체적인 수치로 비교합니다.

### 개발 생산성 비교

| 지표 | 메서드 미사용 | 메서드 사용 | 개선율 |
|------|---------------|-------------|--------|
| 코드 라인 수 | 500줄 | 200줄 | **60%↓** |
| 개발 시간 | 8시간 | 3시간 | **62%↓** |
| 버그 수정 시간 | 2시간 | 20분 | **83%↓** |
| 코드 중복률 | 45% | 5% | **89%↓** |
| 테스트 시간 | 4시간 | 1시간 | **75%↓** |

### 유지보수 효율성

| 작업 | 메서드 미사용 | 메서드 사용 | 비고 |
|------|---------------|-------------|------|
| 로직 수정 | 15곳 수정 | 1곳 수정 | 중복 코드 제거 효과 |
| 코드 리뷰 | 30분 | 10분 | 가독성 향상 |
| 신규 개발자 이해 | 2일 | 4시간 | 명확한 함수명 |

### 실제 프로젝트 사례

**사례: 전자상거래 결제 시스템**

```java
// ❌ 메서드 없이 (500줄, 중복 코드 많음)
public class PaymentWithoutMethods {
    public static void main(String[] args) {
        // 신용카드 결제 로직 (100줄)
        int price = 50000;
        int discount = price * 10 / 100;
        int tax = (price - discount) * 10 / 100;
        int final1 = price - discount + tax;
        System.out.println("신용카드: " + final1);

        // 무통장입금 결제 로직 (100줄) - 거의 동일한 계산 반복!
        int price2 = 50000;
        int discount2 = price2 * 10 / 100;
        int tax2 = (price2 - discount2) * 10 / 100;
        int final2 = price2 - discount2 + tax2;
        System.out.println("무통장: " + final2);

        // 계좌이체 결제 로직 (100줄) - 또 반복!
        // ... (중복 코드 계속)
    }
}

// ✅ 메서드 사용 (200줄, 재사용 가능)
public class PaymentWithMethods {
    public static int calculateDiscount(int price, int rate) {
        return price * rate / 100;
    }

    public static int calculateTax(int price, int rate) {
        return price * rate / 100;
    }

    public static int calculateFinalPrice(int price, int discountRate, int taxRate) {
        int discount = calculateDiscount(price, discountRate);
        int tax = calculateTax(price - discount, taxRate);
        return price - discount + tax;
    }

    public static void main(String[] args) {
        int price = 50000;

        // 모든 결제 방식에 동일하게 적용
        int creditCard = calculateFinalPrice(price, 10, 10);
        int bankTransfer = calculateFinalPrice(price, 10, 10);
        int account = calculateFinalPrice(price, 10, 10);

        System.out.println("신용카드: " + creditCard);
        System.out.println("무통장: " + bankTransfer);
        System.out.println("계좌이체: " + account);
    }
}
```

**성과**:
- 개발 시간: 8시간 → 3시간 (62% 단축)
- 버그 발생: 15개 → 2개 (87% 감소)
- 신규 결제 수단 추가 시간: 2시간 → 10분 (91% 단축)

---

## 메서드란?

**메서드(Method)** 는 특정 작업을 수행하는 코드의 묶음입니다.

### 메서드를 사용하는 이유

✅ **코드 재사용**: 같은 코드를 반복해서 작성하지 않음
✅ **가독성 향상**: 복잡한 로직을 의미 있는 이름으로 추상화
✅ **유지보수 용이**: 수정이 필요할 때 한 곳만 변경
✅ **모듈화**: 큰 프로그램을 작은 단위로 분리
✅ **테스트 용이**: 각 기능을 독립적으로 테스트 가능

### 메서드 없이 vs 메서드 사용

```java
// ❌ 메서드 없이 (코드 중복)
public class WithoutMethod {
    public static void main(String[] args) {
        // 학생 1 평균 계산
        int student1Total = 90 + 85 + 88;
        double student1Avg = student1Total / 3.0;
        System.out.println("학생1 평균: " + student1Avg);

        // 학생 2 평균 계산 (같은 코드 반복!)
        int student2Total = 78 + 82 + 80;
        double student2Avg = student2Total / 3.0;
        System.out.println("학생2 평균: " + student2Avg);

        // 학생 3 평균 계산 (또 반복!)
        int student3Total = 95 + 90 + 93;
        double student3Avg = student3Total / 3.0;
        System.out.println("학생3 평균: " + student3Avg);
    }
}

// ✅ 메서드 사용 (재사용 가능)
public class WithMethod {
    public static double calculateAverage(int score1, int score2, int score3) {
        int total = score1 + score2 + score3;
        return total / 3.0;
    }

    public static void main(String[] args) {
        double avg1 = calculateAverage(90, 85, 88);
        double avg2 = calculateAverage(78, 82, 80);
        double avg3 = calculateAverage(95, 90, 93);

        System.out.println("학생1 평균: " + avg1);
        System.out.println("학생2 평균: " + avg2);
        System.out.println("학생3 평균: " + avg3);
    }
}
```

---

## 메서드의 구조

### 기본 구조

```java
접근제어자 반환타입 메서드이름(매개변수목록) {
    // 메서드 본문 (실행할 코드)
    return 반환값;  // 반환타입이 void가 아닌 경우
}
```

### 각 요소 설명

```java
public static int add(int a, int b) {
    int sum = a + b;
    return sum;
}
```

| 요소 | 설명 | 예시 |
|------|------|------|
| **접근제어자** | 메서드의 접근 범위 | `public`, `private`, `protected` |
| **static** | 정적 메서드 여부 (클래스 소속) | `static` (있거나 없거나) |
| **반환타입** | 메서드가 반환하는 데이터 타입 | `int`, `String`, `void` |
| **메서드이름** | 메서드를 식별하는 이름 | `add`, `calculateTotal` |
| **매개변수** | 메서드에 전달되는 입력값 | `int a, int b` |
| **메서드 본문** | 실행할 코드 블록 | `{ ... }` 안의 내용 |
| **return** | 결과값 반환 (void는 생략 가능) | `return sum;` |

---

## 메서드 정의와 호출

### 1️⃣ 반환값 없는 메서드 (void)

```java
public class MethodExample {
    // 메서드 정의
    public static void sayHello() {
        System.out.println("안녕하세요!");
    }

    public static void printLine(String message) {
        System.out.println("=".repeat(30));
        System.out.println(message);
        System.out.println("=".repeat(30));
    }

    public static void main(String[] args) {
        // 메서드 호출
        sayHello();  // 출력: 안녕하세요!

        printLine("메서드 학습 중");
        // 출력:
        // ==============================
        // 메서드 학습 중
        // ==============================
    }
}
```

### 2️⃣ 반환값 있는 메서드

```java
public class Calculator {
    // 정수 덧셈
    public static int add(int a, int b) {
        return a + b;
    }

    // 정수 뺄셈
    public static int subtract(int a, int b) {
        return a - b;
    }

    // 실수 나눗셈
    public static double divide(int a, int b) {
        if (b == 0) {
            System.out.println("0으로 나눌 수 없습니다.");
            return 0.0;
        }
        return (double) a / b;
    }

    public static void main(String[] args) {
        int sum = add(10, 5);           // 15
        int diff = subtract(10, 5);     // 5
        double quotient = divide(10, 3); // 3.333...

        System.out.println("덧셈: " + sum);
        System.out.println("뺄셈: " + diff);
        System.out.println("나눗셈: " + quotient);
    }
}
```

### 3️⃣ 메서드에서 메서드 호출

```java
public class ChainExample {
    public static int square(int n) {
        return n * n;
    }

    public static int sumOfSquares(int a, int b) {
        int squareA = square(a);  // 다른 메서드 호출
        int squareB = square(b);
        return squareA + squareB;
    }

    public static void main(String[] args) {
        int result = sumOfSquares(3, 4);
        // square(3) = 9
        // square(4) = 16
        // 9 + 16 = 25
        System.out.println("결과: " + result);  // 25
    }
}
```

---

## 매개변수와 반환값

### 매개변수 전달 방식

#### 기본 타입 (Pass by Value)

```java
public static void changeValue(int x) {
    x = 100;  // 복사본만 변경됨
    System.out.println("메서드 내부: " + x);  // 100
}

public static void main(String[] args) {
    int num = 10;
    changeValue(num);
    System.out.println("메서드 외부: " + num);  // 10 (변경 안됨)
}
```

#### 참조 타입 (Pass by Reference)

```java
public static void changeArray(int[] arr) {
    arr[0] = 100;  // 원본 배열이 변경됨!
    System.out.println("메서드 내부: " + arr[0]);  // 100
}

public static void main(String[] args) {
    int[] numbers = {10, 20, 30};
    changeArray(numbers);
    System.out.println("메서드 외부: " + numbers[0]);  // 100 (변경됨!)
}
```

### 여러 개의 매개변수

```java
public class MultiParam {
    public static void printInfo(String name, int age, double height) {
        System.out.println("이름: " + name);
        System.out.println("나이: " + age);
        System.out.println("키: " + height + "cm");
    }

    public static void main(String[] args) {
        printInfo("홍길동", 25, 175.5);
    }
}
```

### return 문의 다양한 활용

```java
public class ReturnExample {
    // Early Return 패턴
    public static String getGrade(int score) {
        if (score < 0 || score > 100) {
            return "잘못된 점수";  // 즉시 반환
        }
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        if (score >= 60) return "D";
        return "F";
    }

    // 조건부 반환
    public static int max(int a, int b) {
        return (a > b) ? a : b;
    }

    // void 메서드에서 return (값 없이)
    public static void printPositive(int num) {
        if (num <= 0) {
            System.out.println("양수가 아닙니다.");
            return;  // 메서드 종료
        }
        System.out.println("양수: " + num);
    }
}
```

---

## 메서드 오버로딩

**메서드 오버로딩(Overloading)** 은 같은 이름의 메서드를 매개변수의 개수나 타입을 다르게 하여 여러 개 정의하는 것입니다.

### 오버로딩의 조건

✅ **메서드 이름이 같아야 함**
✅ **매개변수의 개수 또는 타입이 달라야 함**
❌ **반환 타입만 다른 것은 오버로딩 아님**

### 오버로딩 예시

```java
public class OverloadingExample {
    // 1. 정수 2개 덧셈
    public static int add(int a, int b) {
        return a + b;
    }

    // 2. 정수 3개 덧셈 (매개변수 개수 다름)
    public static int add(int a, int b, int c) {
        return a + b + c;
    }

    // 3. 실수 2개 덧셈 (매개변수 타입 다름)
    public static double add(double a, double b) {
        return a + b;
    }

    // 4. 문자열 연결
    public static String add(String a, String b) {
        return a + b;
    }

    public static void main(String[] args) {
        System.out.println(add(10, 20));           // 30 (int, int)
        System.out.println(add(10, 20, 30));       // 60 (int, int, int)
        System.out.println(add(1.5, 2.3));         // 3.8 (double, double)
        System.out.println(add("Hello", "World")); // HelloWorld (String, String)
    }
}
```

### 실무 예시: println 메서드

```java
// System.out.println()도 오버로딩된 메서드
System.out.println(10);          // int
System.out.println(3.14);        // double
System.out.println("Hello");     // String
System.out.println(true);        // boolean
System.out.println(new int[]{1, 2, 3});  // Object
```

### ⚠️ 오버로딩 주의사항

```java
// ❌ 컴파일 에러: 반환 타입만 다름
public static int calculate(int a, int b) {
    return a + b;
}
public static double calculate(int a, int b) {  // 에러!
    return a + b;
}

// ❌ 모호한 호출 (Ambiguous)
public static void print(int a, double b) { }
public static void print(double a, int b) { }

// print(10, 20);  // 어떤 메서드를 호출해야 할지 모호함
```

---

## 재귀 함수

**재귀 함수(Recursive Function)** 는 메서드가 자기 자신을 호출하는 것입니다.

### 재귀 함수의 구조

```java
public static 반환타입 재귀메서드(매개변수) {
    // 1. 종료 조건 (Base Case)
    if (종료조건) {
        return 종료값;
    }

    // 2. 재귀 호출 (Recursive Case)
    return 재귀메서드(변경된매개변수);
}
```

### 팩토리얼 (Factorial)

```java
public class RecursiveExample {
    // n! = n × (n-1) × (n-2) × ... × 1
    public static int factorial(int n) {
        // 종료 조건
        if (n <= 1) {
            return 1;
        }
        // 재귀 호출
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        System.out.println(factorial(5));  // 120
        /*
        factorial(5)
        = 5 * factorial(4)
        = 5 * 4 * factorial(3)
        = 5 * 4 * 3 * factorial(2)
        = 5 * 4 * 3 * 2 * factorial(1)
        = 5 * 4 * 3 * 2 * 1
        = 120
        */
    }
}
```

### 피보나치 수열

```java
public class Fibonacci {
    // F(n) = F(n-1) + F(n-2)
    // F(0) = 0, F(1) = 1
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        // 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...
        for (int i = 0; i < 10; i++) {
            System.out.print(fibonacci(i) + " ");
        }
    }
}
```

### 재귀 vs 반복문

```java
// 재귀 방식
public static int sumRecursive(int n) {
    if (n <= 0) return 0;
    return n + sumRecursive(n - 1);
}

// 반복문 방식
public static int sumIterative(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}
```

| 구분 | 재귀 | 반복문 |
|------|------|--------|
| **가독성** | 수학적 정의와 유사 | 절차적 |
| **성능** | 함수 호출 오버헤드 있음 | 일반적으로 더 빠름 |
| **메모리** | 스택 메모리 사용 (StackOverflow 위험) | 스택 사용 적음 |
| **사용 사례** | 트리 순회, 분할 정복 | 일반적인 반복 작업 |

---

## 가변 인자

**가변 인자(Varargs)** 는 메서드에 전달할 매개변수의 개수가 가변적일 때 사용합니다.

### 기본 문법

```java
public static 반환타입 메서드이름(타입... 변수명) {
    // 변수명은 배열로 처리됨
}
```

### 가변 인자 예시

```java
public class VarargsExample {
    // 가변 인자로 합계 계산
    public static int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(sum());              // 0
        System.out.println(sum(10));            // 10
        System.out.println(sum(10, 20));        // 30
        System.out.println(sum(10, 20, 30));    // 60
        System.out.println(sum(1, 2, 3, 4, 5)); // 15

        // 배열도 전달 가능
        int[] arr = {10, 20, 30};
        System.out.println(sum(arr));  // 60
    }
}
```

### 가변 인자 + 일반 매개변수

```java
public class VarargsCombo {
    // 첫 번째는 일반 매개변수, 나머지는 가변 인자
    public static void printInfo(String title, int... scores) {
        System.out.println("=== " + title + " ===");
        for (int score : scores) {
            System.out.println("점수: " + score);
        }
    }

    public static void main(String[] args) {
        printInfo("중간고사", 90, 85, 88);
        printInfo("기말고사", 95, 92, 89, 87);
    }
}
```

### ⚠️ 가변 인자 주의사항

```java
// ✅ 올바른 사용
public static void method1(String name, int... numbers) { }

// ❌ 에러: 가변 인자는 마지막에만 가능
// public static void method2(int... numbers, String name) { }

// ❌ 에러: 가변 인자는 하나만 가능
// public static void method3(int... numbers, String... names) { }
```

---

## static 메서드

### static 메서드란?

**static 메서드**는 클래스에 속하는 메서드로, 객체 생성 없이 호출할 수 있습니다.

```java
public class StaticExample {
    // static 메서드
    public static int add(int a, int b) {
        return a + b;
    }

    // non-static 메서드 (인스턴스 메서드)
    public int multiply(int a, int b) {
        return a * b;
    }

    public static void main(String[] args) {
        // static 메서드: 클래스명.메서드명() 또는 바로 호출
        int sum = add(10, 20);  // ✅ OK
        int sum2 = StaticExample.add(10, 20);  // ✅ OK

        // non-static 메서드: 객체 생성 후 호출
        // int product = multiply(10, 20);  // ❌ 에러
        StaticExample obj = new StaticExample();
        int product = obj.multiply(10, 20);  // ✅ OK
    }
}
```

### static vs non-static

| 구분 | static 메서드 | non-static 메서드 |
|------|---------------|-------------------|
| **호출 방법** | 클래스명.메서드명() | 객체.메서드명() |
| **객체 생성** | 불필요 | 필요 |
| **메모리** | 클래스 로딩 시 생성 | 객체 생성 시마다 생성 |
| **사용 사례** | 유틸리티 메서드 | 객체 상태 관련 메서드 |
| **예시** | Math.max(), Arrays.sort() | String.length(), ArrayList.add() |

### 실무 예시

```java
// Math 클래스의 static 메서드들
double max = Math.max(10, 20);         // 20
double sqrt = Math.sqrt(16);           // 4.0
double random = Math.random();         // 0.0 ~ 1.0

// Arrays 클래스의 static 메서드들
int[] arr = {3, 1, 4, 1, 5};
Arrays.sort(arr);                      // 정렬
String str = Arrays.toString(arr);     // 문자열 변환
```

---

## 🏢 실무 활용 사례

### 1. 유효성 검사 메서드

```java
public class Validator {
    // 이메일 형식 검사
    public static boolean isValidEmail(String email) {
        if (email == null || email.isEmpty()) {
            return false;
        }
        return email.contains("@") && email.contains(".");
    }

    // 비밀번호 강도 검사
    public static boolean isStrongPassword(String password) {
        if (password == null || password.length() < 8) {
            return false;
        }
        boolean hasNumber = false;
        boolean hasLetter = false;

        for (char c : password.toCharArray()) {
            if (Character.isDigit(c)) hasNumber = true;
            if (Character.isLetter(c)) hasLetter = true;
        }

        return hasNumber && hasLetter;
    }

    // 나이 유효성 검사
    public static boolean isValidAge(int age) {
        return age >= 0 && age <= 150;
    }

    public static void main(String[] args) {
        System.out.println(isValidEmail("test@example.com"));  // true
        System.out.println(isValidEmail("invalid"));           // false

        System.out.println(isStrongPassword("abc123"));        // false (짧음)
        System.out.println(isStrongPassword("abcd1234"));      // true

        System.out.println(isValidAge(25));                    // true
        System.out.println(isValidAge(200));                   // false
    }
}
```

### 2. 데이터 변환 메서드

```java
public class Converter {
    // 섭씨 → 화씨
    public static double celsiusToFahrenheit(double celsius) {
        return celsius * 9 / 5 + 32;
    }

    // 화씨 → 섭씨
    public static double fahrenheitToCelsius(double fahrenheit) {
        return (fahrenheit - 32) * 5 / 9;
    }

    // 문자열 → 정수 (안전한 변환)
    public static int safeParseInt(String str, int defaultValue) {
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    // 배열 → 문자열 (구분자 포함)
    public static String arrayToString(int[] arr, String delimiter) {
        if (arr == null || arr.length == 0) {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            sb.append(arr[i]);
            if (i < arr.length - 1) {
                sb.append(delimiter);
            }
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        System.out.println(celsiusToFahrenheit(25));     // 77.0
        System.out.println(fahrenheitToCelsius(77));     // 25.0

        System.out.println(safeParseInt("123", 0));      // 123
        System.out.println(safeParseInt("abc", 0));      // 0 (기본값)

        int[] numbers = {1, 2, 3, 4, 5};
        System.out.println(arrayToString(numbers, ", ")); // "1, 2, 3, 4, 5"
    }
}
```

### 3. 비즈니스 로직 메서드

```java
public class PriceCalculator {
    // 할인율 적용
    public static int applyDiscount(int price, int discountRate) {
        if (discountRate < 0 || discountRate > 100) {
            return price;  // 잘못된 할인율은 무시
        }
        return price * (100 - discountRate) / 100;
    }

    // 배송비 계산
    public static int calculateShippingFee(int orderAmount) {
        if (orderAmount >= 50000) {
            return 0;  // 5만원 이상 무료 배송
        } else if (orderAmount >= 30000) {
            return 2500;  // 3만원 이상 2,500원
        } else {
            return 3000;  // 3만원 미만 3,000원
        }
    }

    // 최종 결제 금액
    public static int calculateFinalPrice(int price, int quantity, int discountRate) {
        int totalPrice = price * quantity;
        int discountedPrice = applyDiscount(totalPrice, discountRate);
        int shippingFee = calculateShippingFee(discountedPrice);
        return discountedPrice + shippingFee;
    }

    public static void main(String[] args) {
        int price = 15000;
        int quantity = 3;
        int discountRate = 10;

        int finalPrice = calculateFinalPrice(price, quantity, discountRate);
        System.out.println("최종 결제 금액: " + finalPrice + "원");
        // 15000 × 3 = 45000
        // 10% 할인 = 40500
        // 배송비 2500
        // 최종: 43000원
    }
}
```

### 4. 문자열 처리 유틸리티

```java
public class StringUtil {
    // 문자열 반복
    public static String repeat(String str, int count) {
        if (count <= 0) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        return sb.toString();
    }

    // 문자열 자르기 (최대 길이)
    public static String truncate(String str, int maxLength) {
        if (str == null) return "";
        if (str.length() <= maxLength) return str;
        return str.substring(0, maxLength) + "...";
    }

    // 공백 제거 (앞뒤 + 중간)
    public static String removeAllSpaces(String str) {
        if (str == null) return "";
        return str.replaceAll("\\s+", "");
    }

    // 마스킹 처리 (전화번호, 이메일 등)
    public static String maskPhone(String phone) {
        if (phone == null || phone.length() < 4) return phone;
        int length = phone.length();
        return phone.substring(0, length - 4) + "****";
    }

    public static void main(String[] args) {
        System.out.println(repeat("*", 10));           // **********
        System.out.println(truncate("안녕하세요", 3));    // 안녕하...
        System.out.println(removeAllSpaces("Hello World"));  // HelloWorld
        System.out.println(maskPhone("010-1234-5678"));     // 010-1234-****
    }
}
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: return 문 누락

**상황**: 반환 타입이 void가 아닌데 return 문을 빠뜨림

```java
// ❌ 컴파일 에러
public static int calculate(int a, int b) {
    int result = a + b;
    // return 문 없음!
}  // Error: missing return statement
```

**문제점**
- 반환 타입이 있는 메서드는 반드시 값을 반환해야 함
- 모든 실행 경로에서 return 필요

**해결책**
```java
// ✅ 해결 1: return 문 추가
public static int calculate(int a, int b) {
    int result = a + b;
    return result;
}

// ✅ 해결 2: 조건문 모든 경로에 return
public static String getGrade(int score) {
    if (score >= 90) {
        return "A";
    } else if (score >= 80) {
        return "B";
    } else {
        return "C";
    }
    // 모든 경로에 return이 있음
}

// ❌ 에러 예시: 일부 경로에만 return
public static int getValue(boolean flag) {
    if (flag) {
        return 10;
    }
    // flag가 false일 때 return이 없음!
}

// ✅ 수정
public static int getValue(boolean flag) {
    if (flag) {
        return 10;
    }
    return 0;  // 기본값 반환
}
```

### 시나리오 2: 매개변수 수정의 함정

**상황**: 매개변수를 수정해도 원본이 바뀌지 않음 (기본 타입)

```java
public static void increaseScore(int score) {
    score += 10;  // 복사본만 변경됨
    System.out.println("메서드 내부: " + score);
}

public static void main(String[] args) {
    int myScore = 80;
    increaseScore(myScore);
    System.out.println("메서드 외부: " + myScore);  // 80 (변경 안됨!)
}
```

**문제점**
- 기본 타입은 값이 복사되어 전달됨 (Pass by Value)
- 메서드 내부에서 변경해도 원본에 영향 없음

**해결책**
```java
// 방법 1: 반환값으로 받기
public static int increaseScore(int score) {
    return score + 10;
}

public static void main(String[] args) {
    int myScore = 80;
    myScore = increaseScore(myScore);  // 반환값으로 받음
    System.out.println(myScore);  // 90
}

// 방법 2: 배열이나 객체 사용 (참조 타입)
public static void increaseScore(int[] scoreArray) {
    scoreArray[0] += 10;  // 원본 배열이 변경됨
}

public static void main(String[] args) {
    int[] myScore = {80};
    increaseScore(myScore);
    System.out.println(myScore[0]);  // 90
}
```

### 시나리오 3: 메서드 이름 짓기 실수

**상황**: 메서드 이름이 구체적이지 않아 혼란 발생

```java
// ❌ 나쁜 메서드 이름
public class BadNaming {
    public static int calc(int a, int b) {  // 무엇을 계산하는지 불명확
        return a + b;
    }

    public static void process(String s) {  // 무엇을 처리하는지 불명확
        System.out.println(s.toUpperCase());
    }

    public static boolean check(int n) {  // 무엇을 확인하는지 불명확
        return n > 0;
    }

    public static void doSomething() {  // 너무 모호함
        // ...
    }
}
```

**문제점**
- 메서드 이름만으로 기능 파악 불가
- 코드 리뷰 시 이해 어려움
- 유지보수 시 시간 낭비

**해결책**
```java
// ✅ 좋은 메서드 이름
public class GoodNaming {
    // 동사 + 명사 형태로 명확하게
    public static int calculateSum(int a, int b) {
        return a + b;
    }

    public static void convertToUpperCase(String text) {
        System.out.println(text.toUpperCase());
    }

    public static boolean isPositive(int number) {
        return number > 0;
    }

    public static void sendEmailNotification(String email, String message) {
        // 이메일 전송 로직
    }
}

// 메서드 이름 짓기 규칙
// - get: 값을 가져올 때 (getAge, getName)
// - set: 값을 설정할 때 (setAge, setName)
// - is/has: boolean 반환 (isValid, hasPermission)
// - calculate: 계산 (calculateTotal, calculateDiscount)
// - find/search: 검색 (findUser, searchProduct)
// - create/make: 생성 (createUser, makeReport)
// - update: 수정 (updateProfile, updateStatus)
// - delete/remove: 삭제 (deleteAccount, removeItem)
```

**배운 점**
- 💡 메서드 이름은 "동사 + 명사" 형태 권장
- 💡 누가 봐도 기능을 알 수 있어야 함
- 💡 축약보다는 명확성이 우선

### 시나리오 4: static 메서드에서 non-static 변수 접근

**상황**: static 메서드에서 인스턴스 변수를 사용하려고 시도

```java
public class MyClass {
    int instanceVar = 10;  // 인스턴스 변수

    public static void staticMethod() {
        System.out.println(instanceVar);  // ❌ 컴파일 에러
    }
}
```

**문제점**
- static 메서드는 객체 생성 전에도 호출 가능
- 인스턴스 변수는 객체 생성 후에만 존재
- 따라서 static 메서드에서 인스턴스 변수 접근 불가

**해결책**
```java
public class MyClass {
    int instanceVar = 10;
    static int staticVar = 20;  // static 변수

    // 방법 1: static 변수 사용
    public static void staticMethod1() {
        System.out.println(staticVar);  // ✅ OK
    }

    // 방법 2: 객체를 매개변수로 받기
    public static void staticMethod2(MyClass obj) {
        System.out.println(obj.instanceVar);  // ✅ OK
    }

    // 방법 3: 객체 생성 후 사용
    public static void staticMethod3() {
        MyClass obj = new MyClass();
        System.out.println(obj.instanceVar);  // ✅ OK
    }

    // 방법 4: non-static 메서드로 변경
    public void instanceMethod() {
        System.out.println(instanceVar);  // ✅ OK
    }
}
```

---

## 🛠️ 실전 프로젝트

### 프로젝트: 간단한 은행 시스템

**난이도**: ⭐⭐⭐☆☆
**학습 목표**: 메서드 정의, 오버로딩, 유효성 검사, 메서드 체이닝 활용

```java
import java.util.Scanner;

public class SimpleBankSystem {
    // 계좌 잔액 (전역 변수처럼 사용)
    static int balance = 0;
    static String accountHolder = "";

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("=== 간단한 은행 시스템 ===");
        System.out.print("예금주 이름: ");
        accountHolder = scanner.nextLine();

        System.out.print("초기 입금액: ");
        int initialDeposit = scanner.nextInt();
        deposit(initialDeposit);

        while (true) {
            printMenu();
            int choice = scanner.nextInt();

            if (choice == 1) {
                // 입금
                System.out.print("입금액: ");
                int amount = scanner.nextInt();
                deposit(amount);
            } else if (choice == 2) {
                // 출금
                System.out.print("출금액: ");
                int amount = scanner.nextInt();
                withdraw(amount);
            } else if (choice == 3) {
                // 잔액 조회
                checkBalance();
            } else if (choice == 4) {
                // 이자 계산
                System.out.print("이율 (%, 예: 3.5): ");
                double rate = scanner.nextDouble();
                calculateInterest(rate);
            } else if (choice == 5) {
                // 종료
                System.out.println("이용해 주셔서 감사합니다!");
                break;
            } else {
                System.out.println("잘못된 선택입니다.");
            }
        }

        scanner.close();
    }

    // 메뉴 출력
    public static void printMenu() {
        System.out.println("\n=== 메뉴 ===");
        System.out.println("1. 입금");
        System.out.println("2. 출금");
        System.out.println("3. 잔액 조회");
        System.out.println("4. 이자 계산");
        System.out.println("5. 종료");
        System.out.print("선택: ");
    }

    // 입금 (기본)
    public static void deposit(int amount) {
        if (!isValidAmount(amount)) {
            System.out.println("유효하지 않은 금액입니다.");
            return;
        }
        balance += amount;
        System.out.printf("%s님, %,d원이 입금되었습니다.\n", accountHolder, amount);
        printBalance();
    }

    // 입금 (메시지 포함) - 오버로딩
    public static void deposit(int amount, String message) {
        if (!isValidAmount(amount)) {
            System.out.println("유효하지 않은 금액입니다.");
            return;
        }
        balance += amount;
        System.out.printf("%s - %,d원이 입금되었습니다.\n", message, amount);
        printBalance();
    }

    // 출금
    public static boolean withdraw(int amount) {
        if (!isValidAmount(amount)) {
            System.out.println("유효하지 않은 금액입니다.");
            return false;
        }

        if (amount > balance) {
            System.out.printf("잔액이 부족합니다. (현재 잔액: %,d원)\n", balance);
            return false;
        }

        balance -= amount;
        System.out.printf("%,d원이 출금되었습니다.\n", amount);
        printBalance();
        return true;
    }

    // 잔액 조회
    public static void checkBalance() {
        printBalance();
    }

    // 잔액 출력 (내부 유틸리티 메서드)
    private static void printBalance() {
        System.out.printf("현재 잔액: %,d원\n", balance);
    }

    // 금액 유효성 검사
    private static boolean isValidAmount(int amount) {
        return amount > 0;
    }

    // 이자 계산
    public static void calculateInterest(double rate) {
        if (rate < 0 || rate > 100) {
            System.out.println("유효하지 않은 이율입니다.");
            return;
        }

        int interest = (int) (balance * rate / 100);
        System.out.printf("이율 %.2f%% 적용 시 이자: %,d원\n", rate, interest);
        System.out.printf("이자 포함 금액: %,d원\n", balance + interest);

        System.out.print("이자를 입금하시겠습니까? (1: 예, 2: 아니오): ");
        Scanner scanner = new Scanner(System.in);
        int choice = scanner.nextInt();

        if (choice == 1) {
            deposit(interest, "이자 입금");
        }
    }

    // 거래 내역 출력 (확장 기능)
    public static void printTransaction(String type, int amount, int balanceAfter) {
        System.out.printf("[%s] %,d원 | 잔액: %,d원\n", type, amount, balanceAfter);
    }
}
```

**실행 예시**
```
=== 간단한 은행 시스템 ===
예금주 이름: 홍길동
초기 입금액: 100000
홍길동님, 100,000원이 입금되었습니다.
현재 잔액: 100,000원

=== 메뉴 ===
1. 입금
2. 출금
3. 잔액 조회
4. 이자 계산
5. 종료
선택: 1
입금액: 50000
홍길동님, 50,000원이 입금되었습니다.
현재 잔액: 150,000원

선택: 2
출금액: 30000
30,000원이 출금되었습니다.
현재 잔액: 120,000원

선택: 4
이율 (%, 예: 3.5): 3.5
이율 3.50% 적용 시 이자: 4,200원
이자 포함 금액: 124,200원
이자를 입금하시겠습니까? (1: 예, 2: 아니오): 1
이자 입금 - 4,200원이 입금되었습니다.
현재 잔액: 124,200원
```

**확장 기능 아이디어**
```java
// 1. 송금 기능
public static boolean transfer(int amount, String recipient) {
    if (withdraw(amount)) {
        System.out.printf("%s님께 %,d원을 송금했습니다.\n", recipient, amount);
        return true;
    }
    return false;
}

// 2. 거래 내역 저장 (배열 활용)
static String[] transactionHistory = new String[100];
static int transactionCount = 0;

public static void addTransaction(String type, int amount) {
    if (transactionCount < 100) {
        transactionHistory[transactionCount++] =
            String.format("[%s] %,d원", type, amount);
    }
}

public static void printHistory() {
    System.out.println("\n=== 거래 내역 ===");
    for (int i = 0; i < transactionCount; i++) {
        System.out.println(transactionHistory[i]);
    }
}

// 3. 비밀번호 확인
static String password = "1234";

public static boolean checkPassword(String input) {
    return password.equals(input);
}

// 4. 복리 계산
public static int calculateCompoundInterest(int principal, double rate, int years) {
    return (int) (principal * Math.pow(1 + rate / 100, years));
}
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: 메서드 이름을 지을 때 규칙이 있나요?</strong></summary>

**네이밍 규칙**
- **camelCase** 사용 (첫 글자 소문자, 이후 단어 첫 글자 대문자)
- **동사로 시작**: 메서드는 동작을 나타냄
- **명확하고 구체적**: 메서드가 하는 일을 정확히 표현

**좋은 예시**
```java
calculateTotal()      // 총합 계산
getUserInfo()         // 사용자 정보 가져오기
isValid()             // 유효성 검사
hasPermission()       // 권한 확인
saveData()            // 데이터 저장
findByName()          // 이름으로 찾기
```

**나쁜 예시**
```java
calc()               // 너무 축약됨
method1()            // 의미 없음
doSomething()        // 구체적이지 않음
getdata()            // camelCase 위반
```

**관례적인 접두사**
- `get`: 값 반환
- `set`: 값 설정
- `is/has/can`: boolean 반환
- `find/search`: 검색
- `create/make`: 생성
- `update/modify`: 수정
- `delete/remove`: 삭제
- `print/show`: 출력
- `calculate/compute`: 계산
</details>

<details>
<summary><strong>Q2: 메서드는 얼마나 작게 만들어야 하나요?</strong></summary>

**단일 책임 원칙 (SRP)**
- 하나의 메서드는 하나의 기능만 수행
- 메서드 이름이 메서드의 모든 동작을 설명할 수 있어야 함

**적정 크기**
- 일반적으로 10~20줄 이내 권장
- 화면 한 페이지에 들어오는 크기
- 중첩 깊이는 2~3 레벨 이내

**나쁜 예 (너무 큼)**
```java
public static void processOrder() {
    // 사용자 정보 검증 (10줄)
    // 재고 확인 (15줄)
    // 결제 처리 (20줄)
    // 배송 정보 등록 (10줄)
    // 이메일 발송 (15줄)
    // 총 70줄...
}
```

**좋은 예 (분리)**
```java
public static void processOrder() {
    if (!validateUser()) return;
    if (!checkStock()) return;
    if (!processPayment()) return;
    registerShipping();
    sendEmail();
}

private static boolean validateUser() { /* ... */ }
private static boolean checkStock() { /* ... */ }
private static boolean processPayment() { /* ... */ }
private static void registerShipping() { /* ... */ }
private static void sendEmail() { /* ... */ }
```
</details>

<details>
<summary><strong>Q3: 재귀 함수는 언제 사용하나요?</strong></summary>

**재귀가 적합한 경우**
- 트리 구조 순회
- 분할 정복 알고리즘
- 조합, 순열 생성
- 수학적 정의 (팩토리얼, 피보나치)

**재귀 사용 예시**
```java
// 디렉토리 파일 개수 세기
public static int countFiles(File directory) {
    int count = 0;
    File[] files = directory.listFiles();

    if (files != null) {
        for (File file : files) {
            if (file.isFile()) {
                count++;
            } else if (file.isDirectory()) {
                count += countFiles(file);  // 재귀 호출
            }
        }
    }
    return count;
}
```

**재귀 대신 반복문을 사용해야 하는 경우**
- 단순 반복 작업
- 성능이 중요한 경우
- 깊은 재귀로 StackOverflow 위험이 있을 때

**성능 비교**
```java
// 피보나치 - 재귀 (매우 느림, O(2^n))
public static int fibRecursive(int n) {
    if (n <= 1) return n;
    return fibRecursive(n - 1) + fibRecursive(n - 2);
}

// 피보나치 - 반복문 (빠름, O(n))
public static int fibIterative(int n) {
    if (n <= 1) return n;
    int a = 0, b = 1;
    for (int i = 2; i <= n; i++) {
        int temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// fibRecursive(40) → 수 초 소요
// fibIterative(40) → 즉시 완료
```
</details>

<details>
<summary><strong>Q4: 메서드에서 여러 값을 반환하려면?</strong></summary>

**Java는 하나의 값만 반환 가능**

**해결 방법**

**1. 배열 사용**
```java
public static int[] getMinMax(int[] arr) {
    int min = arr[0];
    int max = arr[0];

    for (int num : arr) {
        if (num < min) min = num;
        if (num > max) max = num;
    }

    return new int[]{min, max};
}

// 사용
int[] result = getMinMax(new int[]{3, 1, 4, 1, 5});
System.out.println("최소: " + result[0]);  // 1
System.out.println("최대: " + result[1]);  // 5
```

**2. 객체 사용 (권장)**
```java
class MinMaxResult {
    int min;
    int max;

    MinMaxResult(int min, int max) {
        this.min = min;
        this.max = max;
    }
}

public static MinMaxResult getMinMax(int[] arr) {
    int min = arr[0];
    int max = arr[0];

    for (int num : arr) {
        if (num < min) min = num;
        if (num > max) max = num;
    }

    return new MinMaxResult(min, max);
}

// 사용
MinMaxResult result = getMinMax(new int[]{3, 1, 4, 1, 5});
System.out.println("최소: " + result.min);
System.out.println("최대: " + result.max);
```

**3. 참조 타입 매개변수 수정**
```java
public static void getMinMax(int[] arr, int[] result) {
    int min = arr[0];
    int max = arr[0];

    for (int num : arr) {
        if (num < min) min = num;
        if (num > max) max = num;
    }

    result[0] = min;
    result[1] = max;
}

// 사용
int[] result = new int[2];
getMinMax(new int[]{3, 1, 4, 1, 5}, result);
System.out.println("최소: " + result[0]);
System.out.println("최대: " + result[1]);
```
</details>

<details>
<summary><strong>Q5: main 메서드는 왜 public static void인가요?</strong></summary>

```java
public static void main(String[] args) { }
```

**각 키워드의 의미**

**public**
- JVM이 외부에서 접근할 수 있어야 함
- 프로그램 시작점이므로 공개되어야 함

**static**
- 객체 생성 없이 호출 가능해야 함
- JVM이 클래스만 로딩하고 바로 main 실행

**void**
- 프로그램 종료 시 OS에 종료 코드를 반환하는 것은 System.exit()으로 함
- main은 값을 반환할 필요가 없음

**main**
- 고정된 메서드 이름 (관례)
- JVM이 "main"이라는 이름을 찾아서 실행

**String[] args**
- 명령줄 인자를 받기 위한 배열
- 프로그램 실행 시 전달되는 파라미터

**명령줄 인자 예시**
```bash
java MyProgram arg1 arg2 arg3
```

```java
public class MyProgram {
    public static void main(String[] args) {
        System.out.println("인자 개수: " + args.length);
        for (int i = 0; i < args.length; i++) {
            System.out.println("args[" + i + "] = " + args[i]);
        }
    }
}

// 출력:
// 인자 개수: 3
// args[0] = arg1
// args[1] = arg2
// args[2] = arg3
```
</details>

<details>
<summary><strong>Q6: 메서드 오버로딩과 오버라이딩의 차이는?</strong></summary>

**메서드 오버로딩 (Overloading)**
- 같은 클래스 내에서
- 같은 이름, 다른 매개변수
- 컴파일 타임에 결정

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {  // 오버로딩
        return a + b;
    }

    public int add(int a, int b, int c) {  // 오버로딩
        return a + b + c;
    }
}
```

**메서드 오버라이딩 (Overriding)**
- 상속 관계에서
- 부모 클래스의 메서드를 자식 클래스에서 재정의
- 런타임에 결정 (다형성)

```java
class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {  // 오버라이딩
        System.out.println("멍멍");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {  // 오버라이딩
        System.out.println("야옹");
    }
}
```

**비교표**

| 구분 | 오버로딩 | 오버라이딩 |
|------|----------|------------|
| 관계 | 같은 클래스 | 상속 관계 |
| 메서드명 | 동일 | 동일 |
| 매개변수 | 다름 | 동일 |
| 반환타입 | 상관없음 | 동일 (또는 하위 타입) |
| 시점 | 컴파일 타임 | 런타임 |
| 목적 | 편의성 | 다형성 |
</details>

<details>
<summary><strong>Q7: 메서드가 너무 많은 매개변수를 받는 것은 좋지 않나요?</strong></summary>

**문제점**
- 가독성 저하
- 호출 시 인자 순서 혼동
- 유지보수 어려움

**나쁜 예**
```java
public static void createUser(
    String firstName,
    String lastName,
    int age,
    String email,
    String phone,
    String address,
    String city,
    String zipCode,
    boolean isActive
) {
    // ...
}

// 호출 시 복잡함
createUser("홍", "길동", 25, "hong@example.com",
          "010-1234-5678", "서울시", "강남구", "12345", true);
```

**해결 방법**

**1. 객체로 묶기 (권장)**
```java
class User {
    String firstName;
    String lastName;
    int age;
    String email;
    String phone;
    String address;
    String city;
    String zipCode;
    boolean isActive;
}

public static void createUser(User user) {
    // ...
}

// 사용
User user = new User();
user.firstName = "홍";
user.lastName = "길동";
user.age = 25;
// ...
createUser(user);
```

**2. 빌더 패턴**
```java
User user = new User.Builder()
    .firstName("홍")
    .lastName("길동")
    .age(25)
    .email("hong@example.com")
    .build();
```

**3. 매개변수 개수 제한**
- 일반적으로 3~4개 이하 권장
- 그 이상이면 객체로 그룹화 고려
</details>

---

## ❓ FAQ

<details>
<summary><strong>Q8: 메서드가 너무 길면 어떻게 해야 하나요?</strong></summary>

**A**: 더 작은 메서드로 분리하세요 (함수 분해, Extract Method)

**원칙**: 하나의 메서드는 하나의 일만 해야 합니다.

**나쁜 예 (100줄짜리 메서드)**
```java
public static void processOrder() {
    // 1. 사용자 검증 (20줄)
    // 2. 재고 확인 (20줄)
    // 3. 결제 처리 (30줄)
    // 4. 배송 등록 (20줄)
    // 5. 이메일 발송 (10줄)
    // 총 100줄의 긴 메서드
}
```

**좋은 예 (메서드 분리)**
```java
public static void processOrder(Order order) {
    if (!validateUser(order.getUser())) {
        return;
    }
    if (!checkInventory(order.getItems())) {
        return;
    }
    if (!processPayment(order.getPayment())) {
        return;
    }
    registerShipping(order);
    sendConfirmationEmail(order);
}

private static boolean validateUser(User user) {
    // 20줄 → 독립적인 메서드
}

private static boolean checkInventory(List<Item> items) {
    // 20줄 → 독립적인 메서드
}
```

**장점**:
- 각 메서드를 독립적으로 테스트 가능
- 가독성 향상
- 재사용 가능

**기준**:
- 일반적으로 10-20줄 이내 권장
- 화면 한 페이지에 보이는 크기
- 중첩 깊이 3레벨 이내

</details>

<details>
<summary><strong>Q9: 메서드를 호출할 때마다 메모리를 많이 사용하나요?</strong></summary>

**A**: 적절한 수준의 메모리만 사용하며, 성능 걱정은 불필요합니다.

**메서드 호출 비용**:
- 스택 프레임 생성: 약 수십 바이트
- 매개변수 복사: 데이터 크기에 따름
- 반환 주소 저장: 8바이트 (64비트 시스템)

**현대 JVM의 최적화**:
- 인라인(Inline) 최적화: 작은 메서드는 자동으로 인라인 처리
- JIT 컴파일: 자주 호출되는 메서드는 네이티브 코드로 컴파일
- 스택 메모리는 빠르게 할당/해제됨

```java
// 이 정도는 전혀 문제없음
for (int i = 0; i < 1000000; i++) {
    int result = add(i, i + 1);  // 100만 번 호출해도 밀리초 단위
}

public static int add(int a, int b) {
    return a + b;  // JVM이 인라인 최적화
}
```

**실무 팁**:
- 메서드 호출 횟수보다 메서드 내부 로직이 더 중요
- 조기 최적화(Premature Optimization)는 악의 근원
- 성능 문제가 실제로 발생했을 때 프로파일링 후 최적화

</details>

<details>
<summary><strong>Q10: 언제 static 메서드를 사용하고, 언제 인스턴스 메서드를 사용하나요?</strong></summary>

**A**: 객체 상태가 필요 없으면 static, 필요하면 인스턴스 메서드

**static 메서드 사용 시기**:
- 유틸리티 기능 (Math.max(), Arrays.sort())
- 팩토리 메서드 (객체 생성)
- 상수 값 반환
- 객체 상태와 무관한 순수 함수

```java
// static 적합: 객체 상태 불필요
public class MathUtil {
    public static int max(int a, int b) {
        return a > b ? a : b;
    }
}

MathUtil.max(10, 20);  // 객체 생성 불필요
```

**인스턴스 메서드 사용 시기**:
- 객체의 필드 값을 사용
- 객체 상태를 변경
- 다형성(Polymorphism) 필요

```java
// 인스턴스 메서드 적합: 객체 상태 사용
public class BankAccount {
    private int balance;  // 객체 상태

    public void deposit(int amount) {
        this.balance += amount;  // 필드 사용
    }

    public int getBalance() {
        return this.balance;
    }
}

BankAccount account = new BankAccount();
account.deposit(10000);  // 객체 필요
```

**결정 기준**:
```
객체의 필드(상태)를 사용하는가?
    ↓ YES
인스턴스 메서드

    ↓ NO
static 메서드
```

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. 메서드란 무엇이며, 왜 사용하나요?</strong></summary>

**모범 답안 포인트**
- 특정 작업을 수행하는 코드의 묶음
- 코드 재사용, 가독성, 유지보수성 향상
- 모듈화를 통한 프로그램 구조화

**예시 답변**
> "메서드는 특정 기능을 수행하는 코드 블록을 하나의 단위로 묶은 것입니다. 같은 코드를 반복해서 작성하지 않고 재사용할 수 있어 효율적이며, 복잡한 로직을 의미 있는 이름으로 추상화하여 코드 가독성을 높입니다. 또한 수정이 필요할 때 해당 메서드만 변경하면 되므로 유지보수가 용이합니다."

**꼬리 질문**
- Q: 메서드와 함수의 차이는?
- A: 메서드는 클래스에 속한 함수, 함수는 독립적인 코드 블록 (Java는 모두 메서드)

**실무 연관**
- 비즈니스 로직을 메서드 단위로 분리
- 테스트 가능한 단위로 코드 작성
</details>

<details>
<summary><strong>2. 메서드의 반환 타입이 void일 때와 값을 반환할 때의 차이는?</strong></summary>

**모범 답안 포인트**
- void: 결과값을 반환하지 않음, 작업만 수행
- 반환값 있음: 계산 결과나 데이터를 호출자에게 전달
- return 문의 사용 차이

**예시 답변**
> "void는 메서드가 어떤 값도 반환하지 않음을 의미합니다. 주로 출력, 데이터 저장 등의 작업만 수행할 때 사용합니다. 반환 타입이 있는 경우는 계산 결과나 처리된 데이터를 호출한 곳에 전달해야 할 때 사용하며, 반드시 해당 타입의 값을 return 해야 합니다."

```java
// void: 작업만 수행
public static void printMessage(String msg) {
    System.out.println(msg);
    // return 생략 가능
}

// 값 반환: 결과를 돌려줌
public static int add(int a, int b) {
    return a + b;  // 반드시 return 필요
}
```

**꼬리 질문**
- Q: void 메서드에서도 return을 사용할 수 있나요?
- A: 가능합니다. return; (값 없이)으로 메서드를 중간에 종료할 수 있습니다.

**실무 연관**
- void: setter, 출력, 로깅, 이벤트 핸들러
- 반환값: getter, 계산, 변환, 조회 메서드
</details>

<details>
<summary><strong>3. 메서드 오버로딩이란 무엇이며, 어떤 경우에 사용하나요?</strong></summary>

**모범 답안 포인트**
- 같은 이름, 다른 매개변수
- 매개변수의 개수, 타입, 순서가 달라야 함
- 같은 기능을 다양한 형태로 제공

**예시 답변**
> "메서드 오버로딩은 같은 이름의 메서드를 매개변수의 개수나 타입을 다르게 하여 여러 개 정의하는 것입니다. 같은 기능을 다양한 입력 형태로 제공하고 싶을 때 사용하며, System.out.println()처럼 다양한 타입을 처리할 수 있게 합니다. 단, 반환 타입만 다른 것은 오버로딩이 아닙니다."

```java
public static int add(int a, int b) { }
public static int add(int a, int b, int c) { }  // 개수 다름
public static double add(double a, double b) { }  // 타입 다름
```

**꼬리 질문**
- Q: 오버로딩과 오버라이딩의 차이는?
- A: 오버로딩은 같은 클래스 내 같은 이름/다른 매개변수, 오버라이딩은 상속 시 재정의

**실무 연관**
- 생성자 오버로딩 (다양한 초기화 방법)
- 편의 메서드 제공 (기본값 설정)
</details>

<details>
<summary><strong>4. static 메서드와 non-static 메서드의 차이는?</strong></summary>

**모범 답안 포인트**
- static: 클래스 소속, 객체 생성 불필요
- non-static: 인스턴스 소속, 객체 생성 필요
- 메모리와 호출 방식의 차이

**예시 답변**
> "static 메서드는 클래스에 속하며 객체 생성 없이 클래스명으로 바로 호출할 수 있습니다. Math.max()처럼 유틸리티 메서드에 주로 사용됩니다. non-static 메서드는 객체의 상태를 다루는 메서드로, 반드시 객체를 생성한 후 호출해야 합니다. static 메서드에서는 인스턴스 변수나 메서드에 접근할 수 없습니다."

```java
public class Example {
    static int staticVar = 10;
    int instanceVar = 20;

    public static void staticMethod() {
        System.out.println(staticVar);  // ✅
        // System.out.println(instanceVar);  // ❌
    }

    public void instanceMethod() {
        System.out.println(staticVar);     // ✅
        System.out.println(instanceVar);   // ✅
    }
}

// 호출
Example.staticMethod();  // static
Example obj = new Example();
obj.instanceMethod();    // non-static
```

**꼬리 질문**
- Q: main 메서드는 왜 static인가요?
- A: JVM이 객체 생성 없이 프로그램을 시작할 수 있도록 하기 위함

**실무 연관**
- static: 유틸리티 클래스, 상수, 팩토리 메서드
- non-static: 비즈니스 로직, 객체 상태 관리
</details>

<details>
<summary><strong>5. 가변 인자(Varargs)란 무엇이며 어떻게 사용하나요?</strong></summary>

**모범 답안 포인트**
- 메서드 매개변수 개수를 유동적으로 받음
- 타입... 변수명 형태
- 내부적으로 배열로 처리
- 마지막 매개변수에만 사용 가능

**예시 답변**
> "가변 인자는 메서드가 같은 타입의 매개변수를 개수에 상관없이 받을 수 있게 하는 기능입니다. 'int... numbers'처럼 타입 뒤에 ...을 붙여 선언하며, 메서드 내부에서는 배열로 처리됩니다. 대표적으로 System.out.printf()나 String.format()이 가변 인자를 사용합니다."

```java
public static int sum(int... numbers) {
    int total = 0;
    for (int num : numbers) {
        total += num;
    }
    return total;
}

// 다양한 호출 방식
sum();              // 0
sum(10);            // 10
sum(10, 20);        // 30
sum(10, 20, 30);    // 60
```

**꼬리 질문**
- Q: 가변 인자를 여러 개 선언할 수 있나요?
- A: 아니요. 가변 인자는 메서드당 하나만 가능하며, 반드시 마지막 매개변수여야 합니다.

**실무 연관**
- 로깅 메서드
- 다중 조건 검증
- 유틸리티 메서드

</details>

<details>
<summary><strong>6. 메서드 오버로딩 시 주의할 점은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 매개변수 타입/개수/순서가 달라야 함
- 반환 타입만 다른 것은 오버로딩 불가
- 모호한(Ambiguous) 호출 방지
- 가독성을 해치지 않아야 함

**예시 답변**
> "메서드 오버로딩 시 매개변수의 타입, 개수, 순서 중 적어도 하나가 달라야 합니다. 반환 타입만 다른 것은 오버로딩으로 인정되지 않으며, 컴파일러가 어떤 메서드를 호출해야 할지 모호한 상황을 만들지 않도록 주의해야 합니다."

```java
// ✅ 올바른 오버로딩
public static int add(int a, int b) { }
public static double add(double a, double b) { }
public static int add(int a, int b, int c) { }

// ❌ 잘못된 오버로딩 - 반환 타입만 다름
public static int calculate(int a, int b) { }
public static double calculate(int a, int b) { }  // 컴파일 에러

// ❌ 모호한 호출
public static void print(int a, double b) { }
public static void print(double a, int b) { }
// print(10, 20); // 컴파일 에러: 모호함
```

**꼬리 질문**
- Q: 오버로딩과 오버라이딩의 차이는?
- A: 오버로딩은 같은 클래스 내 같은 이름/다른 매개변수, 오버라이딩은 상속 시 부모 메서드 재정의

**실무 연관**
- 생성자 오버로딩
- API 설계 시 편의 메서드 제공
- 하위 호환성 유지

</details>

<details>
<summary><strong>7. 재귀 함수란 무엇이며, 사용 시 주의할 점은?</strong></summary>

**모범 답안 포인트**
- 자기 자신을 호출하는 메서드
- 종료 조건(Base Case) 필수
- StackOverflowError 위험

**예시 답변**
> "재귀 함수는 메서드가 자기 자신을 호출하는 것으로, 팩토리얼이나 트리 순회 같은 재귀적 구조에 적합합니다. 반드시 종료 조건이 있어야 하며, 그렇지 않으면 무한 루프가 되어 StackOverflowError가 발생합니다. 재귀 깊이가 깊으면 성능 문제가 있을 수 있어, 경우에 따라 반복문으로 대체하는 것이 좋습니다."

```java
// 팩토리얼
public static int factorial(int n) {
    if (n <= 1) return 1;  // 종료 조건 (필수!)
    return n * factorial(n - 1);
}

// ❌ 무한 재귀
public static void infiniteRecursion(int n) {
    infiniteRecursion(n + 1);  // 종료 조건 없음!
}
```

**꼬리 질문**
- Q: 재귀와 반복문 중 어느 것이 더 효율적인가요?
- A: 일반적으로 반복문이 더 빠르고 메모리 효율적이지만, 재귀가 코드를 더 명확하게 표현할 때도 있습니다.

**실무 연관**
- 파일 시스템 탐색
- JSON/XML 파싱
- 트리/그래프 알고리즘
</details>

---

### 📗 중급 개발자용

<details>
<parameter name="summary"><strong>4. 메서드 참조(Method Reference)와 람다의 차이는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- Java 8 함수형 프로그래밍 기능
- 메서드 참조는 람다의 축약형
- 가독성과 재사용성 향상
- :: 연산자 사용

**예시 답변**
> "메서드 참조는 Java 8에서 도입된 기능으로, 이미 존재하는 메서드를 람다 표현식처럼 사용할 수 있게 합니다. 람다가 단순히 메서드를 호출하는 경우 '::'를 사용해 더 간결하게 표현할 수 있으며, 가독성이 향상됩니다. 정적 메서드, 인스턴스 메서드, 생성자 참조가 가능합니다."

**실무 예시**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// 람다 표현식
names.forEach(name -> System.out.println(name));

// 메서드 참조 (더 간결)
names.forEach(System.out::println);

// 정적 메서드 참조
List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.stream()
       .map(String::valueOf)  // Integer.valueOf()
       .collect(Collectors.toList());

// 인스턴스 메서드 참조
names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);

// 생성자 참조
List<User> users = names.stream()
                        .map(User::new)  // new User(name)
                        .collect(Collectors.toList());
```

**종류**:
1. 정적 메서드 참조: `ClassName::staticMethod`
2. 인스턴스 메서드 참조: `instance::instanceMethod`
3. 특정 타입의 임의 객체 인스턴스 메서드 참조: `ClassName::instanceMethod`
4. 생성자 참조: `ClassName::new`

**꼬리 질문**
- Q: 언제 람다 대신 메서드 참조를 사용하나요?
- A: 람다가 단순히 메서드 호출만 하는 경우, 메서드 참조가 더 간결하고 가독성이 좋습니다.

**실무 연관**
- Stream API 활용
- 함수형 인터페이스 구현
- 컬렉션 처리

</details>

<details>
<summary><strong>5. 꼬리 재귀 최적화(Tail Call Optimization)란 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 재귀 호출의 스택 오버플로우 문제 해결
- 마지막 연산이 재귀 호출인 경우
- Java는 공식적으로 미지원 (일부 JVM만 지원)
- 반복문으로 변환 권장

**예시 답변**
> "꼬리 재귀 최적화는 재귀 함수의 마지막 연산이 재귀 호출 자체일 때, 스택 프레임을 재사용하여 메모리 효율을 높이는 최적화 기법입니다. 하지만 Java는 공식적으로 이를 지원하지 않아, 깊은 재귀가 필요한 경우 반복문으로 변환하는 것이 안전합니다."

**실무 예시**
```java
// ❌ 일반 재귀 (스택 오버플로우 위험)
public static int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);  // 마지막 연산이 곱셈
}

// ✅ 꼬리 재귀 형태 (하지만 Java는 최적화 안 함)
public static int factorialTail(int n, int accumulator) {
    if (n <= 1) return accumulator;
    return factorialTail(n - 1, n * accumulator);  // 마지막이 재귀 호출
}

// ✅ 반복문으로 변환 (권장)
public static int factorialIterative(int n) {
    int result = 1;
    for (int i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}

// 성능 비교
factorialIterative(10000);  // 즉시 완료
factorial(10000);            // StackOverflowError 발생
```

**다른 언어와의 비교**:
- Scala, Kotlin: 꼬리 재귀 최적화 지원 (`tailrec` 키워드)
- JavaScript (ES6): 엄격 모드에서 일부 지원
- Java: 미지원 (JVM 레벨에서 가능하지만 보장 안 됨)

**꼬리 질문**
- Q: 그렇다면 Java에서 재귀는 사용하지 말아야 하나요?
- A: 트리 순회 같은 구조적으로 재귀가 자연스러운 경우는 사용하되, 깊이가 깊어질 가능성이 있으면 반복문 고려

**실무 연관**
- 알고리즘 최적화
- 함수형 프로그래밍 패턴
- 성능 튜닝

</details>

---

### 📗 중급 개발자용 (기존)

<details>
<summary><strong>1. 메서드 호출 시 메모리 구조는 어떻게 되나요?</strong></summary>

**모범 답안 포인트**
- 스택(Stack) 메모리 사용
- 각 메서드 호출마다 스택 프레임 생성
- 지역 변수와 매개변수 저장
- 메서드 종료 시 스택 프레임 제거

**예시 답변**
> "메서드가 호출되면 JVM 스택 메모리에 해당 메서드의 스택 프레임이 생성됩니다. 스택 프레임에는 지역 변수, 매개변수, 반환 주소 등이 저장되며, 메서드가 종료되면 해당 프레임은 스택에서 제거됩니다. 재귀 호출이 깊어지면 스택 프레임이 계속 쌓여 StackOverflowError가 발생할 수 있습니다."

**메모리 구조**
```
[Stack]
┌─────────────────┐
│ main()          │
│ - int a = 10    │
├─────────────────┤
│ method1()       │
│ - int x = 5     │
├─────────────────┤
│ method2()       │
│ - int y = 20    │  ← 현재 실행 중
└─────────────────┘

method2() 종료 → 스택에서 제거
method1() 종료 → 스택에서 제거
main() 종료 → 프로그램 종료
```

**실무 예시**
```java
public static void main(String[] args) {
    int result = calculate(10, 5);  // (1) main 스택 프레임
    System.out.println(result);
}

public static int calculate(int a, int b) {  // (2) calculate 스택 프레임 생성
    int sum = add(a, b);  // (3) add 스택 프레임 생성
    return sum;  // (4) add 스택 프레임 제거
}  // (5) calculate 스택 프레임 제거

public static int add(int x, int y) {
    return x + y;
}
```

**꼬리 질문**
- Q: StackOverflowError는 언제 발생하나요?
- A: 재귀 호출이 너무 깊거나 무한 재귀 시 스택 메모리가 가득 차면 발생

**실무 연관**
- 디버깅 시 스택 트레이스 분석
- 재귀 깊이 제한 설정
- 성능 프로파일링
</details>

<details>
<summary><strong>2. Java의 매개변수 전달 방식은 Pass by Value인가요, Pass by Reference인가요?</strong></summary>

**모범 답안 포인트**
- Java는 항상 Pass by Value
- 기본 타입: 값 자체를 복사
- 참조 타입: 참조(주소)의 값을 복사
- 참조의 복사 ≠ Pass by Reference

**예시 답변**
> "Java는 항상 Pass by Value입니다. 기본 타입은 값 자체가 복사되고, 참조 타입은 객체의 주소값이 복사됩니다. 주의할 점은 참조 타입의 경우 주소가 복사되므로 메서드 내부에서 객체의 필드를 변경하면 원본에도 영향을 주지만, 참조 자체를 변경하면 원본에는 영향이 없습니다."

**실무 예시**
```java
// 기본 타입 (값 복사)
public static void changeValue(int x) {
    x = 100;  // 복사본만 변경
}

int num = 10;
changeValue(num);
System.out.println(num);  // 10 (변경 안됨)

// 참조 타입 (주소 복사)
public static void changeArray(int[] arr) {
    arr[0] = 100;  // 원본 배열 변경됨!
}

public static void reassignArray(int[] arr) {
    arr = new int[]{1, 2, 3};  // 복사된 참조만 변경, 원본 영향 없음
}

int[] numbers = {10, 20, 30};
changeArray(numbers);
System.out.println(numbers[0]);  // 100 (변경됨)

reassignArray(numbers);
System.out.println(numbers[0]);  // 100 (변경 안됨)
```

**C++과의 비교**
```cpp
// C++는 Pass by Reference 지원
void change(int& x) {  // 참조자
    x = 100;
}

int num = 10;
change(num);
// num은 100으로 변경됨
```

**꼬리 질문**
- Q: 그렇다면 String도 참조 타입인데 왜 변경이 안 되나요?
- A: String은 불변(Immutable) 객체이기 때문입니다.

**실무 연관**
- 방어적 복사(Defensive Copy)
- 불변 객체 패턴
- Side Effect 방지
</details>

<details>
<summary><strong>3. 메서드 시그니처(Method Signature)란 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 메서드 이름 + 매개변수 타입/개수/순서
- 반환 타입은 시그니처에 포함 안 됨
- 오버로딩 판단 기준

**예시 답변**
> "메서드 시그니처는 메서드를 고유하게 식별하는 정보로, 메서드 이름과 매개변수의 타입, 개수, 순서로 구성됩니다. 반환 타입과 접근 제어자는 시그니처에 포함되지 않습니다. 컴파일러는 시그니처로 메서드를 구분하며, 오버로딩된 메서드 중 어떤 것을 호출할지 결정합니다."

**예시**
```java
// 시그니처: add(int, int)
public static int add(int a, int b) { }

// 시그니처: add(double, double)  ← 다른 시그니처 (오버로딩 OK)
public static double add(double a, double b) { }

// 시그니처: add(int, int)  ← 같은 시그니처 (오버로딩 ❌)
// public static double add(int a, int b) { }  // 컴파일 에러

// 시그니처: add(int, int, int)  ← 다른 시그니처 (오버로딩 OK)
public static int add(int a, int b, int c) { }
```

**시그니처 구성 요소**
```java
public static int calculate(int a, double b, String c) throws Exception
       ↑      ↑    ↑    ↑                                    ↑
   접근제어자 static 반환  이름        매개변수               예외
                  타입

시그니처 = calculate(int, double, String)
         ↑         ↑    ↑
       이름      매개변수 타입/개수/순서
```

**꼬리 질문**
- Q: 매개변수 이름이 다르면 다른 시그니처인가요?
- A: 아니요. 매개변수 이름은 시그니처에 포함되지 않습니다.

**실무 연관**
- 리플렉션(Reflection)에서 메서드 식별
- 메서드 오버로딩 설계
- API 버전 관리
</details>

---

## 🎉 축하합니다!

**08장 메서드 학습을 완료하셨습니다!**

### 이제 여러분은:

✅ 메서드의 개념과 필요성을 이해했습니다
✅ 메서드를 정의하고 호출할 수 있습니다
✅ 매개변수와 반환값을 활용할 수 있습니다
✅ 메서드 오버로딩을 구현할 수 있습니다
✅ 재귀 함수의 원리를 이해했습니다
✅ static과 non-static 메서드를 구분할 수 있습니다
✅ 실무에서 메서드를 효과적으로 설계할 수 있습니다

### 학습 완료 체크리스트

#### 기본 개념
- [ ] 메서드의 구조를 설명할 수 있다
- [ ] void와 반환 타입의 차이를 안다
- [ ] 매개변수와 인자의 차이를 안다
- [ ] return 문의 역할을 이해한다

#### 실습
- [ ] 간단한 계산 메서드를 작성했다
- [ ] 메서드 오버로딩을 구현했다
- [ ] 재귀 함수를 작성했다
- [ ] 실전 프로젝트(은행 시스템)를 완성했다

#### 심화
- [ ] Pass by Value를 이해했다
- [ ] 메서드 시그니처를 설명할 수 있다
- [ ] 좋은 메서드 설계 원칙을 안다
- [ ] 면접 질문에 답할 수 있다

### 다음 단계

**다음 장 미리보기: 09장 클래스와 객체**

메서드를 마스터했다면, 이제 객체지향 프로그래밍의 핵심인 **클래스와 객체**를 학습할 차례입니다!

**배울 내용**:
- 클래스 정의와 객체 생성
- 필드(Field)와 메서드의 관계
- 생성자(Constructor)
- this 키워드
- 캡슐화(Encapsulation)
- **실전 프로젝트**: 학생 관리 시스템

**이 장과의 연결점**:
```
08장: 메서드 (기능 중심)
    ↓
09장: 클래스와 객체 (데이터 + 기능)
    ↓
객체지향 프로그래밍의 세계로!
```

### 복습이 필요하다면

- 메서드 오버로딩이 헷갈린다 → [메서드 오버로딩](#메서드-오버로딩) 섹션 재학습
- 재귀가 어렵다 → [재귀 함수](#재귀-함수) 섹션 + 실습 문제 풀이
- static이 이해 안 된다 → [static 메서드](#static-메서드) 섹션 + FAQ Q10

### 추가 학습 자료

**공식 문서**:
- [Oracle Java Tutorial - Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
- [Java Language Specification - Method Declarations](https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.4)

**추천 블로그**:
- [Baeldung - Java Methods](https://www.baeldung.com/java-methods)
- [효과적인 메서드 설계](https://www.baeldung.com/java-clean-code)

**영상 강의**:
- [Java Methods Explained](https://www.youtube.com/results?search_query=java+methods+tutorial)

### 실무 적용 과제

1. **작은 프로젝트에 적용하기**
   - 기존 코드에서 중복 제거
   - 메서드로 리팩토링
   - 의미 있는 메서드명 사용

2. **코드 리뷰 연습**
   - 동료 코드에서 개선점 찾기
   - 메서드 분리 제안
   - 네이밍 개선 제안

3. **알고리즘 문제 풀이**
   - 백준, 프로그래머스 문제 풀기
   - 재귀 문제 5개 이상 풀기
   - 코드 재사용성 고려

---

## 🚀 다음 장으로 이동

**준비되셨나요?** 객체지향 프로그래밍의 진정한 여정이 시작됩니다!

[→ 09장: 클래스와 객체 학습 시작하기](09-클래스와-객체.md)

---

**목차로 돌아가기**: [📚 전체 목차](README.md)

**이전 장**: [← 07장: 배열](07-배열.md)

---

**작성일**: 2025-01-XX
**최종 수정일**: 2025-01-XX
**작성자**: Java 학습 가이드 팀
