# 43장 함수형 프로그래밍 - Part 2: 기업 사례 & 주니어 실수

## 📚 목차
1. [기업 사례](#기업-사례)
2. [주니어 실수 시나리오](#주니어-실수-시나리오)
3. [실무 패턴](#실무-패턴)

---

## 🏢 기업 사례

### 🔷 네이버 - 검색 결과 처리

**배경**: 복잡한 검색 결과 필터링 및 정렬

```java
// ❌ Before (명령형)
public class SearchService {
    public List<SearchResult> search(String query) {
        List<Document> docs = searchEngine.query(query);
        List<SearchResult> results = new ArrayList<>();

        for (Document doc : docs) {
            if (doc.getScore() > 0.5) {
                if (doc.isPublished()) {
                    if (!doc.isDeleted()) {
                        SearchResult result = new SearchResult();
                        result.setTitle(doc.getTitle().toUpperCase());
                        result.setScore(doc.getScore() * 100);
                        result.setHighlight(highlighter.highlight(doc, query));
                        results.add(result);
                    }
                }
            }
        }

        Collections.sort(results, (a, b) ->
            Double.compare(b.getScore(), a.getScore()));

        if (results.size() > 10) {
            results = results.subList(0, 10);
        }

        return results;
    }
}

// ✅ After (함수형)
public class SearchService {
    public List<SearchResult> search(String query) {
        return searchEngine.query(query).stream()
            .filter(doc -> doc.getScore() > 0.5)
            .filter(Document::isPublished)
            .filter(doc -> !doc.isDeleted())
            .map(doc -> createSearchResult(doc, query))
            .sorted(Comparator.comparingDouble(SearchResult::getScore).reversed())
            .limit(10)
            .collect(Collectors.toList());
    }

    private SearchResult createSearchResult(Document doc, String query) {
        return SearchResult.builder()
            .title(doc.getTitle().toUpperCase())
            .score(doc.getScore() * 100)
            .highlight(highlighter.highlight(doc, query))
            .build();
    }
}
```

**성과**:
- 코드량 50% 감소
- 가독성 대폭 향상
- 버그 발생률 70% 감소

---

### 🔷 카카오 - 결제 처리 파이프라인

**배경**: 복잡한 결제 검증 로직 개선

```java
// ❌ Before
public class PaymentService {
    public PaymentResult processPayment(Payment payment) {
        // 1. 검증
        if (payment.getAmount() == null || payment.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new InvalidPaymentException("금액 오류");
        }
        if (payment.getUserId() == null) {
            throw new InvalidPaymentException("사용자 정보 없음");
        }

        // 2. 사용자 조회
        User user = userRepository.findById(payment.getUserId());
        if (user == null) {
            throw new UserNotFoundException();
        }

        // 3. 잔액 확인
        if (user.getBalance().compareTo(payment.getAmount()) < 0) {
            throw new InsufficientBalanceException();
        }

        // 4. 결제 처리
        user.setBalance(user.getBalance().subtract(payment.getAmount()));
        userRepository.save(user);

        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setCompletedAt(LocalDateTime.now());
        paymentRepository.save(payment);

        return new PaymentResult(true, payment.getId());
    }
}

// ✅ After (함수형)
public class PaymentService {
    public PaymentResult processPayment(Payment payment) {
        return validatePayment(payment)
            .flatMap(this::findUser)
            .flatMap(tuple -> checkBalance(tuple.payment(), tuple.user()))
            .map(this::executePayment)
            .map(this::savePayment)
            .map(p -> new PaymentResult(true, p.getId()))
            .orElseThrow(() -> new PaymentException("결제 실패"));
    }

    private Optional<Payment> validatePayment(Payment payment) {
        return Optional.of(payment)
            .filter(p -> p.getAmount() != null)
            .filter(p -> p.getAmount().compareTo(BigDecimal.ZERO) > 0)
            .filter(p -> p.getUserId() != null);
    }

    private Optional<PaymentUserTuple> findUser(Payment payment) {
        return userRepository.findById(payment.getUserId())
            .map(user -> new PaymentUserTuple(payment, user));
    }

    private Optional<PaymentUserTuple> checkBalance(Payment payment, User user) {
        return user.getBalance().compareTo(payment.getAmount()) >= 0
            ? Optional.of(new PaymentUserTuple(payment, user))
            : Optional.empty();
    }

    private Payment executePayment(PaymentUserTuple tuple) {
        User user = tuple.user();
        Payment payment = tuple.payment();

        user.subtractBalance(payment.getAmount());
        userRepository.save(user);

        payment.complete();
        return payment;
    }

    private Payment savePayment(Payment payment) {
        return paymentRepository.save(payment);
    }

    record PaymentUserTuple(Payment payment, User user) {}
}
```

**성과**:
- 각 단계가 독립적으로 테스트 가능
- 에러 처리가 명확
- 코드 재사용성 향상

---

### 🔷 쿠팡 - 상품 추천 시스템

**배경**: 사용자 행동 기반 상품 추천

```java
public class RecommendationEngine {
    // 함수형 파이프라인으로 구현
    public List<Product> recommend(User user, int limit) {
        return user.getPurchaseHistory().stream()
            // 1. 최근 6개월 구매 내역만
            .filter(this::isRecentPurchase)
            // 2. 상품 카테고리 추출
            .flatMap(purchase -> purchase.getProducts().stream())
            .map(Product::getCategory)
            .distinct()
            // 3. 각 카테고리의 인기 상품
            .flatMap(category -> getPopularProducts(category).stream())
            // 4. 이미 구매한 상품 제외
            .filter(product -> !user.hasPurchased(product))
            // 5. 사용자 선호도 점수 계산
            .map(product -> scoringFunction.apply(user, product))
            // 6. 점수 순 정렬
            .sorted(Comparator.comparingDouble(ScoredProduct::getScore).reversed())
            // 7. 상위 N개
            .limit(limit)
            .map(ScoredProduct::getProduct)
            .collect(Collectors.toList());
    }

    private boolean isRecentPurchase(Purchase purchase) {
        return purchase.getDate().isAfter(LocalDate.now().minusMonths(6));
    }

    private List<Product> getPopularProducts(Category category) {
        return productRepository.findByCategoryOrderByPopularityDesc(category);
    }

    // 고차 함수로 점수 계산 로직 분리
    private final BiFunction<User, Product, ScoredProduct> scoringFunction = (user, product) -> {
        double score = 0.0;

        // 카테고리 선호도
        score += user.getCategoryPreference(product.getCategory()) * 0.4;

        // 가격대 선호도
        score += user.getPriceRangePreference(product.getPrice()) * 0.3;

        // 브랜드 선호도
        score += user.getBrandPreference(product.getBrand()) * 0.2;

        // 평점
        score += product.getRating() / 5.0 * 0.1;

        return new ScoredProduct(product, score);
    };
}
```

**성과**:
- 추천 정확도 35% 향상
- 코드 유지보수성 개선
- 새로운 추천 로직 추가 용이

---

### 🔷 토스 - 실시간 이상 거래 탐지

**배경**: 복잡한 규칙 기반 탐지 시스템

```java
public class FraudDetectionSystem {
    // 규칙을 함수로 정의
    private final List<Predicate<Transaction>> rules = Arrays.asList(
        // 규칙 1: 고액 거래
        tx -> tx.getAmount().compareTo(new BigDecimal("1000000")) > 0,

        // 규칙 2: 야간 거래
        tx -> {
            LocalTime time = tx.getTime().toLocalTime();
            return time.isAfter(LocalTime.of(0, 0)) &&
                   time.isBefore(LocalTime.of(6, 0));
        },

        // 규칙 3: 연속 거래
        tx -> recentTransactionCount(tx.getUserId()) > 5,

        // 규칙 4: 해외 거래
        tx -> !tx.getCountry().equals("KR"),

        // 규칙 5: 미인증 사용자
        tx -> !tx.getUser().isVerified()
    );

    // 함수 조합으로 탐지
    public List<Transaction> detectFraud(List<Transaction> transactions) {
        return transactions.stream()
            .filter(this::isSuspicious)
            .collect(Collectors.toList());
    }

    private boolean isSuspicious(Transaction tx) {
        // 2개 이상의 규칙에 걸리면 의심 거래
        long matchedRules = rules.stream()
            .filter(rule -> rule.test(tx))
            .count();

        return matchedRules >= 2;
    }

    // 규칙 추가가 쉬움
    public void addRule(Predicate<Transaction> newRule) {
        rules.add(newRule);
    }

    // 규칙 조합
    public Predicate<Transaction> combineRules(
            Predicate<Transaction> rule1,
            Predicate<Transaction> rule2) {
        return rule1.and(rule2);
    }
}
```

**성과**:
- 이상 거래 탐지율 25% 향상
- 규칙 추가/변경 용이
- 실시간 처리 성능 개선

---

## 🚨 주니어 실수 시나리오

### ❌ 실수 1: 스트림에서 외부 상태 변경

```java
// ❌ 잘못된 코드
public class BadExample {
    private int total = 0;  // 외부 상태

    public void calculate(List<Integer> numbers) {
        numbers.stream()
            .forEach(n -> total += n);  // 외부 상태 변경!
    }
}

// ✅ 올바른 코드
public class GoodExample {
    public int calculate(List<Integer> numbers) {
        return numbers.stream()
            .mapToInt(n -> n)
            .sum();  // 순수 함수
    }
}
```

**교훈**: 스트림 내에서 외부 상태 변경 금지

---

### ❌ 실수 2: Optional.get() 남용

```java
// ❌ 잘못된 코드
Optional<User> userOpt = findUser(id);
if (userOpt.isPresent()) {
    User user = userOpt.get();  // Optional의 의미 없음
    System.out.println(user.getName());
}

// ✅ 올바른 코드
findUser(id)
    .map(User::getName)
    .ifPresent(System.out::println);
```

**교훈**: Optional은 함수형 메서드 사용

---

### ❌ 실수 3: 과도한 함수 체이닝

```java
// ❌ 잘못된 코드 - 가독성 떨어짐
public BigDecimal calculate(List<Order> orders) {
    return orders.stream()
        .filter(order -> order.getStatus() == OrderStatus.COMPLETED)
        .flatMap(order -> order.getItems().stream())
        .filter(item -> item.getCategory() == Category.ELECTRONICS)
        .map(item -> item.getPrice())
        .filter(price -> price.compareTo(new BigDecimal("10000")) > 0)
        .map(price -> price.multiply(new BigDecimal("0.9")))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
}

// ✅ 올바른 코드 - 단계별 분리
public BigDecimal calculate(List<Order> orders) {
    List<Order> completedOrders = filterCompletedOrders(orders);
    List<Item> electronicItems = extractElectronicItems(completedOrders);
    List<BigDecimal> discountedPrices = applyDiscount(electronicItems);
    return sumPrices(discountedPrices);
}

private List<Order> filterCompletedOrders(List<Order> orders) {
    return orders.stream()
        .filter(order -> order.getStatus() == OrderStatus.COMPLETED)
        .collect(Collectors.toList());
}

private List<Item> extractElectronicItems(List<Order> orders) {
    return orders.stream()
        .flatMap(order -> order.getItems().stream())
        .filter(item -> item.getCategory() == Category.ELECTRONICS)
        .collect(Collectors.toList());
}
```

**교훈**: 긴 체이닝은 단계별로 분리

---

### ❌ 실수 4: 부작용 있는 map 사용

```java
// ❌ 잘못된 코드
List<User> users = Arrays.asList(/*...*/);
users.stream()
    .map(user -> {
        user.setLastLogin(LocalDateTime.now());  // 부작용!
        return user;
    })
    .collect(Collectors.toList());

// ✅ 올바른 코드 - forEach 사용
users.forEach(user -> user.setLastLogin(LocalDateTime.now()));

// 또는 불변 객체로
List<User> updated = users.stream()
    .map(user -> user.withLastLogin(LocalDateTime.now()))
    .collect(Collectors.toList());
```

**교훈**: map은 변환용, 부작용은 forEach

---

### ❌ 실수 5: 람다에서 예외 처리

```java
// ❌ 잘못된 코드 - 컴파일 에러!
List<String> urls = Arrays.asList(/*...*/);
urls.stream()
    .map(url -> new URL(url))  // MalformedURLException 발생
    .collect(Collectors.toList());

// ✅ 올바른 코드 - 래퍼 메서드
urls.stream()
    .map(this::createURL)
    .filter(Optional::isPresent)
    .map(Optional::get)
    .collect(Collectors.toList());

private Optional<URL> createURL(String url) {
    try {
        return Optional.of(new URL(url));
    } catch (MalformedURLException e) {
        return Optional.empty();
    }
}
```

**교훈**: 예외는 별도 메서드로 래핑

---

## 🎯 실무 패턴

### 패턴 1: 전략 패턴 + 함수형

```java
// 전통적 전략 패턴
interface PaymentStrategy {
    void pay(BigDecimal amount);
}

// 함수형 전략 패턴
@FunctionalInterface
interface PaymentFunction {
    PaymentResult pay(BigDecimal amount);
}

public class PaymentProcessor {
    private Map<PaymentType, PaymentFunction> strategies = Map.of(
        PaymentType.CARD, this::payWithCard,
        PaymentType.BANK, this::payWithBank,
        PaymentType.MOBILE, this::payWithMobile
    );

    public PaymentResult process(PaymentType type, BigDecimal amount) {
        return strategies.get(type).pay(amount);
    }
}
```

---

### 패턴 2: 데이터 변환 파이프라인

```java
public class DataTransformer {
    // 변환 함수들을 조합
    private final Function<String, String> pipeline =
        ((Function<String, String>) String::trim)
            .andThen(String::toLowerCase)
            .andThen(this::removeSpecialChars)
            .andThen(this::normalizeSpaces);

    public List<String> transform(List<String> data) {
        return data.stream()
            .map(pipeline)
            .collect(Collectors.toList());
    }

    private String removeSpecialChars(String s) {
        return s.replaceAll("[^a-z0-9\\s]", "");
    }

    private String normalizeSpaces(String s) {
        return s.replaceAll("\\s+", " ");
    }
}
```

---

### 패턴 3: 지연 평가 (Lazy Evaluation)

```java
public class LazyProcessor {
    // Supplier로 지연 평가
    public <T> T processIfNeeded(
            boolean condition,
            Supplier<T> expensiveOperation,
            T defaultValue) {

        return condition
            ? expensiveOperation.get()  // 필요할 때만 실행
            : defaultValue;
    }

    // 사용
    String result = processIfNeeded(
        user.isPremium(),
        () -> expensiveRecommendation(user),  // 지연 실행
        "기본 추천"
    );
}
```

---

## 🎓 핵심 요약

### 함수형 프로그래밍 DO & DON'T

```
✅ DO
- 순수 함수 작성
- 불변 객체 사용
- 함수 조합
- map, filter, reduce 활용

❌ DON'T
- 외부 상태 변경
- Optional.get() 직접 호출
- 과도한 체이닝
- 람다에서 부작용
```

**다음 Part 3**: 성능 최적화 & 면접 질문
