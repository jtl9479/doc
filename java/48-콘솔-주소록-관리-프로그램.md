# 48장: 콘솔 주소록 관리 프로그램

> **학습 목표**: 실무에서 사용되는 CRUD 패턴을 이해하고, 콘솔 기반 주소록 관리 시스템을 완성할 수 있습니다.

**⏱️ 예상 학습 시간**: 6-8시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [핵심 개념](#핵심-개념)
- [기본 실습](#기본-실습)
- [실무 활용 사례](#실무-활용-사례)
- [주니어 시나리오](#주니어-시나리오)
- [실전 프로젝트](#실전-프로젝트)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)
- [다음 단계](#다음-단계)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경

**모든 애플리케이션의 기본은 데이터 관리(CRUD)입니다. 주소록 프로그램은 이러한 기본 패턴을 학습하기에 최적입니다.**

#### ❌ 체계적인 데이터 관리를 모르면 발생하는 문제

```
문제 1: 데이터 손실
- 증상: 프로그램 종료 시 모든 데이터 사라짐
- 영향: 사용자 신뢰 상실, 업무 마비
- 비용: 데이터 복구 비용 및 업무 중단 손실

문제 2: 중복 데이터 처리 미흡
- 증상: 같은 연락처가 여러 번 저장됨
- 영향: 데이터 정합성 문제
- 비용: 유지보수 비용 2배 증가

문제 3: 검색 기능 부재
- 증상: 수백 개의 데이터에서 원하는 정보를 찾지 못함
- 영향: 사용성 저하
- 비용: 사용자 이탈률 50% 증가
```

#### ✅ 체계적인 주소록 시스템을 구축하면

```
해결책 1: 파일 기반 영속성
- 방법: 파일 I/O로 데이터 저장/로드
- 효과: 데이터 손실 0%
- 절감: 데이터 복구 비용 100% 절감

해결책 2: 중복 체크 로직
- 방법: 전화번호/이메일 유일성 검증
- 효과: 데이터 정합성 100% 유지
- 절감: 유지보수 시간 60% 단축

해결책 3: 다양한 검색 기능
- 방법: 이름, 전화번호, 이메일별 검색
- 효과: 원하는 정보 즉시 조회
- 절감: 사용자 만족도 80% 향상
```

### 📊 수치로 보는 효과

| 지표 | 수작업 관리 | 시스템 관리 | 개선율 |
|------|------------|------------|--------|
| 연락처 추가 시간 | 30초 | 5초 | **83%↓** |
| 검색 시간 | 5분 | 1초 | **99.7%↓** |
| 데이터 손실률 | 10% | 0% | **100%↓** |
| 중복 데이터 | 15% | 0% | **100%↓** |
| 유지보수 시간 | 10시간/월 | 2시간/월 | **80%↓** |
| 사용자 만족도 | 40% | 85% | **112%↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 전화번호부 (Physical Phone Book)

```
종이 전화번호부 = 전통적 방식
- 수기로 작성
- 수정 시 지우개로 지움
- 분실 위험 높음
- 검색이 느림 (페이지 넘기며 찾기)
→ 불편하고 비효율적

디지털 전화번호부 = 주소록 프로그램
- 키보드로 입력
- 즉시 수정/삭제
- 파일로 백업
- 검색 1초 이내
→ 빠르고 안전함

┌─────────────────────────────┐
│   종이 전화번호부            │
│   ┌──────┐  ┌──────┐       │
│   │김철수│  │이영희│       │
│   │010- │  │010- │       │
│   └──────┘  └──────┘       │
│        ↓ 디지털화            │
│   [주소록 프로그램]          │
│   - 빠른 검색                │
│   - 자동 정렬                │
│   - 안전한 저장              │
└─────────────────────────────┘
```

**Java 코드로 표현:**
```java
// 전통적 방식 (배열)
String[] contacts = new String[100];
contacts[0] = "김철수,010-1234-5678";

// 객체 지향 방식 (클래스)
Contact contact = new Contact("김철수", "010-1234-5678", "kim@example.com");
contactManager.add(contact);
```

---

### 비유 2: 명함 정리함 (Business Card Organizer)

```
실물 명함 정리함 = 수동 관리
- 명함을 서랍에 보관
- 찾을 때마다 뒤적거림
- 분류 기준이 애매함
- 오래된 명함 관리 어려움

디지털 명함 관리 = 주소록 시스템
- 회사별, 이름별 자동 분류
- 검색 1초
- 중요 명함 즐겨찾기
- 오래된 연락처 자동 알림

📇 명함 정리 프로세스
┌─────────────────────────┐
│ 1. 명함 받음             │
│ 2. 사진 촬영/입력        │
│ 3. 자동 분류 (회사/직급) │
│ 4. 태그 추가             │
│ 5. 즐겨찾기 설정         │
└─────────────────────────┘
```

---

### 비유 3: 편의점 재고 관리 (Convenience Store Inventory)

```
수기 재고 관리 = 비효율
- 장부에 수기 기록
- 재고 확인 시간 오래 걸림
- 발주 시점 놓침
- 오기/누락 빈번

POS 시스템 = 체계적 관리
- 바코드 스캔으로 자동 입력
- 실시간 재고 확인
- 자동 발주 알림
- 판매 통계 자동 생성

🏪 재고 관리 = 주소록 관리
├─ 상품 추가 = 연락처 추가
├─ 상품 검색 = 연락처 검색
├─ 재고 수정 = 정보 수정
└─ 폐기 처리 = 연락처 삭제
```

---

### 비유 4: 학교 학생 명부 (School Student Roster)

```
종이 출석부 = 전통적 방식
- 교무실 파일에 보관
- 수정 시 정정 도장
- 통계 산출 수작업
- 분실 위험

전자 학적부 = 디지털 시스템
- 클라우드 저장
- 즉시 수정
- 자동 통계
- 보안 강화

📚 학생 관리 시스템
┌────────────────────────┐
│ 학생 정보 입력         │
│  ↓                     │
│ 자동 분류 (학년/반)    │
│  ↓                     │
│ 성적/출석 연동         │
│  ↓                     │
│ 학부모 연락망 생성     │
└────────────────────────┘
```

---

### 비유 5: 병원 환자 기록부 (Hospital Patient Records)

```
종이 차트 = 구식 방법
- 차트실에 물리적 보관
- 찾는 데 시간 소요
- 과거 기록 추적 어려움
- 공간 차지

전자 의무 기록(EMR) = 현대적 방법
- 디지털 저장
- 환자번호로 즉시 조회
- 과거 기록 한눈에
- 의료진 간 공유 용이

🏥 환자 관리 = 주소록 관리
├─ 환자 등록 = 연락처 등록
├─ 진료 기록 = 연락처 이력
├─ 처방전 = 메모 기능
└─ 재방문 알림 = 생일 알림
```

---

### 🎯 종합 비교표

```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ 주소록 기능  │ 전화번호부   │ 명함 정리함  │ 학생 명부    │
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 추가 (Create)│ 새 페이지    │ 명함 꽂기    │ 신입생 등록  │
│ 조회 (Read)  │ 페이지 넘김  │ 서랍 뒤적임  │ 출석부 확인  │
│ 수정 (Update)│ 지우개 사용  │ 명함 교체    │ 정정 도장    │
│ 삭제 (Delete)│ 페이지 찢음  │ 명함 버림    │ 졸업 처리    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📖 핵심 개념

### 개념 설명 (3단계 깊이)

#### 1️⃣ 초보자 수준 설명

**주소록 프로그램은 연락처를 저장하고, 찾고, 수정하고, 삭제하는 기본 기능을 제공합니다.**

- **Create**: 새로운 연락처 추가
- **Read**: 연락처 조회 및 검색
- **Update**: 연락처 정보 수정
- **Delete**: 연락처 삭제

```java
// 간단한 예제
Contact contact = new Contact("김철수", "010-1234-5678");
contactManager.add(contact);  // Create
contactManager.find("김철수");  // Read
contactManager.update(contact);  // Update
contactManager.delete(contact);  // Delete
```

#### 2️⃣ 중급자 수준 설명

**CRUD 패턴은 데이터베이스 설계의 기본이며, MVC 패턴과 결합하여 확장 가능한 시스템을 만듭니다.**

주요 개념:
- **데이터 계층 분리**: Model(데이터), View(UI), Controller(로직)
- **입력 검증**: 전화번호, 이메일 형식 검증
- **파일 영속성**: JSON, CSV, 바이너리 직렬화
- **예외 처리**: IOException, InvalidInputException

```java
// 중급 예제: 검증과 예외 처리
public class ContactManager {
    public void add(Contact contact) throws InvalidContactException {
        validateContact(contact);
        if (isDuplicate(contact)) {
            throw new DuplicateContactException();
        }
        contacts.add(contact);
        saveToFile();
    }

    private void validateContact(Contact contact) {
        if (!contact.getPhone().matches("\\d{3}-\\d{4}-\\d{4}")) {
            throw new InvalidPhoneNumberException();
        }
    }
}
```

#### 3️⃣ 고급자 수준 설명

**Repository 패턴과 전략 패턴을 활용한 확장 가능한 데이터 액세스 계층 설계**

내부 동작:
- **Repository 패턴**: 데이터 액세스 추상화
- **전략 패턴**: 저장 방식 교체 가능 (JSON, DB, XML)
- **단일 책임 원칙**: 각 클래스가 하나의 역할만 담당
- **의존성 주입**: 테스트 가능한 구조

```java
// 고급 예제: 디자인 패턴 적용
public interface ContactRepository {
    void save(Contact contact);
    Optional<Contact> findById(Long id);
    List<Contact> findAll();
    void delete(Long id);
}

public class FileContactRepository implements ContactRepository {
    private final StorageStrategy strategy;

    public FileContactRepository(StorageStrategy strategy) {
        this.strategy = strategy;
    }

    @Override
    public void save(Contact contact) {
        strategy.serialize(contact);
    }
}

// 전략 교체 가능
ContactRepository repo = new FileContactRepository(new JsonStrategy());
// 또는
ContactRepository repo = new FileContactRepository(new CsvStrategy());
```

---

### 주요 용어 정리

| 용어 | 영문 | 설명 | 예시 |
|------|------|------|------|
| CRUD | Create Read Update Delete | 데이터 기본 조작 4가지 | `add(), find(), update(), delete()` |
| 영속성 | Persistence | 프로그램 종료 후에도 데이터 유지 | 파일 저장, DB 저장 |
| 검증 | Validation | 데이터 유효성 확인 | 전화번호 형식 체크 |
| 직렬화 | Serialization | 객체를 바이트로 변환 | `ObjectOutputStream` |
| 역직렬화 | Deserialization | 바이트를 객체로 변환 | `ObjectInputStream` |
| 리포지토리 | Repository | 데이터 액세스 추상화 계층 | `ContactRepository` |

---

### 기술 아키텍처

```
┌─────────────────────────────────────────────────┐
│           주소록 프로그램 아키텍처              │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐   │
│  │        Presentation Layer               │   │
│  │  (Main Menu, Input/Output)              │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Business Logic Layer             │   │
│  │  (ContactManager, Validator)            │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Data Access Layer                │   │
│  │  (ContactRepository, FileManager)       │   │
│  └──────────────┬──────────────────────────┘   │
│                 ↓                               │
│  ┌─────────────────────────────────────────┐   │
│  │        Storage Layer                    │   │
│  │  (contacts.dat, JSON, CSV)              │   │
│  └─────────────────────────────────────────┘   │
└─────────────────────────────────────────────────┘

데이터 흐름:
사용자 입력 → 검증 → 비즈니스 로직 → 저장소 → 파일
```

---

## 💻 기본 실습

### 📋 사전 체크리스트
```bash
# 1. Java 버전 확인 (Java 8 이상)
java -version

# 2. 프로젝트 디렉토리 생성
mkdir contact-manager
cd contact-manager

# 3. 소스 파일 디렉토리 생성
mkdir src
cd src
```

### 실습 1: Contact 클래스 만들기
**난이도**: ⭐☆☆☆☆

#### 코드
```java
import java.io.Serializable;

public class Contact implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String name;
    private String phone;
    private String email;
    private String address;

    public Contact(String name, String phone, String email, String address) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getPhone() { return phone; }
    public void setPhone(String phone) { this.phone = phone; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getAddress() { return address; }
    public void setAddress(String address) { this.address = address; }

    @Override
    public String toString() {
        return String.format("[%d] %s | %s | %s | %s",
            id, name, phone, email, address);
    }
}
```

#### 실행
```bash
javac Contact.java
```

#### 예상 출력
```
# 컴파일 성공, Contact.class 파일 생성
```

#### 코드 설명
- **라인 1**: Serializable 인터페이스로 파일 저장 가능
- **라인 2**: serialVersionUID로 직렬화 버전 관리
- **라인 4-8**: 연락처 필드 정의
- **라인 32**: toString()으로 보기 좋은 출력 형식

---

### 실습 2: 기본 CRUD 구현
**난이도**: ⭐⭐⭐☆☆

#### 코드
```java
import java.util.*;

public class ContactManager {
    private Map<Long, Contact> contacts;
    private Long nextId;

    public ContactManager() {
        this.contacts = new HashMap<>();
        this.nextId = 1L;
    }

    // Create
    public Contact add(Contact contact) {
        contact.setId(nextId++);
        contacts.put(contact.getId(), contact);
        System.out.println("연락처가 추가되었습니다: " + contact.getName());
        return contact;
    }

    // Read - 전체 조회
    public List<Contact> findAll() {
        return new ArrayList<>(contacts.values());
    }

    // Read - ID로 조회
    public Contact findById(Long id) {
        return contacts.get(id);
    }

    // Read - 이름으로 검색
    public List<Contact> findByName(String name) {
        List<Contact> result = new ArrayList<>();
        for (Contact contact : contacts.values()) {
            if (contact.getName().contains(name)) {
                result.add(contact);
            }
        }
        return result;
    }

    // Update
    public boolean update(Long id, Contact newContact) {
        if (!contacts.containsKey(id)) {
            return false;
        }
        newContact.setId(id);
        contacts.put(id, newContact);
        System.out.println("연락처가 수정되었습니다.");
        return true;
    }

    // Delete
    public boolean delete(Long id) {
        Contact removed = contacts.remove(id);
        if (removed != null) {
            System.out.println("연락처가 삭제되었습니다: " + removed.getName());
            return true;
        }
        return false;
    }

    // 통계
    public int count() {
        return contacts.size();
    }
}
```

---

### 실습 3: 파일 저장/로드
**난이도**: ⭐⭐⭐⭐☆

#### 코드
```java
import java.io.*;
import java.util.*;

public class FileManager {
    private static final String FILE_PATH = "contacts.dat";

    // 저장
    public static void save(Map<Long, Contact> contacts) {
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(FILE_PATH))) {
            oos.writeObject(contacts);
            System.out.println("파일에 저장되었습니다.");
        } catch (IOException e) {
            System.err.println("저장 실패: " + e.getMessage());
        }
    }

    // 로드
    @SuppressWarnings("unchecked")
    public static Map<Long, Contact> load() {
        File file = new File(FILE_PATH);
        if (!file.exists()) {
            return new HashMap<>();
        }

        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(FILE_PATH))) {
            return (Map<Long, Contact>) ois.readObject();
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("로드 실패: " + e.getMessage());
            return new HashMap<>();
        }
    }
}
```

---

### 좋은 예 vs 나쁜 예

#### ❌ 나쁜 예
```java
// 1. 하드코딩된 파일 경로
public void save() {
    FileOutputStream fos = new FileOutputStream("C:\\Users\\Admin\\contacts.dat");
}

// 2. 예외 무시
public void load() {
    try {
        // 파일 읽기
    } catch (Exception e) {
        // 아무것도 안 함!
    }
}

// 3. 검증 없는 입력
public void add(Contact contact) {
    contacts.add(contact);  // null 체크 없음!
}
```

**문제점**:
- 문제 1: 절대 경로는 다른 환경에서 작동 안 함
- 문제 2: 에러 발생 시 원인 파악 불가
- 문제 3: NullPointerException 위험

#### ✅ 좋은 예
```java
// 1. 상대 경로 사용
private static final String FILE_PATH = "./data/contacts.dat";

// 2. 예외 처리
public void load() {
    try {
        // 파일 읽기
    } catch (IOException e) {
        logger.error("파일 로드 실패", e);
        showErrorDialog("파일을 불러올 수 없습니다.");
    }
}

// 3. 입력 검증
public void add(Contact contact) {
    if (contact == null) {
        throw new IllegalArgumentException("연락처는 null일 수 없습니다.");
    }
    validateContact(contact);
    contacts.add(contact);
}
```

**장점**:
- 장점 1: 어디서든 실행 가능
- 장점 2: 에러 원인 명확히 파악
- 장점 3: 안전한 데이터 처리

---

## 🏢 실무 활용 사례

### 실제 기업 활용 사례

#### 사례 1: 중소기업 - 고객 관리 시스템

```java
// 사용 목적: 소규모 사무실의 고객 정보 관리
// 규모: 고객 500-1,000명
// 효과: 엑셀 대비 검색 속도 100배 향상

public class CustomerManager extends ContactManager {
    // 고객 등급별 분류
    public List<Contact> findByGrade(String grade) {
        return findAll().stream()
            .filter(c -> c.getAddress().contains(grade))
            .collect(Collectors.toList());
    }

    // 최근 연락일 기준 정렬
    public List<Contact> sortByRecentContact() {
        // 구현 생략
        return null;
    }

    // 성과
    // - 고객 검색 시간: 30초 → 0.3초 (100배 개선)
    // - 데이터 입력 시간: 5분 → 1분 (80% 단축)
    // - 실수로 인한 오류: 20건/월 → 0건 (100% 감소)
}
```

#### 사례 2: 스타트업 - 초기 고객 DB

```java
// 사용 목적: 스타트업 초기 고객 데이터베이스
// 규모: 베타 테스터 100-500명
// 효과: 본격 DB 도입 전 빠른 프로토타이핑

public class BetaTesterManager {
    private ContactManager contactManager;

    // 피드백 기록
    public void addFeedback(Long contactId, String feedback) {
        Contact contact = contactManager.findById(contactId);
        String currentAddress = contact.getAddress();
        contact.setAddress(currentAddress + " | Feedback: " + feedback);
    }

    // 통계
    public Map<String, Integer> getFeedbackStats() {
        // 피드백 통계 분석
        return null;
    }

    // 성과
    // - 개발 기간: 2주 (DB 구축 대비 4주 단축)
    // - 개발 비용: $0 (DB 라이센스 $5,000 절약)
    // - 출시 시간: 1개월 앞당김
}
```

#### 사례 3: 학원 - 학생 관리 시스템

```java
// 사용 목적: 소규모 학원의 학생 및 학부모 연락처 관리
// 규모: 학생 100-300명
// 효과: 출결 관리 및 긴급 연락 시스템 구축

public class StudentContactManager {
    private ContactManager contactManager;

    // 학년별 일괄 문자 발송 대상 조회
    public List<Contact> getParentsByGrade(int grade) {
        return contactManager.findAll().stream()
            .filter(c -> c.getName().contains("학년:" + grade))
            .collect(Collectors.toList());
    }

    // 긴급 연락망 (전화번호만 추출)
    public List<String> getEmergencyContacts() {
        return contactManager.findAll().stream()
            .map(Contact::getPhone)
            .collect(Collectors.toList());
    }

    // 성과
    // - 긴급 연락 시간: 30분 → 5분 (83% 단축)
    // - 문자 발송 오류: 15% → 0% (100% 감소)
    // - 학부모 만족도: 70% → 95% (36% 향상)
}
```

### 성능 비교

| 방법 | 추가 시간 | 검색 시간 | 수정 시간 | 데이터 손실 |
|------|----------|----------|----------|------------|
| 엑셀 수작업 | 60초 | 30초 | 90초 | 10% |
| 간단한 프로그램 | 10초 | 5초 | 15초 | 5% |
| 완성된 시스템 | 5초 | 0.3초 | 5초 | 0% |
| **개선** | **92%↓** | **99%↓** | **94%↓** | **100%↓** |

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: 파일 경로 하드코딩 문제

**상황**: 윈도우에서 개발한 프로그램을 맥에서 실행하니 파일을 찾지 못함

```java
// ❌ 주니어 개발자가 작성한 코드
public class FileManager {
    // 윈도우 절대 경로
    private static final String FILE_PATH = "C:\\Users\\MyName\\Desktop\\contacts.dat";

    public void save(List<Contact> contacts) {
        try {
            FileOutputStream fos = new FileOutputStream(FILE_PATH);
            // 저장 로직
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// 맥에서 실행 시:
// FileNotFoundException: C:\Users\MyName\Desktop\contacts.dat
// (맥에는 C:\ 드라이브가 없음!)
```

**문제점**:
- 문제 1: 절대 경로를 하드코딩
- 문제 2: 운영체제 종속적 (Windows only)
- 왜 이 문제가 발생하는가: 다른 환경을 고려하지 않음

**해결책**:
```java
// ✅ 올바른 코드
public class FileManager {
    // 상대 경로 사용
    private static final String FILE_PATH = "contacts.dat";

    // 또는 시스템 속성 활용
    private static final String DATA_DIR =
        System.getProperty("user.home") + File.separator + ".contactmanager";

    public void save(List<Contact> contacts) {
        // 디렉토리 존재 확인
        File dir = new File(DATA_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        File file = new File(dir, FILE_PATH);
        try (FileOutputStream fos = new FileOutputStream(file)) {
            // 저장 로직
        } catch (IOException e) {
            logger.error("파일 저장 실패", e);
        }
    }
}
```

**배운 점**:
- 💡 팁 1: 상대 경로 또는 사용자 홈 디렉토리 활용
- 💡 팁 2: File.separator로 OS 독립적 경로 생성

---

### 시나리오 2: 예외 처리 누락

**상황**: 파일이 없을 때 프로그램이 갑자기 종료됨

```java
// ❌ 잘못된 코드
public class ContactApp {
    public static void main(String[] args) {
        FileInputStream fis = new FileInputStream("contacts.dat");
        // 컴파일 에러: Unhandled exception: FileNotFoundException

        ObjectInputStream ois = new ObjectInputStream(fis);
        List<Contact> contacts = (List<Contact>) ois.readObject();
    }
}
```

**문제점**:
- 문제 1: checked exception을 처리하지 않음
- 문제 2: 파일이 없을 때 프로그램 강제 종료
- 왜 이 문제가 발생하는가: 예외 상황을 고려하지 않음

**해결책**:
```java
// ✅ 올바른 코드
public class ContactApp {
    public static void main(String[] args) {
        List<Contact> contacts = loadContacts();

        if (contacts.isEmpty()) {
            System.out.println("저장된 연락처가 없습니다. 새로 시작합니다.");
        } else {
            System.out.println(contacts.size() + "개의 연락처를 불러왔습니다.");
        }
    }

    private static List<Contact> loadContacts() {
        File file = new File("contacts.dat");

        // 파일이 없으면 빈 리스트 반환
        if (!file.exists()) {
            return new ArrayList<>();
        }

        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(file))) {
            return (List<Contact>) ois.readObject();
        } catch (IOException e) {
            System.err.println("파일 읽기 오류: " + e.getMessage());
            return new ArrayList<>();
        } catch (ClassNotFoundException e) {
            System.err.println("데이터 형식 오류: " + e.getMessage());
            return new ArrayList<>();
        }
    }
}
```

**배운 점**:
- 💡 팁 1: 파일 존재 여부를 먼저 확인
- 💡 팁 2: 예외 발생 시 기본값 반환으로 프로그램 계속 실행

---

### 시나리오 3: 입력 검증 부족

**상황**: 잘못된 전화번호 형식이 저장되어 나중에 문제 발생

```java
// ❌ 검증 없는 코드
public void addContact(String name, String phone, String email) {
    Contact contact = new Contact(name, phone, email, "");
    contacts.add(contact);
}

// 사용자 입력: "전화번호: 01012345678" (형식 틀림)
// 나중에 전화 걸 때: 오류 발생!
```

**문제점**:
- 문제 1: 전화번호 형식 검증 없음
- 문제 2: 이메일 유효성 체크 없음
- 왜 이 문제가 발생하는가: 사용자 입력을 믿고 그대로 저장

**해결책**:
```java
// ✅ 검증이 있는 코드
public class ContactValidator {
    private static final String PHONE_PATTERN = "^01[0-9]-\\d{4}-\\d{4}$";
    private static final String EMAIL_PATTERN =
        "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";

    public static boolean validatePhone(String phone) {
        if (phone == null || phone.trim().isEmpty()) {
            return false;
        }
        return phone.matches(PHONE_PATTERN);
    }

    public static boolean validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            return false;
        }
        return email.matches(EMAIL_PATTERN);
    }

    public static void validate(Contact contact) throws ValidationException {
        if (contact.getName() == null || contact.getName().trim().isEmpty()) {
            throw new ValidationException("이름은 필수입니다.");
        }

        if (!validatePhone(contact.getPhone())) {
            throw new ValidationException(
                "전화번호 형식이 올바르지 않습니다. (예: 010-1234-5678)");
        }

        if (!validateEmail(contact.getEmail())) {
            throw new ValidationException(
                "이메일 형식이 올바르지 않습니다.");
        }
    }
}

// 사용
public void addContact(Contact contact) {
    try {
        ContactValidator.validate(contact);
        contacts.add(contact);
        System.out.println("연락처가 추가되었습니다.");
    } catch (ValidationException e) {
        System.err.println("입력 오류: " + e.getMessage());
    }
}
```

**배운 점**:
- 💡 팁 1: 정규표현식으로 형식 검증
- 💡 팁 2: 명확한 오류 메시지 제공

---

### 시나리오 4: Scanner 미닫기로 인한 리소스 누수

**상황**: Scanner를 닫지 않아 경고 발생 및 리소스 낭비

```java
// ❌ 잘못된 코드
public void getUserInput() {
    Scanner scanner = new Scanner(System.in);
    System.out.print("이름: ");
    String name = scanner.nextLine();
    // scanner.close() 누락!
}
// 경고: Resource leak: 'scanner' is never closed
```

**문제점**:
- 문제 1: Scanner를 닫지 않음
- 문제 2: 메모리 및 시스템 리소스 낭비
- 왜 이 문제가 발생하는가: try-with-resources를 모름

**해결책**:
```java
// ✅ 올바른 코드 (방법 1: try-with-resources)
public void getUserInput() {
    try (Scanner scanner = new Scanner(System.in)) {
        System.out.print("이름: ");
        String name = scanner.nextLine();
        // 자동으로 닫힘!
    }
}

// ✅ 더 나은 방법 (방법 2: 싱글톤 Scanner)
public class InputManager {
    private static final Scanner scanner = new Scanner(System.in);

    public static String readLine(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine();
    }

    public static void close() {
        scanner.close();
    }
}

// 사용
String name = InputManager.readLine("이름: ");
```

**배운 점**:
- 💡 팁 1: try-with-resources로 자동 닫기
- 💡 팁 2: Scanner는 싱글톤으로 관리 (System.in 여러 번 닫기 방지)

---

## 🛠️ 실전 프로젝트

### 프로젝트: 완전한 콘솔 주소록 관리 시스템

**난이도**: ⭐⭐⭐⭐☆
**예상 소요 시간**: 6-8시간
**학습 목표**: 실무에서 사용 가능한 완전한 CRUD 애플리케이션 구현

### 요구사항 분석

#### 기능 요구사항
- [ ] 연락처 추가 (이름, 전화번호, 이메일, 주소)
- [ ] 연락처 목록 조회 (전체, 페이징)
- [ ] 연락처 검색 (이름, 전화번호)
- [ ] 연락처 수정
- [ ] 연락처 삭제
- [ ] 파일 저장/불러오기 (자동 저장)
- [ ] 입력 검증 (전화번호, 이메일 형식)
- [ ] 중복 체크 (전화번호 기준)

#### 기술 요구사항
- [ ] 객체 지향 설계 (캡슐화, 상속, 다형성)
- [ ] 예외 처리 (파일 I/O, 입력 검증)
- [ ] 파일 영속성 (직렬화)
- [ ] 메뉴 기반 UI

#### 비기능 요구사항
- [ ] 성능: 1,000건 조회 시 1초 이내
- [ ] 안정성: 프로그램 종료 전 자동 저장
- [ ] 사용성: 직관적인 메뉴 구조

### 프로젝트 구조
```
contact-manager/
├── src/
│   ├── Contact.java
│   ├── ContactManager.java
│   ├── FileManager.java
│   ├── ContactValidator.java
│   ├── ValidationException.java
│   ├── InputManager.java
│   └── Main.java
├── data/
│   └── contacts.dat
└── README.md
```

### 전체 소스 코드

#### Contact.java
```java
import java.io.Serializable;
import java.time.LocalDateTime;

public class Contact implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long id;
    private String name;
    private String phone;
    private String email;
    private String address;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;

    public Contact(String name, String phone, String email, String address) {
        this.name = name;
        this.phone = phone;
        this.email = email;
        this.address = address;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) {
        this.name = name;
        this.updatedAt = LocalDateTime.now();
    }

    public String getPhone() { return phone; }
    public void setPhone(String phone) {
        this.phone = phone;
        this.updatedAt = LocalDateTime.now();
    }

    public String getEmail() { return email; }
    public void setEmail(String email) {
        this.email = email;
        this.updatedAt = LocalDateTime.now();
    }

    public String getAddress() { return address; }
    public void setAddress(String address) {
        this.address = address;
        this.updatedAt = LocalDateTime.now();
    }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }

    @Override
    public String toString() {
        return String.format("┌─────────────────────────────────────────┐\n" +
                           "│ ID: %-36d│\n" +
                           "│ 이름: %-34s│\n" +
                           "│ 전화: %-34s│\n" +
                           "│ 이메일: %-32s│\n" +
                           "│ 주소: %-34s│\n" +
                           "└─────────────────────────────────────────┘",
                           id, name, phone, email, address);
    }

    public String toSimpleString() {
        return String.format("[%d] %s | %s | %s", id, name, phone, email);
    }
}
```

#### ContactValidator.java
```java
import java.util.regex.Pattern;

public class ContactValidator {
    private static final Pattern PHONE_PATTERN =
        Pattern.compile("^01[0-9]-\\d{3,4}-\\d{4}$");
    private static final Pattern EMAIL_PATTERN =
        Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$");

    public static void validate(Contact contact) throws ValidationException {
        validateName(contact.getName());
        validatePhone(contact.getPhone());
        validateEmail(contact.getEmail());
    }

    private static void validateName(String name) throws ValidationException {
        if (name == null || name.trim().isEmpty()) {
            throw new ValidationException("이름은 필수입니다.");
        }
        if (name.length() < 2 || name.length() > 50) {
            throw new ValidationException("이름은 2-50자 사이여야 합니다.");
        }
    }

    private static void validatePhone(String phone) throws ValidationException {
        if (phone == null || phone.trim().isEmpty()) {
            throw new ValidationException("전화번호는 필수입니다.");
        }
        if (!PHONE_PATTERN.matcher(phone).matches()) {
            throw new ValidationException(
                "전화번호 형식이 올바르지 않습니다. (예: 010-1234-5678)");
        }
    }

    private static void validateEmail(String email) throws ValidationException {
        if (email == null || email.trim().isEmpty()) {
            throw new ValidationException("이메일은 필수입니다.");
        }
        if (!EMAIL_PATTERN.matcher(email).matches()) {
            throw new ValidationException(
                "이메일 형식이 올바르지 않습니다. (예: user@example.com)");
        }
    }
}

class ValidationException extends Exception {
    public ValidationException(String message) {
        super(message);
    }
}
```

#### ContactManager.java
```java
import java.util.*;
import java.util.stream.Collectors;

public class ContactManager {
    private Map<Long, Contact> contacts;
    private Long nextId;

    public ContactManager() {
        this.contacts = new HashMap<>();
        this.nextId = 1L;
    }

    public ContactManager(Map<Long, Contact> contacts, Long nextId) {
        this.contacts = contacts;
        this.nextId = nextId;
    }

    // Create
    public Contact add(Contact contact) throws ValidationException {
        ContactValidator.validate(contact);

        // 중복 체크 (전화번호 기준)
        if (isDuplicatePhone(contact.getPhone())) {
            throw new ValidationException(
                "이미 등록된 전화번호입니다: " + contact.getPhone());
        }

        contact.setId(nextId++);
        contacts.put(contact.getId(), contact);
        System.out.println("\n✓ 연락처가 추가되었습니다: " + contact.getName());
        return contact;
    }

    // Read - 전체 조회
    public List<Contact> findAll() {
        return new ArrayList<>(contacts.values());
    }

    // Read - ID로 조회
    public Contact findById(Long id) {
        return contacts.get(id);
    }

    // Read - 이름으로 검색
    public List<Contact> findByName(String keyword) {
        return contacts.values().stream()
            .filter(c -> c.getName().toLowerCase()
                          .contains(keyword.toLowerCase()))
            .collect(Collectors.toList());
    }

    // Read - 전화번호로 검색
    public List<Contact> findByPhone(String keyword) {
        return contacts.values().stream()
            .filter(c -> c.getPhone().contains(keyword))
            .collect(Collectors.toList());
    }

    // Update
    public boolean update(Long id, Contact newContact) throws ValidationException {
        Contact existing = contacts.get(id);
        if (existing == null) {
            return false;
        }

        ContactValidator.validate(newContact);

        // 다른 연락처와 전화번호 중복 체크
        if (!existing.getPhone().equals(newContact.getPhone()) &&
            isDuplicatePhone(newContact.getPhone())) {
            throw new ValidationException(
                "이미 등록된 전화번호입니다: " + newContact.getPhone());
        }

        newContact.setId(id);
        contacts.put(id, newContact);
        System.out.println("\n✓ 연락처가 수정되었습니다.");
        return true;
    }

    // Delete
    public boolean delete(Long id) {
        Contact removed = contacts.remove(id);
        if (removed != null) {
            System.out.println("\n✓ 연락처가 삭제되었습니다: " + removed.getName());
            return true;
        }
        return false;
    }

    // 통계
    public int count() {
        return contacts.size();
    }

    // 중복 체크
    private boolean isDuplicatePhone(String phone) {
        return contacts.values().stream()
            .anyMatch(c -> c.getPhone().equals(phone));
    }

    // 데이터 접근 (저장용)
    public Map<Long, Contact> getContacts() {
        return contacts;
    }

    public Long getNextId() {
        return nextId;
    }
}
```

#### FileManager.java
```java
import java.io.*;
import java.util.*;

public class FileManager {
    private static final String DATA_DIR = "data";
    private static final String FILE_NAME = "contacts.dat";
    private static final String FILE_PATH = DATA_DIR + File.separator + FILE_NAME;

    // 저장
    public static void save(ContactManager manager) {
        createDataDirectory();

        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(FILE_PATH))) {

            SaveData data = new SaveData(
                manager.getContacts(),
                manager.getNextId()
            );

            oos.writeObject(data);
            System.out.println("✓ 파일에 저장되었습니다: " + FILE_PATH);
        } catch (IOException e) {
            System.err.println("✗ 저장 실패: " + e.getMessage());
        }
    }

    // 로드
    public static ContactManager load() {
        File file = new File(FILE_PATH);

        if (!file.exists()) {
            System.out.println("저장된 파일이 없습니다. 새로 시작합니다.");
            return new ContactManager();
        }

        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(FILE_PATH))) {

            SaveData data = (SaveData) ois.readObject();
            System.out.println("✓ 파일을 불러왔습니다: " +
                             data.contacts.size() + "개의 연락처");

            return new ContactManager(data.contacts, data.nextId);
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("✗ 로드 실패: " + e.getMessage());
            return new ContactManager();
        }
    }

    // 디렉토리 생성
    private static void createDataDirectory() {
        File dir = new File(DATA_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
        }
    }

    // 저장 데이터 래퍼
    private static class SaveData implements Serializable {
        private static final long serialVersionUID = 1L;
        Map<Long, Contact> contacts;
        Long nextId;

        SaveData(Map<Long, Contact> contacts, Long nextId) {
            this.contacts = contacts;
            this.nextId = nextId;
        }
    }
}
```

#### InputManager.java
```java
import java.util.Scanner;

public class InputManager {
    private static final Scanner scanner = new Scanner(System.in);

    public static String readLine(String prompt) {
        System.out.print(prompt);
        return scanner.nextLine().trim();
    }

    public static int readInt(String prompt) {
        while (true) {
            try {
                System.out.print(prompt);
                String input = scanner.nextLine().trim();
                return Integer.parseInt(input);
            } catch (NumberFormatException e) {
                System.out.println("✗ 숫자를 입력해주세요.");
            }
        }
    }

    public static long readLong(String prompt) {
        while (true) {
            try {
                System.out.print(prompt);
                String input = scanner.nextLine().trim();
                return Long.parseLong(input);
            } catch (NumberFormatException e) {
                System.out.println("✗ 숫자를 입력해주세요.");
            }
        }
    }

    public static boolean confirm(String message) {
        String answer = readLine(message + " (y/n): ");
        return answer.equalsIgnoreCase("y") || answer.equalsIgnoreCase("yes");
    }

    public static void close() {
        scanner.close();
    }
}
```

#### Main.java
```java
import java.util.List;

public class Main {
    private static ContactManager manager;
    private static boolean running = true;

    public static void main(String[] args) {
        System.out.println("╔═══════════════════════════════════════╗");
        System.out.println("║     주소록 관리 프로그램 v1.0        ║");
        System.out.println("╚═══════════════════════════════════════╝\n");

        // 파일에서 로드
        manager = FileManager.load();

        // 종료 시 자동 저장
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("\n프로그램을 종료합니다...");
            FileManager.save(manager);
        }));

        // 메인 루프
        while (running) {
            showMenu();
            int choice = InputManager.readInt("선택: ");
            System.out.println();

            handleMenuChoice(choice);
        }
    }

    private static void showMenu() {
        System.out.println("\n┌─────────────────────────────────────┐");
        System.out.println("│           메인 메뉴                 │");
        System.out.println("├─────────────────────────────────────┤");
        System.out.println("│ 1. 연락처 추가                      │");
        System.out.println("│ 2. 전체 연락처 보기                 │");
        System.out.println("│ 3. 연락처 검색                      │");
        System.out.println("│ 4. 연락처 수정                      │");
        System.out.println("│ 5. 연락처 삭제                      │");
        System.out.println("│ 6. 저장                             │");
        System.out.println("│ 0. 종료                             │");
        System.out.println("└─────────────────────────────────────┘");
        System.out.println("현재 연락처 수: " + manager.count() + "개");
    }

    private static void handleMenuChoice(int choice) {
        switch (choice) {
            case 1: addContact(); break;
            case 2: listAllContacts(); break;
            case 3: searchContact(); break;
            case 4: updateContact(); break;
            case 5: deleteContact(); break;
            case 6: saveContacts(); break;
            case 0: exitProgram(); break;
            default: System.out.println("✗ 잘못된 선택입니다.");
        }
    }

    // 1. 연락처 추가
    private static void addContact() {
        System.out.println("=== 새 연락처 추가 ===");

        String name = InputManager.readLine("이름: ");
        String phone = InputManager.readLine("전화번호 (예: 010-1234-5678): ");
        String email = InputManager.readLine("이메일: ");
        String address = InputManager.readLine("주소: ");

        Contact contact = new Contact(name, phone, email, address);

        try {
            manager.add(contact);
        } catch (ValidationException e) {
            System.out.println("✗ 추가 실패: " + e.getMessage());
        }
    }

    // 2. 전체 연락처 보기
    private static void listAllContacts() {
        List<Contact> contacts = manager.findAll();

        if (contacts.isEmpty()) {
            System.out.println("등록된 연락처가 없습니다.");
            return;
        }

        System.out.println("=== 전체 연락처 (" + contacts.size() + "개) ===\n");

        for (Contact contact : contacts) {
            System.out.println(contact.toSimpleString());
        }
    }

    // 3. 연락처 검색
    private static void searchContact() {
        System.out.println("=== 연락처 검색 ===");
        System.out.println("1. 이름으로 검색");
        System.out.println("2. 전화번호로 검색");

        int choice = InputManager.readInt("선택: ");
        String keyword = InputManager.readLine("검색어: ");

        List<Contact> results;
        if (choice == 1) {
            results = manager.findByName(keyword);
        } else if (choice == 2) {
            results = manager.findByPhone(keyword);
        } else {
            System.out.println("✗ 잘못된 선택입니다.");
            return;
        }

        if (results.isEmpty()) {
            System.out.println("검색 결과가 없습니다.");
            return;
        }

        System.out.println("\n검색 결과: " + results.size() + "개\n");
        for (Contact contact : results) {
            System.out.println(contact);
        }
    }

    // 4. 연락처 수정
    private static void updateContact() {
        System.out.println("=== 연락처 수정 ===");

        long id = InputManager.readLong("수정할 연락처 ID: ");
        Contact existing = manager.findById(id);

        if (existing == null) {
            System.out.println("✗ 해당 ID의 연락처가 없습니다.");
            return;
        }

        System.out.println("\n현재 정보:");
        System.out.println(existing);

        System.out.println("\n새 정보 입력 (변경하지 않으려면 Enter):");

        String name = InputManager.readLine("이름 [" + existing.getName() + "]: ");
        if (name.isEmpty()) name = existing.getName();

        String phone = InputManager.readLine("전화번호 [" + existing.getPhone() + "]: ");
        if (phone.isEmpty()) phone = existing.getPhone();

        String email = InputManager.readLine("이메일 [" + existing.getEmail() + "]: ");
        if (email.isEmpty()) email = existing.getEmail();

        String address = InputManager.readLine("주소 [" + existing.getAddress() + "]: ");
        if (address.isEmpty()) address = existing.getAddress();

        Contact updated = new Contact(name, phone, email, address);

        try {
            manager.update(id, updated);
        } catch (ValidationException e) {
            System.out.println("✗ 수정 실패: " + e.getMessage());
        }
    }

    // 5. 연락처 삭제
    private static void deleteContact() {
        System.out.println("=== 연락처 삭제 ===");

        long id = InputManager.readLong("삭제할 연락처 ID: ");
        Contact contact = manager.findById(id);

        if (contact == null) {
            System.out.println("✗ 해당 ID의 연락처가 없습니다.");
            return;
        }

        System.out.println("\n삭제할 연락처:");
        System.out.println(contact);

        if (InputManager.confirm("\n정말 삭제하시겠습니까?")) {
            manager.delete(id);
        } else {
            System.out.println("취소되었습니다.");
        }
    }

    // 6. 저장
    private static void saveContacts() {
        FileManager.save(manager);
    }

    // 0. 종료
    private static void exitProgram() {
        if (InputManager.confirm("\n저장하고 종료하시겠습니까?")) {
            FileManager.save(manager);
        }
        running = false;
        System.out.println("\n프로그램을 종료합니다. 안녕히 가세요!");
    }
}
```

### 실행 결과 화면
```
╔═══════════════════════════════════════╗
║     주소록 관리 프로그램 v1.0        ║
╚═══════════════════════════════════════╝

저장된 파일이 없습니다. 새로 시작합니다.

┌─────────────────────────────────────┐
│           메인 메뉴                 │
├─────────────────────────────────────┤
│ 1. 연락처 추가                      │
│ 2. 전체 연락처 보기                 │
│ 3. 연락처 검색                      │
│ 4. 연락처 수정                      │
│ 5. 연락처 삭제                      │
│ 6. 저장                             │
│ 0. 종료                             │
└─────────────────────────────────────┘
현재 연락처 수: 0개
선택: 1

=== 새 연락처 추가 ===
이름: 김철수
전화번호 (예: 010-1234-5678): 010-1234-5678
이메일: kim@example.com
주소: 서울시 강남구

✓ 연락처가 추가되었습니다: 김철수

┌─────────────────────────────────────┐
│           메인 메뉴                 │
├─────────────────────────────────────┤
│ 1. 연락처 추가                      │
│ 2. 전체 연락처 보기                 │
│ 3. 연락처 검색                      │
│ 4. 연락처 수정                      │
│ 5. 연락처 삭제                      │
│ 6. 저장                             │
│ 0. 종료                             │
└─────────────────────────────────────┘
현재 연락처 수: 1개
선택: 2

=== 전체 연락처 (1개) ===

[1] 김철수 | 010-1234-5678 | kim@example.com

┌─────────────────────────────────────┐
│           메인 메뉴                 │
├─────────────────────────────────────┤
│ 1. 연락처 추가                      │
│ 2. 전체 연락처 보기                 │
│ 3. 연락처 검색                      │
│ 4. 연락처 수정                      │
│ 5. 연락처 삭제                      │
│ 6. 저장                             │
│ 0. 종료                             │
└─────────────────────────────────────┘
현재 연락처 수: 1개
선택: 0

저장하고 종료하시겠습니까? (y/n): y
✓ 파일에 저장되었습니다: data/contacts.dat

프로그램을 종료합니다. 안녕히 가세요!
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: 파일 저장 형식은 어떤 것을 선택해야 하나요?</strong></summary>

**A**: 프로젝트 규모와 요구사항에 따라 다릅니다.

**상세 설명**:
- 포인트 1: 소규모(< 1,000건) → 직렬화(.dat) 또는 JSON
- 포인트 2: 중규모(1,000-10,000건) → CSV 또는 SQLite
- 포인트 3: 대규모(> 10,000건) → MySQL, PostgreSQL

**비교표**:
```
형식       | 속도 | 가독성 | 호환성 | 용량
---------|------|--------|--------|------
직렬화    | 빠름 | 낮음   | Java   | 작음
JSON     | 보통 | 높음   | 모든언어| 중간
CSV      | 빠름 | 높음   | 엑셀   | 작음
DB       | 빠름 | 낮음   | SQL    | 최적
```

**실무 팁**:
💡 초기 프로토타입은 직렬화, 배포 버전은 DB 사용
</details>

<details>
<summary><strong>Q2: 전화번호 형식을 어떻게 통일하나요?</strong></summary>

**A**: 정규표현식으로 검증하고, 자동 포매팅을 적용합니다.

**상세 설명**:
- 포인트 1: 입력 시 자동으로 하이픈 추가
- 포인트 2: 정규표현식으로 형식 검증
- 포인트 3: 국제 번호 지원 시 별도 처리

**예시**:
```java
public static String formatPhone(String phone) {
    // 숫자만 추출
    String digits = phone.replaceAll("[^0-9]", "");

    // 010-1234-5678 형식으로 변환
    if (digits.length() == 11) {
        return digits.substring(0, 3) + "-" +
               digits.substring(3, 7) + "-" +
               digits.substring(7);
    }

    return phone;  // 형식 맞지 않으면 원본 반환
}

// 사용
String formatted = formatPhone("01012345678");
// 결과: "010-1234-5678"
```

**실무 팁**:
💡 라이브러리 사용: libphonenumber-java (Google)
</details>

<details>
<summary><strong>Q3: 대량의 연락처를 처리할 때 성능 문제는?</strong></summary>

**A**: 인덱싱, 캐싱, 페이징을 적용합니다.

**상세 설명**:
- 포인트 1: HashMap으로 O(1) 조회 성능
- 포인트 2: 검색은 인덱스 활용 (이름별, 전화번호별)
- 포인트 3: 페이징으로 메모리 사용량 제한

**성능 비교**:
```
데이터 수 | ArrayList | HashMap | 데이터베이스
---------|-----------|---------|-------------
100      | 0.1ms     | 0.01ms  | 0.5ms
1,000    | 1ms       | 0.01ms  | 1ms
10,000   | 10ms      | 0.01ms  | 2ms
100,000  | 100ms     | 0.01ms  | 5ms
```

**실무 팁**:
💡 1만 건 이상은 데이터베이스 필수
</details>

<details>
<summary><strong>Q4: 중복 연락처는 어떻게 처리하나요?</strong></summary>

**A**: 전화번호를 유일 키로 사용하고, 추가 전 체크합니다.

**상세 설명**:
- 포인트 1: 전화번호는 고유해야 함 (유일 키)
- 포인트 2: 이메일은 중복 허용 (여러 사람이 같은 회사 이메일)
- 포인트 3: 이름은 중복 가능 (동명이인)

**예시**:
```java
public boolean isDuplicate(String phone) {
    return contacts.values().stream()
        .anyMatch(c -> c.getPhone().equals(phone));
}

public void add(Contact contact) {
    if (isDuplicate(contact.getPhone())) {
        System.out.println("이미 등록된 전화번호입니다.");

        // 병합 옵션 제공
        if (confirmMerge()) {
            mergeContact(contact);
        }
    } else {
        contacts.put(contact.getId(), contact);
    }
}
```

**실무 팁**:
💡 중복 발견 시 병합(merge) 기능 제공
</details>

<details>
<summary><strong>Q5: 파일이 손상되었을 때 복구 방법은?</strong></summary>

**A**: 백업 파일을 자동으로 생성하고, 복구 메커니즘을 구현합니다.

**상세 설명**:
- 포인트 1: 저장 시 이전 파일을 .bak으로 백업
- 포인트 2: 로드 실패 시 백업 파일 시도
- 포인트 3: 자동 백업 주기 설정 (1시간마다)

**예시**:
```java
public static void saveWithBackup(ContactManager manager) {
    File currentFile = new File(FILE_PATH);
    File backupFile = new File(FILE_PATH + ".bak");

    // 기존 파일을 백업으로 이동
    if (currentFile.exists()) {
        currentFile.renameTo(backupFile);
    }

    try {
        // 새 파일 저장
        save(manager);
    } catch (Exception e) {
        // 실패 시 백업 복원
        backupFile.renameTo(currentFile);
        throw e;
    }
}
```

**실무 팁**:
💡 클라우드 동기화 (Google Drive, Dropbox)
</details>

<details>
<summary><strong>Q6: 여러 사용자가 동시에 사용할 수 있나요?</strong></summary>

**A**: 파일 기반은 어렵고, 데이터베이스를 사용해야 합니다.

**상세 설명**:
- 포인트 1: 파일 기반은 동시 쓰기 불가
- 포인트 2: 파일 잠금(Lock)으로 제한적 지원
- 포인트 3: 네트워크 DB로 완전한 동시성 지원

**아키텍처**:
```
단일 사용자 (현재):
사용자 → 파일 (contacts.dat)

다중 사용자 (개선):
사용자1 ↘
사용자2 → 데이터베이스 (MySQL)
사용자3 ↗
```

**실무 팁**:
💡 다중 사용자는 Client-Server 모델 필요
</details>

<details>
<summary><strong>Q7: 데이터를 엑셀로 내보낼 수 있나요?</strong></summary>

**A**: CSV 형식으로 내보내면 엑셀에서 열 수 있습니다.

**상세 설명**:
- 포인트 1: CSV는 엑셀 호환 형식
- 포인트 2: Apache POI 라이브러리로 직접 .xlsx 생성 가능
- 포인트 3: 가져오기(import) 기능도 구현 가능

**예시**:
```java
public void exportToCsv(String filename) {
    try (PrintWriter writer = new PrintWriter(filename)) {
        // 헤더
        writer.println("ID,이름,전화번호,이메일,주소");

        // 데이터
        for (Contact contact : findAll()) {
            writer.printf("%d,\"%s\",\"%s\",\"%s\",\"%s\"\n",
                contact.getId(),
                contact.getName(),
                contact.getPhone(),
                contact.getEmail(),
                contact.getAddress());
        }

        System.out.println("CSV 파일로 내보냈습니다: " + filename);
    } catch (IOException e) {
        System.err.println("내보내기 실패: " + e.getMessage());
    }
}
```

**실무 팁**:
💡 CSV는 UTF-8 BOM으로 저장 (엑셀 한글 깨짐 방지)
</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. CRUD란 무엇이며, 왜 중요한가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: Create, Read, Update, Delete의 약자
- 포인트 2: 모든 데이터 관리 시스템의 기본 연산
- 포인트 3: 데이터베이스 설계의 기초
- 포인트 4: REST API도 CRUD 기반

**예시 답변**
> "CRUD는 Create(생성), Read(조회), Update(수정), Delete(삭제)의 약자로, 데이터를 다루는 모든 시스템의 기본 연산입니다. 주소록 프로그램에서는 연락처를 추가하고, 조회하고, 수정하고, 삭제하는 것이 CRUD에 해당합니다. 이 패턴은 데이터베이스, REST API, 파일 시스템 등 모든 곳에 적용됩니다."

**꼬리 질문**
- Q: REST API의 HTTP 메서드와 CRUD의 대응 관계는?
- A: POST(Create), GET(Read), PUT/PATCH(Update), DELETE(Delete)

**실무 연관**
- 실무에서 대부분의 백엔드 개발은 CRUD 로직 구현
</details>

<details>
<summary><strong>2. 직렬화(Serialization)란 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 객체를 바이트 스트림으로 변환
- 포인트 2: 파일 저장, 네트워크 전송에 사용
- 포인트 3: Serializable 인터페이스 구현 필요
- 포인트 4: serialVersionUID로 버전 관리

**예시 답변**
> "직렬화는 Java 객체를 바이트 스트림으로 변환하는 과정입니다. Contact 객체를 파일에 저장하려면 Serializable 인터페이스를 구현해야 하고, ObjectOutputStream으로 저장, ObjectInputStream으로 읽습니다. serialVersionUID를 명시하면 클래스 변경 시에도 호환성을 유지할 수 있습니다."

```java
public class Contact implements Serializable {
    private static final long serialVersionUID = 1L;
    // 필드들...
}
```

**실무 연관**
- 세션 저장, 캐싱, 메시지 큐에 활용
</details>

<details>
<summary><strong>3. HashMap을 사용한 이유는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: O(1) 시간에 조회 가능
- 포인트 2: ID를 키로 사용하여 빠른 접근
- 포인트 3: ArrayList는 O(n) 조회 시간
- 포인트 4: 대량 데이터 처리에 유리

**예시 답변**
> "HashMap을 사용한 이유는 ID로 연락처를 조회할 때 O(1) 시간 복잡도를 달성하기 위해서입니다. ArrayList를 사용하면 O(n) 시간이 걸리지만, HashMap은 평균적으로 상수 시간에 조회할 수 있습니다. 연락처 수가 늘어나도 성능이 일정하게 유지됩니다."

**성능 비교**:
```
데이터 1,000개 기준:
ArrayList 조회: 0.5ms (평균 500번 반복)
HashMap 조회: 0.001ms (바로 접근)
```

**실무 연관**
- 캐싱, 인덱싱에 HashMap 필수
</details>

<details>
<summary><strong>4. 입력 검증은 왜 필요한가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 잘못된 데이터 저장 방지
- 포인트 2: 보안 (SQL Injection 등)
- 포인트 3: 데이터 정합성 유지
- 포인트 4: 사용자 경험 향상

**예시 답변**
> "입력 검증은 잘못된 데이터가 시스템에 저장되는 것을 방지합니다. 전화번호 형식이 틀리면 나중에 전화를 걸 수 없고, 이메일 형식이 틀리면 메일을 보낼 수 없습니다. 또한 SQL Injection 같은 보안 공격도 막을 수 있습니다. 정규표현식으로 형식을 체크하고, 명확한 오류 메시지를 제공해야 합니다."

**실무 연관**
- 프론트엔드와 백엔드 모두에서 검증 필수
</details>

<details>
<summary><strong>5. 예외 처리는 어떻게 해야 하나요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: try-catch로 예외 처리
- 포인트 2: 구체적인 예외 타입 처리
- 포인트 3: 사용자에게 명확한 메시지
- 포인트 4: 로깅으로 디버깅 지원

**예시 답변**
> "예외 처리는 프로그램이 비정상 종료되지 않도록 합니다. FileNotFoundException, IOException 등 구체적인 예외를 따로 처리하고, 사용자에게는 '파일을 찾을 수 없습니다' 같은 이해하기 쉬운 메시지를 보여줍니다. 개발자를 위해서는 로그에 상세한 스택 트레이스를 남깁니다."

```java
try {
    // 파일 읽기
} catch (FileNotFoundException e) {
    System.err.println("파일을 찾을 수 없습니다.");
    logger.error("File not found", e);
} catch (IOException e) {
    System.err.println("파일 읽기 오류.");
    logger.error("IO error", e);
}
```

**실무 연관**
- 안정적인 서비스 운영의 핵심
</details>

<details>
<summary><strong>6. try-with-resources는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: 자동 리소스 관리
- 포인트 2: AutoCloseable 구현 객체에 사용
- 포인트 3: finally 블록 불필요
- 포인트 4: 리소스 누수 방지

**예시 답변**
> "try-with-resources는 Java 7에서 도입된 기능으로, 리소스를 자동으로 닫아줍니다. 파일, 네트워크 연결 등 AutoCloseable을 구현한 객체를 try 괄호 안에 선언하면, try 블록이 끝날 때 자동으로 close()가 호출됩니다. 리소스 누수를 방지하고 코드를 간결하게 만듭니다."

```java
// 자동으로 닫힘
try (FileOutputStream fos = new FileOutputStream("file.txt")) {
    // 파일 작업
}  // 여기서 fos.close() 자동 호출
```

**실무 연관**
- 데이터베이스 연결, 파일 처리에 필수
</details>

<details>
<summary><strong>7. MVC 패턴을 이 프로젝트에 어떻게 적용했나요?</strong></summary>

**모범 답안 포인트**
- 포인트 1: Model - Contact 클래스 (데이터)
- 포인트 2: View - Main 클래스의 메뉴 출력 (UI)
- 포인트 3: Controller - ContactManager (로직)
- 포인트 4: 각 계층이 독립적으로 변경 가능

**예시 답변**
> "MVC 패턴을 적용하여 Model은 Contact 클래스로 데이터를 표현하고, View는 Main 클래스의 메뉴와 출력 부분으로 UI를 담당하며, Controller는 ContactManager가 비즈니스 로직을 처리합니다. 이렇게 분리하면 UI를 콘솔에서 GUI로 바꾸더라도 Model과 Controller는 그대로 사용할 수 있습니다."

**실무 연관**
- 웹 개발의 기본 패턴 (Spring MVC)
</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. Repository 패턴을 적용한다면 어떻게 설계하시겠습니까?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: 인터페이스로 데이터 액세스 추상화
- 심화 포인트 2: 구현체 교체 가능 (파일 → DB)
- 심화 포인트 3: 테스트 가능성 향상 (Mock)
- 심화 포인트 4: 단일 책임 원칙 준수

**예시 답변**
> "ContactRepository 인터페이스를 정의하고, FileContactRepository와 DatabaseContactRepository 구현체를 만듭니다. 이렇게 하면 파일 저장에서 데이터베이스로 전환할 때 비즈니스 로직은 변경하지 않아도 됩니다. 또한 테스트 시 InMemoryContactRepository를 사용하여 빠른 단위 테스트가 가능합니다."

**설계 예시**:
```java
public interface ContactRepository {
    Contact save(Contact contact);
    Optional<Contact> findById(Long id);
    List<Contact> findAll();
    void delete(Long id);
}

public class FileContactRepository implements ContactRepository {
    // 파일 기반 구현
}

public class DatabaseContactRepository implements ContactRepository {
    // DB 기반 구현
}
```

**실무 연관**
- Spring Data JPA의 Repository 패턴
- 마이크로서비스 아키텍처에 필수
</details>

<details>
<summary><strong>2. 동시성 문제를 어떻게 해결하시겠습니까?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: ConcurrentHashMap 사용
- 심화 포인트 2: 파일 잠금 (FileLock)
- 심화 포인트 3: 낙관적 잠금 (버전 관리)
- 심화 포인트 4: 트랜잭션 개념 도입

**예시 답변**
> "파일 기반 시스템에서는 FileLock을 사용하여 동시 쓰기를 방지합니다. 메모리 내 데이터는 ConcurrentHashMap으로 thread-safe하게 관리하고, 각 Contact에 version 필드를 추가하여 낙관적 잠금을 구현합니다. 충돌 발생 시 'Conflict' 예외를 던지고 재시도 로직을 제공합니다."

**구현 예시**:
```java
public synchronized void save(ContactManager manager) {
    try (FileChannel channel = FileChannel.open(
            Paths.get(FILE_PATH),
            StandardOpenOption.WRITE,
            StandardOpenOption.CREATE)) {

        FileLock lock = channel.lock();
        try {
            // 파일 쓰기
        } finally {
            lock.release();
        }
    }
}
```

**실무 연관**
- 분산 시스템에서 필수 고려사항
</details>

<details>
<summary><strong>3. 대용량 데이터 처리를 위한 최적화 방안은?</strong></summary>

**모범 답안 포인트**
- 심화 포인트 1: 페이징 처리
- 심화 포인트 2: 인덱싱 (이름, 전화번호)
- 심화 포인트 3: 캐싱 전략 (LRU Cache)
- 심화 포인트 4: 비동기 저장

**예시 답변**
> "10만 건 이상의 데이터를 처리하려면 전체 로드 대신 페이징을 사용합니다. 검색 성능을 위해 이름과 전화번호에 인덱스를 구축하고, 자주 조회되는 데이터는 LRU Cache에 저장합니다. 파일 저장은 별도 스레드에서 비동기로 처리하여 UI 블로킹을 방지합니다."

**성능 개선**:
```
최적화 전: 100,000건 로드 - 30초
최적화 후: 페이징 100건 - 0.1초
인덱스 적용: 검색 100ms → 1ms
```

**실무 연관**
- 빅데이터 처리 시스템 설계
</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| CRUD | 데이터 기본 연산 | `Create`, `Read`, `Update`, `Delete` |
| 직렬화 | 객체를 바이트로 변환 | `Serializable`, `ObjectOutputStream` |
| 입력 검증 | 데이터 유효성 확인 | 정규표현식, `ValidationException` |
| 파일 I/O | 파일 읽기/쓰기 | `FileInputStream`, `FileOutputStream` |
| HashMap | 빠른 조회 자료구조 | O(1) 시간 복잡도 |
| 예외 처리 | 오류 상황 대응 | `try-catch`, `try-with-resources` |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| `new HashMap<>()` | 맵 생성 | `Map<Long, Contact> contacts` |
| `ObjectOutputStream` | 객체 직렬화 | `oos.writeObject(data)` |
| `ObjectInputStream` | 객체 역직렬화 | `ois.readObject()` |
| `Pattern.matches()` | 정규표현식 검증 | `phone.matches(PATTERN)` |
| `try-with-resources` | 자동 리소스 관리 | `try (Scanner s = ...)` |
| `File.exists()` | 파일 존재 확인 | `if (file.exists())` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 입력은 반드시 검증
- [ ] 파일 저장 전 백업
- [ ] 예외는 구체적으로 처리
- [ ] 리소스는 자동으로 닫기
- [ ] 상대 경로 사용

#### ❌ 하지 말아야 할 것
- [ ] 절대 경로 하드코딩 금지
- [ ] 예외 무시(빈 catch 블록) 금지
- [ ] Scanner 닫지 않기 금지
- [ ] 검증 없는 데이터 저장 금지
- [ ] 민감 정보 평문 저장 금지

### 성능/보안 체크리스트

#### 성능
- [ ] HashMap으로 빠른 조회
- [ ] 대량 데이터는 페이징
- [ ] 인덱스 활용
- [ ] 파일 I/O 최소화
- [ ] 캐싱 전략 적용

#### 보안
- [ ] 입력 검증 필수
- [ ] 예외 메시지에 민감 정보 노출 금지
- [ ] 파일 권한 설정
- [ ] 비밀번호는 암호화
- [ ] SQL Injection 방지

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| JDBC | 데이터베이스 연동 | ⭐⭐⭐⭐⭐ |
| JSON | 데이터 직렬화 | ⭐⭐⭐⭐ |
| Spring Boot | 웹 애플리케이션 | ⭐⭐⭐⭐⭐ |
| JPA/Hibernate | ORM | ⭐⭐⭐⭐ |
| JUnit | 테스트 | ⭐⭐⭐⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: 49장 - 성적 관리 시스템

- **배울 내용 1**: Student 클래스 설계 및 성적 관리
- **배울 내용 2**: 통계 기능 (평균, 최고점, 최저점)
- **배울 내용 3**: 등급 자동 계산 및 성적표 생성
- **실전 프로젝트**: 완전한 성적 관리 시스템 구현

### 이 장과의 연결점
```
이번 장에서 배운 [CRUD 패턴과 파일 I/O]
    ↓
다음 장에서 [통계 기능과 등급 시스템]
    ↓
최종적으로 [종합 관리 시스템 설계]
```

### 준비하면 좋을 것들
```bash
# 통계 라이브러리 (선택)
# Apache Commons Math
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-math3</artifactId>
    <version>3.6.1</version>
</dependency>
```

---

## 🎉 축하합니다!

**이제 여러분은**:
✅ CRUD 패턴을 이해하고 구현할 수 있습니다
✅ 파일 I/O로 데이터를 저장/로드할 수 있습니다
✅ 입력 검증과 예외 처리를 적용할 수 있습니다
✅ 실무에서 사용 가능한 주소록 시스템을 만들 수 있습니다

**다음 단계**:
- [ ] 다음 장으로 진행 (성적 관리 시스템)
- [ ] 주소록에 생일 알림 기능 추가
- [ ] GUI 버전으로 업그레이드 (Swing/JavaFX)

---

**다음 장으로 이동**: [다음: 49장 성적 관리 시스템 →](49-성적-관리-시스템.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
