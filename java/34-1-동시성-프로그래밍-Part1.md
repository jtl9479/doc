# 34장 동시성 프로그래밍 - Part 1: Concurrent 패키지

## 🔍 java.util.concurrent 패키지

**고수준 동시성 유틸리티 제공**

---

## 📖 ExecutorService

### 스레드 풀 관리
```java
// 고정 크기 스레드 풀
ExecutorService executor = Executors.newFixedThreadPool(10);

// 작업 제출
executor.submit(() -> {
    System.out.println("작업 실행");
});

// 종료
executor.shutdown();
```

---

## 📖 주요 Concurrent 컬렉션

### 1. ConcurrentHashMap
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// 스레드 안전
map.put("key", 1);
map.computeIfAbsent("key", k -> 0);
```

### 2. CopyOnWriteArrayList
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

// 읽기가 많고 쓰기가 적을 때 유리
list.add("item");
```

### 3. BlockingQueue
```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// 생산자
queue.put("item");

// 소비자
String item = queue.take();  // 비어있으면 대기
```

---

## 📖 Atomic 클래스

```java
AtomicInteger count = new AtomicInteger(0);

// 스레드 안전한 증가
count.incrementAndGet();
count.addAndGet(5);

// CAS (Compare-And-Swap)
count.compareAndSet(expected, newValue);
```

---

## 📖 CountDownLatch

```java
CountDownLatch latch = new CountDownLatch(3);

// 3개 작업 실행
for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        // 작업 수행
        latch.countDown();  // 카운트 감소
    }).start();
}

// 모든 작업 완료 대기
latch.await();
System.out.println("모든 작업 완료");
```

---

## 📖 CompletableFuture

```java
// 비동기 작업
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "결과";
});

// 결과 처리
future.thenAccept(result -> {
    System.out.println(result);
});

// 여러 작업 조합
CompletableFuture<String> combined = future1
    .thenCombine(future2, (r1, r2) -> r1 + r2);
```

**다음 Part 2**: 실전 패턴
