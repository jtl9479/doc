# 섹션 34: 고급 주제와 모범 사례

## 비유로 시작하기

Docker 모범 사례는 **건축 설계 원칙**과 같습니다.

```
건축 설계                            Docker 모범 사례
=========                            =================
🏗️ 견고한 기초                  →    최적화된 이미지
🔧 품질 좋은 자재                →    신뢰할 수 있는 베이스 이미지
📐 표준 규격                     →    컨테이너 디자인 패턴
🚪 비상구                        →    헬스체크, 그레이스풀 셧다운
🔥 화재 경보                     →    모니터링, 알림
📋 설계도                        →    문서화
♻️ 친환경 설계                   →    리소스 효율성
```

건축물이 설계 원칙 없이 지어지면 무너지듯이, Docker도 모범 사례 없이 운영하면 문제가 발생합니다.

---

## 1. 이미지 최적화

### 1.1 멀티 스테이지 빌드 마스터하기

```dockerfile
# ❌ 나쁜 예: 빌드 도구가 프로덕션 이미지에 포함
FROM gradle:8.5-jdk17
WORKDIR /app
COPY . .
RUN gradle build --no-daemon
CMD ["java", "-jar", "build/libs/app.jar"]
# 결과: 이미지 크기 ~800MB


# ✅ 좋은 예: 멀티 스테이지 빌드
FROM gradle:8.5-jdk17 AS builder
WORKDIR /app
COPY build.gradle.kts settings.gradle.kts ./
COPY gradle ./gradle
# 의존성만 먼저 다운로드 (캐싱 활용)
RUN gradle dependencies --no-daemon
# 소스 코드 복사 및 빌드
COPY src ./src
RUN gradle build --no-daemon -x test

# 프로덕션 스테이지
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app
# 빌드된 JAR만 복사
COPY --from=builder /app/build/libs/*.jar app.jar
# non-root 사용자
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser && \
    chown -R appuser:appuser /app
USER appuser
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
# 결과: 이미지 크기 ~200MB (75% 감소)
```

### 1.2 레이어 캐싱 최적화

```dockerfile
# ❌ 나쁜 예: 소스 변경마다 전체 재빌드
FROM node:18-alpine
WORKDIR /app
COPY . .                    # 모든 파일 복사
RUN npm install             # 소스 변경 시에도 재실행
RUN npm run build
CMD ["npm", "start"]


# ✅ 좋은 예: 레이어 캐싱 활용
FROM node:18-alpine
WORKDIR /app

# 1. 의존성 파일만 먼저 복사
COPY package*.json ./

# 2. 의존성 설치 (package.json 변경 시에만 재실행)
RUN npm ci --only=production

# 3. 소스 코드 복사 (자주 변경됨)
COPY . .

# 4. 빌드
RUN npm run build

CMD ["npm", "start"]

# package.json이 변경되지 않으면 npm ci는 캐시 사용
```

### 1.3 불필요한 파일 제외 (.dockerignore)

```bash
# .dockerignore
# VCS
.git
.gitignore
.gitattributes

# CI/CD
.github
.gitlab-ci.yml
Jenkinsfile

# 문서
README.md
CHANGELOG.md
docs/
*.md

# 빌드 산출물
build/
dist/
target/
*.jar
*.war

# 의존성
node_modules/
.gradle/
.m2/

# IDE
.idea/
.vscode/
*.iml
.project
.classpath

# 로그
*.log
logs/

# 환경 변수
.env
.env.local
secrets/

# 테스트
test/
tests/
__tests__/
*.test.js
*.spec.js

# OS
.DS_Store
Thumbs.db

# Docker
Dockerfile*
docker-compose*.yml
```

### 1.4 Distroless 이미지 사용

```dockerfile
# 최소한의 이미지 (OS 없음)
FROM gcr.io/distroless/java17-debian11

COPY --from=builder /app/build/libs/*.jar /app.jar

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]

# 장점:
# - 최소 이미지 크기
# - 공격 표면 최소화
# - 불필요한 도구 없음 (shell, package manager)
```

---

## 2. 컨테이너 디자인 패턴

### 2.1 사이드카 패턴 (Sidecar Pattern)

```yaml
# 로그 수집 사이드카
apiVersion: v1
kind: Pod
metadata:
  name: app-with-logging
spec:
  containers:
  # 메인 애플리케이션
  - name: app
    image: lk-trade/user-service:latest
    volumeMounts:
    - name: logs
      mountPath: /app/logs

  # 사이드카: 로그 수집
  - name: log-collector
    image: fluentd:latest
    volumeMounts:
    - name: logs
      mountPath: /app/logs
      readOnly: true

  volumes:
  - name: logs
    emptyDir: {}
```

용도:
- 로그 수집 및 전송
- 설정 파일 동기화
- 프록시 (Envoy, Linkerd)
- 모니터링 에이전트

### 2.2 앰배서더 패턴 (Ambassador Pattern)

```yaml
# 데이터베이스 프록시
apiVersion: v1
kind: Pod
metadata:
  name: app-with-db-proxy
spec:
  containers:
  # 메인 애플리케이션
  - name: app
    image: lk-trade/user-service:latest
    env:
    - name: DB_HOST
      value: "localhost"  # 앰배서더를 통해 접근
    - name: DB_PORT
      value: "5432"

  # 앰배서더: DB 프록시
  - name: db-proxy
    image: haproxy:latest
    # DB 연결 관리, 로드 밸런싱, SSL 종료
```

용도:
- 외부 서비스 연결 추상화
- 연결 풀링
- 재시도 로직
- 서킷 브레이커

### 2.3 어댑터 패턴 (Adapter Pattern)

```yaml
# 메트릭 변환 어댑터
apiVersion: v1
kind: Pod
metadata:
  name: app-with-adapter
spec:
  containers:
  # 메인 애플리케이션 (자체 메트릭 포맷)
  - name: app
    image: legacy-app:latest
    ports:
    - containerPort: 8080

  # 어댑터: Prometheus 포맷으로 변환
  - name: metrics-adapter
    image: prometheus-adapter:latest
    ports:
    - containerPort: 9090
```

용도:
- 메트릭 포맷 변환
- 로그 포맷 표준화
- 레거시 시스템 통합

---

## 3. 헬스체크 및 그레이스풀 셧다운

### 3.1 올바른 헬스체크 구현

```kotlin
// Spring Boot Actuator
@RestController
class HealthController {

    // Liveness: "나 살아있니?"
    @GetMapping("/actuator/health/liveness")
    fun liveness(): ResponseEntity<Map<String, Any>> {
        // 간단한 체크만
        return ResponseEntity.ok(mapOf(
            "status" to "UP",
            "timestamp" to Instant.now()
        ))
    }

    // Readiness: "요청 받을 준비 됐니?"
    @GetMapping("/actuator/health/readiness")
    fun readiness(): ResponseEntity<Map<String, Any>> {
        // 의존성 체크
        val dbHealthy = checkDatabaseConnection()
        val redisHealthy = checkRedisConnection()
        val externalApiHealthy = checkExternalApi()

        val allHealthy = dbHealthy && redisHealthy && externalApiHealthy

        return if (allHealthy) {
            ResponseEntity.ok(mapOf(
                "status" to "UP",
                "checks" to mapOf(
                    "database" to "UP",
                    "redis" to "UP",
                    "externalApi" to "UP"
                )
            ))
        } else {
            ResponseEntity.status(503).body(mapOf(
                "status" to "DOWN",
                "checks" to mapOf(
                    "database" to if (dbHealthy) "UP" else "DOWN",
                    "redis" to if (redisHealthy) "UP" else "DOWN",
                    "externalApi" to if (externalApiHealthy) "UP" else "DOWN"
                )
            ))
        }
    }
}
```

```yaml
# Kubernetes Deployment
spec:
  containers:
  - name: app
    livenessProbe:
      httpGet:
        path: /actuator/health/liveness
        port: 8080
      initialDelaySeconds: 60  # 시작 후 60초 후부터 체크
      periodSeconds: 10         # 10초마다 체크
      timeoutSeconds: 3         # 3초 내에 응답 없으면 실패
      failureThreshold: 3       # 3번 연속 실패 시 재시작

    readinessProbe:
      httpGet:
        path: /actuator/health/readiness
        port: 8080
      initialDelaySeconds: 30
      periodSeconds: 5
      timeoutSeconds: 3
      failureThreshold: 3       # 3번 실패 시 트래픽 차단
```

### 3.2 그레이스풀 셧다운 (Graceful Shutdown)

```kotlin
// application.yml
server:
  shutdown: graceful  # 그레이스풀 셧다운 활성화

spring:
  lifecycle:
    timeout-per-shutdown-phase: 30s  # 최대 30초 대기

// 커스텀 셧다운 로직
@Component
class GracefulShutdown : DisposableBean {
    private val logger = LoggerFactory.getLogger(GracefulShutdown::class.java)

    override fun destroy() {
        logger.info("Graceful shutdown initiated...")

        // 1. 새 요청 받지 않기
        logger.info("Stopping accepting new requests")

        // 2. 진행 중인 요청 완료 대기
        logger.info("Waiting for in-flight requests to complete")
        Thread.sleep(5000)  // 실제로는 요청 카운터 확인

        // 3. 리소스 정리
        logger.info("Cleaning up resources")
        // DB 연결 풀 종료
        // 캐시 플러시
        // 백그라운드 작업 종료

        logger.info("Graceful shutdown completed")
    }
}
```

```yaml
# Kubernetes에서 그레이스풀 셧다운
spec:
  containers:
  - name: app
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 15"]
    # SIGTERM 받은 후 15초 대기 → 애플리케이션 셧다운 시작
    terminationGracePeriodSeconds: 30
    # 최대 30초 후 SIGKILL
```

---

## 4. 리소스 관리 모범 사례

### 4.1 적절한 리소스 설정

```yaml
# ❌ 나쁜 예: 리소스 설정 없음
spec:
  containers:
  - name: app
    image: myapp:latest
    # requests/limits 없음 → 리소스 무한 사용 가능


# ✅ 좋은 예: 적절한 리소스 설정
spec:
  containers:
  - name: app
    image: myapp:latest
    resources:
      requests:
        cpu: "500m"      # 0.5 CPU 예약
        memory: "512Mi"  # 512MB 예약
      limits:
        cpu: "1000m"     # 최대 1 CPU
        memory: "1Gi"    # 최대 1GB

# 가이드라인:
# requests: 평균 사용량의 80%
# limits: 피크 사용량의 120%
```

### 4.2 JVM 메모리 설정

```dockerfile
# Dockerfile
FROM eclipse-temurin:17-jre-alpine

ENV JAVA_OPTS="-XX:+UseContainerSupport \
               -XX:MaxRAMPercentage=75.0 \
               -XX:InitialRAMPercentage=50.0 \
               -XX:+UseG1GC \
               -XX:MaxGCPauseMillis=200"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app.jar"]
```

```yaml
# Kubernetes
spec:
  containers:
  - name: app
    resources:
      requests:
        memory: "1Gi"
      limits:
        memory: "1Gi"
    env:
    - name: JAVA_OPTS
      value: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"
    # 1GB 컨테이너에서 JVM은 750MB 사용
```

### 4.3 리소스 모니터링

```bash
# 실시간 리소스 사용량 확인
kubectl top nodes
kubectl top pods -n lk-trade

# 리소스 사용량이 높은 Pod 찾기
kubectl top pods -n lk-trade --sort-by=memory
kubectl top pods -n lk-trade --sort-by=cpu

# 특정 Pod의 상세 리소스 사용량
kubectl describe pod <pod-name> -n lk-trade
```

---

## 5. 보안 모범 사례 체크리스트

### 5.1 이미지 보안

```bash
# ✅ 체크리스트
□ 신뢰할 수 있는 베이스 이미지 사용
□ 특정 버전 태그 사용 (latest 금지)
□ 이미지 스캔 (Trivy, Clair)
□ 이미지 서명 (Docker Content Trust)
□ 멀티 스테이지 빌드
□ non-root 사용자
□ 불필요한 패키지 제거
□ .dockerignore 설정
```

### 5.2 컨테이너 보안

```yaml
# SecurityContext 설정
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  containers:
  - name: app
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE
```

### 5.3 Secret 관리

```bash
# ❌ 나쁜 예
docker run -e DB_PASSWORD=supersecret myapp

# ✅ 좋은 예
# 1. Docker Secret 사용
echo "supersecret" | docker secret create db_password -
docker service create --secret db_password myapp

# 2. Kubernetes Secret 사용
kubectl create secret generic db-secret --from-literal=password=supersecret
```

---

## 6. 모니터링 및 로깅

### 6.1 구조화된 로깅

```kotlin
// ❌ 나쁜 예
logger.info("User login: ${user.email}")


// ✅ 좋은 예
logger.info(
    "User login",
    kv("userId", user.id),
    kv("email", user.email.maskEmail()),
    kv("ip", request.remoteAddr),
    kv("userAgent", request.getHeader("User-Agent"))
)

// JSON 출력:
{
  "timestamp": "2025-09-30T10:15:32.123Z",
  "level": "INFO",
  "message": "User login",
  "userId": 123,
  "email": "te**@example.com",
  "ip": "203.0.113.1",
  "userAgent": "Mozilla/5.0...",
  "correlationId": "abc-123-def"
}
```

### 6.2 메트릭 수집

```kotlin
// Prometheus 메트릭
import io.micrometer.core.instrument.MeterRegistry

@Service
class OrderService(
    private val meterRegistry: MeterRegistry
) {
    private val orderCounter = meterRegistry.counter("orders.created")
    private val orderTimer = meterRegistry.timer("orders.processing.time")

    fun createOrder(request: OrderRequest): Order {
        return orderTimer.record {
            // 주문 생성 로직
            val order = processOrder(request)

            // 카운터 증가
            orderCounter.increment()

            // 태그 추가
            meterRegistry.counter(
                "orders.created",
                "type", request.type,
                "status", "success"
            ).increment()

            order
        }
    }
}
```

---

## 7. 프로덕션 체크리스트

### 7.1 배포 전 체크리스트

```
□ 이미지
  □ 최적화된 이미지 크기 (<500MB)
  □ 보안 스캔 완료 (HIGH/CRITICAL 없음)
  □ 멀티 스테이지 빌드
  □ non-root 사용자
  □ 헬스체크 구현

□ 설정
  □ 환경별 설정 분리 (dev/staging/prod)
  □ Secret 암호화
  □ 리소스 requests/limits 설정
  □ 적절한 레플리카 수

□ 네트워킹
  □ 서비스 디스커버리 설정
  □ 로드 밸런서 구성
  □ Ingress 규칙 정의
  □ 네트워크 정책 적용

□ 스토리지
  □ PersistentVolume 설정
  □ 백업 전략 수립
  □ 데이터 마이그레이션 계획

□ 모니터링
  □ 메트릭 수집 (Prometheus)
  □ 로그 집계 (ELK/Loki)
  □ 알림 규칙 설정
  □ 대시보드 구성 (Grafana)

□ 보안
  □ RBAC 설정
  □ NetworkPolicy 적용
  □ PodSecurityPolicy 설정
  □ 이미지 스캔 자동화

□ 백업 및 재해 복구
  □ 정기 백업 스케줄
  □ 백업 복구 테스트
  □ DR 계획 수립
  □ RTO/RPO 정의

□ 문서화
  □ 아키텍처 다이어그램
  □ 배포 가이드
  □ 트러블슈팅 가이드
  □ 런북 (Runbook)
```

### 7.2 운영 체크리스트

```
일일 체크
□ 클러스터 상태 확인
□ Pod 상태 확인
□ 리소스 사용량 확인
□ 에러 로그 검토

주간 체크
□ 이미지 업데이트 확인
□ 보안 패치 적용
□ 백업 검증
□ 성능 메트릭 분석

월간 체크
□ 용량 계획 검토
□ 비용 분석
□ 보안 감사
□ DR 훈련
```

---

## 8. 성능 최적화

### 8.1 이미지 빌드 최적화

```dockerfile
# BuildKit 활성화
# syntax=docker/dockerfile:1

FROM node:18-alpine AS builder

WORKDIR /app

# 캐시 마운트 활용
RUN --mount=type=cache,target=/root/.npm \
    npm ci --only=production

# 빌드 캐시 활용
RUN --mount=type=cache,target=/app/.cache \
    npm run build

FROM node:18-alpine

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules

CMD ["node", "dist/main.js"]
```

```bash
# BuildKit으로 빌드
DOCKER_BUILDKIT=1 docker build -t myapp:latest .

# 빌드 속도 비교
# BuildKit 없이: 300초
# BuildKit 사용: 60초 (5배 빠름)
```

### 8.2 네트워크 최적화

```yaml
# Service Mesh (Istio) 없이 서비스 간 통신 최적화
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  type: ClusterIP
  clusterIP: None  # Headless Service
  selector:
    app: user-service
  ports:
  - port: 8080

# 장점:
# - DNS로 직접 Pod IP 반환
# - 로드 밸런서 오버헤드 없음
# - 빠른 서비스 디스커버리
```

### 8.3 스토리지 최적화

```yaml
# 로컬 SSD 사용 (높은 IOPS)
apiVersion: v1
kind: PersistentVolume
metadata:
  name: local-ssd
spec:
  capacity:
    storage: 100Gi
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd0
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node1
```

---

## 9. 트러블슈팅 가이드

### 9.1 일반적인 문제와 해결

```bash
# 문제 1: Pod가 Pending 상태
kubectl describe pod <pod-name>
# 확인: 리소스 부족, PV 바인딩 실패, 노드 선택 문제

# 해결:
# - 노드 리소스 확인: kubectl top nodes
# - PV 확인: kubectl get pv
# - 이벤트 확인: kubectl get events


# 문제 2: Pod가 CrashLoopBackOff
kubectl logs <pod-name> --previous
# 확인: 애플리케이션 에러, 설정 오류, 헬스체크 실패

# 해결:
# - 로그 확인
# - 환경 변수 확인
# - 헬스체크 설정 확인


# 문제 3: 이미지 Pull 실패
kubectl describe pod <pod-name>
# ErrImagePull, ImagePullBackOff

# 해결:
# - 이미지 이름 확인
# - 레지스트리 인증 확인
# - imagePullSecrets 설정


# 문제 4: 네트워크 연결 실패
# 디버그 Pod 실행
kubectl run -it --rm debug --image=nicolaka/netshoot --restart=Never -- bash
# nslookup <service-name>
# ping <service-name>
# curl http://<service-name>:<port>
```

### 9.2 디버깅 도구

```bash
# 1. kubectl debug (Kubernetes 1.23+)
kubectl debug <pod-name> -it --image=busybox --target=<container-name>

# 2. 로그 실시간 확인
kubectl logs -f <pod-name>

# 3. 여러 Pod 로그 동시 확인
kubectl logs -l app=user-service -f --all-containers=true

# 4. 이벤트 모니터링
kubectl get events -w

# 5. 리소스 사용량
kubectl top pods --containers
```

---

## 10. 도구 추천

### 10.1 필수 도구

```bash
# CLI 도구
1. kubectl - Kubernetes CLI
2. docker - Docker CLI
3. k9s - Kubernetes TUI (텍스트 UI)
4. stern - 여러 Pod 로그 동시 확인
5. kubectx/kubens - 컨텍스트/네임스페이스 빠른 전환

# 설치
brew install k9s stern kubectx

# 사용
k9s  # 실행
stern -n lk-trade user-service  # 로그 확인
kubectx  # 컨텍스트 목록
kubens lk-trade  # 네임스페이스 전환
```

### 10.2 GUI 도구

```bash
# 1. Lens - Kubernetes IDE
https://k8slens.dev/

# 2. Portainer - Docker/Kubernetes 웹 UI
docker run -d -p 9000:9000 \
  -v /var/run/docker.sock:/var/run/docker.sock \
  portainer/portainer-ce

# 3. Kubernetes Dashboard
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml
kubectl proxy
# http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
```

---

## 마무리

축하합니다! 🎉 Docker의 고급 주제와 모범 사례를 모두 마스터했습니다.

### 이번 섹션에서 배운 것

✅ 이미지 최적화 (멀티 스테이지, 캐싱, .dockerignore)
✅ 컨테이너 디자인 패턴 (Sidecar, Ambassador, Adapter)
✅ 헬스체크 및 그레이스풀 셧다운
✅ 리소스 관리 모범 사례
✅ 보안 체크리스트
✅ 모니터링 및 로깅 전략
✅ 프로덕션 체크리스트
✅ 성능 최적화
✅ 트러블슈팅 가이드
✅ 유용한 도구

### 다음 섹션

이제 Docker의 전반적인 내용을 모두 학습했습니다! 🎓

**섹션 35-44**에서는:
- 실전 예제 및 사례 연구
- 특정 시나리오별 가이드
- 추가 학습 자료
- 커뮤니티 및 리소스
- 마무리

### 계속 학습하기

**공식 문서:**
- [Docker Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Kubernetes Best Practices](https://kubernetes.io/docs/concepts/configuration/overview/)

**책:**
- "Docker Deep Dive" by Nigel Poulton
- "Kubernetes in Action" by Marko Luksa

**커뮤니티:**
- [Docker Community](https://www.docker.com/community/)
- [CNCF Slack](https://slack.cncf.io/)

---

**Docker 마스터가 되신 것을 축하합니다!** 🚀