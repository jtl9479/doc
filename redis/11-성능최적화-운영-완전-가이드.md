# Redis 성능 최적화 및 운영 완전 가이드

> **학습 목표**: Redis 서버를 실무 환경에서 모니터링하고, 성능을 최적화하며, 안정적으로 운영할 수 있는 실전 능력 습득

**⏱️ 예상 학습 시간**: 4-5시간
**난이도**: ⭐⭐⭐⭐☆ (4개/5개)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [핵심 개념](#핵심-개념)
- [성능 모니터링](#성능-모니터링)
- [메모리 최적화](#메모리-최적화)
- [네트워크 최적화](#네트워크-최적화)
- [백업 및 복구](#백업-및-복구)
- [주니어 시나리오](#주니어-시나리오)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경
**캐시 서버가 느려지거나 멈추면 전체 서비스가 마비됩니다**

#### ❌ Redis 성능 최적화를 모르면 발생하는 문제
```
문제 1: 메모리 부족으로 서비스 중단
- 증상: OOM(Out of Memory) 발생, Redis 강제 종료
- 영향: 전체 서비스 응답 시간 10배 이상 증가
- 비용: 시간당 $10,000 이상 매출 손실

문제 2: 느린 쿼리로 전체 시스템 지연
- 증상: KEYS * 같은 블로킹 명령으로 서버 먹통
- 영향: 모든 사용자 요청이 타임아웃
- 비용: 고객 이탈, 평판 손실

문제 3: 데이터 손실
- 증상: 백업 없이 서버 장애 발생
- 영향: 세션, 캐시 데이터 전체 유실
- 비용: 복구 불가능한 데이터 손실
```

#### ✅ Redis 성능 최적화를 적용하면
```
해결책 1: 실시간 모니터링으로 장애 예방
- 방법: 메모리, CPU, 네트워크 지표 실시간 추적
- 효과: 장애 발생 전 95% 사전 감지
- 절감: 연간 장애 복구 비용 $50,000 절감

해결책 2: 자동화된 성능 튜닝
- 방법: 메모리 압축, 슬로우 쿼리 자동 탐지
- 효과: 응답 시간 50% 단축, 처리량 2배 증가
- 절감: 서버 증설 비용 30% 절감

해결책 3: 안정적인 백업 및 복구
- 방법: 자동 백업, Point-in-Time 복구
- 효과: 99.99% 데이터 보존율
- 절감: 데이터 손실로 인한 비즈니스 리스크 제거
```

### 📊 수치로 보는 효과

| 지표 | 최적화 전 | 최적화 후 | 개선율 |
|------|-----------|-----------|--------|
| 평균 응답 시간 | 100ms | 2ms | **98%↓** |
| 메모리 사용량 | 8GB | 3GB | **62%↓** |
| 처리량 (ops/sec) | 10,000 | 50,000 | **400%↑** |
| 캐시 히트율 | 75% | 95% | **27%↑** |
| 서버 비용 | $2,000/월 | $800/월 | **60%↓** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 고속도로 톨게이트 시스템

```
Redis 성능 모니터링 = 고속도로 교통 관제 센터

- 메모리 사용량 = 톨게이트 차량 대기 수
- CPU 사용률 = 톨게이트 직원 바쁜 정도
- 처리량(ops/sec) = 시간당 통과 차량 수
- 슬로우 쿼리 = 특정 차량이 톨게이트를 막고 있는 상황

┌─────────────────────────────────────┐
│    🚗🚗🚗 → [톨게이트] → 🚗🚗        │
│                                     │
│  ⚠️ 대기 차량 많음 = 메모리 부족    │
│  ⚠️ 한 차량이 막음 = 슬로우 쿼리    │
│  ✅ 관제센터 = 모니터링 시스템       │
└─────────────────────────────────────┘

관제센터가 실시간으로 교통 흐름을 모니터링하듯,
Redis 모니터링으로 서버 상태를 실시간 추적합니다.
```

### 비유 2: 편의점 재고 관리

```
Redis 메모리 최적화 = 편의점 진열대 효율적 배치

- 자주 팔리는 상품 = Hot Key (앞쪽 진열)
- 안 팔리는 상품 = Cold Key (뒤쪽 또는 제거)
- 진열대 공간 = 메모리 용량
- 상품 압축 포장 = 데이터 압축

🏪 편의점 진열대:
┌────────────────────────┐
│ 🥤🥤🥤 (자주 팔림)      │ ← HOT DATA (빠른 접근)
│ 🍫🍫                   │ ← WARM DATA
│ 📦📦                   │ ← COLD DATA (제거 대상)
└────────────────────────┘

진열대 공간이 부족하면 안 팔리는 상품을 치우듯,
메모리가 부족하면 Cold Key를 삭제합니다 (Eviction).
```

### 비유 3: 병원 응급실 트리아지

```
Redis 슬로우 쿼리 분석 = 응급실 환자 우선순위 분류

- 빠른 쿼리 (GET, SET) = 경증 환자 (빠른 처리)
- 느린 쿼리 (KEYS *, FLUSHALL) = 중증 환자 (긴 처리 시간)
- 쿼리 대기열 = 대기 환자
- 슬로우 로그 = 중증 환자 기록

🏥 응급실:
┌─────────────────────────────────┐
│ [경증] → 5분 → ✅               │
│ [경증] → 5분 → ✅               │
│ [중증] → 60분 → ⏳ (전체 지연) │
└─────────────────────────────────┘

한 명의 중증 환자가 모든 의료진을 묶어두면,
경증 환자들이 대기하듯이,
하나의 슬로우 쿼리가 전체 서버를 느리게 만듭니다.
```

### 비유 4: 스마트폰 배터리 관리

```
Redis 백업 및 복구 = 스마트폰 클라우드 자동 백업

- RDB 백업 = 전체 사진 백업 (스냅샷)
- AOF 백업 = 매 순간 변경사항 백업 (증분)
- 백업 주기 = 자동 백업 주기
- 복구 = 새 폰에 백업 복원

📱 백업 전략:
┌────────────────────────────────┐
│ 스냅샷 (주 1회)                │ ← RDB (빠름, 일부 손실)
│   📸 → 💾                      │
│                                │
│ 실시간 동기화 (매 동작)        │ ← AOF (느림, 손실 없음)
│   📝 → ☁️                      │
└────────────────────────────────┘

스마트폰 데이터가 날아가도 백업으로 복구하듯,
Redis 서버 장애 시 백업으로 복구합니다.
```

### 비유 5: 아파트 관리사무소

```
Redis 운영 자동화 = 아파트 24시간 관리 시스템

- 헬스체크 = 경비실 순찰
- 자동 알림 = 화재 경보기
- 메모리 정리 = 쓰레기 수거
- 성능 튜닝 = 공용시설 유지보수

🏢 아파트 관리:
┌─────────────────────────────────┐
│ 🚨 화재 감지 → 자동 알림        │
│ 🚮 쓰레기 자동 수거             │
│ 🔧 엘리베이터 정기 점검         │
│ 📊 전기/수도 사용량 모니터링    │
└─────────────────────────────────┘

관리사무소가 아파트를 24시간 관리하듯,
자동화 스크립트가 Redis를 24시간 모니터링합니다.
```

### 🎯 종합 비교표
```
┌──────────────┬──────────────┬──────────────┬──────────────┐
│ Redis 개념   │ 비유1(톨게이트)│ 비유2(편의점)│ 비유3(응급실)│
├──────────────┼──────────────┼──────────────┼──────────────┤
│ 모니터링     │ 관제센터     │ 재고 확인    │ 환자 상태체크│
│ 메모리 최적화│ 차선 추가    │ 진열 정리    │ 병상 확보    │
│ 슬로우 쿼리  │ 정체 차량    │ 느린 계산대  │ 중증 환자    │
│ 백업         │ CCTV 녹화    │ 장부 기록    │ 의무 기록    │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

---

## 📖 핵심 개념

### 개념 설명 (3단계 깊이)

#### 1️⃣ 초보자 수준 설명
**Redis 성능 모니터링은 서버의 건강 상태를 확인하는 것**

자동차의 계기판을 보듯이, Redis 서버의 상태를 숫자로 확인합니다:
- 메모리: 현재 얼마나 사용 중인가?
- 속도: 초당 몇 개의 요청을 처리하는가?
- 히트율: 캐시에서 데이터를 찾는 성공률은?

#### 2️⃣ 중급자 수준 설명
**Redis 성능은 메모리, CPU, 네트워크의 균형**

핵심 모니터링 지표:
- **used_memory**: 실제 데이터가 차지하는 메모리
- **mem_fragmentation_ratio**: 메모리 단편화 비율 (1.5 이하 권장)
- **instantaneous_ops_per_sec**: 초당 처리하는 명령 수
- **keyspace_hit_rate**: 캐시 히트율 (80% 이상 권장)

최적화 전략:
- 메모리 압축으로 용량 절약
- 슬로우 쿼리 제거로 응답 시간 단축
- 연결 풀 최적화로 네트워크 효율 증대

#### 3️⃣ 고급자 수준 설명
**내부 메모리 구조와 이벤트 루프 최적화**

Redis의 싱글 스레드 아키텍처:
- 모든 명령은 순차적으로 처리
- 긴 명령 하나가 전체를 블로킹
- I/O 멀티플렉싱으로 동시 연결 처리

메모리 최적화 기법:
- **Ziplist**: 작은 Hash/List를 압축 (메모리 50% 절약)
- **Intset**: 정수 Set을 압축
- **Jemalloc**: 메모리 할당자 최적화

### 주요 용어 정리

| 용어 | 영문 | 설명 | 예시 |
|------|------|------|------|
| 히트율 | Hit Rate | 캐시에서 데이터를 찾는 성공률 | 95% = 100번 중 95번 성공 |
| 메모리 단편화 | Memory Fragmentation | 메모리가 조각나서 비효율적인 상태 | 1.5 = 실제의 1.5배 메모리 사용 |
| 슬로우 쿼리 | Slow Query | 실행 시간이 긴 명령 | KEYS * (100만 키 검색) |
| 축출 정책 | Eviction Policy | 메모리 부족 시 삭제 규칙 | LRU = 가장 오래된 것 삭제 |
| 지연 쓰기 | Lazy Free | 삭제를 백그라운드로 처리 | DEL 대신 UNLINK 사용 |

### 기술 아키텍처

```
┌─────────────────────────────────────────────────────────┐
│                  Redis 성능 모니터링 시스템              │
│                                                          │
│  ┌──────────────┐    ┌──────────────┐                  │
│  │ 모니터링     │    │ 알림 시스템  │                  │
│  │ - INFO       │ ──→│ - 메모리 90% │                  │
│  │ - SLOWLOG    │    │ - 슬로우쿼리  │                  │
│  │ - CLIENT     │    │ - 높은 CPU   │                  │
│  └──────────────┘    └──────────────┘                  │
│         ↓                    ↓                          │
│  ┌──────────────────────────────────┐                  │
│  │      Redis Server (싱글스레드)    │                  │
│  │  ┌────────────────────────────┐  │                  │
│  │  │  Command Queue (순차처리)  │  │                  │
│  │  │  GET → SET → GET → KEYS    │  │ ← 슬로우쿼리     │
│  │  └────────────────────────────┘  │                  │
│  │  ┌────────────────────────────┐  │                  │
│  │  │  Memory (메모리 관리)       │  │                  │
│  │  │  [used] [fragmentation]    │  │                  │
│  │  └────────────────────────────┘  │                  │
│  └──────────────────────────────────┘                  │
│         ↓                                               │
│  ┌──────────────┐    ┌──────────────┐                  │
│  │ RDB 백업     │    │ AOF 백업     │                  │
│  │ (스냅샷)     │    │ (로그)       │                  │
│  └──────────────┘    └──────────────┘                  │
└─────────────────────────────────────────────────────────┘

설명:
- 모니터링: INFO, SLOWLOG로 실시간 상태 확인
- 알림: 임계값 초과 시 자동 알림
- 싱글스레드: 모든 명령은 순차 처리 (블로킹 주의)
- 백업: RDB(빠름) + AOF(안전함) 조합
```

---

## 💻 성능 모니터링

### 📋 사전 체크리스트
```bash
# 1. Redis 연결 확인
redis-cli ping
# PONG 출력 확인

# 2. Redis 버전 확인
redis-cli INFO server | grep redis_version
# redis_version:7.0.0 이상 권장

# 3. 모니터링 명령어 활성화
redis-cli CONFIG GET slowlog-log-slower-than
# 슬로우 로그 설정 확인
```

### 실습 1: 기본 모니터링
**난이도**: ⭐☆☆☆☆

#### 코드
```bash
# 실시간 성능 지표 확인
redis-cli INFO stats

# 출력:
# instantaneous_ops_per_sec:15234  ← 초당 처리량
# keyspace_hits:1000000            ← 캐시 히트
# keyspace_misses:50000            ← 캐시 미스
```

#### 히트율 계산
```bash
# 캐시 히트율 계산
redis-cli INFO stats | grep keyspace

# 계산: hits / (hits + misses) * 100
# 1000000 / (1000000 + 50000) * 100 = 95.2%
```

#### 코드 설명
- **instantaneous_ops_per_sec**: 현재 초당 처리 중인 명령 수
- **keyspace_hits**: 캐시에서 데이터를 찾은 횟수
- **keyspace_misses**: 캐시에서 찾지 못한 횟수

### 실습 2: 슬로우 쿼리 탐지
**난이도**: ⭐⭐⭐☆☆

#### 설정
```bash
# 슬로우 로그 임계값 설정 (10ms 이상)
redis-cli CONFIG SET slowlog-log-slower-than 10000

# 슬로우 로그 최대 길이
redis-cli CONFIG SET slowlog-max-len 1000
```

#### 슬로우 쿼리 확인
```bash
# 최근 10개 슬로우 쿼리 조회
redis-cli SLOWLOG GET 10

# 출력:
1) 1) (integer) 123                    # 로그 ID
   2) (integer) 1647834022             # 타임스탬프
   3) (integer) 15000                  # 실행 시간 (마이크로초, 15ms)
   4) 1) "KEYS"                        # 명령어
      2) "user:*"                      # 파라미터
   5) "192.168.1.100:45678"            # 클라이언트 IP
```

#### 좋은 예 vs 나쁜 예

**❌ 나쁜 예**
```bash
# KEYS는 전체 키를 스캔 (블로킹 발생)
redis-cli KEYS user:*
```
**문제점**:
- 100만 개 키가 있으면 수 초간 블로킹
- 그동안 모든 다른 요청이 대기
- 프로덕션에서 절대 사용 금지

**✅ 좋은 예**
```bash
# SCAN은 점진적으로 스캔 (논블로킹)
redis-cli --scan --pattern "user:*"

# 또는 프로그램에서
redis-cli SCAN 0 MATCH user:* COUNT 100
```
**장점**:
- 한 번에 100개씩만 스캔
- 다른 요청을 블로킹하지 않음
- 대용량 데이터에서도 안전

---

## 💾 메모리 최적화

### 실습 3: 메모리 사용량 분석
**난이도**: ⭐⭐⭐☆☆

#### 코드
```bash
# 메모리 상세 정보 확인
redis-cli INFO memory

# 출력:
# used_memory:1024000000           # 사용 중 메모리 (1GB)
# used_memory_peak:2048000000      # 최대 메모리 (2GB)
# mem_fragmentation_ratio:1.25     # 단편화 비율
# maxmemory:4294967296             # 최대 메모리 제한 (4GB)
```

#### 메모리 압축 설정
```bash
# Hash 압축 설정
redis-cli CONFIG SET hash-max-ziplist-entries 512
redis-cli CONFIG SET hash-max-ziplist-value 64

# List 압축 설정
redis-cli CONFIG SET list-max-ziplist-size -2  # 8KB 이하
redis-cli CONFIG SET list-compress-depth 2     # 양 끝 2개 노드는 압축 안함
```

#### 코드 설명
- **hash-max-ziplist-entries**: Hash가 512개 필드 이하면 ziplist로 압축
- **list-max-ziplist-size**: List가 8KB 이하면 압축
- 압축 시 **메모리 50% 절약** 가능

### 실습 4: 메모리 축출 정책 설정
**난이도**: ⭐⭐☆☆☆

#### 코드
```bash
# 메모리 최대 용량 설정
redis-cli CONFIG SET maxmemory 2gb

# LRU (Least Recently Used) 정책 설정
redis-cli CONFIG SET maxmemory-policy allkeys-lru
```

#### 주요 정책 비교

| 정책 | 설명 | 사용 시기 |
|------|------|-----------|
| noeviction | 삭제 안함 (에러 반환) | 모든 데이터가 중요할 때 |
| allkeys-lru | 가장 오래된 키 삭제 | 일반 캐시 |
| allkeys-lfu | 가장 적게 사용된 키 삭제 | 핫키 보호 |
| volatile-ttl | TTL이 짧은 키 삭제 | TTL이 있는 키만 삭제 |

---

## 🌐 네트워크 최적화

### 실습 5: 연결 풀 설정
**난이도**: ⭐⭐⭐☆☆

#### 코드
```bash
# 최대 클라이언트 연결 수
redis-cli CONFIG SET maxclients 10000

# 유휴 연결 타임아웃 (300초)
redis-cli CONFIG SET timeout 300

# TCP keepalive (60초)
redis-cli CONFIG SET tcp-keepalive 60
```

#### 연결 상태 확인
```bash
# 현재 연결된 클라이언트 확인
redis-cli CLIENT LIST

# 출력:
id=12345 addr=192.168.1.100:45678 age=120 idle=5 flags=N
id=12346 addr=192.168.1.101:45679 age=60 idle=30 flags=N
```

---

## 💾 백업 및 복구

### 실습 6: RDB 백업
**난이도**: ⭐⭐☆☆☆

#### 수동 백업
```bash
# 백그라운드 저장 (논블로킹)
redis-cli BGSAVE

# 동기 저장 (블로킹, 운영에서 비권장)
redis-cli SAVE
```

#### 자동 백업 설정
```bash
# redis.conf 설정
# 900초(15분) 동안 1개 이상 변경 시 저장
save 900 1

# 300초(5분) 동안 10개 이상 변경 시 저장
save 300 10

# 60초(1분) 동안 10000개 이상 변경 시 저장
save 60 10000
```

### 실습 7: AOF 백업
**난이도**: ⭐⭐⭐☆☆

#### 설정
```bash
# AOF 활성화
redis-cli CONFIG SET appendonly yes

# AOF 동기화 정책 (매 초)
redis-cli CONFIG SET appendfsync everysec
```

#### AOF vs RDB 비교

| 특징 | RDB | AOF |
|------|-----|-----|
| 백업 방식 | 스냅샷 | 로그 |
| 데이터 손실 | 최대 수 분 | 최대 1초 |
| 파일 크기 | 작음 | 큼 |
| 복구 속도 | 빠름 | 느림 |
| 사용 시기 | 빠른 복구 | 데이터 무손실 |

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: KEYS 명령으로 서비스 다운

**상황**: 주니어 개발자가 프로덕션에서 특정 패턴의 키를 찾기 위해 `KEYS user:*`를 실행했습니다.

```bash
# ❌ 주니어 개발자가 작성한 코드
redis-cli KEYS user:*
```

**문제점**:
- KEYS는 전체 키를 한 번에 스캔 (O(N) 복잡도)
- 100만 개 키가 있으면 3초 이상 블로킹
- 그동안 모든 사용자 요청이 타임아웃
- 실제 사례: 네이버 메인 페이지 3초 다운 (2010년)

**해결책**:
```bash
# ✅ 올바른 코드: SCAN 사용
redis-cli --scan --pattern "user:*" --count 100

# 또는 프로그램에서 점진적 스캔
cursor=0
while [ $cursor != 0 ]; do
  result=$(redis-cli SCAN $cursor MATCH user:* COUNT 100)
  cursor=$(echo $result | awk '{print $1}')
  # 결과 처리...
done
```

**배운 점**:
- 💡 KEYS는 절대 프로덕션에서 사용 금지
- 💡 SCAN은 논블로킹, 점진적 스캔
- 💡 모니터링으로 슬로우 쿼리 사전 탐지

### 시나리오 2: 메모리 부족으로 서버 다운

**상황**: 캐시 데이터가 계속 쌓여서 메모리가 가득 차고 Redis가 OOM으로 종료되었습니다.

```bash
# ❌ 메모리 제한 없이 운영
# redis.conf
# maxmemory 설정 안함
```

**문제점**:
- 메모리 무제한 사용으로 8GB까지 증가
- 시스템 메모리 고갈로 Redis 프로세스 강제 종료
- 전체 세션 데이터 유실

**해결책**:
```bash
# ✅ 올바른 설정
redis-cli CONFIG SET maxmemory 2gb
redis-cli CONFIG SET maxmemory-policy allkeys-lru

# TTL 설정으로 자동 삭제
redis-cli SET session:12345 "data" EX 3600  # 1시간 후 삭제
```

**배운 점**:
- 💡 반드시 maxmemory 설정
- 💡 적절한 축출 정책 선택 (LRU 권장)
- 💡 TTL 설정으로 자동 정리

### 시나리오 3: 백업 없이 데이터 유실

**상황**: 서버 장애로 Redis가 재시작되었는데, 백업이 없어서 모든 세션이 날아갔습니다.

```bash
# ❌ 백업 설정 안함
# redis.conf
save ""         # RDB 비활성화
appendonly no   # AOF 비활성화
```

**문제점**:
- 백업이 없어서 재시작 시 모든 데이터 유실
- 100만 사용자 강제 로그아웃
- 고객 불만 폭주

**해결책**:
```bash
# ✅ 올바른 백업 설정
# redis.conf
save 900 1       # 15분마다 백업
appendonly yes   # AOF 활성화
appendfsync everysec  # 매초 동기화

# 백업 파일 확인
ls -lh /var/lib/redis/
# -rw-r--r-- 1 redis redis 512M dump.rdb
# -rw-r--r-- 1 redis redis 2.1G appendonly.aof
```

**배운 점**:
- 💡 RDB + AOF 조합 사용
- 💡 정기적으로 백업 파일 확인
- 💡 복구 절차 사전 테스트

### 시나리오 4: 메모리 단편화로 성능 저하

**상황**: 메모리 사용량은 50%인데, 실제 메모리는 80% 사용 중입니다.

```bash
# 메모리 상태 확인
redis-cli INFO memory

# used_memory:2147483648        # 2GB
# used_memory_rss:3435973836    # 3.2GB
# mem_fragmentation_ratio:1.6   # 1.6배 낭비
```

**문제점**:
- 메모리 단편화로 실제 사용량의 1.6배 메모리 소비
- 같은 데이터를 저장하는데 더 많은 메모리 필요
- 메모리 부족으로 성능 저하

**해결책**:
```bash
# ✅ Redis 4.0 이상: Active Defragmentation
redis-cli CONFIG SET activedefrag yes

# 또는 재시작 (메모리 정리)
redis-cli SHUTDOWN SAVE
systemctl start redis
```

**배운 점**:
- 💡 mem_fragmentation_ratio는 1.0~1.5가 이상적
- 💡 1.5 이상이면 메모리 조각 모음 필요
- 💡 정기적인 메모리 모니터링 필수

---

## ❓ FAQ

<details>
<summary><strong>Q1: Redis 메모리 사용량이 계속 증가하는데, 어떻게 해야 하나요?</strong></summary>

**A**: maxmemory 설정과 축출 정책을 적용하세요.

**상세 설명**:
- 포인트 1: maxmemory로 최대 메모리 제한
- 포인트 2: allkeys-lru로 오래된 키 자동 삭제
- 포인트 3: TTL 설정으로 자동 만료

**예시**:
```bash
# 최대 메모리 2GB 설정
redis-cli CONFIG SET maxmemory 2gb

# LRU 정책 설정
redis-cli CONFIG SET maxmemory-policy allkeys-lru

# 키 생성 시 TTL 설정
redis-cli SETEX session:123 3600 "data"  # 1시간 후 삭제
```

**실무 팁**:
💡 메모리 사용량을 70% 이하로 유지하면 안정적입니다. 80%가 넘으면 알림을 받도록 설정하세요.

</details>

<details>
<summary><strong>Q2: 캐시 히트율이 낮습니다. 어떻게 개선하나요?</strong></summary>

**A**: TTL을 늘리고, 자주 사용하는 데이터만 캐싱하세요.

**상세 설명**:
- 포인트 1: TTL이 너무 짧으면 데이터가 자주 삭제됨
- 포인트 2: 핫키(자주 사용)와 콜드키(드물게 사용) 구분
- 포인트 3: 캐시 워밍으로 사전 로드

**예시**:
```bash
# TTL을 1시간에서 6시간으로 연장
# Before
redis-cli SETEX product:123 3600 "data"

# After
redis-cli SETEX product:123 21600 "data"  # 6시간

# 자주 사용하는 데이터 미리 로드 (캐시 워밍)
for id in 1 2 3 4 5; do
  redis-cli SET popular:product:$id "data"
done
```

**실무 팁**:
💡 히트율 80% 이상이 목표입니다. 95% 이상이면 매우 좋은 상태입니다.

</details>

<details>
<summary><strong>Q3: BGSAVE와 SAVE의 차이는 무엇인가요?</strong></summary>

**A**: BGSAVE는 백그라운드, SAVE는 포그라운드 저장입니다.

**상세 설명**:
- BGSAVE: 자식 프로세스가 백그라운드에서 저장 (논블로킹)
- SAVE: 메인 프로세스가 직접 저장 (블로킹, 모든 요청 대기)
- 프로덕션에서는 항상 BGSAVE 사용

**예시**:
```bash
# ❌ SAVE: 블로킹 (운영 금지)
redis-cli SAVE
# 저장 중 모든 요청이 멈춤

# ✅ BGSAVE: 논블로킹 (운영 권장)
redis-cli BGSAVE
# Background saving started

# 진행 상황 확인
redis-cli LASTSAVE
```

**실무 팁**:
💡 BGSAVE는 fork()로 자식 프로세스를 생성하므로, 메모리가 충분해야 합니다 (최소 2배).

</details>

<details>
<summary><strong>Q4: AOF와 RDB 중 어떤 것을 사용해야 하나요?</strong></summary>

**A**: 둘 다 함께 사용하는 것이 가장 안전합니다.

**비교**:

| 특징 | RDB | AOF | RDB+AOF |
|------|-----|-----|---------|
| 데이터 손실 | 최대 수 분 | 최대 1초 | 최대 1초 |
| 파일 크기 | 작음 | 큼 | 둘 다 |
| 복구 속도 | 빠름 | 느림 | RDB로 빠른 복구 |
| 사용 시기 | 빠른 복구 | 데이터 무손실 | **프로덕션 권장** |

**예시**:
```bash
# 둘 다 활성화
redis-cli CONFIG SET save "900 1 300 10 60 10000"
redis-cli CONFIG SET appendonly yes
redis-cli CONFIG SET appendfsync everysec
```

**실무 팁**:
💡 금융권은 AOF 필수, 일반 웹서비스는 RDB만으로도 충분할 수 있습니다.

</details>

<details>
<summary><strong>Q5: Redis가 갑자기 느려졌습니다. 어떻게 디버깅하나요?</strong></summary>

**A**: 슬로우 로그를 확인하고, 모니터링 지표를 체크하세요.

**디버깅 순서**:
1. 슬로우 로그 확인
2. 메모리 사용량 확인
3. CPU 사용률 확인
4. 네트워크 상태 확인

**예시**:
```bash
# 1. 슬로우 로그 확인
redis-cli SLOWLOG GET 10
# KEYS, FLUSHALL 같은 명령 찾기

# 2. 메모리 확인
redis-cli INFO memory | grep used_memory
# 메모리 부족 확인

# 3. CPU 확인
redis-cli INFO cpu
# cpu_sys, cpu_user 확인

# 4. 현재 실행 중인 명령 확인
redis-cli CLIENT LIST | grep cmd
```

**실무 팁**:
💡 대부분의 성능 문제는 슬로우 쿼리가 원인입니다. KEYS, FLUSHALL, SMEMBERS를 찾아 제거하세요.

</details>

<details>
<summary><strong>Q6: 메모리 단편화(fragmentation)란 무엇이고 어떻게 해결하나요?</strong></summary>

**A**: 메모리가 조각나서 비효율적인 상태를 말하며, Active Defragmentation으로 해결합니다.

**상세 설명**:
- 메모리 할당/해제가 반복되면 조각 발생
- mem_fragmentation_ratio가 1.5 이상이면 문제
- Redis 4.0+ 에서 자동 조각 모음 지원

**예시**:
```bash
# 단편화 확인
redis-cli INFO memory | grep mem_fragmentation_ratio
# mem_fragmentation_ratio:1.8  ← 문제!

# Active Defragmentation 활성화
redis-cli CONFIG SET activedefrag yes

# 또는 재시작으로 해결
redis-cli SHUTDOWN SAVE
systemctl start redis
```

**실무 팁**:
💡 1.0~1.5가 정상, 1.5~2.0이면 주의, 2.0 이상이면 즉시 조치가 필요합니다.

</details>

<details>
<summary><strong>Q7: Redis Cluster와 Sentinel의 차이는 무엇인가요?</strong></summary>

**A**: Cluster는 데이터 분산, Sentinel은 HA(고가용성)를 위한 구조입니다.

**비교**:

| 특징 | Sentinel | Cluster |
|------|----------|---------|
| 목적 | 고가용성 (HA) | 데이터 분산 + HA |
| 데이터 분산 | 없음 (마스터 1대) | 있음 (16384 슬롯) |
| 자동 페일오버 | 있음 | 있음 |
| 사용 시기 | 단일 서버로 충분 | 대용량 데이터 |

**예시**:
```bash
# Sentinel: Master 1대 + Slave 2대 + Sentinel 3대
# 데이터는 모두 Master에 저장

# Cluster: 마스터 3대 (각각 데이터 1/3 보유)
# 16384 슬롯을 3대가 나눠 가짐
```

**실무 팁**:
💡 데이터가 10GB 이하면 Sentinel, 100GB 이상이면 Cluster를 권장합니다.

</details>

<details>
<summary><strong>Q8: Redis 서버 재시작 없이 설정을 변경할 수 있나요?</strong></summary>

**A**: CONFIG SET 명령으로 대부분의 설정을 즉시 변경할 수 있습니다.

**상세 설명**:
- 대부분의 설정은 CONFIG SET으로 즉시 변경 가능
- 변경 사항은 redis.conf에는 자동 저장 안됨
- CONFIG REWRITE로 설정 파일에 영구 저장

**예시**:
```bash
# 메모리 설정 변경 (즉시 적용)
redis-cli CONFIG SET maxmemory 2gb

# 설정 파일에 영구 저장
redis-cli CONFIG REWRITE

# 현재 설정 확인
redis-cli CONFIG GET maxmemory
```

**실무 팁**:
💡 프로덕션 환경에서는 CONFIG SET으로 테스트 후, CONFIG REWRITE로 영구 저장하세요.

</details>

<details>
<summary><strong>Q9: 메모리 사용량을 줄이는 가장 효과적인 방법은?</strong></summary>

**A**: TTL 설정, 압축 활성화, 불필요한 데이터 삭제를 조합합니다.

**상세 설명**:
- TTL 설정: 자동으로 만료되어 메모리 확보
- 압축 설정: ziplist, intset으로 50% 메모리 절약
- 데이터 정리: 오래된 키를 주기적으로 삭제

**예시**:
```bash
# 1. 모든 키에 TTL 설정 (1시간)
redis-cli SET session:123 "data" EX 3600

# 2. 압축 설정 활성화
redis-cli CONFIG SET hash-max-ziplist-entries 512
redis-cli CONFIG SET hash-max-ziplist-value 64

# 3. 축출 정책 설정
redis-cli CONFIG SET maxmemory-policy allkeys-lru

# 효과: 메모리 사용량 50-70% 감소
```

**실무 팁**:
💡 세션 데이터는 TTL, 캐시는 LRU 축출, 대용량 구조는 압축을 모두 적용하세요.

</details>

<details>
<summary><strong>Q10: 프로덕션 환경에서 절대 사용하면 안 되는 명령은?</strong></summary>

**A**: KEYS, FLUSHALL, FLUSHDB 등 전체를 스캔하거나 삭제하는 명령은 금지입니다.

**위험 명령 목록**:

| 명령 | 위험도 | 이유 | 대안 |
|------|--------|------|------|
| KEYS * | ⚠️⚠️⚠️ | 전체 스캔 블로킹 | SCAN |
| FLUSHALL | ⚠️⚠️⚠️ | 전체 데이터 삭제 | - |
| SMEMBERS | ⚠️⚠️ | 대용량 Set 블로킹 | SSCAN |
| HGETALL | ⚠️⚠️ | 대용량 Hash 블로킹 | HSCAN |

**예시**:
```bash
# ❌ 절대 금지
redis-cli KEYS *
redis-cli FLUSHALL

# ✅ 대안 사용
redis-cli --scan --pattern "*"
redis-cli DEL key1 key2 key3  # 개별 삭제
```

**실무 팁**:
💡 redis.conf에서 위험 명령을 rename-command로 비활성화하는 것을 권장합니다.

```bash
# redis.conf에서 위험 명령 비활성화
rename-command KEYS ""
rename-command FLUSHALL ""
rename-command FLUSHDB ""
```

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용 (5-7개)

<details>
<summary><strong>1. Redis의 성능을 모니터링하는 주요 지표는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 메모리 사용량 (used_memory, maxmemory)
- 캐시 히트율 (keyspace_hits / (hits + misses))
- 처리량 (instantaneous_ops_per_sec)
- 메모리 단편화 (mem_fragmentation_ratio)

**예시 답변**
> "Redis 성능 모니터링의 핵심은 크게 4가지입니다. 첫째, 메모리 사용량을 확인하여 maxmemory에 가까워지면 알림을 받습니다. 둘째, 캐시 히트율이 80% 이상인지 확인합니다. 셋째, 초당 처리량(ops/sec)을 모니터링하여 급격한 변화를 감지합니다. 넷째, 메모리 단편화 비율이 1.5 이하인지 확인합니다. 이 지표들을 INFO 명령어로 실시간 조회할 수 있습니다."

**꼬리 질문**
- Q: 캐시 히트율이 낮다면 어떻게 개선할 수 있나요?
- A: TTL을 늘리거나, 자주 사용하는 데이터만 캐싱하거나, 캐시 워밍으로 미리 로드합니다.

**실무 연관**
- 실제로 Datadog, Grafana 같은 모니터링 도구로 이 지표들을 대시보드에 표시합니다.

</details>

<details>
<summary><strong>2. KEYS 명령어를 프로덕션에서 사용하면 안 되는 이유는?</strong></summary>

**모범 답안 포인트**
- KEYS는 전체 키를 한 번에 스캔 (O(N) 복잡도)
- Redis는 싱글 스레드라서 블로킹 발생
- 100만 키면 수 초간 모든 요청이 대기
- 대안은 SCAN 명령어 (점진적 스캔)

**예시 답변**
> "KEYS는 전체 키를 한 번에 스캔하는 O(N) 연산입니다. Redis는 싱글 스레드로 동작하기 때문에, KEYS 실행 중에는 다른 모든 요청이 블로킹됩니다. 만약 100만 개의 키가 있다면 3초 이상 서버가 먹통이 될 수 있습니다. 대안으로 SCAN을 사용하면 100개씩 점진적으로 스캔하여 다른 요청을 블로킹하지 않습니다."

**꼬리 질문**
- Q: SCAN은 어떻게 사용하나요?
- A: `SCAN 0 MATCH pattern COUNT 100`으로 커서 기반 반복 스캔합니다.

**실무 연관**
- 실제 사례: 네이버 메인 페이지가 KEYS * 명령으로 3초간 다운된 적이 있습니다 (2010년).

</details>

<details>
<summary><strong>3. Redis의 메모리 축출 정책(Eviction Policy)은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 메모리가 maxmemory에 도달했을 때 어떤 키를 삭제할지 정하는 규칙
- noeviction: 삭제 안함 (에러 반환)
- allkeys-lru: 모든 키 중 가장 오래된 것 삭제
- volatile-ttl: TTL이 있는 키 중 가장 짧은 것 삭제

**예시 답변**
> "메모리 축출 정책은 Redis가 maxmemory에 도달했을 때 어떤 키를 삭제할지 정하는 규칙입니다. 가장 많이 사용하는 정책은 allkeys-lru로, LRU(Least Recently Used) 알고리즘으로 가장 오래전에 사용된 키를 삭제합니다. 또한 volatile-ttl은 TTL이 설정된 키 중 가장 짧은 것을 먼저 삭제합니다. 캐시 용도로는 allkeys-lru를 권장합니다."

**꼬리 질문**
- Q: LRU와 LFU의 차이는?
- A: LRU는 최근 사용 시간, LFU는 사용 빈도를 기준으로 삭제합니다.

**실무 연관**
- 캐시 서버에는 allkeys-lru, 세션 서버에는 volatile-ttl을 주로 사용합니다.

</details>

<details>
<summary><strong>4. RDB와 AOF 백업의 차이점은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- RDB: 특정 시점의 스냅샷 (빠름, 일부 손실)
- AOF: 모든 쓰기 명령을 로그로 저장 (느림, 무손실)
- RDB는 파일이 작고 복구가 빠름
- AOF는 데이터 손실이 적지만 파일이 큼

**예시 답변**
> "RDB는 특정 시점의 전체 데이터를 스냅샷으로 저장하는 방식으로, 파일 크기가 작고 복구가 빠릅니다. 하지만 마지막 백업 이후의 데이터는 손실될 수 있습니다. 반면 AOF는 모든 쓰기 명령을 로그로 기록하여 최대 1초의 데이터만 손실될 수 있지만, 파일이 크고 복구가 느립니다. 프로덕션에서는 RDB와 AOF를 모두 활성화하는 것이 안전합니다."

**꼬리 질문**
- Q: 금융권 서비스에서는 어떤 방식을 사용해야 하나요?
- A: 데이터 무손실이 중요하므로 AOF를 반드시 활성화해야 합니다.

**실무 연관**
- 은행, 결제 시스템에서는 AOF 필수, 일반 웹 캐시는 RDB만으로도 충분합니다.

</details>

<details>
<summary><strong>5. 슬로우 쿼리(Slow Query)를 찾는 방법은?</strong></summary>

**모범 답안 포인트**
- SLOWLOG 명령어로 느린 쿼리 조회
- slowlog-log-slower-than으로 임계값 설정 (마이크로초)
- SLOWLOG GET 10으로 최근 10개 조회
- 실행 시간, 명령어, 파라미터 확인

**예시 답변**
> "Redis는 SLOWLOG 명령어로 느린 쿼리를 추적할 수 있습니다. 먼저 CONFIG SET slowlog-log-slower-than 10000으로 10ms 이상 걸리는 쿼리를 로그에 기록하도록 설정합니다. 그런 다음 SLOWLOG GET 10으로 최근 10개의 느린 쿼리를 조회하여 KEYS, FLUSHALL 같은 위험한 명령을 찾아냅니다."

**꼬리 질문**
- Q: 슬로우 쿼리를 발견하면 어떻게 해야 하나요?
- A: KEYS는 SCAN으로, SMEMBERS는 SSCAN으로 대체하고, 대용량 데이터는 작게 나눕니다.

**실무 연관**
- 운영팀은 슬로우 로그를 주기적으로 확인하여 성능 이슈를 사전에 방지합니다.

</details>

<details>
<summary><strong>6. 메모리 단편화(Memory Fragmentation)란 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 메모리 할당/해제가 반복되면서 조각이 생기는 현상
- mem_fragmentation_ratio로 측정 (실제 메모리 / 사용 메모리)
- 1.0~1.5가 정상, 1.5 이상이면 비효율적
- Active Defragmentation으로 해결

**예시 답변**
> "메모리 단편화는 Redis가 키를 생성하고 삭제하는 과정에서 메모리가 조각나는 현상입니다. mem_fragmentation_ratio 값이 1.6이면 실제로는 1.6배의 메모리를 사용하는 것입니다. 1.5 이상이면 문제가 있는 상태로, Redis 4.0 이상에서는 activedefrag yes로 자동 조각 모음을 활성화할 수 있습니다."

**꼬리 질문**
- Q: mem_fragmentation_ratio가 0.8이면 어떤 의미인가요?
- A: 스왑 메모리를 사용하고 있어서 매우 위험한 상태입니다.

**실무 연관**
- 장기 운영 서버는 단편화가 심해지므로 정기적으로 재시작하거나 Active Defragmentation을 사용합니다.

</details>

<details>
<summary><strong>7. Redis 성능 최적화를 위한 베스트 프랙티스는?</strong></summary>

**모범 답안 포인트**
- 작은 데이터 구조 사용 (Hash ziplist 압축)
- TTL 설정으로 자동 정리
- 파이프라이닝으로 네트워크 왕복 최소화
- 슬로우 쿼리 제거 (KEYS → SCAN)
- 모니터링 및 알림 설정

**예시 답변**
> "Redis 성능 최적화는 크게 5가지입니다. 첫째, Hash가 512개 필드 이하면 ziplist로 압축하여 메모리 50% 절약합니다. 둘째, 모든 키에 TTL을 설정하여 자동 정리합니다. 셋째, 파이프라이닝으로 여러 명령을 한 번에 전송하여 네트워크 왕복을 줄입니다. 넷째, KEYS 같은 블로킹 명령을 SCAN으로 대체합니다. 다섯째, INFO와 SLOWLOG로 실시간 모니터링합니다."

**꼬리 질문**
- Q: 파이프라이닝의 장점은?
- A: 여러 명령을 한 번에 전송하여 네트워크 RTT를 줄이고 처리량을 10배 이상 높일 수 있습니다.

**실무 연관**
- 대규모 서비스에서는 이 모든 최적화를 적용하여 서버 비용을 50% 이상 절감합니다.

</details>

---

### 📗 중급 개발자용 (3-5개)

<details>
<summary><strong>1. Redis의 싱글 스레드 아키텍처에서 어떻게 높은 성능을 낼 수 있나요?</strong></summary>

**모범 답안 포인트**
- I/O 멀티플렉싱 (epoll, kqueue)으로 동시 연결 처리
- 인메모리 데이터 구조로 디스크 I/O 없음
- 최적화된 C 코드와 효율적인 자료구조
- 이벤트 루프 기반 비동기 처리

**예시 답변**
> "Redis는 싱글 스레드지만 I/O 멀티플렉싱 기술로 수천 개의 동시 연결을 처리합니다. epoll이나 kqueue를 사용하여 커널 레벨에서 비동기 I/O를 처리하고, 인메모리 구조로 디스크 I/O가 없어서 매우 빠릅니다. 또한 이벤트 루프 기반으로 블로킹 없이 순차적으로 명령을 처리합니다. 이 구조 덕분에 초당 10만 건 이상의 요청을 처리할 수 있습니다."

**실무 예시**
```c
// Redis 이벤트 루프 개념
while (true) {
  // 모든 소켓을 폴링 (epoll)
  events = epoll_wait(epfd, events, maxevents, timeout);

  for (event in events) {
    if (event.type == READ) {
      // 명령 읽기
      command = read_command(event.fd);
      // 명령 실행
      result = execute_command(command);
      // 결과 전송
      send_result(event.fd, result);
    }
  }
}
```

**꼬리 질문**
- Q: 멀티 스레드로 바꾸면 더 빠르지 않을까요?
- A: 멀티 스레드는 락(Lock) 오버헤드가 크고, Redis는 메모리 연산이라 CPU 바운드가 아니므로 싱글 스레드가 효율적입니다.

**실무 연관**
- Twitter, GitHub 같은 대규모 서비스도 싱글 스레드 Redis로 초당 수십만 건을 처리합니다.

</details>

<details>
<summary><strong>2. Redis의 메모리 압축 기법(Ziplist, Intset)의 원리와 성능 트레이드오프는?</strong></summary>

**모범 답안 포인트**
- Ziplist: 작은 Hash/List를 연속된 메모리에 압축 저장
- Intset: 정수 Set을 배열로 압축
- 메모리는 50% 절약, CPU는 약간 증가
- 임계값 초과 시 일반 구조로 전환

**예시 답변**
> "Redis는 작은 데이터 구조를 압축하여 메모리를 절약합니다. Ziplist는 Hash나 List의 모든 요소를 연속된 메모리 블록에 저장하여 포인터 오버헤드를 없앱니다. Intset은 정수 Set을 정렬된 배열로 저장합니다. Hash가 512개 필드 이하면 ziplist를 사용하여 메모리를 50% 절약할 수 있습니다. 단, 임계값을 초과하면 자동으로 일반 해시 테이블로 전환되어 성능을 유지합니다."

**실무 예시**
```bash
# Hash 압축 설정
CONFIG SET hash-max-ziplist-entries 512  # 512개 이하
CONFIG SET hash-max-ziplist-value 64     # 각 값 64바이트 이하

# 압축 효과 확인
MEMORY USAGE mykey  # 압축 전: 1024 바이트
# ... 압축 후 ...
MEMORY USAGE mykey  # 압축 후: 512 바이트 (50% 절약)
```

**꼬리 질문**
- Q: 임계값을 크게 설정하면 더 많이 절약할 수 있지 않나요?
- A: 네, 하지만 ziplist는 O(N) 탐색이라 너무 크면 느려집니다. 512는 메모리와 성능의 균형점입니다.

**실무 연관**
- Instagram은 ziplist 최적화로 서버 비용을 30% 절감했습니다.

</details>

<details>
<summary><strong>3. Redis Cluster에서 해시 슬롯(Hash Slot) 분산의 원리와 리샤딩 과정은?</strong></summary>

**모범 답안 포인트**
- 16384개의 해시 슬롯을 여러 마스터 노드가 나눠 가짐
- CRC16(key) % 16384로 슬롯 계산
- 리샤딩은 슬롯을 한 노드에서 다른 노드로 이동
- 이동 중에도 서비스 중단 없음 (온라인 마이그레이션)

**예시 답변**
> "Redis Cluster는 16384개의 해시 슬롯을 여러 마스터 노드가 나눠 갖습니다. 키가 들어오면 CRC16 해시 함수로 0~16383 범위의 슬롯을 계산하여 해당 노드에 저장합니다. 예를 들어 3대의 마스터라면 각각 약 5461개씩 슬롯을 담당합니다. 리샤딩 시에는 MIGRATE 명령으로 슬롯의 키들을 다른 노드로 이동하며, 이동 중에도 클라이언트 요청을 처리할 수 있습니다."

**실무 예시**
```bash
# 슬롯 분산 확인
redis-cli CLUSTER NODES
# 노드1: 0-5460 (5461개)
# 노드2: 5461-10922 (5461개)
# 노드3: 10923-16383 (5461개)

# 슬롯 이동 (리샤딩)
redis-cli --cluster reshard 127.0.0.1:7000
# 1000개 슬롯을 노드1에서 노드4로 이동
```

**꼬리 질문**
- Q: 리샤딩 중에 클라이언트가 이동 중인 키에 접근하면?
- A: MOVED 에러를 받아 새 노드로 리다이렉트되며, 클라이언트 라이브러리가 자동으로 재시도합니다.

**실무 연관**
- 대규모 서비스에서 노드 추가 시 무중단으로 리샤딩하여 확장합니다.

</details>

<details>
<summary><strong>4. Copy-on-Write와 BGSAVE의 메모리 오버헤드는 어떻게 최소화하나요?</strong></summary>

**모범 답안 포인트**
- BGSAVE는 fork()로 자식 프로세스 생성
- Copy-on-Write로 부모와 메모리 공유
- 쓰기 발생 시에만 페이지 복사
- 최악의 경우 2배 메모리 필요

**예시 답변**
> "BGSAVE는 fork() 시스템 콜로 자식 프로세스를 생성하여 백그라운드에서 저장합니다. Copy-on-Write 덕분에 처음에는 부모와 메모리를 공유하므로 추가 메모리가 거의 없습니다. 하지만 백업 중에 쓰기가 발생하면 변경된 메모리 페이지만 복사되어 최악의 경우 원본의 2배 메모리가 필요할 수 있습니다. 이를 최소화하려면 maxmemory를 시스템 메모리의 50% 이하로 설정하고, 쓰기가 적은 시간대에 백업합니다."

**실무 예시**
```bash
# 메모리 사용량 확인
INFO memory
# used_memory: 4GB
# 백업 시작
BGSAVE
# 최악의 경우 8GB까지 증가 가능

# 안전한 설정
CONFIG SET maxmemory 2gb  # 시스템 메모리 4GB의 50%
```

**꼬리 질문**
- Q: 메모리가 부족해서 fork()가 실패하면?
- A: BGSAVE가 실패하고 에러를 반환하며, 백업이 생성되지 않습니다.

**실무 연관**
- AWS ElastiCache는 fork() 실패를 방지하기 위해 메모리 여유분을 권장합니다.

</details>

<details>
<summary><strong>5. Redis의 Lazy Free 기능과 성능 영향은?</strong></summary>

**모범 답안 포인트**
- DEL 대신 UNLINK로 백그라운드 삭제
- 대용량 키 삭제 시 블로킹 방지
- lazyfree-lazy-eviction, lazyfree-lazy-expire 설정
- Redis 4.0+ 기능

**예시 답변**
> "Lazy Free는 Redis 4.0부터 추가된 기능으로, 대용량 키를 삭제할 때 블로킹을 방지합니다. DEL은 동기 삭제라서 100만 개 요소의 List를 삭제하면 수 초간 블로킹되지만, UNLINK는 비동기 삭제로 즉시 반환하고 백그라운드 스레드가 삭제합니다. 또한 lazyfree-lazy-eviction yes로 축출 시에도 비동기 삭제를 적용할 수 있습니다."

**실무 예시**
```bash
# 동기 삭제 (블로킹)
DEL biglist  # 100만 개 요소, 3초 블로킹

# 비동기 삭제 (논블로킹)
UNLINK biglist  # 즉시 반환 (0.001초)

# Lazy Free 설정
CONFIG SET lazyfree-lazy-eviction yes
CONFIG SET lazyfree-lazy-expire yes
```

**꼬리 질문**
- Q: 모든 명령을 UNLINK로 바꿔야 하나요?
- A: 아니요, 작은 키는 DEL이 더 효율적입니다. 10,000개 이상의 요소를 가진 키만 UNLINK를 사용하세요.

**실무 연관**
- 대규모 캐시 서버에서 축출 시 Lazy Free를 사용하여 블로킹을 방지합니다.

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 성능 모니터링 | INFO, SLOWLOG로 실시간 상태 확인 | ops/sec, hit rate, memory |
| 메모리 최적화 | 압축, 축출 정책, TTL 설정 | ziplist, LRU, maxmemory |
| 슬로우 쿼리 | KEYS → SCAN, 블로킹 명령 제거 | SLOWLOG, 블로킹 |
| 백업 복구 | RDB + AOF 조합 사용 | BGSAVE, appendonly |
| 메모리 단편화 | Active Defragmentation | fragmentation ratio |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| INFO memory | 메모리 사용량 확인 | `redis-cli INFO memory` |
| SLOWLOG GET | 슬로우 쿼리 조회 | `redis-cli SLOWLOG GET 10` |
| SCAN | 안전한 키 스캔 | `redis-cli SCAN 0 MATCH user:*` |
| CONFIG SET maxmemory | 최대 메모리 설정 | `redis-cli CONFIG SET maxmemory 2gb` |
| BGSAVE | 백그라운드 백업 | `redis-cli BGSAVE` |
| UNLINK | 비동기 삭제 | `redis-cli UNLINK bigkey` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] 모든 키에 TTL 설정 (자동 정리)
- [ ] maxmemory와 축출 정책 설정
- [ ] SCAN 사용 (KEYS 금지)
- [ ] RDB + AOF 백업 활성화
- [ ] 슬로우 로그 정기 확인
- [ ] 메모리 단편화 모니터링 (1.5 이하 유지)
- [ ] 압축 설정 활성화 (ziplist, intset)

#### ❌ 하지 말아야 할 것
- [ ] KEYS * 절대 사용 금지
- [ ] FLUSHALL 프로덕션 금지
- [ ] 백업 없이 운영
- [ ] maxmemory 미설정
- [ ] SMEMBERS, HGETALL 대용량 키에 사용
- [ ] DEL로 대용량 키 삭제 (UNLINK 사용)

### 성능/보안 체크리스트

#### 성능
- [ ] 캐시 히트율 80% 이상
- [ ] 메모리 사용량 70% 이하
- [ ] mem_fragmentation_ratio 1.0~1.5
- [ ] 슬로우 쿼리 없음
- [ ] 압축 설정 최적화

#### 보안
- [ ] requirepass 설정 (비밀번호)
- [ ] bind 127.0.0.1 (외부 접근 차단)
- [ ] protected-mode yes
- [ ] 위험 명령 비활성화 (rename-command)

---

## 🔗 관련 기술

**Redis와 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Grafana | 모니터링 대시보드 | ⭐⭐⭐ |
| Prometheus | 메트릭 수집 | ⭐⭐⭐ |
| Redis Sentinel | 고가용성 (HA) | ⭐⭐ |
| Redis Cluster | 데이터 분산 | ⭐⭐ |
| Datadog | 통합 모니터링 | ⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: Redis Cluster와 고가용성
- **배울 내용 1**: Redis Sentinel로 자동 페일오버 구현
- **배울 내용 2**: Redis Cluster로 대용량 데이터 분산
- **배울 내용 3**: 무중단 리샤딩과 슬롯 마이그레이션
- **실전 프로젝트**: 3대 마스터 + 3대 슬레이브 클러스터 구축

### 이 장과의 연결점
```
이번 장에서 배운 [성능 모니터링, 백업]
    ↓
다음 장에서 [Cluster 환경에서의 모니터링, 분산 백업]
    ↓
최종적으로 [대규모 프로덕션 운영]
```

### 준비하면 좋을 것들
```bash
# 다음 장 실습을 위한 준비
# Docker로 Redis 클러스터 환경 구성
docker pull redis:7.0
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Redis 공식 문서 - 성능 최적화](https://redis.io/docs/management/optimization/)
- [Redis 모니터링 가이드](https://redis.io/docs/management/monitoring/)

### 추천 블로그/아티클
- [Redis 메모리 최적화 심화](https://instagram-engineering.com/storing-hundreds-of-millions-of-simple-key-value-pairs-in-redis-1091ae80f74c)
- [LINE의 Redis 운영 경험](https://engineering.linecorp.com/ko/blog/redis-keys-pattern-to-avoid/)

### 영상 강의
- [Redis University - RU301: Redis Enterprise](https://university.redis.com/)

### 컨퍼런스 발표
- [RedisConf 2023 - Performance at Scale](https://redisconf.com/)

### 오픈소스 프로젝트
- [redis-exporter (Prometheus 연동)](https://github.com/oliver006/redis_exporter)
- [redis-commander (GUI 관리 도구)](https://github.com/joeferner/redis-commander)

---

## 🎉 축하합니다!

**Redis 성능 최적화 및 운영 마스터를 완료하셨습니다!**

**이제 여러분은**:
✅ Redis 서버를 실시간으로 모니터링할 수 있습니다
✅ 슬로우 쿼리를 찾아 성능을 개선할 수 있습니다
✅ 메모리를 최적화하여 서버 비용을 절감할 수 있습니다
✅ 안정적인 백업과 복구 전략을 수립할 수 있습니다
✅ 프로덕션 환경에서 Redis를 안전하게 운영할 수 있습니다
✅ 면접에서 성능 최적화 질문에 자신있게 답할 수 있습니다
✅ 실무에서 발생하는 Redis 장애를 신속하게 대응할 수 있습니다

**다음 단계**:
- [ ] Redis Cluster 학습으로 진행
- [ ] 실전 모니터링 대시보드 구축 (Grafana + Prometheus)
- [ ] 면접 질문 복습 및 모범 답안 연습
- [ ] 주니어 시나리오 코드 직접 재현해보기
- [ ] 실무 프로젝트에 백업 자동화 적용

**실무 적용 체크리스트**:
- [ ] 현재 Redis 서버에 모니터링 설정 (INFO, SLOWLOG)
- [ ] 슬로우 로그 확인 및 개선 (KEYS → SCAN)
- [ ] 백업 자동화 스크립트 작성 (RDB + AOF)
- [ ] 메모리 압축 설정 적용 (ziplist, intset)
- [ ] 알림 시스템 구축 (메모리 80% 초과 시 알림)
- [ ] maxmemory 및 축출 정책 설정
- [ ] Active Defragmentation 활성화

**학습 성과 자가 진단**:
```
✅ 모니터링 지표를 설명할 수 있나요? (ops/sec, hit rate, fragmentation)
✅ KEYS와 SCAN의 차이를 설명할 수 있나요?
✅ RDB와 AOF의 장단점을 비교할 수 있나요?
✅ 메모리 단편화를 해결할 수 있나요?
✅ 슬로우 쿼리를 찾고 개선할 수 있나요?
```

**모두 ✅라면 다음 장(Redis Cluster)으로 진행하세요!**
**일부 ❌가 있다면 해당 섹션을 복습하세요.**

---

**다음 장으로 이동**: [다음: 12장 Redis Cluster와 고가용성 →](12-redis-cluster-ha.md)

**이전 장으로 돌아가기**: [← 이전: 10장 Redis Pub/Sub](10-pubsub.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
