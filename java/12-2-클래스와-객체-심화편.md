# 12-2. 클래스와 객체 (심화편)

## 학습 목표
- 클래스와 객체에 대한 깊은 이해
- 실무에서 자주 묻는 질문에 답할 수 있다
- 면접에서 자신있게 설명할 수 있다

---

## 1. 자주 묻는 질문 (FAQ)

### FAQ 1: 클래스와 객체의 차이가 정확히 뭔가요?

**질문:**
"클래스와 객체를 구분하는 게 왜 중요한가요? 실무에서 어떤 차이가 있나요?"

**답변:**

**개념적 차이:**

| 구분 | 클래스 (Class) | 객체 (Object) |
|------|---------------|--------------|
| 정의 | 설계도, 템플릿 | 설계도로 만든 실체 |
| 개수 | 1개 (한 번만 정의) | 여러 개 (필요한 만큼) |
| 메모리 | Method Area | Heap |
| 역할 | 구조 정의 | 실제 데이터 저장 |
| 예시 | 자동차 설계도 | 실제 자동차들 |

**코드로 이해:**

```java
// 클래스: 설계도 (1개)
class Car {
    String model;
    int year;
}

// 객체: 실체 (여러 개)
Car car1 = new Car();  // 첫 번째 자동차
car1.model = "소나타";
car1.year = 2024;

Car car2 = new Car();  // 두 번째 자동차
car2.model = "K5";
car2.year = 2023;

// car1과 car2는 같은 클래스로 만들었지만
// 완전히 독립적인 객체
```

**실무 중요성:**

1. **데이터 관리**
   - 클래스: 사용자가 어떤 정보를 가지는지 정의
   - 객체: 각 사용자의 실제 데이터

2. **메모리 효율**
   - 클래스 코드는 한 번만 메모리에 로드
   - 객체는 각각 데이터만 저장

3. **코드 재사용**
   - 클래스 한 번 정의로
   - 수백만 개의 객체 생성 가능

**예시: 넷플릭스**
```java
class User {  // 클래스 1개
    String email;
    String subscription;
}

// 객체 2억 개 생성
User user1 = new User();
User user2 = new User();
// ... 2억 개
```

---

### FAQ 2: null과 NullPointerException을 어떻게 방지하나요?

**질문:**
"실무에서 NullPointerException이 자주 발생하는데, 어떻게 예방할 수 있나요?"

**답변:**

**발생 원인:**
```java
Car car = null;  // 객체를 가리키지 않음
car.drive();     // ❌ NullPointerException!
```

**방지 전략:**

**1. 항상 null 체크**
```java
public void displayCarInfo(Car car) {
    if (car == null) {
        System.out.println("차량 정보가 없습니다.");
        return;
    }

    car.displayInfo();  // 안전
}
```

**2. 초기화 패턴**
```java
// ❌ 나쁜 예
Car car;  // 초기화 안 함

// ✅ 좋은 예
Car car = null;  // 명시적 null 초기화
// 또는
Car car = new Car();  // 객체 생성
```

**3. 방어적 복사**
```java
public class CarService {
    private Car defaultCar = new Car();  // 기본값 준비

    public void process(Car car) {
        Car safeCar = (car != null) ? car : defaultCar;
        safeCar.drive();  // 안전
    }
}
```

**4. Optional 사용 (Java 8+)**
```java
import java.util.Optional;

public class CarService {
    public Optional<Car> findCar(String id) {
        // null을 반환하는 대신 Optional 사용
        if (carExists(id)) {
            return Optional.of(new Car());
        }
        return Optional.empty();
    }

    // 사용
    public void useCar() {
        Optional<Car> carOpt = findCar("123");
        carOpt.ifPresent(car -> car.drive());  // null 안전
    }
}
```

**5. 빠른 실패 (Fail-Fast)**
```java
public void setCar(Car car) {
    if (car == null) {
        throw new IllegalArgumentException("Car cannot be null");
    }
    this.car = car;
}
```

**실무 통계:**
- NullPointerException은 자바 에러의 **70%** 차지
- null 체크로 **90%** 예방 가능

---

### FAQ 3: 객체를 비교할 때 == vs equals()는 무엇을 사용해야 하나요?

**질문:**
"객체 비교할 때 ==와 equals()의 차이가 뭔가요?"

**답변:**

**핵심 차이:**

| 구분 | == | equals() |
|------|-----|----------|
| 비교 대상 | 주소 (참조) | 내용 (값) |
| 용도 | 같은 객체인지 | 의미상 같은지 |
| 결과 | 주소 일치 시 true | 구현에 따라 다름 |

**== 연산자:**
```java
Car car1 = new Car();
car1.model = "소나타";

Car car2 = new Car();
car2.model = "소나타";

Car car3 = car1;

System.out.println(car1 == car2);  // false (다른 객체)
System.out.println(car1 == car3);  // true (같은 객체)
```

메모리 구조:
```
car1 ──→ [객체1: model="소나타"]
car2 ──→ [객체2: model="소나타"]
car3 ──→ [객체1: model="소나타"]  (car1과 같음)

car1 == car2 → false (주소가 다름)
car1 == car3 → true (주소가 같음)
```

**equals() 메서드:**
```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1 == str2);        // false (다른 객체)
System.out.println(str1.equals(str2));   // true (내용이 같음)
```

**사용 가이드:**

1. **== 사용 케이스:**
   - 같은 객체인지 확인할 때
   - null 체크할 때
   ```java
   if (car == null) { }
   if (car1 == car2) { }  // 정말 같은 객체?
   ```

2. **equals() 사용 케이스:**
   - 의미상 같은 값인지 확인
   ```java
   String username1 = "admin";
   String username2 = getUserInput();
   if (username1.equals(username2)) { }  // 내용 비교
   ```

**주의사항:**
```java
String str = null;
str.equals("test");  // ❌ NullPointerException!

// 안전한 방법
"test".equals(str);  // ✅ false 반환 (null safe)
```

---

### FAQ 4: 왜 모든 필드를 private으로 해야 하나요?

**질문:**
"public으로 하면 편한데 왜 private으로 해야 하나요?"

**답변:**

**캡슐화의 중요성:**

**❌ public 필드의 문제:**
```java
class BankAccount {
    public long balance;  // 누구나 접근 가능
}

// 문제 발생
BankAccount account = new BankAccount();
account.balance = 1000000;

// 해커가 직접 수정
account.balance = 999999999;  // 검증 없이 수정 가능!
```

**✅ private 필드 + getter/setter:**
```java
class BankAccount {
    private long balance;  // 외부 직접 접근 불가

    public long getBalance() {
        return balance;
    }

    public void deposit(long amount) {
        if (amount <= 0) {
            System.out.println("❌ 입금액은 0보다 커야 합니다.");
            return;
        }

        balance += amount;
        System.out.println("✅ 입금 완료: " + amount);
    }

    public boolean withdraw(long amount) {
        if (amount > balance) {
            System.out.println("❌ 잔액 부족");
            return false;
        }

        if (amount <= 0) {
            System.out.println("❌ 출금액은 0보다 커야 합니다.");
            return false;
        }

        balance -= amount;
        System.out.println("✅ 출금 완료: " + amount);
        return true;
    }
}
```

**장점:**

1. **데이터 무결성 보장**
   - 잘못된 값 입력 방지
   - 비즈니스 룰 적용

2. **변경 용이성**
   ```java
   // 내부 구현 변경 가능
   class BankAccount {
       private long balance;

       // 나중에 로깅 추가
       public void deposit(long amount) {
           log("입금: " + amount);
           balance += amount;
       }
   }
   ```

3. **읽기 전용 속성**
   ```java
   class Student {
       private String studentId;  // 학번은 변경 불가

       public String getStudentId() {
           return studentId;
       }

       // setter 없음 → 변경 불가
   }
   ```

**실무 예시: 토스**
```java
class Account {
    private long balance;
    private int failedAttempts;

    public boolean withdraw(long amount, String pin) {
        // PIN 검증
        if (!validatePin(pin)) {
            failedAttempts++;
            if (failedAttempts >= 5) {
                lockAccount();  // 계좌 잠금
            }
            return false;
        }

        // 잔액 검증
        if (amount > balance) {
            return false;
        }

        balance -= amount;
        return true;
    }
}
```

---

### FAQ 5: static과 non-static의 차이가 뭔가요?

**질문:**
"static을 언제 사용하고, 언제 사용하지 말아야 하나요?"

**답변:**

**핵심 차이:**

| 구분 | static (정적) | non-static (인스턴스) |
|------|--------------|---------------------|
| 소속 | 클래스에 소속 | 객체에 소속 |
| 개수 | 1개 (공유) | 객체마다 1개 |
| 메모리 | Method Area | Heap |
| 생성 시기 | 클래스 로딩 시 | 객체 생성 시 |
| 접근 | 클래스명.변수 | 객체.변수 |

**코드 예시:**

```java
class Counter {
    static int totalCount = 0;      // 모든 객체가 공유
    int instanceCount = 0;          // 각 객체마다 독립적

    Counter() {
        totalCount++;      // 전체 카운터 증가
        instanceCount++;   // 개별 카운터 증가
    }
}

// 사용
Counter c1 = new Counter();
Counter c2 = new Counter();
Counter c3 = new Counter();

System.out.println("Total: " + Counter.totalCount);      // 3
System.out.println("C1 instance: " + c1.instanceCount);  // 1
System.out.println("C2 instance: " + c2.instanceCount);  // 1
System.out.println("C3 instance: " + c3.instanceCount);  // 1
```

메모리 구조:
```
Method Area (정적 영역)
┌─────────────────────┐
│ Counter.totalCount  │──> 3 (모든 객체가 공유)
└─────────────────────┘

Heap (객체 영역)
┌─────────────────────┐
│ c1 객체              │
│ instanceCount: 1    │
├─────────────────────┤
│ c2 객체              │
│ instanceCount: 1    │
├─────────────────────┤
│ c3 객체              │
│ instanceCount: 1    │
└─────────────────────┘
```

**static 사용 케이스:**

1. **상수 정의**
   ```java
   class MathUtils {
       public static final double PI = 3.14159;
       public static final int MAX_VALUE = 100;
   }

   double area = MathUtils.PI * r * r;
   ```

2. **유틸리티 메서드**
   ```java
   class StringUtils {
       public static boolean isEmpty(String str) {
           return str == null || str.length() == 0;
       }
   }

   if (StringUtils.isEmpty(name)) { }
   ```

3. **팩토리 메서드**
   ```java
   class User {
       private String username;

       public static User createAdmin(String username) {
           User user = new User();
           user.username = username;
           // 관리자 권한 설정
           return user;
       }
   }
   ```

4. **전역 카운터/설정**
   ```java
   class Database {
       private static int connectionCount = 0;
       private static final int MAX_CONNECTIONS = 100;
   }
   ```

**non-static 사용 케이스:**

1. **객체별 고유 데이터**
   ```java
   class Student {
       private String name;      // 각 학생마다 다름
       private int studentId;    // 각 학생마다 다름
   }
   ```

2. **객체 상태 관리**
   ```java
   class BankAccount {
       private long balance;     // 계좌마다 다른 잔액
   }
   ```

**주의사항:**
```java
class MyClass {
    int instanceVar = 10;
    static int staticVar = 20;

    static void staticMethod() {
        System.out.println(staticVar);    // ✅ OK
        System.out.println(instanceVar);  // ❌ 에러!
        // static에서 non-static 접근 불가
    }

    void instanceMethod() {
        System.out.println(staticVar);    // ✅ OK
        System.out.println(instanceVar);  // ✅ OK
    }
}
```

---

### FAQ 6: this 키워드는 언제 사용하나요?

**질문:**
"this를 언제 쓰고 언제 생략하나요?"

**답변:**

**this의 의미:**
- 현재 객체 자신을 가리키는 참조

**사용 케이스:**

**1. 필드와 매개변수 이름이 같을 때 (필수)**
```java
class Student {
    private String name;
    private int age;

    // this 없으면 안됨!
    public Student(String name, int age) {
        this.name = name;  // this.name = 필드, name = 매개변수
        this.age = age;
    }
}
```

**2. 메서드 체이닝**
```java
class Car {
    private String model;
    private String color;

    public Car setModel(String model) {
        this.model = model;
        return this;  // 자기 자신 반환
    }

    public Car setColor(String color) {
        this.color = color;
        return this;
    }
}

// 사용
Car car = new Car()
    .setModel("소나타")
    .setColor("흰색");  // 체이닝
```

**3. 다른 생성자 호출**
```java
class User {
    private String username;
    private String email;
    private int age;

    // 주 생성자
    public User(String username, String email, int age) {
        this.username = username;
        this.email = email;
        this.age = age;
    }

    // 간편 생성자
    public User(String username, String email) {
        this(username, email, 0);  // 다른 생성자 호출
    }

    // 더 간편한 생성자
    public User(String username) {
        this(username, null, 0);
    }
}
```

**4. 명확성을 위해 (선택)**
```java
class Calculator {
    private int result;

    public void add(int value) {
        this.result += value;  // this 생략 가능하지만 명확성을 위해 사용
    }

    public int getResult() {
        return this.result;  // 명확
    }
}
```

**생략 가능한 경우:**
```java
class Person {
    private String name;

    public void printName() {
        // 혼동 가능성이 없으면 생략 가능
        System.out.println(name);  // this.name과 동일
    }
}
```

**실무 가이드:**

1. **필수 사용:**
   - 필드와 매개변수 이름 같을 때
   - 생성자에서 다른 생성자 호출
   - 메서드 체이닝

2. **권장 사용:**
   - 가독성을 위해 명시적으로
   - 팀 코딩 컨벤션에 따라

3. **생략 가능:**
   - 혼동 가능성이 없는 경우

---

### FAQ 7: 객체 배열을 올바르게 초기화하는 방법은?

**질문:**
"객체 배열을 만들 때 자주 NullPointerException이 발생합니다. 올바른 방법은?"

**답변:**

**문제 상황:**
```java
Student[] students = new Student[5];
students[0].name = "김철수";  // ❌ NullPointerException!
```

**이유:**
```
배열 생성 시 각 요소는 null로 초기화됨

students[0] = null
students[1] = null
students[2] = null
students[3] = null
students[4] = null
```

**올바른 초기화 방법:**

**방법 1: 수동 초기화**
```java
Student[] students = new Student[3];

// 각 요소에 객체 생성
students[0] = new Student();
students[0].name = "김철수";
students[0].age = 20;

students[1] = new Student();
students[1].name = "이영희";
students[1].age = 21;

students[2] = new Student();
students[2].name = "박민수";
students[2].age = 22;
```

**방법 2: 반복문 초기화**
```java
Student[] students = new Student[100];

// 모든 요소에 객체 생성
for (int i = 0; i < students.length; i++) {
    students[i] = new Student();
    students[i].name = "학생" + (i + 1);
    students[i].age = 20 + i;
}
```

**방법 3: 배열 초기화 블록**
```java
Student[] students = {
    new Student("김철수", 20),
    new Student("이영희", 21),
    new Student("박민수", 22)
};
```

**방법 4: 팩토리 메서드**
```java
class StudentFactory {
    public static Student[] createStudents(int count) {
        Student[] students = new Student[count];
        for (int i = 0; i < count; i++) {
            students[i] = new Student();
            students[i].name = "학생" + (i + 1);
        }
        return students;
    }
}

// 사용
Student[] students = StudentFactory.createStudents(100);
```

**안전한 접근 패턴:**
```java
public class StudentManager {
    private Student[] students;

    public void processStudents() {
        for (int i = 0; i < students.length; i++) {
            if (students[i] != null) {  // null 체크
                students[i].study();
            }
        }

        // 또는 향상된 for문
        for (Student student : students) {
            if (student != null) {
                student.study();
            }
        }
    }
}
```

**실무 패턴: ArrayList 사용**
```java
import java.util.ArrayList;

// 배열 대신 ArrayList 사용
ArrayList<Student> students = new ArrayList<>();

// null 걱정 없이 추가
students.add(new Student("김철수", 20));
students.add(new Student("이영희", 21));

// 안전한 접근
for (Student student : students) {
    student.study();  // null 체크 불필요
}
```

**메모리 관리 팁:**
```java
// 큰 배열 초기화 시 성능 고려
Student[] students = new Student[10000];

// 지연 초기화 (필요할 때만 생성)
public Student getStudent(int index) {
    if (students[index] == null) {
        students[index] = new Student();
    }
    return students[index];
}
```

---

## 2. 면접 질문

### 주니어 개발자 면접 질문 (7개)

---

#### Q1. 클래스와 객체의 차이를 설명해주세요.

**답변:**

클래스는 객체를 만들기 위한 설계도이고, 객체는 클래스를 바탕으로 생성된 실체입니다.

**구체적 설명:**

1. **클래스 (Class)**
   - 객체의 구조를 정의하는 틀
   - 메모리에 한 번만 로드
   - Method Area에 저장

2. **객체 (Object)**
   - 클래스를 기반으로 생성된 인스턴스
   - 필요한 만큼 여러 개 생성 가능
   - Heap 영역에 저장
   - 각각 독립적인 데이터를 가짐

**코드 예시:**
```java
// 클래스 정의 (설계도)
class Student {
    String name;
    int age;
}

// 객체 생성 (실체)
Student student1 = new Student();  // 첫 번째 학생
student1.name = "김철수";
student1.age = 20;

Student student2 = new Student();  // 두 번째 학생
student2.name = "이영희";
student2.age = 21;

// student1과 student2는 같은 클래스로 만들었지만
// 독립적인 객체
```

**비유:**
- 클래스: 붕어빵 틀 (1개)
- 객체: 붕어빵들 (여러 개)

**실무 중요성:**
- 클래스 한 번 정의로 수백만 개의 객체 생성 가능
- 메모리 효율적 관리
- 코드 재사용성 극대화

---

#### Q2. new 키워드의 역할은 무엇인가요?

**답변:**

`new` 키워드는 클래스의 인스턴스(객체)를 Heap 메모리에 생성하는 연산자입니다.

**동작 과정:**

```java
Student student = new Student();
```

1. **Heap 메모리 할당**
   - Student 객체 크기만큼 메모리 할당

2. **필드 초기화**
   - 기본값으로 초기화 (숫자: 0, boolean: false, 참조: null)

3. **생성자 호출**
   - Student() 생성자 실행

4. **주소 반환**
   - 생성된 객체의 주소를 반환
   - student 변수에 저장

**메모리 구조:**
```
Stack                  Heap
┌─────────┐         ┌──────────────┐
│student  │────────>│ Student 객체  │
│(주소)   │         │ name: null   │
└─────────┘         │ age: 0       │
                    └──────────────┘
```

**주의사항:**
```java
Student student;           // 선언만 (객체 생성 안 됨)
student = new Student();   // 객체 생성 (new 필수)
```

---

#### Q3. NullPointerException은 언제 발생하나요? 어떻게 방지할 수 있나요?

**답변:**

NullPointerException은 null 참조 변수로 메서드나 필드에 접근할 때 발생합니다.

**발생 케이스:**

```java
// 케이스 1: 초기화 안 함
Student student = null;
student.study();  // ❌ NullPointerException

// 케이스 2: 반환값이 null
Student student = findStudent("없는ID");  // null 반환
student.study();  // ❌ NullPointerException

// 케이스 3: 배열 요소가 null
Student[] students = new Student[3];  // 배열만 생성
students[0].study();  // ❌ NullPointerException
```

**방지 방법:**

**1. null 체크**
```java
if (student != null) {
    student.study();
}
```

**2. 객체 생성 확인**
```java
Student student = new Student();  // 반드시 객체 생성
student.study();  // 안전
```

**3. 방어적 프로그래밍**
```java
public void processStudent(Student student) {
    if (student == null) {
        System.out.println("학생 정보가 없습니다.");
        return;
    }
    student.study();
}
```

**4. 배열 초기화**
```java
Student[] students = new Student[3];
for (int i = 0; i < students.length; i++) {
    students[i] = new Student();  // 각 요소 초기화
}
```

---

#### Q4. ==와 equals()의 차이는 무엇인가요?

**답변:**

`==`는 참조(주소)를 비교하고, `equals()`는 내용(값)을 비교합니다.

**차이점:**

```java
// == 연산자 (주소 비교)
String str1 = new String("Hello");
String str2 = new String("Hello");
System.out.println(str1 == str2);  // false (주소가 다름)

// equals() 메서드 (내용 비교)
System.out.println(str1.equals(str2));  // true (내용이 같음)
```

**메모리 구조:**
```
Stack           Heap
str1 ──────> ["Hello"]  객체1
str2 ──────> ["Hello"]  객체2

str1 == str2       → false (주소 비교)
str1.equals(str2)  → true (내용 비교)
```

**사용 가이드:**

1. **== 사용:**
   - 같은 객체인지 확인
   - null 체크
   ```java
   if (student == null) { }
   if (car1 == car2) { }  // 같은 객체?
   ```

2. **equals() 사용:**
   - 의미상 같은 값인지 확인
   ```java
   if (username.equals("admin")) { }
   if (password.equals(inputPassword)) { }
   ```

**주의:**
```java
String str = null;
str.equals("test");  // ❌ NullPointerException

// 안전한 방법
"test".equals(str);  // ✅ false 반환
```

---

#### Q5. 객체 배열과 일반 배열의 차이는 무엇인가요?

**답변:**

**일반 배열:**
- 기본 타입 데이터를 저장
- 값 자체가 배열에 저장됨

```java
int[] numbers = new int[3];
numbers[0] = 10;  // 값 10이 직접 저장
numbers[1] = 20;
numbers[2] = 30;
```

**객체 배열:**
- 참조 타입 데이터를 저장
- 객체의 주소가 배열에 저장됨

```java
Student[] students = new Student[3];
students[0] = new Student();  // 주소가 저장됨
students[1] = new Student();
students[2] = new Student();
```

**메모리 구조 비교:**

일반 배열:
```
numbers 배열
┌────┬────┬────┐
│ 10 │ 20 │ 30 │  값이 직접 저장
└────┴────┴────┘
```

객체 배열:
```
students 배열          Heap 영역
┌────┬────┬────┐
│ ●  │ ●  │ ●  │    ● = 주소 (참조)
└─┬──┴─┬──┴─┬──┘
  │    │    │
  ↓    ↓    ↓
[학생1] [학생2] [학생3]  실제 객체들
```

**초기화 차이:**

```java
// 일반 배열: 자동 초기화
int[] numbers = new int[3];
// numbers = {0, 0, 0}

// 객체 배열: null로 초기화
Student[] students = new Student[3];
// students = {null, null, null}
// 각 요소를 수동으로 생성해야 함!

for (int i = 0; i < students.length; i++) {
    students[i] = new Student();  // 필수!
}
```

---

#### Q6. this 키워드는 언제 사용하나요?

**답변:**

`this`는 현재 객체 자신을 가리키는 참조 변수입니다.

**주요 사용 케이스:**

**1. 필드와 매개변수 구분 (필수)**
```java
class Student {
    String name;

    Student(String name) {
        this.name = name;  // this.name = 필드, name = 매개변수
    }
}
```

**2. 다른 생성자 호출**
```java
class User {
    String username;
    int age;

    User(String username, int age) {
        this.username = username;
        this.age = age;
    }

    User(String username) {
        this(username, 0);  // 다른 생성자 호출
    }
}
```

**3. 메서드 체이닝**
```java
class Car {
    String model;
    String color;

    Car setModel(String model) {
        this.model = model;
        return this;  // 자기 자신 반환
    }

    Car setColor(String color) {
        this.color = color;
        return this;
    }
}

// 사용
Car car = new Car()
    .setModel("소나타")
    .setColor("흰색");
```

**4. 자기 자신을 메서드 인자로 전달**
```java
class Student {
    String name;

    void registerCourse(Course course) {
        course.addStudent(this);  // 자기 자신을 전달
    }
}
```

---

#### Q7. 캡슐화가 무엇이고 왜 중요한가요?

**답변:**

캡슐화는 데이터와 메서드를 하나로 묶고, 외부로부터 데이터를 보호하는 것입니다.

**구현 방법:**

```java
class BankAccount {
    // private: 외부 접근 차단
    private long balance;

    // public: 제어된 접근 제공
    public long getBalance() {
        return balance;
    }

    public void deposit(long amount) {
        if (amount > 0) {  // 검증
            balance += amount;
        }
    }

    public boolean withdraw(long amount) {
        if (amount > balance) {  // 검증
            return false;
        }
        balance -= amount;
        return true;
    }
}
```

**중요한 이유:**

1. **데이터 보호**
   ```java
   // ❌ public: 직접 수정 가능
   account.balance = -1000;  // 음수도 가능!

   // ✅ private + 메서드: 검증 가능
   account.withdraw(1000);  // 잔액 검사
   ```

2. **유지보수 용이**
   ```java
   // 내부 구현 변경해도 외부 코드 영향 없음
   private long balance;
   // → double balance; 로 변경 가능
   ```

3. **비즈니스 룰 적용**
   ```java
   public void deposit(long amount) {
       if (amount <= 0) {
           throw new IllegalArgumentException();
       }
       balance += amount;
       logTransaction("입금", amount);  // 로깅
   }
   ```

---

### 중급 개발자 면접 질문 (5개)

---

#### Q8. 불변 객체(Immutable Object)란 무엇이고, 어떻게 만드나요?

**답변:**

불변 객체는 생성 후 상태를 변경할 수 없는 객체입니다.

**구현 방법:**

```java
public final class ImmutablePerson {
    // 1. 모든 필드를 final로 선언
    private final String name;
    private final int age;

    // 2. 생성자에서만 초기화
    public ImmutablePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 3. getter만 제공 (setter 없음)
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // 4. 값 변경이 필요하면 새 객체 생성
    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(this.name, newAge);
    }
}
```

**장점:**

1. **스레드 안전 (Thread-Safe)**
   ```java
   // 여러 스레드에서 동시에 접근해도 안전
   ImmutablePerson person = new ImmutablePerson("김철수", 20);
   // 상태가 변하지 않으므로 동기화 불필요
   ```

2. **예측 가능성**
   ```java
   ImmutablePerson person = new ImmutablePerson("김철수", 20);
   someMethod(person);
   // person의 상태가 변하지 않음을 보장
   ```

3. **HashMap 키로 안전**
   ```java
   Map<ImmutablePerson, String> map = new HashMap<>();
   ImmutablePerson key = new ImmutablePerson("김철수", 20);
   map.put(key, "데이터");
   // key의 해시코드가 변하지 않음
   ```

**실무 예시: String**
```java
String str = "Hello";
str.toUpperCase();  // 새로운 String 객체 반환
System.out.println(str);  // "Hello" (원본 불변)

String upper = str.toUpperCase();  // 새 객체에 저장
System.out.println(upper);  // "HELLO"
```

---

#### Q9. 객체 지향의 4대 특성을 설명하고, 클래스와 객체가 이를 어떻게 지원하나요?

**답변:**

**1. 캡슐화 (Encapsulation)**
- 데이터와 메서드를 하나로 묶고 외부로부터 보호

```java
class BankAccount {
    private long balance;  // 캡슐화

    public void deposit(long amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
}
```

**2. 상속 (Inheritance)**
- 기존 클래스의 특성을 물려받아 재사용

```java
class Animal {
    void eat() { }
}

class Dog extends Animal {
    void bark() { }  // 추가 기능
}
```

**3. 다형성 (Polymorphism)**
- 같은 인터페이스로 다른 동작 수행

```java
Animal animal = new Dog();  // 다형성
animal.eat();  // Dog의 eat() 실행
```

**4. 추상화 (Abstraction)**
- 복잡한 구현을 숨기고 핵심만 노출

```java
interface Drawable {
    void draw();  // 구현 숨김
}

class Circle implements Drawable {
    public void draw() {
        // 원 그리기 구현
    }
}
```

**클래스와 객체의 역할:**
- **클래스**: 4대 특성을 구현하는 단위
- **객체**: 실제 동작하는 인스턴스

---

#### Q10. 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이는?

**답변:**

**얕은 복사 (Shallow Copy):**
- 객체의 참조만 복사
- 원본과 복사본이 같은 객체를 가리킴

```java
class Student {
    String name;
    int[] scores;
}

Student original = new Student();
original.name = "김철수";
original.scores = new int[]{90, 80, 70};

// 얕은 복사
Student shallow = original;  // 참조만 복사

shallow.scores[0] = 100;
System.out.println(original.scores[0]);  // 100 (원본도 변경됨!)
```

메모리 구조:
```
original ──┐
           ├──> [Student 객체]
shallow ───┘         ↓
                [scores 배열]

같은 객체를 가리킴
```

**깊은 복사 (Deep Copy):**
- 객체의 내용을 새로 복사
- 원본과 복사본이 독립적

```java
class Student implements Cloneable {
    String name;
    int[] scores;

    @Override
    protected Student clone() {
        Student cloned = new Student();
        cloned.name = this.name;

        // 배열도 새로 복사 (깊은 복사)
        cloned.scores = new int[this.scores.length];
        for (int i = 0; i < scores.length; i++) {
            cloned.scores[i] = this.scores[i];
        }

        return cloned;
    }
}

Student original = new Student();
original.scores = new int[]{90, 80, 70};

// 깊은 복사
Student deep = original.clone();

deep.scores[0] = 100;
System.out.println(original.scores[0]);  // 90 (원본 유지!)
```

메모리 구조:
```
original ──> [Student 객체1] ──> [scores 배열1]
                                 [90, 80, 70]

deep ──────> [Student 객체2] ──> [scores 배열2]
                                 [100, 80, 70]

독립적인 객체
```

---

#### Q11. 정적 팩토리 메서드 패턴이란 무엇이고, 생성자와 어떤 차이가 있나요?

**답변:**

정적 팩토리 메서드는 객체 생성을 담당하는 static 메서드입니다.

**일반 생성자:**
```java
User user = new User("admin", "1234");
```

**정적 팩토리 메서드:**
```java
public class User {
    private String username;
    private String password;
    private String role;

    private User(String username, String password, String role) {
        this.username = username;
        this.password = password;
        this.role = role;
    }

    // 정적 팩토리 메서드
    public static User createAdmin(String username, String password) {
        return new User(username, password, "ADMIN");
    }

    public static User createNormalUser(String username, String password) {
        return new User(username, password, "USER");
    }

    public static User createGuest() {
        return new User("guest", "guest", "GUEST");
    }
}

// 사용
User admin = User.createAdmin("admin", "1234");
User user = User.createNormalUser("user", "1234");
User guest = User.createGuest();
```

**장점:**

**1. 이름을 가질 수 있음**
```java
// 생성자: 의미 불명확
User user = new User("admin", "1234", "ADMIN");

// 정적 팩토리: 의미 명확
User user = User.createAdmin("admin", "1234");
```

**2. 매번 새 객체를 만들지 않아도 됨**
```java
public class Boolean {
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    public static Boolean valueOf(boolean b) {
        return b ? TRUE : FALSE;  // 캐싱된 객체 반환
    }
}
```

**3. 하위 타입 객체 반환 가능**
```java
public interface Animal {
    static Animal of(String type) {
        if (type.equals("dog")) {
            return new Dog();
        } else if (type.equals("cat")) {
            return new Cat();
        }
        throw new IllegalArgumentException();
    }
}
```

**4. 파라미터에 따라 다른 객체 반환**
```java
public class User {
    public static User createByAge(int age) {
        if (age < 18) {
            return new MinorUser();
        } else {
            return new AdultUser();
        }
    }
}
```

---

#### Q12. 객체의 생명주기를 설명하고, GC와의 관계는?

**답변:**

**객체 생명주기:**

**1. 생성 (Created)**
```java
Student student = new Student();  // Heap에 객체 생성
```

**2. 사용 (In Use)**
```java
student.study();  // 참조를 통해 사용
student.displayInfo();
```

**3. 참조 제거 (Unreachable)**
```java
student = null;  // 참조 끊김
// 또는
{
    Student localStudent = new Student();
    // 지역 변수는 블록 벗어나면 사라짐
}
```

**4. GC 대상 (Eligible for GC)**
```java
// 더 이상 참조되지 않는 객체는 GC 대상
```

**5. 소멸 (Destroyed)**
```java
// GC가 실행되어 메모리 회수
```

**GC와의 관계:**

**참조 카운팅:**
```java
Student s1 = new Student();  // 참조 1개
Student s2 = s1;             // 참조 2개
s1 = null;                   // 참조 1개
s2 = null;                   // 참조 0개 → GC 대상!
```

**메모리 구조:**
```
1. 생성
Stack           Heap
s1 ──────> [Student 객체]

2. 참조 추가
Stack           Heap
s1 ──┐
     ├──────> [Student 객체]
s2 ──┘

3. 참조 제거
Stack           Heap
s1 (null)
                [Student 객체] ← GC 대상
s2 (null)
```

**실무 고려사항:**

**1. 명시적 null 할당**
```java
public void process() {
    LargeObject obj = new LargeObject();
    // ... 사용 ...
    obj = null;  // 명시적 제거 (GC 힌트)
}
```

**2. try-with-resources (Java 7+)**
```java
try (FileReader fr = new FileReader("file.txt")) {
    // 자동으로 close() 호출
} // fr은 자동으로 정리됨
```

**3. WeakReference**
```java
WeakReference<Student> weakRef = new WeakReference<>(new Student());
// GC가 적극적으로 회수 가능
```

**메모리 누수 방지:**
```java
// ❌ 나쁜 예: static 컬렉션에 계속 추가
class Cache {
    private static List<Object> cache = new ArrayList<>();

    public void add(Object obj) {
        cache.add(obj);  // 메모리 누수!
    }
}

// ✅ 좋은 예: 적절한 제거
class Cache {
    private static Map<String, Object> cache = new HashMap<>();

    public void add(String key, Object obj) {
        cache.put(key, obj);
    }

    public void remove(String key) {
        cache.remove(key);  // 명시적 제거
    }
}
```

---

## 3. 핵심 정리

### 클래스와 객체 체크리스트

✅ **개념 이해**
- [ ] 클래스와 객체의 차이를 명확히 설명할 수 있다
- [ ] new 키워드의 동작을 이해한다
- [ ] 참조 타입의 특성을 안다

✅ **실무 활용**
- [ ] NullPointerException을 예방할 수 있다
- [ ] ==와 equals()를 적절히 사용한다
- [ ] 캡슐화의 중요성을 이해한다

✅ **고급 개념**
- [ ] 불변 객체를 만들 수 있다
- [ ] 얕은 복사와 깊은 복사를 구분한다
- [ ] 정적 팩토리 메서드를 활용할 수 있다

---

## 다음 단계

다음 장에서는 **생성자 (Constructor)**를 학습합니다:

- 생성자의 역할과 특징
- 기본 생성자와 매개변수 생성자
- 생성자 오버로딩
- this()를 이용한 생성자 체이닝

---

**축하합니다! 클래스와 객체를 완벽히 마스터했습니다!** 🎉
