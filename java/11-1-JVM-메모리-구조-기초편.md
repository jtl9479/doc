# 11-1장: JVM 메모리 구조 (기초편)

> **학습 목표**: JVM의 메모리 영역(Stack, Heap, Method Area)을 이해하고, 각 영역의 역할과 동작 원리를 파악할 수 있습니다.

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [왜 JVM 메모리 구조를 알아야 하는가](#-왜-jvm-메모리-구조를-알아야-하는가)
- [실생활 비유로 이해하기](#-실생활-비유로-이해하기)
- [핵심 개념](#-핵심-개념)
- [기본 실습](#-기본-실습)
- [실무 활용 사례](#-실무-활용-사례)
- [주니어 시나리오](#-주니어-시나리오)
- [실전 프로젝트](#-실전-프로젝트)
- [핵심 정리](#-핵심-정리)

---

## 🤔 왜 JVM 메모리 구조를 알아야 하는가?

### 실무 배경

**애플리케이션이 갑자기 멈추거나 느려지는 문제**

#### ❌ JVM 메모리를 이해하지 못하면 발생하는 문제

```
문제 1: OutOfMemoryError 발생
- 증상: 서비스 운영 중 갑자기 서버 다운
- 예시: "java.lang.OutOfMemoryError: Java heap space"
- 영향: 사용자 서비스 중단, 매출 손실
- 비용: 1시간 장애 시 평균 1,000만원 손실

문제 2: StackOverflowError
- 증상: 재귀 함수 호출 시 프로그램 크래시
- 예시: 무한 재귀로 Stack 메모리 초과
- 영향: 특정 기능 사용 불가
- 비용: 버그 수정에 평균 4시간 소요

문제 3: 메모리 누수 (Memory Leak)
- 증상: 시간이 지날수록 메모리 사용량 증가
- 예시: static 컬렉션에 객체 무한 추가
- 영향: 서버 재시작 필요, 성능 저하
- 비용: 야간 긴급 배포, 인력 투입

문제 4: 성능 저하
- 증상: GC(가비지 컬렉션) 시간 증가로 응답 지연
- 예시: Full GC 발생 시 5초 이상 멈춤
- 영향: 사용자 이탈, 서비스 품질 저하
- 비용: 고객 불만, 브랜드 이미지 하락
```

#### ✅ JVM 메모리를 이해하면

```
해결책 1: 메모리 에러 예방
- 방법: 적절한 Heap 크기 설정 (-Xmx, -Xms)
- 효과: OutOfMemoryError 사전 방지
- 절감: 장애 시간 95% 감소

해결책 2: Stack 에러 해결
- 방법: 재귀 깊이 제한, 반복문 전환
- 효과: StackOverflowError 방지
- 절감: 버그 수정 시간 80% 단축

해결책 3: 메모리 누수 탐지
- 방법: Heap Dump 분석, 프로파일링
- 효과: 메모리 사용량 정상화
- 절감: 서버 재시작 빈도 90% 감소

해결책 4: GC 튜닝
- 방법: GC 알고리즘 선택, 파라미터 조정
- 효과: GC 시간 최소화, 응답 속도 개선
- 절감: 응답 시간 50% 단축
```

### 📊 수치로 보는 효과

| 지표 | 메모리 이해 전 | 메모리 이해 후 | 개선율 |
|------|--------------|--------------|--------|
| 월 장애 횟수 | 5회 | 0.5회 | **90%↓** |
| GC 일시 정지 시간 | 5초 | 0.5초 | **90%↓** |
| 메모리 사용 효율 | 60% | 85% | **42%↑** |
| 서버 대수 | 10대 | 7대 | **30%↓** (비용 절감) |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 아파트 관리 시스템

```
JVM 메모리 = 아파트 단지

┌─────────────────────────────────────────┐
│            아파트 단지                   │
├─────────────────────────────────────────┤
│ 🏠 각 세대 (Stack)                      │
│    - 각 가구의 개인 공간                 │
│    - 세대별 독립적 사용                  │
│    - 퇴거 시 공간 반환                   │
│                                         │
│ 🏗️ 공용 창고 (Heap)                     │
│    - 주민 공동 사용 공간                 │
│    - 큰 물건 보관 (소파, 자전거 등)       │
│    - 관리인이 정기적으로 정리 (GC)       │
│                                         │
│ 📋 관리사무소 (Method Area)              │
│    - 아파트 설계도 보관                  │
│    - 입주민 명단 (클래스 정보)           │
│    - 규칙과 절차 (메서드 코드)           │
└─────────────────────────────────────────┘

Stack (각 세대):
- 메서드 호출 = 가족 구성원 활동
- 지역 변수 = 개인 물건 (방 안에만 존재)
- 메서드 종료 = 세대원 외출 (공간 비움)

Heap (공용 창고):
- 객체 생성 = 공용 물건 구입
- 참조 변수 = 창고 열쇠 (Stack에 보관)
- GC = 관리인의 불용품 처리

Method Area (관리사무소):
- 클래스 정보 = 아파트 설계도
- static 변수 = 공용 게시판 (모두 공유)
- 메서드 코드 = 관리 규칙
```

**유사점**:
- 세대(Stack)는 각자 독립적 = 스레드별 Stack 독립
- 창고(Heap)는 모두 공유 = 모든 스레드가 Heap 공유
- 관리사무소(Method Area)는 하나 = 모든 클래스 정보 한 곳에

### 비유 2: 레스토랑 운영 시스템

```
JVM = 레스토랑

┌─────────────────────────────────────┐
│         🍽️ 레스토랑               │
├─────────────────────────────────────┤
│ 🪑 테이블 (Stack)                   │
│    - 고객별 독립 공간               │
│    - 주문 받기 (메서드 호출)        │
│    - 식사 후 정리 (메서드 종료)     │
│                                     │
│ 🍳 주방 창고 (Heap)                 │
│    - 식재료 보관 (객체)             │
│    - 조리 도구 (배열, 컬렉션)       │
│    - 주방장이 정리 (GC)             │
│                                     │
│ 📖 레시피북 (Method Area)           │
│    - 요리법 (메서드 코드)           │
│    - 메뉴판 (클래스 정의)           │
│    - 영업 규칙 (static 변수)        │
└─────────────────────────────────────┘

실제 동작:
1. 고객 주문 (메서드 호출) → Stack에 공간 할당
2. 주방에서 재료 꺼냄 (객체 생성) → Heap에 저장
3. 레시피 참조 (메서드 실행) → Method Area 코드 실행
4. 식사 완료 (메서드 종료) → Stack 정리
5. 남은 재료 정리 (GC) → Heap 정리
```

### 비유 3: 도서관 시스템

```
JVM = 도서관

┌────────────────────────────────────┐
│         📚 도서관                   │
├────────────────────────────────────┤
│ 🪑 열람실 책상 (Stack)              │
│    - 개인 학습 공간                 │
│    - 메모지, 펜 (지역 변수)         │
│    - 퇴실 시 정리 (자동 반환)       │
│                                    │
│ 📦 서고 (Heap)                     │
│    - 도서 보관 (객체)               │
│    - 대출/반납 (참조 관리)          │
│    - 사서의 정리 (GC)               │
│                                    │
│ 🗂️ 도서 목록 (Method Area)         │
│    - 도서 분류표 (클래스 정보)      │
│    - 대출 규칙 (메서드)             │
│    - 회원 정보 (static)             │
└────────────────────────────────────┘

동작 흐름:
- 입실 = 스레드 시작 → Stack 생성
- 책 빌리기 = 객체 생성 → Heap에 할당
- 책상에 메모 = 지역 변수 → Stack에 저장
- 퇴실 = 스레드 종료 → Stack 제거
- 반납되지 않은 책 정리 = GC → Heap 정리
```

### 비유 4: 공장 생산 시스템

```
JVM = 제조 공장

┌─────────────────────────────────────┐
│          🏭 공장                     │
├─────────────────────────────────────┤
│ 🔧 작업대 (Stack)                    │
│    - 작업자별 공간                   │
│    - 작업 도구 (지역 변수)           │
│    - 작업 완료 시 정리               │
│                                     │
│ 📦 원자재 창고 (Heap)                │
│    - 부품 보관 (객체)                │
│    - 완제품 임시 저장                │
│    - 창고 관리자 정리 (GC)           │
│                                     │
│ 📋 설계도실 (Method Area)            │
│    - 제품 설계도 (클래스)            │
│    - 작업 지침서 (메서드)            │
│    - 공장 규정 (static)              │
└─────────────────────────────────────┘

생산 과정:
1. 작업 시작 = 메서드 호출 → Stack Frame 생성
2. 원자재 가져오기 = new 키워드 → Heap 할당
3. 설계도 확인 = 메서드 실행 → Method Area 참조
4. 작업 완료 = return → Stack Frame 제거
5. 불량품 폐기 = GC → Heap에서 제거
```

### 비유 5: 회사 사무실

```
JVM = 회사 오피스

┌──────────────────────────────────────┐
│         🏢 회사 사무실                │
├──────────────────────────────────────┤
│ 💺 개인 책상 (Stack)                 │
│    - 직원별 업무 공간                 │
│    - 개인 메모 (지역 변수)            │
│    - 퇴근 시 정리                     │
│                                      │
│ 🗄️ 공용 회의실 (Heap)                │
│    - 프로젝트 자료 (객체)             │
│    - 팀 공유 문서                     │
│    - 총무팀 정리 (GC)                 │
│                                      │
│ 📁 인사부 서류실 (Method Area)        │
│    - 직원 명부 (클래스 메타데이터)    │
│    - 업무 매뉴얼 (메서드 코드)        │
│    - 회사 규정 (static 변수)          │
└──────────────────────────────────────┘

업무 흐름:
- 출근 = 스레드 시작
- 책상에 업무 자료 = 지역 변수 선언
- 회의실 예약 = 객체 생성
- 프로젝트 진행 = 메서드 실행
- 퇴근 = 스레드 종료
- 회의실 정리 = GC 실행
```

### 🎯 종합 비교표

| 실제 세계 | Stack | Heap | Method Area |
|----------|-------|------|-------------|
| 아파트 | 각 세대 | 공용 창고 | 관리사무소 |
| 레스토랑 | 테이블 | 주방 창고 | 레시피북 |
| 도서관 | 열람실 책상 | 서고 | 도서 목록 |
| 공장 | 작업대 | 원자재 창고 | 설계도실 |
| 회사 | 개인 책상 | 회의실 | 인사부 서류실 |

**공통 특징**:
- **Stack**: 개인 전용, 빠른 접근, 자동 정리
- **Heap**: 공용 공간, 동적 할당, 수동 정리(GC)
- **Method Area**: 공유 정보, 프로그램 시작 시 로드

---

## 📖 핵심 개념

### JVM 메모리 구조 개요

#### 1️⃣ 초보자 수준 설명

**JVM은 프로그램을 실행할 때 메모리를 3개의 주요 영역으로 나누어 관리합니다.**

비유: 학교에서 학생들의 물건을 보관하는 방법
- **Stack**: 개인 사물함 (각 학생 전용, 빠른 접근)
- **Heap**: 공용 체육관 창고 (모두 함께 사용, 큰 물건 보관)
- **Method Area**: 교무실 서류 (학급 정보, 규칙 등)

#### 2️⃣ 중급자 수준 설명

**JVM Runtime Data Area는 프로그램 실행 시 사용되는 메모리 영역을 의미합니다.**

**주요 구성**:
- **Stack**: 스레드별로 생성되며, 메서드 호출 시 Stack Frame을 쌓고 종료 시 제거
- **Heap**: 모든 스레드가 공유하며, 객체와 배열이 저장되고 GC가 관리
- **Method Area**: 클래스 메타데이터, static 변수, 메서드 코드 저장

#### 3️⃣ 고급자 수준 설명

**JVM Memory Model은 멀티스레드 환경에서 메모리 가시성과 명령어 재배치를 규정합니다.**

**상세 구조**:
- **Stack**: 각 스레드의 Stack Frame은 Local Variable Array, Operand Stack, Frame Data로 구성
- **Heap**: Young Generation(Eden, S0, S1)과 Old Generation으로 나뉘며, 세대별 GC 알고리즘 적용
- **Method Area**: Runtime Constant Pool, Field/Method 정보, JIT 컴파일 코드 포함
- **PC Register**: 현재 실행 중인 JVM 명령어 주소
- **Native Method Stack**: JNI를 통한 Native 메서드 호출 시 사용

### 주요 용어 정리

| 용어 | 영문 | 설명 | 예시 |
|------|------|------|------|
| Stack | Stack | 메서드 호출 정보 저장 | 지역 변수, 매개변수 |
| Heap | Heap | 객체와 배열 저장 | new로 생성한 객체 |
| Method Area | Method Area | 클래스 정보 저장 | 클래스 메타데이터, static |
| GC | Garbage Collection | 자동 메모리 관리 | 미사용 객체 제거 |
| Stack Frame | Stack Frame | 메서드 호출 단위 | 메서드마다 생성 |

### JVM 메모리 구조 다이어그램

```
┌───────────────────────────────────────────────────┐
│                  JVM Memory                       │
├───────────────────────────────────────────────────┤
│                                                   │
│  🔄 Thread 1      🔄 Thread 2      🔄 Thread 3   │
│  ┌──────────┐    ┌──────────┐    ┌──────────┐   │
│  │  Stack   │    │  Stack   │    │  Stack   │   │
│  │          │    │          │    │          │   │
│  │ Frame 3  │    │ Frame 2  │    │ Frame 1  │   │
│  │ Frame 2  │    │ Frame 1  │    └──────────┘   │
│  │ Frame 1  │    └──────────┘                    │
│  └──────────┘                                    │
│       ↓              ↓              ↓            │
│  ┌────────────────────────────────────────────┐  │
│  │           🗄️ Heap (공유 영역)              │  │
│  │                                            │  │
│  │  ┌─────────────┐   ┌──────────────┐      │  │
│  │  │ Young Gen   │   │  Old Gen     │      │  │
│  │  │ ┌────────┐  │   │              │      │  │
│  │  │ │ Eden   │  │   │  Object ...  │      │  │
│  │  │ ├────────┤  │   │  Object ...  │      │  │
│  │  │ │ S0 S1  │  │   │              │      │  │
│  │  │ └────────┘  │   └──────────────┘      │  │
│  │  └─────────────┘                          │  │
│  │                                            │  │
│  │  [GC가 정리]                               │  │
│  └────────────────────────────────────────────┘  │
│                                                   │
│  ┌─────────────────────────────────────────────┐ │
│  │      📋 Method Area (공유 영역)              │ │
│  │                                             │ │
│  │  - Class Metadata (클래스 구조 정보)        │ │
│  │  - Static Variables (정적 변수)            │ │
│  │  - Method Code (메서드 바이트코드)          │ │
│  │  - Runtime Constant Pool (상수 풀)         │ │
│  │                                             │ │
│  └─────────────────────────────────────────────┘ │
│                                                   │
│  ┌─────────────────────────────────────────────┐ │
│  │      💾 Native Method Stack                 │ │
│  │      (JNI 호출 시 사용)                      │ │
│  └─────────────────────────────────────────────┘ │
│                                                   │
│  ┌─────────────────────────────────────────────┐ │
│  │      🎯 PC Register                         │ │
│  │      (현재 실행 명령어 위치)                 │ │
│  └─────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────┘

메모리 영역 특징:
┌──────────┬──────────┬──────────┬──────────────┐
│  영역    │  공유    │  크기    │   생명 주기   │
├──────────┼──────────┼──────────┼──────────────┤
│ Stack    │ 스레드별 │ 고정     │ 스레드 수명   │
│ Heap     │ 공유     │ 동적     │ GC가 관리    │
│ Method   │ 공유     │ 동적     │ JVM 수명     │
└──────────┴──────────┴──────────┴──────────────┘
```

---

## 💻 기본 실습

### 📋 사전 체크리스트

```bash
# 1. Java 버전 확인
java -version

# 2. JVM 옵션 확인
java -XX:+PrintFlagsFinal -version | grep -i heap

# 3. 메모리 정보 확인 (프로그램 내)
# Runtime.getRuntime() 사용
```

### 실습 1: Stack 메모리 동작 확인

**난이도**: ⭐⭐☆☆☆

#### 코드

```java
// StackDemo.java
public class StackDemo {
    // 메서드 호출 시 Stack Frame 생성
    public static void main(String[] args) {
        System.out.println("=== Stack 메모리 동작 확인 ===\n");

        int x = 10;  // main의 지역 변수 → Stack에 저장
        System.out.println("main: x = " + x);

        methodA(x);  // methodA 호출 → 새 Stack Frame 생성

        System.out.println("\nmain 종료: Stack Frame 제거");
    }

    public static void methodA(int a) {
        int y = 20;  // methodA의 지역 변수 → Stack에 저장
        System.out.println("methodA: a = " + a + ", y = " + y);

        methodB(y);  // methodB 호출 → 또 다른 Stack Frame 생성
    }

    public static void methodB(int b) {
        int z = 30;  // methodB의 지역 변수 → Stack에 저장
        System.out.println("methodB: b = " + b + ", z = " + z);

        // Stack 구조 시각화
        System.out.println("\n현재 Stack 구조:");
        System.out.println("┌─────────────┐");
        System.out.println("│ methodB     │ ← 최상위");
        System.out.println("│ (b=20,z=30) │");
        System.out.println("├─────────────┤");
        System.out.println("│ methodA     │");
        System.out.println("│ (a=10,y=20) │");
        System.out.println("├─────────────┤");
        System.out.println("│ main        │");
        System.out.println("│ (x=10)      │");
        System.out.println("└─────────────┘");

        System.out.println("\nmethodB 종료: Stack Frame 제거");
    }
}
```

#### 실행

```bash
javac StackDemo.java
java StackDemo
```

#### 예상 출력

```
=== Stack 메모리 동작 확인 ===

main: x = 10
methodA: a = 10, y = 20
methodB: b = 20, z = 30

현재 Stack 구조:
┌─────────────┐
│ methodB     │ ← 최상위
│ (b=20,z=30) │
├─────────────┤
│ methodA     │
│ (a=10,y=20) │
├─────────────┤
│ main        │
│ (x=10)      │
└─────────────┘

methodB 종료: Stack Frame 제거

main 종료: Stack Frame 제거
```

#### 코드 설명

- **라인 5**: `main` 메서드 호출 → Stack에 main Frame 생성
- **라인 8**: 지역 변수 `x` → Stack의 main Frame에 저장
- **라인 11**: `methodA` 호출 → Stack에 methodA Frame 추가
- **라인 23**: `methodB` 종료 → Stack에서 methodB Frame 제거 (LIFO)

### 실습 2: Heap 메모리 동작 확인

**난이도**: ⭐⭐⭐☆☆

#### 코드

```java
// HeapDemo.java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    void introduce() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}

public class HeapDemo {
    public static void main(String[] args) {
        System.out.println("=== Heap 메모리 동작 확인 ===\n");

        // 1. 객체 생성 → Heap에 저장
        Person p1 = new Person("김철수", 25);
        // p1 변수는 Stack에, Person 객체는 Heap에

        System.out.println("객체 생성 완료");
        System.out.println("p1 참조: " + p1);  // 객체 주소 (Heap 위치)

        // 2. 메서드 호출
        processPerson(p1);

        // 3. 메모리 구조 시각화
        System.out.println("\n메모리 구조:");
        System.out.println("Stack                  Heap");
        System.out.println("┌──────────┐          ┌─────────────────┐");
        System.out.println("│ main     │          │ Person 객체     │");
        System.out.println("│ p1 ─────────────────→ name: \"김철수\" │");
        System.out.println("│          │          │ age: 25         │");
        System.out.println("└──────────┘          └─────────────────┘");

        // 4. 객체 제거 (참조 끊기)
        p1 = null;  // p1이 더 이상 Heap 객체를 참조하지 않음
        System.out.println("\np1 = null 설정");
        System.out.println("Heap의 Person 객체는 GC 대상이 됨");

        // 5. GC 제안 (실제로 즉시 실행되지 않을 수 있음)
        System.gc();
        System.out.println("System.gc() 호출 → GC에게 정리 요청");
    }

    public static void processPerson(Person person) {
        System.out.println("\nprocessPerson 호출");
        person.introduce();

        // person 변수는 Stack에, 실제 객체는 Heap에
        System.out.println("person 참조: " + person);
    }
}
```

#### 실행 결과

```
=== Heap 메모리 동작 확인 ===

객체 생성 완료
p1 참조: Person@15db9742

processPerson 호출
이름: 김철수, 나이: 25
person 참조: Person@15db9742

메모리 구조:
Stack                  Heap
┌──────────┐          ┌─────────────────┐
│ main     │          │ Person 객체     │
│ p1 ─────────────────→ name: "김철수" │
│          │          │ age: 25         │
└──────────┘          └─────────────────┘

p1 = null 설정
Heap의 Person 객체는 GC 대상이 됨
System.gc() 호출 → GC에게 정리 요청
```

### 실습 3: Method Area (static 변수)

**난이도**: ⭐⭐⭐☆☆

#### 코드

```java
// MethodAreaDemo.java
class Counter {
    static int count = 0;  // Method Area에 저장 (모든 인스턴스 공유)
    int instanceCount = 0; // Heap에 저장 (인스턴스별 독립)

    Counter() {
        count++;           // static 변수 증가
        instanceCount++;   // 인스턴스 변수 증가
    }

    void printCount() {
        System.out.println("static count: " + count +
                         ", instance count: " + instanceCount);
    }
}

public class MethodAreaDemo {
    public static void main(String[] args) {
        System.out.println("=== Method Area (static) 동작 확인 ===\n");

        // 객체 3개 생성
        Counter c1 = new Counter();
        c1.printCount();  // static: 1, instance: 1

        Counter c2 = new Counter();
        c2.printCount();  // static: 2, instance: 1 (새 객체라 리셋)

        Counter c3 = new Counter();
        c3.printCount();  // static: 3, instance: 1

        System.out.println("\n메모리 구조:");
        System.out.println("Method Area           Heap");
        System.out.println("┌─────────────┐      ┌──────────────────┐");
        System.out.println("│ Counter     │      │ c1 객체          │");
        System.out.println("│ count = 3   │←공유→│ instanceCount=1  │");
        System.out.println("│ (static)    │      ├──────────────────┤");
        System.out.println("│             │      │ c2 객체          │");
        System.out.println("│             │←공유→│ instanceCount=1  │");
        System.out.println("│             │      ├──────────────────┤");
        System.out.println("│             │      │ c3 객체          │");
        System.out.println("│             │←공유→│ instanceCount=1  │");
        System.out.println("└─────────────┘      └──────────────────┘");

        System.out.println("\n모든 객체가 static 변수를 공유:");
        System.out.println("c1.count = " + Counter.count);  // 3
        System.out.println("c2.count = " + Counter.count);  // 3
        System.out.println("c3.count = " + Counter.count);  // 3
    }
}
```

#### 실행 결과

```
=== Method Area (static) 동작 확인 ===

static count: 1, instance count: 1
static count: 2, instance count: 1
static count: 3, instance count: 1

메모리 구조:
Method Area           Heap
┌─────────────┐      ┌──────────────────┐
│ Counter     │      │ c1 객체          │
│ count = 3   │←공유→│ instanceCount=1  │
│ (static)    │      ├──────────────────┤
│             │      │ c2 객체          │
│             │←공유→│ instanceCount=1  │
│             │      ├──────────────────┤
│             │      │ c3 객체          │
│             │←공유→│ instanceCount=1  │
└─────────────┘      └──────────────────┘

모든 객체가 static 변수를 공유:
c1.count = 3
c2.count = 3
c3.count = 3
```

### 실습 4: 메모리 정보 확인

**난이도**: ⭐⭐⭐⭐☆

#### 코드

```java
// MemoryInfoDemo.java
public class MemoryInfoDemo {
    public static void main(String[] args) {
        System.out.println("=== JVM 메모리 정보 확인 ===\n");

        // Runtime 객체로 메모리 정보 얻기
        Runtime runtime = Runtime.getRuntime();

        // 메모리 정보 (바이트 단위)
        long maxMemory = runtime.maxMemory();      // 최대 메모리 (-Xmx)
        long totalMemory = runtime.totalMemory();  // 현재 할당된 메모리
        long freeMemory = runtime.freeMemory();    // 사용 가능 메모리
        long usedMemory = totalMemory - freeMemory; // 사용 중 메모리

        // MB 단위로 변환
        System.out.println("최대 메모리 (Xmx): " + (maxMemory / 1024 / 1024) + " MB");
        System.out.println("현재 할당 메모리: " + (totalMemory / 1024 / 1024) + " MB");
        System.out.println("사용 중 메모리: " + (usedMemory / 1024 / 1024) + " MB");
        System.out.println("남은 메모리: " + (freeMemory / 1024 / 1024) + " MB");

        System.out.println("\n" + "=".repeat(50));
        System.out.println("메모리 사용률: " +
            String.format("%.2f%%", (double)usedMemory / maxMemory * 100));

        // 대량 객체 생성 후 메모리 변화 확인
        System.out.println("\n객체 100만 개 생성 중...");
        String[] arr = new String[1000000];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = "String " + i;
        }

        // 다시 메모리 확인
        long usedAfter = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("객체 생성 후 사용 메모리: " +
                         (usedAfter / 1024 / 1024) + " MB");
        System.out.println("증가량: " +
                         ((usedAfter - usedMemory) / 1024 / 1024) + " MB");

        // GC 실행
        System.out.println("\nGC 실행 중...");
        arr = null;  // 참조 제거
        System.gc();

        Thread.sleep(1000);  // GC 완료 대기

        long usedAfterGC = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("GC 후 사용 메모리: " +
                         (usedAfterGC / 1024 / 1024) + " MB");
        System.out.println("회수된 메모리: " +
                         ((usedAfter - usedAfterGC) / 1024 / 1024) + " MB");
    }
}
```

#### 실행

```bash
javac MemoryInfoDemo.java
# Heap 크기 지정하여 실행
java -Xmx512m -Xms256m MemoryInfoDemo
```

#### 예상 출력

```
=== JVM 메모리 정보 확인 ===

최대 메모리 (Xmx): 512 MB
현재 할당 메모리: 256 MB
사용 중 메모리: 10 MB
남은 메모리: 246 MB

==================================================
메모리 사용률: 1.95%

객체 100만 개 생성 중...
객체 생성 후 사용 메모리: 85 MB
증가량: 75 MB

GC 실행 중...
GC 후 사용 메모리: 12 MB
회수된 메모리: 73 MB
```

### 좋은 예 vs 나쁜 예

#### ❌ 나쁜 예

```java
// ❌ 1. static 변수 남용 (Method Area 낭비)
public class BadExample {
    static List<String> cache = new ArrayList<>();  // 프로그램 종료까지 유지

    public void addData(String data) {
        cache.add(data);  // 계속 쌓임, GC 안 됨!
    }
}

// ❌ 2. 무한 재귀 (Stack Overflow)
public class BadRecursion {
    public void infiniteRecursion() {
        infiniteRecursion();  // 종료 조건 없음!
        // StackOverflowError 발생
    }
}

// ❌ 3. 메모리 누수
public class MemoryLeak {
    private List<byte[]> list = new ArrayList<>();

    public void leakMemory() {
        while (true) {
            list.add(new byte[1024 * 1024]);  // 1MB씩 계속 추가
            // OutOfMemoryError 발생!
        }
    }
}
```

**문제점**:
- **static 남용**: Method Area에 계속 쌓여 메모리 낭비
- **무한 재귀**: Stack 영역 초과로 StackOverflowError
- **메모리 누수**: Heap 메모리 고갈로 OutOfMemoryError

#### ✅ 좋은 예

```java
// ✅ 1. 지역 변수 활용 (Stack 자동 정리)
public class GoodExample {
    public List<String> processData() {
        List<String> result = new ArrayList<>();  // 메서드 종료 시 Stack 정리
        // 처리 로직
        return result;
    }
}

// ✅ 2. 재귀에 종료 조건
public class GoodRecursion {
    public int factorial(int n) {
        if (n <= 1) return 1;  // 종료 조건!
        return n * factorial(n - 1);
    }
}

// ✅ 3. 참조 제거로 GC 유도
public class ProperMemory {
    public void processLargeData() {
        List<byte[]> list = new ArrayList<>();

        // 데이터 처리
        for (int i = 0; i < 100; i++) {
            list.add(new byte[1024 * 1024]);
        }

        // 처리 완료 후 참조 제거
        list.clear();
        list = null;  // GC 대상이 됨

        System.gc();  // GC 제안
    }
}
```

**장점**:
- **지역 변수**: 메서드 종료 시 Stack에서 자동 제거
- **종료 조건**: Stack Overflow 방지
- **참조 제거**: GC가 Heap 정리 가능

---

## 🏢 실무 활용 사례

### 실제 기업 활용 사례

#### 사례 1: Netflix - Heap 메모리 튜닝으로 GC 시간 단축

```java
// 문제 상황: Full GC로 5초 이상 서비스 멈춤
// Netflix 동영상 스트리밍 서버

// ❌ 튜닝 전
// 기본 JVM 설정
// -Xmx4g -Xms4g
// Full GC 발생 시 5-10초 멈춤 → 동영상 끊김

// 사용 목적: 전 세계 2억 사용자에게 끊김 없는 스트리밍 제공
// 규모: 초당 100만 요청 처리

// ✅ 튜닝 후
// G1 GC 사용 + Heap 크기 증가
// -Xmx8g -Xms8g
// -XX:+UseG1GC
// -XX:MaxGCPauseMillis=200  // GC 최대 200ms로 제한
// -XX:G1HeapRegionSize=16m

public class NetflixStreamingServer {
    // Heap 메모리를 효율적으로 사용
    private static final int CACHE_SIZE = 10000;

    // 자주 요청되는 데이터를 Heap에 캐싱
    private Map<String, VideoMetadata> videoCache =
        new ConcurrentHashMap<>(CACHE_SIZE);

    public VideoMetadata getVideo(String videoId) {
        // 캐시 확인 (Heap 메모리 활용)
        VideoMetadata cached = videoCache.get(videoId);
        if (cached != null) {
            return cached;  // Heap에서 빠르게 반환
        }

        // DB 조회
        VideoMetadata metadata = loadFromDatabase(videoId);
        videoCache.put(videoId, metadata);
        return metadata;
    }

    private VideoMetadata loadFromDatabase(String videoId) {
        // DB 조회 로직
        return new VideoMetadata(videoId);
    }
}

class VideoMetadata {
    String id;
    String title;
    int duration;

    VideoMetadata(String id) {
        this.id = id;
    }
}

// 성과
// - GC 일시 정지: 5초 → 0.2초 (96% 개선)
// - 동영상 버퍼링 발생률: 5% → 0.5% (90% 감소)
// - 사용자 만족도: 큰 폭 상승
// - 서버 비용: Heap 효율화로 서버 20% 절감
```

#### 사례 2: 카카오톡 - Stack Overflow 에러 해결

```java
// 문제 상황: 메시지 전달 시 깊은 재귀로 Stack Overflow

// ❌ 문제 코드 (재귀 방식)
public class MessageDelivery {
    // 그룹 채팅에서 100명에게 메시지 전달
    public void deliverToGroup(List<User> users, Message msg, int index) {
        if (index >= users.size()) return;

        sendMessage(users.get(index), msg);
        deliverToGroup(users, msg, index + 1);  // 재귀 호출

        // 그룹원이 1000명이면? Stack Frame 1000개!
        // StackOverflowError 발생!
    }

    private void sendMessage(User user, Message msg) {
        System.out.println(user.name + "에게 전송: " + msg.content);
    }
}

// ✅ 해결책 (반복문 사용)
public class ImprovedMessageDelivery {
    // Stack 깊이를 일정하게 유지
    public void deliverToGroup(List<User> users, Message msg) {
        // 반복문 사용 → Stack Frame 하나만 사용
        for (User user : users) {
            sendMessage(user, msg);
        }
        // Stack 안전!
    }

    private void sendMessage(User user, Message msg) {
        System.out.println(user.name + "에게 전송: " + msg.content);
    }

    public static void main(String[] args) {
        List<User> users = new ArrayList<>();
        for (int i = 1; i <= 10000; i++) {
            users.add(new User("사용자" + i));
        }

        Message msg = new Message("안녕하세요!");

        ImprovedMessageDelivery delivery = new ImprovedMessageDelivery();
        delivery.deliverToGroup(users, msg);

        System.out.println("\n1만 명에게 메시지 전달 완료 (Stack 안전)");
    }
}

class User {
    String name;
    User(String name) { this.name = name; }
}

class Message {
    String content;
    Message(String content) { this.content = content; }
}

// 성과
// - StackOverflowError 발생: 100% 제거
// - 대규모 그룹 채팅 안정성: 대폭 향상
// - 동시 사용자 처리: 5천만 명 (Stack 문제 없음)
```

#### 사례 3: 네이버 검색 - Method Area 최적화로 서버 시작 시간 단축

```java
// 문제 상황: 수만 개의 클래스 로딩으로 서버 시작 지연

// ❌ 튜닝 전
// 초기화 시 모든 클래스를 Method Area에 로드
// 서버 시작 시간: 5분

// ✅ 튜닝 후: Lazy Loading 적용
public class SearchEngine {
    // static 블록으로 초기화 → Method Area에 로드
    private static Map<String, Index> indices;

    // ❌ 기존 방식: 모든 인덱스를 시작 시 로드
    /*
    static {
        indices = new HashMap<>();
        // 10만 개의 인덱스 로드 → Method Area에 모두 적재
        for (int i = 0; i < 100000; i++) {
            indices.put("index" + i, new Index());
        }
    }
    */

    // ✅ 개선: 필요할 때만 로드 (Lazy Initialization)
    static {
        indices = new HashMap<>();
        System.out.println("SearchEngine 클래스 로드 (Method Area)");
    }

    public static Index getIndex(String key) {
        // 인덱스가 없으면 그때 생성 (Lazy Loading)
        return indices.computeIfAbsent(key, k -> {
            System.out.println("인덱스 생성: " + k);
            return new Index();
        });
    }

    public static void main(String[] args) {
        System.out.println("=== 서버 시작 ===");
        // 시작 시에는 indices만 초기화 (빠름!)

        System.out.println("\n검색 요청 처리...");
        Index idx1 = getIndex("search_index");  // 필요할 때 생성
        Index idx2 = getIndex("image_index");

        System.out.println("\n서버 시작 시간 단축!");
    }
}

class Index {
    // 인덱스 데이터
}

// JVM 옵션 최적화
// -XX:+TieredCompilation  // 단계별 컴파일로 시작 빠르게
// -XX:TieredStopAtLevel=1 // 레벨1까지만 컴파일
// -Xverify:none           // 바이트코드 검증 생략 (개발 환경)

// 성과
// - 서버 시작 시간: 5분 → 30초 (90% 단축)
// - Method Area 메모리 사용: 40% 감소
// - 개발자 생산성: 빠른 재시작으로 향상
```

---

## 👨‍💻 주니어 시나리오

### 시나리오 1: StackOverflowError 발생

**상황**: 재귀 함수를 작성했는데 프로그램이 크래시

```java
// ❌ 주니어 개발자가 작성한 코드
public class FileCounter {
    // 파일 개수를 세는 재귀 함수
    public int countFiles(File dir) {
        int count = 0;

        for (File file : dir.listFiles()) {
            if (file.isDirectory()) {
                count += countFiles(file);  // 재귀 호출
            } else {
                count++;
            }
        }

        return count;
    }

    public static void main(String[] args) {
        FileCounter counter = new FileCounter();
        File root = new File("/");  // 루트부터 탐색

        int total = counter.countFiles(root);
        // Exception in thread "main" java.lang.StackOverflowError
        System.out.println("총 파일: " + total);
    }
}
```

**문제점**:
- 폴더 깊이가 깊으면 재귀 호출이 수천 번 발생
- 각 재귀마다 Stack Frame 생성 → Stack 메모리 초과
- `/a/b/c/d/e/f/g/h/i/j/k/.../z` 깊이가 1000이면?
- Stack 크기 (기본 1MB) 초과 → **StackOverflowError**

**해결책**:
```java
// ✅ 올바른 코드 (반복문 + 스택 자료구조 사용)
import java.io.File;
import java.util.Stack;

public class ImprovedFileCounter {
    // Stack 자료구조로 깊이 제한 없이 탐색
    public int countFiles(File root) {
        int count = 0;
        Stack<File> stack = new Stack<>();  // Heap에 생성
        stack.push(root);

        while (!stack.isEmpty()) {
            File current = stack.pop();

            if (current.isDirectory()) {
                File[] files = current.listFiles();
                if (files != null) {
                    for (File file : files) {
                        stack.push(file);  // Heap의 Stack에 추가
                    }
                }
            } else {
                count++;
            }
        }

        return count;
    }

    public static void main(String[] args) {
        ImprovedFileCounter counter = new ImprovedFileCounter();
        File root = new File("C:\\");  // Windows 루트

        System.out.println("파일 탐색 시작...");
        int total = counter.countFiles(root);
        System.out.println("총 파일 개수: " + total);
        System.out.println("Stack Overflow 없이 완료!");
    }
}
```

**배운 점**:
- 💡 **재귀는 Stack 메모리 사용**: 깊이가 깊으면 위험
- 💡 **반복문 + Heap 자료구조**: Stack 메모리 절약
- 💡 **Stack 크기 조정**: `-Xss2m` (2MB로 증가) 가능하지만 근본적 해결 아님

### 시나리오 2: OutOfMemoryError: Java heap space

**상황**: 대용량 파일을 읽다가 메모리 부족 에러

```java
// ❌ 주니어 개발자의 실수
import java.io.*;
import java.util.*;

public class LogAnalyzer {
    public void analyzeLargeLog(String filePath) {
        List<String> allLines = new ArrayList<>();

        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;
            // 1GB 로그 파일을 전부 메모리에 로드!
            while ((line = br.readLine()) != null) {
                allLines.add(line);  // Heap에 계속 추가
            }
            // OutOfMemoryError: Java heap space 발생!

            // 분석 로직
            for (String logLine : allLines) {
                processLog(logLine);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void processLog(String line) {
        System.out.println(line);
    }

    public static void main(String[] args) {
        LogAnalyzer analyzer = new LogAnalyzer();
        analyzer.analyzeLargeLog("huge_log.txt");  // 1GB 파일
    }
}
```

**문제점**:
- 1GB 파일을 List에 전부 로드 → Heap 메모리 부족
- 파일 크기 > Heap 크기 → **OutOfMemoryError**
- Heap 기본 크기: 물리 메모리의 1/4 (예: 8GB PC → 2GB Heap)

**해결책**:
```java
// ✅ 스트림 방식으로 한 줄씩 처리
import java.io.*;

public class EfficientLogAnalyzer {
    // 한 줄씩 읽고 처리 후 버림 (메모리 절약)
    public void analyzeLargeLog(String filePath) {
        int processedLines = 0;

        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;

            while ((line = br.readLine()) != null) {
                processLog(line);  // 처리
                // line 변수는 다음 반복에서 덮어써짐
                // → 이전 line은 GC 대상

                processedLines++;

                if (processedLines % 10000 == 0) {
                    System.out.println(processedLines + "줄 처리 완료");
                }
            }

            System.out.println("\n총 " + processedLines + "줄 처리 (메모리 효율적)");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void processLog(String line) {
        // 로그 분석 로직
        // 여기서만 line 사용 후 버림
    }

    public static void main(String[] args) {
        EfficientLogAnalyzer analyzer = new EfficientLogAnalyzer();
        analyzer.analyzeLargeLog("huge_log.txt");
        // 메모리 부족 없이 처리 완료!
    }
}
```

**배운 점**:
- 💡 **스트리밍 방식**: 전체 로드 대신 한 줄씩 처리
- 💡 **Heap 크기 인식**: 파일 크기 < Heap 크기 확인
- 💡 **Heap 증가**: `-Xmx4g`로 4GB 할당 가능 (임시 방편)

### 시나리오 3: 지역 변수와 인스턴스 변수 혼동

**상황**: 변수 값이 예상과 다르게 동작

```java
// ❌ 주니어 개발자의 혼동
class Calculator {
    int result;  // 인스턴스 변수 (Heap)

    public void add(int a, int b) {
        int sum = a + b;  // 지역 변수 (Stack)
        result = sum;
    }

    public void multiply(int a, int b) {
        int product = a * b;  // 지역 변수 (Stack)
        // result를 업데이트 안 함!
    }

    public void printResult() {
        System.out.println("Result: " + result);
    }
}

public class VariableConfusion {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        calc.add(10, 20);
        calc.printResult();  // 30

        calc.multiply(5, 6);
        calc.printResult();  // 30 (변화 없음, 예상은 30?)

        // 왜 30이 나올까? multiply에서 result 안 바꿈!
    }
}
```

**문제점**:
- 지역 변수 `product`는 Stack에만 존재 → 메서드 종료 시 사라짐
- 인스턴스 변수 `result`는 Heap에 존재 → 계속 유지
- `multiply`에서 `result` 업데이트 안 함

**해결책**:
```java
// ✅ 명확한 변수 사용
class ImprovedCalculator {
    private int result;  // 인스턴스 변수 (Heap) - 명시적 private

    public void add(int a, int b) {
        int sum = a + b;      // 지역 변수 (Stack)
        this.result = sum;    // this로 명확히 Heap 변수 지정
        System.out.println("Stack: sum = " + sum);
        System.out.println("Heap: result = " + this.result);
    }

    public void multiply(int a, int b) {
        int product = a * b;      // 지역 변수 (Stack)
        this.result = product;    // Heap 변수에 저장!
        System.out.println("Stack: product = " + product);
        System.out.println("Heap: result = " + this.result);
    }

    public int getResult() {
        return this.result;  // Heap에서 값 반환
    }

    public void demonstrateMemory() {
        System.out.println("\n=== 메모리 구조 ===");
        System.out.println("Stack (add/multiply 메서드):");
        System.out.println("  - sum, product (지역 변수)");
        System.out.println("  - 메서드 종료 시 자동 제거");
        System.out.println("\nHeap (Calculator 객체):");
        System.out.println("  - result (인스턴스 변수)");
        System.out.println("  - 객체가 존재하는 동안 유지");
    }
}

public class ClearVariableUsage {
    public static void main(String[] args) {
        ImprovedCalculator calc = new ImprovedCalculator();

        System.out.println("=== add(10, 20) 호출 ===");
        calc.add(10, 20);

        System.out.println("\n=== multiply(5, 6) 호출 ===");
        calc.multiply(5, 6);

        System.out.println("\n최종 result: " + calc.getResult());  // 30

        calc.demonstrateMemory();
    }
}
```

**배운 점**:
- 💡 **지역 변수 (Stack)**: 메서드 내에서만 유효, 자동 제거
- 💡 **인스턴스 변수 (Heap)**: 객체와 함께 유지, GC가 관리
- 💡 **this 키워드**: Heap의 인스턴스 변수 명시적 참조

### 시나리오 4: static 변수 남용으로 메모리 누수

**상황**: static 변수에 데이터를 계속 추가해서 메모리 증가

```java
// ❌ 주니어 개발자의 실수
import java.util.*;

class UserManager {
    // static 변수 → Method Area에 저장 (프로그램 종료까지 유지)
    private static List<User> allUsers = new ArrayList<>();

    public void registerUser(String name) {
        User user = new User(name);
        allUsers.add(user);  // 계속 쌓임, GC 안 됨!
        System.out.println("사용자 등록: " + name);
    }

    public void printUserCount() {
        System.out.println("현재 사용자 수: " + allUsers.size());
    }
}

class User {
    String name;
    User(String name) { this.name = name; }
}

public class StaticMemoryLeak {
    public static void main(String[] args) {
        UserManager manager = new UserManager();

        // 100만 사용자 등록
        for (int i = 0; i < 1000000; i++) {
            manager.registerUser("User" + i);
        }

        manager.printUserCount();  // 100만

        // manager = null로 설정해도...
        manager = null;

        // allUsers는 static이라 여전히 Method Area에 존재!
        // → 100만 User 객체가 Heap에 남아있음
        // → 메모리 누수!

        System.gc();  // GC 실행해도 allUsers는 제거 안 됨

        System.out.println("메모리 누수 발생!");
        System.out.println("allUsers는 프로그램 종료까지 유지됨");
    }
}
```

**문제점**:
- `static allUsers`는 Method Area에 저장 → 프로그램 종료까지 유지
- allUsers가 참조하는 User 객체들은 Heap에 → GC 대상 아님
- 100만 User × 약 100바이트 = 100MB 메모리 계속 점유

**해결책**:
```java
// ✅ 인스턴스 변수 사용
import java.util.*;

class ImprovedUserManager {
    // static 제거 → 인스턴스 변수 (Heap)
    private List<User> users = new ArrayList<>();

    public void registerUser(String name) {
        User user = new User(name);
        users.add(user);
    }

    public void printUserCount() {
        System.out.println("사용자 수: " + users.size());
    }

    // 명시적으로 메모리 정리 메서드 제공
    public void clearUsers() {
        users.clear();
        users = null;  // GC 대상으로 만듦
        System.out.println("사용자 목록 정리 완료");
    }
}

public class ProperMemoryManagement {
    public static void main(String[] args) {
        ImprovedUserManager manager = new ImprovedUserManager();

        // 사용자 등록
        for (int i = 0; i < 1000000; i++) {
            manager.registerUser("User" + i);
        }

        manager.printUserCount();

        // 명시적 정리
        manager.clearUsers();

        // manager 참조 제거
        manager = null;

        // 이제 GC가 User 객체들을 회수할 수 있음!
        System.gc();

        System.out.println("메모리 정상적으로 회수 가능");
    }
}
```

**배운 점**:
- 💡 **static 신중히 사용**: Method Area에 영구 저장됨
- 💡 **인스턴스 변수 선호**: 객체와 함께 GC 대상
- 💡 **명시적 정리**: `clear()`, `= null`로 GC 유도
- 💡 **static은 상수나 유틸리티에만**: `static final` 상수, `Math.abs()` 같은 유틸리티

---

## 🛠️ 실전 프로젝트

### 프로젝트: JVM 메모리 모니터링 프로그램

**난이도**: ⭐⭐⭐⭐☆
**예상 소요 시간**: 4-5시간
**학습 목표**: JVM 메모리의 실시간 상태를 모니터링하고 분석하는 프로그램 구현

### 요구사항 분석

#### 기능 요구사항
- [ ] 실시간 메모리 사용량 출력 (Heap, Stack)
- [ ] 객체 생성 시 메모리 변화 추적
- [ ] GC 실행 전후 메모리 비교
- [ ] 메모리 누수 시뮬레이션 및 탐지
- [ ] 메모리 사용 통계 분석

#### 기술 요구사항
- [ ] Runtime API 활용
- [ ] 스레드별 메모리 사용
- [ ] 메모리 임계값 경고

#### 비기능 요구사항
- [ ] 1초 간격 모니터링
- [ ] 메모리 사용률 그래프 (콘솔)
- [ ] 로그 파일 저장

### 프로젝트 구조

```
memory-monitor/
  └── src/
       ├── MemoryMonitor.java        (메인 클래스)
       ├── MemoryStats.java          (메모리 통계)
       ├── MemoryLeakSimulator.java  (메모리 누수 시뮬레이션)
       └── MemoryVisualizer.java     (콘솔 시각화)
```

### 설계 의사결정

#### 왜 이렇게 설계했는가?

1. **Runtime API 사용**
   - 이유: JVM 메모리 정보 실시간 조회
   - 효과: 정확한 Heap 메모리 사용량 파악

2. **스레드 분리**
   - 이유: 모니터링과 작업 분리
   - 효과: 실시간 모니터링하면서 다른 작업 가능

### 단계별 구현 가이드

#### 1단계: 메모리 통계 클래스

```java
// MemoryStats.java
public class MemoryStats {
    private long maxMemory;     // 최대 메모리
    private long totalMemory;   // 현재 할당된 메모리
    private long freeMemory;    // 사용 가능한 메모리
    private long usedMemory;    // 사용 중인 메모리

    public MemoryStats() {
        update();
    }

    public void update() {
        Runtime runtime = Runtime.getRuntime();
        this.maxMemory = runtime.maxMemory();
        this.totalMemory = runtime.totalMemory();
        this.freeMemory = runtime.freeMemory();
        this.usedMemory = totalMemory - freeMemory;
    }

    public long getMaxMemoryMB() {
        return maxMemory / 1024 / 1024;
    }

    public long getTotalMemoryMB() {
        return totalMemory / 1024 / 1024;
    }

    public long getUsedMemoryMB() {
        return usedMemory / 1024 / 1024;
    }

    public long getFreeMemoryMB() {
        return freeMemory / 1024 / 1024;
    }

    public double getUsagePercentage() {
        return (double) usedMemory / maxMemory * 100;
    }

    public void printStats() {
        System.out.printf("최대: %dMB | 할당: %dMB | 사용: %dMB | 여유: %dMB | 사용률: %.2f%%\n",
            getMaxMemoryMB(), getTotalMemoryMB(), getUsedMemoryMB(),
            getFreeMemoryMB(), getUsagePercentage());
    }
}
```

#### 2단계: 메모리 시각화 클래스

```java
// MemoryVisualizer.java
public class MemoryVisualizer {
    private static final int BAR_LENGTH = 50;

    public static void drawMemoryBar(double percentage) {
        int filled = (int) (BAR_LENGTH * percentage / 100);
        int empty = BAR_LENGTH - filled;

        System.out.print("[");
        for (int i = 0; i < filled; i++) {
            System.out.print("█");
        }
        for (int i = 0; i < empty; i++) {
            System.out.print("░");
        }
        System.out.printf("] %.2f%%\n", percentage);
    }

    public static void drawMemoryGraph(MemoryStats stats) {
        System.out.println("\n" + "=".repeat(60));
        System.out.println("📊 JVM Heap 메모리 사용 현황");
        System.out.println("=".repeat(60));

        stats.printStats();
        System.out.print("사용량: ");
        drawMemoryBar(stats.getUsagePercentage());

        // 경고 메시지
        if (stats.getUsagePercentage() > 90) {
            System.out.println("⚠️  경고: 메모리 사용률이 90%를 초과했습니다!");
        } else if (stats.getUsagePercentage() > 70) {
            System.out.println("⚡ 주의: 메모리 사용률이 70%를 초과했습니다.");
        }

        System.out.println("=".repeat(60));
    }
}
```

#### 3단계: 메모리 누수 시뮬레이터

```java
// MemoryLeakSimulator.java
import java.util.*;

public class MemoryLeakSimulator {
    // 메모리 누수 시뮬레이션용 static 리스트
    private static List<byte[]> leakyList = new ArrayList<>();

    // 정상적인 메모리 사용
    public static void normalAllocation(int count) {
        List<byte[]> localList = new ArrayList<>();

        for (int i = 0; i < count; i++) {
            localList.add(new byte[1024 * 1024]);  // 1MB씩 할당
        }

        System.out.println(count + "MB 할당 완료 (지역 변수, GC 가능)");
        // 메서드 종료 시 localList는 GC 대상
    }

    // 메모리 누수 시뮬레이션
    public static void leakyAllocation(int count) {
        for (int i = 0; i < count; i++) {
            leakyList.add(new byte[1024 * 1024]);  // 1MB씩 할당
        }

        System.out.println(count + "MB 할당 (static 변수, GC 불가)");
        System.out.println("누적 메모리 누수: " + leakyList.size() + "MB");
    }

    // 메모리 정리
    public static void cleanup() {
        int size = leakyList.size();
        leakyList.clear();
        leakyList = null;

        System.out.println(size + "MB 메모리 정리 완료");
    }
}
```

#### 4단계: 메인 모니터링 프로그램

```java
// MemoryMonitor.java
import java.util.*;

public class MemoryMonitor {
    private static boolean monitoring = true;

    public static void main(String[] args) throws Exception {
        System.out.println("🚀 JVM 메모리 모니터링 프로그램 시작\n");

        // 모니터링 스레드 시작
        Thread monitorThread = new Thread(() -> {
            while (monitoring) {
                MemoryStats stats = new MemoryStats();
                MemoryVisualizer.drawMemoryGraph(stats);

                try {
                    Thread.sleep(2000);  // 2초마다 업데이트
                } catch (InterruptedException e) {
                    break;
                }
            }
        });

        monitorThread.start();

        // 메인 스레드에서 메모리 작업 시뮬레이션
        simulateMemoryOperations();

        // 모니터링 종료
        monitoring = false;
        monitorThread.join();

        System.out.println("\n✅ 프로그램 종료");
    }

    private static void simulateMemoryOperations() throws Exception {
        Scanner scanner = new Scanner(System.in);

        while (true) {
            System.out.println("\n[ 메모리 작업 선택 ]");
            System.out.println("1. 정상 메모리 할당 (GC 가능)");
            System.out.println("2. 메모리 누수 시뮬레이션 (GC 불가)");
            System.out.println("3. GC 실행");
            System.out.println("4. 메모리 정리");
            System.out.println("5. 대량 객체 생성 테스트");
            System.out.println("0. 종료");
            System.out.print("선택: ");

            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("할당할 MB: ");
                    int normalMB = scanner.nextInt();
                    MemoryLeakSimulator.normalAllocation(normalMB);
                    Thread.sleep(1000);
                    break;

                case 2:
                    System.out.print("누수시킬 MB: ");
                    int leakMB = scanner.nextInt();
                    MemoryLeakSimulator.leakyAllocation(leakMB);
                    Thread.sleep(1000);
                    break;

                case 3:
                    System.out.println("GC 실행 중...");
                    System.gc();
                    Thread.sleep(2000);
                    System.out.println("GC 완료");
                    break;

                case 4:
                    MemoryLeakSimulator.cleanup();
                    Thread.sleep(1000);
                    break;

                case 5:
                    massObjectCreation();
                    break;

                case 0:
                    return;

                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }

    private static void massObjectCreation() throws Exception {
        System.out.println("\n대량 객체 생성 시작...");

        MemoryStats before = new MemoryStats();
        System.out.println("생성 전:");
        before.printStats();

        // 100만 개 객체 생성
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            list.add("Object " + i);

            if (i % 100000 == 0) {
                System.out.println((i / 1000) + "K 객체 생성...");
            }
        }

        Thread.sleep(1000);

        MemoryStats after = new MemoryStats();
        System.out.println("\n생성 후:");
        after.printStats();

        long increase = after.getUsedMemoryMB() - before.getUsedMemoryMB();
        System.out.println("메모리 증가량: " + increase + "MB");

        // 참조 제거
        System.out.println("\n참조 제거 및 GC...");
        list.clear();
        list = null;
        System.gc();

        Thread.sleep(2000);

        MemoryStats afterGC = new MemoryStats();
        System.out.println("GC 후:");
        afterGC.printStats();

        long reclaimed = after.getUsedMemoryMB() - afterGC.getUsedMemoryMB();
        System.out.println("회수된 메모리: " + reclaimed + "MB");
    }
}
```

### 실행 방법

```bash
# 컴파일
javac MemoryStats.java
javac MemoryVisualizer.java
javac MemoryLeakSimulator.java
javac MemoryMonitor.java

# Heap 크기 지정하여 실행
java -Xmx512m -Xms256m MemoryMonitor
```

### 실행 결과 예시

```
🚀 JVM 메모리 모니터링 프로그램 시작

============================================================
📊 JVM Heap 메모리 사용 현황
============================================================
최대: 512MB | 할당: 256MB | 사용: 15MB | 여유: 241MB | 사용률: 2.93%
사용량: [█░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 2.93%
============================================================

[ 메모리 작업 선택 ]
1. 정상 메모리 할당 (GC 가능)
2. 메모리 누수 시뮬레이션 (GC 불가)
3. GC 실행
4. 메모리 정리
5. 대량 객체 생성 테스트
0. 종료
선택: 2
할당할 MB: 100
100MB 할당 (static 변수, GC 불가)
누적 메모리 누수: 100MB

============================================================
📊 JVM Heap 메모리 사용 현황
============================================================
최대: 512MB | 할당: 256MB | 사용: 115MB | 여유: 141MB | 사용률: 22.46%
사용량: [███████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 22.46%
============================================================

선택: 3
GC 실행 중...
GC 완료

============================================================
📊 JVM Heap 메모리 사용 현황
============================================================
최대: 512MB | 할당: 256MB | 사용: 110MB | 여유: 146MB | 사용률: 21.48%
사용량: [██████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░] 21.48%
⚡ 주의: GC 실행했지만 메모리 사용률 여전히 높음 (누수 의심)
============================================================
```

### 확장 아이디어

#### 추가 기능 1: 메모리 경고 알림
**난이도**: ⭐⭐⭐☆☆
**구현 힌트**: 사용률 90% 초과 시 경고음 재생

#### 추가 기능 2: 메모리 사용 로그 저장
**난이도**: ⭐⭐⭐⭐☆
**구현 힌트**: CSV 파일로 시간별 메모리 사용량 기록

#### 추가 기능 3: Stack 깊이 측정
**난이도**: ⭐⭐⭐⭐⭐
**구현 힌트**: Thread.currentThread().getStackTrace()로 Stack Frame 개수 확인

### 코드 리뷰 포인트

#### 체크리스트
- [x] Runtime API를 올바르게 사용했는가?
- [x] 메모리 단위 변환 (byte → MB)이 정확한가?
- [x] static 변수를 적절히 사용했는가?
- [x] GC 호출 후 충분한 대기 시간을 주었는가?
- [x] 스레드 안전성을 고려했는가?
- [x] 메모리 누수를 올바르게 시뮬레이션했는가?

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| Stack | 메서드 호출 정보 저장 | 지역 변수, LIFO, 자동 정리 |
| Heap | 객체와 배열 저장 | new, GC, 동적 할당 |
| Method Area | 클래스 메타데이터 | static, 클래스 정보, 상수 풀 |
| GC | 자동 메모리 관리 | 미사용 객체 제거 |
| Memory Leak | 메모리 누수 | static 남용, 참조 유지 |

### JVM 메모리 영역 비교

| 영역 | 공유 여부 | 저장 내용 | 생명 주기 | GC 대상 |
|------|---------|----------|----------|---------|
| **Stack** | 스레드별 독립 | 지역 변수, 메서드 호출 | 스레드 수명 | 자동 제거 |
| **Heap** | 모든 스레드 공유 | 객체, 배열 | 객체 생명 | GC 관리 |
| **Method Area** | 모든 스레드 공유 | 클래스 정보, static | JVM 수명 | 거의 안 됨 |

### 변수 타입별 메모리 위치

| 변수 타입 | 메모리 위치 | 생명 주기 | 예시 |
|----------|-----------|----------|------|
| 지역 변수 | Stack | 메서드 수명 | `int x = 10;` |
| 인스턴스 변수 | Heap | 객체 수명 | `this.name` |
| static 변수 | Method Area | JVM 수명 | `static int count` |
| 매개변수 | Stack | 메서드 수명 | `void method(int a)` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] **지역 변수 우선**: Stack 자동 정리 활용
- [ ] **적절한 Heap 크기**: `-Xmx`, `-Xms` 설정
- [ ] **참조 제거**: 사용 완료 후 `= null`
- [ ] **재귀 깊이 제한**: StackOverflowError 방지
- [ ] **메모리 모니터링**: 주기적 점검

#### ❌ 하지 말아야 할 것
- [ ] **static 컬렉션에 무한 추가**: Method Area 누수
- [ ] **무한 재귀**: Stack Overflow
- [ ] **대량 객체 한번에 생성**: OutOfMemoryError
- [ ] **GC 과도한 호출**: `System.gc()` 남용
- [ ] **메모리 누수 방치**: 모니터링 없이 운영

---

## 🔗 관련 기술

**JVM 메모리와 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| Garbage Collection | Heap 메모리 관리 | ⭐⭐⭐⭐⭐ (필수) |
| JVM 옵션 | 메모리 크기 조정 | ⭐⭐⭐⭐ |
| Profiling 도구 | 메모리 분석 | ⭐⭐⭐⭐ |
| Heap Dump | 메모리 스냅샷 | ⭐⭐⭐ |
| JConsole/VisualVM | 모니터링 | ⭐⭐⭐⭐ |

**학습 순서 추천**:
```
JVM 메모리 구조 (현재) ✅
    ↓
Garbage Collection 심화
    ↓
JVM 옵션과 튜닝
    ↓
메모리 프로파일링
    ↓
성능 최적화
```

---

## 🚀 다음 단계

### 다음 장 미리보기: 11-2장 JVM 메모리 구조 (심화편)

**배울 내용**:
- **GC 알고리즘 상세**: Serial, Parallel, CMS, G1GC, ZGC
- **Heap 세대별 구조**: Young Gen, Old Gen, Eden, Survivor
- **메모리 튜닝 실전**: JVM 옵션 최적화
- **메모리 프로파일링**: VisualVM, JProfiler 사용법
- **FAQ 7개**: 자주 묻는 질문과 답변
- **면접 질문 12개**: 주니어 7개 + 중급 5개

### 이 장과의 연결점

```
11-1장: JVM 메모리 기초
    ↓
Stack, Heap, Method Area 이해
    ↓
11-2장: JVM 메모리 심화
    ↓
GC, 튜닝, 프로파일링
    ↓
최종적으로
    ↓
고성능 Java 애플리케이션 개발 능력
```

---

**💪 "JVM 메모리 구조의 기초를 완벽히 이해했습니다!"**

**📖 다음 장에서 만나요!**

[← 이전: 10-2장 패키지와 import 심화편](10-2-패키지와-import-심화편.md) | [다음: 11-2장 JVM 메모리 구조 심화편 →](11-2-JVM-메모리-구조-심화편.md)

[📚 전체 목차로 돌아가기](README.md)

---

**🌟 Java 마스터의 길, 계속 전진하세요! 🚀**

*"Premature optimization is the root of all evil." - Donald Knuth*
*"하지만 메모리 구조 이해는 최적화의 기초입니다!"*
