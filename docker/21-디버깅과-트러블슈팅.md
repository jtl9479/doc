# 21. 디버깅 및 트러블슈팅

## 목차
1. [Docker 디버깅 기초](#docker-디버깅-기초)
2. [컨테이너 로그 분석](#컨테이너-로그-분석)
3. [컨테이너 내부 검사](#컨테이너-내부-검사)
4. [네트워크 디버깅](#네트워크-디버깅)
5. [성능 문제 진단](#성능-문제-진단)
6. [이미지 문제 해결](#이미지-문제-해결)
7. [볼륨 문제 해결](#볼륨-문제-해결)
8. [일반적인 오류 패턴](#일반적인-오류-패턴)
9. [고급 디버깅 기법](#고급-디버깅-기법)
10. [트러블슈팅 체크리스트](#트러블슈팅-체크리스트)

---

## Docker 디버깅 기초

### 디버깅 마인드셋

**실생활 비유**: 탐정의 사건 수사

```
증상 발견 → 단서 수집 → 가설 수립 → 검증 → 해결

Docker 디버깅도 동일:
1. 무엇이 문제인가? (증상)
2. 어디서 발생했는가? (위치)
3. 언제 발생했는가? (시간)
4. 왜 발생했는가? (원인)
5. 어떻게 해결하나? (해결책)
```

### 기본 디버깅 명령어

```bash
# 1. 컨테이너 상태 확인
docker ps -a

# 2. 컨테이너 로그 확인
docker logs <container_id>

# 3. 컨테이너 상세 정보
docker inspect <container_id>

# 4. 컨테이너 내부 접속
docker exec -it <container_id> sh

# 5. 프로세스 확인
docker top <container_id>

# 6. 리소스 사용량
docker stats <container_id>

# 7. 파일 시스템 변경 사항
docker diff <container_id>

# 8. 이벤트 모니터링
docker events
```

### 디버깅 워크플로우

```
문제 발생
    ↓
1. docker ps -a (상태 확인)
    ↓
    컨테이너가 실행 중인가?
    ├─ Yes → 2. docker logs (로그 확인)
    │           ↓
    │        에러 메시지 확인
    │           ↓
    │        3. docker exec (내부 진입)
    │           ↓
    │        환경 변수, 파일, 네트워크 확인
    │
    └─ No → Exit Code 확인
              ↓
           docker logs (종료 원인)
              ↓
           Dockerfile/compose 검토
```

---

## 컨테이너 로그 분석

### 로그 확인 명령어

```bash
# 기본 로그 확인
docker logs <container_id>

# 실시간 로그 (tail -f)
docker logs -f <container_id>

# 최근 N줄만 확인
docker logs --tail 100 <container_id>

# 타임스탬프 포함
docker logs -t <container_id>

# 특정 시간 이후 로그
docker logs --since 2024-01-01T10:00:00 <container_id>

# 최근 1시간 로그
docker logs --since 1h <container_id>

# 특정 시간 이전 로그
docker logs --until 2024-01-01T12:00:00 <container_id>
```

### docker-compose 로그

```bash
# 모든 서비스 로그
docker-compose logs

# 특정 서비스 로그
docker-compose logs user-service

# 실시간 로그
docker-compose logs -f

# 최근 50줄
docker-compose logs --tail 50

# 여러 서비스 동시에
docker-compose logs user-service account-service
```

### 로그 필터링 및 분석

```bash
# grep으로 에러만 필터링
docker logs container_id 2>&1 | grep -i error

# 특정 패턴 검색
docker logs container_id 2>&1 | grep "connection refused"

# 에러 카운트
docker logs container_id 2>&1 | grep -c ERROR

# 여러 패턴 검색
docker logs container_id 2>&1 | grep -E "ERROR|FATAL|Exception"

# 타임라인 분석 (시간별 에러 수)
docker logs -t container_id 2>&1 | grep ERROR | awk '{print $1}' | uniq -c
```

### 로그 레벨별 분석

```bash
#!/bin/bash
# scripts/analyze-logs.sh

CONTAINER_ID=$1

echo "📊 로그 분석: $CONTAINER_ID"
echo ""

# 총 로그 라인 수
TOTAL=$(docker logs $CONTAINER_ID 2>&1 | wc -l)
echo "총 로그 라인: $TOTAL"

# 에러 레벨별 카운트
echo ""
echo "에러 레벨별 통계:"
echo "  ERROR:   $(docker logs $CONTAINER_ID 2>&1 | grep -c ERROR)"
echo "  WARN:    $(docker logs $CONTAINER_ID 2>&1 | grep -c WARN)"
echo "  INFO:    $(docker logs $CONTAINER_ID 2>&1 | grep -c INFO)"
echo "  DEBUG:   $(docker logs $CONTAINER_ID 2>&1 | grep -c DEBUG)"

# 최근 에러 메시지 (최근 5개)
echo ""
echo "최근 에러 메시지 (최근 5개):"
docker logs $CONTAINER_ID 2>&1 | grep ERROR | tail -5
```

### 로그 드라이버 설정

```yaml
# docker-compose.yml

services:
  user-service:
    image: user-service:latest
    logging:
      driver: json-file
      options:
        max-size: "10m"      # 최대 파일 크기
        max-file: "3"        # 최대 파일 개수
        labels: "service"
        env: "ENV,APP_VERSION"

  # syslog로 전송
  account-service:
    image: account-service:latest
    logging:
      driver: syslog
      options:
        syslog-address: "tcp://192.168.1.100:514"
        tag: "account-service"

  # fluentd로 전송
  trade-service:
    image: trade-service:latest
    logging:
      driver: fluentd
      options:
        fluentd-address: localhost:24224
        tag: trade-service
```

---

## 컨테이너 내부 검사

### 컨테이너 접속

```bash
# sh/bash 셸 실행
docker exec -it <container_id> sh
docker exec -it <container_id> bash

# 특정 명령어 실행
docker exec <container_id> ls -la /app
docker exec <container_id> cat /app/config.json
docker exec <container_id> ps aux

# 루트 권한으로 실행
docker exec -u root -it <container_id> sh

# 환경 변수 확인
docker exec <container_id> env

# 작업 디렉토리 지정
docker exec -w /app <container_id> ls -la
```

### 파일 시스템 검사

```bash
# 컨테이너 내부에서
$ ls -la /app
$ cat /app/config/application.yml
$ find /app -name "*.jar"
$ df -h  # 디스크 사용량

# 파일 존재 확인
docker exec container_id test -f /app/app.jar && echo "exists" || echo "not found"

# 디렉토리 구조 확인
docker exec container_id tree /app

# 파일 권한 확인
docker exec container_id ls -l /app/app.jar
```

### 프로세스 검사

```bash
# 실행 중인 프로세스
docker top <container_id>

# 컨테이너 내부에서 상세 확인
docker exec <container_id> ps aux
docker exec <container_id> ps -ef

# 특정 프로세스 검색
docker exec <container_id> ps aux | grep java

# 포트 리스닝 확인
docker exec <container_id> netstat -tuln

# 또는
docker exec <container_id> ss -tuln
```

### 환경 변수 검사

```bash
# 모든 환경 변수
docker exec <container_id> env

# 특정 환경 변수
docker exec <container_id> printenv DATABASE_URL

# docker inspect로 확인
docker inspect <container_id> | jq '.[0].Config.Env'

# docker-compose 환경 변수
docker-compose config
```

### 네트워크 인터페이스 검사

```bash
# IP 주소 확인
docker exec <container_id> ip addr

# 또는
docker exec <container_id> ifconfig

# 라우팅 테이블
docker exec <container_id> ip route

# DNS 확인
docker exec <container_id> cat /etc/resolv.conf

# 네트워크 연결 테스트
docker exec <container_id> ping -c 3 google.com
docker exec <container_id> curl -I https://google.com
```

---

## 네트워크 디버깅

### 컨테이너 간 통신 테스트

```bash
# 1. 컨테이너 IP 확인
docker inspect <container_id> | grep IPAddress

# 2. ping 테스트
docker exec container_a ping -c 3 container_b

# 3. 포트 연결 테스트
docker exec container_a nc -zv container_b 8080

# 또는 telnet
docker exec container_a telnet container_b 8080

# 4. HTTP 요청 테스트
docker exec container_a curl http://container_b:8080/health
```

### 네트워크 정보 확인

```bash
# Docker 네트워크 목록
docker network ls

# 네트워크 상세 정보
docker network inspect bridge

# 특정 네트워크에 연결된 컨테이너
docker network inspect my-network | jq '.[0].Containers'

# 컨테이너가 속한 네트워크
docker inspect container_id | jq '.[0].NetworkSettings.Networks'
```

### DNS 해석 문제

```bash
# 컨테이너 내부에서 DNS 테스트
docker exec container_id nslookup postgres
docker exec container_id dig postgres

# /etc/hosts 확인
docker exec container_id cat /etc/hosts

# DNS 서버 확인
docker exec container_id cat /etc/resolv.conf

# 커스텀 DNS 사용
docker run --dns 8.8.8.8 --dns 8.8.4.4 myapp:latest
```

### 포트 매핑 문제

```bash
# 포트 매핑 확인
docker port <container_id>

# 호스트에서 포트 사용 중 확인
netstat -tuln | grep 8080
# Windows
netstat -ano | findstr :8080

# 컨테이너 내부 포트 리스닝 확인
docker exec <container_id> netstat -tuln | grep 8080

# 방화벽 확인 (Linux)
sudo iptables -L -n | grep 8080

# 포트 포워딩 테스트
curl http://localhost:8080/health
```

### 네트워크 격리 문제

```yaml
# docker-compose.yml

services:
  frontend:
    networks:
      - frontend-net
      - backend-net  # 양쪽 네트워크 접근

  backend:
    networks:
      - backend-net
      - database-net

  database:
    networks:
      - database-net  # 데이터베이스 네트워크만

networks:
  frontend-net:
  backend-net:
  database-net:
```

**네트워크 연결 테스트**:

```bash
# frontend가 backend에 접근 가능한가?
docker-compose exec frontend ping backend

# backend가 database에 접근 가능한가?
docker-compose exec backend ping database

# frontend가 database에 직접 접근 불가능 (의도된 동작)
docker-compose exec frontend ping database
# ping: bad address 'database'
```

### 네트워크 디버깅 도구 설치

```bash
# 알파인 기반 컨테이너에 도구 설치
docker exec -u root container_id apk add --no-cache \
    curl \
    bind-tools \
    netcat-openbsd \
    tcpdump

# 데비안/우분투 기반
docker exec -u root container_id apt-get update && \
    apt-get install -y curl dnsutils netcat tcpdump
```

### 패킷 캡처

```bash
# 컨테이너 네트워크 인터페이스 확인
docker exec container_id ip link

# tcpdump로 패킷 캡처
docker exec container_id tcpdump -i eth0 -w /tmp/capture.pcap

# 특정 포트만 캡처
docker exec container_id tcpdump -i eth0 port 8080

# 컨테이너에서 호스트로 파일 복사
docker cp container_id:/tmp/capture.pcap ./capture.pcap

# Wireshark로 분석
wireshark capture.pcap
```

---

## 성능 문제 진단

### 리소스 사용량 모니터링

```bash
# 실시간 리소스 사용량
docker stats

# 특정 컨테이너만
docker stats user-service account-service

# 포맷 지정
docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"

# 1회만 출력
docker stats --no-stream
```

### CPU 사용량 분석

```bash
# CPU 사용률 높은 컨테이너 찾기
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}" | sort -k2 -rn

# 컨테이너 내부 프로세스 CPU 사용량
docker exec container_id top -bn1 | head -20

# CPU 제한 확인
docker inspect container_id | jq '.[0].HostConfig.CpuQuota'
docker inspect container_id | jq '.[0].HostConfig.CpuPeriod'
```

**CPU 프로파일링 (Java)**:

```bash
# JVM 스레드 덤프
docker exec container_id jstack 1 > thread-dump.txt

# CPU 사용 중인 스레드 찾기
docker exec container_id top -H -p 1
```

### 메모리 사용량 분석

```bash
# 메모리 사용량 확인
docker stats --no-stream --format "table {{.Name}}\t{{.MemUsage}}"

# 메모리 제한 확인
docker inspect container_id | jq '.[0].HostConfig.Memory'

# OOM Killer 로그 확인 (Linux)
dmesg | grep -i "killed process"
docker inspect container_id | jq '.[0].State.OOMKilled'
```

**메모리 프로파일링 (Java)**:

```bash
# 힙 덤프 생성
docker exec container_id jmap -dump:format=b,file=/tmp/heap.hprof 1

# 힙 덤프 복사
docker cp container_id:/tmp/heap.hprof ./heap.hprof

# Eclipse MAT 또는 VisualVM으로 분석
```

**메모리 누수 감지**:

```bash
#!/bin/bash
# scripts/memory-leak-detector.sh

CONTAINER_ID=$1
INTERVAL=60  # 60초마다 확인

echo "메모리 사용량 모니터링 시작: $CONTAINER_ID"
echo "시간, 메모리 사용량" > memory-usage.csv

while true; do
    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    MEM_USAGE=$(docker stats --no-stream --format "{{.MemUsage}}" $CONTAINER_ID)

    echo "$TIMESTAMP, $MEM_USAGE" >> memory-usage.csv
    echo "$TIMESTAMP - $MEM_USAGE"

    sleep $INTERVAL
done
```

### 디스크 I/O 분석

```bash
# 디스크 사용량
docker exec container_id df -h

# 대용량 파일 찾기
docker exec container_id du -sh /* | sort -hr | head -10

# I/O 통계
docker stats --format "table {{.Name}}\t{{.BlockIO}}"

# 컨테이너별 디스크 사용량
docker system df
docker system df -v
```

### 네트워크 I/O 분석

```bash
# 네트워크 사용량
docker stats --format "table {{.Name}}\t{{.NetIO}}"

# 컨테이너 내부에서 네트워크 모니터링
docker exec container_id iftop -i eth0
docker exec container_id nethogs

# 연결 수 확인
docker exec container_id netstat -an | wc -l
```

---

## 이미지 문제 해결

### 이미지 빌드 실패

```bash
# 빌드 로그 상세 출력
docker build --no-cache --progress=plain -t myapp:latest .

# 특정 단계까지만 빌드
docker build --target builder -t myapp:builder .

# 빌드 컨텍스트 크기 확인
tar -czf - . | wc -c

# .dockerignore 확인
cat .dockerignore
```

**일반적인 빌드 오류**:

```dockerfile
# ❌ 문제: COPY 실패
COPY app.jar /app/
# Error: no such file or directory

# ✅ 해결: 빌드 컨텍스트 확인
# app.jar가 Dockerfile과 같은 디렉토리에 있는지 확인
ls -la app.jar

# ❌ 문제: RUN 명령어 실패
RUN apt-get install -y nodejs
# E: Unable to locate package nodejs

# ✅ 해결: 패키지 업데이트
RUN apt-get update && apt-get install -y nodejs
```

### 이미지 레이어 분석

```bash
# 이미지 히스토리
docker history myapp:latest

# 상세 레이어 정보
docker history --no-trunc myapp:latest

# 레이어 크기 순으로 정렬
docker history --format "{{.Size}}\t{{.CreatedBy}}" myapp:latest | sort -hr

# dive 도구로 상세 분석
dive myapp:latest
```

### 이미지 크기 최적화

```bash
# 현재 이미지 크기
docker images myapp:latest

# 불필요한 레이어 제거
docker build --squash -t myapp:latest .

# 멀티스테이지 빌드 사용
# (Dockerfile에서 구현)

# 이미지 크기 비교
docker images | grep myapp
```

---

## 볼륨 문제 해결

### 볼륨 마운트 문제

```bash
# 볼륨 목록
docker volume ls

# 볼륨 상세 정보
docker volume inspect my-volume

# 컨테이너의 마운트 정보
docker inspect container_id | jq '.[0].Mounts'

# 볼륨 내용 확인
docker run --rm -v my-volume:/data alpine ls -la /data
```

**권한 문제**:

```bash
# 컨테이너 내부에서 권한 확인
docker exec container_id ls -la /app/data

# 소유자 변경
docker exec -u root container_id chown -R appuser:appuser /app/data

# Dockerfile에서 해결
COPY --chown=appuser:appuser . /app
```

### 볼륨 데이터 손실

```bash
# 익명 볼륨 찾기 (댕글링 볼륨)
docker volume ls -qf dangling=true

# 볼륨 백업
docker run --rm -v my-volume:/source -v $(pwd):/backup \
    alpine tar czf /backup/backup.tar.gz -C /source .

# 볼륨 복원
docker run --rm -v my-volume:/target -v $(pwd):/backup \
    alpine tar xzf /backup/backup.tar.gz -C /target

# 볼륨 마이그레이션
docker run --rm -v old-volume:/from -v new-volume:/to \
    alpine sh -c "cp -av /from/. /to/"
```

### 볼륨 성능 문제

```bash
# Docker Desktop (Mac/Windows): cached, delegated 옵션
volumes:
  - ./src:/app/src:cached  # 읽기 성능 향상

# Linux: 기본 설정이 최적

# 볼륨 I/O 테스트
docker run --rm -v my-volume:/data alpine \
    dd if=/dev/zero of=/data/testfile bs=1M count=100
```

---

## 일반적인 오류 패턴

### 1. "Cannot connect to Docker daemon"

```bash
# 증상
Cannot connect to the Docker daemon at unix:///var/run/docker.sock

# 원인 및 해결
# 1. Docker가 실행 중인지 확인
sudo systemctl status docker

# 2. Docker 시작
sudo systemctl start docker

# 3. 권한 확인 (Linux)
sudo usermod -aG docker $USER
# 로그아웃 후 재로그인

# 4. Docker Desktop (Windows/Mac) 확인
# Docker Desktop이 실행 중인지 확인
```

### 2. "Port is already allocated"

```bash
# 증상
Error: bind: address already in use

# 원인: 포트가 이미 사용 중

# 해결 1: 사용 중인 포트 찾기
netstat -tuln | grep 8080
lsof -i :8080  # Mac/Linux

# Windows
netstat -ano | findstr :8080

# 해결 2: 프로세스 종료
kill <PID>

# 해결 3: 다른 포트 사용
docker run -p 8081:8080 myapp:latest
```

### 3. "No space left on device"

```bash
# 증상
no space left on device

# 원인: 디스크 공간 부족

# 진단
docker system df
df -h

# 해결 1: 사용하지 않는 리소스 정리
docker system prune -a

# 해결 2: 특정 리소스 정리
docker image prune    # 댕글링 이미지
docker container prune  # 중지된 컨테이너
docker volume prune   # 사용하지 않는 볼륨

# 해결 3: 로그 정리
docker logs container_id --tail 0  # 로그 초기화
```

### 4. "Exec format error"

```bash
# 증상
exec format error

# 원인: 아키텍처 불일치 (ARM vs AMD64)

# 확인
docker inspect myapp:latest | jq '.[0].Architecture'
uname -m  # 호스트 아키텍처

# 해결: 멀티 아키텍처 빌드
docker buildx build --platform linux/amd64,linux/arm64 -t myapp:latest .
```

### 5. "OCI runtime create failed"

```bash
# 증상
OCI runtime create failed: ...

# 일반적인 원인 및 해결

# 1. 마운트 경로 문제
# ❌
volumes:
  - /nonexistent:/app
# ✅
volumes:
  - ./data:/app

# 2. 권한 문제
# ✅ 컨테이너를 루트로 실행
docker run --user root myapp:latest

# 3. 시스템 리소스 부족
# Docker Desktop: Settings > Resources > 메모리/CPU 증가
```

### 6. "Container unhealthy"

```bash
# 증상
Container is unhealthy

# 원인: 헬스체크 실패

# 진단
docker inspect container_id | jq '.[0].State.Health'

# 로그 확인
docker inspect container_id | jq '.[0].State.Health.Log'

# 헬스체크 수동 실행
docker exec container_id curl -f http://localhost:8080/health

# 해결: 헬스체크 조정
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  interval: 30s        # 간격 늘리기
  timeout: 10s         # 타임아웃 늘리기
  retries: 5           # 재시도 횟수 늘리기
  start_period: 60s    # 시작 대기 시간 늘리기
```

---

## 고급 디버깅 기법

### strace로 시스템 콜 추적

```bash
# strace 설치
docker exec -u root container_id apt-get update && \
    apt-get install -y strace

# 프로세스 추적
docker exec container_id strace -p 1

# 파일 I/O 추적
docker exec container_id strace -e trace=open,close,read,write -p 1

# 네트워크 콜 추적
docker exec container_id strace -e trace=network -p 1
```

### 컨테이너 이벤트 모니터링

```bash
# 실시간 이벤트
docker events

# 특정 컨테이너만
docker events --filter container=user-service

# 특정 이벤트만
docker events --filter event=start
docker events --filter event=die

# 시간 범위 지정
docker events --since 2024-01-01T00:00:00 --until 2024-01-01T23:59:59
```

### 디버그 컨테이너 실행

```bash
# 같은 네트워크에 디버그 컨테이너 실행
docker run -it --rm \
    --network container:user-service \
    nicolaka/netshoot

# 또는 같은 네트워크 공유
docker run -it --rm \
    --network lk-trade_default \
    nicolaka/netshoot

# 디버그 도구가 포함된 이미지
# - nicolaka/netshoot: 네트워크 디버깅
# - busybox: 기본 유닉스 도구
# - alpine: 가벼운 리눅스
```

### 컨테이너 체크포인트 및 복원

```bash
# 실험적 기능 활성화 필요

# 컨테이너 체크포인트 생성
docker checkpoint create container_id checkpoint1

# 체크포인트 목록
docker checkpoint ls container_id

# 체크포인트에서 복원
docker start --checkpoint checkpoint1 container_id
```

---

## 트러블슈팅 체크리스트

### 컨테이너가 시작하지 않을 때

```
□ docker ps -a로 Exit Code 확인
  - 0: 정상 종료
  - 1: 애플리케이션 오류
  - 137: OOM Killed
  - 139: Segmentation Fault
  - 143: SIGTERM

□ docker logs로 오류 메시지 확인

□ docker inspect로 설정 확인
  - Cmd, Entrypoint
  - Environment
  - Mounts
  - Networks

□ Dockerfile 검토
  - CMD/ENTRYPOINT 올바른가?
  - 필요한 파일 모두 COPY되었나?
  - 권한 문제 없나?

□ 의존성 확인
  - depends_on 설정
  - 데이터베이스/Redis 준비되었나?
```

### 네트워크 문제 체크리스트

```
□ 컨테이너 IP 주소 확인
  docker inspect container_id | grep IPAddress

□ 같은 네트워크인가?
  docker network inspect network_name

□ DNS 해석 되는가?
  docker exec container_id ping target_container

□ 포트 리스닝 중인가?
  docker exec container_id netstat -tuln

□ 방화벽/보안 그룹 확인

□ 서비스 이름 사용하는가?
  (localhost ❌, service_name ✅)
```

### 성능 문제 체크리스트

```
□ docker stats로 리소스 사용량 확인

□ 리소스 제한 확인
  docker inspect | grep -i "cpu\|memory"

□ 로그 파일 크기 확인
  docker logs --tail 1 container_id

□ 볼륨 I/O 성능 확인

□ 네트워크 지연 확인
  docker exec container_id ping -c 10 target

□ 애플리케이션 프로파일링
  (JProfiler, pprof, py-spy 등)
```

### 데이터 손실 체크리스트

```
□ 볼륨 사용 중인가?
  docker inspect container_id | jq '.[0].Mounts'

□ 익명 볼륨인가? (이름 있는 볼륨으로 변경)

□ --rm 옵션 사용하지 않았나?

□ docker-compose down -v 실행하지 않았나?

□ 백업 존재하는가?
  docker volume ls
```

---

## 실전 디버깅 시나리오

### 시나리오 1: "Service Unavailable"

```bash
# 1. 증상
$ curl http://localhost:8081/api/users
Service Unavailable

# 2. 컨테이너 상태 확인
$ docker ps
CONTAINER ID   STATUS                    PORTS
a1b2c3d4e5f6   Up 2 minutes (unhealthy)  0.0.0.0:8081->8080/tcp

# 3. 헬스체크 로그 확인
$ docker inspect user-service | jq '.[0].State.Health.Log'
[
  {
    "ExitCode": 1,
    "Output": "curl: (7) Failed to connect to localhost port 8080"
  }
]

# 4. 컨테이너 로그 확인
$ docker logs user-service
Error: Cannot connect to database at postgres:5432
Connection refused

# 5. 데이터베이스 확인
$ docker ps | grep postgres
(아무것도 없음)

# 6. 원인: 데이터베이스 시작 안됨
$ docker-compose up -d postgres

# 7. 서비스 재시작
$ docker-compose restart user-service

# 8. 확인
$ curl http://localhost:8081/health
{"status":"UP"}
```

### 시나리오 2: 메모리 부족

```bash
# 1. 증상
$ docker ps -a
CONTAINER ID   STATUS                      NAMES
a1b2c3d4e5f6   Exited (137) 1 minute ago   user-service

# Exit Code 137 = OOM Killed

# 2. 메모리 제한 확인
$ docker inspect user-service | jq '.[0].HostConfig.Memory'
536870912  # 512MB

# 3. 로그 확인
$ docker logs user-service --tail 50
java.lang.OutOfMemoryError: Java heap space

# 4. 해결: 메모리 증가
# docker-compose.yml
services:
  user-service:
    mem_limit: 1g
    environment:
      - JAVA_OPTS=-Xmx768m

# 5. 재시작
$ docker-compose up -d user-service
```

### 시나리오 3: 느린 응답

```bash
# 1. 증상
$ curl http://localhost:8081/api/users
(5초 후 응답)

# 2. 리소스 확인
$ docker stats user-service
CONTAINER   CPU %   MEM USAGE / LIMIT   MEM %
user-service  98%   450MiB / 512MiB     87.8%

# CPU 거의 100% 사용 중!

# 3. 프로세스 확인
$ docker exec user-service top
  PID USER      PR  NI    VIRT    RES  %CPU  %MEM
    1 root      20   0  2.5g    450m  98.0  11.2  java

# 4. 스레드 덤프
$ docker exec user-service jstack 1 > thread-dump.txt

# 5. 분석: 무한 루프 발견
# (코드 수정 필요)

# 6. 임시 해결: CPU 제한 완화
# docker-compose.yml
services:
  user-service:
    cpus: "2.0"  # 1.0 → 2.0

# 7. 근본 해결: 코드 수정 후 재배포
```

---

## 유용한 디버깅 도구

### ctop (컨테이너 top)

```bash
# 설치
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    quay.io/vektorlab/ctop:latest

# 실시간 컨테이너 모니터링
```

### lazydocker

```bash
# 설치
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v ~/.config/lazydocker:/.config/jesseduffield/lazydocker \
    lazyteam/lazydocker

# TUI 인터페이스로 Docker 관리
```

### dive (이미지 분석)

```bash
# 설치
docker pull wagoodman/dive

# 이미지 레이어 분석
docker run --rm -it \
    -v /var/run/docker.sock:/var/run/docker.sock \
    wagoodman/dive:latest myapp:latest
```

---

## 다음 단계

### 22. 일일 개발 루틴
- 개발 환경 시작
- 개발 중 모니터링
- 코드 변경 시 재빌드

### 학습 자료

**디버깅**:
- [Docker Debugging Guide](https://docs.docker.com/config/containers/logging/)
- [Troubleshooting Docker](https://docs.docker.com/config/daemon/troubleshoot/)

**도구**:
- [ctop](https://github.com/bcicen/ctop)
- [lazydocker](https://github.com/jesseduffield/lazydocker)
- [dive](https://github.com/wagoodman/dive)

---

**축하합니다! 🎉** Docker 디버깅과 트러블슈팅 마스터!