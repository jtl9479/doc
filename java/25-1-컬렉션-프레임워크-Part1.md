# 25장 컬렉션 프레임워크 개요 Part 1 - 실생활 비유로 이해하기 📚

## 🌟 실생활 비유로 이해하기

컬렉션 프레임워크(Collection Framework)는 데이터를 저장하고 관리하는 표준화된 방법을 제공하는 Java의 핵심 라이브러리입니다. 배열의 한계를 극복하고, 다양한 자료구조를 일관된 인터페이스로 제공합니다.

---

## 비유 1: 도서관 분류 시스템 📖

도서관은 책을 체계적으로 분류하여 관리합니다. 컬렉션 프레임워크의 계층 구조는 이런 "체계적인 분류 시스템"과 같습니다.

### 실생활 상황
- **최상위 분류**: Collection (소설/비소설)과 Map (주제별 카탈로그)
- **중간 분류**: List (연속 서가), Set (중복 없는 목록), Queue (대출 대기)
- **구체적 서가**: ArrayList (오픈 서가), LinkedList (연결 서가), HashSet (해시 분류)

### 코드 예시

```java
import java.util.*;

// 도서관 책 클래스
class Book {
    private String isbn;  // 고유 번호
    private String title;
    private String author;
    private String category;

    public Book(String isbn, String title, String author, String category) {
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        this.category = category;
    }

    public String getIsbn() { return isbn; }
    public String getTitle() { return title; }
    public String getAuthor() { return author; }
    public String getCategory() { return category; }

    @Override
    public String toString() {
        return "《" + title + "》 - " + author + " [" + category + "]";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Book)) return false;
        Book book = (Book) o;
        return isbn.equals(book.isbn);  // ISBN으로 동일성 판단
    }

    @Override
    public int hashCode() {
        return Objects.hash(isbn);
    }
}

// 도서관 시스템
class Library {
    // Collection 계층 구조 시연

    // 1. List - 입고 순서대로 관리 (순서 O, 중복 O)
    private List<Book> newArrivals = new ArrayList<>();

    // 2. Set - 전체 소장 도서 (순서 X, 중복 X)
    private Set<Book> allBooks = new HashSet<>();

    // 3. Queue - 대출 대기열 (FIFO)
    private Queue<String> waitingList = new LinkedList<>();

    // 4. Map - ISBN으로 빠른 검색 (Key-Value)
    private Map<String, Book> isbnIndex = new HashMap<>();

    public void addNewBook(Book book) {
        newArrivals.add(book);  // List: 순서대로 추가
        allBooks.add(book);     // Set: 중복 자동 제거
        isbnIndex.put(book.getIsbn(), book);  // Map: 인덱싱

        System.out.println("✅ 신간 등록: " + book);
    }

    public void showNewArrivals() {
        System.out.println("\n📚 신간 도서 (입고 순서):");
        for (int i = 0; i < newArrivals.size(); i++) {
            System.out.println("   " + (i+1) + ". " + newArrivals.get(i));
        }
    }

    public void showAllBooks() {
        System.out.println("\n📖 전체 소장 도서 (" + allBooks.size() + "권):");
        for (Book book : allBooks) {
            System.out.println("   - " + book);
        }
    }

    public void searchByIsbn(String isbn) {
        System.out.println("\n🔍 ISBN 검색: " + isbn);
        Book found = isbnIndex.get(isbn);
        if (found != null) {
            System.out.println("   찾음: " + found);
        } else {
            System.out.println("   해당 ISBN의 책이 없습니다.");
        }
    }

    public void addToWaitingList(String memberName) {
        waitingList.offer(memberName);
        System.out.println("📝 대출 대기 등록: " + memberName +
                         " (대기 " + waitingList.size() + "번째)");
    }

    public void processWaitingList() {
        System.out.println("\n🔔 대출 대기열 처리:");
        while (!waitingList.isEmpty()) {
            String member = waitingList.poll();  // FIFO 순서
            System.out.println("   " + member + "님 차례입니다.");
        }
    }

    // 컬렉션 프레임워크 특징 시연
    public void demonstrateCollectionFeatures() {
        System.out.println("\n=== 컬렉션 프레임워크 특징 ===\n");

        // 특징 1: 동적 크기
        System.out.println("1. 동적 크기 조정:");
        System.out.println("   신간 리스트 크기: " + newArrivals.size());
        newArrivals.add(new Book("ISBN-999", "테스트", "작가", "기타"));
        System.out.println("   추가 후 크기: " + newArrivals.size());
        System.out.println("   (배열과 달리 자동으로 확장!)");

        // 특징 2: 타입 안전성 (제네릭)
        System.out.println("\n2. 타입 안전성 (제네릭):");
        // List<Book> books = new ArrayList<>();
        // books.add("문자열");  // ❌ 컴파일 에러! Book만 가능
        System.out.println("   List<Book>은 Book 타입만 허용");

        // 특징 3: 통일된 인터페이스
        System.out.println("\n3. 통일된 인터페이스:");
        Collection<Book> collection1 = new ArrayList<>();  // List → Collection
        Collection<Book> collection2 = new HashSet<>();    // Set → Collection
        System.out.println("   ArrayList와 HashSet 모두 Collection 인터페이스 구현");
        System.out.println("   → add(), remove(), size() 등 공통 메서드 사용 가능");

        // 특징 4: 다양한 구현체
        System.out.println("\n4. 다양한 구현체:");
        System.out.println("   List: ArrayList (빠른 조회), LinkedList (빠른 삽입/삭제)");
        System.out.println("   Set: HashSet (빠른 검색), TreeSet (정렬 유지)");
        System.out.println("   Map: HashMap (빠른 검색), TreeMap (정렬 유지)");
    }
}

public class LibraryCollectionExample {
    public static void main(String[] args) {
        System.out.println("=== 도서관 컬렉션 시스템 ===\n");

        Library library = new Library();

        // 신간 등록
        library.addNewBook(new Book("ISBN-001", "Effective Java", "Joshua Bloch", "프로그래밍"));
        library.addNewBook(new Book("ISBN-002", "Clean Code", "Robert Martin", "프로그래밍"));
        library.addNewBook(new Book("ISBN-003", "Java의 정석", "남궁성", "프로그래밍"));
        library.addNewBook(new Book("ISBN-001", "Effective Java", "Joshua Bloch", "프로그래밍"));  // 중복!

        // List: 순서 유지, 중복 허용
        library.showNewArrivals();

        // Set: 중복 제거
        library.showAllBooks();

        // Map: 빠른 검색
        library.searchByIsbn("ISBN-002");
        library.searchByIsbn("ISBN-999");

        // Queue: FIFO 처리
        System.out.println();
        library.addToWaitingList("김철수");
        library.addToWaitingList("이영희");
        library.addToWaitingList("박민수");
        library.processWaitingList();

        // 컬렉션 프레임워크 특징
        library.demonstrateCollectionFeatures();

        System.out.println("\n\n✅ 컬렉션 프레임워크 계층 구조:");
        System.out.println("Iterable");
        System.out.println("  ├─ Collection");
        System.out.println("  │   ├─ List (ArrayList, LinkedList, Vector)");
        System.out.println("  │   ├─ Set (HashSet, TreeSet, LinkedHashSet)");
        System.out.println("  │   └─ Queue (LinkedList, PriorityQueue)");
        System.out.println("  └─ Map (HashMap, TreeMap, LinkedHashMap)");
    }
}
```

### 실행 결과
```
=== 도서관 컬렉션 시스템 ===

✅ 신간 등록: 《Effective Java》 - Joshua Bloch [프로그래밍]
✅ 신간 등록: 《Clean Code》 - Robert Martin [프로그래밍]
✅ 신간 등록: 《Java의 정석》 - 남궁성 [프로그래밍]
✅ 신간 등록: 《Effective Java》 - Joshua Bloch [프로그래밍]

📚 신간 도서 (입고 순서):
   1. 《Effective Java》 - Joshua Bloch [프로그래밍]
   2. 《Clean Code》 - Robert Martin [프로그래밍]
   3. 《Java의 정석》 - 남궁성 [프로그래밍]
   4. 《Effective Java》 - Joshua Bloch [프로그래밍]

📖 전체 소장 도서 (3권):
   - 《Clean Code》 - Robert Martin [프로그래밍]
   - 《Java의 정석》 - 남궁성 [프로그래밍]
   - 《Effective Java》 - Joshua Bloch [프로그래밍]

🔍 ISBN 검색: ISBN-002
   찾음: 《Clean Code》 - Robert Martin [프로그래밍]

🔍 ISBN 검색: ISBN-999
   해당 ISBN의 책이 없습니다.

📝 대출 대기 등록: 김철수 (대기 1번째)
📝 대출 대기 등록: 이영희 (대기 2번째)
📝 대출 대기 등록: 박민수 (대기 3번째)

🔔 대출 대기열 처리:
   김철수님 차례입니다.
   이영희님 차례입니다.
   박민수님 차례입니다.

=== 컬렉션 프레임워크 특징 ===

1. 동적 크기 조정:
   신간 리스트 크기: 4
   추가 후 크기: 5
   (배열과 달리 자동으로 확장!)

2. 타입 안전성 (제네릭):
   List<Book>은 Book 타입만 허용

3. 통일된 인터페이스:
   ArrayList와 HashSet 모두 Collection 인터페이스 구현
   → add(), remove(), size() 등 공통 메서드 사용 가능

4. 다양한 구현체:
   List: ArrayList (빠른 조회), LinkedList (빠른 삽입/삭제)
   Set: HashSet (빠른 검색), TreeSet (정렬 유지)
   Map: HashMap (빠른 검색), TreeMap (정렬 유지)


✅ 컬렉션 프레임워크 계층 구조:
Iterable
  ├─ Collection
  │   ├─ List (ArrayList, LinkedList, Vector)
  │   ├─ Set (HashSet, TreeSet, LinkedHashSet)
  │   └─ Queue (LinkedList, PriorityQueue)
  └─ Map (HashMap, TreeMap, LinkedHashMap)
```

### 핵심 정리
- **Collection**: List, Set, Queue의 공통 인터페이스
- **Map**: Key-Value 쌍, Collection과 별도 계층
- **특징**: 동적 크기, 타입 안전성, 통일된 인터페이스, 다양한 구현체

---

## 비유 2: 놀이공원 줄 서기 시스템 🎢

놀이공원에서 사람들이 줄을 서는 것처럼, List는 순서를 유지하고 중복을 허용하는 자료구조입니다.

### 실생활 상황
- **순서 보장**: 먼저 온 사람이 앞에 위치
- **중복 허용**: 같은 사람이 여러 번 탈 수 있음
- **인덱스 접근**: "앞에서 3번째 사람"처럼 위치로 접근

### 코드 예시

```java
import java.util.*;

class Visitor {
    private String name;
    private int age;
    private String ticketType;

    public Visitor(String name, int age, String ticketType) {
        this.name = name;
        this.age = age;
        this.ticketType = ticketType;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
    public String getTicketType() { return ticketType; }

    @Override
    public String toString() {
        return name + "(" + age + "세, " + ticketType + ")";
    }
}

class RideQueue {
    private List<Visitor> queue = new ArrayList<>();
    private String rideName;

    public RideQueue(String rideName) {
        this.rideName = rideName;
    }

    // List 특징 1: 순서대로 추가
    public void joinQueue(Visitor visitor) {
        queue.add(visitor);
        System.out.println("✅ " + visitor.getName() + "님 입장 - " +
                         "현재 대기: " + queue.size() + "명");
    }

    // List 특징 2: 인덱스로 접근 가능
    public void showPosition(int index) {
        if (index >= 0 && index < queue.size()) {
            System.out.println((index + 1) + "번째: " + queue.get(index));
        } else {
            System.out.println("유효하지 않은 위치입니다.");
        }
    }

    // List 특징 3: 순서 유지
    public void showQueue() {
        System.out.println("\n🎢 " + rideName + " 대기열:");
        for (int i = 0; i < queue.size(); i++) {
            System.out.println("   " + (i+1) + "번째: " + queue.get(i));
        }
        System.out.println("   총 대기: " + queue.size() + "명\n");
    }

    // List 특징 4: 중간 삽입/삭제
    public void skipLine(Visitor vip, int position) {
        if (position >= 0 && position <= queue.size()) {
            queue.add(position, vip);  // 특정 위치에 삽입
            System.out.println("⭐ VIP " + vip.getName() + "님 " +
                             (position + 1) + "번째에 삽입");
        }
    }

    // List 특징 5: 순서대로 처리 (FIFO)
    public void processQueue(int count) {
        System.out.println("🎫 탑승 시작:");
        for (int i = 0; i < count && !queue.isEmpty(); i++) {
            Visitor visitor = queue.remove(0);  // 첫 번째 제거
            System.out.println("   " + (i+1) + ". " + visitor.getName() + "님 탑승");
        }
        System.out.println("   남은 대기: " + queue.size() + "명\n");
    }

    // ArrayList vs LinkedList 성능 비교
    public static void comparePerformance() {
        System.out.println("=== ArrayList vs LinkedList 성능 비교 ===\n");

        int size = 100000;

        // ArrayList 테스트
        List<Integer> arrayList = new ArrayList<>();
        long start = System.currentTimeMillis();

        // 1. 끝에 추가 - ArrayList 빠름
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        long arrayListAdd = System.currentTimeMillis() - start;

        // 2. 인덱스 조회 - ArrayList 매우 빠름
        start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            arrayList.get(size / 2);
        }
        long arrayListGet = System.currentTimeMillis() - start;

        // LinkedList 테스트
        List<Integer> linkedList = new LinkedList<>();
        start = System.currentTimeMillis();

        // 1. 끝에 추가 - LinkedList도 빠름
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        long linkedListAdd = System.currentTimeMillis() - start;

        // 2. 인덱스 조회 - LinkedList 느림
        start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            linkedList.get(size / 2);
        }
        long linkedListGet = System.currentTimeMillis() - start;

        // 3. 앞에 삽입 - LinkedList 빠름
        start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            linkedList.add(0, i);
        }
        long linkedListInsert = System.currentTimeMillis() - start;

        start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            arrayList.add(0, i);
        }
        long arrayListInsert = System.currentTimeMillis() - start;

        System.out.println("📊 성능 테스트 결과 (" + size + "개 요소):\n");
        System.out.println("1. 끝에 추가 (add):");
        System.out.println("   ArrayList:  " + arrayListAdd + "ms ✅");
        System.out.println("   LinkedList: " + linkedListAdd + "ms ✅");

        System.out.println("\n2. 중간 조회 (get):");
        System.out.println("   ArrayList:  " + arrayListGet + "ms ✅ 빠름!");
        System.out.println("   LinkedList: " + linkedListGet + "ms ⚠️ 느림");

        System.out.println("\n3. 앞에 삽입 (add(0, item)):");
        System.out.println("   ArrayList:  " + arrayListInsert + "ms ⚠️ 느림");
        System.out.println("   LinkedList: " + linkedListInsert + "ms ✅ 빠름!");

        System.out.println("\n✅ 선택 기준:");
        System.out.println("   - 조회가 많음 → ArrayList");
        System.out.println("   - 삽입/삭제가 많음 → LinkedList");
    }
}

public class RideQueueExample {
    public static void main(String[] args) {
        System.out.println("=== 놀이공원 줄 서기 시스템 (List) ===\n");

        RideQueue rollerCoaster = new RideQueue("롤러코스터");

        // 방문객 입장
        rollerCoaster.joinQueue(new Visitor("김철수", 25, "일반"));
        rollerCoaster.joinQueue(new Visitor("이영희", 30, "일반"));
        rollerCoaster.joinQueue(new Visitor("박민수", 28, "일반"));
        rollerCoaster.joinQueue(new Visitor("최지훈", 22, "일반"));

        // 순서 확인
        rollerCoaster.showQueue();

        // 인덱스로 특정 위치 확인
        System.out.println("특정 위치 조회:");
        rollerCoaster.showPosition(0);  // 첫 번째
        rollerCoaster.showPosition(2);  // 세 번째
        System.out.println();

        // VIP 새치기
        rollerCoaster.skipLine(new Visitor("정VIP", 35, "VIP"), 1);
        rollerCoaster.showQueue();

        // 탑승 처리
        rollerCoaster.processQueue(3);  // 3명 탑승
        rollerCoaster.showQueue();

        // 성능 비교
        System.out.println();
        RideQueue.comparePerformance();

        System.out.println("\n\n✅ List의 핵심 특징:");
        System.out.println("1. 순서 유지: 추가한 순서대로 보관");
        System.out.println("2. 인덱스 접근: get(index)로 빠른 조회");
        System.out.println("3. 중복 허용: 같은 요소 여러 번 추가 가능");
        System.out.println("4. null 허용: null 값도 저장 가능");
        System.out.println("5. 구현체: ArrayList (조회 빠름), LinkedList (삽입/삭제 빠름)");
    }
}
```

### 실행 결과
```
=== 놀이공원 줄 서기 시스템 (List) ===

✅ 김철수님 입장 - 현재 대기: 1명
✅ 이영희님 입장 - 현재 대기: 2명
✅ 박민수님 입장 - 현재 대기: 3명
✅ 최지훈님 입장 - 현재 대기: 4명

🎢 롤러코스터 대기열:
   1번째: 김철수(25세, 일반)
   2번째: 이영희(30세, 일반)
   3번째: 박민수(28세, 일반)
   4번째: 최지훈(22세, 일반)
   총 대기: 4명

특정 위치 조회:
1번째: 김철수(25세, 일반)
3번째: 박민수(28세, 일반)

⭐ VIP 정VIP님 2번째에 삽입

🎢 롤러코스터 대기열:
   1번째: 김철수(25세, 일반)
   2번째: 정VIP(35세, VIP)
   3번째: 이영희(30세, 일반)
   4번째: 박민수(28세, 일반)
   5번째: 최지훈(22세, 일반)
   총 대기: 5명

🎫 탑승 시작:
   1. 김철수님 탑승
   2. 정VIP님 탑승
   3. 이영희님 탑승
   남은 대기: 2명

🎢 롤러코스터 대기열:
   1번째: 박민수(28세, 일반)
   2번째: 최지훈(22세, 일반)
   총 대기: 2명

=== ArrayList vs LinkedList 성능 비교 ===

📊 성능 테스트 결과 (100000개 요소):

1. 끝에 추가 (add):
   ArrayList:  5ms ✅
   LinkedList: 7ms ✅

2. 중간 조회 (get):
   ArrayList:  0ms ✅ 빠름!
   LinkedList: 325ms ⚠️ 느림

3. 앞에 삽입 (add(0, item)):
   ArrayList:  892ms ⚠️ 느림
   LinkedList: 1ms ✅ 빠름!

✅ 선택 기준:
   - 조회가 많음 → ArrayList
   - 삽입/삭제가 많음 → LinkedList


✅ List의 핵심 특징:
1. 순서 유지: 추가한 순서대로 보관
2. 인덱스 접근: get(index)로 빠른 조회
3. 중복 허용: 같은 요소 여러 번 추가 가능
4. null 허용: null 값도 저장 가능
5. 구현체: ArrayList (조회 빠름), LinkedList (삽입/삭제 빠름)
```

### 핵심 정리
- **List 인터페이스**: 순서 유지, 인덱스 접근, 중복 허용
- **ArrayList**: 배열 기반, 조회 O(1), 삽입/삭제 O(n)
- **LinkedList**: 연결 리스트 기반, 조회 O(n), 삽입/삭제 O(1)
- **실생활 비유**: 놀이공원 줄 = 순서가 중요한 List

---

## 비유 3: 헬스장 회원 명부 🏋️

헬스장 회원 명부는 중복 없이 회원을 관리합니다. Set은 이런 "중복 불허 집합"과 같습니다.

### 실생활 상황
- **중복 불허**: 같은 회원은 한 번만 등록
- **순서 무관**: 등록 순서는 중요하지 않음 (HashSet)
- **빠른 검색**: 회원 번호로 빠른 조회

### 코드 예시

```java
import java.util.*;

class GymMember {
    private String memberId;
    private String name;
    private String membershipType;

    public GymMember(String memberId, String name, String membershipType) {
        this.memberId = memberId;
        this.name = name;
        this.membershipType = membershipType;
    }

    public String getMemberId() { return memberId; }
    public String getName() { return name; }
    public String getMembershipType() { return membershipType; }

    @Override
    public String toString() {
        return name + " [" + memberId + ", " + membershipType + "]";
    }

    // equals와 hashCode 구현 - Set의 핵심!
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof GymMember)) return false;
        GymMember that = (GymMember) o;
        return memberId.equals(that.memberId);  // memberId로 동일성 판단
    }

    @Override
    public int hashCode() {
        return Objects.hash(memberId);
    }
}

class GymManagement {
    // HashSet: 순서 X, 중복 X, 빠른 검색
    private Set<GymMember> members = new HashSet<>();

    // Set 특징 1: 중복 자동 제거
    public void registerMember(GymMember member) {
        boolean added = members.add(member);
        if (added) {
            System.out.println("✅ 회원 등록: " + member.getName());
        } else {
            System.out.println("❌ 이미 등록된 회원: " + member.getName() +
                             " (중복 등록 불가)");
        }
    }

    // Set 특징 2: 포함 여부 확인 (빠름!)
    public void checkMembership(GymMember member) {
        if (members.contains(member)) {
            System.out.println("✅ " + member.getName() + "님은 등록된 회원입니다.");
        } else {
            System.out.println("❌ " + member.getName() + "님은 미등록 회원입니다.");
        }
    }

    // Set 특징 3: 전체 조회 (순서 보장 안 됨)
    public void showAllMembers() {
        System.out.println("\n🏋️ 전체 회원 목록 (" + members.size() + "명):");
        for (GymMember member : members) {
            System.out.println("   - " + member);
        }
        System.out.println();
    }

    // Set 특징 4: 삭제
    public void removeMember(String memberId) {
        GymMember toRemove = null;
        for (GymMember member : members) {
            if (member.getMemberId().equals(memberId)) {
                toRemove = member;
                break;
            }
        }

        if (toRemove != null) {
            members.remove(toRemove);
            System.out.println("🗑️ 회원 탈퇴: " + toRemove.getName());
        } else {
            System.out.println("❌ 해당 회원 ID를 찾을 수 없습니다: " + memberId);
        }
    }

    // HashSet vs TreeSet 비교
    public static void compareSetTypes() {
        System.out.println("=== HashSet vs TreeSet 비교 ===\n");

        // HashSet: 순서 없음, 빠른 검색
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Charlie");
        hashSet.add("Alice");
        hashSet.add("Bob");
        hashSet.add("David");

        System.out.println("HashSet (순서 보장 안 됨):");
        System.out.println("   " + hashSet);

        // TreeSet: 자동 정렬, 느린 검색
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("Charlie");
        treeSet.add("Alice");
        treeSet.add("Bob");
        treeSet.add("David");

        System.out.println("\nTreeSet (자동 정렬):");
        System.out.println("   " + treeSet);

        // LinkedHashSet: 삽입 순서 유지
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Charlie");
        linkedHashSet.add("Alice");
        linkedHashSet.add("Bob");
        linkedHashSet.add("David");

        System.out.println("\nLinkedHashSet (삽입 순서 유지):");
        System.out.println("   " + linkedHashSet);

        System.out.println("\n✅ Set 구현체 선택:");
        System.out.println("   - HashSet: 순서 무관, 최고 성능 (O(1) 검색)");
        System.out.println("   - TreeSet: 정렬 필요, 느린 성능 (O(log n) 검색)");
        System.out.println("   - LinkedHashSet: 삽입 순서 유지, 중간 성능");
    }

    // Set 집합 연산
    public static void setOperations() {
        System.out.println("\n=== Set 집합 연산 ===\n");

        Set<String> morning = new HashSet<>(Arrays.asList("김철수", "이영희", "박민수"));
        Set<String> evening = new HashSet<>(Arrays.asList("이영희", "박민수", "최지훈"));

        System.out.println("아침 회원: " + morning);
        System.out.println("저녁 회원: " + evening);

        // 1. 합집합 (Union)
        Set<String> union = new HashSet<>(morning);
        union.addAll(evening);
        System.out.println("\n합집합 (전체 회원): " + union);

        // 2. 교집합 (Intersection)
        Set<String> intersection = new HashSet<>(morning);
        intersection.retainAll(evening);
        System.out.println("교집합 (아침+저녁 모두 등록): " + intersection);

        // 3. 차집합 (Difference)
        Set<String> difference = new HashSet<>(morning);
        difference.removeAll(evening);
        System.out.println("차집합 (아침만 등록): " + difference);
    }
}

public class GymMembershipExample {
    public static void main(String[] args) {
        System.out.println("=== 헬스장 회원 관리 시스템 (Set) ===\n");

        GymManagement gym = new GymManagement();

        // 회원 등록
        GymMember member1 = new GymMember("M001", "김철수", "1개월");
        GymMember member2 = new GymMember("M002", "이영희", "3개월");
        GymMember member3 = new GymMember("M003", "박민수", "6개월");

        gym.registerMember(member1);
        gym.registerMember(member2);
        gym.registerMember(member3);

        // 중복 등록 시도
        System.out.println();
        GymMember duplicate = new GymMember("M001", "김철수", "1개월");
        gym.registerMember(duplicate);  // 중복 방지!

        // 전체 회원 조회
        gym.showAllMembers();

        // 회원 확인
        gym.checkMembership(member1);
        gym.checkMembership(new GymMember("M999", "홍길동", "1개월"));

        // 회원 탈퇴
        System.out.println();
        gym.removeMember("M002");
        gym.showAllMembers();

        // Set 구현체 비교
        System.out.println();
        GymManagement.compareSetTypes();

        // 집합 연산
        GymManagement.setOperations();

        System.out.println("\n\n✅ Set의 핵심 특징:");
        System.out.println("1. 중복 불허: 같은 요소 한 번만 저장");
        System.out.println("2. 순서 무관: HashSet은 순서 보장 안 함");
        System.out.println("3. 빠른 검색: contains() O(1) (HashSet 기준)");
        System.out.println("4. null 허용: null도 한 개만 저장");
        System.out.println("5. equals/hashCode: 중복 판단에 필수!");
    }
}
```

### 실행 결과
```
=== 헬스장 회원 관리 시스템 (Set) ===

✅ 회원 등록: 김철수
✅ 회원 등록: 이영희
✅ 회원 등록: 박민수

❌ 이미 등록된 회원: 김철수 (중복 등록 불가)

🏋️ 전체 회원 목록 (3명):
   - 박민수 [M003, 6개월]
   - 이영희 [M002, 3개월]
   - 김철수 [M001, 1개월]

✅ 김철수님은 등록된 회원입니다.
❌ 홍길동님은 미등록 회원입니다.

🗑️ 회원 탈퇴: 이영희

🏋️ 전체 회원 목록 (2명):
   - 박민수 [M003, 6개월]
   - 김철수 [M001, 1개월]

=== HashSet vs TreeSet 비교 ===

HashSet (순서 보장 안 됨):
   [Bob, Charlie, David, Alice]

TreeSet (자동 정렬):
   [Alice, Bob, Charlie, David]

LinkedHashSet (삽입 순서 유지):
   [Charlie, Alice, Bob, David]

✅ Set 구현체 선택:
   - HashSet: 순서 무관, 최고 성능 (O(1) 검색)
   - TreeSet: 정렬 필요, 느린 성능 (O(log n) 검색)
   - LinkedHashSet: 삽입 순서 유지, 중간 성능

=== Set 집합 연산 ===

아침 회원: [박민수, 이영희, 김철수]
저녁 회원: [박민수, 이영희, 최지훈]

합집합 (전체 회원): [박민수, 이영희, 김철수, 최지훈]
교집합 (아침+저녁 모두 등록): [박민수, 이영희]
차집합 (아침만 등록): [김철수]


✅ Set의 핵심 특징:
1. 중복 불허: 같은 요소 한 번만 저장
2. 순서 무관: HashSet은 순서 보장 안 함
3. 빠른 검색: contains() O(1) (HashSet 기준)
4. null 허용: null도 한 개만 저장
5. equals/hashCode: 중복 판단에 필수!
```

### 핵심 정리
- **Set 인터페이스**: 중복 불허, 순서 무관 (HashSet 기준)
- **HashSet**: 해시 테이블 기반, O(1) 검색, 순서 보장 안 함
- **TreeSet**: 레드-블랙 트리 기반, O(log n) 검색, 자동 정렬
- **LinkedHashSet**: 삽입 순서 유지
- **실생활 비유**: 헬스장 회원 명부 = 중복 없는 Set

---

## 비유 4: 학교 사물함 시스템 🗄️

학교 사물함은 번호(Key)로 빠르게 찾을 수 있는 보관함(Value)입니다. Map은 이런 "키-값 쌍 저장소"와 같습니다.

### 실생활 상황
- **Key-Value 쌍**: 사물함 번호 → 소유자
- **빠른 검색**: 번호만 알면 즉시 찾기
- **Key 중복 불가**: 하나의 번호에 하나의 사물함

### 코드 예시

```java
import java.util.*;

class Locker {
    private String ownerName;
    private List<String> items;

    public Locker(String ownerName) {
        this.ownerName = ownerName;
        this.items = new ArrayList<>();
    }

    public void addItem(String item) {
        items.add(item);
    }

    public String getOwnerName() { return ownerName; }
    public List<String> getItems() { return items; }

    @Override
    public String toString() {
        return ownerName + "의 사물함: " + items;
    }
}

class LockerManagement {
    // HashMap: Key로 빠른 검색
    private Map<Integer, Locker> lockers = new HashMap<>();

    // Map 특징 1: Key-Value 쌍으로 저장
    public void assignLocker(Integer lockerNumber, String ownerName) {
        if (lockers.containsKey(lockerNumber)) {
            System.out.println("❌ " + lockerNumber + "번은 이미 사용 중입니다.");
        } else {
            lockers.put(lockerNumber, new Locker(ownerName));
            System.out.println("✅ " + lockerNumber + "번 사물함 배정: " + ownerName);
        }
    }

    // Map 특징 2: Key로 빠른 조회
    public void storeItem(Integer lockerNumber, String item) {
        Locker locker = lockers.get(lockerNumber);
        if (locker != null) {
            locker.addItem(item);
            System.out.println("📦 " + lockerNumber + "번에 보관: " + item);
        } else {
            System.out.println("❌ " + lockerNumber + "번 사물함이 없습니다.");
        }
    }

    // Map 특징 3: Key 존재 여부 확인
    public void checkLocker(Integer lockerNumber) {
        if (lockers.containsKey(lockerNumber)) {
            Locker locker = lockers.get(lockerNumber);
            System.out.println("🔍 " + lockerNumber + "번: " + locker);
        } else {
            System.out.println("❌ " + lockerNumber + "번은 사용되지 않습니다.");
        }
    }

    // Map 특징 4: 전체 순회 (entrySet)
    public void showAllLockers() {
        System.out.println("\n🗄️ 전체 사물함 현황:");
        for (Map.Entry<Integer, Locker> entry : lockers.entrySet()) {
            System.out.println("   " + entry.getKey() + "번: " + entry.getValue());
        }
        System.out.println();
    }

    // Map 특징 5: Key만, Value만 조회
    public void showLockerNumbers() {
        System.out.println("사용 중인 사물함 번호: " + lockers.keySet());
    }

    public void showOwners() {
        System.out.println("사물함 소유자 목록:");
        for (Locker locker : lockers.values()) {
            System.out.println("   - " + locker.getOwnerName());
        }
    }

    // HashMap vs TreeMap vs LinkedHashMap 비교
    public static void compareMapTypes() {
        System.out.println("\n=== HashMap vs TreeMap vs LinkedHashMap ===\n");

        // HashMap: 순서 보장 안 함, 빠름
        Map<Integer, String> hashMap = new HashMap<>();
        hashMap.put(103, "Charlie");
        hashMap.put(101, "Alice");
        hashMap.put(105, "Eve");
        hashMap.put(102, "Bob");
        hashMap.put(104, "David");

        System.out.println("HashMap (순서 보장 안 됨):");
        hashMap.forEach((k, v) -> System.out.println("   " + k + ": " + v));

        // TreeMap: Key 기준 자동 정렬
        Map<Integer, String> treeMap = new TreeMap<>();
        treeMap.put(103, "Charlie");
        treeMap.put(101, "Alice");
        treeMap.put(105, "Eve");
        treeMap.put(102, "Bob");
        treeMap.put(104, "David");

        System.out.println("\nTreeMap (Key 기준 정렬):");
        treeMap.forEach((k, v) -> System.out.println("   " + k + ": " + v));

        // LinkedHashMap: 삽입 순서 유지
        Map<Integer, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put(103, "Charlie");
        linkedHashMap.put(101, "Alice");
        linkedHashMap.put(105, "Eve");
        linkedHashMap.put(102, "Bob");
        linkedHashMap.put(104, "David");

        System.out.println("\nLinkedHashMap (삽입 순서 유지):");
        linkedHashMap.forEach((k, v) -> System.out.println("   " + k + ": " + v));

        System.out.println("\n✅ Map 구현체 선택:");
        System.out.println("   - HashMap: 순서 무관, 최고 성능 (O(1))");
        System.out.println("   - TreeMap: Key 정렬 필요 (O(log n))");
        System.out.println("   - LinkedHashMap: 삽입 순서 유지");
    }

    // Map 고급 메서드
    public static void advancedMapMethods() {
        System.out.println("\n=== Map 고급 메서드 (Java 8+) ===\n");

        Map<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 90);
        scores.put("Bob", 85);

        // 1. getOrDefault - 키가 없으면 기본값 반환
        int charlieScore = scores.getOrDefault("Charlie", 0);
        System.out.println("Charlie 점수: " + charlieScore + " (기본값)");

        // 2. putIfAbsent - 키가 없을 때만 추가
        scores.putIfAbsent("Alice", 100);  // Alice 있음 → 무시
        scores.putIfAbsent("David", 95);   // David 없음 → 추가
        System.out.println("putIfAbsent 후: " + scores);

        // 3. compute - 값 계산하여 업데이트
        scores.compute("Alice", (k, v) -> v + 10);  // Alice: 90 → 100
        System.out.println("compute 후: " + scores);

        // 4. merge - 병합
        scores.merge("Bob", 10, (old, add) -> old + add);  // Bob: 85 + 10 = 95
        System.out.println("merge 후: " + scores);

        // 5. forEach - 순회
        System.out.println("\nforEach 순회:");
        scores.forEach((name, score) ->
            System.out.println("   " + name + ": " + score + "점"));
    }
}

public class LockerManagementExample {
    public static void main(String[] args) {
        System.out.println("=== 학교 사물함 관리 시스템 (Map) ===\n");

        LockerManagement management = new LockerManagement();

        // 사물함 배정
        management.assignLocker(101, "김철수");
        management.assignLocker(105, "이영희");
        management.assignLocker(103, "박민수");
        management.assignLocker(101, "최지훈");  // 중복 시도

        System.out.println();

        // 물건 보관
        management.storeItem(101, "교과서");
        management.storeItem(101, "체육복");
        management.storeItem(105, "도시락");
        management.storeItem(999, "가방");  // 없는 사물함

        // 조회
        System.out.println();
        management.checkLocker(101);
        management.checkLocker(999);

        // 전체 현황
        management.showAllLockers();

        // Key/Value 조회
        management.showLockerNumbers();
        System.out.println();
        management.showOwners();

        // Map 구현체 비교
        LockerManagement.compareMapTypes();

        // 고급 메서드
        LockerManagement.advancedMapMethods();

        System.out.println("\n\n✅ Map의 핵심 특징:");
        System.out.println("1. Key-Value 쌍: 키로 값에 빠르게 접근");
        System.out.println("2. Key 중복 불가: 같은 키는 하나의 값만");
        System.out.println("3. Value 중복 허용: 다른 키가 같은 값 가능");
        System.out.println("4. null 허용: HashMap은 null key 1개, null value 여러 개 허용");
        System.out.println("5. 빠른 검색: get(key) O(1) (HashMap 기준)");
    }
}
```

### 실행 결과
```
=== 학교 사물함 관리 시스템 (Map) ===

✅ 101번 사물함 배정: 김철수
✅ 105번 사물함 배정: 이영희
✅ 103번 사물함 배정: 박민수
❌ 101번은 이미 사용 중입니다.

📦 101번에 보관: 교과서
📦 101번에 보관: 체육복
📦 105번에 보관: 도시락
❌ 999번 사물함이 없습니다.

🔍 101번: 김철수의 사물함: [교과서, 체육복]
❌ 999번은 사용되지 않습니다.

🗄️ 전체 사물함 현황:
   101번: 김철수의 사물함: [교과서, 체육복]
   103번: 박민수의 사물함: []
   105번: 이영희의 사물함: [도시락]

사용 중인 사물함 번호: [101, 103, 105]

사물함 소유자 목록:
   - 김철수
   - 박민수
   - 이영희

=== HashMap vs TreeMap vs LinkedHashMap ===

HashMap (순서 보장 안 됨):
   101: Alice
   102: Bob
   103: Charlie
   104: David
   105: Eve

TreeMap (Key 기준 정렬):
   101: Alice
   102: Bob
   103: Charlie
   104: David
   105: Eve

LinkedHashMap (삽입 순서 유지):
   103: Charlie
   101: Alice
   105: Eve
   102: Bob
   104: David

✅ Map 구현체 선택:
   - HashMap: 순서 무관, 최고 성능 (O(1))
   - TreeMap: Key 정렬 필요 (O(log n))
   - LinkedHashMap: 삽입 순서 유지

=== Map 고급 메서드 (Java 8+) ===

Charlie 점수: 0 (기본값)
putIfAbsent 후: {Bob=85, Alice=90, David=95}
compute 후: {Bob=85, Alice=100, David=95}
merge 후: {Bob=95, Alice=100, David=95}

forEach 순회:
   Bob: 95점
   Alice: 100점
   David: 95점


✅ Map의 핵심 특징:
1. Key-Value 쌍: 키로 값에 빠르게 접근
2. Key 중복 불가: 같은 키는 하나의 값만
3. Value 중복 허용: 다른 키가 같은 값 가능
4. null 허용: HashMap은 null key 1개, null value 여러 개 허용
5. 빠른 검색: get(key) O(1) (HashMap 기준)
```

### 핵심 정리
- **Map 인터페이스**: Key-Value 쌍, Key 중복 불가
- **HashMap**: 해시 테이블, O(1) 검색, 순서 보장 안 함
- **TreeMap**: 레드-블랙 트리, O(log n) 검색, Key 정렬
- **LinkedHashMap**: 삽입 순서 유지
- **실생활 비유**: 학교 사물함 = 번호(Key)로 빠르게 찾는 Map

---

## 비유 5: 책장 탐색기 📕

책장의 책을 순서대로 탐색하는 것처럼, Iterator는 컬렉션을 순회하는 표준화된 방법입니다.

### 실생활 상황
- **순차 탐색**: 책장을 왼쪽부터 오른쪽으로 훑기
- **안전한 삭제**: 읽는 중에 책을 빼내기
- **통일된 방법**: 어떤 책장이든 같은 방법으로 탐색

### 코드 예시

```java
import java.util.*;

class Book2 {
    private String title;
    private String author;

    public Book2(String title, String author) {
        this.title = title;
        this.author = author;
    }

    public String getTitle() { return title; }
    public String getAuthor() { return author; }

    @Override
    public String toString() {
        return "《" + title + "》 - " + author;
    }
}

class BookShelf {
    private List<Book2> books = new ArrayList<>();

    public void addBook(Book2 book) {
        books.add(book);
    }

    // Iterator 패턴 1: 기본 순회
    public void showAllBooks() {
        System.out.println("📚 전체 도서 목록:");
        Iterator<Book2> iterator = books.iterator();
        int index = 1;
        while (iterator.hasNext()) {
            Book2 book = iterator.next();
            System.out.println("   " + index++ + ". " + book);
        }
        System.out.println();
    }

    // Iterator 패턴 2: 조건부 삭제
    public void removeByAuthor(String author) {
        System.out.println("🗑️ 작가 '" + author + "' 책 삭제:");
        Iterator<Book2> iterator = books.iterator();
        int removed = 0;

        while (iterator.hasNext()) {
            Book2 book = iterator.next();
            if (book.getAuthor().equals(author)) {
                iterator.remove();  // ✅ Iterator로 안전하게 삭제
                System.out.println("   삭제: " + book.getTitle());
                removed++;
            }
        }

        if (removed == 0) {
            System.out.println("   해당 작가의 책이 없습니다.");
        }
        System.out.println();
    }

    // ❌ for-each 중 삭제 시도 (위험!)
    public static void demonstrateConcurrentModification() {
        System.out.println("=== ConcurrentModificationException 예시 ===\n");

        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

        System.out.println("❌ for-each 중 삭제 시도:");
        try {
            for (String item : list) {
                if (item.equals("B")) {
                    list.remove(item);  // 💥 ConcurrentModificationException!
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("   에러 발생: " + e.getClass().getSimpleName());
        }

        System.out.println("\n✅ Iterator로 안전하게 삭제:");
        list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (item.equals("B")) {
                iterator.remove();  // ✅ 안전!
            }
        }
        System.out.println("   결과: " + list);
        System.out.println();
    }

    // Iterator vs for문 vs for-each
    public static void compareIterationMethods() {
        System.out.println("=== 순회 방법 비교 ===\n");

        List<String> books = Arrays.asList("책1", "책2", "책3");

        // 1. for문 (인덱스)
        System.out.println("1. for문 (인덱스 접근):");
        for (int i = 0; i < books.size(); i++) {
            System.out.println("   " + i + ": " + books.get(i));
        }

        // 2. for-each (간결)
        System.out.println("\n2. for-each (간결):");
        for (String book : books) {
            System.out.println("   - " + book);
        }

        // 3. Iterator (안전한 삭제)
        System.out.println("\n3. Iterator (명시적 제어):");
        Iterator<String> iterator = books.iterator();
        while (iterator.hasNext()) {
            String book = iterator.next();
            System.out.println("   → " + book);
        }

        // 4. Java 8 forEach (함수형)
        System.out.println("\n4. forEach (람다):");
        books.forEach(book -> System.out.println("   * " + book));

        System.out.println("\n✅ 순회 방법 선택:");
        System.out.println("   - for문: 인덱스 필요 시");
        System.out.println("   - for-each: 간단한 순회");
        System.out.println("   - Iterator: 순회 중 삭제");
        System.out.println("   - forEach: 함수형 프로그래밍");
    }

    // ListIterator - 양방향 순회
    public static void demonstrateListIterator() {
        System.out.println("\n=== ListIterator (양방향 순회) ===\n");

        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

        ListIterator<String> iterator = list.listIterator();

        // 순방향
        System.out.println("순방향 순회:");
        while (iterator.hasNext()) {
            int index = iterator.nextIndex();
            String item = iterator.next();
            System.out.println("   [" + index + "] " + item);
        }

        // 역방향
        System.out.println("\n역방향 순회:");
        while (iterator.hasPrevious()) {
            int index = iterator.previousIndex();
            String item = iterator.previous();
            System.out.println("   [" + index + "] " + item);
        }

        // 수정
        System.out.println("\n수정 (B → X):");
        iterator = list.listIterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (item.equals("B")) {
                iterator.set("X");  // 현재 요소 수정
            }
        }
        System.out.println("   결과: " + list);

        // 삽입
        System.out.println("\n삽입 (C 앞에 Y):");
        iterator = list.listIterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if (item.equals("C")) {
                iterator.add("Y");  // 현재 위치에 삽입
                break;
            }
        }
        System.out.println("   결과: " + list);
    }
}

public class BookShelfIteratorExample {
    public static void main(String[] args) {
        System.out.println("=== 책장 탐색 시스템 (Iterator) ===\n");

        BookShelf bookShelf = new BookShelf();
        bookShelf.addBook(new Book2("Effective Java", "Joshua Bloch"));
        bookShelf.addBook(new Book2("Clean Code", "Robert Martin"));
        bookShelf.addBook(new Book2("Java의 정석", "남궁성"));
        bookShelf.addBook(new Book2("Refactoring", "Martin Fowler"));
        bookShelf.addBook(new Book2("Design Patterns", "Gang of Four"));

        // 전체 순회
        bookShelf.showAllBooks();

        // 조건부 삭제
        bookShelf.removeByAuthor("Robert Martin");
        bookShelf.showAllBooks();

        // ConcurrentModificationException
        BookShelf.demonstrateConcurrentModification();

        // 순회 방법 비교
        BookShelf.compareIterationMethods();

        // ListIterator
        BookShelf.demonstrateListIterator();

        System.out.println("\n\n✅ Iterator의 핵심 특징:");
        System.out.println("1. 통일된 순회: 모든 컬렉션을 같은 방법으로 순회");
        System.out.println("2. 안전한 삭제: 순회 중 remove() 가능");
        System.out.println("3. Fail-Fast: 순회 중 컬렉션 변경 시 예외 발생");
        System.out.println("4. hasNext/next: 다음 요소 존재 확인 → 조회");
        System.out.println("5. ListIterator: 양방향 순회 + 수정/삽입 가능");
    }
}
```

### 실행 결과
```
=== 책장 탐색 시스템 (Iterator) ===

📚 전체 도서 목록:
   1. 《Effective Java》 - Joshua Bloch
   2. 《Clean Code》 - Robert Martin
   3. 《Java의 정석》 - 남궁성
   4. 《Refactoring》 - Martin Fowler
   5. 《Design Patterns》 - Gang of Four

🗑️ 작가 'Robert Martin' 책 삭제:
   삭제: Clean Code

📚 전체 도서 목록:
   1. 《Effective Java》 - Joshua Bloch
   2. 《Java의 정석》 - 남궁성
   3. 《Refactoring》 - Martin Fowler
   4. 《Design Patterns》 - Gang of Four

=== ConcurrentModificationException 예시 ===

❌ for-each 중 삭제 시도:
   에러 발생: ConcurrentModificationException

✅ Iterator로 안전하게 삭제:
   결과: [A, C, D]

=== 순회 방법 비교 ===

1. for문 (인덱스 접근):
   0: 책1
   1: 책2
   2: 책3

2. for-each (간결):
   - 책1
   - 책2
   - 책3

3. Iterator (명시적 제어):
   → 책1
   → 책2
   → 책3

4. forEach (람다):
   * 책1
   * 책2
   * 책3

✅ 순회 방법 선택:
   - for문: 인덱스 필요 시
   - for-each: 간단한 순회
   - Iterator: 순회 중 삭제
   - forEach: 함수형 프로그래밍

=== ListIterator (양방향 순회) ===

순방향 순회:
   [0] A
   [1] B
   [2] C
   [3] D

역방향 순회:
   [3] D
   [2] C
   [1] B
   [0] A

수정 (B → X):
   결과: [A, X, C, D]

삽입 (C 앞에 Y):
   결과: [A, X, Y, C, D]


✅ Iterator의 핵심 특징:
1. 통일된 순회: 모든 컬렉션을 같은 방법으로 순회
2. 안전한 삭제: 순회 중 remove() 가능
3. Fail-Fast: 순회 중 컬렉션 변경 시 예외 발생
4. hasNext/next: 다음 요소 존재 확인 → 조회
5. ListIterator: 양방향 순회 + 수정/삽입 가능
```

### 핵심 정리
- **Iterator**: 컬렉션 순회의 표준 인터페이스
- **hasNext/next**: 다음 요소 확인 + 조회
- **remove()**: 순회 중 안전한 삭제
- **Fail-Fast**: 순회 중 컬렉션 변경 시 `ConcurrentModificationException`
- **ListIterator**: 양방향 순회, 수정, 삽입 가능
- **실생활 비유**: 책장 탐색 = 순서대로 순회하는 Iterator

---

## 🎯 Part 1 핵심 요약

### 컬렉션 프레임워크 계층 구조
```
Iterable
  ├─ Collection
  │   ├─ List (ArrayList, LinkedList)
  │   ├─ Set (HashSet, TreeSet, LinkedHashSet)
  │   └─ Queue (LinkedList, PriorityQueue)
  └─ Map (HashMap, TreeMap, LinkedHashMap)
```

### 주요 인터페이스 비교

| 특징 | List | Set | Map |
|------|------|-----|-----|
| 순서 | ✅ 유지 | ❌ 무관 (HashSet) | ❌ 무관 (HashMap) |
| 중복 | ✅ 허용 | ❌ 불허 | Key 중복 ❌, Value 허용 ✅ |
| null | ✅ 허용 | ✅ 1개 허용 | Key 1개, Value 여러 개 (HashMap) |
| 조회 | `get(index)` | `contains(obj)` | `get(key)` |
| 특징 | 인덱스 접근 | 집합 연산 | Key-Value 쌍 |

### 구현체 성능 비교

| 구현체 | 조회 | 삽입 | 삭제 | 정렬 | 순서 |
|--------|------|------|------|------|------|
| ArrayList | O(1) | O(n) | O(n) | ❌ | 삽입 순서 |
| LinkedList | O(n) | O(1) | O(1) | ❌ | 삽입 순서 |
| HashSet | O(1) | O(1) | O(1) | ❌ | 무관 |
| TreeSet | O(log n) | O(log n) | O(log n) | ✅ | 자동 정렬 |
| HashMap | O(1) | O(1) | O(1) | ❌ | 무관 |
| TreeMap | O(log n) | O(log n) | O(log n) | ✅ | Key 정렬 |

### Iterator 사용 시점
- ✅ 순회 중 삭제가 필요할 때
- ✅ 컬렉션 타입에 무관하게 통일된 순회
- ❌ 단순 조회만 → for-each 사용

다음 Part 2에서는 실제 기업 사례와 주니어 개발자가 흔히 하는 실수를 다룹니다! 🚀
