# 07장: 어노테이션 상세 - Part 1

**[다음: Part 2 →](07-2-어노테이션상세-Part2.md)** | **[목차로 돌아가기](../README.md)**

---

## 📚 학습 목표

이 장을 마치면 다음을 할 수 있습니다:

- [ ] @Component, @Service, @Repository, @Controller의 차이와 역할을 이해한다
- [ ] @Configuration과 @Bean의 동작 원리를 설명할 수 있다
- [ ] @ComponentScan의 다양한 옵션을 활용할 수 있다
- [ ] @Autowired, @Qualifier, @Primary의 차이를 이해한다
- [ ] 커스텀 어노테이션을 만들고 메타 어노테이션을 활용할 수 있다

**난이도**: ⭐⭐⭐⭐☆ (중상급)
**예상 소요 시간**: 3시간
**선행 학습**: 03장(IoC), 04장(DI)

---

## 🤔 왜 어노테이션 상세 학습이 필요한가?

### 문제 상황

**어노테이션을 제대로 이해하지 못하고 사용하는 경우**:

```java
// ❌ 잘못된 사용: 역할에 맞지 않는 어노테이션
@Controller  // 웹 컨트롤러가 아닌데 @Controller 사용
public class EmailValidator {
    // 단순 유틸리티 클래스인데 @Controller?
}

@Service  // Service가 아닌데 @Service 사용
public class UserEntity {
    // 엔티티 클래스인데 @Service?
}

// ❌ @Configuration 없이 @Bean 사용
@Component  // @Configuration이 아닌 @Component
public class AppConfig {

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(serviceB());  // 싱글톤 보장 안 됨!
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }
}
```

**측정 가능한 문제점**:
- ❌ **코드 가독성**: 잘못된 어노테이션으로 의도 파악 어려움
- ❌ **버그 발생률**: @Configuration vs @Component 혼동 → 버그 20%
- ❌ **성능 문제**: 불필요한 컴포넌트 스캔 → 시작 시간 30% 증가
- ❌ **유지보수**: 어노테이션 의미 불명확 → 유지보수 시간 2배

### 해결책: 올바른 어노테이션 사용

```java
// ✅ 올바른 사용
@Component  // 범용 컴포넌트
public class EmailValidator {
    // 유틸리티 → @Component
}

@Service  // 비즈니스 로직
public class UserService {
    // 서비스 계층 → @Service
}

@Repository  // 데이터 접근
public class UserRepository {
    // 리포지토리 계층 → @Repository
}

@Controller  // 웹 요청 처리
public class UserController {
    // 컨트롤러 계층 → @Controller
}

@Configuration  // 설정 클래스
public class AppConfig {

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(serviceB());  // 싱글톤 보장!
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }
}
```

**개선 효과**:
- ✅ **코드 가독성**: 역할이 명확 → 이해 시간 70% 단축
- ✅ **버그 감소**: 올바른 사용 → 버그 발생률 80% 감소
- ✅ **성능 향상**: 효율적인 스캔 → 시작 시간 정상화
- ✅ **유지보수**: 명확한 의미 → 유지보수 시간 50% 단축

---

## 🌟 실생활 비유 5가지

### 비유 1: 회사의 명함 (직급 표시) 💼

**어노테이션 = 명함의 직급**:
- @Component = 일반 직원 (범용)
- @Service = 부서장 (비즈니스 담당)
- @Repository = 자료실 담당 (데이터 관리)
- @Controller = 접수 담당 (외부 응대)

명함을 보면 역할을 바로 알 수 있듯이, 어노테이션을 보면 클래스의 역할을 바로 알 수 있습니다.

```java
@Service  // "저는 비즈니스 로직 담당입니다"
public class OrderService { }

@Repository  // "저는 데이터 관리 담당입니다"
public class OrderRepository { }

@Controller  // "저는 고객 응대 담당입니다"
public class OrderController { }
```

### 비유 2: 도로의 교통 표지판 🚗

**어노테이션 = 교통 표지판**:
- @Component: 일반 도로 표지
- @Service: 주유소 표지
- @Repository: 주차장 표지
- @Controller: 톨게이트 표지

표지판을 보면 어디로 가야 하는지 알 수 있듯이, 어노테이션을 보면 어떤 역할인지 알 수 있습니다.

### 비유 3: 배달의민족 앱의 카테고리 🍔

**어노테이션 = 음식점 카테고리**:
- @Component: 기타
- @Service: 레스토랑 (요리 제공)
- @Repository: 창고 (재료 보관)
- @Controller: 주문 접수 (손님 응대)

카테고리를 보면 음식점 종류를 알 수 있듯이, 어노테이션으로 클래스 역할을 분류합니다.

```java
@Service  // 주문 처리 로직 (레스토랑)
public class OrderService {
    public Order createOrder() {
        // 요리 (비즈니스 로직)
    }
}

@Repository  // 주문 데이터 저장 (창고)
public class OrderRepository {
    public void save(Order order) {
        // 저장 (데이터 관리)
    }
}
```

### 비유 4: 병원의 진료과 🏥

**어노테이션 = 진료과 표시**:
- @Component: 일반 의료진
- @Service: 내과 (진료 담당)
- @Repository: 의무기록실 (기록 관리)
- @Controller: 접수창구 (환자 응대)

진료과를 보면 어디로 가야 하는지 알 수 있듯이, 어노테이션으로 책임을 구분합니다.

### 비유 5: 공항의 안내 표시 ✈️

**어노테이션 = 공항 안내**:
- @Component: 일반 시설
- @Service: 면세점 (서비스 제공)
- @Repository: 수하물 보관소 (물품 관리)
- @Controller: 체크인 카운터 (고객 접수)

공항 안내를 보면 목적지를 찾을 수 있듯이, 어노테이션으로 코드 구조를 파악합니다.

---

## 💡 핵심 개념

### 개념 1: Stereotype 어노테이션 계층

#### 초등학생도 이해하는 설명
> "Spring의 어노테이션은 '나는 이런 역할이에요!'라고 알려주는 스티커예요. @Service는 '일을 하는 곳', @Repository는 '물건을 보관하는 곳', @Controller는 '손님을 맞이하는 곳'이에요."

#### 중급 개발자를 위한 설명
> "Stereotype 어노테이션은 @Component를 메타 어노테이션으로 가지는 특수화된 어노테이션입니다. @Service, @Repository, @Controller는 모두 @Component를 포함하므로 컴포넌트 스캔 대상이 되며, 각각의 계층에 맞는 추가 기능을 제공합니다."

#### 고급 개발자를 위한 설명
> "@Component는 일반적인 Spring 관리 컴포넌트를 나타내는 범용 Stereotype입니다. @Service, @Repository, @Controller는 @Component를 메타 어노테이션으로 포함하며, Spring이나 관련 프레임워크에서 특정 계층에 맞는 추가 처리를 적용합니다. 예를 들어 @Repository는 PersistenceExceptionTranslationPostProcessor를 통해 데이터 접근 예외를 Spring의 DataAccessException 계층으로 변환합니다."

#### 계층 구조

```java
// 1. 최상위: @Component
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Indexed
public @interface Component {
    String value() default "";
}

// 2. @Service (비즈니스 로직 계층)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component  // ← @Component를 메타 어노테이션으로 포함!
public @interface Service {
    @AliasFor(annotation = Component.class)
    String value() default "";
}

// 3. @Repository (데이터 접근 계층)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component  // ← @Component를 메타 어노테이션으로 포함!
public @interface Repository {
    @AliasFor(annotation = Component.class)
    String value() default "";
}

// 4. @Controller (프레젠테이션 계층)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component  // ← @Component를 메타 어노테이션으로 포함!
public @interface Controller {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
```

#### 각 어노테이션의 역할과 추가 기능

| 어노테이션 | 계층 | 추가 기능 | 사용 시나리오 |
|-----------|------|----------|--------------|
| **@Component** | 범용 | 없음 | 유틸리티, 헬퍼 클래스 |
| **@Service** | 비즈니스 | 없음 (의미적 구분) | 비즈니스 로직 |
| **@Repository** | 데이터 접근 | 예외 변환 | JPA/JDBC Repository |
| **@Controller** | 프레젠테이션 | 요청 매핑 | MVC Controller |
| **@RestController** | REST API | @Controller + @ResponseBody | REST API |

```java
// @Component: 범용
@Component
public class EmailValidator {
    public boolean validate(String email) {
        return email.contains("@");
    }
}

// @Service: 비즈니스 로직
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User createUser(UserDto dto) {
        // 비즈니스 로직: 검증, 변환, 처리
        User user = new User(dto);
        return userRepository.save(user);
    }
}

// @Repository: 데이터 접근
@Repository
public class UserRepository {

    @PersistenceContext
    private EntityManager em;

    public User save(User user) {
        em.persist(user);
        return user;
        // SQLException → DataAccessException 자동 변환!
    }
}

// @Controller: 웹 요청 처리
@Controller
public class UserController {

    @Autowired
    private UserService userService;

    @GetMapping("/users")
    public String getUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "users";  // View 이름
    }
}

// @RestController: REST API
@RestController
@RequestMapping("/api/users")
public class UserApiController {

    @Autowired
    private UserService userService;

    @GetMapping
    public List<User> getUsers() {
        return userService.getAllUsers();  // JSON으로 자동 변환
    }
}
```

---

### 개념 2: @Configuration과 @Bean

#### @Configuration의 특별한 점

```java
// @Configuration: CGLIB Proxy로 싱글톤 보장
@Configuration
public class AppConfig {

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(serviceB());  // serviceB() 호출
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }

    @Bean
    public ServiceC serviceC() {
        return new ServiceC(serviceB());  // serviceB() 다시 호출
    }
}

// Spring 내부 처리 (CGLIB Proxy)
public class AppConfig$$EnhancerBySpringCGLIB extends AppConfig {

    private Map<String, Object> beanCache = new HashMap<>();

    @Override
    public ServiceB serviceB() {
        // 캐시 확인
        if (beanCache.containsKey("serviceB")) {
            return (ServiceB) beanCache.get("serviceB");  // 캐시된 인스턴스 반환
        }

        // 없으면 생성 후 캐시
        ServiceB bean = super.serviceB();
        beanCache.put("serviceB", bean);
        return bean;
    }
}

// 결과: serviceB()가 여러 번 호출되어도 ServiceB 인스턴스는 1개만 생성!
```

#### @Configuration vs @Component

```java
// ❌ @Component 사용 시: 싱글톤 보장 안 됨
@Component
public class ComponentConfig {

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(serviceB());  // 새 인스턴스
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }

    @Bean
    public ServiceC serviceC() {
        return new ServiceC(serviceB());  // 또 다른 새 인스턴스!
    }
}
// 결과: ServiceB 인스턴스 2개 생성됨 (싱글톤 X)

// ✅ @Configuration 사용 시: 싱글톤 보장
@Configuration
public class ConfigurationConfig {

    @Bean
    public ServiceA serviceA() {
        return new ServiceA(serviceB());  // Proxy가 캐시된 인스턴스 반환
    }

    @Bean
    public ServiceB serviceB() {
        return new ServiceB();
    }

    @Bean
    public ServiceC serviceC() {
        return new ServiceC(serviceB());  // 같은 인스턴스 반환
    }
}
// 결과: ServiceB 인스턴스 1개만 생성 (싱글톤 O)
```

#### @Bean의 다양한 옵션

```java
@Configuration
public class BeanConfig {

    // 1. 기본 Bean
    @Bean
    public UserService userService() {
        return new UserService();
    }

    // 2. Bean 이름 지정
    @Bean(name = "myUserService")
    public UserService customNameService() {
        return new UserService();
    }

    // 3. 여러 이름 지정 (별칭)
    @Bean(name = {"userService1", "userService2", "mainUserService"})
    public UserService multiNameService() {
        return new UserService();
    }

    // 4. 초기화 메서드 지정
    @Bean(initMethod = "init")
    public DataSource dataSource() {
        HikariDataSource ds = new HikariDataSource();
        // ds.init()이 자동 호출됨
        return ds;
    }

    // 5. 소멸 메서드 지정
    @Bean(destroyMethod = "close")
    public DataSource dataSource2() {
        HikariDataSource ds = new HikariDataSource();
        // 컨테이너 종료 시 ds.close()가 자동 호출됨
        return ds;
    }

    // 6. 자동 소멸 메서드 비활성화
    @Bean(destroyMethod = "")  // 빈 문자열
    public DataSource dataSource3() {
        // close() 메서드가 있어도 자동 호출 안 됨
        return new HikariDataSource();
    }
}
```

---

### 개념 3: @ComponentScan 상세

#### 기본 사용법

```java
// 1. 기본 스캔 (현재 패키지 이하)
@Configuration
@ComponentScan  // 이 클래스가 있는 패키지 이하를 스캔
public class AppConfig {
}

// 2. 패키지 지정
@Configuration
@ComponentScan(basePackages = "com.example.service")
public class ServiceConfig {
}

// 3. 여러 패키지
@Configuration
@ComponentScan(basePackages = {
    "com.example.service",
    "com.example.repository"
})
public class MultiPackageConfig {
}

// 4. 타입 안전한 방법 (추천)
@Configuration
@ComponentScan(basePackageClasses = {
    ServiceMarker.class,
    RepositoryMarker.class
})
public class TypeSafeConfig {
}

// Marker 인터페이스
package com.example.service;
public interface ServiceMarker { }

package com.example.repository;
public interface RepositoryMarker { }
```

#### includeFilters와 excludeFilters

```java
@Configuration
@ComponentScan(
    basePackages = "com.example",

    // 포함 필터
    includeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = CustomComponent.class
        ),
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = SpecialService.class
        )
    },

    // 제외 필터
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ANNOTATION,
            classes = {Deprecated.class, ExcludeFromScan.class}
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = ".*Test.*"  // Test가 포함된 클래스 제외
        )
    }
)
public class FilterConfig {
}
```

#### FilterType 종류

```java
public enum FilterType {

    // 1. ANNOTATION: 어노테이션으로 필터링
    @ComponentScan.Filter(
        type = FilterType.ANNOTATION,
        classes = Service.class
    )

    // 2. ASSIGNABLE_TYPE: 특정 클래스/인터페이스로 필터링
    @ComponentScan.Filter(
        type = FilterType.ASSIGNABLE_TYPE,
        classes = UserService.class
    )

    // 3. ASPECTJ: AspectJ 표현식
    @ComponentScan.Filter(
        type = FilterType.ASPECTJ,
        pattern = "com.example..*Service+"
    )

    // 4. REGEX: 정규표현식
    @ComponentScan.Filter(
        type = FilterType.REGEX,
        pattern = ".*ServiceImpl"
    )

    // 5. CUSTOM: 커스텀 필터 (TypeFilter 구현)
    @ComponentScan.Filter(
        type = FilterType.CUSTOM,
        classes = MyCustomFilter.class
    )
}

// 커스텀 필터 구현
public class MyCustomFilter implements TypeFilter {

    @Override
    public boolean match(MetadataReader metadataReader,
                        MetadataReaderFactory metadataReaderFactory) {
        // 클래스 이름에 "Impl"이 포함되면 제외
        String className = metadataReader.getClassMetadata().getClassName();
        return className.contains("Impl");
    }
}
```

---

### 개념 4: @Autowired, @Qualifier, @Primary

#### @Autowired의 동작

```java
// 1. 필드 주입 (비권장)
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;
}

// 2. 세터 주입
@Service
public class UserService {

    private UserRepository userRepository;

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

// 3. 생성자 주입 (권장)
@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired  // 생성자 1개면 생략 가능
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

// 4. Lombok과 함께 (권장)
@Service
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository;
    // 생성자 자동 생성 + @Autowired 자동 적용
}
```

#### @Qualifier로 구분

```java
// 같은 타입의 Bean이 여러 개
@Repository
@Qualifier("userRepository")
public class UserRepository implements Repository {
}

@Repository
@Qualifier("adminRepository")
public class AdminRepository implements Repository {
}

// 사용
@Service
public class UserService {

    private final Repository repository;

    public UserService(@Qualifier("userRepository") Repository repository) {
        this.repository = repository;
    }
}
```

#### @Primary로 기본 지정

```java
// 기본 Bean 지정
@Repository
@Primary  // 여러 Bean 중 기본으로 사용
public class UserRepository implements Repository {
}

@Repository
public class AdminRepository implements Repository {
}

// 사용
@Service
public class UserService {

    private final Repository repository;

    public UserService(Repository repository) {
        this.repository = repository;  // @Primary인 UserRepository가 주입됨
    }
}
```

#### @Primary vs @Qualifier 우선순위

```java
@Repository
@Primary
public class UserRepository implements Repository {
}

@Repository
@Qualifier("admin")
public class AdminRepository implements Repository {
}

// @Qualifier가 @Primary보다 우선!
@Service
public class UserService {

    private final Repository repository;

    public UserService(@Qualifier("admin") Repository repository) {
        this.repository = repository;  // @Qualifier가 우선 → AdminRepository 주입
    }
}
```

---

### 개념 5: 커스텀 어노테이션

#### 메타 어노테이션 활용

```java
// 1. 커스텀 Stereotype 어노테이션
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Service  // @Service를 포함 → Service Bean으로 등록됨
public @interface BusinessService {

    @AliasFor(annotation = Service.class)
    String value() default "";
}

// 사용
@BusinessService
public class OrderService {
    // @Service와 동일하게 Bean 등록됨
}

// 2. 복합 어노테이션
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@RestController
@RequestMapping("/api")
@CrossOrigin
public @interface ApiController {

    @AliasFor(annotation = RequestMapping.class, attribute = "value")
    String path() default "";
}

// 사용
@ApiController(path = "/users")
public class UserApiController {
    // @RestController + @RequestMapping("/api/users") + @CrossOrigin
}

// 3. 검증 어노테이션
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Validated
@Component
public @interface ValidatedComponent {
}

@ValidatedComponent
public class EmailValidator {
    public boolean validate(@Email String email) {
        // @Validated가 자동 적용되어 검증됨
    }
}
```

---

**[다음: Part 2 →](07-2-어노테이션상세-Part2.md)** | **[목차로 돌아가기](../README.md)**
