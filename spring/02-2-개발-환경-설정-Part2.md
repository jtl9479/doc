# 02장: 개발 환경 설정 (Part 2)
## Spring Boot, IntelliJ/Eclipse - 실무 사례 & 면접 대비

> **Part 2에서 다룰 내용**: 실무 활용 사례, 주니어 시나리오, 실전 프로젝트, FAQ, 면접 대비

---

## 🏢 실무 활용 사례

실제 IT 기업들이 개발 환경을 어떻게 표준화하고 관리하는지 살펴봅시다.

### 사례 1: 토스(Toss) - 환경 표준화로 온보딩 시간 75% 단축

**배경**
- 2020년 초, 토스 개발팀이 급격히 성장 (50명 → 200명)
- 신입 개발자마다 환경 설정에 1-2주 소요
- 환경 불일치로 인한 버그가 월평균 15건 발생

**솔루션: 자동화된 개발 환경 스크립트**

```bash
#!/bin/bash
# toss-dev-setup.sh - 토스 개발자 환경 자동 설치 스크립트

echo "🏦 Toss 개발 환경 설정을 시작합니다..."

# 1. JDK 17 설치 확인
if ! command -v java &> /dev/null; then
    echo "❌ JDK가 설치되어 있지 않습니다."
    echo "📥 JDK 17 설치 링크: https://adoptium.net/"
    exit 1
fi

JAVA_VERSION=$(java -version 2>&1 | awk -F '"' '/version/ {print $2}' | cut -d'.' -f1)
if [ "$JAVA_VERSION" -lt 17 ]; then
    echo "❌ JDK 17 이상이 필요합니다. 현재 버전: $JAVA_VERSION"
    exit 1
fi

echo "✅ JDK $JAVA_VERSION 확인 완료"

# 2. IntelliJ 설정 파일 다운로드
echo "📥 IntelliJ 설정 파일 다운로드 중..."
curl -O https://internal.toss.im/dev-setup/intellij-settings.zip
unzip -q intellij-settings.zip -d ~/Library/Preferences/IntelliJIdea2024.1/

# 3. 필수 플러그인 목록
cat > plugins.txt <<EOF
lombok
google-java-format
sonarlint
rainbow-brackets
key-promoter-x
EOF

echo "✅ 플러그인 목록 생성 완료 (IntelliJ에서 수동 설치 필요)"

# 4. Maven settings.xml 설정 (사내 Nexus 레포지토리)
mkdir -p ~/.m2
cat > ~/.m2/settings.xml <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <mirrors>
    <mirror>
      <id>toss-nexus</id>
      <url>https://nexus.toss.im/repository/maven-public/</url>
      <mirrorOf>central</mirrorOf>
    </mirror>
  </mirrors>
</settings>
EOF

echo "✅ Maven 설정 완료"

# 5. Git 설정
git config --global user.name "YourName"
git config --global user.email "your.email@toss.im"
git config --global core.autocrlf input
git config --global pull.rebase true

echo "✅ Git 설정 완료"

# 6. 환경 변수 설정
cat >> ~/.zshrc <<EOF

# Toss Development Environment
export JAVA_HOME=$(/usr/libexec/java_home -v 17)
export PATH=\$JAVA_HOME/bin:\$PATH
export SPRING_PROFILES_ACTIVE=local
EOF

echo "✅ 환경 변수 설정 완료"

echo ""
echo "🎉 토스 개발 환경 설정이 완료되었습니다!"
echo "📝 다음 단계:"
echo "   1. IntelliJ를 재시작하세요"
echo "   2. plugins.txt의 플러그인을 설치하세요"
echo "   3. 터미널을 재시작하세요 (source ~/.zshrc)"
echo ""
echo "❓ 문제가 있으면 #dev-support 채널로 문의하세요"
```

**결과 지표**
```
┌─────────────────────────────┬──────────┬─────────┬────────┐
│ 지표                        │ 도입 전  │ 도입 후 │ 개선율 │
├─────────────────────────────┼──────────┼─────────┼────────┤
│ 신입 온보딩 시간            │ 7-10일   │ 1-2일   │ -80%   │
│ 환경 관련 버그 (월평균)     │ 15건     │ 2건     │ -87%   │
│ 개발자 만족도               │ 6.2/10   │ 9.1/10  │ +47%   │
│ 첫 커밋까지 걸리는 시간     │ 12일     │ 3일     │ -75%   │
└─────────────────────────────┴──────────┴─────────┴────────┘
```

**핵심 교훈**
1. **자동화**: 수동 단계를 스크립트로 자동화
2. **문서화**: README.md에 상세한 설명 작성
3. **표준화**: 모든 개발자가 동일한 환경 사용
4. **지원 채널**: 즉각적인 도움을 받을 수 있는 슬랙 채널 운영

---

### 사례 2: 네이버(NAVER) - 멀티 환경 관리 시스템

**배경**
- 네이버 쇼핑 팀은 5개 환경 관리 (local, dev, qa, staging, production)
- 환경별 설정 파일 관리가 복잡
- 실수로 운영 DB에 접속하는 사고 발생 (2019년)

**솔루션: Spring Profile 기반 멀티 환경 설정**

```yaml
# application.yml (공통 설정)
spring:
  application:
    name: naver-shopping-api

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        format_sql: true

logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

---
# application-local.yml (로컬 개발 환경)
spring:
  config:
    activate:
      on-profile: local

  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:

  h2:
    console:
      enabled: true
      path: /h2-console

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true

server:
  port: 8080

# 로컬에서는 외부 API를 Mock으로 대체
external:
  payment-api:
    url: http://localhost:9090/mock
    enabled: false

logging:
  level:
    com.naver.shopping: DEBUG
    org.hibernate.SQL: DEBUG

---
# application-dev.yml (개발 서버)
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:mysql://dev-db.naver.com:3306/shopping_dev
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: ${DB_USERNAME}  # 환경 변수에서 주입
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5

server:
  port: 8080

external:
  payment-api:
    url: https://dev-payment.naver.com
    enabled: true

---
# application-prod.yml (운영 환경)
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: jdbc:mysql://prod-db-replica.naver.com:3306/shopping_prod
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50
      minimum-idle: 20
      connection-timeout: 3000

server:
  port: 8080

external:
  payment-api:
    url: https://payment.naver.com
    enabled: true

logging:
  level:
    com.naver.shopping: INFO
    org.hibernate.SQL: WARN
```

**환경별 실행 방법**

```bash
# 1. 로컬 환경 (H2 인메모리 DB 사용)
./mvnw spring-boot:run -Dspring-boot.run.profiles=local

# 2. 개발 환경
export DB_USERNAME=dev_user
export DB_PASSWORD=dev_password_secret
java -jar -Dspring.profiles.active=dev shopping-api.jar

# 3. 운영 환경 (Kubernetes에서 실행)
# ConfigMap과 Secret으로 환경 변수 주입
kubectl apply -f k8s/configmap-prod.yml
kubectl apply -f k8s/secret-prod.yml
kubectl apply -f k8s/deployment-prod.yml
```

**IntelliJ에서 Profile 설정**

```
Run > Edit Configurations...
  └─ Environment variables: SPRING_PROFILES_ACTIVE=local
  └─ Active profiles: local
```

**결과 지표**
```
┌─────────────────────────────┬──────────┬─────────┬────────┐
│ 지표                        │ 도입 전  │ 도입 후 │ 개선율 │
├─────────────────────────────┼──────────┼─────────┼────────┤
│ 환경 설정 실수 (월평균)     │ 8건      │ 0건     │ -100%  │
│ 환경 전환 시간              │ 30분     │ 5초     │ -99%   │
│ 설정 파일 관리 복잡도       │ 높음     │ 낮음    │ N/A    │
│ 운영 DB 오접속 사고         │ 2건/년   │ 0건     │ -100%  │
└─────────────────────────────┴──────────┴─────────┴────────┘
```

**핵심 교훈**
1. **Profile 분리**: 환경별로 완전히 독립된 설정
2. **환경 변수 사용**: 민감 정보는 코드에 포함하지 않음
3. **색상 구분**: IntelliJ에서 환경별로 다른 색상 사용
4. **접근 제어**: 운영 DB는 특정 IP에서만 접속 가능

---

### 사례 3: 우아한형제들(배달의민족) - Docker 기반 일관된 환경

**배경**
- 개발자마다 Mac, Windows, Linux 사용
- "내 컴퓨터에서는 되는데요?" 문제가 빈번
- 로컬과 서버 환경 차이로 배포 후 버그 발견

**솔루션: Docker Compose로 로컬 환경 통일**

```yaml
# docker-compose.yml - 배달의민족 로컬 개발 환경
version: '3.8'

services:
  # MySQL 데이터베이스
  mysql:
    image: mysql:8.0
    container_name: baemin-mysql
    environment:
      MYSQL_ROOT_PASSWORD: root1234
      MYSQL_DATABASE: baemin_local
      MYSQL_USER: baemin
      MYSQL_PASSWORD: baemin1234
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./init-db:/docker-entrypoint-initdb.d
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci

  # Redis 캐시
  redis:
    image: redis:7-alpine
    container_name: baemin-redis
    ports:
      - "6379:6379"
    command: redis-server --requirepass redis1234

  # Spring Boot 애플리케이션
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    container_name: baemin-app
    ports:
      - "8080:8080"
    environment:
      SPRING_PROFILES_ACTIVE: local
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/baemin_local
      SPRING_DATASOURCE_USERNAME: baemin
      SPRING_DATASOURCE_PASSWORD: baemin1234
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PASSWORD: redis1234
    depends_on:
      - mysql
      - redis
    volumes:
      - ./src:/app/src
      - ~/.m2:/root/.m2

volumes:
  mysql-data:
```

```dockerfile
# Dockerfile.dev - 로컬 개발용 Dockerfile
FROM eclipse-temurin:17-jdk

WORKDIR /app

# Maven Wrapper 복사
COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .

# 의존성 다운로드 (캐싱 활용)
RUN ./mvnw dependency:go-offline

# 소스 코드 복사
COPY src src

# 개발 모드로 실행 (Hot Reload 지원)
CMD ["./mvnw", "spring-boot:run", "-Dspring-boot.run.profiles=local"]
```

```bash
# baemin-dev.sh - 한 줄로 개발 환경 시작
#!/bin/bash

echo "🍔 배달의민족 로컬 개발 환경을 시작합니다..."

# Docker Compose로 모든 서비스 시작
docker-compose up -d

# 서비스가 준비될 때까지 대기
echo "⏳ 서비스 준비 중..."
sleep 10

# Health Check
until $(curl --output /dev/null --silent --head --fail http://localhost:8080/actuator/health); do
    printf '.'
    sleep 2
done

echo ""
echo "✅ 배달의민족 개발 환경이 준비되었습니다!"
echo ""
echo "🔗 접속 정보:"
echo "   - API: http://localhost:8080"
echo "   - Swagger: http://localhost:8080/swagger-ui.html"
echo "   - MySQL: localhost:3306 (baemin/baemin1234)"
echo "   - Redis: localhost:6379 (password: redis1234)"
echo ""
echo "📝 명령어:"
echo "   - 로그 확인: docker-compose logs -f app"
echo "   - 중지: docker-compose down"
echo "   - 데이터 초기화: docker-compose down -v"
```

**개발자 사용 예시**

```bash
# 1. 저장소 클론
git clone https://github.com/woowabros/baemin-backend.git
cd baemin-backend

# 2. 한 줄로 환경 시작
./baemin-dev.sh

# 3. 코드 수정 후 자동 재시작 확인
# src/main/java/... 파일 수정하면 Spring DevTools가 자동 재시작

# 4. 종료
docker-compose down
```

**결과 지표**
```
┌─────────────────────────────┬──────────┬─────────┬────────┐
│ 지표                        │ 도입 전  │ 도입 후 │ 개선율 │
├─────────────────────────────┼──────────┼─────────┼────────┤
│ 환경 설정 시간              │ 2-3시간  │ 5분     │ -95%   │
│ "내 컴퓨터에서는" 버그      │ 주 5건   │ 주 0.5건│ -90%   │
│ 신입 온보딩 난이도          │ 8/10     │ 3/10    │ -62%   │
│ 로컬-서버 환경 일치도       │ 70%      │ 98%     │ +40%   │
└─────────────────────────────┴──────────┴─────────┴────────┘
```

**핵심 교훈**
1. **컨테이너 사용**: OS 차이를 Docker가 흡수
2. **한 줄 시작**: `./baemin-dev.sh`로 모든 환경 자동 구성
3. **실서버와 동일**: 로컬에서 MySQL, Redis 등 실제 환경과 동일하게 사용
4. **빠른 초기화**: `docker-compose down -v`로 깨끗한 상태로 복구

---

## 👨‍💻 주니어 개발자 시나리오

실무에서 주니어 개발자가 자주 겪는 문제 상황과 해결 방법입니다.

### 시나리오 1: JDK 버전 충돌 - "왜 동료 컴퓨터에서는 되는데 내 컴퓨터에서는 안 되지?"

**상황**
민수는 첫 출근 후 Git에서 프로젝트를 클론했습니다. 하지만 실행하면 이런 에러가 발생합니다.

```
Error: A JNI error has occurred, please check your installation and try again
Exception in thread "main" java.lang.UnsupportedClassVersionError:
com/example/demo/DemoApplication has been compiled by a more recent version of the Java Runtime (class file version 61.0),
this version of the Java Runtime only recognizes class file versions up to 55.0
```

**문제 분석**
```
┌─────────────────────────────────────────────────┐
│ 클래스 파일 버전 번호                            │
├─────────────┬───────────────┬───────────────────┤
│ Java 버전   │ 클래스 버전   │ 16진수            │
├─────────────┼───────────────┼───────────────────┤
│ Java 11     │ 55.0          │ 0x37              │
│ Java 17     │ 61.0          │ 0x3D              │
│ Java 21     │ 65.0          │ 0x41              │
└─────────────┴───────────────┴───────────────────┘

민수의 상황:
- 프로젝트: Java 17로 컴파일 (61.0)
- 민수 PC: Java 11 설치 (55.0만 인식)
→ 버전 불일치!
```

**해결 과정**

```bash
# 1단계: 현재 Java 버전 확인
java -version
# 출력: openjdk version "11.0.12" 2021-07-20

# 2단계: 프로젝트가 요구하는 Java 버전 확인
cat pom.xml | grep -A 2 java.version
# 출력:
# <java.version>17</java.version>

# 3단계: Java 17 다운로드 및 설치
# Windows:
# https://adoptium.net/temurin/releases/?version=17 에서 MSI 설치

# macOS:
brew install openjdk@17

# Linux:
sudo apt-get install openjdk-17-jdk

# 4단계: 여러 Java 버전이 있을 때 JAVA_HOME 설정
# Windows: 시스템 환경 변수에서 JAVA_HOME 설정
setx JAVA_HOME "C:\Program Files\Eclipse Adoptium\jdk-17.0.8.7-hotspot"

# macOS/Linux: ~/.zshrc 또는 ~/.bashrc에 추가
export JAVA_HOME=/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home
export PATH=$JAVA_HOME/bin:$PATH

# 5단계: 터미널 재시작 후 확인
java -version
# 출력: openjdk version "17.0.8" 2023-07-18

# 6단계: 프로젝트 다시 빌드
./mvnw clean package
# 이제 성공!
```

**IntelliJ에서 JDK 설정**

```
File > Project Structure (Ctrl+Alt+Shift+S)
  ├─ Project
  │   └─ SDK: [17] (Download JDK... 에서 설치 가능)
  └─ Modules
      └─ Language level: 17 - Sealed types, always-strict floating-point semantics

Settings > Build, Execution, Deployment > Build Tools > Maven
  └─ JRE for importer: 17
  └─ JDK for Maven: 17
```

**교훈**
- ✅ `java -version`과 프로젝트 요구 버전을 항상 확인
- ✅ JAVA_HOME 환경 변수 설정 필수
- ✅ IntelliJ의 SDK 설정도 확인
- ❌ 프로젝트마다 다른 Java 버전이 필요하면 jEnv(Mac) 또는 Jabba(Windows) 사용

---

### 시나리오 2: Port 충돌 - "8080 포트가 이미 사용 중입니다"

**상황**
지은이는 Spring Boot 앱을 실행하려는데 이런 에러가 발생합니다.

```
***************************
APPLICATION FAILED TO START
***************************

Description:

Web server failed to start. Port 8080 was already in use.

Action:

Identify and stop the process that's listening on port 8080 or configure this application to listen on another port.
```

**원인**
- 이전에 실행한 애플리케이션이 종료되지 않음
- 다른 프로그램(Tomcat, Node.js 등)이 8080 포트 사용 중

**해결 방법**

```bash
# ===== Windows =====

# 1단계: 8080 포트를 사용하는 프로세스 찾기
netstat -ano | findstr :8080
# 출력:
#   TCP    0.0.0.0:8080    0.0.0.0:0    LISTENING    12345

# 2단계: PID로 프로세스 정보 확인
tasklist | findstr 12345
# 출력:
#   java.exe    12345 Console    1    234,567 K

# 3단계: 프로세스 종료
taskkill /F /PID 12345
# 출력: SUCCESS: The process with PID 12345 has been terminated.

# ===== macOS/Linux =====

# 1단계: 8080 포트를 사용하는 프로세스 찾기
lsof -i :8080
# 출력:
# COMMAND   PID USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
# java    12345 user   47u  IPv6  0x1234      0t0  TCP *:http-alt (LISTEN)

# 2단계: 프로세스 종료
kill -9 12345

# 또는 한 줄로
lsof -ti :8080 | xargs kill -9
```

**대안: 다른 포트 사용**

```yaml
# application.yml
server:
  port: 8081  # 다른 포트로 변경
```

```bash
# 또는 실행 시 포트 지정
./mvnw spring-boot:run -Dspring-boot.run.arguments=--server.port=8081
```

**IntelliJ에서 실행 중인 애플리케이션 확인**

```
Run > Stop (Ctrl+F2) - 모든 실행 중인 애플리케이션 종료

또는 하단 Run 탭에서:
  └─ Stop 버튼 클릭 (빨간 사각형)
```

**교훈**
- ✅ `netstat` 또는 `lsof`로 포트 사용 확인
- ✅ IntelliJ를 종료해도 백그라운드에서 실행 중일 수 있음
- ✅ 개발용으로는 8080 대신 8081, 8082 등 다른 포트 사용 권장
- ❌ 서버 종료는 Ctrl+C만으로는 부족할 수 있음 (프로세스 확인 필수)

---

### 시나리오 3: Maven/Gradle 빌드 실패 - "의존성을 다운로드할 수 없습니다"

**상황**
수진이는 프로젝트를 클론한 후 IntelliJ에서 열었는데 빌드가 계속 실패합니다.

```
[ERROR] Failed to execute goal on project demo:
Could not resolve dependencies for project com.example:demo:jar:0.0.1-SNAPSHOT:
Failed to collect dependencies at org.springframework.boot:spring-boot-starter-web:jar:3.2.0:
Failed to read artifact descriptor for org.springframework.boot:spring-boot-starter-web:jar:3.2.0:
Could not transfer artifact org.springframework.boot:spring-boot-starter-web:pom:3.2.0
from/to central (https://repo.maven.apache.org/maven2):
Connection timed out
```

**원인 1: 인터넷 연결 문제 (회사 방화벽)**

```bash
# 진단: Maven Central 접속 테스트
curl -I https://repo.maven.apache.org/maven2/
# 타임아웃 발생 → 방화벽 문제

# 해결: 회사 내부 Nexus 사용
# ~/.m2/settings.xml 생성
mkdir -p ~/.m2
cat > ~/.m2/settings.xml <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<settings>
  <mirrors>
    <mirror>
      <id>company-nexus</id>
      <url>https://nexus.company.com/repository/maven-public/</url>
      <mirrorOf>central</mirrorOf>
    </mirror>
  </mirrors>

  <!-- 프록시 설정이 필요한 경우 -->
  <proxies>
    <proxy>
      <id>company-proxy</id>
      <active>true</active>
      <protocol>http</protocol>
      <host>proxy.company.com</host>
      <port>8080</port>
    </proxy>
  </proxies>
</settings>
EOF
```

**원인 2: 로컬 Maven 캐시 손상**

```bash
# 진단: 캐시 디렉토리 확인
ls -la ~/.m2/repository/org/springframework/boot/spring-boot-starter-web/3.2.0/
# *.jar.lastUpdated 파일들이 있음 → 캐시 손상

# 해결: 캐시 삭제 후 재빌드
rm -rf ~/.m2/repository/org/springframework/boot
./mvnw clean install -U

# 또는 전체 캐시 삭제 (주의: 모든 의존성 재다운로드)
rm -rf ~/.m2/repository
./mvnw clean install
```

**원인 3: IntelliJ Maven 설정 문제**

```
IntelliJ 설정:

Settings > Build, Execution, Deployment > Build Tools > Maven
  ├─ Maven home directory: [Bundled (Maven 3.9.5)]
  ├─ User settings file: [Override] ~/.m2/settings.xml
  ├─ Local repository: [Override] ~/.m2/repository
  └─ [✓] Work offline (오프라인 모드 해제 확인!)

그리고:
  └─ Importing
      └─ [✓] Import Maven projects automatically
      └─ VM options for importer: -Xmx1024m
```

**IntelliJ에서 Maven 동기화**

```
1. pom.xml 파일 우클릭
   └─ Maven > Reload Project

2. 또는 Maven 탭 (오른쪽)
   └─ 새로고침 아이콘 클릭 (Reload All Maven Projects)

3. 캐시 문제라면
   File > Invalidate Caches... > Invalidate and Restart
```

**확인 사항 체크리스트**

```markdown
## Maven 빌드 문제 해결 체크리스트

1. [ ] 인터넷 연결 확인
   - [ ] `curl https://repo.maven.apache.org/maven2/` 접속 테스트

2. [ ] Maven 버전 확인
   - [ ] `./mvnw -v` 또는 `mvn -v`로 3.6 이상인지 확인

3. [ ] settings.xml 설정
   - [ ] `~/.m2/settings.xml` 존재 여부
   - [ ] 회사 Nexus/프록시 설정 확인

4. [ ] 로컬 캐시 정리
   - [ ] `rm -rf ~/.m2/repository` 후 재빌드

5. [ ] IntelliJ 설정
   - [ ] Work offline 모드 해제
   - [ ] User settings file 경로 확인

6. [ ] 방화벽/VPN
   - [ ] 회사 VPN 연결 필요한지 확인
   - [ ] IT 팀에 Maven Central 접근 요청
```

**교훈**
- ✅ 회사에서는 내부 Nexus 사용이 일반적
- ✅ `~/.m2/settings.xml` 파일을 팀에서 공유
- ✅ 의존성 다운로드 실패 시 캐시 삭제가 가장 빠른 해결책
- ❌ "Work offline" 모드를 켠 채로 두면 안 됨

---

### 시나리오 4: Lombok이 동작하지 않습니다 - "@Getter를 인식하지 못해요"

**상황**
현우는 강의에서 본 대로 `@Getter`, `@Setter`를 사용했는데 빨간 줄이 그어집니다.

```java
package com.example.demo;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class User {
    private Long id;
    private String name;
}

// 다른 클래스에서 사용
User user = new User();
user.setName("현우");  // ❌ Error: Cannot resolve method 'setName'
String name = user.getName();  // ❌ Error: Cannot resolve method 'getName'
```

**원인 3가지**

```
┌─────────────────────────────────────────────────┐
│ Lombok이 동작하지 않는 원인                      │
├────┬────────────────────────────────────────────┤
│ 1  │ Lombok 플러그인 미설치                     │
│ 2  │ Annotation Processing 비활성화             │
│ 3  │ Lombok 의존성 미추가                       │
└────┴────────────────────────────────────────────┘
```

**해결 1: Lombok 플러그인 설치**

```
IntelliJ IDEA:

File > Settings > Plugins
  └─ Marketplace 탭
      └─ 검색: "Lombok"
      └─ Lombok 플러그인 설치 (JetBrains 공식)
      └─ Apply > IDE 재시작

설치 확인:
Settings > Plugins > Installed
  └─ Lombok Plugin (✓ 활성화됨)
```

**해결 2: Annotation Processing 활성화**

```
IntelliJ IDEA:

Settings > Build, Execution, Deployment > Compiler > Annotation Processors
  └─ [✓] Enable annotation processing
  └─ Store generated sources relative to: Module content root
  └─ Production sources directory: generated
  └─ Test sources directory: generated_tests

Apply > OK
```

**해결 3: Lombok 의존성 추가**

```xml
<!-- pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.30</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
```

```groovy
// build.gradle
dependencies {
    compileOnly 'org.projectlombok:lombok:1.18.30'
    annotationProcessor 'org.projectlombok:lombok:1.18.30'
}
```

**테스트: Lombok이 제대로 동작하는지 확인**

```java
package com.example.demo;

import lombok.*;

@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
public class Product {
    private Long id;
    private String name;
    private int price;
}

// 테스트 코드
public class LombokTest {
    public static void main(String[] args) {
        Product product = new Product();
        product.setId(1L);
        product.setName("노트북");
        product.setPrice(1500000);

        System.out.println(product);
        // 출력: Product(id=1, name=노트북, price=1500000)

        Product product2 = new Product(2L, "마우스", 30000);
        System.out.println(product2.getName());
        // 출력: 마우스

        System.out.println("✅ Lombok이 정상 동작합니다!");
    }
}
```

**실행 후 빌드 디렉토리 확인**

```bash
# Lombok이 생성한 코드 확인 (디컴파일)
cd target/classes
javap -p com.example.demo.Product

# 출력 예시:
# public class com.example.demo.Product {
#   private java.lang.Long id;
#   private java.lang.String name;
#   private int price;
#   public java.lang.Long getId();      ← Lombok이 생성
#   public void setId(java.lang.Long);  ← Lombok이 생성
#   public java.lang.String getName();  ← Lombok이 생성
#   ...
# }
```

**교훈**
- ✅ Lombok 사용 시 3가지 설정 모두 필요: 플러그인 + Annotation Processing + 의존성
- ✅ Spring Initializr에서 Lombok을 선택하면 의존성은 자동 추가됨
- ✅ 팀원 전체가 동일한 Lombok 버전 사용 권장
- ❌ Lombok은 컴파일 타임에 코드를 생성하므로 IDE에서만 에러가 보일 수 있음

---

## 🛠️ 실전 프로젝트: 멀티 환경 TODO 애플리케이션

이제 배운 내용을 모두 활용하여 **로컬/개발/운영 환경을 분리한 TODO 애플리케이션**을 만들어봅시다.

### 프로젝트 개요

```
📦 todo-app (멀티 환경 TODO 애플리케이션)
  ├─ 로컬: H2 인메모리 DB 사용
  ├─ 개발: MySQL 사용 (Docker Compose)
  └─ 운영: PostgreSQL 사용 (환경 변수 주입)
```

### 1단계: Spring Initializr로 프로젝트 생성

```bash
# start.spring.io에서 설정
Project: Maven
Language: Java
Spring Boot: 3.2.1
Project Metadata:
  Group: com.example
  Artifact: todo-app
  Name: todo-app
  Packaging: Jar
  Java: 17

Dependencies:
  - Spring Web
  - Spring Data JPA
  - H2 Database
  - MySQL Driver
  - PostgreSQL Driver
  - Lombok
  - Validation
```

### 2단계: 프로젝트 구조

```
todo-app/
├── src/
│   ├── main/
│   │   ├── java/com/example/todoapp/
│   │   │   ├── TodoAppApplication.java
│   │   │   ├── domain/
│   │   │   │   └── Todo.java
│   │   │   ├── repository/
│   │   │   │   └── TodoRepository.java
│   │   │   ├── service/
│   │   │   │   ├── TodoService.java
│   │   │   │   └── TodoServiceImpl.java
│   │   │   └── controller/
│   │   │       └── TodoController.java
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── application-local.yml
│   │       ├── application-dev.yml
│   │       └── application-prod.yml
│   └── test/
│       └── java/com/example/todoapp/
│           └── TodoServiceTest.java
├── docker-compose.yml
├── pom.xml
└── README.md
```

### 3단계: 도메인 엔티티 작성

```java
// src/main/java/com/example/todoapp/domain/Todo.java
package com.example.todoapp.domain;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "todos")
@Getter
@Setter
@ToString
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Todo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 200)
    private String title;

    @Column(length = 1000)
    private String description;

    @Column(nullable = false)
    private Boolean completed = false;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
```

### 4단계: Repository 작성

```java
// src/main/java/com/example/todoapp/repository/TodoRepository.java
package com.example.todoapp.repository;

import com.example.todoapp.domain.Todo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long> {

    // 완료 여부로 조회
    List<Todo> findByCompleted(Boolean completed);

    // 제목에 특정 키워드 포함된 TODO 조회
    List<Todo> findByTitleContaining(String keyword);
}
```

### 5단계: Service 작성

```java
// src/main/java/com/example/todoapp/service/TodoService.java
package com.example.todoapp.service;

import com.example.todoapp.domain.Todo;
import java.util.List;
import java.util.Optional;

public interface TodoService {
    List<Todo> getAllTodos();
    Optional<Todo> getTodoById(Long id);
    Todo createTodo(String title, String description);
    Todo updateTodo(Long id, String title, String description, Boolean completed);
    void deleteTodo(Long id);
    List<Todo> getCompletedTodos();
    List<Todo> getIncompleteTodos();
}
```

```java
// src/main/java/com/example/todoapp/service/TodoServiceImpl.java
package com.example.todoapp.service;

import com.example.todoapp.domain.Todo;
import com.example.todoapp.repository.TodoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
@Transactional(readOnly = true)
public class TodoServiceImpl implements TodoService {

    private final TodoRepository todoRepository;

    @Override
    public List<Todo> getAllTodos() {
        log.info("전체 TODO 목록 조회");
        return todoRepository.findAll();
    }

    @Override
    public Optional<Todo> getTodoById(Long id) {
        log.info("TODO 조회: id={}", id);
        return todoRepository.findById(id);
    }

    @Override
    @Transactional
    public Todo createTodo(String title, String description) {
        log.info("TODO 생성: title={}", title);
        Todo todo = Todo.builder()
                .title(title)
                .description(description)
                .completed(false)
                .build();
        return todoRepository.save(todo);
    }

    @Override
    @Transactional
    public Todo updateTodo(Long id, String title, String description, Boolean completed) {
        log.info("TODO 수정: id={}", id);
        Todo todo = todoRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("TODO를 찾을 수 없습니다: " + id));

        todo.setTitle(title);
        todo.setDescription(description);
        todo.setCompleted(completed);

        return todoRepository.save(todo);
    }

    @Override
    @Transactional
    public void deleteTodo(Long id) {
        log.info("TODO 삭제: id={}", id);
        todoRepository.deleteById(id);
    }

    @Override
    public List<Todo> getCompletedTodos() {
        log.info("완료된 TODO 목록 조회");
        return todoRepository.findByCompleted(true);
    }

    @Override
    public List<Todo> getIncompleteTodos() {
        log.info("미완료 TODO 목록 조회");
        return todoRepository.findByCompleted(false);
    }
}
```

### 6단계: Controller 작성

```java
// src/main/java/com/example/todoapp/controller/TodoController.java
package com.example.todoapp.controller;

import com.example.todoapp.domain.Todo;
import com.example.todoapp.service.TodoService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/todos")
@RequiredArgsConstructor
@Slf4j
public class TodoController {

    private final TodoService todoService;

    // 환경 확인용 엔드포인트
    @GetMapping("/health")
    public ResponseEntity<Map<String, String>> health(
            @Value("${spring.profiles.active:default}") String profile) {
        return ResponseEntity.ok(Map.of(
            "status", "UP",
            "profile", profile,
            "message", "TODO App is running on " + profile + " environment"
        ));
    }

    // 전체 TODO 목록 조회
    @GetMapping
    public ResponseEntity<List<Todo>> getAllTodos() {
        List<Todo> todos = todoService.getAllTodos();
        return ResponseEntity.ok(todos);
    }

    // ID로 TODO 조회
    @GetMapping("/{id}")
    public ResponseEntity<Todo> getTodoById(@PathVariable Long id) {
        return todoService.getTodoById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    // TODO 생성
    @PostMapping
    public ResponseEntity<Todo> createTodo(@RequestBody Map<String, String> request) {
        String title = request.get("title");
        String description = request.get("description");

        if (title == null || title.trim().isEmpty()) {
            return ResponseEntity.badRequest().build();
        }

        Todo todo = todoService.createTodo(title, description);
        return ResponseEntity.status(HttpStatus.CREATED).body(todo);
    }

    // TODO 수정
    @PutMapping("/{id}")
    public ResponseEntity<Todo> updateTodo(
            @PathVariable Long id,
            @RequestBody Map<String, Object> request) {

        String title = (String) request.get("title");
        String description = (String) request.get("description");
        Boolean completed = (Boolean) request.getOrDefault("completed", false);

        try {
            Todo updatedTodo = todoService.updateTodo(id, title, description, completed);
            return ResponseEntity.ok(updatedTodo);
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    // TODO 삭제
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTodo(@PathVariable Long id) {
        todoService.deleteTodo(id);
        return ResponseEntity.noContent().build();
    }

    // 완료된 TODO 목록
    @GetMapping("/completed")
    public ResponseEntity<List<Todo>> getCompletedTodos() {
        List<Todo> todos = todoService.getCompletedTodos();
        return ResponseEntity.ok(todos);
    }

    // 미완료 TODO 목록
    @GetMapping("/incomplete")
    public ResponseEntity<List<Todo>> getIncompleteTodos() {
        List<Todo> todos = todoService.getIncompleteTodos();
        return ResponseEntity.ok(todos);
    }
}
```

### 7단계: 멀티 환경 설정 파일

```yaml
# src/main/resources/application.yml (공통 설정)
spring:
  application:
    name: todo-app

  jpa:
    hibernate:
      ddl-auto: validate
    properties:
      hibernate:
        format_sql: true
        show_sql: false

logging:
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  level:
    root: INFO
```

```yaml
# src/main/resources/application-local.yml (로컬 환경)
spring:
  config:
    activate:
      on-profile: local

  datasource:
    url: jdbc:h2:mem:tododb
    driver-class-name: org.h2.Driver
    username: sa
    password:

  h2:
    console:
      enabled: true
      path: /h2-console

  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true

server:
  port: 8080

logging:
  level:
    com.example.todoapp: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
```

```yaml
# src/main/resources/application-dev.yml (개발 환경)
spring:
  config:
    activate:
      on-profile: dev

  datasource:
    url: jdbc:mysql://localhost:3307/tododb_dev
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: todouser
    password: todopass123
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true

server:
  port: 8080

logging:
  level:
    com.example.todoapp: DEBUG
```

```yaml
# src/main/resources/application-prod.yml (운영 환경)
spring:
  config:
    activate:
      on-profile: prod

  datasource:
    url: ${DB_URL}
    driver-class-name: org.postgresql.Driver
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 50
      minimum-idle: 20
      connection-timeout: 20000
      idle-timeout: 300000
      max-lifetime: 1200000

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false

server:
  port: ${SERVER_PORT:8080}

logging:
  level:
    com.example.todoapp: INFO
    org.hibernate: WARN
```

### 8단계: Docker Compose로 개발 환경 구성

```yaml
# docker-compose.yml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    container_name: todo-mysql
    environment:
      MYSQL_ROOT_PASSWORD: root1234
      MYSQL_DATABASE: tododb_dev
      MYSQL_USER: todouser
      MYSQL_PASSWORD: todopass123
    ports:
      - "3307:3306"
    volumes:
      - mysql-data:/var/lib/mysql
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci

volumes:
  mysql-data:
```

### 9단계: 실행 방법

```bash
# ===== 로컬 환경 (H2) =====
# IntelliJ: Edit Configurations > Active profiles: local
./mvnw spring-boot:run -Dspring-boot.run.profiles=local

# 접속:
# - API: http://localhost:8080/api/todos
# - H2 Console: http://localhost:8080/h2-console
#   JDBC URL: jdbc:h2:mem:tododb

# ===== 개발 환경 (MySQL + Docker) =====
# 1. MySQL 시작
docker-compose up -d

# 2. 애플리케이션 실행
./mvnw spring-boot:run -Dspring-boot.run.profiles=dev

# 3. MySQL 접속 확인
docker exec -it todo-mysql mysql -u todouser -ptodopass123 tododb_dev
# mysql> SHOW TABLES;
# mysql> SELECT * FROM todos;

# ===== 운영 환경 (PostgreSQL) =====
# 환경 변수 설정 후 실행
export DB_URL=jdbc:postgresql://prod-db.example.com:5432/tododb_prod
export DB_USERNAME=prod_user
export DB_PASSWORD=super_secret_password
export SERVER_PORT=8080

java -jar target/todo-app-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod
```

### 10단계: API 테스트

```bash
# 1. Health Check
curl http://localhost:8080/api/todos/health
# 출력: {"status":"UP","profile":"local","message":"TODO App is running on local environment"}

# 2. TODO 생성
curl -X POST http://localhost:8080/api/todos \
  -H "Content-Type: application/json" \
  -d '{"title":"Spring 공부하기","description":"IoC, DI, AOP 학습"}'

# 3. 전체 TODO 조회
curl http://localhost:8080/api/todos

# 4. TODO 수정 (완료 처리)
curl -X PUT http://localhost:8080/api/todos/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Spring 공부하기","description":"IoC, DI, AOP 학습","completed":true}'

# 5. 완료된 TODO 조회
curl http://localhost:8080/api/todos/completed

# 6. TODO 삭제
curl -X DELETE http://localhost:8080/api/todos/1
```

### 프로젝트 완성 확인

```markdown
## ✅ 완성 체크리스트

환경 설정:
- [ ] JDK 17 설치 및 JAVA_HOME 설정
- [ ] IntelliJ IDEA에서 프로젝트 열림
- [ ] Lombok 플러그인 설치 및 Annotation Processing 활성화
- [ ] Maven 의존성 다운로드 성공

로컬 환경 (H2):
- [ ] local 프로필로 애플리케이션 실행
- [ ] http://localhost:8080/h2-console 접속
- [ ] API 테스트 성공

개발 환경 (MySQL):
- [ ] docker-compose up으로 MySQL 시작
- [ ] dev 프로필로 애플리케이션 실행
- [ ] MySQL에서 todos 테이블 확인
- [ ] API 테스트 성공

코드 품질:
- [ ] 모든 클래스에 Lombok 적용
- [ ] Service 계층에 @Transactional 적용
- [ ] Controller에서 ResponseEntity 사용
- [ ] 로깅이 적절히 동작
```

---

## ❓ FAQ (자주 묻는 질문)

### Q1. Java를 여러 버전 설치했는데, 프로젝트마다 다른 버전을 사용하고 싶어요.

**A1. 여러 JDK 버전 관리 도구 사용**

```bash
# ===== macOS/Linux: jEnv =====
# 설치
brew install jenv

# jEnv 초기화
echo 'export PATH="$HOME/.jenv/bin:$PATH"' >> ~/.zshrc
echo 'eval "$(jenv init -)"' >> ~/.zshrc
source ~/.zshrc

# 설치된 Java 추가
jenv add /Library/Java/JavaVirtualMachines/temurin-11.jdk/Contents/Home
jenv add /Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home

# Java 버전 목록 확인
jenv versions

# 전역 버전 설정
jenv global 17.0

# 프로젝트별 버전 설정
cd ~/projects/legacy-project
jenv local 11.0

cd ~/projects/new-spring-project
jenv local 17.0

# 확인
java -version  # 각 디렉토리에서 다른 버전 출력

# ===== Windows: Jabba =====
# PowerShell에서 설치
Invoke-Expression (Invoke-WebRequest https://github.com/shyiko/jabba/raw/master/install.ps1 -UseBasicParsing).Content

# Java 설치
jabba install openjdk@1.17.0
jabba install openjdk@1.11.0

# 사용할 버전 선택
jabba use openjdk@1.17.0

# 확인
jabba current
java -version
```

**IntelliJ에서 프로젝트별 JDK 설정**

```
File > Project Structure > Project
  └─ SDK: [프로젝트별로 다른 JDK 선택]

각 프로젝트가 독립적인 JDK 사용 가능!
```

---

### Q2. Maven과 Gradle 중 무엇을 선택해야 하나요?

**A2. 상황에 따라 선택**

```
┌──────────────────┬─────────────────┬─────────────────┐
│ 비교 항목        │ Maven           │ Gradle          │
├──────────────────┼─────────────────┼─────────────────┤
│ 설정 파일        │ pom.xml (XML)   │ build.gradle    │
│                  │                 │ (Groovy/Kotlin) │
├──────────────────┼─────────────────┼─────────────────┤
│ 빌드 속도        │ 보통            │ 빠름 (증분빌드) │
├──────────────────┼─────────────────┼─────────────────┤
│ 학습 난이도      │ 쉬움            │ 중간            │
├──────────────────┼─────────────────┼─────────────────┤
│ 기업 사용률      │ 70%             │ 30%             │
├──────────────────┼─────────────────┼─────────────────┤
│ Spring 공식 가이드│ Maven 위주      │ 점점 증가       │
├──────────────────┼─────────────────┼─────────────────┤
│ 멀티 모듈        │ 복잡함          │ 간결함          │
├──────────────────┼─────────────────┼─────────────────┤
│ 추천 대상        │ 초보자          │ 경험자, 대규모  │
│                  │ 레거시 프로젝트 │ 마이크로서비스  │
└──────────────────┴─────────────────┴─────────────────┘
```

**권장 사항**
- **초보자**: Maven부터 시작 (Spring 공식 문서가 Maven 기준)
- **신규 프로젝트**: Gradle 고려 (빌드 속도, 유연성)
- **기존 프로젝트**: 현재 사용 중인 도구 유지
- **Spring Boot**: 둘 다 잘 지원하므로 팀의 선호도에 따라 선택

---

### Q3. IntelliJ Community vs Ultimate, 어떤 걸 사용해야 하나요?

**A3. Spring Boot 학습에는 Community면 충분**

```
┌──────────────────────┬────────────┬────────────────┐
│ 기능                 │ Community  │ Ultimate       │
├──────────────────────┼────────────┼────────────────┤
│ 가격                 │ 무료       │ $149/년 (학생무료) │
├──────────────────────┼────────────┼────────────────┤
│ Java 개발            │ ✅         │ ✅             │
│ Maven/Gradle 지원    │ ✅         │ ✅             │
│ Git 통합             │ ✅         │ ✅             │
│ Spring Boot 개발     │ ✅         │ ✅             │
│ REST API 테스트      │ ✅ (플러그인)│ ✅ (내장)      │
├──────────────────────┼────────────┼────────────────┤
│ Spring Framework 지원│ ❌         │ ✅             │
│ (XML 설정 자동완성)  │            │                │
│ Database Tools       │ ❌         │ ✅             │
│ Thymeleaf 지원       │ ❌         │ ✅             │
│ JavaScript/React     │ ❌         │ ✅             │
│ Docker 통합          │ ❌         │ ✅             │
└──────────────────────┴────────────┴────────────────┘
```

**권장 사항**
- **학습 목적**: Community Edition으로 시작
- **취업 준비생/학생**: Ultimate 학생 라이선스 신청 (무료)
  - https://www.jetbrains.com/community/education/
- **실무 개발자**: 회사에서 라이선스 제공하는 경우 많음
- **프론트엔드도 개발**: Ultimate 필요 (React, Vue 지원)

---

### Q4. Spring Boot DevTools가 자동 재시작이 안 돼요.

**A4. 설정 확인 필요**

```
IntelliJ 설정:

Settings > Build, Execution, Deployment > Compiler
  └─ [✓] Build project automatically

Settings > Advanced Settings
  └─ [✓] Allow auto-make to start even if developed application is currently running
```

```xml
<!-- pom.xml에 DevTools 추가 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
    <optional>true</optional>
</dependency>
```

**작동 원리**
1. 코드 수정
2. IntelliJ가 자동으로 컴파일 (Build project automatically)
3. DevTools가 변경 감지
4. 애플리케이션 자동 재시작

**주의사항**
- static 파일(HTML, CSS)은 재시작 없이 반영
- Java 코드 변경은 재시작 필요 (2-3초 소요)
- 완전한 재시작보다 훨씬 빠름

---

### Q5. application.yml vs application.properties, 어떤 게 더 좋나요?

**A5. YAML이 더 읽기 쉽고 최신 트렌드**

```properties
# application.properties (전통적)
spring.application.name=my-app
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=user
spring.datasource.password=pass
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

```yaml
# application.yml (현대적)
spring:
  application:
    name: my-app
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
    password: pass
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
```

**장단점 비교**
```
┌─────────────────┬──────────────┬──────────────┐
│ 항목            │ Properties   │ YAML         │
├─────────────────┼──────────────┼──────────────┤
│ 가독성          │ 보통         │ 우수         │
│ 계층 구조       │ 반복적       │ 명확         │
│ 주석            │ #            │ #            │
│ 배열 지원       │ 불편         │ 쉬움         │
│ Spring 공식예제 │ 과거 사용    │ 최신 사용    │
│ 오타 민감도     │ 낮음         │ 높음(들여쓰기)│
└─────────────────┴──────────────┴──────────────┘
```

**권장 사항**
- **신규 프로젝트**: YAML 사용
- **기존 프로젝트**: 현재 형식 유지
- **복잡한 설정**: YAML이 훨씬 읽기 쉬움

---

### Q6. M1/M2 Mac에서 개발 환경 설정 시 주의사항이 있나요?

**A6. ARM 아키텍처 호환성 확인 필요**

```bash
# 1. Rosetta 2 설치 (Intel 앱 실행용)
softwareupdate --install-rosetta

# 2. ARM 네이티브 JDK 설치 (추천)
brew install openjdk@17

# 3. Docker Desktop for Mac (Apple Silicon 버전) 설치
# https://docs.docker.com/desktop/install/mac-install/

# 4. 아키텍처 확인
uname -m
# 출력: arm64 (Apple Silicon) 또는 x86_64 (Intel)

# 5. Java 아키텍처 확인
java -version
# "aarch64" 또는 "arm64"가 포함되어 있으면 ARM 네이티브
```

**MySQL 이미지 호환성 (중요!)**

```yaml
# docker-compose.yml
# ❌ 잘못된 예 (x86 전용 이미지)
services:
  mysql:
    image: mysql:8.0  # 일부 버전은 ARM 미지원

# ✅ 올바른 예 (ARM 지원 확인)
services:
  mysql:
    image: mysql:8.0  # 8.0.27 이상은 ARM 지원
    platform: linux/arm64/v8  # 명시적으로 지정
```

**주의사항**
- 일부 오래된 Docker 이미지는 ARM 미지원
- `platform: linux/amd64`를 명시하면 Rosetta로 에뮬레이션 (느림)
- 네이티브 ARM 이미지 사용 권장

---

### Q7. Git에 올리면 안 되는 파일은 무엇인가요?

**A7. .gitignore 파일 작성 필수**

```gitignore
# .gitignore

# ===== 빌드 결과물 =====
target/
build/
out/
*.jar
*.war
*.class

# ===== IDE 설정 파일 =====
.idea/
*.iml
.vscode/
.DS_Store

# ===== 환경 변수 & 비밀 정보 (절대 커밋 금지!) =====
application-local.yml
application-prod.yml
.env
*.key
*.pem
*.p12
*.jks

# ===== 로그 파일 =====
*.log
logs/

# ===== OS 생성 파일 =====
Thumbs.db
.DS_Store

# ===== Maven/Gradle =====
.mvn/
!.mvn/wrapper/maven-wrapper.jar
.gradle/
```

**민감 정보 관리 방법**

```yaml
# ❌ 나쁜 예: 비밀번호를 직접 작성
spring:
  datasource:
    password: mySecretPassword123!

# ✅ 좋은 예: 환경 변수 사용
spring:
  datasource:
    password: ${DB_PASSWORD}
```

```bash
# 로컬에서만 사용하는 환경 변수 파일
# .env (Git에 추가 금지!)
DB_PASSWORD=mySecretPassword123!
```

**이미 커밋한 비밀 정보 제거**

```bash
# ⚠️ 주의: 히스토리를 다시 쓰므로 팀원과 협의 필요
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch src/main/resources/application-prod.yml" \
  --prune-empty --tag-name-filter cat -- --all

# 또는 git-filter-repo 사용 (더 빠름)
git filter-repo --path src/main/resources/application-prod.yml --invert-paths
```

---

## 💼 면접 질문 리스트

### 주니어 개발자 면접 질문 (5-7개)

#### Q1. Spring Boot 개발을 위해 필요한 최소한의 환경 구성 요소는 무엇인가요?

**난이도**: ⭐
**출제 빈도**: 매우 높음
**예상 답변 키워드**: JDK, IDE, Build Tool, Spring Initializr

---

#### Q2. `java -version`과 `javac -version`의 차이는 무엇인가요?

**난이도**: ⭐
**출제 빈도**: 높음
**예상 답변 키워드**: JRE, JDK, 런타임, 컴파일러

---

#### Q3. Maven과 Gradle의 차이점을 설명해주세요.

**난이도**: ⭐⭐
**출제 빈도**: 높음
**예상 답변 키워드**: 빌드 도구, 의존성 관리, pom.xml, build.gradle

---

#### Q4. Spring Initializr에서 "Dependencies"로 추가한 것들은 무엇인가요?

**난이도**: ⭐
**출제 빈도**: 중간
**예상 답변 키워드**: 의존성, 라이브러리, Spring Web, Spring Data JPA

---

#### Q5. `application.yml` 파일의 역할은 무엇인가요?

**난이도**: ⭐
**출제 빈도**: 높음
**예상 답변 키워드**: 설정 파일, 프로퍼티, 환경 설정

---

#### Q6. 개발(dev)과 운영(prod) 환경에서 설정을 다르게 가져가야 하는 이유는 무엇인가요?

**난이도**: ⭐⭐
**출제 빈도**: 높음
**예상 답변 키워드**: Spring Profile, 환경 분리, 보안, 데이터베이스

---

#### Q7. Git에 올리면 안 되는 파일과 그 이유를 설명해주세요.

**난이도**: ⭐
**출제 빈도**: 중간
**예상 답변 키워드**: .gitignore, 비밀 정보, 빌드 결과물, IDE 설정

---

### 중급 개발자 면접 질문 (3-5개)

#### Q8. Spring Profile을 사용하여 환경별로 설정을 분리하는 방법을 설명하고, 실무에서 어떻게 활용했나요?

**난이도**: ⭐⭐⭐
**출제 빈도**: 매우 높음
**예상 답변 키워드**: application-{profile}.yml, @Profile, spring.profiles.active

---

#### Q9. 로컬에서는 H2를, 운영에서는 PostgreSQL을 사용하는 멀티 데이터베이스 환경을 구성할 때 주의할 점은?

**난이도**: ⭐⭐⭐
**출제 빈도**: 높음
**예상 답변 키워드**: JPA 호환성, Dialect, DDL, SQL 차이

---

#### Q10. Docker Compose를 사용하여 로컬 개발 환경을 구성하는 이점은 무엇인가요?

**난이도**: ⭐⭐⭐
**출제 빈도**: 중간
**예상 답변 키워드**: 환경 일관성, 격리, 컨테이너, 재현 가능성

---

#### Q11. Maven의 Dependency Scope(`compile`, `provided`, `runtime`, `test`)를 설명하고, Lombok은 어떤 Scope를 사용해야 하나요?

**난이도**: ⭐⭐⭐
**출제 빈도**: 중간
**예상 답변 키워드**: 컴파일 타임, 런타임, 애노테이션 프로세서, provided

---

#### Q12. CI/CD 파이프라인에서 Spring Boot 애플리케이션을 빌드하고 배포할 때, 환경 변수를 안전하게 주입하는 방법은?

**난이도**: ⭐⭐⭐⭐
**출제 빈도**: 높음
**예상 답변 키워드**: Secret Management, Kubernetes ConfigMap/Secret, AWS Parameter Store

---

## 💼 면접 질문 리스트 답안

### 주니어 개발자 면접 질문 답안

#### A1. Spring Boot 개발을 위해 필요한 최소한의 환경 구성 요소

**답변 구조**: 필수 요소 나열 → 각각의 역할 설명 → 실무 팁

**모범 답변**:
```
Spring Boot 개발을 위해서는 4가지 핵심 요소가 필요합니다.

1. **JDK (Java Development Kit)**:
   - Java 17 이상 권장 (Spring Boot 3.x 기준)
   - 자바 코드를 컴파일하고 실행하는 데 필수

2. **IDE (통합 개발 환경)**:
   - IntelliJ IDEA 또는 Eclipse
   - 코드 작성, 디버깅, 실행을 편리하게 해줌

3. **빌드 도구**:
   - Maven 또는 Gradle
   - 의존성 관리와 프로젝트 빌드 자동화

4. **Spring Initializr**:
   - 프로젝트 초기 구조 생성
   - start.spring.io에서 웹으로 사용 가능

실무에서는 추가로 Git(버전 관리), Docker(환경 격리),
Postman(API 테스트) 등도 함께 사용합니다.
```

**면접관이 좋아하는 포인트**:
- ✅ 단순 나열이 아닌 "왜 필요한지" 설명
- ✅ 버전 정보 언급 (Java 17)
- ✅ 실무 도구까지 추가로 언급

**꼬리 질문 대비**:
- Q: "JDK와 JRE의 차이는?" → A: JDK는 개발 도구 포함, JRE는 실행만 가능
- Q: "IDE 없이 개발 가능한가?" → A: 가능하지만 생산성이 크게 떨어짐

---

#### A2. `java -version`과 `javac -version`의 차이

**답변 구조**: 각 명령어의 역할 설명 → 차이점 강조 → 실무 사례

**모범 답변**:
```
두 명령어는 서로 다른 도구의 버전을 확인합니다.

1. **java -version**:
   - JRE(Java Runtime Environment)의 버전 확인
   - 자바 프로그램을 "실행"하는 환경
   - 예: "openjdk version 17.0.8"

2. **javac -version**:
   - JDK의 컴파일러(Java Compiler) 버전 확인
   - .java 파일을 .class 파일로 "컴파일"하는 도구
   - 예: "javac 17.0.8"

실무에서 주의할 점은, JRE만 설치하면 javac 명령어가
존재하지 않아 컴파일이 불가능합니다. 따라서 개발 환경에는
반드시 JDK를 설치해야 합니다.
```

**실무 예시**:
```bash
# 서버에는 JRE만 설치 (실행만 필요)
java -version  # ✅ 작동
javac -version # ❌ command not found

# 개발 PC에는 JDK 설치 (개발 필요)
java -version  # ✅ 작동
javac -version # ✅ 작동
```

**면접관이 좋아하는 포인트**:
- ✅ JRE vs JDK 차이 이해
- ✅ 실무 시나리오 연결 (서버 vs 개발 PC)

---

#### A3. Maven과 Gradle의 차이점

**답변 구조**: 공통점 → 차이점 비교 → 선택 기준

**모범 답변**:
```
Maven과 Gradle 모두 자바 프로젝트의 빌드 자동화 도구입니다.

**주요 차이점**:

1. **설정 파일 형식**:
   - Maven: pom.xml (XML 기반)
   - Gradle: build.gradle (Groovy/Kotlin DSL)

2. **빌드 속도**:
   - Maven: 매번 전체 빌드
   - Gradle: 증분 빌드로 변경된 부분만 빌드 (더 빠름)

3. **유연성**:
   - Maven: 정해진 라이프사이클 (convention over configuration)
   - Gradle: 사용자 정의 태스크 작성 용이

4. **학습 곡선**:
   - Maven: 단순하고 배우기 쉬움
   - Gradle: Groovy 문법 이해 필요

실무에서는 Spring 공식 문서가 Maven 예제를 많이 사용하므로
초보자는 Maven부터 시작하는 것을 추천합니다. 하지만 멀티
모듈 프로젝트나 Android 개발에서는 Gradle이 더 효율적입니다.
```

**비교표로 정리**:
```
┌─────────────┬──────────┬───────────┐
│ 항목        │ Maven    │ Gradle    │
├─────────────┼──────────┼───────────┤
│ 설정 파일   │ pom.xml  │ build.gradle│
│ 빌드 속도   │ 보통     │ 빠름      │
│ 학습 난이도 │ 쉬움     │ 중간      │
│ 기업 사용률 │ 70%      │ 30%       │
└─────────────┴──────────┴───────────┘
```

---

#### A4. Spring Initializr에서 "Dependencies"로 추가한 것들은 무엇인가요?

**답변 구조**: 의존성 개념 설명 → 예시 → 작동 원리

**모범 답변**:
```
Dependencies는 프로젝트에 필요한 외부 라이브러리입니다.

예를 들어, "Spring Web"을 선택하면:
- Spring MVC (웹 애플리케이션 개발)
- Tomcat (내장 웹 서버)
- Jackson (JSON 변환)
등의 라이브러리가 자동으로 pom.xml에 추가됩니다.

**자주 사용하는 의존성**:
- Spring Web: REST API 개발
- Spring Data JPA: 데이터베이스 연동
- H2 Database: 테스트용 인메모리 DB
- Lombok: 반복 코드 자동 생성

Spring Initializr는 이런 의존성들의 버전 호환성을
자동으로 맞춰주기 때문에, 수동으로 추가할 때보다
훨씬 안전합니다.
```

**실무 팁**:
```xml
<!-- Spring Initializr가 자동 생성한 pom.xml -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <!-- 버전 명시 없음! parent에서 관리 -->
</dependency>

<!-- 이렇게 하면 호환되는 버전이 자동 선택됨 -->
```

---

#### A5. `application.yml` 파일의 역할

**답변 구조**: 정의 → 용도 → 예시 → properties와의 차이

**모범 답변**:
```
application.yml은 Spring Boot 애플리케이션의 설정을
관리하는 파일입니다.

**주요 용도**:
1. 데이터베이스 연결 정보
2. 서버 포트 번호
3. 로깅 레벨
4. 외부 API URL

**예시**:
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: user
  jpa:
    show-sql: true

server:
  port: 8081
```

application.properties보다 YAML 형식이 계층 구조를
더 명확하게 표현할 수 있어 최근에는 yml을 선호합니다.

실무에서는 환경별로 application-local.yml,
application-dev.yml, application-prod.yml처럼
분리하여 관리합니다.
```

**꼬리 질문 대비**:
- Q: "코드에서 이 값을 어떻게 읽나?" → A: `@Value` 또는 `@ConfigurationProperties`

---

#### A6. 개발(dev)과 운영(prod) 환경에서 설정을 다르게 가져가야 하는 이유

**답변 구조**: 문제 상황 제시 → 해결 방법 → 실무 사례

**모범 답변**:
```
개발과 운영 환경은 목적과 요구사항이 다르기 때문입니다.

**환경별 차이점**:

1. **데이터베이스**:
   - 개발: 테스트 데이터 사용, H2 인메모리 DB 가능
   - 운영: 실제 고객 데이터, MySQL/PostgreSQL

2. **로깅**:
   - 개발: DEBUG 레벨 (모든 로그 출력)
   - 운영: INFO/WARN 레벨 (필요한 로그만)

3. **보안**:
   - 개발: 간단한 비밀번호
   - 운영: 강력한 비밀번호, 환경 변수 사용

4. **성능**:
   - 개발: 커넥션 풀 10개
   - 운영: 커넥션 풀 50개 (동시 접속자 많음)

**Spring Profile 예시**:
```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
  jpa:
    show-sql: true

# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://prod-db.company.com:3306/mydb
  jpa:
    show-sql: false
```

실무에서 실수로 운영 DB에 접속하는 사고를 방지하려면
환경 분리가 필수입니다.
```

**실무 사고 사례**:
```
❌ 잘못된 예:
개발자가 로컬에서 테스트하다가 실수로 운영 DB URL을
설정 파일에 넣어서 Git에 커밋 → 고객 데이터 노출 위험

✅ 올바른 예:
환경별로 설정 파일을 분리하고, 운영 환경의 민감 정보는
환경 변수로 주입하여 Git에 올리지 않음
```

---

#### A7. Git에 올리면 안 되는 파일과 그 이유

**답변 구조**: 카테고리별 분류 → 이유 설명 → .gitignore 예시

**모범 답변**:
```
Git에 올리면 안 되는 파일은 크게 4가지 카테고리입니다.

1. **빌드 결과물** (target/, build/, *.jar):
   - 이유: 소스 코드만 있으면 언제든 다시 빌드 가능
   - 용량만 차지하고 불필요

2. **IDE 설정 파일** (.idea/, *.iml, .vscode/):
   - 이유: 개발자마다 IDE 설정이 다름
   - 충돌 발생 가능

3. **민감 정보** (application-prod.yml, .env, *.key):
   - 이유: DB 비밀번호, API 키 등이 노출되면 보안 사고
   - ⚠️ 가장 위험! 절대 커밋 금지

4. **로그 파일** (*.log, logs/):
   - 이유: 임시 파일이며 계속 변경됨
   - 불필요한 커밋 생성

**.gitignore 예시**:
```gitignore
# 빌드
target/
*.jar

# IDE
.idea/
*.iml

# 민감 정보
application-prod.yml
.env

# 로그
*.log
```

실무에서는 실수로 민감 정보를 커밋하는 사고가 자주
발생하므로, 프로젝트 시작 시 .gitignore를 먼저 작성하는
습관이 중요합니다.
```

**실무 사고 사례**:
```
2021년 삼성 개발자가 실수로 AWS 키를 GitHub에 커밋
→ 24시간 만에 $6,000의 EC2 요금 청구
→ .gitignore에 .env 파일을 추가했다면 방지 가능
```

---

### 중급 개발자 면접 질문 답안

#### A8. Spring Profile을 사용하여 환경별로 설정을 분리하는 방법

**답변 구조**: 개념 설명 → 구현 방법 → 실무 활용 사례

**모범 답변**:
```
Spring Profile은 환경별로 다른 Bean과 설정을 로드하는 기능입니다.

**구현 방법**:

1. **설정 파일 분리**:
```yaml
# application.yml (공통)
spring:
  application:
    name: my-app

# application-local.yml (로컬)
spring:
  config.activate.on-profile: local
  datasource:
    url: jdbc:h2:mem:testdb

# application-prod.yml (운영)
spring:
  config.activate.on-profile: prod
  datasource:
    url: jdbc:postgresql://prod-db:5432/mydb
```

2. **Profile 활성화**:
```bash
# 실행 시 지정
java -jar app.jar --spring.profiles.active=prod

# 환경 변수
export SPRING_PROFILES_ACTIVE=prod

# IntelliJ: Run Configurations > Active profiles: prod
```

3. **코드에서 Profile별 Bean 등록**:
```java
@Configuration
@Profile("local")
public class LocalConfig {
    @Bean
    public DataSource dataSource() {
        // H2 인메모리 DB 설정
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        // PostgreSQL 설정
    }
}
```

**실무 활용 사례**:

제가 이전 프로젝트에서는 4개의 Profile을 사용했습니다:
- **local**: H2, 로그 레벨 DEBUG, Mock 외부 API
- **dev**: MySQL, 로그 레벨 DEBUG, 개발 서버 API
- **staging**: MySQL, 로그 레벨 INFO, 운영과 동일 환경
- **prod**: PostgreSQL, 로그 레벨 WARN, 실제 고객 대상

CI/CD 파이프라인에서는 환경 변수로 Profile을 주입하여
동일한 JAR 파일을 여러 환경에 배포할 수 있었습니다.
```

**고급 팁**:
```java
// 여러 Profile 동시 활성화
--spring.profiles.active=prod,monitoring,cache

// Profile 그룹 설정 (Spring Boot 2.4+)
spring.profiles.group.prod=prod,monitoring,cache
```

---

#### A9. 로컬에서는 H2를, 운영에서는 PostgreSQL을 사용하는 멀티 데이터베이스 환경 구성 시 주의할 점

**답변 구조**: 호환성 문제 제시 → 해결 방법 → 실무 경험

**모범 답변**:
```
H2와 PostgreSQL은 SQL 문법과 동작이 다르므로 주의가 필요합니다.

**주요 주의사항**:

1. **JPA Dialect 설정**:
```yaml
# application-local.yml
spring:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect

# application-prod.yml
spring:
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
```

2. **DDL 자동 생성 차이**:
   - H2: `ddl-auto: create-drop` (매번 초기화)
   - PostgreSQL: `ddl-auto: validate` (스키마 검증만)

3. **SQL 문법 차이**:
```sql
-- H2는 대소문자 구분 안 함
SELECT * FROM user;  -- ✅ 작동

-- PostgreSQL은 대소문자 구분 (소문자로 변환)
SELECT * FROM User;  -- ❌ 테이블을 찾을 수 없음
SELECT * FROM "User"; -- ✅ 큰따옴표로 감싸야 함
```

4. **날짜/시간 함수 차이**:
```sql
-- H2
NOW()

-- PostgreSQL
CURRENT_TIMESTAMP
```

**실무 해결책**:

1. **가능한 한 JPA 사용**:
   - 네이티브 SQL 최소화
   - JPQL/Criteria API 활용

2. **로컬에서도 Docker로 PostgreSQL 사용**:
```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    ports:
      - "5432:5432"
```

3. **통합 테스트는 Testcontainers 사용**:
```java
@SpringBootTest
@Testcontainers
class UserServiceTest {
    @Container
    static PostgreSQLContainer<?> postgres =
        new PostgreSQLContainer<>("postgres:15");

    @DynamicPropertySource
    static void properties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
    }
}
```

제 경험상 로컬과 운영 DB를 다르게 사용하면
운영 배포 후 예상치 못한 버그가 발생할 확률이 높습니다.
가능하면 로컬에서도 Docker로 동일한 DB를 사용하는 것을
강력히 추천합니다.
```

---

#### A10. Docker Compose를 사용하여 로컬 개발 환경을 구성하는 이점

**답변 구조**: 문제 상황 → Docker Compose 해결책 → 실무 예시

**모범 답변**:
```
Docker Compose는 여러 컨테이너를 한 번에 관리하는 도구입니다.

**이점 4가지**:

1. **환경 일관성**:
   - "내 컴퓨터에서는 되는데요?" 문제 해결
   - Mac, Windows, Linux 모두 동일한 환경

2. **빠른 설정**:
   - MySQL, Redis 등을 한 명령어로 시작
   ```bash
   docker-compose up -d  # 모든 서비스 시작
   ```

3. **격리된 환경**:
   - 호스트 OS에 직접 설치하지 않음
   - 프로젝트별로 다른 버전 사용 가능

4. **쉬운 초기화**:
   ```bash
   docker-compose down -v  # 데이터까지 모두 삭제
   docker-compose up -d    # 깨끗한 상태로 재시작
   ```

**실무 예시**:
```yaml
# docker-compose.yml
version: '3.8'
services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: mydb
    ports:
      - "3306:3306"

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  app:
    build: .
    depends_on:
      - mysql
      - redis
    ports:
      - "8080:8080"
```

저희 팀에서는 신입 개발자가 입사 첫날 저장소를 클론하고
`docker-compose up`만 실행하면 바로 개발을 시작할 수 있도록
환경을 구성했습니다. 온보딩 시간이 2일에서 30분으로 단축되었습니다.
```

---

#### A11. Maven Dependency Scope와 Lombok Scope

**답변 구조**: Scope 종류 설명 → Lombok 특수성 → 이유

**모범 답변**:
```
Maven Dependency Scope는 의존성이 필요한 시점을 정의합니다.

**Scope 종류**:

1. **compile** (기본값):
   - 컴파일, 테스트, 런타임 모두 포함
   - 예: Spring Core, Hibernate

2. **provided**:
   - 컴파일 시에만 필요, 런타임에는 외부에서 제공
   - 예: Servlet API (Tomcat이 제공), Lombok

3. **runtime**:
   - 런타임에만 필요
   - 예: JDBC 드라이버 (MySQL Connector)

4. **test**:
   - 테스트 코드에서만 사용
   - 예: JUnit, Mockito

**Lombok은 왜 provided?**
```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <scope>provided</scope>
</dependency>
```

이유:
1. Lombok은 **컴파일 타임 애노테이션 프로세서**
2. `@Getter`, `@Setter` 등을 실제 메서드로 변환
3. 컴파일 후에는 Lombok 코드가 필요 없음
4. 런타임 JAR 크기 절약 (1.5MB 감소)

**컴파일 전 (Lombok 필요)**:
```java
@Getter @Setter
public class User {
    private String name;
}
```

**컴파일 후 (.class 파일, Lombok 불필요)**:
```java
public class User {
    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

따라서 Lombok은 개발 중에만 필요하고,
실행 시에는 필요 없으므로 `provided` scope를 사용합니다.
```

**꼬리 질문 대비**:
- Q: "Lombok 없이 운영 서버에서 실행 가능한가?" → A: 가능, .class 파일에 이미 코드 생성됨

---

#### A12. CI/CD 파이프라인에서 환경 변수를 안전하게 주입하는 방법

**답변 구조**: 보안 위험 제시 → 해결 방법들 → 실무 예시

**모범 답변**:
```
민감한 정보를 코드나 설정 파일에 넣으면 보안 사고 위험이 있습니다.

**안전한 주입 방법**:

1. **Kubernetes ConfigMap & Secret**:
```yaml
# configmap.yaml (비민감 정보)
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  SPRING_PROFILES_ACTIVE: prod
  SERVER_PORT: "8080"

# secret.yaml (민감 정보, base64 인코딩)
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_PASSWORD: cGFzc3dvcmQxMjM=  # base64 encoded

# deployment.yaml
spec:
  containers:
  - name: app
    env:
    - name: SPRING_PROFILES_ACTIVE
      valueFrom:
        configMapKeyRef:
          name: app-config
          key: SPRING_PROFILES_ACTIVE
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: app-secret
          key: DB_PASSWORD
```

2. **AWS Systems Manager Parameter Store**:
```yaml
# application-prod.yml
spring:
  datasource:
    password: ${DB_PASSWORD}  # 환경 변수로 주입

# GitHub Actions workflow
- name: Deploy to AWS
  env:
    DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  run: |
    aws ssm put-parameter \
      --name /myapp/db-password \
      --value "$DB_PASSWORD" \
      --type SecureString
```

3. **HashiCorp Vault** (엔터프라이즈):
```bash
# Vault에 저장
vault kv put secret/myapp \
  db_password=super_secret_123 \
  api_key=abc123xyz

# Spring Cloud Vault로 자동 로드
spring:
  cloud:
    vault:
      uri: https://vault.company.com
      token: ${VAULT_TOKEN}
      kv:
        enabled: true
        backend: secret
        profile-separator: '/'
```

**실무 예시 (GitHub Actions + AWS)**:
```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Build JAR
        run: ./mvnw clean package

      - name: Deploy to EC2
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        run: |
          ssh ec2-user@prod-server << EOF
            export DB_PASSWORD=$DB_PASSWORD
            export REDIS_PASSWORD=$REDIS_PASSWORD
            java -jar app.jar --spring.profiles.active=prod
          EOF
```

**절대 하지 말아야 할 것**:
```yaml
# ❌ 위험: Git에 평문 비밀번호
spring:
  datasource:
    password: myRealPassword123!

# ❌ 위험: Dockerfile에 하드코딩
ENV DB_PASSWORD=myRealPassword123!

# ✅ 안전: 환경 변수 주입
spring:
  datasource:
    password: ${DB_PASSWORD}
```

제 경험상 가장 많이 사용하는 방식은:
- **로컬**: .env 파일 (Git에 추가 안 함)
- **개발/스테이징**: Kubernetes Secret
- **운영**: AWS Parameter Store + KMS 암호화
```

---

## 📝 핵심 정리

### 개발 환경 설정 3단계

```
┌─────────────┬──────────────────────────────────┐
│ 1단계       │ 기본 도구 설치                   │
│             │ - JDK 17 (JAVA_HOME 설정)        │
│             │ - IntelliJ IDEA                  │
│             │ - Git                            │
├─────────────┼──────────────────────────────────┤
│ 2단계       │ 프로젝트 생성                    │
│             │ - Spring Initializr 사용         │
│             │ - Maven/Gradle 선택              │
│             │ - Dependencies 추가              │
├─────────────┼──────────────────────────────────┤
│ 3단계       │ 환경별 설정 분리                 │
│             │ - application-local.yml          │
│             │ - application-dev.yml            │
│             │ - application-prod.yml           │
└─────────────┴──────────────────────────────────┘
```

### 필수 체크리스트

```markdown
✅ JDK 설치 및 버전 확인
   □ java -version (17.0.x 이상)
   □ javac -version (컴파일러 확인)
   □ JAVA_HOME 환경 변수 설정

✅ IDE 설정
   □ IntelliJ IDEA 설치
   □ Lombok 플러그인 설치
   □ Annotation Processing 활성화
   □ Maven/Gradle 설정 확인

✅ 첫 Spring Boot 프로젝트
   □ Spring Initializr로 프로젝트 생성
   □ HelloController 작성
   □ localhost:8080 접속 확인

✅ 환경 분리
   □ application-{profile}.yml 작성
   □ Profile별 실행 확인
   □ .gitignore 작성

✅ Docker (선택)
   □ Docker Desktop 설치
   □ docker-compose.yml 작성
   □ MySQL/PostgreSQL 컨테이너 실행
```

### 자주 발생하는 에러와 해결

```
┌─────────────────────────────┬─────────────────────┐
│ 에러                        │ 해결 방법           │
├─────────────────────────────┼─────────────────────┤
│ UnsupportedClassVersionError│ JDK 버전 맞추기     │
│ Port 8080 already in use    │ 포트 변경 또는 종료 │
│ Cannot resolve dependencies │ Maven 캐시 삭제     │
│ Lombok not working          │ 플러그인 + AP 활성화│
└─────────────────────────────┴─────────────────────┘
```

---

## 🔗 관련 기술

이번 챕터에서 다룬 기술들과 연관된 학습 주제:

```
개발 환경 설정
    ├─ JDK (Java Development Kit)
    │   └─ 관련: JVM, JRE, GraalVM
    │
    ├─ IDE (IntelliJ IDEA)
    │   └─ 관련: Eclipse, VS Code, NetBeans
    │
    ├─ 빌드 도구
    │   ├─ Maven
    │   │   └─ 관련: Nexus, Artifactory (레포지토리 관리)
    │   └─ Gradle
    │       └─ 관련: Gradle Wrapper, Kotlin DSL
    │
    ├─ 환경 분리
    │   ├─ Spring Profile
    │   │   └─ 관련: @Profile, @Conditional
    │   └─ 환경 변수
    │       └─ 관련: .env, Vault, Parameter Store
    │
    └─ 컨테이너
        ├─ Docker
        │   └─ 관련: Dockerfile, Docker Hub, Docker Compose
        └─ Kubernetes
            └─ 관련: ConfigMap, Secret, Deployment
```

**다음 학습 추천 순서**:
1. **03장: Spring Core (IoC/DI)** ← 다음 챕터
2. 04장: AOP (관점 지향 프로그래밍)
3. 05장: Spring MVC 기초

**심화 학습**:
- Docker & Kubernetes 실전
- CI/CD 파이프라인 구축 (GitHub Actions, Jenkins)
- 모니터링 (Prometheus, Grafana)

---

## 🚀 다음 단계

### 03장 미리보기: Spring Core - IoC와 DI

이제 개발 환경이 준비되었으니, Spring의 핵심 개념을 배울 차례입니다!

**03장에서 배울 내용**:
```java
// IoC (Inversion of Control): Spring이 객체를 관리
@Component
public class OrderService {
    private final PaymentService paymentService;

    // DI (Dependency Injection): Spring이 자동 주입
    public OrderService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

// Bean 생성과 라이프사이클
@Configuration
public class AppConfig {
    @Bean
    public OrderService orderService() {
        return new OrderService(paymentService());
    }
}
```

**왜 IoC/DI를 배워야 하나요?**
- ✅ Spring의 가장 핵심적인 철학
- ✅ 테스트하기 쉬운 코드 작성
- ✅ 객체 간 결합도 낮추기
- ✅ 실무에서 가장 많이 사용하는 패턴

**03장 학습 목표**:
1. Spring 컨테이너가 Bean을 관리하는 원리 이해
2. 생성자 주입, Setter 주입, 필드 주입 비교
3. @Component, @Service, @Repository 차이
4. ApplicationContext 활용

---

## 📚 추가 학습 자료

### 공식 문서

1. **Spring Boot 공식 문서**
   - https://docs.spring.io/spring-boot/docs/current/reference/html/
   - Getting Started Guide
   - Configuration Properties

2. **Spring Initializr**
   - https://start.spring.io/
   - 프로젝트 생성 가이드

3. **JDK 다운로드**
   - https://adoptium.net/ (Eclipse Temurin)
   - https://www.oracle.com/java/technologies/downloads/

### 추천 유튜브 강의

1. **백기선 - 스프링 부트 개념과 활용**
   - Spring Boot 기초부터 심화까지
   - 한글 자막, 무료

2. **우아한Tech - 개발 환경 구성하기**
   - 실무 개발 환경 설정 노하우
   - 배달의민족 개발자의 실전 경험

3. **IntelliJ IDEA 공식 채널**
   - IntelliJ 단축키와 생산성 팁
   - Spring Boot 개발 워크플로우

### 추천 도서

1. **스프링 부트 핵심 가이드** (장정우 저)
   - 개발 환경 설정부터 배포까지
   - 초보자 친화적

2. **토비의 스프링 3.1** (이일민 저)
   - Spring 원리 깊이 있게 학습
   - 중급자 이상 추천

### 실습 프로젝트 아이디어

1. **개인 프로젝트**:
   - TODO 앱 (이번 챕터에서 완성!)
   - 블로그 시스템
   - 간단한 게시판

2. **포트폴리오용**:
   - 멀티 환경 배포 (로컬/개발/운영)
   - Docker Compose로 전체 인프라 구성
   - CI/CD 파이프라인 연동

3. **팀 프로젝트**:
   - 환경 설정 자동화 스크립트 작성
   - 팀 공용 .gitignore 파일 관리
   - README.md에 환경 설정 가이드 문서화

---

## 🎉 축하합니다!

**02장: 개발 환경 설정**을 완료했습니다!

### 이번 챕터에서 달성한 것들

```
✅ JDK 17 설치 및 환경 변수 설정
✅ IntelliJ IDEA로 첫 Spring Boot 프로젝트 실행
✅ Maven/Gradle 빌드 도구 이해
✅ application.yml로 환경별 설정 분리
✅ Docker Compose로 로컬 개발 환경 구성
✅ 멀티 환경 TODO 애플리케이션 완성
✅ 주니어 개발자가 겪는 문제 해결 방법 학습
✅ 실무 회사들의 환경 설정 사례 분석
```

### 자신감을 가지세요!

이제 여러분은:
- ✅ Spring Boot 프로젝트를 **처음부터 끝까지** 설정할 수 있습니다
- ✅ 개발/운영 환경을 **안전하게 분리**할 수 있습니다
- ✅ 팀원들과 **일관된 개발 환경**을 공유할 수 있습니다
- ✅ 문제가 발생해도 **스스로 해결**할 수 있습니다

### 다음 챕터 예고

```
03장: Spring Core - IoC와 DI
  - Spring이 객체를 관리하는 방법
  - 의존성 주입으로 결합도 낮추기
  - Bean 생성과 라이프사이클
  - 실전 프로젝트: 주문 시스템 리팩토링
```

**준비되셨나요? 03장에서 만나요!** 🚀

---

> **💡 Tip**: 이번 챕터의 내용이 Spring Boot 개발의 기초입니다. 막히는 부분이 있다면 언제든 다시 돌아와서 복습하세요. 실무에서도 환경 설정 문제는 자주 발생하므로, 이 챕터는 참고 자료로 계속 활용할 수 있습니다.

**다음 챕터에서는 더 흥미진진한 Spring의 세계로 들어갑니다!**

[← 01장: Spring이란?](01-3-Spring이란-Part3.md) | [03장: Spring Core →](03-1-Spring-Core-Part1.md)
