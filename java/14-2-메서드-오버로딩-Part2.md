# Chapter 14-2: 메서드 오버로딩 (Method Overloading) - Part 2

## 목차
1. [기업 사례 연구](#기업-사례-연구)
2. [주니어 개발자 시나리오](#주니어-개발자-시나리오)

---

## 기업 사례 연구

### 사례 1: 유튜브 (YouTube) - 동영상 업로드 시스템

**비즈니스 요구사항:**
- 다양한 소스에서 동영상 업로드
- 일반 업로드, 스트리밍 업로드, 재생목록 업로드
- 메타데이터 옵션 (제목, 설명, 태그)
- 공개 설정 (공개, 비공개, 일부 공개)

**메서드 오버로딩 설계:**

```java
public class YouTubeUploadService {
    // 1. 기본 업로드 (파일만)
    public String upload(VideoFile video) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📹 기본 업로드");
        System.out.println("파일명: " + video.fileName);
        System.out.println("크기: " + video.fileSize + " MB");
        System.out.println("길이: " + video.duration + "초");
        System.out.println("제목: " + video.fileName);
        System.out.println("공개: 비공개");
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    // 2. 제목 포함 업로드
    public String upload(VideoFile video, String title) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📹 제목 지정 업로드");
        System.out.println("파일명: " + video.fileName);
        System.out.println("제목: " + title);
        System.out.println("공개: 비공개");
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    // 3. 메타데이터 포함 업로드
    public String upload(VideoFile video, String title, String description) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📹 메타데이터 업로드");
        System.out.println("파일명: " + video.fileName);
        System.out.println("제목: " + title);
        System.out.println("설명: " + description);
        System.out.println("공개: 비공개");
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    // 4. 완전 맞춤 업로드 (태그 + 공개 설정)
    public String upload(VideoFile video, String title, String description,
                        String[] tags, String privacy) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📹 완전 맞춤 업로드");
        System.out.println("파일명: " + video.fileName);
        System.out.println("제목: " + title);
        System.out.println("설명: " + description);
        System.out.print("태그: ");
        for (String tag : tags) {
            System.out.print("#" + tag + " ");
        }
        System.out.println("\n공개: " + privacy);
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    // 5. 스트리밍 업로드 (URL로 업로드)
    public String upload(String videoUrl) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📡 스트리밍 업로드");
        System.out.println("URL: " + videoUrl);
        System.out.println("제목: URL에서 추출");
        System.out.println("공개: 비공개");
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    // 6. 재생목록 업로드
    public String[] upload(VideoFile[] videos, String playlistName) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📺 재생목록 업로드");
        System.out.println("재생목록: " + playlistName);
        System.out.println("비디오 수: " + videos.length + "개");

        String[] videoIds = new String[videos.length];
        for (int i = 0; i < videos.length; i++) {
            videoIds[i] = generateVideoId();
            System.out.println("  " + (i+1) + ". " + videos[i].fileName +
                              " → " + videoIds[i]);
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoIds;
    }

    // 7. 예약 업로드
    public String upload(VideoFile video, String title, String scheduledTime) {
        String videoId = generateVideoId();
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("⏰ 예약 업로드");
        System.out.println("파일명: " + video.fileName);
        System.out.println("제목: " + title);
        System.out.println("공개 예정: " + scheduledTime);
        System.out.println("비디오 ID: " + videoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━\n");
        return videoId;
    }

    private String generateVideoId() {
        return "VID" + System.currentTimeMillis() % 1000000;
    }
}

class VideoFile {
    String fileName;
    int fileSize;  // MB
    int duration;  // 초

    public VideoFile(String fileName, int fileSize, int duration) {
        this.fileName = fileName;
        this.fileSize = fileSize;
        this.duration = duration;
    }
}

// 사용 예시
public class YouTubeTest {
    public static void main(String[] args) {
        YouTubeUploadService youtube = new YouTubeUploadService();

        System.out.println("╔══════════════════════════════════╗");
        System.out.println("║   YouTube 업로드 시스템          ║");
        System.out.println("╚══════════════════════════════════╝\n");

        // 다양한 업로드 방식
        VideoFile video1 = new VideoFile("vlog.mp4", 500, 600);
        youtube.upload(video1);

        VideoFile video2 = new VideoFile("tutorial.mp4", 300, 900);
        youtube.upload(video2, "자바 프로그래밍 입문 강좌");

        VideoFile video3 = new VideoFile("review.mp4", 400, 720);
        youtube.upload(video3, "신제품 리뷰", "최신 스마트폰 언박싱 및 리뷰");

        VideoFile video4 = new VideoFile("music.mp4", 200, 240);
        String[] tags = {"음악", "뮤직비디오", "kpop"};
        youtube.upload(video4, "뮤직비디오", "새 앨범 타이틀곡", tags, "공개");

        youtube.upload("https://livestream.example.com/live123");

        VideoFile[] playlist = {
            new VideoFile("ep1.mp4", 300, 1200),
            new VideoFile("ep2.mp4", 300, 1200),
            new VideoFile("ep3.mp4", 300, 1200)
        };
        youtube.upload(playlist, "시리즈 강좌");

        VideoFile video5 = new VideoFile("premiere.mp4", 800, 3600);
        youtube.upload(video5, "영화 프리미어", "2024-02-01 20:00");
    }
}
```

**비즈니스 인사이트:**
- 사용자 경험 향상: 필요한 정보만 입력
- 점진적 기능 추가: 간단한 업로드부터 복잡한 업로드까지
- 유연성: 다양한 업로드 시나리오 지원
- 하위 호환성: 기존 API 유지하면서 새 기능 추가

---

### 사례 2: 배달의민족 - 음식 주문 시스템

**비즈니스 요구사항:**
- 단일 메뉴 주문, 여러 메뉴 주문
- 옵션 추가 (맵기 조절, 토핑 추가 등)
- 주소 지정, 시간 지정
- 쿠폰 적용, 포인트 사용

**메서드 오버로딩 설계:**

```java
public class BaeminOrderService {
    // 1. 기본 주문 (메뉴만)
    public String order(String menuName) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 기본 주문");
        System.out.println("메뉴: " + menuName + " x 1");
        System.out.println("배송지: 기본 주소");
        System.out.println("요청 사항: 없음");
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 2. 수량 지정 주문
    public String order(String menuName, int quantity) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 수량 지정 주문");
        System.out.println("메뉴: " + menuName + " x " + quantity);
        System.out.println("배송지: 기본 주소");
        System.out.println("요청 사항: 없음");
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 3. 옵션 포함 주문
    public String order(String menuName, int quantity, String[] options) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 옵션 주문");
        System.out.println("메뉴: " + menuName + " x " + quantity);
        System.out.print("옵션: ");
        for (String option : options) {
            System.out.print(option + " / ");
        }
        System.out.println("\n배송지: 기본 주소");
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 4. 주소 지정 주문
    public String order(String menuName, int quantity, String[] options,
                       String address) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 주소 지정 주문");
        System.out.println("메뉴: " + menuName + " x " + quantity);
        System.out.print("옵션: ");
        for (String option : options) {
            System.out.print(option + " / ");
        }
        System.out.println("\n배송지: " + address);
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 5. 여러 메뉴 주문
    public String order(String[] menuNames, int[] quantities) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 다중 메뉴 주문");
        for (int i = 0; i < menuNames.length; i++) {
            System.out.println("  " + (i+1) + ". " + menuNames[i] +
                              " x " + quantities[i]);
        }
        System.out.println("배송지: 기본 주소");
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 6. 완전 맞춤 주문 (할인 쿠폰 + 포인트)
    public String order(String menuName, int quantity, String[] options,
                       String address, String couponCode, int pointsToUse) {
        String orderId = generateOrderId();
        int basePrice = 12000 * quantity;
        int discount = 2000;  // 쿠폰 할인
        int finalPrice = basePrice - discount - pointsToUse;

        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍜 완전 맞춤 주문");
        System.out.println("메뉴: " + menuName + " x " + quantity);
        System.out.print("옵션: ");
        for (String option : options) {
            System.out.print(option + " / ");
        }
        System.out.println("\n배송지: " + address);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("금액: " + String.format("%,d", basePrice) + "원");
        System.out.println("쿠폰 할인: -" + String.format("%,d", discount) + "원");
        System.out.println("포인트 사용: -" + String.format("%,d", pointsToUse) + "점");
        System.out.println("최종 결제: " + String.format("%,d", finalPrice) + "원");
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    // 7. 예약 주문
    public String order(String menuName, int quantity, String deliveryTime) {
        String orderId = generateOrderId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("⏰ 예약 주문");
        System.out.println("메뉴: " + menuName + " x " + quantity);
        System.out.println("배송 시간: " + deliveryTime);
        System.out.println("주문 번호: " + orderId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return orderId;
    }

    private String generateOrderId() {
        return "ORD" + System.currentTimeMillis() % 1000000;
    }
}

// 사용 예시
public class BaeminTest {
    public static void main(String[] args) {
        BaeminOrderService baemin = new BaeminOrderService();

        System.out.println("╔══════════════════════════════════╗");
        System.out.println("║   배달의민족 주문 시스템         ║");
        System.out.println("╚══════════════════════════════════╝");

        baemin.order("치킨");
        baemin.order("피자", 2);

        String[] options1 = {"맵게", "치즈 추가"};
        baemin.order("떡볶이", 1, options1);

        String[] options2 = {"보통맛", "곱빼기"};
        baemin.order("짜장면", 2, options2, "서울시 강남구 테헤란로 123");

        String[] menus = {"짜장면", "탕수육", "짬뽕"};
        int[] quantities = {2, 1, 1};
        baemin.order(menus, quantities);

        String[] options3 = {"보통맛"};
        baemin.order("짜장면", 3, options3, "회사 주소", "COUPON2024", 1000);

        baemin.order("족발", 1, "19:00");
    }
}
```

**비즈니스 인사이트:**
- 간편한 주문부터 복잡한 주문까지 유연하게 대응
- 점진적 정보 입력으로 사용자 편의성 증대
- 다양한 프로모션 옵션 지원

---

### 사례 3: GitHub - 저장소 생성 및 관리 시스템

**비즈니스 요구사항:**
- 다양한 방식의 저장소 생성
- 템플릿 저장소, 포크, 임포트
- 공개/비공개 설정
- README, .gitignore, 라이선스 자동 생성

**메서드 오버로딩 설계:**

```java
public class GitHubRepositoryService {
    // 1. 기본 저장소 생성
    public String createRepository(String repoName) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📦 기본 저장소 생성");
        System.out.println("이름: " + repoName);
        System.out.println("공개: 공개");
        System.out.println("README: 없음");
        System.out.println("저장소 ID: " + repoId);
        System.out.println("URL: https://github.com/user/" + repoName);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 2. 공개 설정 포함
    public String createRepository(String repoName, boolean isPublic) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📦 저장소 생성");
        System.out.println("이름: " + repoName);
        System.out.println("공개: " + (isPublic ? "공개" : "비공개"));
        System.out.println("README: 없음");
        System.out.println("저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 3. 설명 포함
    public String createRepository(String repoName, String description, boolean isPublic) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📦 저장소 생성 (설명 포함)");
        System.out.println("이름: " + repoName);
        System.out.println("설명: " + description);
        System.out.println("공개: " + (isPublic ? "공개" : "비공개"));
        System.out.println("저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 4. README + .gitignore 자동 생성
    public String createRepository(String repoName, String description,
                                   boolean isPublic, boolean initReadme,
                                   String gitignoreTemplate) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📦 완전 초기화 저장소");
        System.out.println("이름: " + repoName);
        System.out.println("설명: " + description);
        System.out.println("공개: " + (isPublic ? "공개" : "비공개"));
        System.out.println("README: " + (initReadme ? "자동 생성" : "없음"));
        System.out.println(".gitignore: " + gitignoreTemplate);
        System.out.println("저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 5. 템플릿에서 생성
    public String createRepository(String repoName, String templateRepo) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📋 템플릿에서 생성");
        System.out.println("이름: " + repoName);
        System.out.println("템플릿: " + templateRepo);
        System.out.println("저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 6. 포크 생성
    public String createRepository(String originalRepo, String newRepoName,
                                   boolean forkAllBranches) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🍴 포크 생성");
        System.out.println("원본: " + originalRepo);
        System.out.println("새 이름: " + newRepoName);
        System.out.println("모든 브랜치 복사: " + (forkAllBranches ? "예" : "아니오"));
        System.out.println("저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    // 7. 조직 저장소 생성
    public String createRepository(String orgName, String repoName,
                                   String description, boolean isPublic,
                                   String[] teams) {
        String repoId = generateRepoId();
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🏢 조직 저장소 생성");
        System.out.println("조직: " + orgName);
        System.out.println("이름: " + repoName);
        System.out.println("설명: " + description);
        System.out.println("공개: " + (isPublic ? "공개" : "비공개"));
        System.out.print("팀 접근: ");
        for (String team : teams) {
            System.out.print(team + " ");
        }
        System.out.println("\n저장소 ID: " + repoId);
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━");
        return repoId;
    }

    private String generateRepoId() {
        return "REPO" + System.currentTimeMillis() % 1000000;
    }
}

// 사용 예시
public class GitHubTest {
    public static void main(String[] args) {
        GitHubRepositoryService github = new GitHubRepositoryService();

        System.out.println("╔══════════════════════════════════╗");
        System.out.println("║   GitHub 저장소 생성 시스템      ║");
        System.out.println("╚══════════════════════════════════╝");

        github.createRepository("my-project");
        github.createRepository("private-project", false);
        github.createRepository("web-app", "웹 애플리케이션 프로젝트", true);
        github.createRepository("java-app", "자바 애플리케이션", true, true, "Java");
        github.createRepository("my-blog", "blog-template");
        github.createRepository("awesome-project", "my-awesome-fork", true);

        String[] teams = {"developers", "qa-team"};
        github.createRepository("company-org", "internal-tool",
                               "내부 관리 도구", false, teams);
    }
}
```

**비즈니스 인사이트:**
- 다양한 저장소 생성 시나리오 지원
- 개인 개발자부터 대규모 조직까지 대응
- 템플릿, 포크 등 협업 기능 강화

---

## 주니어 개발자 시나리오

### 시나리오 1: 매개변수 이름만 다르게 했는데 오버로딩이 안 돼요! 😱

**상황:**
주니어 개발자 김코딩은 메서드 오버로딩을 하려고 매개변수 이름을 다르게 했는데 컴파일 에러가 발생합니다.

**문제 코드:**
```java
public class UserService {
    // 메서드 1
    public void register(String username, String email) {
        System.out.println("사용자 등록: " + username);
    }

    // 메서드 2 - ❌ 컴파일 에러!
    public void register(String email, String password) {
        System.out.println("이메일로 등록: " + email);
    }
}
```

**에러 메시지:**
```
Error: Duplicate method register(String, String) in type UserService
```

**왜 에러가 발생했을까?**

```
오버로딩 구분 기준:
✅ 매개변수 개수
✅ 매개변수 타입
✅ 매개변수 순서 (타입이 다를 때)

❌ 매개변수 이름 (구분 불가!)

register(String username, String email)
register(String email, String password)
↑ 둘 다 (String, String)으로 동일 → 중복!
```

**해결 방법:**

**방법 1: 매개변수 타입을 다르게**
```java
public class UserService {
    // String, String
    public void register(String username, String email) {
        System.out.println("일반 등록: " + username);
    }

    // String, String, String (✅ 개수 다름)
    public void register(String username, String email, String password) {
        System.out.println("완전 등록: " + username);
    }
}
```

**방법 2: 메서드 이름을 다르게 (오버로딩 포기)**
```java
public class UserService {
    public void registerWithUsername(String username, String email) {
        System.out.println("사용자명 등록: " + username);
    }

    public void registerWithEmail(String email, String password) {
        System.out.println("이메일 등록: " + email);
    }
}
```

**방법 3: 객체로 묶기 (권장)**
```java
class RegistrationRequest {
    String username;
    String email;
    String password;

    public RegistrationRequest(String username, String email) {
        this.username = username;
        this.email = email;
    }

    public RegistrationRequest(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
}

public class UserService {
    public void register(RegistrationRequest request) {
        if (request.password != null) {
            System.out.println("완전 등록: " + request.username);
        } else {
            System.out.println("간단 등록: " + request.username);
        }
    }
}
```

**핵심 교훈:**
- ✅ **매개변수 이름은 오버로딩 구분 기준이 아님**
- ✅ **타입, 개수, 순서로만 구분**
- ✅ **비슷한 기능이지만 구분이 안 되면 메서드 이름을 다르게 하거나 객체로 묶기**

---

### 시나리오 2: 반환 타입만 다르게 했는데 안 돼요! 🤔

**상황:**
주니어 개발자 이자바는 같은 입력으로 다른 타입을 반환하려고 했는데 컴파일 에러가 발생합니다.

**문제 코드:**
```java
public class DataConverter {
    // int 반환
    public int getValue(String data) {
        return Integer.parseInt(data);
    }

    // String 반환 - ❌ 컴파일 에러!
    public String getValue(String data) {
        return data;
    }
}
```

**에러 메시지:**
```
Error: Duplicate method getValue(String) in type DataConverter
```

**왜 에러가 발생했을까?**

```
메서드 호출 시 컴파일러가 어떤 메서드를 선택할지 결정할 수 없음!

String result = converter.getValue("123");

int getValue(String) → 반환값을 String으로 변환? (가능)
String getValue(String) → 그대로 String (가능)

→ 애매모호함! 컴파일 에러
```

**해결 방법:**

**방법 1: 메서드 이름을 다르게**
```java
public class DataConverter {
    public int getValueAsInt(String data) {
        return Integer.parseInt(data);
    }

    public String getValueAsString(String data) {
        return data;
    }

    public double getValueAsDouble(String data) {
        return Double.parseDouble(data);
    }
}

// 사용
DataConverter converter = new DataConverter();
int intValue = converter.getValueAsInt("123");
String stringValue = converter.getValueAsString("123");
double doubleValue = converter.getValueAsDouble("123.45");
```

**방법 2: 제네릭 사용 (고급)**
```java
public class DataConverter {
    @SuppressWarnings("unchecked")
    public <T> T getValue(String data, Class<T> type) {
        if (type == Integer.class) {
            return (T) Integer.valueOf(data);
        } else if (type == Double.class) {
            return (T) Double.valueOf(data);
        } else if (type == String.class) {
            return (T) data;
        }
        throw new IllegalArgumentException("지원하지 않는 타입: " + type);
    }
}

// 사용
DataConverter converter = new DataConverter();
int intValue = converter.getValue("123", Integer.class);
double doubleValue = converter.getValue("123.45", Double.class);
String stringValue = converter.getValue("text", String.class);
```

**핵심 교훈:**
- ✅ **반환 타입은 오버로딩 구분 기준이 아님**
- ✅ **같은 매개변수로 다른 반환 타입이 필요하면 메서드 이름을 다르게**
- ✅ **또는 제네릭을 사용하여 하나의 메서드로 처리**

---

### 시나리오 3: 자동 형변환 때문에 예상과 다른 메서드가 호출돼요! 😭

**상황:**
주니어 개발자 박스프링은 오버로딩된 메서드 중 어떤 것이 호출될지 예상했는데 다른 메서드가 호출됩니다.

**문제 코드:**
```java
public class MathUtils {
    public void print(int value) {
        System.out.println("int: " + value);
    }

    public void print(long value) {
        System.out.println("long: " + value);
    }

    public void print(double value) {
        System.out.println("double: " + value);
    }
}

public class Test {
    public static void main(String[] args) {
        MathUtils math = new MathUtils();

        math.print(10);      // int 호출 (예상대로)
        math.print(10L);     // long 호출 (예상대로)
        math.print(10.0);    // double 호출 (예상대로)

        byte b = 10;
        math.print(b);       // 어떤 메서드 호출?

        short s = 10;
        math.print(s);       // 어떤 메서드 호출?

        float f = 10.0f;
        math.print(f);       // 어떤 메서드 호출?
    }
}
```

**출력:**
```
int: 10
long: 10
double: 10.0
int: 10          // byte → int 자동 형변환!
int: 10          // short → int 자동 형변환!
double: 10.0     // float → double 자동 형변환!
```

**자동 형변환 규칙:**
```
byte/short/char → int → long → float → double

1. 정확히 일치하는 타입 메서드 먼저 찾기
2. 없으면 자동 형변환 가능한 메서드 찾기
3. 여러 개면 가장 작은 형변환 선택
```

**예제:**
```java
public class TypeConversion {
    public void process(int value) {
        System.out.println("int");
    }

    public void process(double value) {
        System.out.println("double");
    }
}

TypeConversion tc = new TypeConversion();

tc.process(10);      // int
tc.process(10.0);    // double

byte b = 10;
tc.process(b);       // int (byte → int)

long l = 10L;
tc.process(l);       // double (long → double, int는 형변환 불가)

float f = 10.0f;
tc.process(f);       // double (float → double)
```

**해결 방법: 모든 타입에 대한 오버로딩 제공**
```java
public class MathUtils {
    public void print(byte value) {
        System.out.println("byte: " + value);
    }

    public void print(short value) {
        System.out.println("short: " + value);
    }

    public void print(int value) {
        System.out.println("int: " + value);
    }

    public void print(long value) {
        System.out.println("long: " + value);
    }

    public void print(float value) {
        System.out.println("float: " + value);
    }

    public void print(double value) {
        System.out.println("double: " + value);
    }
}
```

**핵심 교훈:**
- ✅ **자동 형변환이 발생하면 예상과 다른 메서드 호출 가능**
- ✅ **정확한 타입 매칭을 원하면 모든 타입에 대한 오버로딩 제공**
- ✅ **형변환 규칙 숙지: byte/short/char → int → long → float → double**

---

### 시나리오 4: 가변 인자와 일반 메서드 중 어느 게 호출될까요? 😵

**상황:**
주니어 개발자 최코드는 가변 인자 메서드와 일반 메서드가 동시에 있을 때 어떤 것이 호출되는지 헷갈립니다.

**문제 코드:**
```java
public class Calculator {
    // 일반 메서드
    public int sum(int a, int b) {
        System.out.println("일반 메서드 (2개)");
        return a + b;
    }

    // 가변 인자 메서드
    public int sum(int... numbers) {
        System.out.println("가변 인자 메서드");
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        System.out.println(calc.sum(1, 2));           // 어떤 메서드?
        System.out.println(calc.sum(1, 2, 3));        // 어떤 메서드?
        System.out.println(calc.sum(1, 2, 3, 4, 5)); // 어떤 메서드?
    }
}
```

**출력:**
```
일반 메서드 (2개)
3
가변 인자 메서드
6
가변 인자 메서드
15
```

**우선순위 규칙:**
```
1. 정확히 일치하는 일반 메서드
2. 가변 인자 메서드

sum(1, 2) → sum(int, int) 있음 → 일반 메서드 호출
sum(1, 2, 3) → sum(int, int, int) 없음 → 가변 인자 메서드 호출
```

**복잡한 예제:**
```java
public class Printer {
    // 메서드 1: 매개변수 없음
    public void print() {
        System.out.println("메서드 1: 매개변수 없음");
    }

    // 메서드 2: String 1개
    public void print(String message) {
        System.out.println("메서드 2: String 1개 - " + message);
    }

    // 메서드 3: String 2개
    public void print(String message, String suffix) {
        System.out.println("메서드 3: String 2개 - " + message + suffix);
    }

    // 메서드 4: 가변 인자
    public void print(String... messages) {
        System.out.println("메서드 4: 가변 인자 - " + messages.length + "개");
    }
}

public class PrinterTest {
    public static void main(String[] args) {
        Printer printer = new Printer();

        printer.print();                        // 메서드 1
        printer.print("Hello");                 // 메서드 2
        printer.print("Hello", "!");            // 메서드 3
        printer.print("A", "B", "C");           // 메서드 4
        printer.print("A", "B", "C", "D");      // 메서드 4
    }
}
```

**출력:**
```
메서드 1: 매개변수 없음
메서드 2: String 1개 - Hello
메서드 3: String 2개 - Hello!
메서드 4: 가변 인자 - 3개
메서드 4: 가변 인자 - 4개
```

**가변 인자 주의사항:**
```java
public class VarargsIssue {
    // ❌ 컴파일 에러: 가변 인자는 마지막에만 가능
    public void method(int... numbers, String message) {
    }

    // ✅ 정상
    public void method(String message, int... numbers) {
    }

    // ❌ 컴파일 에러: 가변 인자는 하나만 가능
    public void method(int... numbers, String... messages) {
    }
}
```

**핵심 교훈:**
- ✅ **일반 메서드가 가변 인자 메서드보다 우선순위 높음**
- ✅ **정확히 일치하는 메서드가 없으면 가변 인자 메서드 호출**
- ✅ **가변 인자는 마지막 매개변수로만 가능**
- ✅ **가변 인자는 하나만 사용 가능**

---

## 정리

### Part 2에서 배운 핵심 개념

**1. 기업 사례에서 배운 점**
- 유튜브: 다양한 업로드 옵션을 오버로딩으로 처리
- 배달의민족: 간단한 주문부터 복잡한 주문까지 유연하게 대응
- GitHub: 저장소 생성의 다양한 시나리오를 하나의 메서드 이름으로 통일

**2. 주니어 개발자가 자주 하는 실수**
- 매개변수 이름만 다르게 해서 오버로딩 시도
- 반환 타입만 다르게 해서 오버로딩 시도
- 자동 형변환 규칙 모르고 예상과 다른 결과
- 가변 인자와 일반 메서드의 우선순위 혼동

**3. 오버로딩 베스트 프랙티스**
```java
public class BestPractice {
    // 기본 메서드
    public void process(Data data) {
        process(data, defaultOptions);
    }

    // 옵션 포함
    public void process(Data data, Options options) {
        // 실제 처리 로직
    }

    // 편의 메서드 (자주 사용하는 조합)
    public void processQuick(Data data) {
        process(data, quickOptions);
    }
}
```

다음 Part 3에서는 **실전 프로젝트**, **7개 FAQ**, **12개 면접 질문**을 다룹니다!
