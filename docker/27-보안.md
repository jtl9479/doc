# 섹션 27: 보안 (Security)

## 비유로 시작하기

Docker 보안은 **아파트 보안 시스템**과 같습니다.

```
아파트 보안                          Docker 보안
===========                          ===========
🏢 외부 담장                    →    네트워크 격리
🚪 현관문 보안카드              →    컨테이너 격리
📹 CCTV 감시                    →    로그 모니터링
👮 경비원 순찰                  →    보안 스캐너
🔒 각 세대 도어락               →    컨테이너 권한 제한
🗝️ 마스터키 관리               →    Secrets 관리
🚨 화재 경보기                  →     보안 이벤트 알림
📋 방문자 명부                  →     감사 로그 (Audit Log)
```

아파트 보안이 허술하면 도둑이 들듯이, Docker 보안이 허술하면 해커가 시스템을 장악할 수 있습니다.

---

## 왜 Docker 보안이 중요한가?

### 1. 보안 사고 시나리오

```
❌ 보안 취약 시스템
=================

해커의 공격 시나리오:
──────────────────

1. 취약한 웹 애플리케이션 발견
   ↓
2. 컨테이너 내부로 침투 (RCE)
   ↓
3. root 권한으로 실행 중 → 컨테이너 완전 장악
   ↓
4. Docker 소켓 마운트 발견 → 호스트 장악
   ↓
5. 다른 컨테이너도 모두 장악
   ↓
6. 데이터베이스 접근 → 고객 정보 유출
   ↓
7. 랜섬웨어 설치 → 시스템 암호화
   ↓
💀 회사 파산


✅ 보안 강화 시스템
=================

같은 공격 시도:
─────────────

1. 취약한 웹 애플리케이션 발견
   ↓
2. 컨테이너 내부로 침투 시도
   ↓ 🛡️ 네트워크 격리로 차단

2-1. 다른 경로로 침투 성공
   ↓
3. 파일 시스템 조작 시도
   ↓ 🛡️ Read-only 파일 시스템으로 차단

3-1. 메모리에만 악성코드 로드
   ↓
4. 다른 컨테이너 공격 시도
   ↓ 🛡️ 컨테이너 격리로 차단

4-1. 호스트 공격 시도
   ↓ 🛡️ 권한 제한으로 차단

5. 비정상 활동 감지
   ↓ 🚨 알림 발송

6. 관리자가 해당 컨테이너 격리/중지
   ↓
✅ 피해 최소화, 시스템 보호
```

### 2. Docker 보안의 중요성

| 위협 | 보안 없이 | 보안 적용 시 |
|------|----------|------------|
| 🐛 취약점 공격 | 시스템 전체 장악 | 컨테이너 내부만 피해 |
| 🔓 권한 상승 | root 권한 획득 | 제한된 권한만 획득 |
| 📦 악성 이미지 | 백도어 설치 | 이미지 스캔으로 차단 |
| 🔑 비밀 정보 노출 | 코드에 하드코딩된 암호 유출 | Secrets로 안전하게 관리 |
| 🌐 네트워크 공격 | 모든 컨테이너 접근 가능 | 네트워크 격리 |

---

## Docker 보안의 핵심 원칙

### 1. 심층 방어 (Defense in Depth)

여러 계층의 보안을 적용하여, 하나가 뚫려도 다른 계층에서 방어합니다.

```
보안 계층 구조
=============

                    외부 공격
                       ↓
    ┌──────────────────────────────────┐
    │  계층 1: 네트워크 보안            │ ← 방화벽, 네트워크 격리
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 2: 이미지 보안              │ ← 이미지 스캔, 서명 검증
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 3: 컨테이너 격리            │ ← namespace, cgroup
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 4: 권한 제한                │ ← non-root, capabilities
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 5: 파일 시스템 보호         │ ← read-only, 볼륨 제한
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 6: Secrets 관리             │ ← 암호화된 비밀 정보
    └──────────────────────────────────┘
                       ↓
    ┌──────────────────────────────────┐
    │  계층 7: 모니터링 & 감사          │ ← 로그, 알림
    └──────────────────────────────────┘
                       ↓
                  핵심 자산
```

### 2. 최소 권한 원칙 (Principle of Least Privilege)

필요한 최소한의 권한만 부여합니다.

```
❌ 나쁜 예: 모든 권한 부여
docker run --privileged \
  -v /:/host \
  --net=host \
  --pid=host \
  myapp

→ 컨테이너가 호스트와 동일한 권한 (위험!)


✅ 좋은 예: 최소 권한만 부여
docker run \
  --read-only \
  --user 1000:1000 \
  --cap-drop=ALL \
  --cap-add=NET_BIND_SERVICE \
  --security-opt=no-new-privileges \
  myapp

→ 꼭 필요한 권한만 부여 (안전)
```

---

## 1. 이미지 보안

### 1.1 신뢰할 수 있는 베이스 이미지 사용

```dockerfile
# ❌ 나쁜 예: 출처 불명 이미지
FROM random-user/ubuntu

# ❌ 나쁜 예: latest 태그 (재현성 없음)
FROM ubuntu:latest

# ✅ 좋은 예: 공식 이미지 + 특정 버전
FROM ubuntu:22.04

# ✅ 더 좋은 예: Distroless 이미지 (최소 이미지)
FROM gcr.io/distroless/java17-debian11

# ✅ 최선의 예: 공식 이미지 + SHA256 해시
FROM ubuntu:22.04@sha256:ac58ff7fe25edc58bdf0067ca99df00014dbd032e2246d30a722fa348fd799a5
```

### 1.2 멀티 스테이지 빌드로 최소화

```dockerfile
# ❌ 나쁜 예: 빌드 도구가 포함된 큰 이미지
FROM openjdk:17
WORKDIR /app
COPY . .
RUN ./gradlew build
CMD ["java", "-jar", "app.jar"]
# 결과: 이미지 크기 ~800MB, 빌드 도구 포함 (공격 표면 넓음)


# ✅ 좋은 예: 멀티 스테이지 빌드
# Stage 1: 빌드
FROM gradle:8.5-jdk17 AS builder
WORKDIR /app
COPY . .
RUN gradle build --no-daemon

# Stage 2: 실행 (최소 이미지)
FROM eclipse-temurin:17-jre-alpine
WORKDIR /app

# non-root 사용자 생성
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# 파일 복사 및 권한 설정
COPY --from=builder /app/build/libs/*.jar app.jar
RUN chown appuser:appuser app.jar

# non-root 사용자로 전환
USER appuser

EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
# 결과: 이미지 크기 ~200MB, 빌드 도구 없음 (공격 표면 좁음)
```

### 1.3 취약점 스캐닝

Docker 이미지의 보안 취약점을 자동으로 검사합니다.

#### Trivy 사용

```bash
# Trivy 설치 (Linux/Mac)
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# Trivy 설치 (Docker)
docker pull aquasec/trivy:latest

# 이미지 스캔
trivy image lk-trade/user-service:latest

# 출력 예시:
lk-trade/user-service:latest (alpine 3.18.4)
=========================================

Total: 23 (UNKNOWN: 0, LOW: 12, MEDIUM: 8, HIGH: 3, CRITICAL: 0)

┌────────────────┬──────────────┬──────────┬────────────────┬───────────────────┬───────────────────────────────┐
│    Library     │ Vulnerability│ Severity │ Installed Ver. │   Fixed Version   │            Title              │
├────────────────┼──────────────┼──────────┼────────────────┼───────────────────┼───────────────────────────────┤
│ openssl        │ CVE-2023-1234│ HIGH     │ 3.1.1          │ 3.1.4             │ OpenSSL: Buffer overflow      │
│ curl           │ CVE-2023-5678│ MEDIUM   │ 8.3.0          │ 8.4.0             │ curl: Cookie injection        │
└────────────────┴──────────────┴──────────┴────────────────┴───────────────────┴───────────────────────────────┘

# 심각도별 필터링 (HIGH, CRITICAL만)
trivy image --severity HIGH,CRITICAL lk-trade/user-service:latest

# JSON 출력 (CI/CD 파이프라인에서 활용)
trivy image --format json --output results.json lk-trade/user-service:latest

# 취약점 발견 시 빌드 실패 (CI/CD)
trivy image --exit-code 1 --severity HIGH,CRITICAL lk-trade/user-service:latest
```

#### Docker Scout 사용 (Docker Desktop 내장)

```bash
# Docker Scout 활성화
docker scout --help

# 이미지 분석
docker scout cves lk-trade/user-service:latest

# 권장 사항 보기
docker scout recommendations lk-trade/user-service:latest

# 비교 분석 (이전 버전과 비교)
docker scout compare lk-trade/user-service:v1.0 --to lk-trade/user-service:v2.0
```

#### CI/CD에 통합

```yaml
# .github/workflows/security-scan.yml
name: Security Scan

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t lk-trade/user-service:${{ github.sha }} .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'lk-trade/user-service:${{ github.sha }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'  # HIGH/CRITICAL 발견 시 빌드 실패

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
```

### 1.4 이미지 서명 및 검증 (Docker Content Trust)

이미지가 신뢰할 수 있는 출처에서 왔는지 확인합니다.

```bash
# Docker Content Trust 활성화
export DOCKER_CONTENT_TRUST=1

# 이미지 push (자동으로 서명됨)
docker push lk-trade/user-service:latest

# 이미지 pull (서명 검증)
docker pull lk-trade/user-service:latest
# 서명이 없거나 유효하지 않으면 실패

# 특정 이미지의 서명 정보 확인
docker trust inspect --pretty lk-trade/user-service:latest
```

---

## 2. 컨테이너 격리 및 권한 관리

### 2.1 Non-root 사용자로 실행

```dockerfile
# ✅ 권장: non-root 사용자 생성 및 사용
FROM eclipse-temurin:17-jre-alpine

# 사용자 생성
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# 애플리케이션 디렉토리 생성 및 권한 설정
WORKDIR /app
COPY --chown=appuser:appuser app.jar app.jar

# non-root 사용자로 전환
USER appuser

# 이제 이 컨테이너는 appuser 권한으로 실행됨
CMD ["java", "-jar", "app.jar"]
```

```yaml
# docker-compose.yml
services:
  user-service:
    image: lk-trade/user-service:latest
    user: "1000:1000"  # UID:GID 명시
    # 또는
    # user: appuser
```

#### 검증

```bash
# 컨테이너 내부에서 실행 중인 사용자 확인
docker exec user-service whoami
# 출력: appuser (✅)
# 출력: root (❌ 위험!)

# 프로세스 확인
docker exec user-service ps aux
# UID가 1000이어야 함
```

### 2.2 Linux Capabilities 제한

Linux Capabilities는 root 권한을 세밀하게 분할한 것입니다.

```yaml
# docker-compose.yml
services:
  user-service:
    image: lk-trade/user-service:latest
    cap_drop:
      - ALL  # 모든 capabilities 제거
    cap_add:
      - NET_BIND_SERVICE  # 1024 이하 포트 바인딩만 허용
    security_opt:
      - no-new-privileges:true  # 권한 상승 방지
```

주요 Capabilities:

| Capability | 설명 | 필요 시나리오 |
|-----------|------|-------------|
| **CAP_NET_BIND_SERVICE** | 1024 이하 포트 바인딩 | 웹 서버 (80, 443 포트) |
| **CAP_NET_ADMIN** | 네트워크 설정 변경 | VPN, 프록시 |
| **CAP_SYS_ADMIN** | 시스템 관리 작업 | 파일 시스템 마운트 |
| **CAP_CHOWN** | 파일 소유권 변경 | 파일 권한 변경 필요 시 |
| **CAP_DAC_OVERRIDE** | 파일 권한 무시 | root 파일 접근 필요 시 |

```bash
# 현재 컨테이너의 capabilities 확인
docker exec user-service cat /proc/1/status | grep Cap

# 출력 예시:
CapInh: 0000000000000000
CapPrm: 0000000000000400  # NET_BIND_SERVICE만 있음
CapEff: 0000000000000400
```

### 2.3 AppArmor / SELinux 프로파일

추가적인 강제 접근 제어(MAC)를 적용합니다.

```yaml
# docker-compose.yml (AppArmor)
services:
  user-service:
    image: lk-trade/user-service:latest
    security_opt:
      - apparmor=docker-default  # Docker의 기본 AppArmor 프로파일
      # 또는 커스텀 프로파일
      - apparmor=my-custom-profile
```

```yaml
# docker-compose.yml (SELinux)
services:
  user-service:
    image: lk-trade/user-service:latest
    security_opt:
      - label=type:container_runtime_t
```

### 2.4 Read-only 파일 시스템

컨테이너 내부에서 파일 수정을 방지합니다.

```yaml
# docker-compose.yml
services:
  user-service:
    image: lk-trade/user-service:latest
    read_only: true  # 파일 시스템 읽기 전용
    tmpfs:
      - /tmp  # /tmp만 쓰기 가능 (메모리)
      - /app/logs  # 로그 디렉토리만 쓰기 가능
```

```bash
# 테스트
docker exec user-service touch /test.txt
# 출력: touch: cannot touch '/test.txt': Read-only file system (✅)

docker exec user-service touch /tmp/test.txt
# 출력: (성공) (✅)
```

### 2.5 PID 제한

Fork bomb 공격을 방어합니다.

```yaml
# docker-compose.yml
services:
  user-service:
    image: lk-trade/user-service:latest
    pids_limit: 100  # 최대 100개 프로세스
```

---

## 3. 네트워크 보안

### 3.1 네트워크 격리

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 프론트엔드 (외부 접근 가능)
  frontend:
    image: lk-trade/frontend:latest
    networks:
      - public
    ports:
      - "80:80"
      - "443:443"

  # API Gateway (외부 접근 가능)
  api-gateway:
    image: lk-trade/api-gateway:latest
    networks:
      - public
      - internal
    ports:
      - "8080:8080"

  # 내부 서비스 (외부 접근 불가)
  user-service:
    image: lk-trade/user-service:latest
    networks:
      - internal
    # ports 없음 → 외부 접근 불가

  trade-service:
    image: lk-trade/trade-service:latest
    networks:
      - internal

  # 데이터베이스 (외부 접근 불가)
  postgres:
    image: postgres:16-alpine
    networks:
      - database
    # ports 없음 → 외부 접근 불가

  # 백업 서비스 (DB만 접근 가능)
  backup-service:
    image: lk-trade/backup:latest
    networks:
      - database

networks:
  public:        # 외부 접근 가능
    driver: bridge
  internal:      # API Gateway ↔ 내부 서비스
    driver: bridge
    internal: true  # 외부 인터넷 접근 불가
  database:      # 데이터베이스 전용
    driver: bridge
    internal: true
```

네트워크 격리 효과:

```
인터넷
  ↓
┌───────────────┐
│  frontend     │ (public)
└───────────────┘
  ↓
┌───────────────┐
│  api-gateway  │ (public + internal)
└───────────────┘
  ↓
┌─────────────────────────────────┐
│  user-service, trade-service    │ (internal)
└─────────────────────────────────┘
  ↕️ (네트워크 분리됨)
┌─────────────────────────────────┐
│  postgres, backup-service       │ (database)
└─────────────────────────────────┘

user-service → postgres ❌ (다른 네트워크)
backup-service → postgres ✅ (같은 네트워크)
외부 → user-service ❌ (포트 노출 없음)
```

### 3.2 방화벽 규칙 (iptables)

```bash
# 호스트 레벨 방화벽 설정 (Ubuntu/Debian)
sudo apt install ufw

# 기본 정책: 모든 incoming 차단, outgoing 허용
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 필요한 포트만 허용
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS

# 특정 IP에서만 접근 허용 (관리자 IP)
sudo ufw allow from 203.0.113.10 to any port 22

# 방화벽 활성화
sudo ufw enable

# 상태 확인
sudo ufw status verbose
```

---

## 4. Secrets 관리

**절대로 하면 안 되는 것:**

```dockerfile
# ❌ Dockerfile에 비밀 정보 하드코딩
ENV DB_PASSWORD=super_secret_password

# ❌ 이미지에 비밀 정보 복사
COPY database.env /app/
```

```yaml
# ❌ docker-compose.yml에 평문 저장
environment:
  - DB_PASSWORD=super_secret_password
```

이러한 방법은 이미지를 pull한 누구나 비밀 정보를 볼 수 있습니다!

```bash
# 누구나 볼 수 있음
docker inspect user-service | grep PASSWORD
docker history user-service
```

### 4.1 Docker Secrets (Swarm 모드)

```bash
# Swarm 초기화
docker swarm init

# Secret 생성
echo "super_secret_password" | docker secret create db_password -

# 또는 파일에서 생성
docker secret create db_password ./secrets/db_password.txt

# Secret 목록 확인
docker secret ls

# Secret 사용
docker service create \
  --name user-service \
  --secret db_password \
  lk-trade/user-service:latest

# 컨테이너 내부에서 Secret은 파일로 마운트됨
# /run/secrets/db_password
```

```yaml
# docker-stack.yml (Swarm)
version: '3.8'

services:
  user-service:
    image: lk-trade/user-service:latest
    secrets:
      - db_password
      - jwt_secret
    environment:
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - JWT_SECRET_FILE=/run/secrets/jwt_secret

secrets:
  db_password:
    external: true
  jwt_secret:
    external: true
```

애플리케이션에서 Secret 읽기:

```kotlin
// application.yml
spring:
  datasource:
    password: ${DB_PASSWORD}  # 환경 변수에서 읽기

// or 파일에서 직접 읽기
import java.nio.file.Files
import java.nio.file.Paths

class DatabaseConfig {
    fun getDatabasePassword(): String {
        val secretFile = Paths.get("/run/secrets/db_password")
        return if (Files.exists(secretFile)) {
            Files.readString(secretFile).trim()
        } else {
            System.getenv("DB_PASSWORD") ?: throw IllegalStateException("No DB password")
        }
    }
}
```

### 4.2 환경 변수 파일 (개발 환경)

```bash
# .env.example (Git에 커밋)
DB_HOST=postgres
DB_PORT=5432
DB_NAME=lk_trade
DB_USER=lk_admin
DB_PASSWORD=CHANGE_ME
JWT_SECRET=CHANGE_ME

# .env (Git에 커밋하지 않음, .gitignore에 추가)
DB_HOST=postgres
DB_PORT=5432
DB_NAME=lk_trade
DB_USER=lk_admin
DB_PASSWORD=actual_secure_password_here
JWT_SECRET=actual_jwt_secret_here
```

```yaml
# docker-compose.yml
services:
  user-service:
    image: lk-trade/user-service:latest
    env_file:
      - .env  # .env 파일에서 환경 변수 로드
```

```bash
# .gitignore
.env
.env.local
.env.production
secrets/
```

### 4.3 외부 Secrets 관리 시스템

#### HashiCorp Vault

```yaml
# docker-compose.yml
services:
  vault:
    image: vault:1.15
    ports:
      - "8200:8200"
    environment:
      - VAULT_DEV_ROOT_TOKEN_ID=myroot
      - VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200
    cap_add:
      - IPC_LOCK

  user-service:
    image: lk-trade/user-service:latest
    environment:
      - VAULT_ADDR=http://vault:8200
      - VAULT_TOKEN=myroot
    depends_on:
      - vault
```

```kotlin
// Vault에서 Secret 읽기
import com.bettercloud.vault.Vault
import com.bettercloud.vault.VaultConfig

class VaultSecretManager {
    private val vault: Vault

    init {
        val config = VaultConfig()
            .address(System.getenv("VAULT_ADDR"))
            .token(System.getenv("VAULT_TOKEN"))
            .build()
        vault = Vault(config)
    }

    fun getDatabasePassword(): String {
        val response = vault.logical().read("secret/data/database")
        return response.data["password"] as String
    }
}
```

#### AWS Secrets Manager

```kotlin
// AWS Secrets Manager에서 Secret 읽기
import software.amazon.awssdk.services.secretsmanager.SecretsManagerClient
import software.amazon.awssdk.services.secretsmanager.model.GetSecretValueRequest

class AwsSecretManager {
    private val client = SecretsManagerClient.create()

    fun getSecret(secretName: String): String {
        val request = GetSecretValueRequest.builder()
            .secretId(secretName)
            .build()
        val response = client.getSecretValue(request)
        return response.secretString()
    }
}
```

---

## 5. Docker Daemon 보안

### 5.1 Docker 소켓 보호

```bash
# ❌ 절대 하지 말 것: Docker 소켓을 컨테이너에 마운트
docker run -v /var/run/docker.sock:/var/run/docker.sock myapp
# 이렇게 하면 컨테이너가 호스트의 Docker를 완전히 제어할 수 있음!

# 컨테이너 내부에서:
docker run --privileged -v /:/host alpine chroot /host
# → 호스트 시스템 완전 장악!
```

Docker 소켓을 꼭 마운트해야 한다면:

```yaml
# docker-compose.yml
services:
  # CI/CD runner 등 Docker 제어가 필요한 경우
  gitlab-runner:
    image: gitlab/gitlab-runner:latest
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro  # 읽기 전용
    # 추가 보안 설정
    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges:true
```

### 5.2 TLS로 Docker Daemon 보호

원격에서 Docker Daemon에 접근할 때 TLS 필수:

```bash
# 인증서 생성
openssl genrsa -out ca-key.pem 4096
openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem

# Docker Daemon 설정
# /etc/docker/daemon.json
{
  "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],
  "tls": true,
  "tlsverify": true,
  "tlscacert": "/etc/docker/certs/ca.pem",
  "tlscert": "/etc/docker/certs/server-cert.pem",
  "tlskey": "/etc/docker/certs/server-key.pem"
}

# Docker Daemon 재시작
sudo systemctl restart docker

# 클라이언트에서 TLS로 연결
docker --tlsverify \
  --tlscacert=ca.pem \
  --tlscert=cert.pem \
  --tlskey=key.pem \
  -H=tcp://docker-host:2376 ps
```

### 5.3 User Namespace 격리

컨테이너 내부의 root를 호스트의 일반 사용자로 매핑합니다.

```json
// /etc/docker/daemon.json
{
  "userns-remap": "default"
}
```

```bash
# Docker 재시작
sudo systemctl restart docker

# 확인
docker run --rm alpine id
# 출력: uid=0(root) gid=0(root) groups=0(root)
# 하지만 호스트에서는:
ps aux | grep alpine
# 출력: dockremap (UID 100000+)
```

---

## 6. 보안 모니터링 및 감사

### 6.1 Docker Bench Security

Docker의 보안 모범 사례를 자동으로 검사합니다.

```bash
# Docker Bench Security 실행
docker run --rm --net host --pid host --userns host \
  --cap-add audit_control \
  -v /etc:/etc:ro \
  -v /usr/bin/containerd:/usr/bin/containerd:ro \
  -v /usr/bin/runc:/usr/bin/runc:ro \
  -v /usr/lib/systemd:/usr/lib/systemd:ro \
  -v /var/lib:/var/lib:ro \
  -v /var/run/docker.sock:/var/run/docker.sock:ro \
  docker/docker-bench-security

# 출력 예시:
[INFO] 1 - Host Configuration
[PASS] 1.1.1 - Ensure a separate partition for containers has been created
[WARN] 1.1.2 - Ensure only trusted users are allowed to control Docker daemon
[PASS] 1.2.1 - Ensure the container host has been hardened
...

[INFO] 4 - Container Images and Build File
[WARN] 4.1 - Ensure a user for the container has been created
[PASS] 4.2 - Ensure that containers use only trusted base images
...

# JSON 출력
docker run ... docker/docker-bench-security -j > bench-results.json
```

### 6.2 Falco (런타임 보안 모니터링)

컨테이너 내부의 비정상 행위를 실시간으로 감지합니다.

```yaml
# docker-compose.yml
services:
  falco:
    image: falcosecurity/falco:latest
    privileged: true
    volumes:
      - /var/run/docker.sock:/host/var/run/docker.sock
      - /dev:/host/dev
      - /proc:/host/proc:ro
      - /boot:/host/boot:ro
      - /lib/modules:/host/lib/modules:ro
      - /usr:/host/usr:ro
      - ./falco-rules.yaml:/etc/falco/rules.d/custom-rules.yaml
```

```yaml
# falco-rules.yaml (커스텀 규칙)
- rule: Unauthorized Process in Container
  desc: Detect unauthorized process execution
  condition: >
    spawned_process and
    container and
    not proc.name in (java, node, python)
  output: >
    Unauthorized process started in container
    (user=%user.name command=%proc.cmdline container=%container.name)
  priority: WARNING

- rule: Write to Non-Temp Directory
  desc: Detect writes to non-temp directories in read-only containers
  condition: >
    open_write and
    container and
    not fd.directory in (/tmp, /app/logs)
  output: >
    Write to unexpected directory
    (file=%fd.name container=%container.name)
  priority: ERROR

- rule: Sensitive File Access
  desc: Detect access to sensitive files
  condition: >
    open_read and
    container and
    fd.name in (/etc/shadow, /etc/passwd, /root/.ssh/id_rsa)
  output: >
    Sensitive file accessed
    (file=%fd.name user=%user.name container=%container.name)
  priority: CRITICAL
```

Falco 알림:

```
17:23:45.123456789: Warning Unauthorized process started in container
  (user=appuser command=bash container=user-service)

17:24:12.987654321: Error Write to unexpected directory
  (file=/etc/hosts container=user-service)

17:24:58.456789012: Critical Sensitive file accessed
  (file=/etc/shadow user=root container=compromised-container)
```

### 6.3 Audit 로그

Docker 이벤트를 모두 기록합니다.

```json
// /etc/docker/daemon.json
{
  "log-level": "info",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
```

```bash
# Docker 이벤트 실시간 모니터링
docker events

# 특정 이벤트 필터링
docker events --filter 'type=container' --filter 'event=start'
docker events --filter 'type=container' --filter 'event=exec_start'

# 출력 예시:
2025-09-30T10:15:32.123456789+09:00 container start abc123 (image=lk-trade/user-service, name=user-service)
2025-09-30T10:16:45.987654321+09:00 container exec_start abc123 (image=lk-trade/user-service, name=user-service)

# JSON 형식으로 저장
docker events --format '{{json .}}' >> /var/log/docker-events.log
```

---

## LK-Trade 프로젝트에 보안 적용하기

### 1. 보안 강화된 Dockerfile

```dockerfile
# modules/user/api/Dockerfile
# Stage 1: Build
FROM gradle:8.5-jdk17-alpine AS builder
WORKDIR /build
COPY . .
RUN gradle build --no-daemon -x test

# Stage 2: Runtime
FROM eclipse-temurin:17-jre-alpine

# 보안: 불필요한 패키지 제거, 업데이트
RUN apk update && \
    apk upgrade && \
    apk add --no-cache dumb-init && \
    rm -rf /var/cache/apk/*

# 보안: non-root 사용자 생성
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app

# 보안: 파일 복사 및 권한 설정
COPY --from=builder --chown=appuser:appuser /build/build/libs/*.jar app.jar

# 보안: non-root 사용자로 전환
USER appuser

# 보안: 헬스체크
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1

EXPOSE 8080

# 보안: dumb-init으로 PID 1 문제 해결
ENTRYPOINT ["/usr/bin/dumb-init", "--"]
CMD ["java", \
     "-XX:+UseContainerSupport", \
     "-XX:MaxRAMPercentage=75.0", \
     "-Djava.security.egd=file:/dev/./urandom", \
     "-jar", "app.jar"]
```

### 2. 보안 강화된 docker-compose.yml

```yaml
# docker-compose.prod.yml
version: '3.8'

x-security-defaults: &security-defaults
  cap_drop:
    - ALL
  cap_add:
    - NET_BIND_SERVICE
  security_opt:
    - no-new-privileges:true
  read_only: true
  tmpfs:
    - /tmp

services:
  user-service:
    <<: *security-defaults
    build:
      context: ./modules/user/api
      dockerfile: Dockerfile
    image: lk-trade/user-service:${VERSION:-latest}
    container_name: lk-user-service
    user: "1000:1000"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_PASSWORD_FILE=/run/secrets/db_password
      - JWT_SECRET_FILE=/run/secrets/jwt_secret
    secrets:
      - db_password
      - jwt_secret
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - internal
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 40s

  trade-service:
    <<: *security-defaults
    build:
      context: ./modules/trade/api
      dockerfile: Dockerfile
    image: lk-trade/trade-service:${VERSION:-latest}
    container_name: lk-trade-service
    user: "1000:1000"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_PASSWORD_FILE=/run/secrets/db_password
    secrets:
      - db_password
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    networks:
      - internal
    depends_on:
      postgres:
        condition: service_healthy
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  postgres:
    image: postgres:16-alpine
    container_name: lk-postgres
    user: postgres
    environment:
      - POSTGRES_DB=lk_trade
      - POSTGRES_USER=lk_admin
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
    secrets:
      - db_password
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - database
    # 외부 포트 노출 안 함 (보안)
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 2G
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U lk_admin"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: lk-redis
    user: redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    networks:
      - internal
    volumes:
      - redis-data:/data
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M

secrets:
  db_password:
    file: ./secrets/db_password.txt
  jwt_secret:
    file: ./secrets/jwt_secret.txt

networks:
  internal:
    driver: bridge
    internal: true  # 외부 인터넷 접근 차단
  database:
    driver: bridge
    internal: true

volumes:
  postgres-data:
  redis-data:
```

### 3. Secrets 디렉토리 구조

```bash
C:\trade\backend1\
├── secrets/              # .gitignore에 추가
│   ├── .gitkeep         # 디렉토리 유지용
│   ├── db_password.txt  # Git에 커밋 안 함
│   └── jwt_secret.txt   # Git에 커밋 안 함
├── secrets.example/     # Git에 커밋
│   ├── db_password.txt  # "CHANGE_ME"
│   └── jwt_secret.txt   # "CHANGE_ME"
└── scripts/
    └── generate-secrets.sh
```

```bash
#!/bin/bash
# scripts/generate-secrets.sh

echo "🔐 Generating secrets..."

mkdir -p secrets

# DB 비밀번호 생성 (32자 랜덤)
openssl rand -base64 32 > secrets/db_password.txt
echo "✅ Database password generated"

# JWT Secret 생성 (64자 랜덤)
openssl rand -base64 64 > secrets/jwt_secret.txt
echo "✅ JWT secret generated"

# 권한 설정 (읽기 전용)
chmod 400 secrets/*.txt

echo "
========================================
Secrets generated successfully! 🎉
========================================

⚠️  IMPORTANT: Keep these secrets safe!

Files created:
- secrets/db_password.txt
- secrets/jwt_secret.txt

Next steps:
1. Review the generated secrets
2. Update them if needed
3. NEVER commit secrets/ to Git!
========================================
"
```

### 4. 보안 체크 스크립트

```bash
#!/bin/bash
# scripts/security-check.sh

echo "🔍 Running security checks..."

# 1. Trivy 이미지 스캔
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "1. Image Vulnerability Scan (Trivy)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
for service in user-service trade-service account-service strategy-service; do
    echo "Scanning lk-trade/$service:latest..."
    trivy image --severity HIGH,CRITICAL lk-trade/$service:latest
done

# 2. Docker Bench Security
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "2. Docker Bench Security"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
docker run --rm --net host --pid host --userns host \
  --cap-add audit_control \
  -v /var/lib:/var/lib:ro \
  -v /var/run/docker.sock:/var/run/docker.sock:ro \
  docker/docker-bench-security

# 3. 실행 중인 컨테이너 보안 체크
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "3. Running Container Security Check"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
for container in $(docker ps --format '{{.Names}}'); do
    echo "Checking $container..."

    # root로 실행되는지 확인
    user=$(docker exec $container whoami 2>/dev/null)
    if [ "$user" = "root" ]; then
        echo "  ❌ WARNING: Running as root"
    else
        echo "  ✅ Running as non-root user: $user"
    fi

    # privileged 모드 확인
    privileged=$(docker inspect --format='{{.HostConfig.Privileged}}' $container)
    if [ "$privileged" = "true" ]; then
        echo "  ❌ WARNING: Running in privileged mode"
    else
        echo "  ✅ Not privileged"
    fi

    # Docker 소켓 마운트 확인
    sock_mount=$(docker inspect --format='{{range .Mounts}}{{if eq .Destination "/var/run/docker.sock"}}true{{end}}{{end}}' $container)
    if [ "$sock_mount" = "true" ]; then
        echo "  ❌ WARNING: Docker socket mounted"
    else
        echo "  ✅ Docker socket not mounted"
    fi
done

echo "
========================================
Security check completed! 🎉
========================================
"
```

### 5. Makefile 통합

```makefile
# Makefile
.PHONY: security-check security-scan secrets-generate

# 보안 검사
security-check:
	@bash scripts/security-check.sh

# 이미지 취약점 스캔
security-scan:
	@echo "🔍 Scanning images for vulnerabilities..."
	@trivy image --severity HIGH,CRITICAL lk-trade/user-service:latest
	@trivy image --severity HIGH,CRITICAL lk-trade/trade-service:latest
	@trivy image --severity HIGH,CRITICAL lk-trade/account-service:latest
	@trivy image --severity HIGH,CRITICAL lk-trade/strategy-service:latest

# Secrets 생성
secrets-generate:
	@bash scripts/generate-secrets.sh

# 보안 강화 모드로 시작
start-secure:
	@echo "🔒 Starting in secure mode..."
	@docker-compose -f docker-compose.prod.yml up -d
	@make health-check
```

---

## 보안 체크리스트

배포 전에 반드시 확인하세요:

### 이미지 보안
- [ ] 신뢰할 수 있는 베이스 이미지 사용
- [ ] 멀티 스테이지 빌드 적용
- [ ] 이미지 취약점 스캔 (Trivy)
- [ ] 불필요한 패키지 제거
- [ ] 특정 버전 태그 사용 (`:latest` 금지)

### 컨테이너 격리
- [ ] non-root 사용자로 실행
- [ ] 불필요한 Capabilities 제거 (`cap_drop: ALL`)
- [ ] `no-new-privileges` 설정
- [ ] Read-only 파일 시스템 (가능한 경우)
- [ ] PID 제한 설정

### 네트워크 보안
- [ ] 네트워크 격리 (internal 네트워크)
- [ ] 불필요한 포트 노출 금지
- [ ] 방화벽 규칙 설정

### Secrets 관리
- [ ] 환경 변수로 비밀 정보 전달 (하드코딩 금지)
- [ ] `.env` 파일을 `.gitignore`에 추가
- [ ] Docker Secrets 또는 외부 관리 시스템 사용
- [ ] Secret 파일 권한 제한 (400)

### 리소스 제한
- [ ] CPU 제한 설정
- [ ] 메모리 제한 설정
- [ ] 디스크 I/O 제한 (필요 시)

### 모니터링 & 감사
- [ ] 로그 수집 및 모니터링
- [ ] Docker 이벤트 로깅
- [ ] Falco 또는 유사 도구로 런타임 모니터링
- [ ] 정기적인 보안 스캔

---

## 다음 단계

축하합니다! 🎉 Docker 보안의 모든 것을 배웠습니다.

### 이번 섹션에서 배운 것

✅ 이미지 보안 (베이스 이미지, 멀티 스테이지, 취약점 스캔)
✅ 컨테이너 격리 및 권한 관리 (non-root, capabilities, AppArmor)
✅ 네트워크 보안 (네트워크 격리, 방화벽)
✅ Secrets 관리 (Docker Secrets, Vault, 환경 변수)
✅ Docker Daemon 보안 (소켓 보호, TLS, User Namespace)
✅ 보안 모니터링 (Docker Bench, Falco, Audit 로그)
✅ LK-Trade 프로젝트에 보안 적용

### 다음에 배울 것

**섹션 28: 백업과 복구**에서는:
- 데이터 볼륨 백업 전략
- 데이터베이스 백업 및 복원
- 컨테이너 이미지 백업
- 재해 복구 계획
- 자동화된 백업 시스템

### 추가 학습 자료

**공식 문서:**
- [Docker Security](https://docs.docker.com/engine/security/)
- [Docker Security Best Practices](https://docs.docker.com/develop/security-best-practices/)
- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)

**도구:**
- [Trivy](https://github.com/aquasecurity/trivy)
- [Docker Bench Security](https://github.com/docker/docker-bench-security)
- [Falco](https://falco.org/)
- [HashiCorp Vault](https://www.vaultproject.io/)

**심화 학습:**
- [OWASP Docker Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
- [Linux Capabilities](https://man7.org/linux/man-pages/man7/capabilities.7.html)

---

**다음 섹션에서 만나요!** 🚀