# 19-3. 인터페이스 Part 3: 실전 프로젝트, FAQ, 면접 질문

## 🚀 실전 프로젝트: 플러그인 기반 알림 시스템

이번 프로젝트에서는 인터페이스를 활용하여 **확장 가능한 알림 시스템**을 구축하겠습니다. 이 시스템은 다양한 알림 채널(이메일, SMS, 푸시, 슬랙 등)을 플러그인 방식으로 추가할 수 있으며, 실무에서 자주 사용되는 디자인 패턴을 적용합니다.

### 📋 프로젝트 요구사항

1. **다양한 알림 채널 지원**
   - 이메일, SMS, 푸시 알림, 슬랙 메시지 등
   - 새로운 채널을 코드 수정 없이 추가 가능

2. **알림 우선순위 및 타입**
   - 긴급(URGENT), 중요(HIGH), 일반(NORMAL), 정보(LOW)
   - 타입별 다른 전송 전략

3. **템플릿 시스템**
   - 알림 내용을 템플릿으로 관리
   - 변수 치환 기능

4. **전송 이력 관리**
   - 전송 성공/실패 기록
   - 재전송 기능

5. **필터링 및 라우팅**
   - 조건에 따라 적절한 채널 선택
   - 복수 채널 동시 전송

### 💻 프로젝트 구현

```java
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * ============================================
 * 1단계: 핵심 인터페이스 정의
 * ============================================
 */

/**
 * 알림 채널 인터페이스 - 모든 알림 채널이 구현해야 하는 계약
 */
interface NotificationChannel {
    /**
     * 알림 전송
     * @return 전송 성공 여부
     */
    boolean send(Notification notification);

    /**
     * 채널 이름
     */
    String getChannelName();

    /**
     * 채널이 해당 알림 타입을 지원하는지 확인
     */
    boolean supports(NotificationType type);

    /**
     * 채널 활성화 상태
     */
    boolean isEnabled();

    /**
     * 전송 가능 여부 확인 (rate limit 등)
     */
    boolean canSend();
}

/**
 * 템플릿 엔진 인터페이스
 */
interface TemplateEngine {
    String render(String template, Map<String, Object> variables);
}

/**
 * 알림 필터 인터페이스
 */
interface NotificationFilter {
    boolean shouldSend(Notification notification);
}

/**
 * 전송 이력 저장소 인터페이스
 */
interface NotificationRepository {
    void save(NotificationRecord record);
    List<NotificationRecord> findByRecipient(String recipient);
    List<NotificationRecord> findByStatus(DeliveryStatus status);
}

/**
 * 알림 라우터 인터페이스
 */
interface NotificationRouter {
    List<NotificationChannel> route(Notification notification);
}

/**
 * ============================================
 * 2단계: 데이터 모델
 * ============================================
 */

/**
 * 알림 타입
 */
enum NotificationType {
    URGENT,    // 긴급
    HIGH,      // 중요
    NORMAL,    // 일반
    LOW        // 정보
}

/**
 * 전송 상태
 */
enum DeliveryStatus {
    PENDING,   // 대기
    SENDING,   // 전송 중
    SUCCESS,   // 성공
    FAILED,    // 실패
    RETRYING   // 재시도 중
}

/**
 * 알림 객체
 */
class Notification {
    private String id;
    private String recipient;
    private String title;
    private String message;
    private NotificationType type;
    private Map<String, Object> metadata;
    private LocalDateTime createdAt;

    public Notification(String recipient, String title, String message, NotificationType type) {
        this.id = UUID.randomUUID().toString();
        this.recipient = recipient;
        this.title = title;
        this.message = message;
        this.type = type;
        this.metadata = new HashMap<>();
        this.createdAt = LocalDateTime.now();
    }

    // Getters and Setters
    public String getId() { return id; }
    public String getRecipient() { return recipient; }
    public String getTitle() { return title; }
    public String getMessage() { return message; }
    public NotificationType getType() { return type; }
    public Map<String, Object> getMetadata() { return metadata; }
    public LocalDateTime getCreatedAt() { return createdAt; }

    public void addMetadata(String key, Object value) {
        metadata.put(key, value);
    }

    @Override
    public String toString() {
        return String.format("Notification[id=%s, type=%s, recipient=%s, title=%s]",
            id, type, recipient, title);
    }
}

/**
 * 전송 기록
 */
class NotificationRecord {
    private String notificationId;
    private String channelName;
    private DeliveryStatus status;
    private LocalDateTime sentAt;
    private String errorMessage;
    private int retryCount;

    public NotificationRecord(String notificationId, String channelName) {
        this.notificationId = notificationId;
        this.channelName = channelName;
        this.status = DeliveryStatus.PENDING;
        this.sentAt = LocalDateTime.now();
        this.retryCount = 0;
    }

    // Getters and Setters
    public String getNotificationId() { return notificationId; }
    public String getChannelName() { return channelName; }
    public DeliveryStatus getStatus() { return status; }
    public void setStatus(DeliveryStatus status) { this.status = status; }
    public LocalDateTime getSentAt() { return sentAt; }
    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    public int getRetryCount() { return retryCount; }
    public void incrementRetryCount() { this.retryCount++; }

    @Override
    public String toString() {
        return String.format("Record[channel=%s, status=%s, retries=%d]",
            channelName, status, retryCount);
    }
}

/**
 * ============================================
 * 3단계: 인터페이스 구현 - 알림 채널들
 * ============================================
 */

/**
 * 이메일 채널
 */
class EmailChannel implements NotificationChannel {
    private boolean enabled = true;
    private int sentCount = 0;
    private static final int RATE_LIMIT = 100; // 시간당 100개 제한

    @Override
    public boolean send(Notification notification) {
        System.out.println("\n📧 [Email] 전송 중...");
        System.out.println("  To: " + notification.getRecipient());
        System.out.println("  Subject: " + notification.getTitle());
        System.out.println("  Body: " + notification.getMessage());

        // 전송 시뮬레이션
        try {
            Thread.sleep(100);
            sentCount++;
            System.out.println("  ✓ 이메일 전송 성공");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  ✗ 이메일 전송 실패");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Email";
    }

    @Override
    public boolean supports(NotificationType type) {
        // 이메일은 모든 타입 지원
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return sentCount < RATE_LIMIT;
    }
}

/**
 * SMS 채널
 */
class SmsChannel implements NotificationChannel {
    private boolean enabled = true;

    @Override
    public boolean send(Notification notification) {
        System.out.println("\n📱 [SMS] 전송 중...");
        System.out.println("  To: " + notification.getRecipient());
        System.out.println("  Message: " + notification.getMessage());

        try {
            Thread.sleep(50);
            System.out.println("  ✓ SMS 전송 성공");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  ✗ SMS 전송 실패");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "SMS";
    }

    @Override
    public boolean supports(NotificationType type) {
        // SMS는 긴급, 중요 알림만 지원 (비용 때문에)
        return type == NotificationType.URGENT || type == NotificationType.HIGH;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * 푸시 알림 채널
 */
class PushChannel implements NotificationChannel {
    private boolean enabled = true;

    @Override
    public boolean send(Notification notification) {
        System.out.println("\n🔔 [Push] 전송 중...");
        System.out.println("  Device: " + notification.getRecipient());
        System.out.println("  Title: " + notification.getTitle());
        System.out.println("  Body: " + notification.getMessage());

        try {
            Thread.sleep(30);
            System.out.println("  ✓ 푸시 알림 전송 성공");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  ✗ 푸시 알림 전송 실패");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Push";
    }

    @Override
    public boolean supports(NotificationType type) {
        // 푸시는 긴급, 중요, 일반만 지원 (정보성 제외)
        return type != NotificationType.LOW;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * 슬랙 채널
 */
class SlackChannel implements NotificationChannel {
    private boolean enabled = true;
    private String webhookUrl;

    public SlackChannel(String webhookUrl) {
        this.webhookUrl = webhookUrl;
    }

    @Override
    public boolean send(Notification notification) {
        System.out.println("\n💬 [Slack] 전송 중...");
        System.out.println("  Webhook: " + webhookUrl);
        System.out.println("  Channel: " + notification.getRecipient());
        System.out.println("  Message: " + notification.getTitle());

        try {
            Thread.sleep(40);
            System.out.println("  ✓ 슬랙 메시지 전송 성공");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  ✗ 슬랙 메시지 전송 실패");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Slack";
    }

    @Override
    public boolean supports(NotificationType type) {
        // 슬랙은 중요 이상만
        return type == NotificationType.URGENT || type == NotificationType.HIGH;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * ============================================
 * 4단계: 템플릿 엔진 구현
 * ============================================
 */

/**
 * 간단한 템플릿 엔진 구현
 */
class SimpleTemplateEngine implements TemplateEngine {

    @Override
    public String render(String template, Map<String, Object> variables) {
        String result = template;

        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            result = result.replace(placeholder, entry.getValue().toString());
        }

        return result;
    }
}

/**
 * ============================================
 * 5단계: 필터 구현
 * ============================================
 */

/**
 * 시간대 필터 - 야간에는 긴급 알림만
 */
class TimeBasedFilter implements NotificationFilter {

    @Override
    public boolean shouldSend(Notification notification) {
        LocalTime now = LocalTime.now();
        boolean isNightTime = now.isAfter(LocalTime.of(22, 0)) || now.isBefore(LocalTime.of(8, 0));

        if (isNightTime && notification.getType() != NotificationType.URGENT) {
            System.out.println("  [Filter] 야간 시간대: 긴급 알림만 허용");
            return false;
        }

        return true;
    }
}

/**
 * 중복 방지 필터
 */
class DuplicateFilter implements NotificationFilter {
    private Set<String> recentNotifications = new HashSet<>();
    private Map<String, LocalDateTime> sentTimes = new HashMap<>();
    private static final Duration COOLDOWN = Duration.ofMinutes(5);

    @Override
    public boolean shouldSend(Notification notification) {
        String key = notification.getRecipient() + ":" + notification.getTitle();

        if (sentTimes.containsKey(key)) {
            LocalDateTime lastSent = sentTimes.get(key);
            if (Duration.between(lastSent, LocalDateTime.now()).compareTo(COOLDOWN) < 0) {
                System.out.println("  [Filter] 중복 알림 차단: 5분 이내 동일 알림");
                return false;
            }
        }

        sentTimes.put(key, LocalDateTime.now());
        return true;
    }
}

/**
 * ============================================
 * 6단계: 라우터 구현
 * ============================================
 */

/**
 * 우선순위 기반 라우터
 */
class PriorityBasedRouter implements NotificationRouter {
    private List<NotificationChannel> channels;

    public PriorityBasedRouter(List<NotificationChannel> channels) {
        this.channels = channels;
    }

    @Override
    public List<NotificationChannel> route(Notification notification) {
        List<NotificationChannel> selectedChannels = new ArrayList<>();

        switch (notification.getType()) {
            case URGENT:
                // 긴급: 모든 채널 사용
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled() && ch.canSend())
                    .collect(Collectors.toList());
                System.out.println("  [Router] 긴급 알림 → 모든 채널 사용");
                break;

            case HIGH:
                // 중요: 푸시 + 이메일
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Push") || ch.getChannelName().equals("Email"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] 중요 알림 → 푸시 + 이메일");
                break;

            case NORMAL:
                // 일반: 푸시만
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Push"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] 일반 알림 → 푸시");
                break;

            case LOW:
                // 정보: 이메일만
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Email"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] 정보 알림 → 이메일");
                break;
        }

        return selectedChannels;
    }
}

/**
 * ============================================
 * 7단계: 저장소 구현
 * ============================================
 */

/**
 * 인메모리 저장소
 */
class InMemoryNotificationRepository implements NotificationRepository {
    private List<NotificationRecord> records = new ArrayList<>();

    @Override
    public void save(NotificationRecord record) {
        records.add(record);
    }

    @Override
    public List<NotificationRecord> findByRecipient(String recipient) {
        return records.stream()
            .filter(r -> r.getNotificationId().contains(recipient))
            .collect(Collectors.toList());
    }

    @Override
    public List<NotificationRecord> findByStatus(DeliveryStatus status) {
        return records.stream()
            .filter(r -> r.getStatus() == status)
            .collect(Collectors.toList());
    }

    public List<NotificationRecord> getAll() {
        return new ArrayList<>(records);
    }
}

/**
 * ============================================
 * 8단계: 알림 서비스 (모든 컴포넌트 통합)
 * ============================================
 */

/**
 * 알림 서비스 - 모든 인터페이스 구현체를 조합하여 사용
 */
class NotificationService {
    private List<NotificationChannel> channels;
    private NotificationRouter router;
    private List<NotificationFilter> filters;
    private NotificationRepository repository;
    private TemplateEngine templateEngine;

    public NotificationService(
        List<NotificationChannel> channels,
        NotificationRouter router,
        List<NotificationFilter> filters,
        NotificationRepository repository,
        TemplateEngine templateEngine
    ) {
        this.channels = channels;
        this.router = router;
        this.filters = filters;
        this.repository = repository;
        this.templateEngine = templateEngine;
    }

    /**
     * 알림 전송
     */
    public void send(Notification notification) {
        System.out.println("\n" + "=".repeat(60));
        System.out.println("📨 알림 전송 시작: " + notification);
        System.out.println("=".repeat(60));

        // 1. 필터링
        for (NotificationFilter filter : filters) {
            if (!filter.shouldSend(notification)) {
                System.out.println("  ⚠️  필터에 의해 차단됨");
                return;
            }
        }

        // 2. 라우팅
        List<NotificationChannel> selectedChannels = router.route(notification);

        if (selectedChannels.isEmpty()) {
            System.out.println("  ⚠️  사용 가능한 채널 없음");
            return;
        }

        // 3. 각 채널로 전송
        for (NotificationChannel channel : selectedChannels) {
            NotificationRecord record = new NotificationRecord(
                notification.getId(),
                channel.getChannelName()
            );

            record.setStatus(DeliveryStatus.SENDING);

            boolean success = channel.send(notification);

            if (success) {
                record.setStatus(DeliveryStatus.SUCCESS);
            } else {
                record.setStatus(DeliveryStatus.FAILED);
                record.setErrorMessage("전송 실패");
            }

            repository.save(record);
        }

        System.out.println("\n✅ 알림 전송 완료\n");
    }

    /**
     * 템플릿을 사용한 알림 전송
     */
    public void sendWithTemplate(String recipient, String template, Map<String, Object> variables, NotificationType type) {
        String message = templateEngine.render(template, variables);
        Notification notification = new Notification(recipient, "알림", message, type);
        send(notification);
    }

    /**
     * 전송 통계
     */
    public void printStatistics() {
        System.out.println("\n" + "=".repeat(60));
        System.out.println("📊 전송 통계");
        System.out.println("=".repeat(60));

        if (repository instanceof InMemoryNotificationRepository) {
            InMemoryNotificationRepository repo = (InMemoryNotificationRepository) repository;
            List<NotificationRecord> allRecords = repo.getAll();

            Map<DeliveryStatus, Long> statusCount = allRecords.stream()
                .collect(Collectors.groupingBy(NotificationRecord::getStatus, Collectors.counting()));

            Map<String, Long> channelCount = allRecords.stream()
                .collect(Collectors.groupingBy(NotificationRecord::getChannelName, Collectors.counting()));

            System.out.println("\n상태별 통계:");
            statusCount.forEach((status, count) ->
                System.out.println("  " + status + ": " + count + "건"));

            System.out.println("\n채널별 통계:");
            channelCount.forEach((channel, count) ->
                System.out.println("  " + channel + ": " + count + "건"));

            System.out.println("\n총 전송: " + allRecords.size() + "건");
        }
    }
}

/**
 * ============================================
 * 9단계: 테스트 및 실행
 * ============================================
 */

/**
 * 알림 시스템 테스트
 */
public class NotificationSystemTest {

    public static void main(String[] args) {

        System.out.println("╔════════════════════════════════════════════════════════╗");
        System.out.println("║     플러그인 기반 알림 시스템 - 실전 프로젝트          ║");
        System.out.println("╚════════════════════════════════════════════════════════╝");

        // 1. 알림 채널 생성 (인터페이스 구현체들)
        List<NotificationChannel> channels = Arrays.asList(
            new EmailChannel(),
            new SmsChannel(),
            new PushChannel(),
            new SlackChannel("https://hooks.slack.com/services/YOUR/WEBHOOK/URL")
        );

        // 2. 라우터 생성
        NotificationRouter router = new PriorityBasedRouter(channels);

        // 3. 필터 생성
        List<NotificationFilter> filters = Arrays.asList(
            new TimeBasedFilter(),
            new DuplicateFilter()
        );

        // 4. 저장소 생성
        NotificationRepository repository = new InMemoryNotificationRepository();

        // 5. 템플릿 엔진 생성
        TemplateEngine templateEngine = new SimpleTemplateEngine();

        // 6. 알림 서비스 생성 (의존성 주입)
        NotificationService service = new NotificationService(
            channels, router, filters, repository, templateEngine
        );

        // ========================================
        // 테스트 시나리오
        // ========================================

        // 테스트 1: 긴급 알림
        test1_UrgentNotification(service);

        // 테스트 2: 중요 알림
        test2_HighPriorityNotification(service);

        // 테스트 3: 일반 알림
        test3_NormalNotification(service);

        // 테스트 4: 정보 알림
        test4_LowPriorityNotification(service);

        // 테스트 5: 템플릿 사용
        test5_TemplateNotification(service, templateEngine);

        // 통계 출력
        service.printStatistics();

        // 최종 요약
        printSummary();
    }

    static void test1_UrgentNotification(NotificationService service) {
        System.out.println("\n\n### 테스트 1: 긴급 알림 ###");
        Notification urgent = new Notification(
            "user@example.com",
            "시스템 장애 발생",
            "데이터베이스 연결이 끊어졌습니다. 즉시 확인이 필요합니다.",
            NotificationType.URGENT
        );
        service.send(urgent);
    }

    static void test2_HighPriorityNotification(NotificationService service) {
        System.out.println("\n\n### 테스트 2: 중요 알림 ###");
        Notification high = new Notification(
            "admin@example.com",
            "보안 경고",
            "비정상적인 로그인 시도가 감지되었습니다.",
            NotificationType.HIGH
        );
        service.send(high);
    }

    static void test3_NormalNotification(NotificationService service) {
        System.out.println("\n\n### 테스트 3: 일반 알림 ###");
        Notification normal = new Notification(
            "user@example.com",
            "새 메시지",
            "안녕하세요! 새로운 메시지가 도착했습니다.",
            NotificationType.NORMAL
        );
        service.send(normal);
    }

    static void test4_LowPriorityNotification(NotificationService service) {
        System.out.println("\n\n### 테스트 4: 정보 알림 ###");
        Notification low = new Notification(
            "user@example.com",
            "주간 리포트",
            "이번 주 활동 요약을 확인하세요.",
            NotificationType.LOW
        );
        service.send(low);
    }

    static void test5_TemplateNotification(NotificationService service, TemplateEngine templateEngine) {
        System.out.println("\n\n### 테스트 5: 템플릿 알림 ###");

        String template = "안녕하세요 {{name}}님!\n" +
                          "귀하의 주문 {{orderId}}가 {{status}} 상태입니다.\n" +
                          "예상 배송일: {{deliveryDate}}";

        Map<String, Object> variables = new HashMap<>();
        variables.put("name", "홍길동");
        variables.put("orderId", "ORD-12345");
        variables.put("status", "배송 중");
        variables.put("deliveryDate", "2024-01-20");

        service.sendWithTemplate(
            "customer@example.com",
            template,
            variables,
            NotificationType.NORMAL
        );
    }

    static void printSummary() {
        System.out.println("\n\n" + "=".repeat(60));
        System.out.println("🎯 프로젝트 핵심 포인트");
        System.out.println("=".repeat(60));

        System.out.println("\n✅ 인터페이스 활용:");
        System.out.println("  1. NotificationChannel - 다양한 알림 채널 추상화");
        System.out.println("  2. NotificationRouter - 라우팅 전략 분리");
        System.out.println("  3. NotificationFilter - 필터링 로직 분리");
        System.out.println("  4. NotificationRepository - 저장소 추상화");
        System.out.println("  5. TemplateEngine - 템플릿 엔진 추상화");

        System.out.println("\n✅ 디자인 패턴:");
        System.out.println("  1. Strategy Pattern - 채널 선택 전략");
        System.out.println("  2. Chain of Responsibility - 필터 체인");
        System.out.println("  3. Dependency Injection - 의존성 주입");
        System.out.println("  4. Repository Pattern - 데이터 액세스");
        System.out.println("  5. Template Method - 템플릿 처리");

        System.out.println("\n✅ 확장성:");
        System.out.println("  • 새로운 채널 추가: NotificationChannel 구현만 추가");
        System.out.println("  • 새로운 필터 추가: NotificationFilter 구현만 추가");
        System.out.println("  • 새로운 라우팅 전략: NotificationRouter 구현 교체");
        System.out.println("  • 코드 수정 없이 플러그인 방식으로 확장 가능!");

        System.out.println("\n✅ 실무 적용:");
        System.out.println("  • 마이크로서비스 아키텍처의 알림 서비스");
        System.out.println("  • 이커머스 주문/배송 알림");
        System.out.println("  • 모니터링 시스템의 경고 알림");
        System.out.println("  • 소셜 미디어 알림 시스템");
    }
}
```

### 🎯 프로젝트 학습 포인트

1. **인터페이스 기반 설계의 장점**
   - 새로운 채널 추가가 매우 쉬움 (OCP - Open/Closed Principle)
   - 각 컴포넌트가 독립적으로 테스트 가능
   - Mock 객체로 쉽게 대체 가능

2. **다중 인터페이스 활용**
   - 각 관심사를 별도 인터페이스로 분리
   - 단일 책임 원칙 준수

3. **의존성 주입**
   - 생성자를 통한 의존성 주입
   - 느슨한 결합으로 유연한 구조

4. **확장 시나리오**
   ```java
   // 새로운 채널 추가 예: 카카오톡
   class KakaoTalkChannel implements NotificationChannel {
       @Override
       public boolean send(Notification notification) {
           // 카카오톡 전송 로직
           return true;
       }

       @Override
       public String getChannelName() {
           return "KakaoTalk";
       }

       @Override
       public boolean supports(NotificationType type) {
           return true;
       }

       @Override
       public boolean isEnabled() {
           return true;
       }

       @Override
       public boolean canSend() {
           return true;
       }
   }

   // 사용: channels 리스트에 추가만 하면 됨!
   channels.add(new KakaoTalkChannel());
   ```

---

## ❓ FAQ (자주 묻는 질문)

### Q1. 인터페이스와 추상 클래스 중 어느 것을 선택해야 하나요?

**A:** 다음 기준으로 판단하세요:

**인터페이스 선택:**
- 관련 없는 클래스들이 같은 행동을 해야 할 때
- 다중 상속(구현)이 필요할 때
- "can-do" 관계 (날 수 있다, 수영할 수 있다)
- 공통 구현 코드가 없거나 적을 때

**추상 클래스 선택:**
- 관련된 클래스들 간 코드를 공유하고 싶을 때
- 공통 필드와 메서드가 많을 때
- "is-a" 관계 (강아지는 동물이다)
- 생성자나 상태가 필요할 때

**실무 팁:**
```java
// 좋은 조합: 추상 클래스 + 인터페이스
abstract class Animal {
    protected String name; // 공통 필드

    public void sleep() { // 공통 구현
        System.out.println(name + " is sleeping");
    }

    abstract void eat(); // 서브클래스가 구현
}

interface Flyable {
    void fly(); // 능력 정의
}

class Bird extends Animal implements Flyable {
    // Animal의 공통 기능 + Flyable 능력
}
```

---

### Q2. 인터페이스에 default 메서드를 언제 사용해야 하나요?

**A:** default 메서드는 다음 상황에서 유용합니다:

1. **기존 인터페이스에 메서드 추가 (하위 호환성)**
   ```java
   interface PaymentProcessor {
       boolean process(Payment payment);

       // 나중에 추가된 메서드 - 기존 구현체를 깨지 않음
       default void refund(Payment payment) {
           System.out.println("Refund not implemented");
       }
   }
   ```

2. **공통 기본 구현 제공**
   ```java
   interface Logger {
       void log(String message);

       default void logError(String message) {
           log("ERROR: " + message);
       }

       default void logWarning(String message) {
           log("WARNING: " + message);
       }
   }
   ```

3. **유틸리티 메서드**
   ```java
   interface Comparable<T> {
       int compareTo(T other);

       default boolean lessThan(T other) {
           return compareTo(other) < 0;
       }

       default boolean greaterThan(T other) {
           return compareTo(other) > 0;
       }
   }
   ```

**주의사항:**
- 너무 많은 default 메서드는 인터페이스를 무겁게 만듦
- 상태를 가질 수 없으므로 한계가 있음
- 충돌 가능성을 항상 고려

---

### Q3. 함수형 인터페이스(Functional Interface)란 무엇인가요?

**A:** 추상 메서드가 정확히 1개인 인터페이스입니다.

**기본 개념:**
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    // 추상 메서드가 1개만 있어야 함
}

// 람다식 사용 가능
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));      // 8
System.out.println(multiply.calculate(5, 3)); // 15
```

**Java 표준 함수형 인터페이스:**

| 인터페이스 | 메서드 | 설명 | 예제 |
|-----------|--------|------|------|
| `Predicate<T>` | `boolean test(T t)` | 조건 검사 | `x -> x > 0` |
| `Function<T,R>` | `R apply(T t)` | 변환 | `x -> x * 2` |
| `Consumer<T>` | `void accept(T t)` | 소비 | `x -> System.out.println(x)` |
| `Supplier<T>` | `T get()` | 공급 | `() -> new Random().nextInt()` |

**실무 활용:**
```java
// 필터링
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)  // Predicate
    .collect(Collectors.toList());

// 변환
List<String> strings = numbers.stream()
    .map(n -> "Number: " + n)  // Function
    .collect(Collectors.toList());

// 출력
numbers.forEach(n -> System.out.println(n));  // Consumer
```

---

### Q4. 인터페이스에 static 메서드는 언제 사용하나요?

**A:** 인터페이스 관련 유틸리티 메서드를 제공할 때 사용합니다.

**사용 예:**
```java
interface MathOperations {
    int calculate(int a, int b);

    // 유틸리티 static 메서드
    static MathOperations add() {
        return (a, b) -> a + b;
    }

    static MathOperations subtract() {
        return (a, b) -> a - b;
    }

    static MathOperations multiply() {
        return (a, b) -> a * b;
    }

    // 팩토리 메서드
    static MathOperations create(String operation) {
        switch (operation) {
            case "add": return add();
            case "subtract": return subtract();
            case "multiply": return multiply();
            default: throw new IllegalArgumentException();
        }
    }
}

// 사용
MathOperations op = MathOperations.create("add");
System.out.println(op.calculate(5, 3)); // 8
```

**실제 Java API 예:**
```java
// Comparator 인터페이스의 static 메서드
List<String> names = Arrays.asList("Charlie", "Alice", "Bob");

// naturalOrder() - static 메서드
names.sort(Comparator.naturalOrder());

// comparing() - static 메서드
List<Person> people = ...;
people.sort(Comparator.comparing(Person::getName));
```

---

### Q5. 마커 인터페이스(Marker Interface)란 무엇인가요?

**A:** 메서드가 없는 빈 인터페이스로, 타입을 표시하는 용도로 사용됩니다.

**Java의 대표적인 마커 인터페이스:**
```java
// Serializable - 직렬화 가능함을 표시
public interface Serializable {
    // 메서드 없음
}

// Cloneable - 복제 가능함을 표시
public interface Cloneable {
    // 메서드 없음
}

// 사용 예
class User implements Serializable {
    private String name;
    private int age;
    // 이제 직렬화 가능
}
```

**커스텀 마커 인터페이스:**
```java
// 삭제 가능한 엔티티 표시
interface Deletable {
}

// 감사 대상 표시
interface Auditable {
}

class Document implements Deletable, Auditable {
    // ...
}

// 타입 체크로 활용
public void deleteIfPossible(Object obj) {
    if (obj instanceof Deletable) {
        // 삭제 로직
        System.out.println("Deleting: " + obj);
    } else {
        throw new IllegalArgumentException("Not deletable");
    }
}
```

**현대적 대안 - 어노테이션:**
```java
// 마커 인터페이스 대신 어노테이션 사용 (더 권장됨)
@interface Deletable {
}

@interface Auditable {
}

@Deletable
@Auditable
class Document {
    // ...
}
```

---

### Q6. 인터페이스 타입으로 변수를 선언하는 것이 왜 좋은가요?

**A:** 유연성과 다형성을 위해서입니다.

**좋은 예 (인터페이스 타입):**
```java
// 인터페이스 타입으로 선언
List<String> names = new ArrayList<>();

// 나중에 구현체 교체 가능
names = new LinkedList<>();  // OK!
names = new Vector<>();      // OK!

// 메서드 파라미터도 인터페이스 타입
public void processNames(List<String> names) {
    // ArrayList든 LinkedList든 상관없이 동작
    names.forEach(System.out::println);
}
```

**나쁜 예 (구체 클래스 타입):**
```java
// 구체 클래스로 선언
ArrayList<String> names = new ArrayList<>();

// 다른 구현체로 교체 불가
names = new LinkedList<>();  // 컴파일 에러!

// 메서드가 특정 구현에 의존
public void processNames(ArrayList<String> names) {
    // ArrayList만 받을 수 있음 - 유연성 떨어짐
}
```

**실무 가이드:**
```java
// ✅ 좋음: 인터페이스 타입
Map<String, User> userMap = new HashMap<>();
Set<String> tags = new HashSet<>();
Collection<Item> items = new ArrayList<>();

// ❌ 나쁨: 구체 클래스 타입
HashMap<String, User> userMap = new HashMap<>();
HashSet<String> tags = new HashSet<>();
ArrayList<Item> items = new ArrayList<>();

// ✅ 예외: 구체 클래스의 특정 기능이 필요한 경우
LinkedList<Task> tasks = new LinkedList<>();
tasks.addFirst(task);  // LinkedList만의 메서드
```

---

### Q7. 여러 인터페이스를 구현할 때 메서드 이름이 충돌하면 어떻게 하나요?

**A:** 충돌 유형에 따라 해결 방법이 다릅니다.

**케이스 1: 같은 시그니처, 같은 반환 타입**
```java
interface A {
    String getValue();
}

interface B {
    String getValue();
}

class MyClass implements A, B {
    @Override
    public String getValue() {
        // 하나만 구현하면 두 인터페이스 모두 만족
        return "value";
    }
}
```

**케이스 2: default 메서드 충돌**
```java
interface A {
    default void process() {
        System.out.println("A");
    }
}

interface B {
    default void process() {
        System.out.println("B");
    }
}

class MyClass implements A, B {
    @Override
    public void process() {
        // 명시적으로 오버라이드 필수
        A.super.process();  // A의 default 호출
        B.super.process();  // B의 default 호출
        // 또는 새로운 구현
    }
}
```

**케이스 3: 반환 타입이 다른 경우 (해결 불가)**
```java
interface A {
    String getData();
}

interface B {
    int getData();  // 같은 이름, 다른 반환 타입
}

// 컴파일 에러! 구현 불가능
// class MyClass implements A, B {
// }

// 해결: 인터페이스 이름을 명확히 분리
interface A {
    String getStringData();
}

interface B {
    int getIntData();
}
```

---

## 🎤 면접 질문

### 주니어 개발자 면접 질문 (7문제)

#### Q1. 인터페이스란 무엇이며, 왜 사용하나요?

**모범 답변:**

인터페이스는 클래스가 구현해야 하는 메서드들의 집합을 정의하는 추상 타입입니다.

**사용 이유:**
1. **추상화**: 구현 세부사항을 숨기고 계약만 정의
2. **다중 구현**: Java는 단일 상속만 지원하지만, 인터페이스는 여러 개 구현 가능
3. **느슨한 결합**: 구현체가 아닌 인터페이스에 의존하여 유연한 설계
4. **다형성**: 하나의 인터페이스 타입으로 여러 구현체를 다룰 수 있음

**예제:**
```java
// 결제 인터페이스
interface Payment {
    boolean process(double amount);
}

// 다양한 구현
class CreditCardPayment implements Payment {
    public boolean process(double amount) {
        // 신용카드 결제 로직
        return true;
    }
}

class KakaoPayment implements Payment {
    public boolean process(double amount) {
        // 카카오페이 결제 로직
        return true;
    }
}

// 다형성 활용
Payment payment = new CreditCardPayment();
payment.process(10000);  // 어떤 구현체든 동일하게 사용
```

---

#### Q2. 인터페이스와 추상 클래스의 차이점을 설명하세요.

**모범 답변:**

| 구분 | 인터페이스 | 추상 클래스 |
|------|------------|-------------|
| **상속/구현** | 여러 개 구현 가능 | 하나만 상속 가능 |
| **필드** | 상수만 가능 (public static final) | 모든 종류의 필드 가능 |
| **생성자** | 없음 | 있음 |
| **메서드** | 추상 메서드 + default/static | 추상/구체 메서드 모두 가능 |
| **접근 제어자** | public만 (기본) | 모든 접근 제어자 사용 가능 |
| **관계** | can-do (능력) | is-a (계층) |
| **목적** | 계약 정의 | 공통 구현 제공 |

**사용 시나리오:**
```java
// 추상 클래스: 공통 코드가 많을 때
abstract class Animal {
    protected String name;  // 공통 필드

    public Animal(String name) {  // 생성자
        this.name = name;
    }

    public void sleep() {  // 공통 구현
        System.out.println(name + " is sleeping");
    }

    abstract void eat();  // 서브클래스가 구현
}

// 인터페이스: 능력을 정의할 때
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

// 조합 사용
class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    void eat() { /* ... */ }
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

---

#### Q3. 인터페이스의 모든 메서드를 구현하지 않으면 어떻게 되나요?

**모범 답변:**

인터페이스의 모든 추상 메서드를 구현하지 않으면 **컴파일 에러**가 발생합니다.

**예제:**
```java
interface MediaPlayer {
    void play();
    void pause();
    void stop();
}

// ❌ 컴파일 에러!
class SimplePlayer implements MediaPlayer {
    public void play() {
        System.out.println("Playing");
    }
    // pause()와 stop()을 구현하지 않음!
}
```

**에러 메시지:**
```
Error: SimplePlayer is not abstract and does not override abstract method
pause() in MediaPlayer
```

**해결 방법:**

1. **모든 메서드 구현:**
   ```java
   class SimplePlayer implements MediaPlayer {
       public void play() { /* 구현 */ }
       public void pause() { /* 구현 */ }
       public void stop() { /* 구현 */ }
   }
   ```

2. **추상 클래스로 만들기:**
   ```java
   abstract class SimplePlayer implements MediaPlayer {
       public void play() { /* 구현 */ }
       // 나머지는 서브클래스에서 구현
   }
   ```

3. **인터페이스 분리 (ISP):**
   ```java
   interface BasicPlayer {
       void play();
   }

   interface AdvancedPlayer extends BasicPlayer {
       void pause();
       void stop();
   }

   // 필요한 것만 구현
   class SimplePlayer implements BasicPlayer {
       public void play() { /* 구현 */ }
   }
   ```

---

#### Q4. default 메서드는 무엇이며, 왜 Java 8에 추가되었나요?

**모범 답변:**

default 메서드는 인터페이스에 기본 구현을 제공하는 메서드입니다.

**추가된 이유:**
1. **하위 호환성**: 기존 인터페이스에 새 메서드를 추가해도 기존 구현체가 깨지지 않음
2. **공통 기능 제공**: 인터페이스에서도 공통 구현 코드를 제공 가능
3. **선택적 구현**: 필요한 경우에만 오버라이드

**예제:**
```java
interface Collection<E> {
    // 기존 메서드들...
    boolean add(E e);
    boolean remove(Object o);

    // Java 8에 추가된 default 메서드
    default void forEach(Consumer<? super E> action) {
        for (E element : this) {
            action.accept(element);
        }
    }

    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
}

// 기존 구현체들은 수정 없이도 새 메서드 사용 가능!
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.forEach(System.out::println);  // default 메서드 사용
```

**실무 활용:**
```java
interface Logger {
    void log(String message);

    // 편의 메서드들
    default void logInfo(String message) {
        log("INFO: " + message);
    }

    default void logError(String message) {
        log("ERROR: " + message);
    }

    default void logDebug(String message) {
        log("DEBUG: " + message);
    }
}

// 구현 클래스는 log()만 구현하면 됨
class ConsoleLogger implements Logger {
    public void log(String message) {
        System.out.println(message);
    }
    // logInfo, logError, logDebug는 자동으로 사용 가능
}
```

---

#### Q5. 인터페이스를 직접 인스턴스화할 수 있나요?

**모범 답변:**

**아니요, 인터페이스는 직접 인스턴스화할 수 없습니다.**

인터페이스는 추상 타입이므로 구현체를 통해서만 사용할 수 있습니다.

**잘못된 시도:**
```java
interface Runnable {
    void run();
}

// ❌ 컴파일 에러!
Runnable r = new Runnable();
```

**올바른 방법:**

1. **구현 클래스 사용:**
   ```java
   class MyRunnable implements Runnable {
       public void run() {
           System.out.println("Running");
       }
   }

   Runnable r = new MyRunnable();
   r.run();
   ```

2. **익명 클래스 사용:**
   ```java
   Runnable r = new Runnable() {
       @Override
       public void run() {
           System.out.println("Running");
       }
   };
   r.run();
   ```

3. **람다식 사용 (함수형 인터페이스인 경우):**
   ```java
   Runnable r = () -> System.out.println("Running");
   r.run();
   ```

**왜 인스턴스화가 불가능한가?**
- 인터페이스는 구현 코드가 없는 추상 메서드를 포함
- 객체를 만들려면 모든 메서드가 구현되어 있어야 함
- 따라서 구현 클래스가 필요함

---

#### Q6. 함수형 인터페이스(Functional Interface)란 무엇인가요?

**모범 답변:**

함수형 인터페이스는 **추상 메서드가 정확히 하나만 있는 인터페이스**입니다.

람다식과 함께 사용되며, `@FunctionalInterface` 어노테이션으로 명시할 수 있습니다.

**특징:**
- 추상 메서드 1개
- default 메서드는 여러 개 가능
- static 메서드도 여러 개 가능
- 람다식으로 간결하게 구현 가능

**예제:**
```java
// 함수형 인터페이스 정의
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // 추상 메서드 1개

    // default와 static은 개수 제한 없음
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }

    static Calculator add() {
        return (a, b) -> a + b;
    }
}

// 람다식으로 구현
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));      // 8
System.out.println(multiply.calculate(5, 3)); // 15
```

**Java 표준 함수형 인터페이스:**
```java
// Predicate<T> - 조건 검사
Predicate<Integer> isPositive = n -> n > 0;
System.out.println(isPositive.test(5));  // true

// Function<T,R> - 변환
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Hello"));  // 5

// Consumer<T> - 소비
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");  // Hello

// Supplier<T> - 공급
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());  // 랜덤 값
```

**실무 활용:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 필터링 (Predicate)
numbers.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);  // 2, 4

// 변환 (Function)
numbers.stream()
    .map(n -> n * 2)
    .forEach(System.out::println);  // 2, 4, 6, 8, 10
```

---

#### Q7. 인터페이스에서 변수를 선언하면 어떻게 되나요?

**모범 답변:**

인터페이스에서 선언하는 모든 변수는 **자동으로 `public static final`**이 됩니다. 즉, **상수**가 됩니다.

**특징:**
- `public`: 어디서나 접근 가능
- `static`: 인터페이스 이름으로 직접 접근
- `final`: 값 변경 불가능 (상수)

**예제:**
```java
interface Constants {
    // 모두 동일: public static final이 자동 추가됨
    int MAX_SIZE = 100;
    public static final int MIN_SIZE = 0;
    String DEFAULT_NAME = "Unknown";
}

// 사용
class Test {
    public static void main(String[] args) {
        System.out.println(Constants.MAX_SIZE);      // 100
        System.out.println(Constants.DEFAULT_NAME);  // Unknown

        // ❌ 컴파일 에러! 값 변경 불가
        // Constants.MAX_SIZE = 200;
    }
}
```

**실제 사용 사례:**
```java
// HTTP 상태 코드
interface HttpStatus {
    int OK = 200;
    int CREATED = 201;
    int BAD_REQUEST = 400;
    int UNAUTHORIZED = 401;
    int NOT_FOUND = 404;
    int INTERNAL_SERVER_ERROR = 500;
}

// 사용
if (statusCode == HttpStatus.NOT_FOUND) {
    System.out.println("Page not found");
}
```

**Enum과의 비교:**
```java
// 예전 방식: 인터페이스 상수
interface Color {
    int RED = 0;
    int GREEN = 1;
    int BLUE = 2;
}

// 현대적 방식: Enum (더 권장됨)
enum Color {
    RED, GREEN, BLUE
}

// Enum이 더 좋은 이유:
// 1. 타입 안정성
// 2. 메서드 추가 가능
// 3. switch 문에서 사용 편리
```

---

### 중급 개발자 면접 질문 (5문제)

#### Q8. 인터페이스 기반 설계의 SOLID 원칙 중 어떤 것을 만족하나요?

**모범 답변:**

인터페이스는 SOLID 원칙의 여러 항목을 만족하는 핵심 도구입니다.

**1. SRP (Single Responsibility Principle) - 단일 책임 원칙**
```java
// ❌ 나쁜 예: 하나의 인터페이스에 너무 많은 책임
interface UserService {
    void createUser();
    void deleteUser();
    void sendEmail();
    void generateReport();
    void processPayment();
}

// ✅ 좋은 예: 책임별로 인터페이스 분리
interface UserRepository {
    void createUser();
    void deleteUser();
}

interface EmailService {
    void sendEmail();
}

interface ReportGenerator {
    void generateReport();
}
```

**2. OCP (Open/Closed Principle) - 개방/폐쇄 원칙**
```java
// 확장에는 열려있고, 수정에는 닫혀있음
interface PaymentProcessor {
    boolean process(Payment payment);
}

// 새로운 결제 방식 추가 시 기존 코드 수정 없이 확장
class CreditCardProcessor implements PaymentProcessor { }
class PayPalProcessor implements PaymentProcessor { }
class KakaoPayProcessor implements PaymentProcessor { }  // 새로 추가

// 사용하는 코드는 변경 불필요
class OrderService {
    private PaymentProcessor processor;

    public void processOrder(Payment payment) {
        processor.process(payment);  // 어떤 구현체든 동작
    }
}
```

**3. LSP (Liskov Substitution Principle) - 리스코프 치환 원칙**
```java
interface Shape {
    double area();
}

class Circle implements Shape {
    public double area() { return Math.PI * radius * radius; }
}

class Rectangle implements Shape {
    public double area() { return width * height; }
}

// Shape 타입으로 Circle과 Rectangle을 동일하게 사용 가능
void printArea(Shape shape) {
    System.out.println(shape.area());  // 어떤 구현체든 정상 동작
}
```

**4. ISP (Interface Segregation Principle) - 인터페이스 분리 원칙**
```java
// ❌ 나쁜 예: 거대한 인터페이스
interface Worker {
    void work();
    void eat();
    void sleep();
    void getPaid();
}

// ✅ 좋은 예: 작고 구체적인 인터페이스들
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

interface Payable {
    void getPaid();
}

// 필요한 것만 구현
class Robot implements Workable {
    public void work() { /* ... */ }
    // Robot은 먹거나 자지 않으므로 다른 인터페이스는 구현 안 함
}

class Human implements Workable, Eatable, Sleepable, Payable {
    // 모든 인터페이스 구현
}
```

**5. DIP (Dependency Inversion Principle) - 의존성 역전 원칙**
```java
// ❌ 나쁜 예: 구체 클래스에 의존
class OrderService {
    private MySQLDatabase database;  // 구체 클래스에 의존

    public void saveOrder(Order order) {
        database.save(order);
    }
}

// ✅ 좋은 예: 인터페이스에 의존
interface Database {
    void save(Order order);
}

class OrderService {
    private Database database;  // 인터페이스에 의존

    public OrderService(Database database) {
        this.database = database;
    }

    public void saveOrder(Order order) {
        database.save(order);  // MySQL이든 MongoDB든 상관없음
    }
}

class MySQLDatabase implements Database { }
class MongoDatabase implements Database { }
```

---

#### Q9. 인터페이스와 추상 클래스를 함께 사용하는 디자인 패턴을 설명하세요.

**모범 답변:**

인터페이스와 추상 클래스를 조합하면 **유연성**과 **코드 재사용**을 모두 얻을 수 있습니다.

**패턴: 인터페이스 + 추상 골격 클래스 (Skeletal Implementation)**

Java의 컬렉션 프레임워크에서 많이 사용하는 패턴입니다.

**구조:**
```java
// 1. 인터페이스 정의 (계약)
interface List<E> {
    boolean add(E element);
    E get(int index);
    int size();
    boolean isEmpty();
    // ... 많은 메서드들
}

// 2. 추상 골격 클래스 (공통 구현 제공)
abstract class AbstractList<E> implements List<E> {

    // 공통 구현 메서드
    @Override
    public boolean isEmpty() {
        return size() == 0;
    }

    @Override
    public boolean contains(E element) {
        for (int i = 0; i < size(); i++) {
            if (get(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    // 서브클래스가 구현해야 하는 핵심 메서드만 추상으로
    @Override
    public abstract E get(int index);

    @Override
    public abstract int size();
}

// 3. 구체 클래스 (최소한의 구현만)
class ArrayList<E> extends AbstractList<E> {
    private Object[] elements;
    private int size;

    @Override
    public boolean add(E element) {
        elements[size++] = element;
        return true;
    }

    @Override
    public E get(int index) {
        return (E) elements[index];
    }

    @Override
    public int size() {
        return size;
    }

    // isEmpty(), contains()는 AbstractList에서 상속받아 사용
}
```

**실무 예제:**
```java
// 알림 시스템 예제
interface NotificationChannel {
    boolean send(Notification notification);
    String getChannelName();
    boolean supports(NotificationType type);
}

// 공통 기능을 제공하는 추상 클래스
abstract class AbstractNotificationChannel implements NotificationChannel {
    protected boolean enabled = true;
    protected int retryCount = 3;

    @Override
    public boolean send(Notification notification) {
        // 공통 전처리
        if (!enabled) {
            System.out.println("Channel disabled");
            return false;
        }

        if (!supports(notification.getType())) {
            System.out.println("Type not supported");
            return false;
        }

        // 재시도 로직
        for (int i = 0; i < retryCount; i++) {
            if (doSend(notification)) {
                return true;
            }
            System.out.println("Retry " + (i + 1));
        }

        return false;
    }

    // 서브클래스가 구현할 핵심 메서드
    protected abstract boolean doSend(Notification notification);
}

// 구체 클래스는 핵심 로직만 구현
class EmailChannel extends AbstractNotificationChannel {
    @Override
    protected boolean doSend(Notification notification) {
        // 이메일 전송 로직만 구현
        System.out.println("Sending email: " + notification.getMessage());
        return true;
    }

    @Override
    public String getChannelName() {
        return "Email";
    }

    @Override
    public boolean supports(NotificationType type) {
        return true;  // 모든 타입 지원
    }
}

class SmsChannel extends AbstractNotificationChannel {
    @Override
    protected boolean doSend(Notification notification) {
        // SMS 전송 로직만 구현
        System.out.println("Sending SMS: " + notification.getMessage());
        return true;
    }

    @Override
    public String getChannelName() {
        return "SMS";
    }

    @Override
    public boolean supports(NotificationType type) {
        return type == NotificationType.URGENT;  // 긴급만 지원
    }
}
```

**장점:**
1. 인터페이스의 유연성 유지 (다중 구현 가능)
2. 공통 코드 재사용 (추상 클래스)
3. 최소한의 구현으로 새로운 클래스 추가 가능
4. 템플릿 메서드 패턴 활용 가능

---

#### Q10. Java 8 이후 인터페이스에 default 메서드가 추가되면서 추상 클래스와의 차이가 줄어들었습니다. 그럼에도 추상 클래스가 필요한 이유는?

**모범 답변:**

default 메서드가 추가되었지만, 추상 클래스는 여전히 중요한 역할을 합니다.

**추상 클래스만 할 수 있는 것들:**

**1. 인스턴스 변수 (상태) 보유**
```java
// 인터페이스: 인스턴스 변수 불가능
interface Drawable {
    // int x, y;  // ❌ 불가능 (상수만 가능)

    default void draw() {
        // ❌ 상태를 저장할 방법이 없음
    }
}

// 추상 클래스: 인스턴스 변수 가능
abstract class Shape {
    protected int x, y;  // ✅ 상태 보유 가능
    protected String color;

    public Shape(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void moveTo(int newX, int newY) {
        this.x = newX;
        this.y = newY;
    }

    abstract void draw();
}
```

**2. 생성자**
```java
// 인터페이스: 생성자 없음
interface Animal {
    // ❌ 생성자 불가능
}

// 추상 클래스: 생성자 있음
abstract class Animal {
    private String name;
    private int age;

    // ✅ 생성자로 필수 필드 초기화
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    abstract void makeSound();
}

class Dog extends Animal {
    public Dog(String name, int age) {
        super(name, age);  // 부모 생성자 호출
    }

    void makeSound() {
        System.out.println("Woof!");
    }
}
```

**3. protected 멤버**
```java
// 인터페이스: public만 가능
interface Processor {
    // ❌ protected 불가능
    void process();
}

// 추상 클래스: 모든 접근 제어자 사용 가능
abstract class DataProcessor {
    // ✅ 서브클래스에서만 접근 가능한 protected 메서드
    protected void validateData(String data) {
        if (data == null) {
            throw new IllegalArgumentException();
        }
    }

    // ✅ 내부에서만 사용하는 private 메서드
    private void log(String message) {
        System.out.println(message);
    }

    public abstract void process(String data);
}
```

**4. final 메서드 (오버라이드 방지)**
```java
// 추상 클래스: final 메서드로 변경 방지
abstract class PaymentProcessor {
    // ✅ 서브클래스가 절대 오버라이드할 수 없음
    public final void processPayment(Payment payment) {
        validatePayment(payment);
        deductAmount(payment);
        sendReceipt(payment);
    }

    protected abstract void validatePayment(Payment payment);
    protected abstract void deductAmount(Payment payment);

    private void sendReceipt(Payment payment) {
        // 영수증 발송
    }
}
```

**5. 명확한 상속 계층**
```java
// 추상 클래스: is-a 관계 표현
abstract class Vehicle {
    private String brand;
    private int maxSpeed;

    public Vehicle(String brand, int maxSpeed) {
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    public void start() {
        System.out.println(brand + " starting...");
    }

    abstract void move();
}

class Car extends Vehicle {
    public Car(String brand) {
        super(brand, 200);
    }

    void move() {
        System.out.println("Driving on road");
    }
}

// Car IS-A Vehicle (명확한 상속 관계)
```

**실무 가이드:**

| 상황 | 선택 |
|------|------|
| 공통 상태(필드)가 필요함 | 추상 클래스 |
| 생성자가 필요함 | 추상 클래스 |
| protected 멤버가 필요함 | 추상 클래스 |
| 다중 구현이 필요함 | 인터페이스 |
| 관련 없는 클래스들의 공통 행동 | 인터페이스 |
| is-a 관계 | 추상 클래스 |
| can-do 관계 | 인터페이스 |

**최선의 조합:**
```java
// 인터페이스로 능력 정의
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

// 추상 클래스로 공통 상태와 구현 제공
abstract class Animal {
    protected String name;
    protected int energy;

    public Animal(String name) {
        this.name = name;
        this.energy = 100;
    }

    public void rest() {
        energy += 20;
    }

    abstract void eat();
}

// 조합 사용
class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    void eat() { /* ... */ }
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

---

#### Q11. 전략 패턴(Strategy Pattern)과 인터페이스의 관계를 설명하고, 실제 사용 사례를 제시하세요.

**모범 답변:**

전략 패턴은 **알고리즘을 캡슐화하고 교체 가능하게 만드는 디자인 패턴**으로, 인터페이스를 핵심으로 사용합니다.

**구조:**
1. Strategy 인터페이스: 알고리즘의 공통 인터페이스
2. Concrete Strategy: 다양한 알고리즘 구현
3. Context: 전략을 사용하는 클래스

**기본 예제:**
```java
// 1. 전략 인터페이스
interface PaymentStrategy {
    boolean pay(double amount);
    String getPaymentMethod();
}

// 2. 구체적 전략들
class CreditCardStrategy implements PaymentStrategy {
    private String cardNumber;

    public CreditCardStrategy(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public boolean pay(double amount) {
        System.out.println("신용카드 " + cardNumber + "로 " + amount + "원 결제");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Credit Card";
    }
}

class KakaoPayStrategy implements PaymentStrategy {
    private String phoneNumber;

    public KakaoPayStrategy(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    @Override
    public boolean pay(double amount) {
        System.out.println("카카오페이로 " + amount + "원 결제");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Kakao Pay";
    }
}

class NaverPayStrategy implements PaymentStrategy {
    @Override
    public boolean pay(double amount) {
        System.out.println("네이버페이로 " + amount + "원 결제");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Naver Pay";
    }
}

// 3. Context 클래스
class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    private PaymentStrategy paymentStrategy;

    public void addItem(Item item) {
        items.add(item);
    }

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout() {
        double total = items.stream()
            .mapToDouble(Item::getPrice)
            .sum();

        System.out.println("\n총 금액: " + total + "원");
        System.out.println("결제 수단: " + paymentStrategy.getPaymentMethod());

        boolean success = paymentStrategy.pay(total);

        if (success) {
            System.out.println("✓ 결제 완료!");
            items.clear();
        } else {
            System.out.println("✗ 결제 실패!");
        }
    }
}

// 사용
ShoppingCart cart = new ShoppingCart();
cart.addItem(new Item("노트북", 1500000));
cart.addItem(new Item("마우스", 30000));

// 런타임에 전략 변경 가능!
cart.setPaymentStrategy(new CreditCardStrategy("1234-5678-9012-3456"));
cart.checkout();

// 다른 결제 수단으로 변경
cart.addItem(new Item("키보드", 80000));
cart.setPaymentStrategy(new KakaoPayStrategy("010-1234-5678"));
cart.checkout();
```

**실무 사례 1: 정렬 알고리즘**
```java
// 정렬 전략 인터페이스
interface SortStrategy<T> {
    void sort(List<T> list, Comparator<T> comparator);
}

// 버블 정렬
class BubbleSortStrategy<T> implements SortStrategy<T> {
    @Override
    public void sort(List<T> list, Comparator<T> comparator) {
        System.out.println("Bubble Sort 사용");
        // 버블 정렬 구현
        for (int i = 0; i < list.size() - 1; i++) {
            for (int j = 0; j < list.size() - i - 1; j++) {
                if (comparator.compare(list.get(j), list.get(j + 1)) > 0) {
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                }
            }
        }
    }
}

// 퀵 정렬
class QuickSortStrategy<T> implements SortStrategy<T> {
    @Override
    public void sort(List<T> list, Comparator<T> comparator) {
        System.out.println("Quick Sort 사용");
        // 퀵 정렬 구현
        quickSort(list, 0, list.size() - 1, comparator);
    }

    private void quickSort(List<T> list, int low, int high, Comparator<T> comparator) {
        // 퀵 정렬 로직...
    }
}

// Context
class Sorter<T> {
    private SortStrategy<T> strategy;

    public void setStrategy(SortStrategy<T> strategy) {
        this.strategy = strategy;
    }

    public void sort(List<T> list, Comparator<T> comparator) {
        // 데이터 크기에 따라 전략 선택
        if (list.size() < 10) {
            setStrategy(new BubbleSortStrategy<>());
        } else {
            setStrategy(new QuickSortStrategy<>());
        }

        strategy.sort(list, comparator);
    }
}
```

**실무 사례 2: 파일 압축**
```java
// 압축 전략
interface CompressionStrategy {
    byte[] compress(byte[] data);
    byte[] decompress(byte[] data);
    String getAlgorithmName();
}

class ZipCompression implements CompressionStrategy {
    @Override
    public byte[] compress(byte[] data) {
        System.out.println("ZIP 압축 중...");
        // ZIP 압축 로직
        return data;
    }

    @Override
    public byte[] decompress(byte[] data) {
        System.out.println("ZIP 압축 해제 중...");
        return data;
    }

    @Override
    public String getAlgorithmName() {
        return "ZIP";
    }
}

class GzipCompression implements CompressionStrategy {
    @Override
    public byte[] compress(byte[] data) {
        System.out.println("GZIP 압축 중...");
        return data;
    }

    @Override
    public byte[] decompress(byte[] data) {
        System.out.println("GZIP 압축 해제 중...");
        return data;
    }

    @Override
    public String getAlgorithmName() {
        return "GZIP";
    }
}

// Context
class FileCompressor {
    private CompressionStrategy strategy;

    public void setCompressionStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void compressFile(String filename, byte[] data) {
        System.out.println("\n파일 압축: " + filename);
        System.out.println("알고리즘: " + strategy.getAlgorithmName());

        byte[] compressed = strategy.compress(data);

        System.out.println("원본 크기: " + data.length + " bytes");
        System.out.println("압축 크기: " + compressed.length + " bytes");
    }
}

// 사용
FileCompressor compressor = new FileCompressor();

// 작은 파일은 ZIP
compressor.setCompressionStrategy(new ZipCompression());
compressor.compressFile("small.txt", smallData);

// 큰 파일은 GZIP
compressor.setCompressionStrategy(new GzipCompression());
compressor.compressFile("large.txt", largeData);
```

**전략 패턴의 장점:**
1. **개방/폐쇄 원칙 (OCP)**: 새로운 전략 추가가 쉬움
2. **런타임 변경**: 실행 중에 알고리즘 교체 가능
3. **조건문 제거**: if-else 대신 다형성 사용
4. **테스트 용이**: 각 전략을 독립적으로 테스트 가능

**Before (전략 패턴 없이):**
```java
class PaymentProcessor {
    public void processPayment(String type, double amount) {
        if (type.equals("credit")) {
            // 신용카드 로직
        } else if (type.equals("kakao")) {
            // 카카오페이 로직
        } else if (type.equals("naver")) {
            // 네이버페이 로직
        }
        // 새로운 결제 수단 추가 시 이 클래스를 수정해야 함 (OCP 위반)
    }
}
```

**After (전략 패턴 사용):**
```java
class PaymentProcessor {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPayment(double amount) {
        strategy.pay(amount);
        // 새로운 결제 수단 추가 시 PaymentStrategy 구현만 추가 (OCP 준수)
    }
}
```

---

#### Q12. 인터페이스를 사용한 Dependency Injection(의존성 주입)의 원리와 장점을 설명하세요.

**모범 답변:**

의존성 주입은 **객체가 필요로 하는 의존성을 외부에서 주입받는 디자인 패턴**으로, 인터페이스를 통해 느슨한 결합을 달성합니다.

**의존성 주입의 3가지 방법:**

**1. 생성자 주입 (Constructor Injection) - 가장 권장**
```java
interface UserRepository {
    User findById(int id);
    void save(User user);
}

class UserService {
    private final UserRepository repository;  // final로 불변성 보장

    // 생성자로 주입
    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }
}

// 사용
UserRepository repo = new JdbcUserRepository();
UserService service = new UserService(repo);  // 의존성 주입
```

**2. 세터 주입 (Setter Injection)**
```java
class UserService {
    private UserRepository repository;

    // 세터로 주입
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }
}

// 사용
UserService service = new UserService();
service.setRepository(new JdbcUserRepository());  // 의존성 주입
```

**3. 인터페이스 주입 (Interface Injection) - 잘 안 씀**
```java
interface RepositoryInjector {
    void injectRepository(UserRepository repository);
}

class UserService implements RepositoryInjector {
    private UserRepository repository;

    @Override
    public void injectRepository(UserRepository repository) {
        this.repository = repository;
    }
}
```

**의존성 주입 없이 (나쁜 예):**
```java
// ❌ 강한 결합: UserService가 JdbcUserRepository에 직접 의존
class UserService {
    private JdbcUserRepository repository = new JdbcUserRepository();

    public User getUser(int id) {
        return repository.findById(id);
    }

    // 문제점:
    // 1. 다른 구현체로 교체 불가능
    // 2. 테스트 시 Mock 객체 사용 불가능
    // 3. UserService가 JdbcUserRepository의 생성 방법을 알아야 함
}
```

**의존성 주입 사용 (좋은 예):**
```java
// ✅ 느슨한 결합: 인터페이스에만 의존
interface UserRepository {
    User findById(int id);
    void save(User user);
}

class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }

    // 장점:
    // 1. 다양한 구현체로 교체 가능
    // 2. 테스트 용이
    // 3. 유연한 설계
}

// 다양한 구현체
class JdbcUserRepository implements UserRepository { /* JDBC 구현 */ }
class JpaUserRepository implements UserRepository { /* JPA 구현 */ }
class MongoUserRepository implements UserRepository { /* MongoDB 구현 */ }
class MockUserRepository implements UserRepository { /* 테스트용 */ }

// 사용 - 런타임에 구현체 선택
UserRepository repo = new JdbcUserRepository();  // 프로덕션
// UserRepository repo = new MockUserRepository();  // 테스트
UserService service = new UserService(repo);
```

**실무 예제: 다층 아키텍처**
```java
// === 인터페이스 정의 ===

interface OrderRepository {
    Order findById(int id);
    void save(Order order);
}

interface PaymentGateway {
    boolean processPayment(Payment payment);
}

interface NotificationService {
    void sendOrderConfirmation(Order order);
}

// === 구현체들 ===

class JdbcOrderRepository implements OrderRepository {
    @Override
    public Order findById(int id) {
        // JDBC로 주문 조회
        return null;
    }

    @Override
    public void save(Order order) {
        // JDBC로 주문 저장
    }
}

class StripePaymentGateway implements PaymentGateway {
    @Override
    public boolean processPayment(Payment payment) {
        System.out.println("Stripe로 결제 처리");
        return true;
    }
}

class EmailNotificationService implements NotificationService {
    @Override
    public void sendOrderConfirmation(Order order) {
        System.out.println("이메일 발송: 주문 확인");
    }
}

// === 서비스 계층 (의존성 주입 받음) ===

class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    private final NotificationService notificationService;

    // 생성자 주입
    public OrderService(
        OrderRepository orderRepository,
        PaymentGateway paymentGateway,
        NotificationService notificationService
    ) {
        this.orderRepository = orderRepository;
        this.paymentGateway = paymentGateway;
        this.notificationService = notificationService;
    }

    public boolean placeOrder(Order order, Payment payment) {
        // 1. 결제 처리
        boolean paymentSuccess = paymentGateway.processPayment(payment);
        if (!paymentSuccess) {
            return false;
        }

        // 2. 주문 저장
        orderRepository.save(order);

        // 3. 알림 발송
        notificationService.sendOrderConfirmation(order);

        return true;
    }
}

// === 사용 (수동 DI) ===

class Main {
    public static void main(String[] args) {
        // 의존성들을 생성
        OrderRepository orderRepo = new JdbcOrderRepository();
        PaymentGateway paymentGateway = new StripePaymentGateway();
        NotificationService notificationService = new EmailNotificationService();

        // OrderService에 주입
        OrderService orderService = new OrderService(
            orderRepo,
            paymentGateway,
            notificationService
        );

        // 사용
        Order order = new Order(/*...*/);
        Payment payment = new Payment(/*...*/);
        orderService.placeOrder(order, payment);
    }
}

// === 테스트 (Mock 객체 사용) ===

class OrderServiceTest {
    @Test
    public void testPlaceOrder() {
        // Mock 객체들 생성
        OrderRepository mockRepo = new OrderRepository() {
            @Override
            public Order findById(int id) { return null; }

            @Override
            public void save(Order order) {
                System.out.println("Mock: 주문 저장됨");
            }
        };

        PaymentGateway mockPayment = payment -> {
            System.out.println("Mock: 결제 성공");
            return true;
        };

        NotificationService mockNotification = order -> {
            System.out.println("Mock: 알림 발송됨");
        };

        // OrderService에 Mock 주입
        OrderService service = new OrderService(
            mockRepo,
            mockPayment,
            mockNotification
        );

        // 테스트 실행
        Order order = new Order(/*...*/);
        Payment payment = new Payment(/*...*/);
        boolean result = service.placeOrder(order, payment);

        // 검증
        assertTrue(result);
    }
}
```

**Spring Framework에서의 DI:**
```java
// Spring의 @Autowired를 사용한 자동 DI
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    private final NotificationService notificationService;

    @Autowired  // Spring이 자동으로 주입
    public OrderService(
        OrderRepository orderRepository,
        PaymentGateway paymentGateway,
        NotificationService notificationService
    ) {
        this.orderRepository = orderRepository;
        this.paymentGateway = paymentGateway;
        this.notificationService = notificationService;
    }

    // ...
}

// Bean 등록
@Configuration
public class AppConfig {
    @Bean
    public OrderRepository orderRepository() {
        return new JdbcOrderRepository();
    }

    @Bean
    public PaymentGateway paymentGateway() {
        return new StripePaymentGateway();
    }

    @Bean
    public NotificationService notificationService() {
        return new EmailNotificationService();
    }
}
```

**의존성 주입의 장점:**

1. **테스트 용이성**
   - Mock 객체로 쉽게 대체 가능
   - 단위 테스트 작성이 간편

2. **유연성**
   - 런타임에 구현체 교체 가능
   - 설정만으로 다른 구현 사용 가능

3. **재사용성**
   - 컴포넌트를 다양한 환경에서 재사용

4. **단일 책임 원칙**
   - 객체 생성 책임이 분리됨
   - 각 클래스는 자신의 역할에만 집중

5. **개방/폐쇄 원칙**
   - 새로운 구현체 추가가 쉬움
   - 기존 코드 수정 불필요

---

## 🎯 최종 정리

### 인터페이스 핵심 개념

1. **인터페이스는 계약(Contract)**
   - 무엇을 할지 정의 (how가 아닌 what)
   - 구현 클래스가 반드시 지켜야 할 약속

2. **다형성의 핵심**
   - 하나의 인터페이스로 여러 구현체 다루기
   - 런타임에 동작 변경 가능

3. **느슨한 결합**
   - 구체적인 구현이 아닌 인터페이스에 의존
   - 유연하고 확장 가능한 설계

4. **다중 구현**
   - 여러 인터페이스를 동시에 구현 가능
   - 능력(capability) 조합

### 실무 적용 가이드

1. **인터페이스 타입으로 변수 선언**
   ```java
   List<String> list = new ArrayList<>();  // ✅
   ArrayList<String> list = new ArrayList<>();  // ❌
   ```

2. **의존성 주입 활용**
   ```java
   class Service {
       private final Repository repo;

       public Service(Repository repo) {  // 인터페이스로 받기
           this.repo = repo;
       }
   }
   ```

3. **인터페이스는 작고 구체적으로**
   - ISP (Interface Segregation Principle) 준수
   - 역할별로 분리

4. **default 메서드는 신중하게**
   - 하위 호환성이나 공통 기능 제공에만 사용
   - 너무 많으면 인터페이스가 무거워짐

다음 Chapter 20에서는 **Enum (열거형)**을 다루겠습니다! 🚀
