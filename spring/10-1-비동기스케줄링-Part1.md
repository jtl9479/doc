# 10장: 비동기 처리와 스케줄링 - Part 1

## 학습 목표

이 장을 마치면 다음을 할 수 있습니다:

1. **비동기 처리의 필요성과 장점 이해하기**
   - 동기 vs 비동기 처리 방식의 차이
   - 비동기 처리가 필요한 실무 시나리오

2. **@Async로 비동기 메서드 구현하기**
   - @EnableAsync 설정
   - 비동기 메서드의 반환 타입 (void, Future, CompletableFuture)

3. **TaskExecutor 설정하여 스레드 풀 관리하기**
   - ThreadPoolTaskExecutor 커스터마이징
   - 스레드 풀 크기 조정 전략

4. **@Scheduled로 정기 작업 스케줄링하기**
   - @EnableScheduling 설정
   - cron, fixedDelay, fixedRate 표현식

5. **비동기/스케줄링 예외 처리 전략 수립하기**
   - AsyncUncaughtExceptionHandler 구현
   - 스케줄링 작업의 에러 핸들링

---

## 실생활 비유로 이해하기

### 1. 레스토랑 주문 시스템 (비동기 처리)

**동기 방식의 레스토랑 (Before)**
```
고객1 주문 → 요리 완료까지 대기(30분) → 서빙 → 고객2 주문 받기
└─ 한 번에 한 명만 처리, 다른 고객들은 계속 기다림
```

**비동기 방식의 레스토랑 (After)**
```
고객1 주문 → 주방에 전달 → 즉시 고객2 주문 → 주방에 전달 → 고객3...
             └─ 백그라운드에서 요리 진행
             └─ 요리 완료되면 알림 (Future/CompletableFuture)
```

**Spring 코드**
```java
// 동기 방식 (Synchronous)
public class SyncRestaurant {
    public void processOrder(Order order) {
        cook(order);      // 30분 대기 - 다음 주문 받을 수 없음
        serve(order);
    }
}

// 비동기 방식 (Asynchronous)
@Service
public class AsyncRestaurant {

    @Async  // 즉시 반환, 백그라운드에서 실행
    public CompletableFuture<Meal> processOrder(Order order) {
        Meal meal = cook(order);  // 다른 스레드에서 실행
        serve(meal);
        return CompletableFuture.completedFuture(meal);
    }
}
```

**왜 필요한가?**
- 고객 대기 시간 감소 (응답성 향상)
- 동시에 여러 주문 처리 가능 (처리량 증가)
- 서버 자원 효율적 활용

---

### 2. 청소 서비스 스케줄러 (@Scheduled)

**실생활 시나리오**
```
매일 오전 9시: 사무실 청소 시작
매주 금요일: 대청소
매 30분마다: 화장실 점검
```

**Spring 코드**
```java
@Component
@EnableScheduling
public class CleaningScheduler {

    // 매일 오전 9시
    @Scheduled(cron = "0 0 9 * * *")
    public void dailyCleaning() {
        log.info("일일 청소 시작");
        cleanOffice();
    }

    // 매주 금요일 오후 6시
    @Scheduled(cron = "0 0 18 * * FRI")
    public void weeklyDeepCleaning() {
        log.info("주간 대청소 시작");
        deepClean();
    }

    // 30분마다 실행
    @Scheduled(fixedRate = 30 * 60 * 1000)
    public void bathroomCheck() {
        log.info("화장실 점검");
        checkBathroom();
    }
}
```

**실무 적용**
- **정기 배치 작업**: 매일 자정 데이터 백업
- **헬스 체크**: 매 1분마다 외부 API 상태 확인
- **리포트 생성**: 매주 월요일 주간 리포트 자동 생성

---

### 3. 택배 배송 시스템 (Future vs CompletableFuture)

**Future - 단순 영수증**
```
고객: "택배 보냈나요?"
직원: "네, 영수증 드릴게요. (Future 객체)"
고객: "배송 완료됐나요?"
     └─ future.get() 호출 → 완료될 때까지 대기 (블로킹)
```

**CompletableFuture - 스마트 추적 시스템**
```
고객: "택배 보냈나요?"
직원: "네, 추적번호 드릴게요. (CompletableFuture)"
      └─ 배송 완료되면 자동으로 SMS 알림
      └─ 추가 작업 체이닝 가능
```

**Spring 코드**
```java
@Service
public class DeliveryService {

    // Future - 기본 버전
    @Async
    public Future<DeliveryResult> deliverWithFuture(Package pkg) {
        DeliveryResult result = deliver(pkg);
        return new AsyncResult<>(result);
    }

    // CompletableFuture - 고급 버전
    @Async
    public CompletableFuture<DeliveryResult> deliverWithCallback(Package pkg) {
        return CompletableFuture
            .supplyAsync(() -> deliver(pkg))
            .thenApply(result -> {
                sendSMS(result);  // 완료 후 SMS 전송
                return result;
            })
            .exceptionally(ex -> {
                log.error("배송 실패: {}", ex.getMessage());
                return DeliveryResult.failed();
            });
    }
}

// 사용 예시
CompletableFuture<DeliveryResult> future = deliveryService.deliverWithCallback(pkg);

// 논블로킹 - 즉시 다음 작업 가능
future.thenAccept(result -> {
    log.info("배송 완료: {}", result);
    updateInventory();
});
```

---

### 4. 커피숍 직원 관리 (ThreadPoolTaskExecutor)

**커피숍 운영 시나리오**
```
바쁜 시간 (오전 8-9시): 바리스타 10명 투입
한가한 시간 (오후 3-4시): 바리스타 2명만 근무
대기 고객이 너무 많으면: 주문 거부 (RejectedExecutionHandler)
```

**Spring 설정**
```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    @Bean(name = "taskExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // 기본 바리스타 수 (최소 스레드)
        executor.setCorePoolSize(2);

        // 최대 바리스타 수 (최대 스레드)
        executor.setMaxPoolSize(10);

        // 대기 가능한 주문 수 (큐 용량)
        executor.setQueueCapacity(100);

        // 바리스타 이름 (스레드 이름)
        executor.setThreadNamePrefix("Barista-");

        // 대기열 초과 시 정책
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()  // 요청자가 직접 처리
        );

        executor.initialize();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> {
            log.error("비동기 작업 실패: {}", method.getName(), ex);
            // 슬랙 알림, 관리자 이메일 등
        };
    }
}
```

**실무 튜닝**
```
corePoolSize: CPU 코어 수 * 2
maxPoolSize: 예상 최대 동시 요청 수
queueCapacity: maxPoolSize * 10

예시)
- CPU 4코어 서버
- 평균 50 req/sec, 피크 200 req/sec
- 각 요청 처리 시간 1초

설정:
corePoolSize = 8 (4 * 2)
maxPoolSize = 200
queueCapacity = 2000
```

---

### 5. 지하철 운행 스케줄 (fixedDelay vs fixedRate)

**fixedRate - 정시 출발 (시작 시간 기준)**
```
06:00:00 - 지하철 출발 → 운행 시간 5분 → 06:05:00 도착
06:10:00 - 지하철 출발 (정확히 10분 간격)
06:20:00 - 지하철 출발
└─ 운행 시간과 무관하게 정확한 간격 유지
```

**fixedDelay - 휴식 보장 (종료 시간 기준)**
```
06:00:00 - 청소 시작 → 20분 소요 → 06:20:00 완료
           └─ 10분 대기 (fixedDelay)
06:30:00 - 청소 시작
           └─ 이전 작업 완료 후 정확히 10분 후 시작
```

**Spring 코드**
```java
@Component
public class TransportScheduler {

    // fixedRate: 10초마다 정확히 실행 (작업 시간 무관)
    @Scheduled(fixedRate = 10000)
    public void checkTrainStatus() {
        log.info("열차 상태 체크 시작: {}", LocalDateTime.now());
        // 5초 소요
        Thread.sleep(5000);
        log.info("열차 상태 체크 완료");
        // 완료 후 5초 뒤 다음 실행 (10초 - 5초 = 5초)
    }

    // fixedDelay: 작업 완료 후 10초 대기
    @Scheduled(fixedDelay = 10000)
    public void cleanStation() {
        log.info("역 청소 시작: {}", LocalDateTime.now());
        // 20초 소요
        Thread.sleep(20000);
        log.info("역 청소 완료");
        // 완료 후 정확히 10초 뒤 다음 실행 (총 30초 간격)
    }

    // initialDelay: 애플리케이션 시작 후 1분 뒤 시작
    @Scheduled(initialDelay = 60000, fixedRate = 10000)
    public void lateStart() {
        log.info("늦은 시작 작업");
    }
}
```

**실행 타이밍**
```
[fixedRate = 10초]
00:00 시작 → 00:05 완료 (5초 소요)
00:10 시작 → 00:15 완료 (5초 소요)
00:20 시작 → 00:25 완료
└─ 시작 시간 기준 정확히 10초 간격

[fixedDelay = 10초]
00:00 시작 → 00:05 완료 (5초 소요) → 10초 대기
00:15 시작 → 00:20 완료 (5초 소요) → 10초 대기
00:30 시작 → 00:35 완료
└─ 완료 후 10초 대기, 실제 간격은 15초 (5초 작업 + 10초 대기)
```

---

## 핵심 개념

### 1. @Async - 비동기 메서드 실행

**기본 사용법**

```java
@Configuration
@EnableAsync  // 비동기 처리 활성화
public class AppConfig {
}

@Service
public class EmailService {

    // 1. 반환값 없는 비동기 메서드
    @Async
    public void sendSimpleEmail(String to, String subject) {
        log.info("이메일 전송 시작: {} - Thread: {}",
            to, Thread.currentThread().getName());

        // 시간이 오래 걸리는 작업
        emailClient.send(to, subject);

        log.info("이메일 전송 완료: {}", to);
    }

    // 2. Future로 결과 반환
    @Async
    public Future<EmailResult> sendWithFuture(String to) {
        EmailResult result = emailClient.send(to);
        return new AsyncResult<>(result);  // Spring의 Future 구현
    }

    // 3. CompletableFuture로 결과 반환 (권장)
    @Async
    public CompletableFuture<EmailResult> sendWithCompletableFuture(String to) {
        EmailResult result = emailClient.send(to);
        return CompletableFuture.completedFuture(result);
    }
}
```

**호출 방법**
```java
@RestController
public class EmailController {

    @Autowired
    private EmailService emailService;

    @PostMapping("/send")
    public ResponseEntity<String> sendEmail(@RequestBody EmailRequest request) {

        // 1. void - Fire and Forget (가장 간단)
        emailService.sendSimpleEmail(request.getTo(), request.getSubject());
        return ResponseEntity.ok("이메일 전송 요청됨 (비동기)");
        // 즉시 응답 반환, 이메일은 백그라운드에서 전송

        // 2. Future - 결과 기다리기 (블로킹)
        Future<EmailResult> future = emailService.sendWithFuture(request.getTo());
        try {
            EmailResult result = future.get(5, TimeUnit.SECONDS);  // 최대 5초 대기
            return ResponseEntity.ok("전송 성공: " + result);
        } catch (TimeoutException e) {
            return ResponseEntity.status(408).body("타임아웃");
        }

        // 3. CompletableFuture - 논블로킹 체이닝 (권장)
        CompletableFuture<EmailResult> cf = emailService.sendWithCompletableFuture(request.getTo());

        cf.thenAccept(result -> {
            log.info("전송 완료: {}", result);
            notificationService.sendSuccessAlert(result);
        }).exceptionally(ex -> {
            log.error("전송 실패", ex);
            notificationService.sendFailureAlert(ex);
            return null;
        });

        return ResponseEntity.accepted().body("전송 중...");
    }
}
```

**@Async 동작 원리**

```
[일반 메서드 호출]
Controller → Service.method() → 메서드 실행 → 완료 후 반환
             └─────────────────────┘
                  5초 대기 (동기)

[@Async 메서드 호출]
Controller → Proxy.method() ────→ 즉시 반환 (0.1초)
                  └─→ TaskExecutor → 스레드 풀에서 실행 (5초, 백그라운드)
```

**프록시 기반 동작**
```java
// 실제 생성되는 프록시 코드 (개념적 표현)
public class EmailServiceProxy extends EmailService {

    private TaskExecutor executor;

    @Override
    public void sendSimpleEmail(String to, String subject) {
        // 비동기 실행
        executor.execute(() -> {
            super.sendSimpleEmail(to, subject);
        });
        // 즉시 반환
    }
}
```

---

### 2. TaskExecutor 설정과 스레드 풀 관리

**ThreadPoolTaskExecutor 상세 설정**

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean(name = "emailExecutor")
    public Executor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // 1. 기본 스레드 수 (항상 유지)
        executor.setCorePoolSize(5);
        // └─ 초기에 5개 스레드 생성하고 항상 유지

        // 2. 최대 스레드 수
        executor.setMaxPoolSize(20);
        // └─ 큐가 가득 차면 최대 20개까지 스레드 증가

        // 3. 큐 용량 (대기 작업 수)
        executor.setQueueCapacity(100);
        // └─ 5개 스레드가 모두 사용 중이면 100개까지 큐에 대기

        // 4. 유휴 스레드 유지 시간
        executor.setKeepAliveSeconds(60);
        // └─ corePoolSize 초과 스레드는 60초 유휴 시 제거

        // 5. 스레드 이름 접두사
        executor.setThreadNamePrefix("Email-");

        // 6. 대기열 초과 시 정책
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );

        // 7. 우아한 종료 설정
        executor.setWaitForTasksToCompleteOnShutdown(true);  // 종료 시 작업 완료 대기
        executor.setAwaitTerminationSeconds(30);  // 최대 30초 대기

        executor.initialize();
        return executor;
    }

    // 여러 Executor 사용
    @Bean(name = "reportExecutor")
    public Executor reportExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);  // 리포트는 빈도가 낮음
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("Report-");
        executor.initialize();
        return executor;
    }
}
```

**Executor 지정하여 사용**

```java
@Service
public class NotificationService {

    // emailExecutor 사용
    @Async("emailExecutor")
    public void sendEmail(String to) {
        // Email- 스레드에서 실행
        log.info("Email 전송: Thread={}", Thread.currentThread().getName());
    }

    // reportExecutor 사용
    @Async("reportExecutor")
    public void generateReport(ReportRequest request) {
        // Report- 스레드에서 실행
        log.info("리포트 생성: Thread={}", Thread.currentThread().getName());
    }
}
```

**RejectedExecutionHandler 정책**

```java
// 1. CallerRunsPolicy (기본 권장)
// - 큐가 가득 차면 호출한 스레드에서 직접 실행
// - 시스템 과부하 시 자동으로 처리 속도 조절
new ThreadPoolExecutor.CallerRunsPolicy();

// 2. AbortPolicy (기본값)
// - 큐가 가득 차면 RejectedExecutionException 던짐
new ThreadPoolExecutor.AbortPolicy();

// 3. DiscardPolicy
// - 큐가 가득 차면 조용히 버림 (로그 없음)
new ThreadPoolExecutor.DiscardPolicy();

// 4. DiscardOldestPolicy
// - 가장 오래된 작업을 버리고 새 작업 추가
new ThreadPoolExecutor.DiscardOldestPolicy();

// 5. 커스텀 정책
executor.setRejectedExecutionHandler((runnable, executor) -> {
    log.error("작업 거부됨: Queue={}, Active={}",
        executor.getQueue().size(),
        executor.getActiveCount());

    // 메트릭 기록
    metrics.incrementRejectedTasks();

    // 알림 전송
    alertService.sendAlert("ThreadPool 포화");
});
```

**스레드 풀 작동 순서**

```
작업 도착 시 처리 순서:

1단계: corePoolSize보다 적은 스레드가 있는가?
       YES → 새 스레드 생성하여 즉시 실행
       NO  → 2단계

2단계: 큐에 빈 공간이 있는가?
       YES → 큐에 추가 (대기)
       NO  → 3단계

3단계: maxPoolSize보다 적은 스레드가 있는가?
       YES → 새 스레드 생성하여 즉시 실행
       NO  → 4단계

4단계: RejectedExecutionHandler 실행
       (CallerRunsPolicy, AbortPolicy 등)

예시:
corePoolSize=5, maxPoolSize=10, queueCapacity=100

작업 1-5개: 즉시 5개 스레드 생성하여 실행
작업 6-105개: 큐에 100개 대기
작업 106-110개: 추가 5개 스레드 생성 (총 10개)
작업 111개 이상: RejectedExecutionHandler 호출
```

---

### 3. @Scheduled - 정기 작업 스케줄링

**기본 사용법**

```java
@Configuration
@EnableScheduling  // 스케줄링 활성화
public class AppConfig {
}

@Component
public class ScheduledTasks {

    // 1. fixedRate - 시작 시간 기준 고정 간격
    @Scheduled(fixedRate = 5000)  // 5초마다
    public void fixedRateTask() {
        log.info("FixedRate 작업 실행: {}", LocalDateTime.now());
    }

    // 2. fixedDelay - 종료 후 고정 간격
    @Scheduled(fixedDelay = 5000)
    public void fixedDelayTask() {
        log.info("FixedDelay 작업 실행: {}", LocalDateTime.now());
    }

    // 3. initialDelay - 최초 지연
    @Scheduled(initialDelay = 10000, fixedRate = 5000)
    public void initialDelayTask() {
        log.info("10초 후 시작, 이후 5초마다 실행");
    }

    // 4. cron - 복잡한 스케줄
    @Scheduled(cron = "0 0 9 * * MON-FRI")  // 평일 오전 9시
    public void cronTask() {
        log.info("평일 오전 9시 작업 실행");
    }
}
```

**Cron 표현식 상세**

```
 ┌───────────── 초 (0-59)
 │ ┌───────────── 분 (0-59)
 │ │ ┌───────────── 시 (0-23)
 │ │ │ ┌───────────── 일 (1-31)
 │ │ │ │ ┌───────────── 월 (1-12 또는 JAN-DEC)
 │ │ │ │ │ ┌───────────── 요일 (0-7 또는 SUN-SAT, 0과 7은 일요일)
 │ │ │ │ │ │
 * * * * * *

특수 문자:
* : 모든 값
? : 특정 값 없음 (일, 요일 중 하나만 지정 시 다른 쪽에 사용)
- : 범위 (예: 10-12)
, : 여러 값 (예: MON,WED,FRI)
/ : 증분 (예: 0/15 = 0,15,30,45)
L : 마지막 (일: 월의 마지막 날, 요일: 그 달의 마지막 특정 요일)
W : 평일 (가장 가까운 평일)
# : N번째 요일 (예: 5#3 = 3번째 금요일)

예시:
"0 0 * * * *"        → 매시 정각
"*/10 * * * * *"     → 10초마다
"0 0 8-10 * * *"     → 매일 8시, 9시, 10시
"0 0 9 * * MON-FRI"  → 평일 오전 9시
"0 0 0 1 * *"        → 매월 1일 자정
"0 0 0 L * *"        → 매월 마지막 날 자정
"0 0 9 ? * 2#1"      → 매월 첫 번째 월요일 9시
```

**실무 스케줄링 예시**

```java
@Component
public class BusinessScheduler {

    // 매일 자정 - 일일 통계 집계
    @Scheduled(cron = "0 0 0 * * *")
    public void dailyStatistics() {
        log.info("일일 통계 집계 시작");
        statisticsService.aggregateDailyData();
    }

    // 매주 월요일 오전 9시 - 주간 리포트
    @Scheduled(cron = "0 0 9 * * MON")
    public void weeklyReport() {
        log.info("주간 리포트 생성");
        reportService.generateWeeklyReport();
    }

    // 매월 1일 오전 1시 - 월간 정산
    @Scheduled(cron = "0 0 1 1 * *")
    public void monthlySettlement() {
        log.info("월간 정산 시작");
        settlementService.processMonthlySettlement();
    }

    // 평일 오전 8시 - 재고 알림
    @Scheduled(cron = "0 0 8 * * MON-FRI")
    public void inventoryAlert() {
        log.info("재고 부족 알림 확인");
        inventoryService.checkLowStock();
    }

    // 매 15분마다 - 헬스 체크
    @Scheduled(cron = "0 */15 * * * *")
    public void healthCheck() {
        log.info("시스템 헬스 체크");
        healthService.checkAllServices();
    }

    // 영업 시간에만 실행 (9시-18시, 매 1시간)
    @Scheduled(cron = "0 0 9-18 * * MON-FRI")
    public void businessHoursTask() {
        log.info("영업 시간 작업");
        businessService.processDuringBusinessHours();
    }
}
```

**TaskScheduler 커스터마이징**

```java
@Configuration
@EnableScheduling
public class SchedulingConfig implements SchedulingConfigurer {

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        // 스케줄러 스레드 풀 설정
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();

        scheduler.setPoolSize(10);  // 동시 실행 가능한 스케줄 작업 수
        scheduler.setThreadNamePrefix("Scheduled-");
        scheduler.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());

        scheduler.initialize();
        taskRegistrar.setTaskScheduler(scheduler);
    }
}
```

---

### 4. 예외 처리 전략

**비동기 메서드 예외 처리**

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new CustomAsyncExceptionHandler();
    }
}

// 커스텀 예외 핸들러
public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        log.error("=== 비동기 작업 예외 발생 ===");
        log.error("예외 메시지: {}", ex.getMessage());
        log.error("메서드: {}", method.getName());

        for (int i = 0; i < params.length; i++) {
            log.error("파라미터[{}]: {}", i, params[i]);
        }

        // 실무 처리
        // 1. 슬랙/이메일 알림
        notificationService.sendAlert(
            String.format("비동기 작업 실패: %s", method.getName()),
            ex
        );

        // 2. 메트릭 기록
        metricsService.incrementAsyncFailure(method.getName());

        // 3. 재시도 큐에 추가
        retryService.addToRetryQueue(method, params);
    }
}
```

**스케줄링 작업 예외 처리**

```java
@Component
public class RobustScheduler {

    @Scheduled(fixedRate = 60000)
    public void scheduledTaskWithErrorHandling() {
        try {
            // 실제 작업
            riskyOperation();

        } catch (Exception e) {
            log.error("스케줄 작업 실패", e);

            // 예외 삼켜서 다음 실행 보장
            // (예외 던지면 다음 스케줄 실행 안 될 수 있음)

            // 알림 전송
            alertService.sendAlert("스케줄 작업 실패: " + e.getMessage());

            // 메트릭 기록
            metrics.recordScheduledTaskFailure();
        }
    }

    @Scheduled(cron = "0 0 0 * * *")
    public void criticalDailyTask() {
        int retryCount = 0;
        int maxRetries = 3;

        while (retryCount < maxRetries) {
            try {
                criticalOperation();
                log.info("작업 성공");
                return;

            } catch (Exception e) {
                retryCount++;
                log.error("작업 실패 (시도 {}/{})", retryCount, maxRetries, e);

                if (retryCount >= maxRetries) {
                    // 최종 실패 - 관리자 알림
                    emergencyAlert.send("일일 작업 최종 실패", e);
                } else {
                    // 재시도 전 대기
                    Thread.sleep(5000 * retryCount);  // 지수 백오프
                }
            }
        }
    }
}
```

---

### 5. @Async 제약사항과 해결방법

**1. 같은 클래스 내부 호출 시 동작하지 않음**

```java
// ❌ 동작하지 않는 예
@Service
public class BadService {

    public void publicMethod() {
        asyncMethod();  // 프록시를 거치지 않음 - 동기 실행됨!
    }

    @Async
    public void asyncMethod() {
        // 비동기로 실행 안 됨
    }
}

// ✅ 해결 방법 1: 다른 Bean으로 분리
@Service
public class GoodService {

    @Autowired
    private AsyncWorker asyncWorker;

    public void publicMethod() {
        asyncWorker.asyncMethod();  // 프록시 거침 - 비동기 실행됨!
    }
}

@Component
class AsyncWorker {
    @Async
    public void asyncMethod() {
        // 비동기로 실행됨
    }
}

// ✅ 해결 방법 2: self-injection
@Service
public class SelfInjectService {

    @Autowired
    private SelfInjectService self;  // 자기 자신 주입 (프록시)

    public void publicMethod() {
        self.asyncMethod();  // 프록시 거침 - 비동기 실행됨!
    }

    @Async
    public void asyncMethod() {
        // 비동기로 실행됨
    }
}
```

**2. private 메서드는 @Async 불가**

```java
// ❌ 동작하지 않음
@Service
public class BadService {
    @Async
    private void privateAsync() {  // private은 프록시 불가
        // 비동기 실행 안 됨
    }
}

// ✅ public/protected로 변경
@Service
public class GoodService {
    @Async
    public void publicAsync() {  // public 메서드여야 함
        // 비동기 실행됨
    }
}
```

**3. 반환 타입 제약**

```java
// ❌ 일반 객체 반환 불가
@Async
public String badMethod() {  // String 반환 - 값 받을 수 없음
    return "result";
}

// ✅ void, Future, CompletableFuture만 가능
@Async
public void voidMethod() { }  // OK

@Async
public Future<String> futureMethod() {
    return new AsyncResult<>("result");  // OK
}

@Async
public CompletableFuture<String> cfMethod() {
    return CompletableFuture.completedFuture("result");  // OK (권장)
}
```

---

## 다음 Part에서 배울 내용

Part 2에서는 다음을 학습합니다:

1. **실습**: 이메일 전송, 리포트 생성 비동기 처리
2. **실무 사례**: 대용량 데이터 처리, 배치 작업 최적화
3. **성능 튜닝**: ThreadPool 크기 계산, 모니터링 방법
4. **FAQ**: @Async가 동작하지 않는 이유, 스케줄 중복 실행 방지
5. **면접 질문**: 비동기 처리의 장단점, fixedRate vs fixedDelay 차이

---

**학습 체크리스트**

- [ ] @EnableAsync와 @Async의 관계 이해
- [ ] Future vs CompletableFuture 차이 설명 가능
- [ ] ThreadPoolTaskExecutor 파라미터 이해 (corePoolSize, maxPoolSize, queueCapacity)
- [ ] @Scheduled의 cron 표현식 작성 가능
- [ ] fixedRate vs fixedDelay 차이 이해
- [ ] 비동기 메서드의 예외 처리 방법 숙지
- [ ] @Async가 동작하지 않는 경우(self-invocation) 이해

Part 2에서 실습과 면접 질문으로 마스터해봅시다!
