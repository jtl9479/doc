# 04장: DI (Dependency Injection) - 의존성 주입

> **학습 목표**: 이 장을 완료하면 Spring의 의존성 주입(DI) 방식을 완벽히 이해하고, 생성자/Setter/필드 주입의 차이를 실무에 적용할 수 있습니다.

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐☆☆ (3개/5개)

---

## 📚 목차
- [왜 이 기술이 필요한가](#왜-이-기술이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [핵심 개념](#핵심-개념)
- [기본 실습](#기본-실습)
- [실무 활용 사례](#실무-활용-사례)
- [주니어 시나리오](#주니어-시나리오)
- [실전 프로젝트](#실전-프로젝트)
- [FAQ](#faq)
- [면접 질문 리스트](#면접-질문-리스트)
- [핵심 정리](#핵심-정리)
- [면접 질문 리스트 답안](#면접-질문-리스트-답안)

---

## 🤔 왜 이 기술이 필요한가?

### 실무 배경
**온라인 쇼핑몰에서 결제 시스템을 개발하는데, 신용카드, 계좌이체, 간편결제 등 다양한 결제 수단을 지원해야 한다. 각 결제 수단이 직접 코드에 박혀있다면?**

#### ❌ 이 기술을 모르면 발생하는 문제

```
문제 1: 강한 결합(Tight Coupling)
- 증상: OrderService가 TossPayment를 직접 new로 생성
- 영향: 결제사 변경 시 OrderService 코드 수정 필수
- 비용: 코드 변경 → 재컴파일 → 재배포 (2시간 소요)

문제 2: 테스트 불가능
- 증상: 실제 결제 API를 호출해야만 테스트 가능
- 영향: 테스트 시 실제 결제 발생, 환불 처리 필요
- 비용: 테스트 비용 월 50만원, 개발 속도 50% 감소

문제 3: 코드 재사용성 저하
- 증상: 결제 로직이 OrderService에 하드코딩
- 영향: 구독 서비스, 예약 서비스에서 중복 코드 작성
- 비용: 중복 코드 유지보수에 개발 시간 30% 낭비
```

#### ✅ 이 기술을 사용하면

```
해결책 1: 느슨한 결합(Loose Coupling)
- 방법: PaymentGateway 인터페이스 + DI로 구현체 주입
- 효과: 결제사 변경 시 설정만 수정, 코드 변경 불필요
- 절감: 배포 시간 2시간 → 1분, 개발 생산성 200% 향상

해결책 2: 테스트 용이성
- 방법: Mock PaymentGateway 주입으로 실제 API 호출 없이 테스트
- 효과: 테스트 실행 시간 10분 → 5초, 실제 결제 없음
- 절감: 테스트 비용 월 50만원 → 0원

해결책 3: 코드 재사용성 극대화
- 방법: PaymentService를 여러 서비스에서 DI로 주입
- 효과: 중복 코드 제거, 단일 책임 원칙 준수
- 절감: 유지보수 시간 30% 절감, 버그 발생률 60% 감소
```

### 📊 수치로 보는 효과

| 지표 | Before (직접 생성) | After (DI) | 개선율 |
|------|-------------------|------------|--------|
| 결합도 | 높음 (10점) | 낮음 (2점) | **80%↓** |
| 테스트 시간 | 10분 | 5초 | **99%↓** |
| 코드 재사용 | 30% | 90% | **200%↑** |
| 배포 시간 | 2시간 | 1분 | **99%↓** |
| 테스트 비용 | 월 50만원 | 0원 | **100%↓** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 자동차와 엔진

```
전통적 방식 (DI 없이) = 자동차에 엔진 용접
- 자동차 제조 시 특정 엔진을 용접으로 고정
- 엔진 고장 시 자동차 전체 폐기
- 엔진 업그레이드 불가능
- 다른 엔진으로 교체하려면 차체 분해

DI 방식 = 자동차에 엔진 장착
- 엔진을 외부에서 장착
- 엔진 고장 시 엔진만 교체
- 더 좋은 엔진으로 업그레이드 가능
- 전기 엔진으로도 쉽게 교체

┌─────────────────────────────────┐
│     전통적 (용접)                │
│  [자동차 ← 엔진 (용접)]          │
│  → 엔진 교체 불가능              │
│  → 차체 분해 필요                │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│     DI (장착)                    │
│  [자동차] ← [엔진] (끼워 넣기)   │
│  → 엔진 교체 가능                │
│  → 전기/휘발유 모두 가능         │
└─────────────────────────────────┘

코드 매핑:
자동차 = Service
엔진 = 의존성 (Repository, API Client 등)
장착 = Dependency Injection
```

### 비유 2: 스마트폰과 충전기

```
DI 없이 = 스마트폰에 충전기 내장
- 충전기 고장 시 스마트폰 전체 수리
- 고속 충전기로 업그레이드 불가
- 여행 시 다른 충전기 사용 불가

DI 사용 = USB-C 포트로 연결
- 충전기 고장 시 충전기만 교체
- 고속/무선/보조배터리 자유롭게 교체
- 표준 인터페이스로 호환성 확보

┌──────────────────────────────┐
│  스마트폰 (내장 충전기)       │
│  ┌──────────────────────┐    │
│  │ 스마트폰             │    │
│  │  └─ 충전기 (내장)    │    │
│  └──────────────────────┘    │
│  → 충전기 교체 불가           │
└──────────────────────────────┘

┌──────────────────────────────┐
│  스마트폰 (USB-C 포트)        │
│  ┌──────────────┐            │
│  │ 스마트폰     │ ← 충전기   │
│  │  [USB-C 포트]│            │
│  └──────────────┘            │
│  → 충전기 자유롭게 교체       │
└──────────────────────────────┘

실제 코드 매핑:
스마트폰 = OrderService
USB-C 포트 = 인터페이스 (PaymentGateway)
충전기 = 구현체 (TossPayment, NaverPay)
연결 = @Autowired
```

### 비유 3: 레고 블록

```
DI 없이 = 접착제로 고정
- 한 번 붙이면 떼어낼 수 없음
- 다른 조합 시도 불가
- 실수하면 처음부터 다시

DI 사용 = 레고 블록 조립
- 쉽게 붙이고 떼어내기
- 다양한 조합 시도 가능
- 언제든지 재구성

┌────────────────────────────┐
│    접착제 (DI 없이)         │
│  [블록A-블록B-블록C] (고정) │
│  → 분리 불가능              │
└────────────────────────────┘

┌────────────────────────────┐
│    레고 (DI)               │
│  [블록A]-[블록B]-[블록C]   │
│  → 자유롭게 조립/분리       │
│  → 다른 블록으로 교체 가능  │
└────────────────────────────┘

매핑:
레고 블록 = Bean
돌기/홈 = 인터페이스
조립 = Dependency Injection
```

### 비유 4: 음식점 주방

```
DI 없이 = 모든 요리를 직접
- 쉐프가 재료 구매, 손질, 조리 모두 담당
- 재료 공급처 변경 시 전체 프로세스 변경
- 쉐프 없으면 식당 운영 불가

DI 사용 = 재료는 납품, 조리만 집중
- 재료는 납품업체가 공급
- 쉐프는 조리에만 집중
- 납품업체 변경 시 조리법은 그대로

┌─────────────────────────────┐
│   쉐프가 모든 것 직접        │
│                             │
│  쉐프 → [재료 구매]         │
│       → [재료 손질]         │
│       → [조리]              │
│  → 모든 과정에 의존         │
└─────────────────────────────┘

┌─────────────────────────────┐
│   재료 납품 (DI)            │
│                             │
│  납품업체 → [재료 공급]     │
│         ↓                   │
│  쉐프 → [조리]              │
│  → 조리에만 집중            │
└─────────────────────────────┘

매핑:
쉐프 = Service
재료 = 의존성
납품 = Dependency Injection
조리법 = 비즈니스 로직
```

### 비유 5: 회사 조직

```
DI 없이 = 직원이 모든 부서 일 직접
- 개발자가 채용, 재무, 법무까지 전부 처리
- 전문성 부족, 효율성 저하
- 한 사람이 쉬면 모든 일 중단

DI 사용 = 각 부서에 업무 위임
- 개발자는 개발만
- 채용은 인사팀, 재무는 회계팀
- 전문성과 효율성 향상

┌──────────────────────────────┐
│    1인 기업 (DI 없이)         │
│                              │
│  직원 → 개발                 │
│       → 채용                 │
│       → 회계                 │
│       → 법무                 │
│  → 모든 일을 혼자            │
└──────────────────────────────┘

┌──────────────────────────────┐
│    조직화된 회사 (DI)         │
│                              │
│  개발팀 → 개발               │
│  인사팀 → 채용               │
│  회계팀 → 재무               │
│  법무팀 → 계약               │
│  → 각자 전문 분야에 집중     │
└──────────────────────────────┘

매핑:
직원 = Service
부서 = 의존성 (Repository, Client 등)
위임 = Dependency Injection
```

### 🎯 종합 비교표

```
┌──────────────┬────────────┬────────────┬────────────┐
│ DI 개념      │ 자동차     │ 스마트폰   │ 레고       │
├──────────────┼────────────┼────────────┼────────────┤
│ 의존 객체    │ 엔진       │ 충전기     │ 블록       │
│ 인터페이스   │ 장착구     │ USB-C      │ 돌기/홈    │
│ 주입 방식    │ 끼워 넣기  │ 연결       │ 조립       │
│ 교체 용이성  │ 높음       │ 높음       │ 높음       │
│ 결합도       │ 낮음       │ 낮음       │ 낮음       │
└──────────────┴────────────┴────────────┴────────────┘

┌──────────────┬────────────┬────────────┬────────────┐
│ 개발 관점    │ 직접 생성  │ DI 방식    │ 효과       │
├──────────────┼────────────┼────────────┼────────────┤
│ 객체 생성    │ new 직접   │ @Autowired │ 자동화     │
│ 결합도       │ 높음       │ 낮음       │ 유연성     │
│ 테스트       │ 어려움     │ 쉬움       │ Mock 가능  │
│ 교체 비용    │ 높음       │ 낮음       │ 시간 절약  │
│ 재사용성     │ 낮음       │ 높음       │ 생산성↑    │
└──────────────┴────────────┴────────────┴────────────┘
```

---

**[다음: Part 2로 계속 →](04-2-DI-Part2.md)**
