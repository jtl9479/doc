# 17-2. 다형성 (Polymorphism) - Part 2

## 📋 목차
1. [기업 사례 1: YouTube 동영상 플레이어](#사례1-youtube)
2. [기업 사례 2: 배달의민족 주문 처리](#사례2-배달의민족)
3. [기업 사례 3: GitHub Actions 워크플로우](#사례3-github-actions)
4. [주니어 개발자 시나리오](#주니어-시나리오)
   - [시나리오 1: 다운캐스팅 실수](#시나리오1)
   - [시나리오 2: instanceof 미사용](#시나리오2)
   - [시나리오 3: 배열 타입 혼동](#시나리오3)
   - [시나리오 4: 부모 타입의 한계 이해 부족](#시나리오4)

---

## 🎬 기업 사례 1: YouTube 동영상 플레이어 {#사례1-youtube}

### 비즈니스 요구사항
YouTube는 일반 동영상, 쇼츠, 라이브 스트리밍, 프리미엄 콘텐츠 등 다양한 형태의 콘텐츠를 재생합니다. 플레이어는 하나지만, 콘텐츠 타입에 따라 다른 재생 방식과 기능을 제공해야 합니다.

### 다형성을 활용한 설계

```java
/**
 * 모든 YouTube 콘텐츠의 부모 클래스
 */
public abstract class YouTubeContent {
    protected String videoId;
    protected String title;
    protected String channelName;
    protected long viewCount;
    protected int likeCount;
    protected int duration;  // 초 단위

    public YouTubeContent(String videoId, String title, String channelName, int duration) {
        this.videoId = videoId;
        this.title = title;
        this.channelName = channelName;
        this.duration = duration;
        this.viewCount = 0;
        this.likeCount = 0;
    }

    // 추상 메서드 - 각 콘텐츠 타입마다 다른 재생 방식
    public abstract void play();
    public abstract void pause();
    public abstract void showControls();
    public abstract String getContentType();

    public void incrementViewCount() {
        viewCount++;
        System.out.println("조회수: " + String.format("%,d", viewCount));
    }

    public void like() {
        likeCount++;
        System.out.println("👍 좋아요 +" + likeCount);
    }

    public void showInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("제목: " + title);
        System.out.println("채널: " + channelName);
        System.out.println("조회수: " + String.format("%,d", viewCount));
        System.out.println("좋아요: " + String.format("%,d", likeCount));
        System.out.println("타입: " + getContentType());
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    protected String formatDuration(int seconds) {
        int hours = seconds / 3600;
        int minutes = (seconds % 3600) / 60;
        int secs = seconds % 60;

        if (hours > 0) {
            return String.format("%d:%02d:%02d", hours, minutes, secs);
        } else {
            return String.format("%d:%02d", minutes, secs);
        }
    }
}

/**
 * 일반 동영상
 */
public class RegularVideo extends YouTubeContent {
    private String quality;  // 1080p, 4K 등
    private boolean hasSubtitles;
    private int currentPosition;  // 현재 재생 위치 (초)

    public RegularVideo(String videoId, String title, String channelName, int duration) {
        super(videoId, title, channelName, duration);
        this.quality = "1080p";
        this.hasSubtitles = true;
        this.currentPosition = 0;
    }

    @Override
    public void play() {
        System.out.println("\n▶️ 일반 동영상 재생");
        System.out.println("제목: " + title);
        System.out.println("채널: " + channelName);
        System.out.println("화질: " + quality);
        System.out.println("길이: " + formatDuration(duration));
        System.out.println("현재 위치: " + formatDuration(currentPosition));

        if (hasSubtitles) {
            System.out.println("📝 자막 사용 가능");
        }

        incrementViewCount();
        System.out.println("✅ 재생 중...");
    }

    @Override
    public void pause() {
        System.out.println("\n⏸️ 일시 정지");
        System.out.println("위치: " + formatDuration(currentPosition));
    }

    @Override
    public void showControls() {
        System.out.println("\n🎛️ 플레이어 컨트롤");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("▶️ 재생/일시정지");
        System.out.println("⏮️ 이전 프레임");
        System.out.println("⏭️ 다음 프레임");
        System.out.println("🔊 볼륨 조절");
        System.out.println("⚙️ 화질 선택: " + quality);
        System.out.println("📝 자막 On/Off");
        System.out.println("⏩ 재생 속도");
        System.out.println("🖼️ 전체 화면");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    @Override
    public String getContentType() {
        return "일반 동영상";
    }

    public void changeQuality(String quality) {
        this.quality = quality;
        System.out.println("⚙️ 화질 변경: " + quality);
    }

    public void seek(int position) {
        this.currentPosition = Math.min(position, duration);
        System.out.println("⏩ 이동: " + formatDuration(currentPosition));
    }
}

/**
 * YouTube Shorts (세로 동영상)
 */
public class YouTubeShorts extends YouTubeContent {
    private boolean isVertical;
    private boolean autoPlayNext;

    public YouTubeShorts(String videoId, String title, String channelName, int duration) {
        super(videoId, title, channelName, duration);
        this.isVertical = true;
        this.autoPlayNext = true;

        // Shorts는 최대 60초
        if (duration > 60) {
            this.duration = 60;
        }
    }

    @Override
    public void play() {
        System.out.println("\n▶️ Shorts 재생");
        System.out.println("제목: " + title);
        System.out.println("채널: " + channelName);
        System.out.println("📱 세로 모드");
        System.out.println("길이: " + duration + "초");

        incrementViewCount();

        if (autoPlayNext) {
            System.out.println("🔄 자동 재생: 다음 Shorts 자동 재생됨");
        }

        System.out.println("✅ 재생 중...");
    }

    @Override
    public void pause() {
        System.out.println("\n⏸️ 일시 정지");
        System.out.println("화면 탭으로 재개 가능");
    }

    @Override
    public void showControls() {
        System.out.println("\n🎛️ Shorts 컨트롤");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("👍 좋아요");
        System.out.println("👎 싫어요");
        System.out.println("💬 댓글");
        System.out.println("↗️ 공유");
        System.out.println("⋮ 더보기");
        System.out.println("👆 위로 스와이프: 다음 Shorts");
        System.out.println("👇 아래로 스와이프: 이전 Shorts");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    @Override
    public String getContentType() {
        return "YouTube Shorts";
    }

    public void swipeUp() {
        System.out.println("👆 다음 Shorts로 이동");
    }

    public void swipeDown() {
        System.out.println("👇 이전 Shorts로 이동");
    }
}

/**
 * 라이브 스트리밍
 */
public class LiveStream extends YouTubeContent {
    private boolean isLive;
    private int currentViewers;
    private boolean hasSuperChat;

    public LiveStream(String videoId, String title, String channelName) {
        super(videoId, title, channelName, 0);  // 라이브는 길이 미정
        this.isLive = true;
        this.currentViewers = 0;
        this.hasSuperChat = true;
    }

    @Override
    public void play() {
        System.out.println("\n▶️ 라이브 스트리밍 재생");
        System.out.println("제목: " + title);
        System.out.println("채널: " + channelName);
        System.out.println("🔴 LIVE");
        System.out.println("👥 시청자: " + String.format("%,d", currentViewers) + "명");

        currentViewers++;
        incrementViewCount();

        if (hasSuperChat) {
            System.out.println("💰 슈퍼챗 사용 가능");
        }

        System.out.println("✅ 실시간 스트리밍 중...");
    }

    @Override
    public void pause() {
        System.out.println("\n⏸️ 버퍼링 중...");
        System.out.println("⚠️ 라이브는 일시정지 불가");
        System.out.println("잠시 후 다시 시작됩니다...");
    }

    @Override
    public void showControls() {
        System.out.println("\n🎛️ 라이브 스트리밍 컨트롤");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("💬 실시간 채팅");
        System.out.println("💰 슈퍼챗 보내기");
        System.out.println("👍 좋아요");
        System.out.println("↗️ 공유");
        System.out.println("🔔 알림 설정");
        System.out.println("🔊 볼륨 조절");
        System.out.println("🖼️ 전체 화면");
        System.out.println("⏸️ (일시정지 불가)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    @Override
    public String getContentType() {
        return "라이브 스트리밍";
    }

    public void sendSuperChat(String message, int amount) {
        System.out.println("💰 슈퍼챗: \"" + message + "\" (" + amount + "원)");
    }

    public void sendChat(String message) {
        System.out.println("💬 " + message);
    }

    public void endStream() {
        isLive = false;
        System.out.println("🔴 라이브 종료");
        System.out.println("총 시청자: " + String.format("%,d", currentViewers) + "명");
    }
}

/**
 * 프리미엄 콘텐츠
 */
public class PremiumContent extends YouTubeContent {
    private boolean requiresSubscription;
    private int price;  // 원
    private boolean downloadable;

    public PremiumContent(String videoId, String title, String channelName,
                         int duration, int price) {
        super(videoId, title, channelName, duration);
        this.requiresSubscription = true;
        this.price = price;
        this.downloadable = true;
    }

    @Override
    public void play() {
        if (!requiresSubscription) {
            System.out.println("\n▶️ 프리미엄 콘텐츠 재생");
            System.out.println("제목: " + title);
            System.out.println("채널: " + channelName);
            System.out.println("👑 프리미엄");
            System.out.println("길이: " + formatDuration(duration));
            System.out.println("💎 광고 없음");
            System.out.println("📥 오프라인 저장 가능");

            incrementViewCount();
            System.out.println("✅ 재생 중...");
        } else {
            System.out.println("\n🔒 구독 필요");
            System.out.println("이 콘텐츠는 구독자 전용입니다.");
            System.out.println("가격: " + String.format("%,d", price) + "원");
        }
    }

    @Override
    public void pause() {
        System.out.println("\n⏸️ 일시 정지");
        System.out.println("언제든 이어보기 가능");
    }

    @Override
    public void showControls() {
        System.out.println("\n🎛️ 프리미엄 플레이어 컨트롤");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("▶️ 재생/일시정지");
        System.out.println("⏮️ 이전");
        System.out.println("⏭️ 다음");
        System.out.println("🔊 볼륨");
        System.out.println("⚙️ 화질 (최대 4K)");
        System.out.println("📝 자막");
        System.out.println("⏩ 재생 속도");
        System.out.println("📥 다운로드");
        System.out.println("🎧 백그라운드 재생");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    @Override
    public String getContentType() {
        return "프리미엄 콘텐츠";
    }

    public boolean subscribe() {
        System.out.println("💳 구독 처리 중...");
        requiresSubscription = false;
        System.out.println("✅ 구독 완료! 이제 시청 가능합니다.");
        return true;
    }

    public void download() {
        if (downloadable && !requiresSubscription) {
            System.out.println("📥 다운로드 시작: " + title);
            System.out.println("화질: 1080p, 크기: 2.3GB");
        } else {
            System.out.println("❌ 다운로드 불가");
        }
    }
}
```

### YouTube 플레이어 (다형성 활용)

```java
/**
 * YouTube 플레이어 - 모든 콘텐츠 타입 재생
 */
public class YouTubePlayer {
    private YouTubeContent currentContent;
    private boolean isPlaying;

    public YouTubePlayer() {
        this.currentContent = null;
        this.isPlaying = false;
    }

    /**
     * 콘텐츠 로드 - 다형성!
     * YouTubeContent 타입으로 모든 콘텐츠 처리
     */
    public void loadContent(YouTubeContent content) {
        System.out.println("\n📺 ═══════════════════════════");
        System.out.println("   YouTube 플레이어");
        System.out.println("═══════════════════════════");

        this.currentContent = content;
        this.isPlaying = false;

        System.out.println("콘텐츠 로드 완료: " + content.getContentType());
        content.showInfo();
    }

    public void playContent() {
        if (currentContent == null) {
            System.out.println("❌ 재생할 콘텐츠가 없습니다.");
            return;
        }

        currentContent.play();  // 다형성! 각 타입에 맞게 재생
        isPlaying = true;
    }

    public void pauseContent() {
        if (currentContent == null || !isPlaying) {
            System.out.println("❌ 재생 중인 콘텐츠가 없습니다.");
            return;
        }

        currentContent.pause();  // 다형성!
        isPlaying = false;
    }

    public void showPlayerControls() {
        if (currentContent == null) {
            System.out.println("❌ 로드된 콘텐츠가 없습니다.");
            return;
        }

        currentContent.showControls();  // 다형성! 각 타입에 맞는 컨트롤 표시
    }

    public void likeContent() {
        if (currentContent != null) {
            currentContent.like();
        }
    }

    /**
     * 추천 알고리즘 - 다형성을 활용한 타입별 처리
     */
    public void recommendNext(YouTubeContent[] recommendations) {
        System.out.println("\n🎯 추천 콘텐츠");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        for (YouTubeContent content : recommendations) {
            System.out.println("\n[" + content.getContentType() + "]");
            System.out.println("제목: " + content.title);
            System.out.println("채널: " + content.channelName);

            // 타입별 특별 정보
            if (content instanceof RegularVideo) {
                System.out.println("길이: " + content.formatDuration(content.duration));
            } else if (content instanceof YouTubeShorts) {
                System.out.println("📱 Shorts - " + content.duration + "초");
            } else if (content instanceof LiveStream) {
                System.out.println("🔴 지금 LIVE");
            } else if (content instanceof PremiumContent) {
                System.out.println("👑 프리미엄");
            }
        }
    }
}
```

### 실행 테스트

```java
public class YouTubePlayerTest {
    public static void main(String[] args) {
        System.out.println("📺 ═══════════════════════════════");
        System.out.println("   YouTube 플레이어 시스템");
        System.out.println("═══════════════════════════════\n");

        // 플레이어 생성
        YouTubePlayer player = new YouTubePlayer();

        // 다양한 콘텐츠 생성
        RegularVideo regularVideo = new RegularVideo(
            "dQw4w9WgXcQ",
            "Rick Astley - Never Gonna Give You Up",
            "Rick Astley",
            212
        );

        YouTubeShorts shorts = new YouTubeShorts(
            "shorts123",
            "고양이가 점프하는 순간",
            "펫튜버",
            45
        );

        LiveStream liveStream = new LiveStream(
            "live456",
            "🔴 실시간 게임 방송",
            "게임 스트리머"
        );

        PremiumContent premiumContent = new PremiumContent(
            "premium789",
            "독점 다큐멘터리: 우주의 신비",
            "National Geographic Korea",
            3600,
            9900
        );

        // 1. 일반 동영상 재생
        player.loadContent(regularVideo);
        player.playContent();
        player.showPlayerControls();
        player.likeContent();

        // 2. Shorts 재생
        player.loadContent(shorts);
        player.playContent();
        player.showPlayerControls();

        // 3. 라이브 스트리밍
        player.loadContent(liveStream);
        player.playContent();
        player.showPlayerControls();

        // 4. 프리미엄 콘텐츠 (구독 필요)
        player.loadContent(premiumContent);
        player.playContent();  // 구독 필요 메시지
        premiumContent.subscribe();  // 구독
        player.playContent();  // 이제 재생 가능

        // 5. 추천 알고리즘
        YouTubeContent[] recommendations = {
            regularVideo,
            shorts,
            liveStream,
            premiumContent
        };

        player.recommendNext(recommendations);

        // 다형성의 강력함
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   다형성 활용 예시");
        System.out.println("═══════════════════════════\n");

        System.out.println("모든 콘텐츠 일괄 재생:");
        for (YouTubeContent content : recommendations) {
            content.play();
            System.out.println();
        }

        System.out.println("\n💡 다형성의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ YouTubeContent 타입으로 모든 콘텐츠 처리");
        System.out.println("✅ 플레이어 코드 수정 없이 새 콘텐츠 타입 추가");
        System.out.println("✅ 각 콘텐츠의 고유 기능 유지");
        System.out.println("✅ 실제 YouTube의 설계 원리!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 비즈니스 가치
1. **확장성**: 새로운 콘텐츠 타입 추가 용이 (Podcast, Music Video 등)
2. **유지보수성**: 플레이어 코드 수정 없이 기능 추가
3. **일관성**: 모든 콘텐츠가 동일한 인터페이스로 관리
4. **효율성**: 중복 코드 최소화

---

## 🍔 기업 사례 2: 배달의민족 주문 처리 {#사례2-배달의민족}

### 비즈니스 요구사항
배달의민족은 일반 배달, B마트(장보기), 선물하기, 포장 주문 등 다양한 주문 유형을 처리합니다. 각 주문 타입마다 다른 배송 방식, 결제 방식, 수수료 계산이 필요합니다.

### 다형성을 활용한 설계

```java
/**
 * 모든 주문의 부모 클래스
 */
public abstract class Order {
    protected String orderId;
    protected String customerId;
    protected String restaurantName;
    protected long totalAmount;
    protected String status;  // PENDING, CONFIRMED, PREPARING, DELIVERING, COMPLETED
    protected long orderTime;

    public Order(String orderId, String customerId, String restaurantName, long totalAmount) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.restaurantName = restaurantName;
        this.totalAmount = totalAmount;
        this.status = "PENDING";
        this.orderTime = System.currentTimeMillis();
    }

    // 추상 메서드 - 각 주문 타입마다 다른 처리 방식
    public abstract void processOrder();
    public abstract long calculateDeliveryFee();
    public abstract long calculateCommission();  // 수수료
    public abstract void deliver();
    public abstract String getOrderType();

    public void confirmOrder() {
        status = "CONFIRMED";
        System.out.println("✅ 주문 확인 완료");
        System.out.println("주문번호: " + orderId);
    }

    public void showOrderSummary() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("주문 요약");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("주문번호: " + orderId);
        System.out.println("주문 타입: " + getOrderType());
        System.out.println("가게: " + restaurantName);
        System.out.println("주문 금액: " + String.format("%,d", totalAmount) + "원");
        System.out.println("배달비: " + String.format("%,d", calculateDeliveryFee()) + "원");
        System.out.println("총 결제: " + String.format("%,d", totalAmount + calculateDeliveryFee()) + "원");
        System.out.println("상태: " + getStatusKorean());
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    protected String getStatusKorean() {
        switch (status) {
            case "PENDING": return "주문 대기";
            case "CONFIRMED": return "주문 확인";
            case "PREPARING": return "조리 중";
            case "DELIVERING": return "배달 중";
            case "COMPLETED": return "배달 완료";
            default: return status;
        }
    }
}

/**
 * 일반 배달 주문
 */
public class DeliveryOrder extends Order {
    private String deliveryAddress;
    private String phoneNumber;
    private String deliveryRequest;
    private int distance;  // km

    public DeliveryOrder(String orderId, String customerId, String restaurantName,
                        long totalAmount, String deliveryAddress, int distance) {
        super(orderId, customerId, restaurantName, totalAmount);
        this.deliveryAddress = deliveryAddress;
        this.distance = distance;
        this.deliveryRequest = "";
    }

    @Override
    public void processOrder() {
        System.out.println("\n🏍️ 배달 주문 처리 시작");
        System.out.println("가게: " + restaurantName);
        System.out.println("배달 주소: " + deliveryAddress);
        System.out.println("거리: " + distance + "km");

        confirmOrder();

        status = "PREPARING";
        System.out.println("👨‍🍳 조리 시작");
    }

    @Override
    public long calculateDeliveryFee() {
        // 기본 배달비 + 거리별 추가
        long baseFee = 3000;
        long distanceFee = (distance - 1) * 500;  // 1km 초과 시 500원/km

        if (distance > 5) {
            distanceFee += 1000;  // 5km 초과 시 추가 1000원
        }

        return baseFee + (distanceFee > 0 ? distanceFee : 0);
    }

    @Override
    public long calculateCommission() {
        // 가게 수수료: 주문 금액의 5.8% + 배달비의 50%
        long orderCommission = (long)(totalAmount * 0.058);
        long deliveryCommission = calculateDeliveryFee() / 2;
        return orderCommission + deliveryCommission;
    }

    @Override
    public void deliver() {
        System.out.println("\n🏍️ 배달 출발!");
        status = "DELIVERING";
        System.out.println("배달 예상 시간: " + (distance * 5) + "분");

        // 배달 완료 시뮬레이션
        try {
            Thread.sleep(1000);  // 실제로는 실시간 추적
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        status = "COMPLETED";
        System.out.println("✅ 배달 완료!");
        System.out.println("주소: " + deliveryAddress);
    }

    @Override
    public String getOrderType() {
        return "배달 주문";
    }

    public void setDeliveryRequest(String request) {
        this.deliveryRequest = request;
        System.out.println("📝 배달 요청사항: " + request);
    }
}

/**
 * B마트 (장보기) 주문
 */
public class BMartOrder extends Order {
    private String deliveryAddress;
    private int itemCount;
    private boolean requiresColdChain;  // 냉장/냉동 필요
    private String deliverySlot;  // 배송 시간대

    public BMartOrder(String orderId, String customerId, String restaurantName,
                     long totalAmount, String deliveryAddress, int itemCount) {
        super(orderId, customerId, restaurantName, totalAmount);
        this.deliveryAddress = deliveryAddress;
        this.itemCount = itemCount;
        this.requiresColdChain = false;
        this.deliverySlot = "오늘 도착";
    }

    @Override
    public void processOrder() {
        System.out.println("\n🛒 B마트 주문 처리 시작");
        System.out.println("마트: " + restaurantName);
        System.out.println("배달 주소: " + deliveryAddress);
        System.out.println("상품 수: " + itemCount + "개");
        System.out.println("배송 시간대: " + deliverySlot);

        if (requiresColdChain) {
            System.out.println("❄️ 신선 배송 (냉장/냉동)");
        }

        confirmOrder();

        status = "PREPARING";
        System.out.println("📦 상품 피킹 시작");
    }

    @Override
    public long calculateDeliveryFee() {
        // B마트는 일정 금액 이상 무료 배송
        if (totalAmount >= 15000) {
            return 0;
        }

        // 기본 배송비
        long fee = 2500;

        // 신선 배송 추가 요금
        if (requiresColdChain) {
            fee += 1500;
        }

        return fee;
    }

    @Override
    public long calculateCommission() {
        // B마트 수수료: 주문 금액의 8%
        return (long)(totalAmount * 0.08);
    }

    @Override
    public void deliver() {
        System.out.println("\n🚚 B마트 배송 출발!");
        status = "DELIVERING";

        if (requiresColdChain) {
            System.out.println("❄️ 신선 배송 차량");
        }

        System.out.println("배송 예상: " + deliverySlot);

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        status = "COMPLETED";
        System.out.println("✅ B마트 배송 완료!");
    }

    @Override
    public String getOrderType() {
        return "B마트 주문";
    }

    public void setColdChain(boolean required) {
        this.requiresColdChain = required;
    }

    public void setDeliverySlot(String slot) {
        this.deliverySlot = slot;
    }
}

/**
 * 선물하기 주문
 */
public class GiftOrder extends Order {
    private String recipientName;
    private String recipientPhone;
    private String giftMessage;
    private boolean isAnonymous;

    public GiftOrder(String orderId, String customerId, String restaurantName,
                    long totalAmount, String recipientName, String recipientPhone) {
        super(orderId, customerId, restaurantName, totalAmount);
        this.recipientName = recipientName;
        this.recipientPhone = recipientPhone;
        this.giftMessage = "";
        this.isAnonymous = false;
    }

    @Override
    public void processOrder() {
        System.out.println("\n🎁 선물하기 주문 처리 시작");
        System.out.println("가게: " + restaurantName);
        System.out.println("받는 분: " + recipientName);

        if (isAnonymous) {
            System.out.println("보내는 분: 익명");
        } else {
            System.out.println("보내는 분: " + customerId);
        }

        if (!giftMessage.isEmpty()) {
            System.out.println("💌 메시지: " + giftMessage);
        }

        confirmOrder();

        // 수신자에게 알림 전송
        System.out.println("📱 수신자에게 선물 알림 발송");
        status = "PREPARING";
    }

    @Override
    public long calculateDeliveryFee() {
        // 선물하기는 무료 배송
        return 0;
    }

    @Override
    public long calculateCommission() {
        // 선물하기 수수료: 주문 금액의 9% (높은 수수료)
        return (long)(totalAmount * 0.09);
    }

    @Override
    public void deliver() {
        System.out.println("\n🎁 선물 배송 시작!");
        status = "DELIVERING";

        System.out.println("받는 분: " + recipientName);
        System.out.println("연락처: " + maskPhoneNumber(recipientPhone));

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        status = "COMPLETED";
        System.out.println("✅ 선물 배송 완료!");
        System.out.println("📱 발신자에게 배송 완료 알림 발송");
    }

    @Override
    public String getOrderType() {
        return "선물하기";
    }

    public void setGiftMessage(String message) {
        this.giftMessage = message;
    }

    public void setAnonymous(boolean anonymous) {
        this.isAnonymous = anonymous;
    }

    private String maskPhoneNumber(String phone) {
        if (phone.length() >= 10) {
            return phone.substring(0, 3) + "-****-" + phone.substring(phone.length() - 4);
        }
        return phone;
    }
}

/**
 * 포장 주문
 */
public class TakeoutOrder extends Order {
    private String pickupTime;
    private boolean isPrepaid;
    private String tablewareRequest;

    public TakeoutOrder(String orderId, String customerId, String restaurantName,
                       long totalAmount, String pickupTime) {
        super(orderId, customerId, restaurantName, totalAmount);
        this.pickupTime = pickupTime;
        this.isPrepaid = true;
        this.tablewareRequest = "불필요";
    }

    @Override
    public void processOrder() {
        System.out.println("\n🏪 포장 주문 처리 시작");
        System.out.println("가게: " + restaurantName);
        System.out.println("픽업 시간: " + pickupTime);
        System.out.println("결제: " + (isPrepaid ? "선결제" : "매장 결제"));
        System.out.println("일회용품: " + tablewareRequest);

        confirmOrder();

        status = "PREPARING";
        System.out.println("👨‍🍳 조리 시작");
    }

    @Override
    public long calculateDeliveryFee() {
        // 포장 주문은 배달비 없음
        return 0;
    }

    @Override
    public long calculateCommission() {
        // 포장 주문 수수료: 주문 금액의 2.5% (낮은 수수료)
        return (long)(totalAmount * 0.025);
    }

    @Override
    public void deliver() {
        System.out.println("\n🏪 포장 준비 완료!");
        status = "COMPLETED";
        System.out.println("픽업 대기: " + restaurantName);
        System.out.println("픽업 시간: " + pickupTime);
        System.out.println("📱 고객에게 알림 발송");
    }

    @Override
    public String getOrderType() {
        return "포장 주문";
    }

    public void setTablewareRequest(String request) {
        this.tablewareRequest = request;
    }
}
```

### 배달의민족 주문 관리 시스템

```java
/**
 * 배달의민족 주문 관리 시스템
 */
public class BaeminOrderSystem {
    private String systemName;
    private long dailyRevenue;
    private long dailyCommission;

    public BaeminOrderSystem(String systemName) {
        this.systemName = systemName;
        this.dailyRevenue = 0;
        this.dailyCommission = 0;
    }

    /**
     * 주문 처리 - 다형성!
     * Order 타입으로 모든 주문 처리
     */
    public void handleOrder(Order order) {
        System.out.println("\n🍔 ═══════════════════════════");
        System.out.println("   " + systemName);
        System.out.println("═══════════════════════════");

        // 주문 처리
        order.processOrder();

        // 주문 요약
        order.showOrderSummary();

        // 배송/픽업
        order.deliver();

        // 정산
        long commission = order.calculateCommission();
        dailyRevenue += order.totalAmount;
        dailyCommission += commission;

        System.out.println("\n💰 정산");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("주문 금액: " + String.format("%,d", order.totalAmount) + "원");
        System.out.println("배달비: " + String.format("%,d", order.calculateDeliveryFee()) + "원");
        System.out.println("수수료: " + String.format("%,d", commission) + "원");
        System.out.println("가게 정산: " + String.format("%,d", order.totalAmount - commission) + "원");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    /**
     * 일괄 주문 처리
     */
    public void processBatchOrders(Order[] orders) {
        System.out.println("\n📦 일괄 주문 처리");
        System.out.println("총 " + orders.length + "건의 주문");

        for (Order order : orders) {
            handleOrder(order);
        }
    }

    public void showDailyReport() {
        System.out.println("\n📊 일일 리포트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("총 매출: " + String.format("%,d", dailyRevenue) + "원");
        System.out.println("총 수수료: " + String.format("%,d", dailyCommission) + "원");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 실행 테스트

```java
public class BaeminOrderTest {
    public static void main(String[] args) {
        System.out.println("🍔 ═══════════════════════════════");
        System.out.println("   배달의민족 주문 관리 시스템");
        System.out.println("═══════════════════════════════\n");

        // 주문 시스템 생성
        BaeminOrderSystem system = new BaeminOrderSystem("배달의민족");

        // 다양한 주문 생성
        DeliveryOrder deliveryOrder = new DeliveryOrder(
            "D20250110001",
            "user123",
            "맛있는 치킨",
            24000,
            "서울시 강남구 테헤란로 123",
            3
        );
        deliveryOrder.setDeliveryRequest("문 앞에 놓아주세요");

        BMartOrder bmartOrder = new BMartOrder(
            "B20250110001",
            "user456",
            "이마트24",
            28000,
            "서울시 서초구 서초대로 456",
            15
        );
        bmartOrder.setColdChain(true);
        bmartOrder.setDeliverySlot("오후 2-4시");

        GiftOrder giftOrder = new GiftOrder(
            "G20250110001",
            "user789",
            "스타벅스",
            15000,
            "김민수",
            "010-1234-5678"
        );
        giftOrder.setGiftMessage("생일 축하해요! 🎂");

        TakeoutOrder takeoutOrder = new TakeoutOrder(
            "T20250110001",
            "user321",
            "버거킹",
            12000,
            "15:30"
        );
        takeoutOrder.setTablewareRequest("불필요");

        // 주문 처리
        system.handleOrder(deliveryOrder);
        system.handleOrder(bmartOrder);
        system.handleOrder(giftOrder);
        system.handleOrder(takeoutOrder);

        // 일일 리포트
        system.showDailyReport();

        // 다형성의 강력함
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   다형성 활용 예시");
        System.out.println("═══════════════════════════\n");

        Order[] allOrders = {deliveryOrder, bmartOrder, giftOrder, takeoutOrder};

        System.out.println("모든 주문 타입 확인:");
        for (Order order : allOrders) {
            System.out.println("- " + order.getOrderType() +
                             ": 배달비 " + order.calculateDeliveryFee() + "원, " +
                             "수수료 " + order.calculateCommission() + "원");
        }

        System.out.println("\n\n💡 다형성의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ Order 타입으로 모든 주문 통합 처리");
        System.out.println("✅ 주문 타입별 다른 수수료/배달비 자동 계산");
        System.out.println("✅ 새로운 주문 타입 추가 용이 (새벽배송 등)");
        System.out.println("✅ 실제 배민의 핵심 설계!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 비즈니스 가치
1. **다양한 비즈니스 모델**: 배달, 마트, 선물, 포장 통합 관리
2. **유연한 수수료 정책**: 주문 타입별 다른 수수료율 적용
3. **확장성**: 새로운 서비스 추가 용이 (새벽배송, 구독 서비스 등)
4. **정산 자동화**: 타입별 자동 정산

---

## ⚙️ 기업 사례 3: GitHub Actions 워크플로우 {#사례3-github-actions}

### 비즈니스 요구사항
GitHub Actions는 다양한 작업(Job)을 자동으로 실행합니다. 테스트, 빌드, 배포, 코드 검사 등 각 작업마다 다른 실행 방식과 환경이 필요하지만, 워크플로우 엔진은 통일된 방식으로 모든 작업을 관리해야 합니다.

### 다형성을 활용한 설계

```java
/**
 * 모든 GitHub Actions 작업의 부모 클래스
 */
public abstract class GitHubAction {
    protected String actionName;
    protected String runnerOS;  // ubuntu-latest, windows-latest, macos-latest
    protected String status;  // PENDING, RUNNING, SUCCESS, FAILURE
    protected long startTime;
    protected long endTime;

    public GitHubAction(String actionName, String runnerOS) {
        this.actionName = actionName;
        this.runnerOS = runnerOS;
        this.status = "PENDING";
    }

    // 추상 메서드 - 각 작업마다 다른 실행 방식
    public abstract void setup();
    public abstract void execute();
    public abstract void teardown();
    public abstract String getActionType();

    public void run() {
        System.out.println("\n▶️ " + actionName + " 시작");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("타입: " + getActionType());
        System.out.println("Runner: " + runnerOS);

        startTime = System.currentTimeMillis();
        status = "RUNNING";

        try {
            setup();
            execute();
            teardown();

            status = "SUCCESS";
            System.out.println("✅ " + actionName + " 성공");
        } catch (Exception e) {
            status = "FAILURE";
            System.out.println("❌ " + actionName + " 실패: " + e.getMessage());
        } finally {
            endTime = System.currentTimeMillis();
            showSummary();
        }
    }

    public void showSummary() {
        long duration = endTime - startTime;
        System.out.println("\n📊 실행 요약");
        System.out.println("상태: " + getStatusEmoji());
        System.out.println("실행 시간: " + duration + "ms");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    protected String getStatusEmoji() {
        switch (status) {
            case "SUCCESS": return "✅ 성공";
            case "FAILURE": return "❌ 실패";
            case "RUNNING": return "⏳ 실행 중";
            default: return "⏸️ 대기";
        }
    }
}

/**
 * 테스트 실행 작업
 */
public class TestAction extends GitHubAction {
    private String testFramework;
    private int totalTests;
    private int passedTests;
    private int failedTests;

    public TestAction(String actionName, String runnerOS, String testFramework) {
        super(actionName, runnerOS);
        this.testFramework = testFramework;
        this.totalTests = 0;
        this.passedTests = 0;
        this.failedTests = 0;
    }

    @Override
    public void setup() {
        System.out.println("\n🔧 환경 설정");
        System.out.println("- " + testFramework + " 설치");
        System.out.println("- 의존성 다운로드");
        System.out.println("- 테스트 데이터베이스 설정");
    }

    @Override
    public void execute() {
        System.out.println("\n🧪 테스트 실행");
        System.out.println("프레임워크: " + testFramework);

        // 테스트 실행 시뮬레이션
        totalTests = 150;
        passedTests = 145;
        failedTests = 5;

        System.out.println("총 테스트: " + totalTests);
        System.out.println("✅ 성공: " + passedTests);
        System.out.println("❌ 실패: " + failedTests);

        if (failedTests > 0) {
            System.out.println("\n⚠️ 실패한 테스트:");
            System.out.println("- UserServiceTest.testLogin");
            System.out.println("- PaymentServiceTest.testRefund");
        }

        // 커버리지 리포트
        double coverage = (passedTests / (double)totalTests) * 100;
        System.out.println("\n📊 코드 커버리지: " + String.format("%.1f", coverage) + "%");
    }

    @Override
    public void teardown() {
        System.out.println("\n🧹 정리");
        System.out.println("- 테스트 데이터베이스 삭제");
        System.out.println("- 임시 파일 제거");
    }

    @Override
    public String getActionType() {
        return "Test";
    }
}

/**
 * 빌드 작업
 */
public class BuildAction extends GitHubAction {
    private String buildTool;
    private String targetPlatform;
    private String artifactPath;

    public BuildAction(String actionName, String runnerOS, String buildTool, String targetPlatform) {
        super(actionName, runnerOS);
        this.buildTool = buildTool;
        this.targetPlatform = targetPlatform;
    }

    @Override
    public void setup() {
        System.out.println("\n🔧 빌드 환경 설정");
        System.out.println("- " + buildTool + " 설정");
        System.out.println("- " + targetPlatform + " SDK 설치");
        System.out.println("- 의존성 다운로드");
    }

    @Override
    public void execute() {
        System.out.println("\n🏗️ 빌드 실행");
        System.out.println("빌드 도구: " + buildTool);
        System.out.println("타겟 플랫폼: " + targetPlatform);

        System.out.println("\n단계:");
        System.out.println("1. 소스 컴파일... ✅");
        System.out.println("2. 리소스 번들링... ✅");
        System.out.println("3. 최적화... ✅");
        System.out.println("4. 아티팩트 생성... ✅");

        artifactPath = "build/release/app-v1.2.3.jar";
        System.out.println("\n📦 아티팩트: " + artifactPath);
        System.out.println("크기: 45.2 MB");
    }

    @Override
    public void teardown() {
        System.out.println("\n🧹 정리");
        System.out.println("- 캐시 저장");
        System.out.println("- 아티팩트 업로드");
    }

    @Override
    public String getActionType() {
        return "Build";
    }

    public String getArtifactPath() {
        return artifactPath;
    }
}

/**
 * 배포 작업
 */
public class DeployAction extends GitHubAction {
    private String environment;  // development, staging, production
    private String deployTarget;  // AWS, Azure, GCP
    private String appUrl;

    public DeployAction(String actionName, String runnerOS, String environment, String deployTarget) {
        super(actionName, runnerOS);
        this.environment = environment;
        this.deployTarget = deployTarget;
    }

    @Override
    public void setup() {
        System.out.println("\n🔧 배포 환경 설정");
        System.out.println("- " + deployTarget + " CLI 설치");
        System.out.println("- 인증 정보 설정");
        System.out.println("- 환경 변수 로드");
    }

    @Override
    public void execute() {
        System.out.println("\n🚀 배포 실행");
        System.out.println("환경: " + environment);
        System.out.println("배포 대상: " + deployTarget);

        System.out.println("\n단계:");
        System.out.println("1. 이전 버전 백업... ✅");
        System.out.println("2. 새 버전 업로드... ✅");
        System.out.println("3. 서버 재시작... ✅");
        System.out.println("4. 헬스 체크... ✅");

        appUrl = "https://" + environment + ".myapp.com";
        System.out.println("\n🌐 배포 완료: " + appUrl);
    }

    @Override
    public void teardown() {
        System.out.println("\n🧹 정리");
        System.out.println("- 배포 로그 업로드");
        System.out.println("- Slack 알림 전송");
    }

    @Override
    public String getActionType() {
        return "Deploy";
    }

    public String getAppUrl() {
        return appUrl;
    }
}

/**
 * 코드 품질 검사 작업
 */
public class CodeQualityAction extends GitHubAction {
    private String linter;
    private int issuesFound;
    private String reportUrl;

    public CodeQualityAction(String actionName, String runnerOS, String linter) {
        super(actionName, runnerOS);
        this.linter = linter;
        this.issuesFound = 0;
    }

    @Override
    public void setup() {
        System.out.println("\n🔧 코드 품질 도구 설정");
        System.out.println("- " + linter + " 설치");
        System.out.println("- 규칙 설정 로드");
    }

    @Override
    public void execute() {
        System.out.println("\n🔍 코드 검사 실행");
        System.out.println("Linter: " + linter);

        System.out.println("\n검사 중:");
        System.out.println("- 코딩 스타일... ✅");
        System.out.println("- 보안 취약점... ✅");
        System.out.println("- 복잡도 분석... ✅");
        System.out.println("- 중복 코드 검사... ✅");

        // 이슈 발견 시뮬레이션
        issuesFound = 12;

        System.out.println("\n📋 검사 결과:");
        System.out.println("발견된 이슈: " + issuesFound + "개");
        System.out.println("- ⚠️ Warning: 8개");
        System.out.println("- 🔴 Error: 3개");
        System.out.println("- 💡 Info: 1개");

        reportUrl = "https://github.com/org/repo/actions/runs/12345";
        System.out.println("\n📄 상세 리포트: " + reportUrl);
    }

    @Override
    public void teardown() {
        System.out.println("\n🧹 정리");
        System.out.println("- 리포트 업로드");

        if (issuesFound > 10) {
            System.out.println("- PR에 코멘트 작성");
        }
    }

    @Override
    public String getActionType() {
        return "Code Quality";
    }

    public int getIssuesFound() {
        return issuesFound;
    }
}
```

### GitHub Actions 워크플로우 엔진

```java
/**
 * GitHub Actions 워크플로우 엔진
 */
public class WorkflowEngine {
    private String workflowName;
    private String triggerEvent;  // push, pull_request, schedule

    public WorkflowEngine(String workflowName, String triggerEvent) {
        this.workflowName = workflowName;
        this.triggerEvent = triggerEvent;
    }

    /**
     * 워크플로우 실행 - 다형성!
     * GitHubAction 타입으로 모든 작업 실행
     */
    public void runWorkflow(GitHubAction[] actions) {
        System.out.println("\n⚙️ ═══════════════════════════");
        System.out.println("   GitHub Actions Workflow");
        System.out.println("═══════════════════════════");
        System.out.println("워크플로우: " + workflowName);
        System.out.println("트리거: " + triggerEvent);
        System.out.println("작업 수: " + actions.length);

        long workflowStart = System.currentTimeMillis();
        int successCount = 0;
        int failureCount = 0;

        // 모든 작업 순차 실행
        for (int i = 0; i < actions.length; i++) {
            GitHubAction action = actions[i];

            System.out.println("\n\n[" + (i + 1) + "/" + actions.length + "] " +
                             action.actionName);

            action.run();  // 다형성! 각 작업 타입에 맞게 실행

            if (action.status.equals("SUCCESS")) {
                successCount++;
            } else {
                failureCount++;
                // 실패 시 워크플로우 중단
                System.out.println("\n⛔ 워크플로우 중단 (작업 실패)");
                break;
            }
        }

        long workflowEnd = System.currentTimeMillis();

        // 워크플로우 요약
        showWorkflowSummary(actions, successCount, failureCount,
                          workflowEnd - workflowStart);
    }

    private void showWorkflowSummary(GitHubAction[] actions, int successCount,
                                    int failureCount, long duration) {
        System.out.println("\n\n📊 ═══════════════════════════");
        System.out.println("   워크플로우 요약");
        System.out.println("═══════════════════════════");
        System.out.println("총 작업: " + actions.length);
        System.out.println("✅ 성공: " + successCount);
        System.out.println("❌ 실패: " + failureCount);
        System.out.println("총 실행 시간: " + duration + "ms");

        System.out.println("\n작업 목록:");
        for (GitHubAction action : actions) {
            System.out.println("- " + action.actionName + ": " +
                             action.getStatusEmoji());
        }

        if (failureCount == 0) {
            System.out.println("\n✅ 워크플로우 성공!");
        } else {
            System.out.println("\n❌ 워크플로우 실패!");
        }

        System.out.println("═══════════════════════════");
    }
}
```

### 실행 테스트

```java
public class GitHubActionsTest {
    public static void main(String[] args) {
        System.out.println("⚙️ ═══════════════════════════════");
        System.out.println("   GitHub Actions 시스템");
        System.out.println("═══════════════════════════════\n");

        // 워크플로우 엔진 생성
        WorkflowEngine engine = new WorkflowEngine("CI/CD Pipeline", "push");

        // 다양한 작업 생성
        TestAction testAction = new TestAction(
            "Run Tests",
            "ubuntu-latest",
            "JUnit 5"
        );

        BuildAction buildAction = new BuildAction(
            "Build Application",
            "ubuntu-latest",
            "Gradle",
            "JVM"
        );

        CodeQualityAction qualityAction = new CodeQualityAction(
            "Code Quality Check",
            "ubuntu-latest",
            "SonarQube"
        );

        DeployAction deployAction = new DeployAction(
            "Deploy to Staging",
            "ubuntu-latest",
            "staging",
            "AWS"
        );

        // 워크플로우 실행
        GitHubAction[] pipeline = {
            testAction,
            buildAction,
            qualityAction,
            deployAction
        };

        engine.runWorkflow(pipeline);

        // 다형성의 강력함
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   다형성 활용 예시");
        System.out.println("═══════════════════════════\n");

        System.out.println("모든 작업 타입:");
        for (GitHubAction action : pipeline) {
            System.out.println("- " + action.getActionType() + ": " +
                             action.actionName);
        }

        System.out.println("\n\n💡 다형성의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ GitHubAction 타입으로 모든 작업 실행");
        System.out.println("✅ 워크플로우 엔진 코드 변경 없이 새 작업 추가");
        System.out.println("✅ 작업 간 의존성 관리 용이");
        System.out.println("✅ 실제 GitHub Actions의 설계 원리!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 비즈니스 가치
1. **확장성**: 새로운 작업 타입 추가 용이 (Docker Build, Security Scan 등)
2. **재사용성**: 작업을 다양한 워크플로우에서 재사용
3. **일관성**: 모든 작업이 동일한 라이프사이클 (setup → execute → teardown)
4. **모니터링**: 통합된 방식으로 모든 작업 추적

---

## 👨‍💻 주니어 개발자 시나리오 {#주니어-시나리오}

### 시나리오 1: 다운캐스팅 실수 {#시나리오1}

#### 문제 상황
주니어 개발자 김민수는 다형성을 사용하다가 다운캐스팅을 잘못 사용했습니다.

```java
public class DowncastingMistake {
    public static void main(String[] args) {
        // 동물 배열 생성
        Animal[] animals = new Animal[3];
        animals[0] = new Dog("바둑이");
        animals[1] = new Cat("나비");
        animals[2] = new Bird("짹짹이");

        // ❌ 잘못된 코드
        for (Animal animal : animals) {
            // 모든 동물을 Dog로 캐스팅 시도
            Dog dog = (Dog) animal;  // ClassCastException 발생!
            dog.bark();
        }
    }
}
```

#### 실행 결과
```
Exception in thread "main" java.lang.ClassCastException:
Cat cannot be cast to Dog
```

#### 문제 분석
1. `Cat`과 `Bird` 객체를 `Dog`로 강제 형변환 시도
2. 런타임에 `ClassCastException` 발생
3. `instanceof` 체크 없이 무조건 캐스팅

#### 올바른 해결 방법

```java
public class DowncastingFixed {
    public static void main(String[] args) {
        Animal[] animals = new Animal[3];
        animals[0] = new Dog("바둑이");
        animals[1] = new Cat("나비");
        animals[2] = new Bird("짹짹이");

        // ✅ 올바른 코드
        for (Animal animal : animals) {
            // instanceof로 타입 확인 후 캐스팅
            if (animal instanceof Dog) {
                Dog dog = (Dog) animal;
                dog.bark();
            } else if (animal instanceof Cat) {
                Cat cat = (Cat) animal;
                cat.meow();
            } else if (animal instanceof Bird) {
                Bird bird = (Bird) animal;
                bird.chirp();
            }

            // 또는 다형성 활용 (더 좋은 방법!)
            animal.makeSound();  // 각 동물의 소리 메서드 호출
        }
    }
}
```

#### 핵심 교훈
- **다운캐스팅은 필요할 때만** 사용
- **반드시 `instanceof`로 타입 확인**
- **가능하면 다형성으로 해결** (다운캐스팅 피하기)

---

### 시나리오 2: instanceof 미사용 {#시나리오2}

#### 문제 상황
주니어 개발자 이영희는 타입 확인 없이 특정 타입의 메서드를 호출하려 했습니다.

```java
public class InstanceofMissing {
    public static void processContent(YouTubeContent content) {
        // ❌ 잘못된 코드
        // LiveStream인지 확인하지 않고 메서드 호출 시도
        LiveStream stream = (LiveStream) content;
        stream.sendSuperChat("안녕하세요", 5000);  // 다른 타입이면 에러!
    }

    public static void main(String[] args) {
        RegularVideo video = new RegularVideo("abc123", "테스트", "채널", 180);
        processContent(video);  // ClassCastException!
    }
}
```

#### 실행 결과
```
Exception in thread "main" java.lang.ClassCastException:
RegularVideo cannot be cast to LiveStream
```

#### 문제 분석
1. `RegularVideo`를 `LiveStream`으로 강제 형변환
2. `instanceof` 체크 없이 특정 타입 메서드 호출
3. 타입 안전성 무시

#### 올바른 해결 방법

```java
public class InstanceofFixed {
    public static void processContent(YouTubeContent content) {
        // ✅ 올바른 코드 - instanceof로 타입 확인
        if (content instanceof LiveStream) {
            LiveStream stream = (LiveStream) content;
            stream.sendSuperChat("안녕하세요", 5000);
            System.out.println("슈퍼챗 전송 완료");
        } else if (content instanceof YouTubeShorts) {
            YouTubeShorts shorts = (YouTubeShorts) content;
            shorts.swipeUp();
            System.out.println("다음 Shorts로 이동");
        } else {
            // 일반 동영상은 공통 메서드만 사용
            content.play();
        }
    }

    public static void main(String[] args) {
        // 다양한 콘텐츠 타입 테스트
        RegularVideo video = new RegularVideo("abc123", "테스트", "채널", 180);
        LiveStream stream = new LiveStream("live123", "라이브", "채널");

        processContent(video);   // 일반 재생
        processContent(stream);  // 슈퍼챗 가능
    }
}
```

#### 더 나은 방법 - 패턴 매칭 (Java 16+)

```java
public class PatternMatching {
    public static void processContent(YouTubeContent content) {
        // ✅ Java 16+ Pattern Matching
        if (content instanceof LiveStream stream) {
            // 자동으로 stream 변수 생성
            stream.sendSuperChat("안녕하세요", 5000);
        } else if (content instanceof YouTubeShorts shorts) {
            shorts.swipeUp();
        } else {
            content.play();
        }
    }
}
```

#### 핵심 교훈
- **다운캐스팅 전 반드시 `instanceof` 체크**
- **Pattern Matching 활용** (Java 16+)
- **타입 안전성 최우선**

---

### 시나리오 3: 배열 타입 혼동 {#시나리오3}

#### 문제 상황
주니어 개발자 박철수는 배열의 타입을 잘못 이해했습니다.

```java
public class ArrayTypeMistake {
    public static void main(String[] args) {
        // ❌ 잘못된 코드
        Dog[] dogs = new Dog[3];
        dogs[0] = new Dog("바둑이");
        dogs[1] = new Dog("멍멍이");
        dogs[2] = new Cat("나비");  // 컴파일 에러!

        // Dog[] 배열에 Cat을 넣으려 시도
    }
}
```

#### 컴파일 에러
```
error: incompatible types: Cat cannot be converted to Dog
        dogs[2] = new Cat("나비");
                  ^
```

#### 문제 분석
1. `Dog[]` 타입 배열에 `Cat` 객체 삽입 시도
2. 컴파일 타임에 타입 불일치 에러
3. 다형성을 배열 타입에 적용하지 못함

#### 올바른 해결 방법

```java
public class ArrayTypeFixed {
    public static void main(String[] args) {
        // ✅ 올바른 코드 - 부모 타입 배열 사용
        Animal[] animals = new Animal[3];
        animals[0] = new Dog("바둑이");
        animals[1] = new Dog("멍멍이");
        animals[2] = new Cat("나비");  // OK!

        // 다형성을 활용한 처리
        for (Animal animal : animals) {
            animal.makeSound();

            // 타입별 특별 처리
            if (animal instanceof Dog) {
                System.out.println("강아지입니다!");
            } else if (animal instanceof Cat) {
                System.out.println("고양이입니다!");
            }
        }
    }
}
```

#### List 사용 예시

```java
public class ListExample {
    public static void main(String[] args) {
        // ✅ List를 사용하면 더 유연함
        List<Animal> animals = new ArrayList<>();
        animals.add(new Dog("바둑이"));
        animals.add(new Cat("나비"));
        animals.add(new Bird("짹짹이"));

        // 동적으로 추가 가능
        animals.add(new Dog("멍멍이"));

        // 처리
        for (Animal animal : animals) {
            animal.makeSound();
        }
    }
}
```

#### 핵심 교훈
- **부모 타입 배열**로 다양한 자식 객체 저장
- **배열보다 List 사용** 권장 (유연성)
- **컴파일 타입 타입 체크** 활용

---

### 시나리오 4: 부모 타입의 한계 이해 부족 {#시나리오4}

#### 문제 상황
주니어 개발자 최다은은 부모 타입 참조로는 자식 고유 메서드를 호출할 수 없다는 것을 몰랐습니다.

```java
public class ParentTypeLimitation {
    public static void main(String[] args) {
        // ❌ 잘못된 코드
        Animal animal = new Dog("바둑이");

        animal.makeSound();  // OK - 부모에 정의된 메서드
        animal.bark();       // 컴파일 에러! - Dog 고유 메서드
    }
}
```

#### 컴파일 에러
```
error: cannot find symbol
        animal.bark();
              ^
  symbol:   method bark()
  location: variable animal of type Animal
```

#### 문제 분석
1. `Animal` 타입 참조로는 `Dog`의 `bark()` 메서드 호출 불가
2. 컴파일러는 참조 타입(`Animal`)만 확인
3. 실제 객체 타입(`Dog`)과 무관

#### 올바른 해결 방법

```java
public class ParentTypeFixed {
    public static void main(String[] args) {
        // 방법 1: 다운캐스팅
        Animal animal = new Dog("바둑이");

        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.bark();  // OK!
        }

        // 방법 2: 처음부터 Dog 타입으로 선언 (특정 기능 필요 시)
        Dog dog2 = new Dog("멍멍이");
        dog2.bark();  // OK!
        dog2.makeSound();  // OK - 상속받은 메서드도 사용 가능

        // 방법 3: 다형성 활용 (가장 좋은 방법)
        Animal[] animals = {
            new Dog("바둑이"),
            new Cat("나비"),
            new Bird("짹짹이")
        };

        for (Animal a : animals) {
            // 공통 메서드만 사용 - 타입 상관없이 동작
            a.makeSound();
            a.eat();
        }
    }
}
```

#### 더 나은 설계 - 인터페이스 활용

```java
// 짖는 동물 인터페이스
interface Barkable {
    void bark();
}

class Dog extends Animal implements Barkable {
    @Override
    public void bark() {
        System.out.println("멍멍!");
    }
}

class Wolf extends Animal implements Barkable {
    @Override
    public void bark() {
        System.out.println("아우우!");
    }
}

// 사용
public class InterfaceApproach {
    public static void makeBark(Barkable animal) {
        animal.bark();  // OK!
    }

    public static void main(String[] args) {
        makeBark(new Dog("바둑이"));
        makeBark(new Wolf("늑대"));
        // makeBark(new Cat("나비"));  // 컴파일 에러 - Cat은 Barkable 아님
    }
}
```

#### 핵심 교훈
- **참조 타입에 따라 호출 가능한 메서드 결정**
- **부모 타입 참조 = 공통 기능만** 사용 가능
- **특정 기능 필요 시 다운캐스팅 또는 인터페이스 활용**
- **가능하면 다형성으로 해결** (공통 메서드 호출)

---

## 📚 다음 단계

Part 3에서는 다음 내용을 다룹니다:
- **실전 프로젝트**: 쇼핑몰 결제 시스템 (다양한 결제 수단 통합)
- **7가지 FAQ**: 다형성 관련 자주 묻는 질문
- **12가지 면접 질문**: 주니어 7개 + 중급 5개

---

**작성일**: 2025-01-10
**챕터**: 17. 다형성 (Polymorphism) - Part 2
