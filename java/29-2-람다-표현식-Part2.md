# 29장 람다 표현식 - Part 2: 기업 사례 & 주니어 개발자 시나리오

## 📚 목차
1. [3개 기업 실전 사례](#기업-사례)
   - 네이버: 검색 필터 시스템
   - 쿠팡: 상품 정렬 엔진
   - 토스: 이벤트 드리븐 아키텍처
2. [4개 주니어 개발자 실수 시나리오](#주니어-실수-시나리오)

---

## 🏢 기업 사례

### 🔷 기업 사례 1: 네이버 - 검색 필터 시스템

#### 📌 비즈니스 배경

네이버 쇼핑에서는 수백만 개의 상품 중 사용자가 원하는 조건에 맞는 상품만 필터링해야 합니다.

**요구사항**:
- 다양한 필터 조건 (가격, 브랜드, 배송, 평점 등)
- 필터 조건 동적 조합
- 성능 최적화 (대용량 데이터)
- 유연한 확장성

**문제 상황**:
- 필터 조건마다 별도 메서드 작성 → 코드 중복
- 새로운 필터 추가 시 기존 코드 수정 필요
- 복잡한 조건 조합 구현의 어려움

#### 💡 람다를 활용한 해결책

```java
package com.naver.shopping;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * 상품 정보
 */
class Product {
    private String id;
    private String name;
    private String brand;
    private int price;
    private double rating;  // 평점 (0.0 ~ 5.0)
    private boolean fastShipping;  // 빠른 배송 가능 여부
    private String category;

    public Product(String id, String name, String brand, int price,
                   double rating, boolean fastShipping, String category) {
        this.id = id;
        this.name = name;
        this.brand = brand;
        this.price = price;
        this.rating = rating;
        this.fastShipping = fastShipping;
        this.category = category;
    }

    public String getId() { return id; }
    public String getName() { return name; }
    public String getBrand() { return brand; }
    public int getPrice() { return price; }
    public double getRating() { return rating; }
    public boolean isFastShipping() { return fastShipping; }
    public String getCategory() { return category; }

    @Override
    public String toString() {
        return String.format("[%s] %s - %,d원 (★%.1f) %s",
            brand, name, price, rating,
            fastShipping ? "⚡빠른배송" : "");
    }
}

/**
 * 검색 필터 시스템
 */
class ProductFilter {
    private List<Product> products;

    public ProductFilter(List<Product> products) {
        this.products = products;
    }

    /**
     * ✅ 람다 기반 필터링 (핵심 메서드)
     */
    public List<Product> filter(Predicate<Product> condition) {
        return products.stream()
            .filter(condition)
            .collect(Collectors.toList());
    }

    /**
     * 사전 정의된 필터 조건들 (재사용 가능)
     */
    public static class Filters {
        // 가격 범위
        public static Predicate<Product> priceRange(int min, int max) {
            return product -> product.getPrice() >= min && product.getPrice() <= max;
        }

        // 특정 브랜드
        public static Predicate<Product> brand(String brand) {
            return product -> product.getBrand().equals(brand);
        }

        // 평점 이상
        public static Predicate<Product> ratingAbove(double minRating) {
            return product -> product.getRating() >= minRating;
        }

        // 빠른 배송 가능
        public static Predicate<Product> fastShipping() {
            return Product::isFastShipping;
        }

        // 카테고리
        public static Predicate<Product> category(String category) {
            return product -> product.getCategory().equals(category);
        }

        // 키워드 검색
        public static Predicate<Product> nameContains(String keyword) {
            return product -> product.getName().toLowerCase()
                .contains(keyword.toLowerCase());
        }
    }

    /**
     * 정렬 기준
     */
    public List<Product> sort(Comparator<Product> comparator) {
        return products.stream()
            .sorted(comparator)
            .collect(Collectors.toList());
    }
}

/**
 * 네이버 쇼핑 검색 시스템 데모
 */
public class NaverShoppingDemo {
    public static void main(String[] args) {
        System.out.println("=== 네이버 쇼핑 검색 필터 시스템 ===\n");

        // 상품 데이터
        List<Product> products = Arrays.asList(
            new Product("P001", "갤럭시 S23", "삼성", 1200000, 4.5, true, "전자기기"),
            new Product("P002", "아이폰 14", "애플", 1400000, 4.8, true, "전자기기"),
            new Product("P003", "에어팟 프로", "애플", 350000, 4.7, true, "전자기기"),
            new Product("P004", "갤럭시 버즈", "삼성", 180000, 4.3, true, "전자기기"),
            new Product("P005", "맥북 프로", "애플", 2500000, 4.9, false, "전자기기"),
            new Product("P006", "LG 그램", "LG", 1800000, 4.4, true, "전자기기"),
            new Product("P007", "나이키 운동화", "나이키", 120000, 4.2, true, "패션"),
            new Product("P008", "아디다스 운동화", "아디다스", 150000, 4.5, false, "패션"),
            new Product("P009", "다이슨 청소기", "다이슨", 800000, 4.6, true, "가전"),
            new Product("P010", "삼성 냉장고", "삼성", 1500000, 4.7, false, "가전")
        );

        ProductFilter filter = new ProductFilter(products);

        // 시나리오 1: 단일 조건 필터
        System.out.println("📍 시나리오 1: 단일 조건 필터");

        // 가격 50만원 이하
        List<Product> affordable = filter.filter(
            ProductFilter.Filters.priceRange(0, 500000)
        );

        System.out.println("50만원 이하 상품: " + affordable.size() + "개");
        affordable.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 2: 복합 조건 (AND)
        System.out.println("📍 시나리오 2: 복합 조건 (AND)");

        // 100만원 이하 + 평점 4.5 이상 + 빠른 배송
        List<Product> premium = filter.filter(
            ProductFilter.Filters.priceRange(0, 1000000)
                .and(ProductFilter.Filters.ratingAbove(4.5))
                .and(ProductFilter.Filters.fastShipping())
        );

        System.out.println("프리미엄 조건 (100만원 이하 + ★4.5+ + 빠른배송): " + premium.size() + "개");
        premium.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 3: OR 조건
        System.out.println("📍 시나리오 3: OR 조건");

        // 삼성 또는 애플 제품
        List<Product> brands = filter.filter(
            ProductFilter.Filters.brand("삼성")
                .or(ProductFilter.Filters.brand("애플"))
        );

        System.out.println("삼성 또는 애플 제품: " + brands.size() + "개");
        brands.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 4: 커스텀 필터 (람다 직접 사용)
        System.out.println("📍 시나리오 4: 커스텀 필터");

        // 가격이 7자리 이상인 초고가 제품
        List<Product> luxury = filter.filter(
            product -> product.getPrice() >= 1000000
        );

        System.out.println("초고가 제품 (100만원 이상): " + luxury.size() + "개");
        luxury.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 5: 동적 필터 조합
        System.out.println("📍 시나리오 5: 동적 필터 조합 (사용자 선택에 따라)");

        // 사용자 선택 시뮬레이션
        Map<String, Object> userSelection = new HashMap<>();
        userSelection.put("minPrice", 0);
        userSelection.put("maxPrice", 500000);
        userSelection.put("minRating", 4.3);
        userSelection.put("fastShipping", true);
        userSelection.put("category", "전자기기");

        // 동적으로 필터 구성
        Predicate<Product> dynamicFilter = buildDynamicFilter(userSelection);

        List<Product> results = filter.filter(dynamicFilter);

        System.out.println("사용자 조건에 맞는 상품: " + results.size() + "개");
        results.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 6: 필터 + 정렬
        System.out.println("📍 시나리오 6: 필터 + 정렬");

        List<Product> filtered = products.stream()
            .filter(ProductFilter.Filters.category("전자기기"))
            .filter(ProductFilter.Filters.fastShipping())
            .sorted(Comparator.comparing(Product::getPrice))  // 가격 낮은 순
            .collect(Collectors.toList());

        System.out.println("전자기기 + 빠른배송 (가격 낮은 순):");
        filtered.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 성능 비교
        System.out.println("📊 람다 기반 필터의 장점:");
        System.out.println("✅ 코드 간결성: 조건을 한 줄로 표현");
        System.out.println("✅ 재사용성: 필터 조건을 변수로 저장 및 조합");
        System.out.println("✅ 확장성: 새 필터 추가 시 기존 코드 수정 불필요");
        System.out.println("✅ 가독성: 비즈니스 로직이 명확함");
    }

    /**
     * 사용자 선택에 따라 동적으로 필터 구성
     */
    private static Predicate<Product> buildDynamicFilter(Map<String, Object> selection) {
        Predicate<Product> filter = product -> true;  // 초기값: 모든 상품 허용

        if (selection.containsKey("minPrice") && selection.containsKey("maxPrice")) {
            int min = (int) selection.get("minPrice");
            int max = (int) selection.get("maxPrice");
            filter = filter.and(ProductFilter.Filters.priceRange(min, max));
        }

        if (selection.containsKey("minRating")) {
            double minRating = (double) selection.get("minRating");
            filter = filter.and(ProductFilter.Filters.ratingAbove(minRating));
        }

        if (selection.containsKey("fastShipping") &&
            (boolean) selection.get("fastShipping")) {
            filter = filter.and(ProductFilter.Filters.fastShipping());
        }

        if (selection.containsKey("category")) {
            String category = (String) selection.get("category");
            filter = filter.and(ProductFilter.Filters.category(category));
        }

        return filter;
    }
}
```

#### 🎯 핵심 포인트

**1. Predicate 조합 패턴**:
```java
// 재사용 가능한 필터 조건
Predicate<Product> expensive = p -> p.getPrice() > 1000000;
Predicate<Product> highRating = p -> p.getRating() >= 4.5;

// AND 조합
Predicate<Product> premium = expensive.and(highRating);

// OR 조합
Predicate<Product> goodDeal = expensive.or(highRating);

// NOT
Predicate<Product> notExpensive = expensive.negate();
```

**2. 람다 기반 필터의 장점**:
```
Before (전통적인 방식):
- 필터 메서드 수십 개
- 조건 조합 복잡
- 코드 중복 다수

After (람다):
- 단일 filter() 메서드
- 조건 조합 간단 (.and, .or)
- 코드 재사용
```

---

### 🔷 기업 사례 2: 쿠팡 - 상품 정렬 엔진

#### 📌 비즈니스 배경

쿠팡에서는 수백만 개의 상품을 사용자가 원하는 기준으로 정렬해야 합니다.

**정렬 기준**:
```
1. 낮은 가격순
2. 높은 가격순
3. 할인율 높은 순
4. 평점 높은 순
5. 리뷰 많은 순
6. 최신 등록순
7. 로켓배송 우선
```

**문제 상황**:
- 정렬 기준마다 별도 메서드 필요
- 다단계 정렬 구현의 복잡함
- 정렬 기준 변경 시 기존 코드 수정

#### 💡 람다를 활용한 해결책

```java
package com.coupang.sort;

import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 쿠팡 상품
 */
class CoupangProduct {
    private String name;
    private int originalPrice;  // 원가
    private int salePrice;      // 판매가
    private double rating;      // 평점
    private int reviewCount;    // 리뷰 수
    private LocalDate registeredDate;  // 등록일
    private boolean rocketDelivery;    // 로켓배송

    public CoupangProduct(String name, int originalPrice, int salePrice,
                          double rating, int reviewCount, LocalDate registeredDate,
                          boolean rocketDelivery) {
        this.name = name;
        this.originalPrice = originalPrice;
        this.salePrice = salePrice;
        this.rating = rating;
        this.reviewCount = reviewCount;
        this.registeredDate = registeredDate;
        this.rocketDelivery = rocketDelivery;
    }

    public String getName() { return name; }
    public int getOriginalPrice() { return originalPrice; }
    public int getSalePrice() { return salePrice; }
    public double getRating() { return rating; }
    public int getReviewCount() { return reviewCount; }
    public LocalDate getRegisteredDate() { return registeredDate; }
    public boolean isRocketDelivery() { return rocketDelivery; }

    /**
     * 할인율 계산
     */
    public double getDiscountRate() {
        if (originalPrice == 0) return 0;
        return (1.0 - (double) salePrice / originalPrice) * 100;
    }

    @Override
    public String toString() {
        return String.format("%s - %,d원 (%.0f%% 할인) ★%.1f (%d리뷰) %s",
            name, salePrice, getDiscountRate(), rating, reviewCount,
            rocketDelivery ? "🚀" : "");
    }
}

/**
 * 정렬 엔진
 */
class SortingEngine {
    /**
     * 사전 정의된 정렬 기준들
     */
    public static class Sorters {
        // 낮은 가격순
        public static Comparator<CoupangProduct> byPriceLowToHigh() {
            return Comparator.comparing(CoupangProduct::getSalePrice);
        }

        // 높은 가격순
        public static Comparator<CoupangProduct> byPriceHighToLow() {
            return Comparator.comparing(CoupangProduct::getSalePrice).reversed();
        }

        // 할인율 높은 순
        public static Comparator<CoupangProduct> byDiscountRate() {
            return Comparator.comparing(CoupangProduct::getDiscountRate).reversed();
        }

        // 평점 높은 순
        public static Comparator<CoupangProduct> byRating() {
            return Comparator.comparing(CoupangProduct::getRating).reversed();
        }

        // 리뷰 많은 순
        public static Comparator<CoupangProduct> byReviewCount() {
            return Comparator.comparing(CoupangProduct::getReviewCount).reversed();
        }

        // 최신 등록순
        public static Comparator<CoupangProduct> byRegisteredDate() {
            return Comparator.comparing(CoupangProduct::getRegisteredDate).reversed();
        }

        // 로켓배송 우선
        public static Comparator<CoupangProduct> byRocketDelivery() {
            return Comparator.comparing(CoupangProduct::isRocketDelivery).reversed();
        }

        /**
         * 쿠팡 추천순 (복합 정렬)
         * 1. 로켓배송 우선
         * 2. 평점 높은 순
         * 3. 리뷰 많은 순
         */
        public static Comparator<CoupangProduct> recommended() {
            return byRocketDelivery()
                .thenComparing(byRating())
                .thenComparing(byReviewCount());
        }
    }

    /**
     * 정렬 수행
     */
    public static List<CoupangProduct> sort(List<CoupangProduct> products,
                                            Comparator<CoupangProduct> comparator) {
        return products.stream()
            .sorted(comparator)
            .collect(Collectors.toList());
    }
}

/**
 * 쿠팡 정렬 엔진 데모
 */
public class CoupangSortDemo {
    public static void main(String[] args) {
        System.out.println("=== 쿠팡 상품 정렬 엔진 ===\n");

        // 상품 데이터
        List<CoupangProduct> products = Arrays.asList(
            new CoupangProduct("노트북 A", 1500000, 1200000, 4.5, 350, LocalDate.of(2023, 1, 15), true),
            new CoupangProduct("노트북 B", 2000000, 1800000, 4.8, 520, LocalDate.of(2023, 2, 10), true),
            new CoupangProduct("노트북 C", 1000000, 700000, 4.2, 180, LocalDate.of(2023, 3, 5), false),
            new CoupangProduct("노트북 D", 1800000, 1500000, 4.6, 420, LocalDate.of(2023, 1, 20), true),
            new CoupangProduct("노트북 E", 1200000, 1000000, 4.3, 210, LocalDate.of(2023, 2, 28), false),
            new CoupangProduct("노트북 F", 2500000, 2000000, 4.9, 680, LocalDate.of(2023, 3, 12), true)
        );

        // 시나리오 1: 낮은 가격순
        System.out.println("📍 시나리오 1: 낮은 가격순");
        List<CoupangProduct> byPrice = SortingEngine.sort(
            products,
            SortingEngine.Sorters.byPriceLowToHigh()
        );

        byPrice.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 2: 할인율 높은 순
        System.out.println("📍 시나리오 2: 할인율 높은 순");
        List<CoupangProduct> byDiscount = SortingEngine.sort(
            products,
            SortingEngine.Sorters.byDiscountRate()
        );

        byDiscount.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 3: 평점 높은 순
        System.out.println("📍 시나리오 3: 평점 높은 순");
        List<CoupangProduct> byRating = SortingEngine.sort(
            products,
            SortingEngine.Sorters.byRating()
        );

        byRating.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 4: 쿠팡 추천순 (복합 정렬)
        System.out.println("📍 시나리오 4: 쿠팡 추천순 (로켓배송 → 평점 → 리뷰)");
        List<CoupangProduct> recommended = SortingEngine.sort(
            products,
            SortingEngine.Sorters.recommended()
        );

        recommended.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 5: 커스텀 정렬 (람다 직접 사용)
        System.out.println("📍 시나리오 5: 커스텀 정렬 (가성비 = 평점 / 가격)");

        List<CoupangProduct> byValueForMoney = products.stream()
            .sorted((p1, p2) -> {
                double value1 = p1.getRating() / p1.getSalePrice() * 1000000;
                double value2 = p2.getRating() / p2.getSalePrice() * 1000000;
                return Double.compare(value2, value1);  // 내림차순
            })
            .collect(Collectors.toList());

        byValueForMoney.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 시나리오 6: 다단계 정렬 (사용자 정의)
        System.out.println("📍 시나리오 6: 다단계 정렬");
        System.out.println("1순위: 로켓배송");
        System.out.println("2순위: 할인율");
        System.out.println("3순위: 낮은 가격\n");

        List<CoupangProduct> multiLevel = products.stream()
            .sorted(
                SortingEngine.Sorters.byRocketDelivery()
                    .thenComparing(SortingEngine.Sorters.byDiscountRate())
                    .thenComparing(SortingEngine.Sorters.byPriceLowToHigh())
            )
            .collect(Collectors.toList());

        multiLevel.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // 성능 비교
        System.out.println("📊 람다 기반 정렬의 장점:");
        System.out.println("✅ 유연성: 정렬 기준을 런타임에 변경 가능");
        System.out.println("✅ 조합성: thenComparing()으로 다단계 정렬 쉽게 구현");
        System.out.println("✅ 재사용성: 정렬 기준을 변수로 저장 및 전달");
        System.out.println("✅ 가독성: 비즈니스 로직이 명확히 드러남");
    }
}
```

#### 🎯 핵심 포인트

**1. Comparator 다단계 정렬**:
```java
// 1순위: 평점
// 2순위: 리뷰 수
// 3순위: 가격
Comparator<Product> comparator =
    Comparator.comparing(Product::getRating).reversed()
        .thenComparing(Comparator.comparing(Product::getReviewCount).reversed())
        .thenComparing(Product::getPrice);
```

**2. 정렬 기준의 재사용**:
```java
// 정렬 기준을 변수로 저장
Comparator<Product> byPrice = Comparator.comparing(Product::getPrice);
Comparator<Product> byRating = Comparator.comparing(Product::getRating);

// 사용자 선택에 따라 동적으로 적용
String sortBy = getUserSelection();  // "price" 또는 "rating"

Comparator<Product> comparator = sortBy.equals("price") ? byPrice : byRating;
products.sort(comparator);
```

---

### 🔷 기업 사례 3: 토스 - 이벤트 드리븐 아키텍처

#### 📌 비즈니스 배경

토스에서는 송금, 결제, 충전 등 다양한 이벤트가 발생할 때마다 여러 후속 작업이 필요합니다.

**이벤트 처리 예시**:
```
송금 완료 이벤트 발생 시:
1. 알림 전송
2. 포인트 적립
3. 통계 업데이트
4. 로그 기록
5. 외부 API 호출
```

**문제 상황**:
- 이벤트 핸들러 추가/삭제 시 기존 코드 수정 필요
- 핸들러 간 결합도 높음
- 비동기 처리 복잡

#### 💡 람다를 활용한 해결책

```java
package com.toss.event;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Consumer;

/**
 * 이벤트 기본 클래스
 */
abstract class Event {
    private final String eventId;
    private final LocalDateTime timestamp;

    public Event() {
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
    }

    public String getEventId() { return eventId; }
    public LocalDateTime getTimestamp() { return timestamp; }
}

/**
 * 송금 이벤트
 */
class TransferEvent extends Event {
    private String fromUserId;
    private String toUserId;
    private long amount;

    public TransferEvent(String fromUserId, String toUserId, long amount) {
        super();
        this.fromUserId = fromUserId;
        this.toUserId = toUserId;
        this.amount = amount;
    }

    public String getFromUserId() { return fromUserId; }
    public String getToUserId() { return toUserId; }
    public long getAmount() { return amount; }

    @Override
    public String toString() {
        return String.format("송금: %s → %s (%,d원)", fromUserId, toUserId, amount);
    }
}

/**
 * 결제 이벤트
 */
class PaymentEvent extends Event {
    private String userId;
    private String merchantName;
    private long amount;

    public PaymentEvent(String userId, String merchantName, long amount) {
        super();
        this.userId = userId;
        this.merchantName = merchantName;
        this.amount = amount;
    }

    public String getUserId() { return userId; }
    public String getMerchantName() { return merchantName; }
    public long getAmount() { return amount; }

    @Override
    public String toString() {
        return String.format("결제: %s @ %s (%,d원)", userId, merchantName, amount);
    }
}

/**
 * 이벤트 버스 (이벤트 중앙 관리)
 */
class EventBus {
    // 이벤트 타입별 핸들러 목록
    private Map<Class<? extends Event>, List<Consumer<Event>>> handlers = new ConcurrentHashMap<>();

    // 비동기 처리를 위한 스레드풀
    private ExecutorService executor = Executors.newFixedThreadPool(5);

    /**
     * ✅ 람다 기반 이벤트 핸들러 등록
     */
    public <T extends Event> void subscribe(Class<T> eventType, Consumer<T> handler) {
        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
            .add((Consumer<Event>) handler);

        System.out.println("✅ 핸들러 등록: " + eventType.getSimpleName());
    }

    /**
     * 이벤트 발행 (동기)
     */
    public void publish(Event event) {
        System.out.println("\n📢 이벤트 발생: " + event);

        List<Consumer<Event>> eventHandlers = handlers.get(event.getClass());

        if (eventHandlers != null) {
            for (Consumer<Event> handler : eventHandlers) {
                try {
                    handler.accept(event);
                } catch (Exception e) {
                    System.err.println("❌ 핸들러 실행 오류: " + e.getMessage());
                }
            }
        }
    }

    /**
     * 이벤트 발행 (비동기)
     */
    public CompletableFuture<Void> publishAsync(Event event) {
        System.out.println("\n📢 이벤트 발생 (비동기): " + event);

        List<Consumer<Event>> eventHandlers = handlers.get(event.getClass());

        if (eventHandlers == null || eventHandlers.isEmpty()) {
            return CompletableFuture.completedFuture(null);
        }

        // 모든 핸들러를 비동기로 실행
        CompletableFuture<?>[] futures = eventHandlers.stream()
            .map(handler -> CompletableFuture.runAsync(() -> {
                try {
                    handler.accept(event);
                } catch (Exception e) {
                    System.err.println("❌ 핸들러 실행 오류: " + e.getMessage());
                }
            }, executor))
            .toArray(CompletableFuture[]::new);

        return CompletableFuture.allOf(futures);
    }

    /**
     * 종료
     */
    public void shutdown() {
        executor.shutdown();
    }
}

/**
 * 토스 이벤트 시스템 데모
 */
public class TossEventDemo {
    public static void main(String[] args) throws Exception {
        System.out.println("=== 토스 이벤트 드리븐 아키텍처 ===\n");

        EventBus eventBus = new EventBus();

        // 시나리오 1: 송금 이벤트 핸들러 등록
        System.out.println("📍 시나리오 1: 송금 이벤트 핸들러 등록\n");

        // 핸들러 1: 알림 전송
        eventBus.subscribe(TransferEvent.class, event -> {
            TransferEvent transferEvent = (TransferEvent) event;
            System.out.println("  📱 [알림] " + transferEvent.getToUserId() + "님에게 "
                + String.format("%,d", transferEvent.getAmount()) + "원이 입금되었습니다");
        });

        // 핸들러 2: 포인트 적립
        eventBus.subscribe(TransferEvent.class, event -> {
            TransferEvent transferEvent = (TransferEvent) event;
            long points = transferEvent.getAmount() / 1000;  // 0.1% 포인트
            System.out.println("  🎁 [포인트] " + points + "P 적립");
        });

        // 핸들러 3: 로그 기록
        eventBus.subscribe(TransferEvent.class, event -> {
            System.out.println("  📝 [로그] 이벤트 ID: " + event.getEventId()
                + " | 시각: " + event.getTimestamp());
        });

        // 핸들러 4: 통계 업데이트
        eventBus.subscribe(TransferEvent.class, event -> {
            TransferEvent transferEvent = (TransferEvent) event;
            System.out.println("  📊 [통계] 일일 송금액 누계 업데이트");
        });

        // 송금 이벤트 발생
        TransferEvent transferEvent = new TransferEvent("USER001", "USER002", 50000);
        eventBus.publish(transferEvent);

        Thread.sleep(1000);

        // 시나리오 2: 결제 이벤트 핸들러 등록
        System.out.println("\n📍 시나리오 2: 결제 이벤트 핸들러 등록\n");

        // 핸들러 1: 영수증 전송
        eventBus.subscribe(PaymentEvent.class, event -> {
            PaymentEvent paymentEvent = (PaymentEvent) event;
            System.out.println("  🧾 [영수증] " + paymentEvent.getMerchantName()
                + " 결제 영수증 전송");
        });

        // 핸들러 2: 캐시백 적립
        eventBus.subscribe(PaymentEvent.class, event -> {
            PaymentEvent paymentEvent = (PaymentEvent) event;
            long cashback = paymentEvent.getAmount() / 100;  // 1% 캐시백
            System.out.println("  💰 [캐시백] " + cashback + "원 적립");
        });

        // 결제 이벤트 발생
        PaymentEvent paymentEvent = new PaymentEvent("USER001", "스타벅스", 15000);
        eventBus.publish(paymentEvent);

        Thread.sleep(1000);

        // 시나리오 3: 비동기 이벤트 처리
        System.out.println("\n📍 시나리오 3: 비동기 이벤트 처리\n");

        // 무거운 작업 핸들러 등록
        eventBus.subscribe(TransferEvent.class, event -> {
            System.out.println("  ⏳ [외부 API] 호출 시작...");
            try {
                Thread.sleep(2000);  // 2초 소요
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("  ✅ [외부 API] 호출 완료");
        });

        // 비동기 발행
        TransferEvent asyncEvent = new TransferEvent("USER003", "USER004", 100000);
        CompletableFuture<Void> future = eventBus.publishAsync(asyncEvent);

        System.out.println("\n메인 스레드는 계속 실행됩니다...");

        // 모든 핸들러 완료 대기
        future.get();

        System.out.println("\n모든 핸들러 처리 완료!");

        // 정리
        eventBus.shutdown();

        System.out.println("\n📊 람다 기반 이벤트 시스템의 장점:");
        System.out.println("✅ 느슨한 결합: 이벤트 발행자와 핸들러가 독립적");
        System.out.println("✅ 확장성: 핸들러 추가/제거가 쉬움");
        System.out.println("✅ 비동기 처리: CompletableFuture와 결합");
        System.out.println("✅ 테스트 용이: 핸들러를 독립적으로 테스트 가능");
    }
}
```

#### 🎯 핵심 포인트

**1. Consumer 람다**:
```java
// Consumer<T>: T → void (소비)

// 이벤트 핸들러 등록
eventBus.subscribe(TransferEvent.class, event -> {
    // 이벤트 처리 로직
    System.out.println("처리: " + event);
});
```

**2. 이벤트 드리븐 아키텍처**:
```
Before (전통적인 방식):
class TransferService {
    void transfer() {
        // 송금 로직
        notificationService.send();    // 강한 결합
        pointService.accumulate();     // 강한 결합
        logService.write();            // 강한 결합
    }
}

After (이벤트 기반):
class TransferService {
    void transfer() {
        // 송금 로직
        eventBus.publish(new TransferEvent(...));  // 느슨한 결합
    }
}

// 다른 곳에서 핸들러 등록
eventBus.subscribe(TransferEvent.class, event -> notificationService.send());
eventBus.subscribe(TransferEvent.class, event -> pointService.accumulate());
```

---

## 🚨 주니어 실수 시나리오

### ❌ 실수 1: 람다에서 외부 변수 수정

#### 문제 코드

```java
package lambda.mistakes;

import java.util.*;

public class Mistake1_ModifyingExternalVariable {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // ❌ 나쁜 예: 외부 변수 수정 시도
        int sum = 0;  // effectively final이 아님

        numbers.forEach(n -> {
            // sum += n;  // 컴파일 에러!
            // Variable used in lambda should be final or effectively final
        });

        System.out.println("Sum: " + sum);
    }
}
```

#### 왜 문제인가?

```
람다에서 접근하는 외부 변수는 final 또는 effectively final이어야 함

이유:
1. 람다는 변수의 복사본을 캡처
2. 멀티스레드 환경에서 예측 불가능한 동작
3. 람다가 나중에 실행될 수 있음
```

#### ✅ 올바른 해결책

```java
package lambda.mistakes;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class Mistake1_Solution {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        System.out.println("=== 외부 변수 수정 올바른 방법 ===\n");

        // ✅ 해결책 1: Stream의 reduce 사용 (함수형 방식)
        int sum1 = numbers.stream()
            .reduce(0, Integer::sum);

        System.out.println("해결책 1 (reduce): " + sum1);

        // ✅ 해결책 2: AtomicInteger 사용
        AtomicInteger sum2 = new AtomicInteger(0);
        numbers.forEach(n -> sum2.addAndGet(n));

        System.out.println("해결책 2 (AtomicInteger): " + sum2.get());

        // ✅ 해결책 3: 배열 사용 (트릭)
        int[] sum3 = {0};
        numbers.forEach(n -> sum3[0] += n);

        System.out.println("해결책 3 (배열): " + sum3[0]);

        // ✅ 해결책 4: 람다 대신 일반 for문 (가장 단순)
        int sum4 = 0;
        for (int n : numbers) {
            sum4 += n;
        }

        System.out.println("해결책 4 (for문): " + sum4);

        System.out.println("\n💡 권장: Stream API의 reduce 사용 (함수형 방식)");
    }
}
```

---

### ❌ 실수 2: 람다 내부에서 체크 예외 처리

#### 문제 코드

```java
package lambda.mistakes;

import java.util.*;

public class Mistake2_CheckedException {
    public static void main(String[] args) {
        List<String> urls = Arrays.asList(
            "http://example.com/1",
            "http://example.com/2",
            "http://example.com/3"
        );

        // ❌ 나쁜 예: 체크 예외를 람다에서 처리할 수 없음
        /*
        urls.forEach(url -> {
            String content = fetchUrl(url);  // 컴파일 에러!
            // Unhandled exception: java.io.IOException
        });
        */
    }

    static String fetchUrl(String url) throws java.io.IOException {
        // URL에서 데이터 가져오기
        return "content";
    }
}
```

#### 왜 문제인가?

```
함수형 인터페이스의 메서드는 체크 예외를 던지지 않음

예: Consumer<T>의 accept() 메서드
void accept(T t);  // throws 절이 없음!
```

#### ✅ 올바른 해결책

```java
package lambda.mistakes;

import java.io.IOException;
import java.util.*;
import java.util.function.Consumer;

public class Mistake2_Solution {
    public static void main(String[] args) {
        List<String> urls = Arrays.asList(
            "http://example.com/1",
            "http://example.com/2",
            "http://example.com/3"
        );

        System.out.println("=== 체크 예외 처리 올바른 방법 ===\n");

        // ✅ 해결책 1: try-catch로 감싸기
        System.out.println("해결책 1: try-catch");
        urls.forEach(url -> {
            try {
                String content = fetchUrl(url);
                System.out.println("  " + url + ": " + content);
            } catch (IOException e) {
                System.err.println("  오류: " + url + " - " + e.getMessage());
            }
        });
        System.out.println();

        // ✅ 해결책 2: 래퍼 메서드 사용
        System.out.println("해결책 2: 래퍼 메서드");
        urls.forEach(unchecked(url -> {
            String content = fetchUrl(url);
            System.out.println("  " + url + ": " + content);
        }));
        System.out.println();

        // ✅ 해결책 3: 커스텀 함수형 인터페이스
        System.out.println("해결책 3: 커스텀 함수형 인터페이스");
        urls.forEach(safeConsumer(url -> {
            String content = fetchUrl(url);
            System.out.println("  " + url + ": " + content);
        }));

        System.out.println("\n💡 권장: 래퍼 메서드 사용 (코드 재사용)");
    }

    static String fetchUrl(String url) throws IOException {
        // 시뮬레이션
        if (url.contains("2")) {
            throw new IOException("Connection timeout");
        }
        return "Content of " + url;
    }

    /**
     * 체크 예외를 언체크 예외로 변환
     */
    static <T> Consumer<T> unchecked(ThrowingConsumer<T> consumer) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }

    /**
     * 체크 예외를 허용하는 Consumer
     */
    @FunctionalInterface
    interface ThrowingConsumer<T> {
        void accept(T t) throws Exception;
    }

    /**
     * 예외를 무시하는 Consumer
     */
    static <T> Consumer<T> safeConsumer(ThrowingConsumer<T> consumer) {
        return t -> {
            try {
                consumer.accept(t);
            } catch (Exception e) {
                System.err.println("  오류 무시: " + e.getMessage());
            }
        };
    }
}
```

---

### ❌ 실수 3: 람다에서 this 오해

#### 문제 코드

```java
package lambda.mistakes;

public class Mistake3_ThisReference {
    private String name = "Outer";

    public void testAnonymousClass() {
        Runnable runnable = new Runnable() {
            private String name = "Inner";

            @Override
            public void run() {
                System.out.println(this.name);  // "Inner" (익명 클래스의 this)
            }
        };

        runnable.run();
    }

    public void testLambda() {
        Runnable runnable = () -> {
            // private String name = "Inner";  // 컴파일 에러! 람다에는 필드 불가

            System.out.println(this.name);  // "Outer" (외부 클래스의 this)
        };

        runnable.run();
    }

    public static void main(String[] args) {
        Mistake3_ThisReference example = new Mistake3_ThisReference();

        System.out.println("익명 클래스:");
        example.testAnonymousClass();

        System.out.println("\n람다:");
        example.testLambda();
    }
}
```

#### 왜 문제인가?

```
익명 클래스 vs 람다의 this:

익명 클래스:
- this는 익명 클래스 자체를 가리킴
- 인스턴스 변수 선언 가능

람다:
- this는 외부 클래스를 가리킴
- 인스턴스 변수 선언 불가
```

#### ✅ 올바른 이해

```java
package lambda.mistakes;

public class Mistake3_Solution {
    private String outerField = "Outer Field";

    public void demonstrate() {
        System.out.println("=== this 참조 올바른 이해 ===\n");

        // 익명 클래스: this는 익명 클래스 자체
        Runnable anonymousClass = new Runnable() {
            private String innerField = "Inner Field";

            @Override
            public void run() {
                System.out.println("익명 클래스:");
                System.out.println("  this.innerField: " + this.innerField);
                // 외부 클래스 접근: Mistake3_Solution.this.outerField
                System.out.println("  외부 클래스: " + Mistake3_Solution.this.outerField);
            }
        };

        anonymousClass.run();
        System.out.println();

        // 람다: this는 외부 클래스
        Runnable lambda = () -> {
            System.out.println("람다:");
            System.out.println("  this.outerField: " + this.outerField);
            System.out.println("  this는 Mistake3_Solution: " + this.getClass().getSimpleName());
        };

        lambda.run();
        System.out.println();

        System.out.println("💡 핵심:");
        System.out.println("- 익명 클래스: 새로운 객체 (this는 익명 클래스)");
        System.out.println("- 람다: 메서드와 유사 (this는 외부 클래스)");
    }

    public static void main(String[] args) {
        new Mistake3_Solution().demonstrate();
    }
}
```

---

### ❌ 실수 4: 불필요한 람다 사용

#### 문제 코드

```java
package lambda.mistakes;

import java.util.*;
import java.util.stream.Collectors;

public class Mistake4_UnnecessaryLambda {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        System.out.println("=== 불필요한 람다 사용 ===\n");

        // ❌ 나쁜 예 1: 단순 메서드 호출을 람다로
        names.forEach(name -> System.out.println(name));

        System.out.println();

        // ❌ 나쁜 예 2: 단순 변환을 람다로
        List<Integer> lengths = names.stream()
            .map(name -> name.length())
            .collect(Collectors.toList());

        System.out.println("Lengths: " + lengths);
        System.out.println();

        // ❌ 나쁜 예 3: 단순 정렬을 람다로
        names.sort((a, b) -> a.compareTo(b));

        System.out.println("Sorted: " + names);
    }
}
```

#### 왜 문제인가?

```
메서드 참조가 더 간결하고 명확함

람다: name -> name.length()
메서드 참조: String::length

가독성과 유지보수성이 향상됨
```

#### ✅ 올바른 해결책

```java
package lambda.mistakes;

import java.util.*;
import java.util.stream.Collectors;

public class Mistake4_Solution {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        System.out.println("=== 메서드 참조 사용 (간결) ===\n");

        // ✅ 좋은 예 1: 메서드 참조
        System.out.println("forEach:");
        names.forEach(System.out::println);
        System.out.println();

        // ✅ 좋은 예 2: 메서드 참조
        List<Integer> lengths = names.stream()
            .map(String::length)
            .collect(Collectors.toList());

        System.out.println("Lengths: " + lengths);
        System.out.println();

        // ✅ 좋은 예 3: 메서드 참조 + Comparator
        List<String> sorted = new ArrayList<>(names);
        sorted.sort(String::compareTo);
        // 또는
        sorted.sort(Comparator.naturalOrder());

        System.out.println("Sorted: " + sorted);
        System.out.println();

        // 메서드 참조 종류
        System.out.println("📚 메서드 참조 종류:");

        // 1. 정적 메서드 참조
        List<Integer> numbers = Arrays.asList(-1, 2, -3, 4);
        numbers.stream()
            .map(Math::abs)  // 정적 메서드
            .forEach(System.out::println);

        // 2. 인스턴스 메서드 참조 (특정 객체)
        String prefix = "Hello, ";
        names.stream()
            .map(prefix::concat)  // prefix 객체의 메서드
            .forEach(System.out::println);

        // 3. 인스턴스 메서드 참조 (임의 객체)
        names.stream()
            .map(String::toUpperCase)  // 각 String 객체의 메서드
            .forEach(System.out::println);

        // 4. 생성자 참조
        List<Integer> nums = Arrays.asList(1, 2, 3);
        List<String> strings = nums.stream()
            .map(String::valueOf)  // 생성자 또는 정적 메서드
            .collect(Collectors.toList());

        System.out.println("\n💡 권장: 단순 메서드 호출은 메서드 참조 사용");
    }
}
```

---

## 🎓 Part 2 종합 정리

### 📊 람다 활용 패턴

| 패턴 | 설명 | 예시 |
|------|------|------|
| **필터링** | 조건에 맞는 요소 선택 | `filter(p -> p.getPrice() < 1000)` |
| **정렬** | 비교 기준 정의 | `sort((a, b) -> a.compareTo(b))` |
| **변환** | 요소를 다른 형태로 변환 | `map(s -> s.toUpperCase())` |
| **이벤트 처리** | 콜백 함수 등록 | `button.onClick(e -> ...)` |
| **조건 조합** | Predicate 결합 | `filter1.and(filter2)` |

---

### 🚨 주니어 개발자가 자주 하는 실수

```
1. ❌ 람다에서 외부 변수 수정
   ✅ Stream API 사용 또는 AtomicInteger

2. ❌ 체크 예외 처리 미흡
   ✅ 래퍼 메서드 또는 try-catch

3. ❌ this 참조 혼동
   ✅ 람다의 this는 외부 클래스

4. ❌ 불필요한 람다
   ✅ 메서드 참조 사용
```

**다음 Part 3에서는**: 성능 최적화, 고급 활용 기법, 면접 질문을 다룹니다.
