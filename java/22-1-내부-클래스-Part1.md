# 📝 Chapter 22-1: 내부 클래스 (Inner Classes) Part 1

## 🎯 학습 목표
- 내부 클래스(Inner Class)의 개념을 실생활 비유를 통해 이해합니다
- 4가지 종류의 내부 클래스를 구분하고 사용법을 익힙니다
- 각 내부 클래스의 특징과 활용 시나리오를 학습합니다
- 외부 클래스와 내부 클래스의 관계를 이해합니다
- 실무에서 자주 사용되는 내부 클래스 패턴을 학습합니다

---

## 📚 실생활 비유로 이해하는 내부 클래스

내부 클래스(Inner Class)는 **클래스 안에 정의된 또 다른 클래스**입니다.
마치 집(외부 클래스) 안에 방(내부 클래스)이 있는 것처럼, 외부 클래스 안에 내부 클래스가 포함되어 있습니다.

**4가지 종류:**
1. **Member Inner Class** (멤버 내부 클래스)
2. **Static Nested Class** (정적 중첩 클래스)
3. **Local Inner Class** (지역 내부 클래스)
4. **Anonymous Inner Class** (익명 내부 클래스)

---

## 👨‍👩‍👧‍👦 비유 1: Member Inner Class - 가족 구성원

### 실생활 비유
**가족(외부 클래스)과 가족 구성원(내부 클래스)**의 관계와 같습니다.
- 👨 아버지(외부 클래스)가 있어야 👧 딸(내부 클래스)이 존재할 수 있음
- 딸은 아버지의 모든 자산(private 필드 포함)에 접근 가능
- 딸은 아버지와 독립적으로 존재할 수 없음

### 코드로 이해하기

```java
// 📁 MemberInnerClassExample.java

class Family {
    // 외부 클래스의 private 필드
    private String familyName = "김씨네 가족";
    private int familyMembers = 4;
    private String address = "서울시 강남구";

    // 외부 클래스의 메서드
    public void introducefamily() {
        System.out.println("안녕하세요, 저희는 " + familyName + "입니다");
        System.out.println("가족 구성원: " + familyMembers + "명");
        System.out.println("주소: " + address);
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Member Inner Class (멤버 내부 클래스)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    class Child {
        private String name;
        private int age;
        private String hobby;

        public Child(String name, int age, String hobby) {
            this.name = name;
            this.age = age;
            this.hobby = hobby;
        }

        // ✅ 내부 클래스는 외부 클래스의 private 필드에 접근 가능!
        public void introduce() {
            System.out.println("\n👧 자녀 소개:");
            System.out.println("  이름: " + name);
            System.out.println("  나이: " + age + "세");
            System.out.println("  취미: " + hobby);
            System.out.println("  우리 가족: " + familyName);  // 외부 클래스의 private 필드 접근!
            System.out.println("  우리 집: " + address);       // 외부 클래스의 private 필드 접근!
        }

        public void helpFamily() {
            System.out.println(name + "이(가) 가족 일을 도와요");
            // 외부 클래스의 메서드 호출 가능
            System.out.println("현재 가족 구성원 수: " + familyMembers);
        }

        // 외부 클래스의 this 참조
        public void showOuterThis() {
            System.out.println("\n외부 클래스 참조: " + Family.this);
            System.out.println("내부 클래스 참조: " + this);
        }
    }

    // 외부 클래스에서 내부 클래스 사용
    public void addChild(String name, int age, String hobby) {
        Child child = new Child(name, age, hobby);  // 내부 클래스 인스턴스 생성
        child.introduce();
        child.helpFamily();
    }
}

public class MemberInnerClassExample {
    public static void main(String[] args) {
        System.out.println("=== Member Inner Class - 가족 구성원 비유 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 외부 클래스 인스턴스 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        Family family = new Family();
        family.introducefamily();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 방법 1: 외부 클래스 메서드를 통해 내부 클래스 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("방법 1: 외부 클래스 메서드를 통한 사용");
        System.out.println("=".repeat(50));

        family.addChild("김민지", 8, "그림 그리기");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 방법 2: 외부에서 직접 내부 클래스 인스턴스 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("방법 2: 외부에서 직접 내부 클래스 생성");
        System.out.println("=".repeat(50));

        // ⚠️ 중요: 외부 클래스 인스턴스가 먼저 있어야 함!
        Family.Child child1 = family.new Child("김지훈", 12, "축구");
        child1.introduce();
        child1.showOuterThis();

        Family.Child child2 = family.new Child("김수진", 15, "피아노");
        child2.introduce();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Member Inner Class 핵심:");
        System.out.println("1. 외부 클래스의 인스턴스가 있어야 생성 가능");
        System.out.println("2. 외부 클래스의 모든 멤버(private 포함)에 접근 가능");
        System.out.println("3. 외부 클래스 참조: OuterClass.this");
        System.out.println("4. 인스턴스 생성: outer.new InnerClass()");

        System.out.println("\n🎯 사용 시나리오:");
        System.out.println("- 내부 클래스가 외부 클래스의 상태에 강하게 의존");
        System.out.println("- 외부 클래스의 private 멤버 접근 필요");
        System.out.println("- Iterator, Builder 패턴 구현");
    }
}
```

**실행 결과:**
```
=== Member Inner Class - 가족 구성원 비유 ===

안녕하세요, 저희는 김씨네 가족입니다
가족 구성원: 4명
주소: 서울시 강남구

==================================================
방법 1: 외부 클래스 메서드를 통한 사용
==================================================

👧 자녀 소개:
  이름: 김민지
  나이: 8세
  취미: 그림 그리기
  우리 가족: 김씨네 가족
  우리 집: 서울시 강남구
김민지이(가) 가족 일을 도와요
현재 가족 구성원 수: 4

==================================================
방법 2: 외부에서 직접 내부 클래스 생성
==================================================

👧 자녀 소개:
  이름: 김지훈
  나이: 12세
  취미: 축구
  우리 가족: 김씨네 가족
  우리 집: 서울시 강남구

외부 클래스 참조: Family@15db9742
내부 클래스 참조: Family$Child@6d06d69c

👧 자녀 소개:
  이름: 김수진
  나이: 15세
  취미: 피아노
  우리 가족: 김씨네 가족
  우리 집: 서울시 강남구

==================================================

💡 Member Inner Class 핵심:
1. 외부 클래스의 인스턴스가 있어야 생성 가능
2. 외부 클래스의 모든 멤버(private 포함)에 접근 가능
3. 외부 클래스 참조: OuterClass.this
4. 인스턴스 생성: outer.new InnerClass()

🎯 사용 시나리오:
- 내부 클래스가 외부 클래스의 상태에 강하게 의존
- 외부 클래스의 private 멤버 접근 필요
- Iterator, Builder 패턴 구현
```

### 핵심 정리
- Member Inner Class는 **외부 클래스 인스턴스와 강하게 결합**
- 외부 클래스의 **모든 멤버에 접근** 가능 (private 포함)
- `Outer.this`로 외부 클래스 참조 가능

---

## 🏢 비유 2: Static Nested Class - 아파트 세대

### 실생활 비유
**아파트(외부 클래스)와 각 세대(정적 중첩 클래스)**의 관계와 같습니다.
- 🏢 같은 건물에 있지만 각 세대는 독립적
- 공용 시설(static 멤버)은 모든 세대가 공유
- 각 세대의 private 공간(인스턴스 멤버)은 접근 불가

### 코드로 이해하기

```java
// 📁 StaticNestedClassExample.java

class Apartment {
    // 외부 클래스의 static 필드 (공용 시설)
    private static String apartmentName = "래미안 아파트";
    private static int totalUnits = 200;
    private static String address = "서울시 송파구";

    // 외부 클래스의 인스턴스 필드 (특정 세대의 정보)
    private String unitNumber;
    private int residents;

    public Apartment(String unitNumber, int residents) {
        this.unitNumber = unitNumber;
        this.residents = residents;
    }

    // 외부 클래스의 static 메서드
    public static void showApartmentInfo() {
        System.out.println("아파트 이름: " + apartmentName);
        System.out.println("총 세대 수: " + totalUnits);
        System.out.println("위치: " + address);
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Static Nested Class (정적 중첩 클래스)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    static class Unit {
        private String ownerName;
        private int floor;
        private int squareMeter;

        public Unit(String ownerName, int floor, int squareMeter) {
            this.ownerName = ownerName;
            this.floor = floor;
            this.squareMeter = squareMeter;
        }

        // ✅ 외부 클래스의 static 멤버에 접근 가능!
        public void showUnitInfo() {
            System.out.println("\n🏠 세대 정보:");
            System.out.println("  아파트: " + apartmentName);  // static 필드 접근 OK
            System.out.println("  소유자: " + ownerName);
            System.out.println("  층: " + floor + "층");
            System.out.println("  면적: " + squareMeter + "㎡");
            System.out.println("  위치: " + address);  // static 필드 접근 OK
        }

        // ❌ 외부 클래스의 인스턴스 멤버에는 접근 불가!
        /*
        public void showResidents() {
            System.out.println(residents);  // 컴파일 에러!
        }
        */

        // static 메서드도 정의 가능
        public static void showCommonInfo() {
            System.out.println("공용 시설: 헬스장, 수영장, 독서실");
            System.out.println("주차 가능 대수: " + totalUnits * 2);
        }
    }

    // 외부 클래스에서 정적 중첩 클래스 사용
    public static void registerUnit(String ownerName, int floor, int squareMeter) {
        Unit unit = new Unit(ownerName, floor, squareMeter);
        unit.showUnitInfo();
    }
}

public class StaticNestedClassExample {
    public static void main(String[] args) {
        System.out.println("=== Static Nested Class - 아파트 세대 비유 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 아파트 정보 출력
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        Apartment.showApartmentInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 방법 1: 외부 클래스 없이 직접 정적 중첩 클래스 생성
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("방법 1: 외부 클래스 인스턴스 없이 생성");
        System.out.println("=".repeat(50));

        // ⚠️ 중요: 외부 클래스 인스턴스가 없어도 생성 가능!
        Apartment.Unit unit1 = new Apartment.Unit("김철수", 5, 84);
        unit1.showUnitInfo();

        Apartment.Unit unit2 = new Apartment.Unit("이영희", 12, 102);
        unit2.showUnitInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 방법 2: static 메서드 호출
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("방법 2: static 메서드 호출");
        System.out.println("=".repeat(50) + "\n");

        Apartment.Unit.showCommonInfo();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 방법 3: 외부 클래스 static 메서드를 통한 사용
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("방법 3: 외부 클래스 static 메서드 사용");
        System.out.println("=".repeat(50));

        Apartment.registerUnit("박민수", 20, 120);

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Member Inner Class vs Static Nested Class 비교
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n📊 Member Inner Class vs Static Nested Class:");

        System.out.println("\n✅ Static Nested Class:");
        System.out.println("  - 외부 클래스 인스턴스 없이 생성 가능");
        System.out.println("  - 외부 클래스의 static 멤버만 접근 가능");
        System.out.println("  - 메모리 효율적 (외부 클래스 참조 불필요)");
        System.out.println("  - 생성: new Outer.Nested()");

        System.out.println("\n❌ Member Inner Class:");
        System.out.println("  - 외부 클래스 인스턴스가 반드시 필요");
        System.out.println("  - 외부 클래스의 모든 멤버 접근 가능");
        System.out.println("  - 외부 클래스 참조를 암묵적으로 유지");
        System.out.println("  - 생성: outer.new Inner()");

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Static Nested Class 사용 시나리오:");
        System.out.println("- 외부 클래스의 인스턴스 멤버에 접근할 필요 없음");
        System.out.println("- 논리적 그룹화만 필요");
        System.out.println("- Builder 패턴, Helper 클래스");
        System.out.println("- Entry 클래스 (Map.Entry)");
    }
}
```

**실행 결과:**
```
=== Static Nested Class - 아파트 세대 비유 ===

아파트 이름: 래미안 아파트
총 세대 수: 200
위치: 서울시 송파구

==================================================
방법 1: 외부 클래스 인스턴스 없이 생성
==================================================

🏠 세대 정보:
  아파트: 래미안 아파트
  소유자: 김철수
  층: 5층
  면적: 84㎡
  위치: 서울시 송파구

🏠 세대 정보:
  아파트: 래미안 아파트
  소유자: 이영희
  층: 12층
  면적: 102㎡
  위치: 서울시 송파구

==================================================
방법 2: static 메서드 호출
==================================================

공용 시설: 헬스장, 수영장, 독서실
주차 가능 대수: 400

==================================================
방법 3: 외부 클래스 static 메서드 사용
==================================================

🏠 세대 정보:
  아파트: 래미안 아파트
  소유자: 박민수
  층: 20층
  면적: 120㎡
  위치: 서울시 송파구

==================================================

📊 Member Inner Class vs Static Nested Class:

✅ Static Nested Class:
  - 외부 클래스 인스턴스 없이 생성 가능
  - 외부 클래스의 static 멤버만 접근 가능
  - 메모리 효율적 (외부 클래스 참조 불필요)
  - 생성: new Outer.Nested()

❌ Member Inner Class:
  - 외부 클래스 인스턴스가 반드시 필요
  - 외부 클래스의 모든 멤버 접근 가능
  - 외부 클래스 참조를 암묵적으로 유지
  - 생성: outer.new Inner()

==================================================

💡 Static Nested Class 사용 시나리오:
- 외부 클래스의 인스턴스 멤버에 접근할 필요 없음
- 논리적 그룹화만 필요
- Builder 패턴, Helper 클래스
- Entry 클래스 (Map.Entry)
```

### 핵심 정리
- Static Nested Class는 **외부 클래스와 독립적**
- 외부 클래스의 **static 멤버만** 접근 가능
- **외부 인스턴스 없이** 생성 가능: `new Outer.Nested()`

---

## 📌 비유 3: Local Inner Class - 임시 스태프

### 실생활 비유
**행사(메서드)에서만 고용하는 임시 스태프(지역 내부 클래스)**와 같습니다.
- 🎪 특정 행사(메서드) 동안만 존재
- 행사가 끝나면 사라짐
- 행사장의 자원(지역 변수)에 접근 가능 (단, final 또는 effectively final)

### 코드로 이해하기

```java
// 📁 LocalInnerClassExample.java

class Event {
    private String eventName;
    private int participants;

    public Event(String eventName) {
        this.eventName = eventName;
        this.participants = 0;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Local Inner Class (지역 내부 클래스)
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    public void organizeEvent(String location, int budget) {
        // 메서드의 지역 변수
        final String eventType = "컨퍼런스";  // final 변수
        int setupHours = 3;  // effectively final (값이 변경되지 않음)

        // 지역 내부 클래스 정의
        class Staff {
            private String name;
            private String role;

            public Staff(String name, String role) {
                this.name = name;
                this.role = role;
            }

            public void work() {
                System.out.println("\n👷 임시 스태프: " + name);
                System.out.println("  역할: " + role);

                // ✅ 외부 클래스의 멤버 접근 가능
                System.out.println("  행사 이름: " + eventName);

                // ✅ 메서드의 지역 변수 접근 가능 (final 또는 effectively final)
                System.out.println("  행사 종류: " + eventType);
                System.out.println("  장소: " + location);
                System.out.println("  예산: " + budget + "만원");
                System.out.println("  준비 시간: " + setupHours + "시간");

                // ❌ 지역 변수 수정 불가!
                // setupHours = 4;  // 컴파일 에러!

                participants++;  // 외부 클래스의 필드는 수정 가능
            }

            public void report() {
                System.out.println("  " + name + "의 " + role + " 업무 완료");
            }
        }

        // 지역 내부 클래스 사용
        System.out.println("=== " + eventName + " 준비 시작 ===");

        Staff staff1 = new Staff("김철수", "무대 설치");
        staff1.work();
        staff1.report();

        Staff staff2 = new Staff("이영희", "음향 담당");
        staff2.work();
        staff2.report();

        Staff staff3 = new Staff("박민수", "조명 담당");
        staff3.work();
        staff3.report();

        System.out.println("\n총 참여 인원: " + participants + "명");
    }

    public void runEvent() {
        // ❌ 지역 내부 클래스는 메서드 밖에서 사용 불가!
        // Staff staff = new Staff("홍길동", "진행자");  // 컴파일 에러!

        System.out.println("\n🎉 " + eventName + " 행사 시작!");
    }
}

public class LocalInnerClassExample {
    public static void main(String[] args) {
        System.out.println("=== Local Inner Class - 임시 스태프 비유 ===\n");

        Event event1 = new Event("자바 개발자 컨퍼런스");
        event1.organizeEvent("코엑스", 5000);
        event1.runEvent();

        System.out.println("\n" + "=".repeat(50));

        Event event2 = new Event("스타트업 데모데이");
        event2.organizeEvent("구글 캠퍼스", 3000);
        event2.runEvent();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Local Inner Class 핵심:");
        System.out.println("1. 메서드 내부에서만 정의하고 사용");
        System.out.println("2. 메서드의 지역 변수 접근 가능 (final 또는 effectively final)");
        System.out.println("3. 외부 클래스의 멤버 접근 가능");
        System.out.println("4. 메서드 밖에서는 사용 불가");

        System.out.println("\n❓ 왜 지역 변수는 final이어야 하나?");
        System.out.println("- 메서드가 끝나면 지역 변수는 스택에서 사라짐");
        System.out.println("- 하지만 내부 클래스 인스턴스는 힙에 남아있을 수 있음");
        System.out.println("- 값이 변경되면 일관성 문제 발생 → final로 제한");

        System.out.println("\n🎯 사용 시나리오:");
        System.out.println("- 메서드 내에서만 사용되는 헬퍼 클래스");
        System.out.println("- 일회성 작업 수행");
        System.out.println("- 복잡한 로직을 캡슐화");
    }
}
```

**실행 결과:**
```
=== Local Inner Class - 임시 스태프 비유 ===

=== 자바 개발자 컨퍼런스 준비 시작 ===

👷 임시 스태프: 김철수
  역할: 무대 설치
  행사 이름: 자바 개발자 컨퍼런스
  행사 종류: 컨퍼런스
  장소: 코엑스
  예산: 5000만원
  준비 시간: 3시간
  김철수의 무대 설치 업무 완료

👷 임시 스태프: 이영희
  역할: 음향 담당
  행사 이름: 자바 개발자 컨퍼런스
  행사 종류: 컨퍼런스
  장소: 코엑스
  예산: 5000만원
  준비 시간: 3시간
  이영희의 음향 담당 업무 완료

👷 임시 스태프: 박민수
  역할: 조명 담당
  행사 이름: 자바 개발자 컨퍼런스
  행사 종류: 컨퍼런스
  장소: 코엑스
  예산: 5000만원
  준비 시간: 3시간
  박민수의 조명 담당 업무 완료

총 참여 인원: 3명

🎉 자바 개발자 컨퍼런스 행사 시작!

==================================================
=== 스타트업 데모데이 준비 시작 ===

👷 임시 스태프: 김철수
  역할: 무대 설치
  행사 이름: 스타트업 데모데이
  행사 종류: 컨퍼런스
  장소: 구글 캠퍼스
  예산: 3000만원
  준비 시간: 3시간
  김철수의 무대 설치 업무 완료

👷 임시 스태프: 이영희
  역할: 음향 담당
  행사 이름: 스타트업 데모데이
  행사 종류: 컨퍼런스
  장소: 구글 캠퍼스
  예산: 3000만원
  준비 시간: 3시간
  이영희의 음향 담당 업무 완료

👷 임시 스태프: 박민수
  역할: 조명 담당
  행사 이름: 스타트업 데모데이
  행사 종류: 컨퍼런스
  장소: 구글 캠퍼스
  예산: 3000만원
  준비 시간: 3시간
  박민수의 조명 담당 업무 완료

총 참여 인원: 3명

🎉 스타트업 데모데이 행사 시작!

==================================================

💡 Local Inner Class 핵심:
1. 메서드 내부에서만 정의하고 사용
2. 메서드의 지역 변수 접근 가능 (final 또는 effectively final)
3. 외부 클래스의 멤버 접근 가능
4. 메서드 밖에서는 사용 불가

❓ 왜 지역 변수는 final이어야 하나?
- 메서드가 끝나면 지역 변수는 스택에서 사라짐
- 하지만 내부 클래스 인스턴스는 힙에 남아있을 수 있음
- 값이 변경되면 일관성 문제 발생 → final로 제한

🎯 사용 시나리오:
- 메서드 내에서만 사용되는 헬퍼 클래스
- 일회성 작업 수행
- 복잡한 로직을 캡슐화
```

### 핵심 정리
- Local Inner Class는 **메서드 안에서만** 정의하고 사용
- 지역 변수는 **final 또는 effectively final**만 접근 가능
- 메서드가 끝나도 **인스턴스는 유지될 수 있음**

---

## 🎭 비유 4: Anonymous Inner Class - 일회용 컵

### 실생활 비유
**일회용 컵(익명 내부 클래스)**과 같습니다.
- ☕ 이름이 없음 (일회용이라 이름 지을 필요 없음)
- 한 번 사용하고 버림
- 즉석에서 만들어서 바로 사용

### 코드로 이해하기

```java
// 📁 AnonymousInnerClassExample.java

// 인터페이스 정의
interface Greeting {
    void greet(String name);
}

// 추상 클래스 정의
abstract class Animal {
    abstract void makeSound();
}

class CafeOrder {
    private String menuName;
    private int price;

    public CafeOrder(String menuName, int price) {
        this.menuName = menuName;
        this.price = price;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Anonymous Inner Class 활용
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    public void processOrder(Greeting greeting) {
        System.out.println("\n☕ 주문 접수:");
        System.out.println("  메뉴: " + menuName);
        System.out.println("  가격: " + price + "원");

        greeting.greet("고객님");
    }

    public void serveWithMessage() {
        // 익명 내부 클래스로 Greeting 인터페이스 구현
        Greeting servingMessage = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("  🎉 " + name + ", " + menuName + " 나왔습니다!");
                System.out.println("  맛있게 드세요!");
            }
        };

        servingMessage.greet("고객님");
    }
}

public class AnonymousInnerClassExample {
    public static void main(String[] args) {
        System.out.println("=== Anonymous Inner Class - 일회용 컵 비유 ===\n");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 예제 1: 인터페이스 구현
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("=".repeat(50));
        System.out.println("예제 1: 인터페이스 즉석 구현");
        System.out.println("=".repeat(50));

        // 익명 내부 클래스로 Greeting 인터페이스 구현
        Greeting koreanGreeting = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("안녕하세요, " + name + "님!");
            }
        };

        Greeting englishGreeting = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("Hello, " + name + "!");
            }
        };

        Greeting informalGreeting = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("야, " + name + "!");
            }
        };

        koreanGreeting.greet("김철수");
        englishGreeting.greet("John");
        informalGreeting.greet("친구");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 예제 2: 추상 클래스 구현
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("예제 2: 추상 클래스 즉석 구현");
        System.out.println("=".repeat(50) + "\n");

        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("🐕 멍멍!");
            }
        };

        Animal cat = new Animal() {
            @Override
            void makeSound() {
                System.out.println("🐱 야옹~");
            }
        };

        Animal bird = new Animal() {
            @Override
            void makeSound() {
                System.out.println("🐦 짹짹!");
            }
        };

        dog.makeSound();
        cat.makeSound();
        bird.makeSound();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 예제 3: 메서드 파라미터로 전달
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("예제 3: 메서드 파라미터로 익명 클래스 전달");
        System.out.println("=".repeat(50));

        CafeOrder order1 = new CafeOrder("아메리카노", 4500);

        // 익명 내부 클래스를 직접 파라미터로 전달
        order1.processOrder(new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("  👋 " + name + ", 주문 감사합니다!");
                System.out.println("  잠시만 기다려주세요.");
            }
        });

        order1.serveWithMessage();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 예제 4: 익명 클래스에서 외부 변수 접근
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("예제 4: 외부 변수 접근 (final/effectively final)");
        System.out.println("=".repeat(50) + "\n");

        final String storeName = "스타벅스";
        int discountRate = 10;  // effectively final

        Greeting vipGreeting = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("🌟 VIP " + name + "님, " + storeName + "에 오신 것을 환영합니다!");
                System.out.println("오늘은 " + discountRate + "% 할인 혜택이 있습니다!");
                // discountRate = 20;  // 컴파일 에러! (effectively final 위반)
            }
        };

        vipGreeting.greet("김회원");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // Lambda vs Anonymous Class 비교
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("🔍 Lambda vs Anonymous Class 비교");
        System.out.println("=".repeat(50) + "\n");

        // Anonymous Inner Class 방식
        Greeting anonymous = new Greeting() {
            @Override
            public void greet(String name) {
                System.out.println("익명 클래스: 안녕, " + name);
            }
        };

        // Lambda 방식 (Java 8+)
        Greeting lambda = (name) -> System.out.println("람다: 안녕, " + name);

        anonymous.greet("철수");
        lambda.greet("영희");

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 Anonymous Inner Class 핵심:");
        System.out.println("1. 클래스 이름이 없음 (일회용)");
        System.out.println("2. 선언과 동시에 인스턴스 생성");
        System.out.println("3. 인터페이스 구현 또는 클래스 상속");
        System.out.println("4. 단 하나의 인터페이스/클래스만 구현/상속 가능");

        System.out.println("\n📊 Anonymous Class vs Lambda:");

        System.out.println("\n✅ Anonymous Class:");
        System.out.println("  - 여러 메서드 구현 가능");
        System.out.println("  - 상태(필드) 가질 수 있음");
        System.out.println("  - this는 익명 클래스 자신");
        System.out.println("  - 코드가 길고 verbose");

        System.out.println("\n✅ Lambda (Java 8+):");
        System.out.println("  - Functional Interface만 가능 (메서드 1개)");
        System.out.println("  - 상태 가질 수 없음");
        System.out.println("  - this는 외부 클래스");
        System.out.println("  - 간결하고 읽기 쉬움");

        System.out.println("\n🎯 사용 시나리오:");
        System.out.println("- 이벤트 핸들러 (GUI 프로그래밍)");
        System.out.println("- Comparator, Runnable 등 일회성 구현");
        System.out.println("- 콜백 함수");
        System.out.println("- 간단한 알고리즘 커스터마이징");
    }
}
```

**실행 결과:**
```
=== Anonymous Inner Class - 일회용 컵 비유 ===

==================================================
예제 1: 인터페이스 즉석 구현
==================================================
안녕하세요, 김철수님!
Hello, John!
야, 친구!

==================================================
예제 2: 추상 클래스 즉석 구현
==================================================

🐕 멍멍!
🐱 야옹~
🐦 짹짹!

==================================================
예제 3: 메서드 파라미터로 익명 클래스 전달
==================================================

☕ 주문 접수:
  메뉴: 아메리카노
  가격: 4500원
  👋 고객님, 주문 감사합니다!
  잠시만 기다려주세요.
  🎉 고객님, 아메리카노 나왔습니다!
  맛있게 드세요!

==================================================
예제 4: 외부 변수 접근 (final/effectively final)
==================================================

🌟 VIP 김회원님, 스타벅스에 오신 것을 환영합니다!
오늘은 10% 할인 혜택이 있습니다!

==================================================
🔍 Lambda vs Anonymous Class 비교
==================================================

익명 클래스: 안녕, 철수
람다: 안녕, 영희

==================================================

💡 Anonymous Inner Class 핵심:
1. 클래스 이름이 없음 (일회용)
2. 선언과 동시에 인스턴스 생성
3. 인터페이스 구현 또는 클래스 상속
4. 단 하나의 인터페이스/클래스만 구현/상속 가능

📊 Anonymous Class vs Lambda:

✅ Anonymous Class:
  - 여러 메서드 구현 가능
  - 상태(필드) 가질 수 있음
  - this는 익명 클래스 자신
  - 코드가 길고 verbose

✅ Lambda (Java 8+):
  - Functional Interface만 가능 (메서드 1개)
  - 상태 가질 수 없음
  - this는 외부 클래스
  - 간결하고 읽기 쉬움

🎯 사용 시나리오:
- 이벤트 핸들러 (GUI 프로그래밍)
- Comparator, Runnable 등 일회성 구현
- 콜백 함수
- 간단한 알고리즘 커스터마이징
```

### 핵심 정리
- Anonymous Inner Class는 **이름이 없는** 일회용 클래스
- **선언과 동시에 인스턴스 생성**
- 인터페이스 구현 또는 클래스 상속
- Java 8 이후에는 **Lambda**로 대체 가능 (Functional Interface)

---

## 🎮 비유 5: 내부 클래스 활용 - 게임 캐릭터 인벤토리

### 실생활 비유
**게임 캐릭터(외부 클래스)와 인벤토리 아이템(내부 클래스)**의 관계처럼,
내부 클래스를 활용하면 **강한 응집도(High Cohesion)**를 가진 설계가 가능합니다.

### 코드로 이해하기

```java
// 📁 InnerClassRealWorldExample.java

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

class GameCharacter {
    private String name;
    private int level;
    private int gold;

    public GameCharacter(String name) {
        this.name = name;
        this.level = 1;
        this.gold = 100;
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Member Inner Class - Item 클래스
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    class Item {
        private String itemName;
        private int itemValue;
        private String itemType;

        public Item(String itemName, int itemValue, String itemType) {
            this.itemName = itemName;
            this.itemValue = itemValue;
            this.itemType = itemType;
        }

        public void use() {
            System.out.println(name + "이(가) " + itemName + "을(를) 사용했습니다");

            switch (itemType) {
                case "POTION":
                    System.out.println("  체력이 회복되었습니다!");
                    break;
                case "WEAPON":
                    System.out.println("  공격력이 증가했습니다!");
                    break;
                case "ARMOR":
                    System.out.println("  방어력이 증가했습니다!");
                    break;
            }
        }

        public void sell() {
            gold += itemValue;  // 외부 클래스의 필드 수정 가능!
            System.out.println(itemName + "을(를) " + itemValue + "골드에 판매했습니다");
            System.out.println("현재 골드: " + gold);
        }

        @Override
        public String toString() {
            return String.format("[%s] %s (가치: %d골드)", itemType, itemName, itemValue);
        }
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ Member Inner Class - Inventory 클래스
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    class Inventory implements Iterable<Item> {
        private List<Item> items = new ArrayList<>();
        private int maxSize = 10;

        public void addItem(String itemName, int itemValue, String itemType) {
            if (items.size() >= maxSize) {
                System.out.println("⚠️ 인벤토리가 가득 찼습니다!");
                return;
            }

            Item item = new Item(itemName, itemValue, itemType);
            items.add(item);
            System.out.println("✅ " + itemName + "을(를) 획득했습니다!");
        }

        public void showInventory() {
            System.out.println("\n📦 " + name + "의 인벤토리 (" + items.size() + "/" + maxSize + "):");
            System.out.println("  골드: " + gold);
            System.out.println("  아이템:");

            if (items.isEmpty()) {
                System.out.println("    (비어있음)");
                return;
            }

            for (int i = 0; i < items.size(); i++) {
                System.out.println("    " + (i + 1) + ". " + items.get(i));
            }
        }

        public Item getItem(int index) {
            if (index < 0 || index >= items.size()) {
                return null;
            }
            return items.get(index);
        }

        public void removeItem(int index) {
            if (index >= 0 && index < items.size()) {
                items.remove(index);
            }
        }

        // Iterator 패턴 구현 (Local Inner Class 활용)
        @Override
        public Iterator<Item> iterator() {
            // ✅ Local Inner Class
            class InventoryIterator implements Iterator<Item> {
                private int currentIndex = 0;

                @Override
                public boolean hasNext() {
                    return currentIndex < items.size();
                }

                @Override
                public Item next() {
                    return items.get(currentIndex++);
                }
            }

            return new InventoryIterator();
        }
    }

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 외부 클래스 메서드
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    public Inventory createInventory() {
        return new Inventory();
    }

    public void showStatus() {
        System.out.println("\n⚔️ 캐릭터 정보:");
        System.out.println("  이름: " + name);
        System.out.println("  레벨: " + level);
        System.out.println("  골드: " + gold);
    }

    public void levelUp() {
        level++;
        System.out.println("\n🎉 레벨 업! (레벨 " + level + ")");
    }
}

public class InnerClassRealWorldExample {
    public static void main(String[] args) {
        System.out.println("=== 내부 클래스 활용 - 게임 캐릭터 인벤토리 ===\n");

        // 캐릭터 생성
        GameCharacter character = new GameCharacter("용사 김철수");
        character.showStatus();

        // 인벤토리 생성
        GameCharacter.Inventory inventory = character.createInventory();

        // 아이템 추가
        System.out.println("\n" + "=".repeat(50));
        System.out.println("아이템 획득");
        System.out.println("=".repeat(50) + "\n");

        inventory.addItem("체력 물약", 50, "POTION");
        inventory.addItem("강철 검", 200, "WEAPON");
        inventory.addItem("가죽 갑옷", 150, "ARMOR");
        inventory.addItem("마나 물약", 60, "POTION");
        inventory.addItem("롱소드", 350, "WEAPON");

        // 인벤토리 확인
        inventory.showInventory();

        // 아이템 사용
        System.out.println("\n" + "=".repeat(50));
        System.out.println("아이템 사용");
        System.out.println("=".repeat(50) + "\n");

        GameCharacter.Item potion = inventory.getItem(0);
        if (potion != null) {
            potion.use();
        }

        // 아이템 판매
        System.out.println("\n" + "=".repeat(50));
        System.out.println("아이템 판매");
        System.out.println("=".repeat(50) + "\n");

        GameCharacter.Item weapon = inventory.getItem(1);
        if (weapon != null) {
            weapon.sell();
            inventory.removeItem(1);
        }

        // Iterator로 순회
        System.out.println("\n" + "=".repeat(50));
        System.out.println("Iterator로 전체 아이템 순회");
        System.out.println("=".repeat(50) + "\n");

        System.out.println("남은 아이템:");
        for (GameCharacter.Item item : inventory) {
            System.out.println("  • " + item);
        }

        // 최종 상태
        character.levelUp();
        character.showStatus();

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // 핵심 정리
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

        System.out.println("\n" + "=".repeat(50));
        System.out.println("\n💡 내부 클래스 활용의 장점:");
        System.out.println("1. 강한 응집도 (High Cohesion)");
        System.out.println("   - Item은 GameCharacter와 밀접하게 관련");
        System.out.println("   - 논리적으로 하나의 단위로 묶임");

        System.out.println("\n2. 캡슐화 (Encapsulation)");
        System.out.println("   - Item과 Inventory는 GameCharacter에만 의미 있음");
        System.out.println("   - 외부에 불필요한 클래스 노출 방지");

        System.out.println("\n3. 코드 가독성");
        System.out.println("   - 관련된 클래스를 한 곳에 모음");
        System.out.println("   - 네임스페이스 오염 방지");

        System.out.println("\n4. 외부 클래스 멤버 접근");
        System.out.println("   - Item이 character의 gold에 직접 접근");
        System.out.println("   - getter/setter 없이 자연스러운 협력");

        System.out.println("\n🌟 실무 활용 사례:");
        System.out.println("  - LinkedList.Node (연결 리스트의 노드)");
        System.out.println("  - HashMap.Entry (맵의 엔트리)");
        System.out.println("  - ArrayList.Iterator (컬렉션 순회)");
        System.out.println("  - Builder 패턴 (객체 생성)");
    }
}
```

**실행 결과:**
```
=== 내부 클래스 활용 - 게임 캐릭터 인벤토리 ===

⚔️ 캐릭터 정보:
  이름: 용사 김철수
  레벨: 1
  골드: 100

==================================================
아이템 획득
==================================================

✅ 체력 물약을(를) 획득했습니다!
✅ 강철 검을(를) 획득했습니다!
✅ 가죽 갑옷을(를) 획득했습니다!
✅ 마나 물약을(를) 획득했습니다!
✅ 롱소드을(를) 획득했습니다!

📦 용사 김철수의 인벤토리 (5/10):
  골드: 100
  아이템:
    1. [POTION] 체력 물약 (가치: 50골드)
    2. [WEAPON] 강철 검 (가치: 200골드)
    3. [ARMOR] 가죽 갑옷 (가치: 150골드)
    4. [POTION] 마나 물약 (가치: 60골드)
    5. [WEAPON] 롱소드 (가치: 350골드)

==================================================
아이템 사용
==================================================

용사 김철수이(가) 체력 물약을(를) 사용했습니다
  체력이 회복되었습니다!

==================================================
아이템 판매
==================================================

강철 검을(를) 200골드에 판매했습니다
현재 골드: 300

==================================================
Iterator로 전체 아이템 순회
==================================================

남은 아이템:
  • [POTION] 체력 물약 (가치: 50골드)
  • [ARMOR] 가죽 갑옷 (가치: 150골드)
  • [POTION] 마나 물약 (가치: 60골드)
  • [WEAPON] 롱소드 (가치: 350골드)

🎉 레벨 업! (레벨 2)

⚔️ 캐릭터 정보:
  이름: 용사 김철수
  레벨: 2
  골드: 300

==================================================

💡 내부 클래스 활용의 장점:
1. 강한 응집도 (High Cohesion)
   - Item은 GameCharacter와 밀접하게 관련
   - 논리적으로 하나의 단위로 묶임

2. 캡슐화 (Encapsulation)
   - Item과 Inventory는 GameCharacter에만 의미 있음
   - 외부에 불필요한 클래스 노출 방지

3. 코드 가독성
   - 관련된 클래스를 한 곳에 모음
   - 네임스페이스 오염 방지

4. 외부 클래스 멤버 접근
   - Item이 character의 gold에 직접 접근
   - getter/setter 없이 자연스러운 협력

🌟 실무 활용 사례:
  - LinkedList.Node (연결 리스트의 노드)
  - HashMap.Entry (맵의 엔트리)
  - ArrayList.Iterator (컬렉션 순회)
  - Builder 패턴 (객체 생성)
```

---

## 🎓 전체 요약

### 4가지 내부 클래스 정리

| 종류 | 정의 위치 | 외부 인스턴스 필요 | 외부 멤버 접근 | 생성 방법 |
|-----|---------|-----------------|-------------|---------|
| Member Inner | 클래스 안 | O | 모든 멤버 | `outer.new Inner()` |
| Static Nested | 클래스 안 (static) | X | static만 | `new Outer.Nested()` |
| Local Inner | 메서드 안 | O | 모든 멤버 + final 지역 변수 | 메서드 안에서만 |
| Anonymous | 어디든지 | O | 상황에 따라 다름 | `new Interface() {}` |

### 선택 가이드

**Member Inner Class 사용:**
- 외부 클래스의 인스턴스 멤버 접근 필요
- Iterator, Builder 패턴

**Static Nested Class 사용:**
- 외부 클래스의 static 멤버만 필요
- 논리적 그룹화만 필요
- 메모리 효율 중요

**Local Inner Class 사용:**
- 메서드 내에서만 사용
- 복잡한 로직 캡슐화

**Anonymous Inner Class 사용:**
- 일회성 구현
- 이벤트 핸들러, 콜백
- Functional Interface는 Lambda 사용 권장

---

**📌 다음 Part 2에서는**
기업 사례와 주니어 개발자 시나리오를 통해 내부 클래스의 실전 활용법을 배웁니다!
