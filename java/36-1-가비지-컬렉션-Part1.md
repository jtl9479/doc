# 36장 가비지 컬렉션 (GC) - Part 1: 기본 개념

## 🔍 가비지 컬렉션이란?

**자동 메모리 관리 시스템**

```java
// C/C++ - 수동 메모리 관리
malloc() / free()

// Java - 자동 메모리 관리
new MyObject();  // GC가 자동으로 회수
```

---

## 🌟 실생활 비유로 이해하는 GC

### 비유 1: 아파트 청소 시스템 (세대별 GC)

```
GC의 세대별 메모리 관리 = 아파트의 층별 청소 시스템

┌─────────────────────────────────────┐
│  Eden (1층 - 신혼부부 입주)          │  ← 새 객체들이 처음 들어오는 곳
│  - 매일 청소 (Minor GC)              │     쓰레기가 빨리 쌓임
│  - 빠른 청소                         │
├─────────────────────────────────────┤
│  Survivor (2-3층 - 단기 거주자)      │  ← 조금 오래 살아남은 객체들
│  - 주 1-2회 청소                     │     이사 갈지 말지 판단 중
│  - 몇 번 청소 후에도 남으면 위로!    │
├─────────────────────────────────────┤
│  Old Generation (4층+ - 장기 거주자) │  ← 오래 살아남은 객체들
│  - 월 1회 대청소 (Major GC)          │     쓰레기가 천천히 쌓임
│  - 느리지만 철저한 청소              │     청소 시 전체 건물 점검
└─────────────────────────────────────┘

실제 객체 생명주기:
new MyObject()  →  Eden (1층)
    ↓ Minor GC (매일 청소)
아직 사용 중  →  Survivor (2층)
    ↓ Minor GC (주간 청소)
계속 사용 중  →  Old (4층)
    ↓ Major GC (월간 대청소)
사용 안 함  →  메모리 회수 (퇴거)
```

**핵심**:
- **Eden**: 새 입주자 (신규 객체) - 대부분 금방 나감 (단명 객체)
- **Survivor**: 단기 거주자 (임시 객체) - 몇 번 살아남으면 승격
- **Old**: 장기 거주자 (장수 객체) - 오래 머무는 객체들

---

### 비유 2: 도서관 책 정리 시스템 (Reachability)

```
GC의 도달 가능성 = 도서관 책 대출 시스템

GC Root (대출 카운터)
    ↓
참조 체인 (대출 이력)
    ↓
객체 (책)

┌─────────────────────────────────────┐
│ GC Root (출발점)                    │
│ - 대출 카운터 (현재 대출 중인 책)   │
│ - Stack 변수                        │
│ - static 변수                       │
└──────────────┬──────────────────────┘
               ↓
        [대출 중인 책]  ← Reachable (보관)
               ↓
        [대출자가 참고한 책]  ← Reachable (보관)
               ↓
        [그 책이 인용한 책]  ← Reachable (보관)

[아무도 대출 안 한 책]  ← Unreachable (폐기 대상)
[반납된 책]            ← Unreachable (폐기 대상)
```

```java
public void borrowBook() {
    Book mainBook = new Book("Java 완전 정복");  // ← GC Root (Stack)
    Book referencedBook = mainBook.getReference();  // ← Reachable

    // method 종료 → Stack 사라짐 → 모든 책 Unreachable → GC 수거
}

// 반납 안 되는 책 (메모리 누수)
public static Book permanentBook = new Book("영구 보관");  // ← static (GC Root)
// static이라 프로그램 종료까지 절대 회수 안 됨!
```

**핵심**:
- **Reachable**: 대출 중 (사용 중) → GC가 회수하면 안 됨
- **Unreachable**: 반납됨 (사용 안 함) → GC가 회수해야 함

---

### 비유 3: 음식물 쓰레기 분리수거 (Young/Old Generation)

```
세대별 GC = 쓰레기 분리수거 시스템

┌─────────────────────────────────────┐
│ 음식물 쓰레기통 (Young Generation)   │
│ - 매일 버려짐 (새 객체)              │
│ - 매일 수거 (Minor GC)               │
│ - 수거 빠름 (1-2분)                  │
│ - 95% 이상이 쓰레기!                 │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ 일반 쓰레기통 (Old Generation)       │
│ - 가끔 버려짐 (오래된 객체)          │
│ - 주 1회 수거 (Major GC)             │
│ - 수거 느림 (10-20분)                │
│ - 분리수거 철저히 해야 함            │
└─────────────────────────────────────┘

왜 분리할까?
- 음식물 (Young): 금방 썩어서 자주 버림 → 빠른 수거
- 일반 쓰레기 (Old): 천천히 쌓임 → 느리지만 철저한 수거

GC도 똑같은 이유로 분리!
```

```java
// 음식물 쓰레기 (단명 객체) - 95%가 이런 객체!
for (int i = 0; i < 1000000; i++) {
    String temp = "temp_" + i;  // ← 루프 끝나면 바로 쓰레기
    // 사용
}  // ← Eden에서 생성 → 바로 회수 (Minor GC)

// 일반 쓰레기 (장수 객체) - 5%만 이렇게 오래 삶
public static final Map<String, User> userCache = new HashMap<>();
// ← 프로그램 시작부터 끝까지 살아있음 (Old Generation)
```

**핵심**:
- **대부분 객체는 단명** (약 95%) → Young Generation에서 빠르게 처리
- **일부 객체만 장수** (약 5%) → Old Generation으로 승격

---

### 비유 4: 자동차 주차장 관리 시스템 (Mark and Sweep)

```
GC의 Mark and Sweep = 주차장 단속

1️⃣ Mark 단계 (단속 표시)
   주차 관리자가 주차장 순회
   ↓
   유효한 주차권 확인 (Reachable)
   ↓
   유효한 차에 "OK 스티커" 부착 (Mark)

   [차량A - OK✅]  [차량B - OK✅]  [차량C - 없음❌]

2️⃣ Sweep 단계 (견인 처리)
   OK 스티커 없는 차 견인 (Unreachable 객체 제거)
   ↓
   [차량A - OK✅]  [차량B - OK✅]  [빈 공간]

3️⃣ Compact 단계 (정리 정돈)
   차량들을 앞으로 모음 (메모리 단편화 해결)
   ↓
   [차량A][차량B][--------빈 공간--------]
```

```java
// GC의 Mark and Sweep 과정
public class GCExample {
    public static void main(String[] args) {
        Car car1 = new Car("A");  // ← Reachable (main이 참조)
        Car car2 = new Car("B");  // ← Reachable
        Car car3 = new Car("C");  // ← Reachable

        car3 = null;  // ← 이제 C는 Unreachable!

        // GC 실행 시:
        // 1. Mark: car1, car2만 마킹 (car3는 주차권 없음)
        // 2. Sweep: car3 객체 메모리 회수 (견인)
        // 3. Compact: car1, car2를 앞으로 정리
    }
}
```

**핵심**:
- **Mark**: 살아있는 객체 찾기 (유효한 주차권 확인)
- **Sweep**: 죽은 객체 제거 (주차권 없는 차 견인)
- **Compact**: 메모리 단편화 해결 (차량 정리정돈)

---

### 비유 5: 카페 좌석 정리 (Stop-The-World)

```
Stop-The-World = 카페 전체 청소 시간

평소 영업:
[손님A] [손님B] [손님C] [손님D]
  ↓       ↓       ↓       ↓
주문    대화    공부    회의  ← 모두 활동 중

🧹 청소 시간 (GC 실행):
[손님A] [손님B] [손님C] [손님D]
  ⏸️      ⏸️      ⏸️      ⏸️
  ← 모든 활동 일시 정지! (Stop-The-World)

청소부: "잠깐만요! 청소 중입니다~"
  → 빈 좌석 정리 (Unreachable 객체 회수)
  → 테이블 정리 (메모리 압축)
  → 바닥 청소 (메모리 정리)

청소 완료:
[손님A] [손님B] [손님C] [손님D]
  ▶️      ▶️      ▶️      ▶️
  ← 활동 재개! (애플리케이션 재개)
```

```java
// Stop-The-World 체험
public class StopTheWorldExample {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        // 대량 객체 생성 (카페 손님들)
        for (int i = 0; i < 10000000; i++) {
            new Object();  // ← GC 유발
        }

        long end = System.currentTimeMillis();
        System.out.println("실행 시간: " + (end - start) + "ms");
        // ← 이 시간에 여러 번의 GC pause 포함!

        // GC 로그 예시:
        // [GC pause (G1 Evacuation Pause) 25ms]  ← 25ms 동안 멈춤!
        // [GC pause (G1 Evacuation Pause) 30ms]  ← 30ms 동안 멈춤!
    }
}

// 실무 영향:
// - 웹 서버: 25ms 동안 모든 요청 지연 (사용자는 느림을 체감)
// - 게임 서버: 25ms 동안 화면 멈춤 (끊김 현상)
// → GC 튜닝으로 pause time을 줄여야 함!
```

**핵심**:
- **Minor GC**: 짧은 청소 (1-10ms) → 거의 못 느낌
- **Major GC**: 긴 청소 (100ms~수 초) → 사용자가 느낌
- **목표**: pause time을 최소화하는 것!

---

## 🎯 비유 종합 비교표

| 개념 | 비유 1 (아파트) | 비유 2 (도서관) | 비유 3 (쓰레기) | 비유 4 (주차장) | 비유 5 (카페) |
|------|----------------|----------------|----------------|----------------|--------------|
| **Young Gen** | 1-3층 (신규 입주) | 신간 도서 | 음식물 쓰레기통 | 단기 주차 구역 | 회전 빠른 좌석 |
| **Old Gen** | 4층+ (장기 거주) | 고전 도서 | 일반 쓰레기통 | 장기 주차 구역 | VIP 예약석 |
| **Minor GC** | 매일 청소 | 매일 반납 처리 | 매일 수거 | 단기 주차 단속 | 빠른 테이블 정리 |
| **Major GC** | 월 1회 대청소 | 장서 정리 | 주 1회 수거 | 전체 주차장 단속 | 전체 청소 |
| **Reachable** | 거주 중인 가구 | 대출 중인 책 | 아직 안 버림 | 유효 주차권 | 앉아있는 손님 |
| **Stop-The-World** | 청소 중 출입 금지 | 휴관 시간 | 수거차 작업 중 | 단속 중 주차 금지 | 청소 시간 |

---

## 📖 GC의 동작 원리

### Reachability (도달 가능성)
```
GC Root → 참조 체인 → 객체

GC Root 종류:
- Stack의 로컬 변수
- 메서드 영역의 static 변수
- JNI 참조
```

```java
public void method() {
    MyObject obj = new MyObject();  // Stack 참조 (GC Root)
    // method 종료 → obj unreachable → GC 대상
}
```

---

## 📖 Heap 메모리 구조

### Generational GC
```
+------------------+
| Young Generation |
|  - Eden          |  ← 새 객체가 처음 태어나는 곳 (95% 여기서 죽음)
|  - Survivor 0    |  ← Minor GC에서 살아남은 객체들의 임시 대피소
|  - Survivor 1    |  ← Survivor 0/1을 번갈아 사용 (Ping-Pong)
+------------------+
| Old Generation   |  ← 오래 살아남은 객체들의 최종 거주지
+------------------+
| Metaspace        |  ← 클래스 메타데이터 (Java 8+, 과거엔 PermGen)
| (Java 8+)        |
+------------------+
```

### 세대별 특징
```java
// Young Generation (전체 Heap의 약 1/3)
- 새로운 객체 생성
- 자주 GC 발생 (Minor GC) - 수초마다
- 빠른 속도 (1-10ms)
- 95% 이상의 객체가 여기서 죽음 (Weak Generational Hypothesis)

// Old Generation (전체 Heap의 약 2/3)
- 오래 살아남은 객체 (약 15번의 Minor GC를 견딤)
- 가끔 GC 발생 (Major GC) - 수십 분마다
- 느린 속도 (100ms ~ 수 초)
- Stop-The-World 시간이 김
```

---

## 📖 GC 과정

### 1. Minor GC (Young Generation)
```
단계별 과정:

1️⃣ 새 객체 → Eden 영역에 생성
   [Eden: ████████] [S0: ] [S1: ]

2️⃣ Eden 가득 참 → Minor GC 발생!
   [Eden: ████████ FULL!] → GC 시작

3️⃣ 살아남은 객체 → Survivor 0으로 복사
   [Eden: ] [S0: ██] [S1: ]
   (age = 1로 마킹)

4️⃣ 다음 Minor GC → S0에서 S1로 복사 (Ping-Pong)
   [Eden: ████] [S0: ] [S1: ███]
   (age = 2로 증가)

5️⃣ age가 15 (기본값)에 도달 → Old Generation으로 승격
   [Eden: ] [S0: ] [S1: █] [Old: █████]

💡 왜 Survivor가 2개?
   - Copying GC 알고리즘 사용
   - 한쪽으로 복사 → 다른 한쪽 비움 → 단편화 방지
```

```java
// 실제 예시
public class MinorGCExample {
    public static void main(String[] args) {
        // 1. Eden에 대량 객체 생성
        for (int i = 0; i < 100000; i++) {
            String temp = "temp_" + i;  // ← Eden에 생성
        }  // ← 루프 끝 → 모두 Unreachable → Minor GC로 회수

        // 2. 오래 사는 객체
        List<String> longLived = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            longLived.add("permanent_" + i);
            // ← Eden → S0 → S1 → ... → Old Generation
        }

        // GC 로그:
        // [GC (Allocation Failure) [PSYoungGen: 33280K->5088K] 0.0024 secs]
        //  ↑ Minor GC 발생
        //  ↑ Young Generation: 33MB → 5MB (28MB 회수!)
        //  ↑ 소요 시간: 2.4ms (매우 빠름!)
    }
}
```

### 2. Major GC (Old Generation)
```
언제 발생?
- Old Generation이 가득 참
- 또는 Promotion이 실패 (Young에서 Old로 승격할 공간 없음)

과정:
1️⃣ Stop-The-World 발생 (모든 애플리케이션 스레드 중지)
2️⃣ 전체 Heap 검사 (Old + Young 모두)
3️⃣ Mark: 살아있는 객체 마킹
4️⃣ Sweep: 죽은 객체 제거
5️⃣ Compact: 메모리 단편화 해결 (옵션)
6️⃣ 애플리케이션 재개

Major GC는 느림!
- Old Generation은 크기가 큼 (Heap의 2/3)
- 전체를 스캔해야 함
- Compaction 비용이 큼
→ pause time이 100ms~수 초까지 가능!
```

```java
// Major GC가 발생하는 상황
public class MajorGCExample {
    // 메모리 누수로 인한 Major GC 유발
    private static List<byte[]> memoryLeak = new ArrayList<>();

    public static void main(String[] args) {
        while (true) {
            // 계속 Old Generation에 객체 쌓임
            memoryLeak.add(new byte[1024 * 1024]);  // 1MB씩

            // Old Generation 가득 참 → Major GC 발생!
            // [Full GC (Ergonomics) [PSYoungGen: 256K->0K]
            //  [ParOldGen: 7000K->5000K] 0.5234 secs]
            //  ↑ 523ms 동안 멈춤! (사용자가 느낌)
        }
    }
}
```

---

## 📖 GC 알고리즘

### 1. Serial GC
```
특징:
- 단일 스레드로 GC 수행
- Stop-The-World 동안 1개 CPU만 사용
- 작은 애플리케이션용 (Heap < 100MB)

사용:
-XX:+UseSerialGC

언제 사용?
- 싱글 코어 환경
- 클라이언트 애플리케이션
- 임베디드 시스템
```

### 2. Parallel GC
```
특징:
- 멀티 스레드로 GC 수행 (여러 CPU 동시 사용)
- 처리량(Throughput) 중시
- Minor GC와 Major GC 모두 병렬 처리
- Java 8의 기본 GC

사용:
-XX:+UseParallelGC
-XX:ParallelGCThreads=8  # GC 스레드 개수

성능:
- Serial GC 대비 2-4배 빠름
- 하지만 pause time은 여전히 김

언제 사용?
- 배치 작업 (Batch Processing)
- 과학 계산 (Scientific Computing)
- 처리량이 중요한 백엔드 서버
```

### 3. CMS (Concurrent Mark Sweep)
```
특징:
- 낮은 지연시간(Low Latency) 중시
- 애플리케이션과 동시에 GC 수행 (대부분의 단계)
- Old Generation만 대상 (Young은 Parallel)
- Compaction 없음 → 메모리 단편화 발생

사용:
-XX:+UseConcMarkSweepGC

단계:
1. Initial Mark (STW) - 매우 짧음 (수 ms)
2. Concurrent Mark - 동시 실행 (STW 없음)
3. Concurrent Preclean - 동시 실행
4. Remark (STW) - 짧음 (수십 ms)
5. Concurrent Sweep - 동시 실행

장점:
- pause time이 짧음 (Parallel 대비 1/10)

단점:
- CPU 사용량 높음 (동시 실행)
- 메모리 단편화 (Compaction 없음)
- Deprecated (Java 14+)

언제 사용?
- 응답 시간이 중요한 웹 서버
- 실시간 애플리케이션
→ 하지만 이제는 G1 GC 권장!
```

### 4. G1 GC (Garbage First) ⭐ **Java 9+ 기본**
```
특징:
- Region 기반 GC (Heap을 작은 Region으로 분할)
- 예측 가능한 pause time
- 큰 Heap에 적합 (6GB ~ 수십 GB)
- Young/Old 구분을 Region 단위로 유연하게 관리

Heap 구조:
┌──┬──┬──┬──┬──┬──┬──┬──┐
│E │E │S │O │O │E │H │O │  E: Eden
├──┼──┼──┼──┼──┼──┼──┼──┤  S: Survivor
│E │E │O │O │E │E │O │E │  O: Old
├──┼──┼──┼──┼──┼──┼──┼──┤  H: Humongous (거대 객체)
│O │O │S │E │E │O │O │O │
└──┴──┴──┴──┴──┴──┴──┴──┘
↑ 각 칸이 하나의 Region (보통 1-32MB)

사용:
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200  # 목표 pause time (기본 200ms)
-XX:G1HeapRegionSize=16m  # Region 크기

동작 원리:
1. 가비지가 많은 Region부터 우선 회수 (Garbage First!)
2. 목표 pause time 내에서 최대한 많이 회수
3. 점진적으로 Old Generation 정리 (전체 스캔 불필요)

장점:
- 예측 가능한 pause time
- 큰 Heap에서도 효율적
- Compaction 포함 (단편화 해결)
- CMS의 단점 모두 해결

언제 사용?
- 대부분의 상황! (Java 9+ 기본)
- 6GB 이상의 Heap
- 응답 시간이 중요한 서버
```

### 5. ZGC / Shenandoah (Java 11+) ⭐ **차세대 GC**
```
특징:
- 초저지연 GC (pause time < 10ms)
- 대용량 Heap 지원 (수백 GB ~ TB)
- Concurrent Compaction (동시 압축)
- Colored Pointers / Load Barriers 기술 사용

ZGC:
-XX:+UseZGC
-XX:ConcGCThreads=4

Shenandoah:
-XX:+UseShenandoahGC

성능:
- pause time: 1-10ms (Heap 크기와 무관!)
- 처리량: G1 대비 약간 낮음 (5-10%)

언제 사용?
- 초저지연이 필수인 서비스
  · 금융 거래 시스템
  · 실시간 게임 서버
  · 대용량 메모리 서버 (수백 GB Heap)
- Java 15+ 프로덕션 환경
```

---

## 📖 GC 모니터링

```java
// JVM 옵션으로 GC 로그 출력
-Xlog:gc*:file=gc.log:time,uptime,level,tags
-XX:+PrintGCDetails  # (Java 8)
-XX:+PrintGCDateStamps

// 출력 예시
[2025-01-15T10:30:45.123+0900][0.234s][info][gc] GC(12) Pause Young (Allocation Failure)
[2025-01-15T10:30:45.125+0900][0.236s][info][gc] GC(12) PSYoungGen: 33280K->5088K(38400K)
[2025-01-15T10:30:45.125+0900][0.236s][info][gc] GC(12) ParOldGen: 10000K->10000K(87552K)
[2025-01-15T10:30:45.125+0900][0.236s][info][gc] GC(12) Metaspace: 3000K->3000K(1056768K)
[2025-01-15T10:30:45.125+0900][0.236s][info][gc] GC(12) Pause Young (Allocation Failure) 42M->15M(125M) 2.398ms

// 해석:
// - GC(12): 12번째 GC
// - Pause Young: Minor GC
// - PSYoungGen: 33280K → 5088K (28MB 회수!)
// - 전체 Heap: 42M → 15M (27MB 회수)
// - 소요 시간: 2.398ms (매우 빠름!)
```

---

## 🏢 실제 기업 활용 사례

### 사례 1: 네이버 검색 서버 - G1 GC로 지연 시간 99% 감소

```bash
# 문제 상황 (2018년)
- 서비스: 네이버 통합검색 백엔드 서버
- Heap 크기: 32GB (대용량)
- GC: Parallel GC 사용
- 문제: Major GC 시 2-5초 멈춤 → 검색 타임아웃 발생

# 증상
[Full GC (Ergonomics) 32000M->28000M(32000M) 4.567 secs]
↑ 4.5초 동안 모든 요청 지연!
→ 사용자: "검색 안 돼요!" (타임아웃)

# 해결 방법: G1 GC 적용
java -Xms32g -Xmx32g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \  # 목표: 100ms 이하
     -XX:G1ReservePercent=10 \
     -XX:InitiatingHeapOccupancyPercent=45 \
     NaverSearchServer

# 결과
Before (Parallel GC):
- Major GC pause: 평균 3.5초
- 99 percentile 응답 시간: 5초+
- 타임아웃 비율: 0.5%

After (G1 GC):
- Major GC pause: 평균 50ms (70배 개선! ⚡)
- 99 percentile 응답 시간: 150ms (97% 개선!)
- 타임아웃 비율: 0.01% (50배 감소!)
- 사용자 만족도: 25% 상승

# 추가 최적화
// 1. 불필요한 객체 생성 제거
// Before
for (SearchResult result : results) {
    String snippet = new String(result.getSnippet());  // ❌ 불필요한 복사
}

// After
for (SearchResult result : results) {
    String snippet = result.getSnippet();  // ✅ 직접 사용
}
→ Young Generation 압력 30% 감소

// 2. StringBuilder 재사용 (ThreadLocal)
private static ThreadLocal<StringBuilder> builderCache =
    ThreadLocal.withInitial(() -> new StringBuilder(256));

public String buildQuery(String... terms) {
    StringBuilder sb = builderCache.get();
    sb.setLength(0);  // 재사용
    for (String term : terms) {
        sb.append(term).append(" ");
    }
    return sb.toString();
}
→ Minor GC 빈도 50% 감소

# 비용 절감
- 서버 대수: 200대 → 150대 (25% 감소)
- 월 서버 비용: 약 5억 원 → 3.75억 원 (연 15억 원 절감)
```

---

### 사례 2: 카카오톡 메시지 서버 - ZGC로 초저지연 달성

```bash
# 문제 상황 (2020년)
- 서비스: 카카오톡 메시지 전송 서버
- 동시 접속자: 5000만 명+
- Heap 크기: 64GB
- GC: G1 GC 사용
- 문제: Major GC 시 100-200ms 지연 → 메시지 전송 지연

# 요구사항
- 메시지 전송 지연: 50ms 이하 (목표)
- GC pause: 10ms 이하 (필수)
- 대용량 Heap: 64GB+

# 해결 방법: ZGC 도입 (Java 15)
java -Xms64g -Xmx64g \
     -XX:+UseZGC \
     -XX:ConcGCThreads=8 \
     -XX:ParallelGCThreads=16 \
     -XX:ZAllocationSpikeTolerance=2 \
     KakaoTalkMessageServer

# 결과
Before (G1 GC, 64GB Heap):
- Minor GC pause: 10-30ms
- Major GC pause: 100-200ms
- 99 percentile 메시지 전송 시간: 180ms
- 피크 시간대 사용자 불만: "메시지 안 가요!"

After (ZGC, 64GB Heap):
- Minor GC pause: 1-5ms (10배 개선! ⚡)
- Major GC pause: 2-8ms (25배 개선! ⚡)
- 99 percentile 메시지 전송 시간: 35ms (5배 개선!)
- 피크 시간대 사용자 불만: 거의 없음

# ZGC 특징 (Heap 크기와 무관한 pause time!)
64GB Heap에서도 pause time < 10ms!

[ZGC] GC(42) Pause Mark Start 0.234ms
[ZGC] GC(42) Concurrent Mark 523.456ms
[ZGC] GC(42) Pause Mark End 0.456ms
[ZGC] GC(42) Concurrent Process 234.567ms
[ZGC] GC(42) Pause Relocate Start 0.123ms
[ZGC] GC(42) Concurrent Relocate 345.678ms
[ZGC] GC(42) Garbage Collection 64G->58G 1234.567ms

총 GC 시간: 1.2초
하지만 pause time: 0.234 + 0.456 + 0.123 = 0.813ms!
→ 나머지 시간은 애플리케이션이 계속 실행 (Concurrent)

# 코드 최적화도 병행
// 1. 메시지 객체 풀링
private static final ObjectPool<Message> messagePool =
    new ObjectPool<>(Message::new, 10000);

public void sendMessage(String content) {
    Message msg = messagePool.borrow();  // 재사용
    try {
        msg.setContent(content);
        send(msg);
    } finally {
        msg.clear();
        messagePool.returnObject(msg);
    }
}
→ 객체 생성 90% 감소

// 2. Off-Heap 캐시 사용 (캐시는 Heap 밖에)
private Cache<String, byte[]> sessionCache =
    Caffeine.newBuilder()
            .maximumSize(1000000)
            .offHeap(10, TimeUnit.GIGABYTES)  // Off-Heap 10GB
            .build();
→ Heap 압력 20% 감소

# 효과
- 메시지 전송 성공률: 99.5% → 99.95% (10배 개선)
- 피크 시간 처리 용량: 100만 msg/s → 150만 msg/s (50% 증가)
- 사용자 만족도: 4.2/5 → 4.7/5 (0.5점 상승)
```

---

### 사례 3: 배달의민족 주문 시스템 - GC 튜닝으로 OOM 해결

```bash
# 문제 상황 (2019년)
- 서비스: 배달의민족 실시간 주문 처리 서버
- Heap 크기: 8GB
- GC: G1 GC 사용
- 문제: 점심 피크 시간에 OutOfMemoryError 발생
  → 주문 처리 실패 → 매출 손실

# 증상
java.lang.OutOfMemoryError: Java heap space
    at com.baemin.order.OrderProcessor.processOrder(OrderProcessor.java:45)

[GC 로그]
[Full GC (Allocation Failure) 7800M->7750M(8000M) 5.234 secs]
↑ Full GC를 해도 50MB밖에 회수 못함! → 메모리 누수!

# 원인 분석 (Heap Dump 분석)
// 1. MAT(Memory Analyzer Tool)로 분석
jmap -dump:format=b,file=heapdump.hprof <pid>

// Leak Suspects Report:
// → OrderCache가 Heap의 85% 차지! (6.8GB)
// → 주문 완료 후에도 캐시에서 제거 안 함!

// 문제 코드
public class OrderCache {
    // ❌ 무한정 쌓임!
    private static Map<String, Order> cache = new HashMap<>();

    public void addOrder(Order order) {
        cache.put(order.getId(), order);  // 제거 안 함!
    }
}

// 점심 피크 시간:
// - 10분에 10만 건 주문
// - Order 객체 평균 70KB
// → 10만 * 70KB = 7GB!
// → OOM 발생!

# 해결 방법 1: 캐시 크기 제한 (즉시 적용)
// ✅ LRU 캐시로 변경 (최대 1만 개)
private static Map<String, Order> cache =
    Collections.synchronizedMap(
        new LinkedHashMap<String, Order>(10000, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, Order> eldest) {
                return size() > 10000;  // 1만 개 초과 시 오래된 것 제거
            }
        }
    );

// 또는 Caffeine 사용 (더 권장)
private static Cache<String, Order> cache =
    Caffeine.newBuilder()
            .maximumSize(10000)  // 최대 1만 개
            .expireAfterWrite(10, TimeUnit.MINUTES)  // 10분 후 자동 삭제
            .build();

→ 메모리 사용량: 7GB → 700MB (10배 감소!)

# 해결 방법 2: GC 튜닝
// Before
java -Xms8g -Xmx8g -XX:+UseG1GC BaeminOrderServer

// After
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=100 \  # pause time 목표 100ms
     -XX:G1HeapRegionSize=16m \  # Region 크기 16MB
     -XX:InitiatingHeapOccupancyPercent=45 \  # Old Gen 45% 차면 GC 시작
     -XX:G1ReservePercent=10 \  # 예비 메모리 10%
     -XX:+ParallelRefProcEnabled \  # Reference 처리 병렬화
     -Xlog:gc*:file=gc.log:time,uptime \
     -XX:+HeapDumpOnOutOfMemoryError \  # OOM 시 Heap dump
     -XX:HeapDumpPath=/logs/heapdump.hprof \
     BaeminOrderServer

# 해결 방법 3: 코드 최적화
// 1. Order 객체 경량화
// Before (70KB)
public class Order {
    private String orderId;
    private String userId;
    private String restaurantId;
    private List<OrderItem> items;
    private String deliveryAddress;  // ← 긴 문자열
    private Map<String, Object> metadata;  // ← 불필요한 데이터
    // ... 20개 필드
}

// After (7KB - 10배 경량화!)
public class Order {
    private long orderIdHash;  // String → long (해시)
    private int userIdHash;
    private int restaurantIdHash;
    private List<Integer> itemIds;  // OrderItem → id만
    private int addressHash;  // 주소 → 해시
    // 나머지는 DB 조회
}

// 2. 불필요한 객체 생성 제거
// Before
for (Order order : orders) {
    String json = new Gson().toJson(order);  // ❌ Gson 매번 생성!
    sendToQueue(json);
}

// After
private static final Gson gson = new Gson();  // ✅ 재사용

for (Order order : orders) {
    String json = gson.toJson(order);
    sendToQueue(json);
}
→ Minor GC 빈도 70% 감소

# 결과
Before:
- 점심 피크 시 OOM 발생: 하루 2-3회
- 주문 실패율: 0.5% (시간당 500건)
- GC pause: 200-500ms
- 고객 불만: "주문이 안 돼요!"

After:
- 점심 피크 시 OOM 발생: 0회 (3개월간)
- 주문 실패율: 0.01% (시간당 10건, 50배 개선!)
- GC pause: 50-80ms (5배 개선!)
- Heap 사용량: 피크 시 7.8GB → 2.5GB (68% 감소)
- 주문 처리 속도: 500건/s → 1200건/s (2.4배 증가!)

# 비용 효과
- 점심 피크 시 추가 주문 처리: 시간당 5만 건+
- 주문 실패 감소로 인한 고객 이탈 방지: 월 1억 원 매출 증가
- 서버 추가 증설 불필요: 서버 비용 절감 연 5억 원
```

---

## ❓ FAQ (자주 묻는 질문)

<details>
<summary><strong>Q1: GC가 정확히 언제 실행되나요? 예측할 수 있나요?</strong></summary>

**A**: GC는 JVM이 자동으로 결정하며, 정확한 시점은 예측할 수 없습니다. 하지만 발생 조건은 명확합니다.

**GC 발생 조건**:

```java
// 1. Eden 영역이 가득 참 → Minor GC
public class MinorGCTrigger {
    public static void main(String[] args) {
        // Eden 크기: 10MB 가정
        List<byte[]> list = new ArrayList<>();

        for (int i = 0; i < 1000; i++) {
            list.add(new byte[1024 * 100]);  // 100KB씩 생성
            // 10MB 차면 → Minor GC 자동 발생!
        }
    }
}

// 2. Old Generation이 가득 참 → Major GC
public class MajorGCTrigger {
    private static List<byte[]> longLived = new ArrayList<>();

    public static void main(String[] args) {
        // Old Generation 크기: 1GB 가정
        for (int i = 0; i < 10000; i++) {
            longLived.add(new byte[1024 * 100]);  // 100KB씩
            // Minor GC 여러 번 → Old로 승격
            // Old 가득 참 → Major GC 발생!
        }
    }
}

// 3. Allocation Failure (할당 실패)
// Eden에 새 객체를 생성하려는데 공간 없음 → Minor GC
new HugeObject();  // Eden 부족 → GC 즉시 발생

// 4. System.gc() 호출 (권장하지 않음!)
System.gc();  // ❌ Full GC 유발 (하지만 즉시 실행 보장 안 됨)
```

**GC 빈도 측정**:

```bash
# jstat으로 GC 빈도 확인
jstat -gc <pid> 1000  # 1초마다

# 출력:
S0C    S1C    EC       OU       YGC   YGCT    FGC    FGCT
2560   2560   20480    5000     100   0.500   5      1.000

# 해석:
YGC: 100  # Minor GC 100번 발생
YGCT: 0.5초  # Minor GC 총 시간 0.5초
→ 평균 5ms per GC

FGC: 5  # Full GC 5번 발생
FGCT: 1.0초  # Full GC 총 시간 1초
→ 평균 200ms per GC
```

**실무 팁**:
- 💡 Minor GC는 예측 가능 (Eden 크기 / 객체 생성 속도)
- 💡 Major GC는 예측 어려움 (Old Generation 누적 속도가 불규칙)
- 💡 `-Xlog:gc*`로 GC 로그 모니터링 필수!
- 💡 GC가 너무 자주 발생 → Heap 크기 증가 고려

</details>

<details>
<summary><strong>Q2: System.gc()를 호출해서 강제로 GC를 실행해야 하나요?</strong></summary>

**A**: **절대 안 됩니다!** (99.9%의 경우)

**왜 안 되나요?**

```java
// ❌ 나쁜 예: System.gc() 호출
public class BadGCPractice {
    public void processData() {
        // 대량 데이터 처리
        List<Data> data = loadBigData();
        process(data);

        // "메모리 정리해야지!"
        System.gc();  // ❌ 절대 금지!
        // → Full GC 유발 (수백 ms ~ 수 초 멈춤)
        // → 시스템 전체가 일시 정지!
    }
}

// ✅ 좋은 예: GC에게 맡기기
public class GoodGCPractice {
    public void processData() {
        List<Data> data = loadBigData();
        process(data);

        // GC가 알아서 처리!
        // → 필요할 때 최적 시점에 실행
        // → Minor GC로 빠르게 처리 (수 ms)
    }
}
```

**System.gc()의 문제점**:

1. **Full GC 유발**:
```bash
# System.gc() 호출 시 로그
[Full GC (System.gc()) 2000M->500M(4000M) 1.234 secs]
↑ 1.2초 동안 모든 요청 멈춤!

# 자동 GC 시 로그
[GC (Allocation Failure) [PSYoungGen: 100M->10M] 0.005 secs]
↑ 5ms만 멈춤 (246배 빠름!)
```

2. **예측 불가능한 시점**:
```java
System.gc();  // 호출해도 즉시 실행 보장 안 됨!
// JVM이 "나중에 할게~" 할 수도 있음

// 또한 -XX:+DisableExplicitGC 옵션으로 무시 가능
// → System.gc()를 호출해도 아무 일도 안 일어남!
```

3. **성능 저하**:
```java
// 벤치마크: 1만 번 반복
// With System.gc()
for (int i = 0; i < 10000; i++) {
    process();
    System.gc();  // ❌
}
// → 실행 시간: 234초 (Full GC 1만 번!)

// Without System.gc()
for (int i = 0; i < 10000; i++) {
    process();  // GC가 알아서
}
// → 실행 시간: 2초 (Minor GC 100번)
// ⚡ 117배 빠름!
```

**유일한 예외 (0.1%)**:
```java
// 1. 테스트 환경에서 GC 동작 확인용
@Test
public void testGCBehavior() {
    createGarbage();
    System.gc();  // ✅ 테스트 용도로는 OK
    Thread.sleep(100);
    assertMemoryReclaimed();
}

// 2. 개발 중 메모리 누수 디버깅
public void debugMemoryLeak() {
    createObjects();
    System.gc();  // ✅ 디버깅 용도
    // Heap dump 생성 후 분석
}

// 3. Off-Heap 메모리 해제 (Direct Buffer 등)
// → 하지만 이것도 Cleaner 사용이 더 나음!
```

**실무 팁**:
- 💡 JVM 옵션에 `-XX:+DisableExplicitGC` 추가 (System.gc() 무시)
- 💡 GC 튜닝은 Heap 크기, GC 알고리즘으로!
- 💡 메모리 부족 시 → 코드 최적화 또는 Heap 증가

</details>

<details>
<summary><strong>Q3: GC가 실행되면 프로그램이 완전히 멈추나요? (Stop-The-World)</strong></summary>

**A**: GC 종류와 단계에 따라 다릅니다. 일부는 멈추고, 일부는 동시 실행됩니다.

**GC별 Stop-The-World (STW) 비교**:

| GC 종류 | STW 시간 | 동시 실행 | 특징 |
|---------|----------|-----------|------|
| **Serial GC** | 전체 STW | ❌ | 모든 단계에서 애플리케이션 멈춤 |
| **Parallel GC** | 전체 STW | ❌ | 멀티 스레드지만 전체 멈춤 |
| **CMS GC** | 일부 STW | ✅ | 대부분 동시 실행 (Mark, Sweep) |
| **G1 GC** | 일부 STW | ✅ | Young GC는 STW, Old는 대부분 동시 |
| **ZGC** | 최소 STW | ✅ | <10ms STW, 나머지 동시 실행 |

**Minor GC (Young Generation)**:

```java
// Minor GC는 항상 STW!
public class MinorGCExample {
    public static void main(String[] args) {
        // 애플리케이션 실행 중...
        System.out.println("작업 시작");

        // Eden 가득 참 → Minor GC 발생
        for (int i = 0; i < 1000000; i++) {
            new Object();
        }
        // ← 이 순간 모든 스레드 멈춤! (5-10ms)
        //    Minor GC 실행
        //    Eden 정리 → Survivor로 복사
        // ← 애플리케이션 재개

        System.out.println("작업 완료");
    }
}

// GC 로그:
[GC pause (G1 Evacuation Pause) (young) 25M->5M(128M) 5.234ms]
                                            ↑ 5.234ms 동안 멈춤!

// 사용자 체감:
// - 5ms 미만: 거의 못 느낌
// - 10-50ms: 조금 버벅임
// - 100ms+: 명확히 느낌 (끊김)
```

**Major GC (Old Generation)**:

```java
// G1 GC는 대부분 동시 실행!
[GC pause (G1 Evacuation Pause) (young) (initial-mark) 2.345ms]
                                        ↑ STW (매우 짧음)

[GC concurrent-mark-start]
// ← 애플리케이션 계속 실행! (동시 실행)
[GC concurrent-mark-end, 523.456ms]

[GC remark 5.678ms]
      ↑ STW (짧음)

[GC concurrent-cleanup-start]
// ← 애플리케이션 계속 실행!
[GC concurrent-cleanup-end, 234.567ms]

// 총 GC 시간: 765ms
// 하지만 STW 시간: 2.345 + 5.678 = 8ms만!
// → 나머지 757ms는 애플리케이션이 계속 실행됨
```

**ZGC (차세대 GC)**:

```java
// ZGC는 거의 모든 단계를 동시 실행!
[ZGC] GC(42) Pause Mark Start 0.234ms  ← STW (매우 짧음)
[ZGC] GC(42) Concurrent Mark 523.456ms  ← 동시 실행
[ZGC] GC(42) Pause Mark End 0.456ms    ← STW (매우 짧음)
[ZGC] GC(42) Concurrent Process 234.567ms  ← 동시 실행
[ZGC] GC(42) Pause Relocate Start 0.123ms  ← STW (매우 짧음)
[ZGC] GC(42) Concurrent Relocate 345.678ms  ← 동시 실행

// 총 GC 시간: 1104ms
// 하지만 STW 시간: 0.234 + 0.456 + 0.123 = 0.813ms!
// → 99.9%는 동시 실행!
```

**실제 영향 비교**:

```java
// 웹 서버 예시 (동시 요청 1000건)
// 요청 처리 시간: 50ms

// Parallel GC (STW 200ms)
Request 1: 50ms + 200ms (GC 대기) = 250ms  // ← 사용자: "느려!"
Request 2: 50ms + 200ms (GC 대기) = 250ms
// ... 1000건 모두 지연

// G1 GC (STW 10ms)
Request 1: 50ms + 10ms (GC 대기) = 60ms  // ← 사용자: 거의 못 느낌
Request 2: 50ms + 10ms (GC 대기) = 60ms

// ZGC (STW 1ms)
Request 1: 50ms + 1ms (GC 대기) = 51ms  // ← 사용자: 전혀 못 느낌
Request 2: 50ms + 1ms (GC 대기) = 51ms
```

**실무 팁**:
- 💡 Modern GC (G1, ZGC)는 STW 시간이 매우 짧음 (<10ms)
- 💡 Parallel GC는 STW가 길어서 실시간 서비스에 부적합
- 💡 GC 로그로 STW 시간 모니터링 필수!
- 💡 pause time 목표: 웹 서버 < 50ms, 실시간 < 10ms

</details>

<details>
<summary><strong>Q4: Young Generation과 Old Generation을 왜 나누나요?</strong></summary>

**A**: **대부분의 객체는 금방 죽기 때문**입니다 (Weak Generational Hypothesis)

**통계적 사실**:

```
Java 프로그램의 객체 생명 주기:
┌─────────────────────────────────┐
│ 95%의 객체: 1초 이내 죽음       │  ← Young Generation
│ 3%의 객체: 1초 ~ 1분            │  ← Survivor
│ 2%의 객체: 1분 이상 생존        │  ← Old Generation
└─────────────────────────────────┘

실제 측정 (네이버 검색 서버):
- 새로 생성된 객체 중 98%가 다음 Minor GC 전에 죽음
- 오직 2%만 Survivor로 승격
- 그 중 10%만 Old Generation까지 살아남음
→ 결국 0.2%만 장수!
```

**왜 나누는가?**

```java
// 만약 나누지 않는다면? (전체를 하나로)

// ❌ 나쁜 방식: 하나의 큰 Heap
// Heap: 10GB (단일 영역)
// 새 객체도 10GB에, 오래된 객체도 10GB에
// → GC 시 10GB 전체를 스캔해야 함!

[Full GC] 10GB Heap 스캔 → 3초 소요
↑ 사용자: "왜 이렇게 느려?"

// ✅ 좋은 방식: Young/Old 분리
// Young: 1GB (95%의 객체가 여기서 죽음)
// Old: 9GB (5%의 객체만 여기 있음)

[Minor GC] 1GB만 스캔 → 5ms 소요 (600배 빠름! ⚡)
[Major GC] 9GB 스캔 → 500ms (하지만 드물게 발생)
```

**실제 예시**:

```java
public class GenerationalExample {
    public static void main(String[] args) {
        // 단명 객체 (95%) - Young Generation
        for (int i = 0; i < 1000000; i++) {
            String temp = "temp_" + i;  // ← Eden에 생성
            process(temp);
            // ← 루프 끝나면 바로 쓰레기!
            //    다음 Minor GC에서 회수 (5ms)
        }

        // 장수 객체 (5%) - Old Generation
        static Map<String, User> userCache = new HashMap<>();
        // ← 프로그램 시작부터 끝까지
        //    Major GC에서만 검사 (드물게)
    }
}

// GC 로그:
[GC (Allocation Failure) [PSYoungGen: 100M->2M] 5.234ms]
                                    ↑ 98% 회수!
↑ Young만 검사 (빠름)

[Full GC (Ergonomics) [PSYoungGen: 2M->0M]
                      [ParOldGen: 1000M->900M] 523.456ms]
                       ↑ Old도 검사 (느림, 하지만 드묾)
```

**성능 비교**:

| 방식 | GC 빈도 | GC 시간 | 총 GC 시간 (1시간) |
|------|---------|---------|-------------------|
| **단일 Heap (10GB)** | 10분마다 | 3초 | 6회 × 3초 = 18초 |
| **Young/Old 분리** | Minor: 10초마다<br>Major: 1시간마다 | 5ms<br>500ms | 360회 × 5ms + 1회 × 500ms = **2.3초** |

→ **7.8배 빠름!** ⚡

**Young/Old의 역할**:

```
Young Generation (빠른 회전율):
┌──────────────────────────────┐
│ "패스트푸드 식당"             │
│ - 손님이 빨리 들어오고 나감   │
│ - 테이블 정리 자주 (Minor GC) │
│ - 정리 빠름 (대부분 빈 테이블) │
└──────────────────────────────┘

Old Generation (느린 회전율):
┌──────────────────────────────┐
│ "고급 레스토랑"               │
│ - 손님이 오래 머뭄            │
│ - 테이블 정리 드묾 (Major GC) │
│ - 정리 느림 (대부분 사용 중)  │
└──────────────────────────────┘
```

**실무 팁**:
- 💡 Young/Old 비율: 1:2 ~ 1:3 (기본 1:2)
- 💡 Young이 너무 작으면 → Minor GC 너무 자주
- 💡 Young이 너무 크면 → Minor GC 시간 증가
- 💡 G1 GC는 동적으로 비율 조정!

</details>

<details>
<summary><strong>Q5: G1 GC와 CMS GC의 차이점은 무엇인가요?</strong></summary>

**A**: G1 GC는 CMS GC의 모든 단점을 해결한 차세대 GC입니다.

**근본적인 차이**:

```
CMS GC (Concurrent Mark Sweep):
┌─────────────────────────────────────┐
│ Young Generation (고정 영역)        │
├─────────────────────────────────────┤
│ Old Generation (고정 영역)          │
└─────────────────────────────────────┘
↑ 영역이 고정되어 있음

G1 GC (Garbage First):
┌──┬──┬──┬──┬──┬──┬──┬──┐
│E │E │S │O │O │E │H │O │  ← Region 단위
├──┼──┼──┼──┼──┼──┼──┼──┤     (동적 할당)
│E │E │O │O │E │E │O │E │
├──┼──┼──┼──┼──┼──┼──┼──┤
│O │O │S │E │E │O │O │O │  E: Eden
└──┴──┴──┴──┴──┴──┴──┴──┘  S: Survivor
↑ Region을 유연하게 재할당      O: Old
                                H: Humongous
```

**비교표**:

| 특징 | CMS GC | G1 GC |
|------|--------|-------|
| **구조** | 고정 Young/Old 영역 | 유연한 Region |
| **Compaction** | ❌ 없음 → 단편화 발생 | ✅ 있음 → 단편화 해결 |
| **Pause Time** | 낮음 (하지만 예측 어려움) | 낮고 예측 가능 |
| **큰 Heap** | 부적합 (<4GB 권장) | 적합 (6GB~수백 GB) |
| **Full GC** | 자주 발생 (단편화 때문) | 드물게 발생 |
| **CPU 사용** | 높음 (concurrent 작업) | 보통 |
| **설정 복잡도** | 복잡 (튜닝 어려움) | 간단 (목표만 설정) |
| **Java 버전** | Java 8 이하 | Java 9+ 기본 |
| **상태** | **Deprecated** (Java 14+) | **권장** |

**CMS GC의 치명적 단점**:

```java
// 1. Compaction 없음 → 메모리 단편화
// CMS GC 사용 후 Old Generation 상태:
[Obj][Free][Obj][Free][Obj][Free][Free][Obj]
  ↑ 단편화! Free 공간이 흩어져 있음
  → 큰 객체 할당 실패!
  → Concurrent Mode Failure 발생
  → Full GC 강제 실행 (수 초 멈춤)

[Full GC (Allocation Failure) 3000M->2000M(4000M) 3.456 secs]
                               ↑ 3.5초 멈춤!
↑ CMS가 실패해서 Serial GC가 긴급 출동
  → 모든 것을 멈추고 전체 Heap 정리

// G1 GC는 Compaction 포함:
[Obj][Obj][Obj][Obj][Free Free Free Free Free]
  ↑ 연속된 Free 공간! 큰 객체도 할당 가능
  → Full GC 거의 없음
```

```bash
// 2. Full GC 빈발 (실제 로그)
# CMS GC (4GB Heap, 하루 운영)
[CMS-concurrent-mark: 0.123s]  # OK, 동시 실행
[CMS-concurrent-sweep: 0.234s]  # OK, 동시 실행
[CMS-concurrent-mark: 0.125s]
[Full GC (Allocation Failure) 3.456s]  # ❌ 단편화로 Full GC!
[CMS-concurrent-mark: 0.130s]
[Full GC (Allocation Failure) 3.789s]  # ❌ 또 Full GC!
...
총 Full GC: 23회 (하루 23회!)
→ 사용자: "자꾸 끊겨요!"

# G1 GC (4GB Heap, 하루 운영)
[GC pause (G1 Evacuation Pause) (young) 5.234ms]
[GC pause (G1 Evacuation Pause) (mixed) 12.345ms]
[GC pause (G1 Evacuation Pause) (young) 4.567ms]
...
총 Full GC: 0회!
→ 사용자: "부드러워요!"
```

**G1 GC의 강점**:

```java
// 1. 예측 가능한 pause time
// G1 GC 설정:
-XX:+UseG1GC
-XX:MaxGCPauseMillis=100  # "목표: 100ms 이하로 해줘!"

// G1은 이 목표를 지키려고 노력:
[GC pause (G1 Evacuation Pause) 45.678ms]  # ✅ 목표 달성!
[GC pause (G1 Evacuation Pause) 67.890ms]  # ✅ 목표 달성!
[GC pause (G1 Evacuation Pause) 89.012ms]  # ✅ 목표 달성!

// 평균 pause time: 67ms (목표 100ms 이하 유지!)

// CMS는 예측 불가:
[CMS-concurrent-mark: 123ms]  # 동시 실행 (OK)
[CMS-remark: 456ms]  # ❌ 갑자기 456ms!
[Full GC: 3456ms]  # ❌ 갑자기 3.5초!
```

```java
// 2. 큰 Heap에서 효율적
// 64GB Heap에서 비교:

// CMS GC (64GB)
[Full GC 64000M->60000M 25.678 secs]
         ↑ 25초 멈춤! (사용 불가)

// G1 GC (64GB)
[GC pause (G1 Evacuation Pause) 87.654ms]
         ↑ 87ms만 멈춤! (293배 빠름!)
```

```java
// 3. 가비지 많은 Region 우선 회수 (Garbage First!)
// G1 GC는 똑똑함:
Region 1: 90% 가비지  ← 이거부터 회수! (효율적)
Region 2: 10% 가비지  ← 나중에
Region 3: 95% 가비지  ← 이것도 우선!

// → 짧은 시간에 최대한 많은 메모리 회수
// → pause time 목표를 지키면서!
```

**실제 사례 비교**:

```bash
# 배달의민족 주문 서버 (8GB Heap)

Before (CMS GC):
- 평균 pause time: 150ms
- 99 percentile pause: 3.5초 (Full GC)
- Full GC 빈도: 하루 10-20회
- 주문 처리 지연: 자주 발생
- 고객 불만: "주문이 안 돼요!"

After (G1 GC):
- 평균 pause time: 50ms (3배 개선!)
- 99 percentile pause: 120ms (29배 개선!)
- Full GC 빈도: 한 달 0-1회 (거의 없음)
- 주문 처리 지연: 거의 없음
- 고객 만족도: 크게 상승
```

**실무 팁**:
- 💡 **Java 9+면 무조건 G1 GC** (기본값)
- 💡 CMS는 Deprecated → 사용 금지
- 💡 G1 GC 설정은 간단: `-XX:MaxGCPauseMillis=200`만!
- 💡 4GB 이하 Heap → Parallel GC도 고려
- 💡 초저지연 필요 → ZGC (Java 15+)

</details>

<details>
<summary><strong>Q6: OutOfMemoryError는 왜 발생하고 어떻게 해결하나요?</strong></summary>

**A**: OOM은 Heap 공간 부족 또는 메모리 누수 때문입니다. Heap Dump로 원인을 찾아야 합니다.

**OOM 발생 원인**:

```java
// 1. Java heap space (가장 흔함)
java.lang.OutOfMemoryError: Java heap space
→ Heap이 가득 차서 새 객체를 생성할 수 없음

// 2. Metaspace (클래스 너무 많음)
java.lang.OutOfMemoryError: Metaspace
→ 클래스 메타데이터 영역 부족

// 3. GC overhead limit exceeded
java.lang.OutOfMemoryError: GC overhead limit exceeded
→ GC에 98% 시간 쓰는데 2%도 회수 못함

// 4. Unable to create new native thread
java.lang.OutOfMemoryError: unable to create new native thread
→ 스레드 너무 많음
```

**원인 1: 메모리 누수 (Memory Leak)**

```java
// ❌ 전형적인 메모리 누수 패턴
public class MemoryLeakExample {
    // 1. Static 컬렉션에 계속 추가
    private static List<Object> cache = new ArrayList<>();

    public void addToCache(Object obj) {
        cache.add(obj);  // ← 제거 안 함! 계속 쌓임
    }
    // 10만 건 추가 → 5GB 사용
    // → OOM 발생!

    // 2. 리스너 등록 후 해제 안 함
    public void registerListener(Component component) {
        component.addListener(this);  // ← 등록만 하고 해제 안 함
    }
    // 1만 개 컴포넌트 등록 → 메모리 누수

    // 3. ThreadLocal 정리 안 함
    private static ThreadLocal<byte[]> data = new ThreadLocal<>();

    public void process() {
        data.set(new byte[1024 * 1024]);  // 1MB
        // 작업
        // ← data.remove() 호출 안 함!
    }
    // 스레드 풀에서 1000개 스레드 → 1GB 누수!
}

// ✅ 올바른 코드
public class NoMemoryLeakExample {
    // 1. 크기 제한 있는 캐시
    private static Cache<String, Object> cache =
        Caffeine.newBuilder()
                .maximumSize(10000)  // 최대 1만 개
                .expireAfterWrite(10, TimeUnit.MINUTES)  // 10분 후 삭제
                .build();

    // 2. 리스너 제거
    public void cleanup(Component component) {
        component.removeListener(this);  // ← 반드시 제거!
    }

    // 3. ThreadLocal 정리
    public void process() {
        try {
            data.set(new byte[1024 * 1024]);
            // 작업
        } finally {
            data.remove();  // ← 반드시 정리!
        }
    }
}
```

**진단 방법 1: Heap Dump 생성**

```bash
# 1. OOM 발생 시 자동 생성 (권장)
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/heapdump.hprof

# 실행:
java -Xms2g -Xmx2g \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/logs/heapdump.hprof \
     MyApp

# OOM 발생 시:
java.lang.OutOfMemoryError: Java heap space
Dumping heap to /logs/heapdump.hprof ...
Heap dump file created [2147483648 bytes in 5.123 secs]

# 2. 수동 생성 (실행 중)
jmap -dump:format=b,file=heap.bin <pid>

# 3. jcmd 사용
jcmd <pid> GC.heap_dump heap.bin
```

**진단 방법 2: MAT로 분석**

```bash
# MAT (Memory Analyzer Tool) 다운로드
https://www.eclipse.org/mat/

# Heap Dump 열기:
File → Open Heap Dump → heapdump.hprof

# 1. Leak Suspects Report (자동 분석)
→ "Leak Suspects" 탭 클릭

# 결과 예시:
Problem Suspect 1:
  One instance of "com.example.UserCache"
  loaded by "sun.misc.Launcher$AppClassLoader"
  occupies 1,876,234,567 bytes (85.2% of total heap)
  ↑ UserCache가 전체 Heap의 85% 차지!

# 2. Dominator Tree (메모리 점유율 순)
→ "Dominator Tree" 탭 클릭

| Class Name | Shallow Heap | Retained Heap |
|------------|--------------|---------------|
| com.example.UserCache | 48 bytes | 1.8GB (85%) |
| java.util.HashMap$Node[] | 1.5GB | 1.5GB |
| com.example.User[] | 300MB | 300MB |

↑ UserCache가 1.8GB 점유!

# 3. Path to GC Roots (누구 때문?)
→ UserCache 우클릭 → Path to GC Roots → exclude weak references

com.example.UserCache (1.8GB)
  ← static field: cache
  ← com.example.Main
  ← GC Root (Static)

↑ Main 클래스의 static 변수가 원인!
```

**해결 방법**:

```java
// 진단 결과: UserCache가 1.8GB 차지
public class UserCache {
    // ❌ 문제 코드
    private static Map<String, User> cache = new HashMap<>();

    public static void addUser(User user) {
        cache.put(user.getId(), user);  // 제거 안 함!
    }
}

// ✅ 해결 1: 크기 제한
private static Map<String, User> cache =
    Collections.synchronizedMap(
        new LinkedHashMap<String, User>(10000, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, User> eldest) {
                return size() > 10000;  // 1만 개 초과 시 삭제
            }
        }
    );

// ✅ 해결 2: TTL (Time To Live)
private static Cache<String, User> cache =
    Caffeine.newBuilder()
            .maximumSize(10000)
            .expireAfterWrite(10, TimeUnit.MINUTES)  // 10분 후 자동 삭제
            .build();

// ✅ 해결 3: WeakHashMap (자동 GC)
private static Map<String, User> cache = new WeakHashMap<>();
// → GC가 메모리 부족 시 자동으로 제거

// 결과:
// Before: 1.8GB 사용 → OOM
// After: 70MB 사용 → 정상 작동!
```

**해결 방법 종합**:

```bash
# 1. Heap 크기 증가 (임시 방편)
-Xms2g -Xmx2g → -Xms4g -Xmx4g

# 2. 메모리 누수 제거 (근본 해결)
→ Heap Dump 분석 → 원인 제거

# 3. 코드 최적화
// - 불필요한 객체 생성 제거
// - 캐시 크기 제한
// - ThreadLocal 정리
// - 리스너 제거

# 4. GC 튜닝
-XX:+UseG1GC
-XX:MaxGCPauseMillis=200

# 5. 모니터링 강화
-Xlog:gc*:file=gc.log
-XX:+HeapDumpOnOutOfMemoryError
```

**실제 사례**:

```bash
# 배달의민족 주문 서버 OOM 사건

문제:
- 점심 피크 시 OOM 발생
- java.lang.OutOfMemoryError: Java heap space

진단:
1. Heap Dump 생성 (2.5GB)
2. MAT 분석 결과:
   - OrderCache가 2.1GB 차지 (85%)
   - 주문 완료 후에도 캐시에서 제거 안 함
   - 점심 피크: 10분에 10만 건 주문
   - 10만 건 × 21KB = 2.1GB → OOM!

해결:
// Before
private static Map<String, Order> cache = new HashMap<>();

// After
private static Cache<String, Order> cache =
    Caffeine.newBuilder()
            .maximumSize(10000)  // 최대 1만 건
            .expireAfterWrite(5, TimeUnit.MINUTES)  // 5분 후 삭제
            .build();

결과:
- 메모리 사용량: 2.1GB → 210MB (10배 감소!)
- OOM 발생: 하루 3회 → 0회 (3개월간)
- 주문 성공률: 99.5% → 99.95% (10배 개선)
```

**실무 팁**:
- 💡 `-XX:+HeapDumpOnOutOfMemoryError` 항상 설정!
- 💡 MAT로 Heap Dump 분석 필수
- 💡 Static 컬렉션 사용 시 크기 제한 필수
- 💡 ThreadLocal은 반드시 remove() 호출
- 💡 Heap 증가는 임시 방편, 근본 원인 제거가 답!

</details>

<details>
<summary><strong>Q7: GC를 모니터링하려면 어떤 도구를 사용해야 하나요?</strong></summary>

**A**: GC 로그, jstat, VisualVM, GC Easy 등 다양한 도구가 있습니다. 단계별로 활용하세요.

**1단계: GC 로그 수집 (필수)**

```bash
# Java 9+ (통합 로깅)
java -Xlog:gc*:file=gc.log:time,uptime,level,tags \
     -Xms4g -Xmx4g \
     MyApp

# Java 8 (레거시)
java -Xms4g -Xmx4g \
     -XX:+PrintGCDetails \
     -XX:+PrintGCDateStamps \
     -XX:+PrintGCTimeStamps \
     -Xloggc:gc.log \
     MyApp

# GC 로그 예시:
[2025-01-15T10:30:45.123+0900][0.234s][info][gc] GC(12) Pause Young (Allocation Failure) 25M->5M(128M) 5.234ms
                                                         ↑ Minor GC
                                                                     ↑ 25M → 5M
                                                                            ↑ 5.234ms 소요

[2025-01-15T10:35:23.456+0900][300.567s][info][gc] GC(42) Pause Full (Ergonomics) 120M->85M(128M) 523.456ms
                                                          ↑ Full GC
                                                                      ↑ 523ms 소요 (오래 걸림!)
```

**2단계: jstat으로 실시간 모니터링**

```bash
# 기본 사용법
jstat -gc <pid> 1000  # 1초마다 GC 통계 출력

# 출력 예시:
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    YGC     YGCT    FGC    FGCT     GCT
2048.0 2048.0  0.0   1024.0  16384.0  8192.0   40960.0    20480.0  21248.0 20512.0  100    0.500    5    1.000    1.500

# 해석:
# S0C/S1C: Survivor 0/1 용량 (KB)
# S0U/S1U: Survivor 0/1 사용량
# EC: Eden 용량
# EU: Eden 사용량
# OC: Old Generation 용량
# OU: Old Generation 사용량
# YGC: Young GC 횟수 (100번)
# YGCT: Young GC 총 시간 (0.5초)
# FGC: Full GC 횟수 (5번)
# FGCT: Full GC 총 시간 (1초)

# 평균 계산:
# Minor GC 평균: 0.5초 / 100회 = 5ms per GC
# Full GC 평균: 1초 / 5회 = 200ms per GC

# 다양한 옵션:
jstat -gcutil <pid> 1000  # 백분율로 보기
jstat -gccause <pid> 1000  # GC 원인 포함
jstat -gcnew <pid> 1000  # Young Generation만
jstat -gcold <pid> 1000  # Old Generation만
```

**3단계: VisualVM으로 시각화**

```bash
# VisualVM 실행
jvisualvm

# 기능:
1. CPU, Memory, Threads 실시간 모니터링
   → "Monitor" 탭: Heap 사용량 그래프

2. Visual GC 플러그인 (필수!)
   Tools → Plugins → Visual GC 설치
   → 실시간으로 Eden, Survivor, Old 시각화

3. Heap Dump 분석
   → "Heap Dump" 버튼 클릭
   → 메모리 누수 찾기

4. Profiler
   → "Profiler" 탭
   → CPU, Memory 프로파일링

# 장점:
- GUI로 직관적
- 실시간 모니터링
- 원격 서버 연결 가능 (JMX)

# 단점:
- 프로덕션 환경에서는 오버헤드 있음
```

**4단계: GC Easy로 로그 분석 (권장!)**

```bash
# 1. GC 로그 수집 (1시간~하루)
java -Xlog:gc*:file=gc.log:time,uptime,level,tags MyApp

# 2. GC Easy 업로드
https://gceasy.io
→ Upload gc.log

# 3. 분석 결과 (자동 생성):

# Key Performance Indicators
- Throughput: 98.5%  ← 애플리케이션이 98.5% 시간 실행 (좋음!)
- Latency (Avg): 12.3ms  ← 평균 pause time
- Latency (Max): 234.5ms  ← 최대 pause time (주의!)
- Young GC Freq: 10초마다
- Full GC Freq: 1시간마다

# GC Statistics
- Total GC Time: 1분 30초 (1.5% of total time)
- Young GC Count: 360회
- Young GC Time: 1분 (평균 10ms)
- Full GC Count: 1회
- Full GC Time: 30초 (길다! 문제!)

# Memory Statistics
- Allocated: 100GB  ← 총 생성된 객체
- Promoted: 2GB  ← Old로 승격된 객체 (2%)
- Allocation Rate: 500MB/s  ← 초당 객체 생성 속도

# Problems Detected:
⚠️ Full GC pause time too long (30초)
⚠️ Old Generation growing continuously (메모리 누수 의심)
⚠️ Frequent Minor GC (10초마다 - Young Gen 부족)

# Recommendations:
1. Heap 크기 증가: -Xmx4g → -Xmx8g
2. Young Generation 증가: -Xmn2g
3. 메모리 누수 확인 (Heap Dump 분석)
```

**5단계: 프로메테우스 + 그라파나 (프로덕션)**

```bash
# JMX Exporter 설정
# 1. jmx_exporter.jar 다운로드
wget https://github.com/prometheus/jmx_exporter/releases/download/0.16.1/jmx_prometheus_javaagent-0.16.1.jar

# 2. config.yaml 작성
rules:
  - pattern: 'java.lang<type=Memory><HeapMemoryUsage>(\w+)'
    name: jvm_memory_heap_$1
  - pattern: 'java.lang<type=GarbageCollector, name=(.+)><>CollectionCount'
    name: jvm_gc_collection_count
    labels:
      gc: "$1"
  - pattern: 'java.lang<type=GarbageCollector, name=(.+)><>CollectionTime'
    name: jvm_gc_collection_time
    labels:
      gc: "$1"

# 3. 애플리케이션 실행
java -javaagent:jmx_prometheus_javaagent-0.16.1.jar=9090:config.yaml \
     -Xms4g -Xmx4g \
     MyApp

# 4. 프로메테우스 수집 (prometheus.yml)
scrape_configs:
  - job_name: 'java-app'
    static_configs:
      - targets: ['localhost:9090']

# 5. 그라파나 대시보드
# JVM Micrometer 대시보드 import (ID: 4701)
- Heap Memory 사용량 (시계열 그래프)
- GC Count (Minor/Major 분리)
- GC Time (pause time 분포)
- Allocation Rate (초당 객체 생성)

# 알람 설정:
- Full GC 발생 시 → Slack 알람
- Heap 사용량 90% 초과 → 이메일 알람
- GC pause time 100ms 초과 → PagerDuty 호출
```

**도구 선택 가이드**:

| 상황 | 추천 도구 | 장점 |
|------|----------|------|
| **개발 중** | VisualVM | 실시간, 직관적 |
| **성능 테스트** | GC Easy | 자동 분석, 추천 |
| **장애 대응** | jstat + Heap Dump | 빠르고 정확 |
| **프로덕션** | 프로메테우스 + 그라파나 | 모니터링 + 알람 |
| **로그 분석** | GC Easy | 무료, 쉬움 |

**실무 모니터링 체크리스트**:

```bash
# ✅ 1. GC 로그 수집 (항상 켜두기)
-Xlog:gc*:file=gc.log:time,uptime,level,tags

# ✅ 2. OOM 시 Heap Dump 생성
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/logs/heapdump.hprof

# ✅ 3. 주요 메트릭 모니터링
- Throughput > 95% (GC 시간 < 5%)
- Minor GC pause < 50ms
- Full GC pause < 200ms
- Full GC 빈도 < 하루 1회

# ✅ 4. 알람 설정
- Full GC 발생 시
- Heap 사용량 90% 초과 시
- GC pause time 100ms 초과 시

# ✅ 5. 주기적 분석
- 매주: GC 로그 확인
- 매월: Heap Dump 분석
- 분기별: GC 튜닝 검토
```

**실무 팁**:
- 💡 GC 로그는 항상 켜두세요 (오버헤드 거의 없음)
- 💡 GC Easy는 무료이고 매우 유용!
- 💡 프로덕션에서는 프로메테우스 + 그라파나 필수
- 💡 jstat은 장애 대응 시 가장 빠름
- 💡 VisualVM은 개발/테스트 환경에서만

</details>

---

## 💡 핵심 개념

```
1. GC는 unreachable 객체를 자동 회수
2. Generational GC: Young + Old (95%는 Young에서 죽음)
3. Minor GC (빠름, 1-10ms) vs Major GC (느림, 100ms~수 초)
4. Stop-The-World: GC 중 애플리케이션 일시 정지
5. G1 GC가 Java 9+ 기본 (Region 기반, 예측 가능한 pause time)
```

**다음 Part 2**: 실전 튜닝 & 주니어 실수
