# 25장 컬렉션 프레임워크 개요 Part 3 - 실전 프로젝트 & FAQ 🚀

## 💼 실전 프로젝트: 이벤트 기반 알림 시스템

### 프로젝트 개요
전자상거래 플랫폼의 실시간 알림 시스템을 구현합니다. 다양한 이벤트(주문, 배송, 프로모션)를 효율적으로 관리하고, 사용자별 알림을 빠르게 조회/전송하는 시스템입니다.

### 핵심 기능
1. **이벤트 큐 관리** (Queue): FIFO 순서로 이벤트 처리
2. **중복 알림 방지** (Set): 같은 알림 중복 전송 방지
3. **사용자별 알림 매핑** (Map): 빠른 사용자 조회
4. **알림 이력 관리** (List): 시간순 이력 보관

### 전체 코드

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

// ========== 1. 도메인 모델 ==========

enum NotificationType {
    ORDER_CONFIRMED("주문 확인", "🛒"),
    PAYMENT_COMPLETED("결제 완료", "💳"),
    SHIPPING_STARTED("배송 시작", "🚚"),
    DELIVERY_COMPLETED("배송 완료", "📦"),
    PROMOTION("프로모션", "🎁"),
    SYSTEM_NOTICE("시스템 공지", "📢");

    private final String displayName;
    private final String emoji;

    NotificationType(String displayName, String emoji) {
        this.displayName = displayName;
        this.emoji = emoji;
    }

    public String getDisplayName() { return displayName; }
    public String getEmoji() { return emoji; }
}

class Notification {
    private String notificationId;
    private String userId;
    private NotificationType type;
    private String message;
    private LocalDateTime createdAt;
    private boolean isRead;
    private int priority; // 1(높음) ~ 5(낮음)

    public Notification(String notificationId, String userId, NotificationType type,
                       String message, int priority) {
        this.notificationId = notificationId;
        this.userId = userId;
        this.type = type;
        this.message = message;
        this.createdAt = LocalDateTime.now();
        this.isRead = false;
        this.priority = priority;
    }

    public String getNotificationId() { return notificationId; }
    public String getUserId() { return userId; }
    public NotificationType getType() { return type; }
    public String getMessage() { return message; }
    public LocalDateTime getCreatedAt() { return createdAt; }
    public boolean isRead() { return isRead; }
    public void markAsRead() { this.isRead = true; }
    public int getPriority() { return priority; }

    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM-dd HH:mm");
        String readStatus = isRead ? "✓" : "●";
        return String.format("%s %s [P%d] %s - %s (%s)",
            readStatus, type.getEmoji(), priority, type.getDisplayName(),
            message, createdAt.format(formatter));
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Notification)) return false;
        Notification that = (Notification) o;
        return notificationId.equals(that.notificationId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(notificationId);
    }
}

// ========== 2. 알림 시스템 ==========

class NotificationSystem {

    // Queue: 처리 대기 중인 알림 (FIFO)
    private Queue<Notification> pendingQueue = new LinkedList<>();

    // Set: 전송된 알림 ID (중복 방지)
    private Set<String> sentNotificationIds = new HashSet<>();

    // Map: 사용자별 알림 목록 (빠른 조회)
    private Map<String, List<Notification>> userNotifications = new HashMap<>();

    // List: 전체 알림 이력 (시간순)
    private List<Notification> notificationHistory = new ArrayList<>();

    // 통계
    private int totalSent = 0;
    private int duplicatePrevented = 0;

    // ===== 1. 알림 추가 (Queue + Set 활용) =====

    public boolean addNotification(Notification notification) {
        String notifId = notification.getNotificationId();

        // Set으로 중복 체크 (O(1))
        if (sentNotificationIds.contains(notifId)) {
            duplicatePrevented++;
            System.out.println("⚠️ 중복 알림 차단: " + notifId);
            return false;
        }

        // Queue에 추가
        pendingQueue.offer(notification);
        System.out.println("📝 알림 큐 추가: " + notification.getType().getDisplayName() +
                         " (대기 " + pendingQueue.size() + "건)");
        return true;
    }

    // ===== 2. 알림 처리 (Queue → Map + List) =====

    public void processNotifications(int batchSize) {
        System.out.println("\n🔄 알림 처리 시작 (배치 크기: " + batchSize + ")");

        int processed = 0;
        while (!pendingQueue.isEmpty() && processed < batchSize) {
            Notification notification = pendingQueue.poll(); // Queue에서 제거

            // Set에 추가 (중복 방지)
            sentNotificationIds.add(notification.getNotificationId());

            // Map에 사용자별로 저장
            userNotifications.computeIfAbsent(notification.getUserId(),
                k -> new ArrayList<>()).add(notification);

            // List에 이력 저장
            notificationHistory.add(notification);

            totalSent++;
            processed++;

            System.out.println("   ✅ 전송: " + notification.getUserId() + " - " +
                             notification.getType().getDisplayName());
        }

        System.out.println("처리 완료: " + processed + "건 (남은 대기: " + pendingQueue.size() + "건)\n");
    }

    // ===== 3. 사용자별 알림 조회 (Map 활용) =====

    public List<Notification> getUserNotifications(String userId) {
        return userNotifications.getOrDefault(userId, new ArrayList<>());
    }

    public void showUserNotifications(String userId) {
        List<Notification> notifications = getUserNotifications(userId);

        System.out.println("\n👤 사용자 '" + userId + "' 알림 (" + notifications.size() + "건):");

        if (notifications.isEmpty()) {
            System.out.println("   알림이 없습니다.");
            return;
        }

        notifications.forEach(n -> System.out.println("   " + n));
    }

    // ===== 4. 알림 읽음 처리 =====

    public void markAsRead(String userId, String notificationId) {
        List<Notification> notifications = getUserNotifications(userId);

        for (Notification notification : notifications) {
            if (notification.getNotificationId().equals(notificationId)) {
                notification.markAsRead();
                System.out.println("✓ 읽음 처리: " + notification.getType().getDisplayName());
                return;
            }
        }

        System.out.println("❌ 알림을 찾을 수 없습니다: " + notificationId);
    }

    // ===== 5. 미읽음 알림 개수 =====

    public int getUnreadCount(String userId) {
        List<Notification> notifications = getUserNotifications(userId);
        return (int) notifications.stream()
                                 .filter(n -> !n.isRead())
                                 .count();
    }

    // ===== 6. 알림 타입별 통계 =====

    public void showStatisticsByType() {
        System.out.println("\n📊 알림 타입별 통계:");

        Map<NotificationType, Long> typeStats = notificationHistory.stream()
            .collect(Collectors.groupingBy(
                Notification::getType,
                Collectors.counting()
            ));

        typeStats.entrySet().stream()
            .sorted((e1, e2) -> Long.compare(e2.getValue(), e1.getValue()))
            .forEach(entry -> {
                System.out.println("   " + entry.getKey().getEmoji() + " " +
                                 entry.getKey().getDisplayName() + ": " +
                                 entry.getValue() + "건");
            });
    }

    // ===== 7. 우선순위별 정렬 =====

    public void showNotificationsByPriority(String userId) {
        List<Notification> notifications = getUserNotifications(userId);

        System.out.println("\n⚡ 우선순위 순 알림:");

        notifications.stream()
            .sorted(Comparator.comparingInt(Notification::getPriority)
                            .thenComparing(Notification::getCreatedAt).reversed())
            .forEach(n -> System.out.println("   " + n));
    }

    // ===== 8. 최근 알림 조회 =====

    public void showRecentNotifications(int count) {
        System.out.println("\n📋 최근 알림 " + count + "건:");

        notificationHistory.stream()
            .sorted(Comparator.comparing(Notification::getCreatedAt).reversed())
            .limit(count)
            .forEach(n -> System.out.println("   " + n));
    }

    // ===== 9. 전체 통계 =====

    public void showOverallStatistics() {
        System.out.println("\n📈 전체 통계:");
        System.out.println("   총 전송: " + totalSent + "건");
        System.out.println("   중복 차단: " + duplicatePrevented + "건");
        System.out.println("   대기 중: " + pendingQueue.size() + "건");
        System.out.println("   등록 사용자: " + userNotifications.size() + "명");

        // 전체 미읽음
        long totalUnread = userNotifications.values().stream()
            .flatMap(List::stream)
            .filter(n -> !n.isRead())
            .count();
        System.out.println("   전체 미읽음: " + totalUnread + "건");
    }

    // ===== 10. 사용자별 알림 삭제 (오래된 알림) =====

    public void cleanupOldNotifications(String userId, int daysToKeep) {
        List<Notification> notifications = getUserNotifications(userId);
        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(daysToKeep);

        int sizeBefore = notifications.size();
        notifications.removeIf(n -> n.getCreatedAt().isBefore(cutoffDate));
        int removed = sizeBefore - notifications.size();

        System.out.println("\n🧹 오래된 알림 정리: " + removed + "건 삭제 (" +
                         daysToKeep + "일 이상)");
    }
}

// ========== 3. 메인 실행 ==========

public class NotificationSystemProject {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== 이벤트 기반 알림 시스템 ===\n");

        NotificationSystem system = new NotificationSystem();

        // ===== 1. 알림 생성 및 큐 추가 =====
        System.out.println("--- 1. 알림 추가 ---\n");

        system.addNotification(new Notification(
            "NOTIF-001", "user123", NotificationType.ORDER_CONFIRMED,
            "주문이 확인되었습니다. (주문번호: ORD-001)", 2));

        system.addNotification(new Notification(
            "NOTIF-002", "user123", NotificationType.PAYMENT_COMPLETED,
            "결제가 완료되었습니다. (50,000원)", 1));

        system.addNotification(new Notification(
            "NOTIF-003", "user456", NotificationType.SHIPPING_STARTED,
            "상품이 발송되었습니다.", 2));

        system.addNotification(new Notification(
            "NOTIF-004", "user123", NotificationType.PROMOTION,
            "신규 회원 특별 할인 20%", 3));

        system.addNotification(new Notification(
            "NOTIF-005", "user789", NotificationType.DELIVERY_COMPLETED,
            "배송이 완료되었습니다.", 1));

        // 중복 알림 시도
        system.addNotification(new Notification(
            "NOTIF-001", "user123", NotificationType.ORDER_CONFIRMED,
            "중복 알림", 2));

        // ===== 2. 배치 처리 =====
        Thread.sleep(100);
        system.processNotifications(3);

        Thread.sleep(100);
        system.processNotifications(10);

        // ===== 3. 사용자별 조회 =====
        system.showUserNotifications("user123");
        system.showUserNotifications("user456");

        // ===== 4. 읽음 처리 =====
        System.out.println();
        system.markAsRead("user123", "NOTIF-001");
        system.markAsRead("user123", "NOTIF-002");

        // 미읽음 개수
        System.out.println("\nuser123 미읽음: " + system.getUnreadCount("user123") + "건");

        // ===== 5. 우선순위별 정렬 =====
        system.showNotificationsByPriority("user123");

        // ===== 6. 타입별 통계 =====
        system.showStatisticsByType();

        // ===== 7. 최근 알림 =====
        system.showRecentNotifications(3);

        // ===== 8. 전체 통계 =====
        system.showOverallStatistics();

        // ===== 9. 추가 시나리오: 대량 알림 처리 =====
        System.out.println("\n\n--- 대량 알림 처리 시나리오 ---\n");

        for (int i = 6; i <= 100; i++) {
            String userId = "user" + (i % 10);
            NotificationType type = NotificationType.values()[i % NotificationType.values().length];
            system.addNotification(new Notification(
                "NOTIF-" + String.format("%03d", i),
                userId,
                type,
                "메시지 " + i,
                (i % 3) + 1
            ));
        }

        System.out.println("\n대량 처리 중...");
        system.processNotifications(100);

        system.showOverallStatistics();

        System.out.println("\n\n✅ 프로젝트 핵심 포인트:");
        System.out.println("1. Queue: FIFO 알림 처리 대기열");
        System.out.println("2. Set: O(1) 중복 체크로 같은 알림 재전송 방지");
        System.out.println("3. Map: 사용자별 O(1) 조회");
        System.out.println("4. List: 시간순 이력 보관 및 정렬");
        System.out.println("5. Stream API: 필터링, 그룹핑, 통계 계산");
    }
}
```

### 실행 결과

```
=== 이벤트 기반 알림 시스템 ===

--- 1. 알림 추가 ---

📝 알림 큐 추가: 주문 확인 (대기 1건)
📝 알림 큐 추가: 결제 완료 (대기 2건)
📝 알림 큐 추가: 배송 시작 (대기 3건)
📝 알림 큐 추가: 프로모션 (대기 4건)
📝 알림 큐 추가: 배송 완료 (대기 5건)
⚠️ 중복 알림 차단: NOTIF-001

🔄 알림 처리 시작 (배치 크기: 3)
   ✅ 전송: user123 - 주문 확인
   ✅ 전송: user123 - 결제 완료
   ✅ 전송: user456 - 배송 시작
처리 완료: 3건 (남은 대기: 2건)

🔄 알림 처리 시작 (배치 크기: 10)
   ✅ 전송: user123 - 프로모션
   ✅ 전송: user789 - 배송 완료
처리 완료: 2건 (남은 대기: 0건)


👤 사용자 'user123' 알림 (3건):
   ● 🛒 [P2] 주문 확인 - 주문이 확인되었습니다. (주문번호: ORD-001) (10-10 14:30)
   ● 💳 [P1] 결제 완료 - 결제가 완료되었습니다. (50,000원) (10-10 14:30)
   ● 🎁 [P3] 프로모션 - 신규 회원 특별 할인 20% (10-10 14:30)

👤 사용자 'user456' 알림 (1건):
   ● 🚚 [P2] 배송 시작 - 상품이 발송되었습니다. (10-10 14:30)

✓ 읽음 처리: 주문 확인
✓ 읽음 처리: 결제 완료

user123 미읽음: 1건

⚡ 우선순위 순 알림:
   ✓ 💳 [P1] 결제 완료 - 결제가 완료되었습니다. (50,000원) (10-10 14:30)
   ✓ 🛒 [P2] 주문 확인 - 주문이 확인되었습니다. (주문번호: ORD-001) (10-10 14:30)
   ● 🎁 [P3] 프로모션 - 신규 회원 특별 할인 20% (10-10 14:30)

📊 알림 타입별 통계:
   🛒 주문 확인: 1건
   💳 결제 완료: 1건
   🚚 배송 시작: 1건
   🎁 프로모션: 1건
   📦 배송 완료: 1건

📋 최근 알림 3건:
   ● 📦 [P1] 배송 완료 - 배송이 완료되었습니다. (10-10 14:30)
   ● 🎁 [P3] 프로모션 - 신규 회원 특별 할인 20% (10-10 14:30)
   ● 🚚 [P2] 배송 시작 - 상품이 발송되었습니다. (10-10 14:30)

📈 전체 통계:
   총 전송: 5건
   중복 차단: 1건
   대기 중: 0건
   등록 사용자: 3명
   전체 미읽음: 3건


--- 대량 알림 처리 시나리오 ---

📝 알림 큐 추가: 시스템 공지 (대기 1건)
... (95개 생략)
📝 알림 큐 추가: 배송 완료 (대기 95건)

대량 처리 중...
🔄 알림 처리 시작 (배치 크기: 100)
   ✅ 전송: user6 - 시스템 공지
   ... (95개 생략)
처리 완료: 95건 (남은 대기: 0건)

📈 전체 통계:
   총 전송: 100건
   중복 차단: 1건
   대기 중: 0건
   등록 사용자: 10명
   전체 미읽음: 98건


✅ 프로젝트 핵심 포인트:
1. Queue: FIFO 알림 처리 대기열
2. Set: O(1) 중복 체크로 같은 알림 재전송 방지
3. Map: 사용자별 O(1) 조회
4. List: 시간순 이력 보관 및 정렬
5. Stream API: 필터링, 그룹핑, 통계 계산
```

### 프로젝트 핵심 포인트

#### 1. 컬렉션 조합 활용
```java
Queue<Notification> pendingQueue;      // 처리 대기
Set<String> sentNotificationIds;       // 중복 방지
Map<String, List<Notification>> userNotifications;  // 사용자별 조회
List<Notification> notificationHistory;  // 전체 이력
```

각 컬렉션이 최적의 역할을 수행하도록 조합

#### 2. Stream API 활용
```java
// 타입별 통계
Map<NotificationType, Long> typeStats = notificationHistory.stream()
    .collect(Collectors.groupingBy(
        Notification::getType,
        Collectors.counting()
    ));

// 미읽음 필터링
long totalUnread = notifications.stream()
    .filter(n -> !n.isRead())
    .count();
```

#### 3. 성능 최적화
- **Set 중복 체크**: O(1)로 빠른 중복 판단
- **Map 사용자 조회**: O(1)로 즉시 조회
- **computeIfAbsent**: 존재하지 않을 때만 리스트 생성

#### 4. 확장 가능성
- 우선순위 큐 (PriorityQueue) 추가 가능
- 동시성 처리 (ConcurrentHashMap) 적용 가능
- 알림 만료/삭제 정책 추가 가능

---

## ❓ 자주 묻는 질문 (FAQ)

### Q1. ArrayList와 LinkedList 중 어느 것을 선택해야 하나요?

**A:** **대부분의 경우 ArrayList를 선택**하는 것이 좋습니다.

#### ArrayList를 선택하는 이유
```java
// 1. 조회가 압도적으로 빠름
List<String> arrayList = new ArrayList<>();
String item = arrayList.get(1000);  // O(1) - 즉시 조회

// 2. 메모리 효율적
// ArrayList: 연속된 메모리 공간 → 캐시 친화적
// LinkedList: 노드마다 next/prev 포인터 → 메모리 오버헤드
```

#### LinkedList를 선택하는 경우
```java
// FIFO 큐 구현 시
Queue<Task> taskQueue = new LinkedList<>();
taskQueue.offer(task);  // 끝에 추가 O(1)
Task next = taskQueue.poll();  // 앞에서 제거 O(1)

// 양방향 탐색이 필요한 경우
LinkedList<String> list = new LinkedList<>();
list.addFirst(item);  // O(1)
list.addLast(item);   // O(1)
```

#### 성능 비교
| 작업 | ArrayList | LinkedList | 승자 |
|------|-----------|------------|------|
| get(index) | O(1) | O(n) | ArrayList ✅ |
| add(끝) | O(1)* | O(1) | 동일 |
| add(0, item) | O(n) | O(1) | LinkedList ✅ |
| remove(index) | O(n) | O(n) | 비슷 |
| 메모리 | 적음 | 많음 | ArrayList ✅ |

*ArrayList는 용량 초과 시 O(n) 복사 발생

**결론**: 특별한 이유(Queue, 빈번한 앞/중간 삽입)가 없다면 **ArrayList 선택**

---

### Q2. HashSet과 TreeSet의 차이점과 선택 기준은?

**A:** **순서가 필요 없으면 HashSet, 정렬이 필요하면 TreeSet**을 선택합니다.

#### HashSet
```java
Set<Integer> hashSet = new HashSet<>();
hashSet.add(5);
hashSet.add(1);
hashSet.add(3);

System.out.println(hashSet);  // [1, 3, 5] 또는 [5, 1, 3] - 순서 보장 안 됨

// 특징
// - 내부: 해시 테이블
// - 성능: O(1) 추가/삭제/조회
// - 순서: 무관
// - null: 1개 허용
```

#### TreeSet
```java
Set<Integer> treeSet = new TreeSet<>();
treeSet.add(5);
treeSet.add(1);
treeSet.add(3);

System.out.println(treeSet);  // [1, 3, 5] - 항상 정렬됨

// 특징
// - 내부: 레드-블랙 트리
// - 성능: O(log n) 추가/삭제/조회
// - 순서: 자동 정렬
// - null: 불허 (NullPointerException)

// TreeSet 전용 메서드
Integer first = treeSet.first();  // 1
Integer last = treeSet.last();    // 5
SortedSet<Integer> subset = treeSet.subSet(2, 6);  // [3, 5]
```

#### LinkedHashSet
```java
Set<Integer> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add(5);
linkedHashSet.add(1);
linkedHashSet.add(3);

System.out.println(linkedHashSet);  // [5, 1, 3] - 삽입 순서 유지

// 특징
// - 내부: 해시 테이블 + 연결 리스트
// - 성능: O(1) (HashSet과 동일)
// - 순서: 삽입 순서 유지
// - null: 1개 허용
```

#### 선택 기준
```java
// 1. 순서 무관, 최고 성능 → HashSet
Set<String> uniqueUsers = new HashSet<>();

// 2. 정렬 필요 → TreeSet
Set<Integer> sortedScores = new TreeSet<>();

// 3. 삽입 순서 유지 → LinkedHashSet
Set<String> orderedTags = new LinkedHashSet<>();
```

---

### Q3. HashMap의 동작 원리와 충돌(Collision) 처리는?

**A:** HashMap은 **해시 함수**로 키를 버킷 인덱스로 변환하고, **충돌 시 체이닝** 또는 **트리**로 처리합니다.

#### HashMap 동작 원리

1. **해시 함수로 인덱스 계산**
```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 100);

// 내부 동작
int hashCode = "apple".hashCode();  // 93029210
int index = hashCode & (capacity - 1);  // 버킷 인덱스 계산 (비트 AND)
```

2. **충돌(Collision) 처리**

**같은 버킷에 여러 키가 매핑되는 경우:**

```java
// Java 7 이전: 연결 리스트 (Chaining)
// 버킷 [0] → Entry("apple", 100) → Entry("grape", 200) → null

// Java 8+: 리스트 → 트리 변환 (Treeify)
// 같은 버킷에 8개 이상 → Red-Black Tree로 변환
// O(n) → O(log n) 성능 개선
```

#### 성능에 영향을 주는 요소

1. **Load Factor (부하 계수)**
```java
// 기본값: 0.75 (75%)
Map<String, Integer> map = new HashMap<>(16, 0.75f);

// 용량의 75%가 차면 자동으로 확장 (Resize)
// 16 → 32 → 64 → 128 ...
// Resize는 비용이 크므로 초기 용량 설정 권장
```

2. **좋은 hashCode() 구현**
```java
// ❌ 나쁜 예: 모든 객체가 같은 해시코드 → 충돌 다발
@Override
public int hashCode() {
    return 1;  // 모든 객체가 같은 버킷에!
}

// ✅ 좋은 예: 골고루 분산
@Override
public int hashCode() {
    return Objects.hash(id, name, age);  // 필드 조합
}
```

#### 실무 팁
```java
// 1. 크기를 알면 초기 용량 지정
Map<String, User> users = new HashMap<>(10000);

// 2. ConcurrentHashMap: 멀티스레드 환경
Map<String, User> threadSafeMap = new ConcurrentHashMap<>();

// 3. LinkedHashMap: 삽입 순서 또는 접근 순서 유지
Map<String, User> orderedMap = new LinkedHashMap<>();
```

---

### Q4. Iterator를 사용해야 하는 이유는 무엇인가요?

**A:** **순회 중 안전하게 삭제**하고, **모든 컬렉션을 통일된 방식으로 순회**하기 위함입니다.

#### Iterator가 필요한 이유

1. **for-each 중 삭제 불가**
```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// ❌ ConcurrentModificationException 발생
for (Integer num : numbers) {
    if (num % 2 == 0) {
        numbers.remove(num);  // 💥 예외!
    }
}
```

2. **Iterator로 안전하게 삭제**
```java
Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    Integer num = iterator.next();
    if (num % 2 == 0) {
        iterator.remove();  // ✅ 안전!
    }
}
```

#### Iterator의 핵심 메서드

```java
Iterator<String> iterator = list.iterator();

// 1. hasNext(): 다음 요소 존재 여부
while (iterator.hasNext()) {

    // 2. next(): 다음 요소 조회
    String item = iterator.next();

    // 3. remove(): 현재 요소 삭제
    if (someCondition) {
        iterator.remove();
    }
}
```

#### Fail-Fast vs Fail-Safe

**Fail-Fast (ArrayList, HashMap 등)**
```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> iterator = list.iterator();

list.add("D");  // 외부에서 수정

iterator.next();  // 💥 ConcurrentModificationException!
// → 즉시 예외 발생 (빠른 실패)
```

**Fail-Safe (CopyOnWriteArrayList, ConcurrentHashMap 등)**
```java
List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> iterator = list.iterator();

list.add("D");  // 외부에서 수정

iterator.next();  // ✅ 정상 작동
// → 복사본을 순회하므로 안전
```

#### ListIterator (양방향)

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
ListIterator<String> iterator = list.listIterator();

// 순방향
while (iterator.hasNext()) {
    System.out.println(iterator.next());  // A B C
}

// 역방향
while (iterator.hasPrevious()) {
    System.out.println(iterator.previous());  // C B A
}

// 수정/삽입
iterator.set("X");  // 현재 요소 수정
iterator.add("Y");  // 현재 위치에 삽입
```

---

### Q5. Collections 유틸리티 클래스의 주요 기능은?

**A:** `Collections` 클래스는 **정렬, 검색, 동기화, 불변 컬렉션** 등 다양한 유틸리티 메서드를 제공합니다.

#### 1. 정렬 (Sorting)

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

// 오름차순 정렬
Collections.sort(numbers);
System.out.println(numbers);  // [1, 2, 5, 8, 9]

// 내림차순 정렬
Collections.sort(numbers, Collections.reverseOrder());
System.out.println(numbers);  // [9, 8, 5, 2, 1]

// 커스텀 Comparator
Collections.sort(numbers, (a, b) -> b - a);  // 내림차순
```

#### 2. 검색 (Binary Search)

```java
List<Integer> numbers = Arrays.asList(1, 3, 5, 7, 9);

// 이진 검색 (정렬된 리스트 필수!)
int index = Collections.binarySearch(numbers, 5);
System.out.println("인덱스: " + index);  // 2

// 없는 경우
index = Collections.binarySearch(numbers, 4);
System.out.println("삽입 위치: " + (-index - 1));  // 2 (음수 반환)
```

#### 3. 뒤집기, 섞기, 회전

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));

// 뒤집기
Collections.reverse(list);
System.out.println(list);  // [D, C, B, A]

// 섞기 (랜덤)
Collections.shuffle(list);
System.out.println(list);  // [B, D, A, C] (무작위)

// 회전 (거리만큼 이동)
Collections.rotate(list, 2);
System.out.println(list);  // [A, C, B, D] (오른쪽으로 2칸)
```

#### 4. 최대/최소값

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 9);

Integer max = Collections.max(numbers);
Integer min = Collections.min(numbers);

System.out.println("최대: " + max);  // 9
System.out.println("최소: " + min);  // 1
```

#### 5. 빈도 계산

```java
List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");

int count = Collections.frequency(words, "apple");
System.out.println("apple 등장 횟수: " + count);  // 3
```

#### 6. 불변 컬렉션 (Immutable)

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

// 불변 리스트 생성
List<String> immutableList = Collections.unmodifiableList(list);

immutableList.add("D");  // 💥 UnsupportedOperationException!

// 빈 불변 컬렉션
List<String> emptyList = Collections.emptyList();
Set<String> emptySet = Collections.emptySet();
Map<String, Integer> emptyMap = Collections.emptyMap();
```

#### 7. 동기화 (Thread-Safe)

```java
List<String> list = new ArrayList<>();

// 동기화된 리스트 생성
List<String> syncList = Collections.synchronizedList(list);

// 순회 시에는 여전히 동기화 필요!
synchronized (syncList) {
    for (String item : syncList) {
        System.out.println(item);
    }
}
```

#### 8. 싱글톤 컬렉션

```java
// 단일 요소만 포함하는 불변 컬렉션
Set<String> singletonSet = Collections.singleton("Only One");
List<String> singletonList = Collections.singletonList("Only One");
Map<String, Integer> singletonMap = Collections.singletonMap("key", 1);

singletonSet.add("Two");  // 💥 UnsupportedOperationException!
```

#### 9. 복사 (Copy)

```java
List<String> src = Arrays.asList("A", "B", "C");
List<String> dest = new ArrayList<>(Arrays.asList("1", "2", "3", "4"));

// dest에 src 복사 (dest는 충분히 커야 함)
Collections.copy(dest, src);
System.out.println(dest);  // [A, B, C, 4]
```

#### 10. 채우기 (Fill)

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

// 모든 요소를 "X"로 채우기
Collections.fill(list, "X");
System.out.println(list);  // [X, X, X]
```

---

### Q6. Java 8+의 컬렉션 새로운 기능은?

**A:** Java 8부터 **Stream API, 람다, 디폴트 메서드**로 컬렉션 처리가 획기적으로 개선되었습니다.

#### 1. forEach() - 함수형 순회

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// 전통적 방식
for (String name : names) {
    System.out.println(name);
}

// Java 8+ 람다
names.forEach(name -> System.out.println(name));

// 메서드 참조
names.forEach(System.out::println);
```

#### 2. removeIf() - 조건부 삭제

```java
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6));

// Java 7 이전
Iterator<Integer> iterator = numbers.iterator();
while (iterator.hasNext()) {
    if (iterator.next() % 2 == 0) {
        iterator.remove();
    }
}

// Java 8+
numbers.removeIf(n -> n % 2 == 0);
System.out.println(numbers);  // [1, 3, 5]
```

#### 3. replaceAll() - 일괄 변환

```java
List<String> names = Arrays.asList("alice", "bob", "charlie");

// Java 8+
names.replaceAll(String::toUpperCase);
System.out.println(names);  // [ALICE, BOB, CHARLIE]
```

#### 4. Map 고급 메서드

```java
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 90);
scores.put("Bob", 85);

// getOrDefault: 기본값 반환
int charlieScore = scores.getOrDefault("Charlie", 0);

// putIfAbsent: 없을 때만 추가
scores.putIfAbsent("Alice", 100);  // Alice 있으므로 무시
scores.putIfAbsent("Charlie", 80);  // Charlie 없으므로 추가

// compute: 값 계산하여 업데이트
scores.compute("Alice", (key, oldValue) -> oldValue + 10);  // 90 → 100

// computeIfPresent: 존재할 때만 계산
scores.computeIfPresent("Bob", (key, oldValue) -> oldValue - 5);  // 85 → 80

// computeIfAbsent: 없을 때만 계산
scores.computeIfAbsent("David", key -> 70);

// merge: 병합
scores.merge("Alice", 5, (oldValue, newValue) -> oldValue + newValue);  // 100 + 5 = 105

System.out.println(scores);
// {Alice=105, Bob=80, Charlie=80, David=70}
```

#### 5. Stream API 기본

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 필터링
List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());  // [2, 4]

// 매핑
List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());  // [2, 4, 6, 8, 10]

// 정렬
List<Integer> sorted = numbers.stream()
    .sorted(Comparator.reverseOrder())
    .collect(Collectors.toList());  // [5, 4, 3, 2, 1]

// 집계
int sum = numbers.stream().mapToInt(Integer::intValue).sum();  // 15
double avg = numbers.stream().mapToInt(Integer::intValue).average().orElse(0);  // 3.0
int max = numbers.stream().max(Integer::compare).orElse(0);  // 5
```

#### 6. Collectors 활용

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 리스트로 수집
List<String> upperNames = names.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

// Set으로 수집
Set<String> uniqueNames = names.stream()
    .collect(Collectors.toSet());

// 문자열 결합
String joined = names.stream()
    .collect(Collectors.joining(", "));  // "Alice, Bob, Charlie, David"

// 그룹핑
Map<Integer, List<String>> byLength = names.stream()
    .collect(Collectors.groupingBy(String::length));
// {3=[Bob], 5=[Alice, David], 7=[Charlie]}

// 파티셔닝 (true/false로 분할)
Map<Boolean, List<String>> partitioned = names.stream()
    .collect(Collectors.partitioningBy(name -> name.length() > 4));
// {false=[Bob], true=[Alice, Charlie, David]}
```

---

### Q7. 컬렉션 선택 시 고려해야 할 요소는?

**A:** **데이터 특성, 작업 빈도, 성능 요구사항, 동시성**을 고려하여 선택합니다.

#### 선택 흐름도

```
데이터 중복?
├─ 중복 허용 → List
│   ├─ 조회 많음 → ArrayList
│   └─ 삽입/삭제 많음 → LinkedList (Queue)
└─ 중복 불허 → Set
    ├─ 순서 무관 → HashSet
    ├─ 정렬 필요 → TreeSet
    └─ 삽입 순서 유지 → LinkedHashSet

Key-Value 쌍?
└─ Map
    ├─ 순서 무관 → HashMap
    ├─ 정렬 필요 → TreeMap
    └─ 삽입 순서 유지 → LinkedHashMap
```

#### 체크리스트

| 질문 | 답변 | 추천 |
|------|------|------|
| 중복 허용? | Yes | List |
| 중복 허용? | No | Set |
| Key-Value 쌍? | Yes | Map |
| 순서 중요? | Yes | ArrayList, LinkedHashMap |
| 정렬 필요? | Yes | TreeSet, TreeMap |
| 조회가 많음? | Yes | ArrayList, HashMap |
| 삽입/삭제 많음? | Yes | LinkedList, HashSet |
| null 허용? | Yes | ArrayList, HashMap |
| null 불허? | Yes | TreeSet, TreeMap |
| 멀티스레드? | Yes | ConcurrentHashMap |

#### 실무 사용 빈도

**가장 많이 사용 (90%)**
```java
List<T> list = new ArrayList<>();       // 범용 리스트
Set<T> set = new HashSet<>();           // 중복 제거
Map<K, V> map = new HashMap<>();        // Key-Value 저장
```

**가끔 사용 (9%)**
```java
Queue<T> queue = new LinkedList<>();           // FIFO 대기열
Map<K, V> orderedMap = new LinkedHashMap<>();  // 순서 유지
```

**드물게 사용 (1%)**
```java
Set<T> sortedSet = new TreeSet<>();            // 자동 정렬
Map<K, V> sortedMap = new TreeMap<>();         // 정렬된 맵
Deque<T> deque = new ArrayDeque<>();           // 양방향 큐
```

#### 실전 예시

```java
// 1. 사용자 목록 → ArrayList
List<User> users = new ArrayList<>();

// 2. 고유 태그 → HashSet
Set<String> tags = new HashSet<>();

// 3. 상품 ID → 상품 매핑 → HashMap
Map<String, Product> productMap = new HashMap<>();

// 4. 주문 처리 대기열 → Queue
Queue<Order> orderQueue = new LinkedList<>();

// 5. 정렬된 점수 → TreeSet
Set<Integer> scores = new TreeSet<>();

// 6. 캐시 (LRU) → LinkedHashMap
Map<String, Data> cache = new LinkedHashMap<>(16, 0.75f, true);  // 접근 순서

// 7. 멀티스레드 환경 → ConcurrentHashMap
Map<String, User> threadSafeMap = new ConcurrentHashMap<>();
```

---

## 🎤 면접 질문

### 주니어 레벨 (Junior Level)

#### Q1. List, Set, Map의 차이점을 설명해주세요.

**모범 답변:**

**List**
- 순서가 있는 컬렉션
- 중복 허용
- 인덱스로 접근 가능
- 구현체: ArrayList, LinkedList
```java
List<String> list = new ArrayList<>();
list.add("A");
list.add("A");  // 중복 허용
System.out.println(list.get(0));  // 인덱스 접근
```

**Set**
- 순서가 없는 컬렉션 (HashSet 기준)
- 중복 불허
- 인덱스 접근 불가
- 구현체: HashSet, TreeSet, LinkedHashSet
```java
Set<String> set = new HashSet<>();
set.add("A");
set.add("A");  // 중복 무시
System.out.println(set.size());  // 1
```

**Map**
- Key-Value 쌍으로 저장
- Key는 중복 불가, Value는 중복 가능
- Key로 빠른 조회
- 구현체: HashMap, TreeMap, LinkedHashMap
```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 1);
map.put("A", 2);  // Key 중복 → Value 덮어씀
System.out.println(map.get("A"));  // 2
```

---

#### Q2. ArrayList와 LinkedList의 성능 차이를 설명해주세요.

**모범 답변:**

**ArrayList**
- 내부 구조: 동적 배열
- 조회: O(1) - 인덱스로 즉시 접근
- 추가(끝): O(1)* - 용량 충분 시
- 추가(중간): O(n) - 요소 이동 필요
- 삭제: O(n) - 요소 이동 필요
- 메모리: 연속 공간, 캐시 친화적

```java
List<String> arrayList = new ArrayList<>();
String item = arrayList.get(1000);  // O(1) 빠름!
arrayList.add(0, "new");  // O(n) 느림 (모든 요소 이동)
```

**LinkedList**
- 내부 구조: 이중 연결 리스트
- 조회: O(n) - 순차 탐색
- 추가(앞/끝): O(1) - 포인터만 변경
- 추가(중간): O(n) - 위치 탐색 + O(1) 삽입
- 삭제(앞/끝): O(1)
- 메모리: 노드마다 next/prev 포인터 오버헤드

```java
LinkedList<String> linkedList = new LinkedList<>();
String item = linkedList.get(1000);  // O(n) 느림!
linkedList.addFirst("new");  // O(1) 빠름!
```

**선택 기준:**
- 조회가 많음 → ArrayList
- 앞/뒤 삽입/삭제 많음 → LinkedList (Queue로 사용)

---

#### Q3. HashSet은 어떻게 중복을 판단하나요?

**모범 답변:**

HashSet은 **hashCode()**와 **equals()** 두 메서드로 중복을 판단합니다.

**중복 판단 과정:**
1. 새 요소의 `hashCode()` 계산
2. 해시코드로 버킷 위치 찾기
3. 같은 버킷에 요소가 있으면 `equals()`로 비교
4. `equals()`가 true면 중복으로 판단, 추가 안 함

```java
class Student {
    private String id;
    private String name;

    // ✅ hashCode와 equals 구현 필수!
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Student)) return false;
        Student student = (Student) o;
        return id.equals(student.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);  // id로 해시코드 생성
    }
}

Set<Student> students = new HashSet<>();
students.add(new Student("S001", "김철수"));
students.add(new Student("S001", "김철수"));  // 중복 방지!
System.out.println(students.size());  // 1
```

**주의사항:**
- `equals()`가 true면 `hashCode()`도 반드시 같아야 함
- `hashCode()`가 같아도 `equals()`는 false일 수 있음

---

#### Q4. HashMap의 시간 복잡도는?

**모범 답변:**

HashMap의 기본 연산은 **평균 O(1)**입니다.

| 연산 | 평균 | 최악 |
|------|------|------|
| get(key) | O(1) | O(n) |
| put(key, value) | O(1) | O(n) |
| remove(key) | O(1) | O(n) |
| containsKey(key) | O(1) | O(n) |

**O(1)인 이유:**
- 해시 함수로 버킷 위치를 즉시 계산
- 충돌이 없으면 바로 접근

**O(n)이 되는 경우 (최악):**
- 모든 키가 같은 버킷에 충돌 (해시 함수가 나쁜 경우)
- 하지만 Java 8+에서는 같은 버킷에 8개 이상 충돌 시 트리로 변환 → O(log n)으로 개선

```java
Map<String, Integer> map = new HashMap<>();

// O(1) - 평균적으로 즉시 처리
map.put("key1", 100);
int value = map.get("key1");
boolean exists = map.containsKey("key1");
```

**성능을 위한 팁:**
1. 초기 용량 설정: `new HashMap<>(expectedSize)`
2. 좋은 `hashCode()` 구현: 골고루 분산
3. Load Factor 고려: 기본 0.75 유지

---

#### Q5. Iterator와 for-each의 차이는?

**모범 답변:**

**for-each**
- 간결한 문법
- 읽기 전용
- 순회 중 컬렉션 수정 불가

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

// ✅ 읽기만 가능
for (String item : list) {
    System.out.println(item);
}

// ❌ 삭제 불가
for (String item : list) {
    if (item.equals("B")) {
        list.remove(item);  // ConcurrentModificationException!
    }
}
```

**Iterator**
- 명시적 제어
- 순회 중 안전하게 삭제 가능
- `hasNext()`, `next()`, `remove()` 메서드

```java
Iterator<String> iterator = list.iterator();

// ✅ 삭제 가능
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("B")) {
        iterator.remove();  // 안전하게 삭제
    }
}
```

**내부 동작:**
- for-each는 내부적으로 Iterator를 사용
- 하지만 `iterator.remove()` 접근 불가

**언제 사용?**
- 단순 순회 → for-each
- 순회 중 삭제 → Iterator
- 복잡한 제어 → Iterator

---

#### Q6. Collections.sort()와 Comparable, Comparator의 차이는?

**모범 답변:**

**Comparable**: 객체 자체에 **자연스러운 순서** 정의
```java
class Student implements Comparable<Student> {
    private String name;
    private int score;

    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.score, other.score);  // 점수 오름차순
    }
}

List<Student> students = new ArrayList<>();
Collections.sort(students);  // Comparable 사용
```

**Comparator**: **외부에서 정렬 기준** 정의
```java
// 이름순 정렬
Comparator<Student> byName = (s1, s2) -> s1.name.compareTo(s2.name);
Collections.sort(students, byName);

// 점수 내림차순
Comparator<Student> byScoreDesc = (s1, s2) -> Integer.compare(s2.score, s1.score);
Collections.sort(students, byScoreDesc);

// Java 8+ Comparator 빌더
students.sort(Comparator.comparing(Student::getScore)
                       .thenComparing(Student::getName));
```

**차이점:**

| 특징 | Comparable | Comparator |
|------|------------|------------|
| 위치 | 클래스 내부 | 외부 |
| 메서드 | `compareTo(T)` | `compare(T, T)` |
| 개수 | 1개만 가능 | 여러 개 가능 |
| 용도 | 기본 정렬 | 다양한 정렬 |

**실무 사용:**
- Comparable: 가장 자연스러운 순서 (예: 숫자, 날짜)
- Comparator: 다양한 정렬 기준 (이름순, 점수순 등)

---

#### Q7. ArrayList의 초기 용량과 확장 메커니즘은?

**모범 답변:**

**초기 용량:**
```java
// 기본 생성자: 초기 용량 10
List<String> list1 = new ArrayList<>();

// 용량 지정
List<String> list2 = new ArrayList<>(100);

// 다른 컬렉션으로 초기화
List<String> list3 = new ArrayList<>(existingList);
```

**확장 메커니즘:**
1. 용량 초과 시 자동 확장
2. 새 용량 = 기존 용량 * 1.5 (대략)
3. 기존 배열 → 새 배열로 복사 (O(n))

```java
// 내부 동작 (단순화)
public void add(E element) {
    if (size == capacity) {
        int newCapacity = capacity + (capacity >> 1);  // capacity * 1.5
        Object[] newArray = new Object[newCapacity];
        System.arraycopy(oldArray, 0, newArray, 0, size);
        this.array = newArray;
    }
    array[size++] = element;
}

// 확장 과정
// 10 → 15 → 22 → 33 → 49 → 73 → ...
```

**성능 고려:**
```java
// ❌ 나쁜 예: 매번 확장
List<String> list = new ArrayList<>();  // 용량 10
for (int i = 0; i < 1000000; i++) {
    list.add("item" + i);  // 여러 번 확장 발생!
}

// ✅ 좋은 예: 초기 용량 지정
List<String> list = new ArrayList<>(1000000);
for (int i = 0; i < 1000000; i++) {
    list.add("item" + i);  // 확장 없음!
}
```

**ensureCapacity() 메서드:**
```java
List<String> list = new ArrayList<>();
list.ensureCapacity(1000);  // 사전에 용량 확보
```

---

### 중급 레벨 (Intermediate Level)

#### Q8. HashMap의 Load Factor와 Resize 메커니즘을 설명해주세요.

**모범 답변:**

**Load Factor (부하 계수):**
- HashMap이 얼마나 차면 확장할지 결정하는 임계값
- 기본값: 0.75 (75%)
- 계산: `size / capacity`

```java
// 기본 생성자
Map<String, Integer> map = new HashMap<>();
// 초기 용량 16, Load Factor 0.75
// 16 * 0.75 = 12개가 차면 확장

// 커스텀 설정
Map<String, Integer> map = new HashMap<>(32, 0.75f);
```

**Resize 메커니즘:**

1. **확장 조건**
```java
if (size > capacity * loadFactor) {
    resize();  // 확장!
}
```

2. **확장 과정**
```java
// 1. 새 용량 계산 (기존의 2배)
int newCapacity = oldCapacity * 2;  // 16 → 32 → 64 → 128 ...

// 2. 새 버킷 배열 생성
Node[] newTable = new Node[newCapacity];

// 3. 기존 요소 재배치 (Rehashing)
for (Node node : oldTable) {
    int newIndex = node.hash & (newCapacity - 1);
    newTable[newIndex] = node;
}
```

3. **Rehashing 비용**
- 모든 요소를 새 버킷에 재배치 → O(n)
- 해시 함수 재계산 (인덱스 변경)
- 성능 저하 발생

**Load Factor 선택:**

```java
// Load Factor 낮음 (0.5) → 메모리 낭비, 충돌 적음
Map<String, Integer> spacious = new HashMap<>(16, 0.5f);

// Load Factor 높음 (0.9) → 메모리 효율적, 충돌 많음
Map<String, Integer> compact = new HashMap<>(16, 0.9f);

// 권장: 기본값 0.75 사용 (메모리와 성능의 균형)
```

**성능 최적화:**

```java
// ❌ 나쁜 예: 빈번한 Resize
Map<String, Integer> map = new HashMap<>();  // 용량 16
for (int i = 0; i < 10000; i++) {
    map.put("key" + i, i);  // 여러 번 Resize!
}

// ✅ 좋은 예: 초기 용량 충분히 설정
int expectedSize = 10000;
int capacity = (int) (expectedSize / 0.75) + 1;
Map<String, Integer> map = new HashMap<>(capacity);
for (int i = 0; i < 10000; i++) {
    map.put("key" + i, i);  // Resize 없음!
}
```

---

#### Q9. ConcurrentHashMap과 일반 HashMap의 차이와 동작 원리는?

**모범 답변:**

**HashMap (Thread-Unsafe)**
```java
Map<String, Integer> map = new HashMap<>();

// 멀티스레드 환경에서 위험!
// Thread 1: map.put("A", 1);
// Thread 2: map.put("B", 2);
// → 데이터 손실, 무한 루프 가능
```

**ConcurrentHashMap (Thread-Safe)**
```java
Map<String, Integer> map = new ConcurrentHashMap<>();

// 멀티스레드 환경에서 안전!
// Thread 1: map.put("A", 1);
// Thread 2: map.put("B", 2);
// → 정상 동작
```

**동작 원리 차이:**

**HashMap**
- 동기화 없음
- 빠르지만 Thread-Unsafe
- 단일 스레드 환경에만 사용

**ConcurrentHashMap (Java 7)**
- Segment 단위 Lock (16개 Segment)
- 다른 Segment는 동시 접근 가능
- 세밀한 Lock으로 성능 향상

**ConcurrentHashMap (Java 8+)**
- CAS (Compare-And-Swap) 알고리즘 사용
- Segment 제거, 버킷 단위 Lock
- 읽기는 Lock 없이 가능 (더 빠름)

```java
// Java 8+ 내부 동작 (단순화)
public V put(K key, V value) {
    int hash = spread(key.hashCode());
    Node<K,V>[] tab = table;

    // 1. 버킷이 비어있으면 CAS로 추가
    if (tab[index] == null) {
        if (casTabAt(tab, index, null, newNode)) {
            return null;  // Lock 없이 추가!
        }
    }

    // 2. 충돌 시 해당 버킷만 Lock
    synchronized (tab[index]) {
        // 버킷 내 추가/업데이트
    }
}
```

**성능 비교:**

| 특징 | HashMap | ConcurrentHashMap |
|------|---------|-------------------|
| Thread-Safe | ❌ | ✅ |
| 읽기 성능 | 매우 빠름 | 빠름 (Lock 없음) |
| 쓰기 성능 | 매우 빠름 | 빠름 (버킷 단위 Lock) |
| null Key/Value | 허용 | 불허 |
| Fail-Fast | Yes | Weakly Consistent |

**사용 시나리오:**

```java
// 단일 스레드 → HashMap
Map<String, User> singleThreadMap = new HashMap<>();

// 멀티스레드 → ConcurrentHashMap
Map<String, User> multiThreadMap = new ConcurrentHashMap<>();

// 동기화된 HashMap (레거시, 비추천)
Map<String, User> syncMap = Collections.synchronizedMap(new HashMap<>());
```

**ConcurrentHashMap 전용 메서드:**

```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// 원자적 연산
map.putIfAbsent("key", 1);
map.replace("key", 1, 2);  // oldValue가 1이면 2로 변경

// Bulk 연산 (병렬 처리)
map.forEach(1, (key, value) -> System.out.println(key + ": " + value));
map.search(1, (key, value) -> value > 10 ? key : null);
```

---

#### Q10. fail-fast와 fail-safe Iterator의 차이는?

**모범 답변:**

**fail-fast Iterator**
- 순회 중 컬렉션이 **구조적으로 변경**되면 즉시 예외 발생
- HashMap, ArrayList, HashSet 등

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> iterator = list.iterator();

// 순회 중 외부에서 수정
list.add("D");  // 구조적 변경!

try {
    iterator.next();  // 💥 ConcurrentModificationException!
} catch (ConcurrentModificationException e) {
    System.out.println("fail-fast: 즉시 예외 발생");
}
```

**동작 원리:**
```java
// 내부 구현 (단순화)
private int modCount = 0;  // 수정 횟수

public void add(E element) {
    modCount++;  // 수정 시 증가
    // ...
}

public Iterator<E> iterator() {
    return new Itr(modCount);  // 현재 modCount 저장
}

class Itr implements Iterator<E> {
    private int expectedModCount;

    public E next() {
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();  // 즉시 실패!
        }
        // ...
    }
}
```

**fail-safe Iterator**
- 순회 중 컬렉션이 변경되어도 예외 발생 안 함
- **복사본**을 순회하거나 **동시성** 지원
- CopyOnWriteArrayList, ConcurrentHashMap 등

```java
List<String> list = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));
Iterator<String> iterator = list.iterator();

// 순회 중 수정
list.add("D");

iterator.next();  // ✅ 정상 작동! (복사본 순회)
```

**동작 원리:**
```java
// CopyOnWriteArrayList 내부 (단순화)
private volatile Object[] array;

public Iterator<E> iterator() {
    return new COWIterator<>(array);  // 현재 배열의 스냅샷
}

class COWIterator<E> implements Iterator<E> {
    private final Object[] snapshot;  // 복사본 참조

    public E next() {
        return (E) snapshot[cursor++];  // 복사본 순회
    }
}
```

**비교 표:**

| 특징 | fail-fast | fail-safe |
|------|-----------|-----------|
| 예외 발생 | Yes (ConcurrentModificationException) | No |
| 메모리 | 효율적 | 복사본 생성 (오버헤드) |
| 일관성 | 즉시 반영 안 됨 | Weakly Consistent |
| 성능 | 빠름 | 느림 (복사 비용) |
| 사용 예 | ArrayList, HashMap | CopyOnWriteArrayList |

**Weakly Consistent (약한 일관성):**
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("A", 1);
map.put("B", 2);
map.put("C", 3);

// 순회 시작
Iterator<String> iterator = map.keySet().iterator();

// 순회 중 추가
map.put("D", 4);

// D가 보일 수도, 안 보일 수도 있음 (Weakly Consistent)
while (iterator.hasNext()) {
    System.out.println(iterator.next());  // A, B, C (D는 불확실)
}
```

**선택 기준:**
```java
// 단일 스레드, 높은 성능 → fail-fast (ArrayList, HashMap)
List<String> list = new ArrayList<>();

// 멀티스레드, 안전성 → fail-safe (CopyOnWriteArrayList)
List<String> threadSafeList = new CopyOnWriteArrayList<>();

// 읽기 많음, 쓰기 적음 → CopyOnWriteArrayList
// 쓰기 많음 → ConcurrentHashMap
```

---

#### Q11. TreeMap과 HashMap의 내부 구조와 성능 차이는?

**모범 답변:**

**HashMap**
- **내부 구조**: 해시 테이블 (배열 + 연결 리스트/트리)
- **정렬**: 없음 (순서 보장 안 됨)
- **성능**: O(1) - 평균
- **null**: Key 1개, Value 여러 개 허용

```java
Map<String, Integer> hashMap = new HashMap<>();
hashMap.put("C", 3);
hashMap.put("A", 1);
hashMap.put("B", 2);

System.out.println(hashMap);  // {A=1, B=2, C=3} 또는 다른 순서 (무작위)

// 내부 구조
// 버킷 [0] → null
// 버킷 [1] → Entry("A", 1)
// 버킷 [2] → Entry("B", 2) → Entry("C", 3)  // 충돌 시 연결
// ...
```

**TreeMap**
- **내부 구조**: 레드-블랙 트리 (자가 균형 이진 탐색 트리)
- **정렬**: Key 기준 자동 정렬 (자연 순서 또는 Comparator)
- **성능**: O(log n)
- **null**: Key 불허 (NullPointerException)

```java
Map<String, Integer> treeMap = new TreeMap<>();
treeMap.put("C", 3);
treeMap.put("A", 1);
treeMap.put("B", 2);

System.out.println(treeMap);  // {A=1, B=2, C=3} - 항상 정렬됨

// 내부 구조 (Red-Black Tree)
//       B(black)
//      /        \
//   A(red)    C(red)
```

**성능 비교:**

| 연산 | HashMap | TreeMap |
|------|---------|---------|
| get/put/remove | O(1) | O(log n) |
| 순회 | O(n) | O(n) |
| 정렬 여부 | ❌ | ✅ |
| 메모리 | 적음 | 많음 (노드 구조) |

**TreeMap 전용 메서드:**

```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(5, "five");
map.put(1, "one");
map.put(3, "three");
map.put(7, "seven");

// 첫/마지막 Key
Integer firstKey = map.firstKey();  // 1
Integer lastKey = map.lastKey();    // 7

// 첫/마지막 Entry
Map.Entry<Integer, String> firstEntry = map.firstEntry();  // 1=one
Map.Entry<Integer, String> lastEntry = map.lastEntry();    // 7=seven

// 범위 조회
SortedMap<Integer, String> subMap = map.subMap(2, 6);  // {3=three, 5=five}
SortedMap<Integer, String> headMap = map.headMap(4);   // {1=one, 3=three}
SortedMap<Integer, String> tailMap = map.tailMap(4);   // {5=five, 7=seven}

// 특정 Key 근처
Integer lowerKey = map.lowerKey(4);   // 3 (4보다 작은 최대 Key)
Integer higherKey = map.higherKey(4); // 5 (4보다 큰 최소 Key)
```

**사용 시나리오:**

```java
// 1. 순서 무관, 빠른 조회 → HashMap
Map<String, User> userCache = new HashMap<>();

// 2. 정렬된 Key 필요 → TreeMap
Map<LocalDate, List<Event>> eventsByDate = new TreeMap<>();  // 날짜순 정렬

// 3. 범위 조회 필요 → TreeMap
TreeMap<Integer, Product> productsByPrice = new TreeMap<>();
SortedMap<Integer, Product> affordable = productsByPrice.subMap(10000, 50000);

// 4. 삽입 순서 유지 → LinkedHashMap
Map<String, String> orderedMap = new LinkedHashMap<>();
```

**성능 테스트:**

```java
int size = 100000;

// HashMap 테스트
Map<Integer, String> hashMap = new HashMap<>();
long start = System.currentTimeMillis();
for (int i = 0; i < size; i++) {
    hashMap.put(i, "value" + i);
}
long hashMapTime = System.currentTimeMillis() - start;

// TreeMap 테스트
Map<Integer, String> treeMap = new TreeMap<>();
start = System.currentTimeMillis();
for (int i = 0; i < size; i++) {
    treeMap.put(i, "value" + i);
}
long treeMapTime = System.currentTimeMillis() - start;

System.out.println("HashMap: " + hashMapTime + "ms");  // ~10ms
System.out.println("TreeMap: " + treeMapTime + "ms");  // ~50ms
```

---

#### Q12. Java 컬렉션에서 동시성 문제를 해결하는 방법들을 설명해주세요.

**모범 답변:**

**1. Collections.synchronizedXXX() (레거시)**
```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
Set<String> set = Collections.synchronizedSet(new HashSet<>());
Map<String, Integer> map = Collections.synchronizedMap(new HashMap<>());

// 모든 메서드에 synchronized 키워드 추가
// 단점: 성능 저하, 순회 시 여전히 수동 동기화 필요
synchronized (list) {
    for (String item : list) {
        System.out.println(item);
    }
}
```

**2. ConcurrentHashMap (추천)**
```java
// Java 8+ 최적화된 동시성 Map
Map<String, Integer> map = new ConcurrentHashMap<>();

// 특징
// - 읽기: Lock 없음 (빠름)
// - 쓰기: 버킷 단위 Lock (세밀한 동기화)
// - null 불허
// - Weakly Consistent Iterator

// 원자적 연산
map.putIfAbsent("key", 1);
map.computeIfAbsent("key", k -> expensiveOperation());
map.merge("key", 1, (old, add) -> old + add);
```

**3. CopyOnWriteArrayList**
```java
// 읽기 많고 쓰기 적은 경우
List<String> list = new CopyOnWriteArrayList<>();

// 특징
// - 읽기: Lock 없음, 매우 빠름
// - 쓰기: 전체 배열 복사 (느림!)
// - Snapshot Iterator (fail-safe)

// 사용 사례: 이벤트 리스너 목록
List<EventListener> listeners = new CopyOnWriteArrayList<>();
```

**4. ConcurrentLinkedQueue**
```java
// Lock-free 큐
Queue<Task> taskQueue = new ConcurrentLinkedQueue<>();

// 특징
// - CAS (Compare-And-Swap) 알고리즘
// - Lock 없이 동작
// - 높은 처리량

taskQueue.offer(task);  // 추가
Task task = taskQueue.poll();  // 제거
```

**5. BlockingQueue**
```java
// Producer-Consumer 패턴
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(100);

// Producer 스레드
queue.put(task);  // 큐가 가득 차면 대기

// Consumer 스레드
Task task = queue.take();  // 큐가 비어있으면 대기

// 종류
// - ArrayBlockingQueue: 고정 크기 배열
// - LinkedBlockingQueue: 연결 리스트 (무제한 또는 제한)
// - PriorityBlockingQueue: 우선순위 큐
// - DelayQueue: 지연 후 처리
```

**6. ConcurrentSkipListMap/Set**
```java
// TreeMap/TreeSet의 동시성 버전
NavigableMap<Integer, String> map = new ConcurrentSkipListMap<>();
NavigableSet<Integer> set = new ConcurrentSkipListSet<>();

// 특징
// - 정렬 유지
// - O(log n) 성능
// - Lock-free
```

**비교 표:**

| 컬렉션 | 읽기 | 쓰기 | 정렬 | 사용 사례 |
|--------|------|------|------|----------|
| ConcurrentHashMap | 빠름 | 빠름 | ❌ | 범용 Map |
| CopyOnWriteArrayList | 매우 빠름 | 느림 | ❌ | 리스너 목록 |
| ConcurrentLinkedQueue | 빠름 | 빠름 | ❌ | 작업 큐 |
| BlockingQueue | 빠름 | 빠름 | ❌ | Producer-Consumer |
| ConcurrentSkipListMap | 보통 | 보통 | ✅ | 정렬된 Map |

**실무 사용 예시:**

```java
// 1. 사용자 세션 캐시
Map<String, UserSession> sessions = new ConcurrentHashMap<>();

// 2. 이벤트 리스너 (읽기 많음)
List<EventListener> listeners = new CopyOnWriteArrayList<>();

// 3. 비동기 작업 큐
BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(1000);

// 4. 실시간 점수 순위 (정렬 필요)
NavigableMap<Integer, Player> leaderboard = new ConcurrentSkipListMap<>(
    Comparator.reverseOrder()  // 점수 내림차순
);
```

**선택 가이드:**
1. **일반적인 Map** → ConcurrentHashMap
2. **읽기 위주 List** → CopyOnWriteArrayList
3. **Producer-Consumer** → BlockingQueue
4. **정렬 필요** → ConcurrentSkipListMap
5. **레거시 코드** → Collections.synchronizedXXX()

---

## 🎯 Part 3 핵심 요약

### 실전 프로젝트 핵심
1. **컬렉션 조합**: Queue(대기열) + Set(중복방지) + Map(사용자별 조회) + List(이력)
2. **Stream API**: 필터링, 그룹핑, 정렬을 선언적으로 처리
3. **성능 최적화**: 각 컬렉션의 특성에 맞는 작업 할당

### 면접 대비 핵심 키워드
- **List vs Set vs Map**: 순서, 중복, 인덱스, Key-Value
- **ArrayList vs LinkedList**: 조회 O(1) vs 삽입/삭제 O(1)
- **HashSet 중복 판단**: hashCode() + equals()
- **HashMap 성능**: 평균 O(1), 최악 O(n) → Java 8+ O(log n)
- **Iterator**: 순회 중 안전한 삭제
- **fail-fast vs fail-safe**: 즉시 예외 vs 복사본 순회
- **동시성**: ConcurrentHashMap, CopyOnWriteArrayList

### 실무 선택 가이드
- **범용**: ArrayList, HashMap, HashSet
- **정렬**: TreeSet, TreeMap
- **순서 유지**: LinkedHashSet, LinkedHashMap
- **Queue**: LinkedList, PriorityQueue
- **멀티스레드**: ConcurrentHashMap, CopyOnWriteArrayList

---

**25장 컬렉션 프레임워크 개요 완료!** 🎉

다음 26장에서는 **List 인터페이스**를 심화 학습합니다!
