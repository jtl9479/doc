# 09-2장: 클래스와 객체 (심화편)

> **이전 내용 요약**: 09-1장에서는 클래스와 객체의 기본 개념, 실생활 비유, 기본 실습, 실무 사례, 주니어 시나리오, 실전 프로젝트를 다뤘습니다.

> **이번 장의 목표**: FAQ, 면접 질문, 핵심 정리를 통해 클래스와 객체에 대한 완벽한 이해를 달성합니다.

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [FAQ (자주 묻는 질문)](#-faq)
- [면접 질문 리스트](#-면접-질문-리스트)
- [핵심 정리](#-핵심-정리)
- [관련 기술](#-관련-기술)
- [다음 단계](#-다음-단계)
- [추가 학습 자료](#-추가-학습-자료)

---

## ❓ FAQ

<details>
<summary><strong>Q1: 클래스와 객체의 차이가 정확히 뭔가요?</strong></summary>

**A**: **클래스는 설계도, 객체는 실제 제품**입니다.

**상세 설명**:
- **클래스**: 객체를 만들기 위한 틀(template)
  - 1번만 정의
  - 코드로 작성된 "레시피"
  - 메모리를 차지하지 않음 (Method Area에만 정보 저장)

- **객체**: 클래스를 기반으로 만든 실체(instance)
  - 필요한 만큼 무한 생성 가능
  - 실제 데이터를 담음
  - Heap 메모리 사용

**예시**:
```java
// 클래스 (설계도) - 1개
class Cookie {
    String flavor;
}

// 객체 (실제 쿠키) - 여러 개
Cookie cookie1 = new Cookie();  // 초코 쿠키
cookie1.flavor = "초코";

Cookie cookie2 = new Cookie();  // 딸기 쿠키
cookie2.flavor = "딸기";

Cookie cookie3 = new Cookie();  // 바닐라 쿠키
cookie3.flavor = "바닐라";
```

**실무 팁**:
💡 "Cookie 클래스로 cookie1, cookie2, cookie3 **인스턴스**를 만들었다"라고 표현합니다.

</details>

<details>
<summary><strong>Q2: new 키워드는 정확히 무엇을 하는 건가요?</strong></summary>

**A**: **Heap 메모리에 객체를 생성하고, 그 주소를 반환**합니다.

**상세 설명**:
`new` 키워드는 3가지 일을 합니다:

1. **Heap 메모리 할당**: 객체 크기만큼 메모리 공간 확보
2. **생성자 호출**: 객체 초기화
3. **주소 반환**: 생성된 객체의 메모리 주소 반환

**예시**:
```java
// 1. Heap에 Student 크기만큼 메모리 할당
// 2. Student() 생성자 호출
// 3. 주소(예: 0x1234)를 student에 저장
Student student = new Student();

// student 변수에는 실제 데이터가 아니라 "주소"가 저장됨
```

**메모리 구조**:
```
Stack               Heap
┌──────────┐       ┌──────────────┐
│ student  │ ────→ │ Student 객체 │ 0x1234
│ 0x1234   │       │ name: null   │
└──────────┘       │ age: 0       │
                   └──────────────┘
```

**실무 팁**:
💡 `new`를 호출할 때마다 새로운 객체가 Heap에 생성됩니다. 불필요한 객체 생성은 메모리 낭비와 GC 부담을 유발합니다.

</details>

<details>
<summary><strong>Q3: 생성자가 왜 필요한가요? 그냥 필드에 값을 넣으면 안 되나요?</strong></summary>

**A**: **생성자는 객체를 "안전하게 초기화"하기 위해 필요**합니다.

**생성자 없이 사용할 때의 문제**:
```java
class BankAccount {
    String accountNumber;
    long balance;
}

// 문제 1: 값을 깜빡하고 안 넣을 수 있음
BankAccount account = new BankAccount();
// accountNumber가 null 상태로 사용될 위험

// 문제 2: 여러 줄에 걸쳐 초기화 (실수하기 쉬움)
account.accountNumber = "110-123-456";
account.balance = 0;
```

**생성자를 사용하면**:
```java
class BankAccount {
    String accountNumber;
    long balance;

    // 생성자: 객체 생성 시 반드시 초기화
    BankAccount(String accountNumber) {
        this.accountNumber = accountNumber;
        this.balance = 0;  // 기본값 설정
    }
}

// 사용: 한 줄로 안전하게 생성
BankAccount account = new BankAccount("110-123-456");
// 반드시 계좌번호를 입력해야 객체 생성 가능
```

**장점**:
1. **필수 값 강제**: 생성자 매개변수로 필수값 요구
2. **일관성**: 객체가 항상 유효한 상태로 시작
3. **편의성**: 한 줄로 객체 생성 + 초기화

**실무 팁**:
💡 생성자에서 유효성 검사를 하면 잘못된 객체 생성을 방지할 수 있습니다.

```java
BankAccount(String accountNumber, long initialBalance) {
    if (initialBalance < 0) {
        throw new IllegalArgumentException("초기 잔액은 0 이상이어야 합니다");
    }
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
}
```

</details>

<details>
<summary><strong>Q4: this 키워드를 언제 사용해야 하나요?</strong></summary>

**A**: **필드와 매개변수 이름이 같을 때** 반드시 사용하고, **코드 명확성**을 위해 권장됩니다.

**필수 사용 케이스**:
```java
class Student {
    String name;

    // ❌ this 없으면 동작 안 함
    Student(String name) {
        name = name;  // 둘 다 매개변수를 가리킴 (필드는 null)
    }

    // ✅ this로 구분
    Student(String name) {
        this.name = name;  // this.name은 필드, name은 매개변수
    }
}
```

**선택 사용 케이스**:
```java
class Student {
    String name;

    void printInfo() {
        // 두 줄은 동일하지만, this를 쓰는 것이 더 명확
        System.out.println(name);       // OK
        System.out.println(this.name);  // Better (명확성)
    }
}
```

**this의 다른 용도**:
```java
class Student {
    String name;
    int age;

    // 용도 1: 필드 접근
    Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 용도 2: 다른 생성자 호출
    Student(String name) {
        this(name, 0);  // 다른 생성자 호출
    }

    // 용도 3: 자기 자신 반환
    Student setName(String name) {
        this.name = name;
        return this;  // 메서드 체이닝 가능
    }
}

// 메서드 체이닝 사용
Student student = new Student("김철수")
    .setName("이영희");
```

**실무 팁**:
💡 현대적인 Java 코딩 스타일에서는 명확성을 위해 `this`를 적극 사용합니다.

</details>

<details>
<summary><strong>Q5: 객체를 비교할 때 == vs equals()의 차이는?</strong></summary>

**A**: **`==`는 주소 비교, `equals()`는 값 비교**입니다.

**예시**:
```java
class Student {
    String name;

    Student(String name) {
        this.name = name;
    }
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student("김철수");
        Student s2 = new Student("김철수");
        Student s3 = s1;

        // == : 주소(참조) 비교
        System.out.println(s1 == s2);  // false (다른 객체)
        System.out.println(s1 == s3);  // true (같은 객체)

        // equals() : 값 비교 (String은 자동 구현됨)
        System.out.println(s1.name.equals(s2.name));  // true (같은 이름)
    }
}
```

**메모리 구조**:
```
Stack           Heap
┌────┐         ┌─────────────┐
│ s1 │ ──────→ │ Student 객체 │ 0x100
└────┘         │ name: "김철수"|
               └─────────────┘
┌────┐         ┌─────────────┐
│ s2 │ ──────→ │ Student 객체 │ 0x200
└────┘         │ name: "김철수"|
               └─────────────┘
┌────┐
│ s3 │ ──────→ (s1과 같은 주소)
└────┘

s1 == s2  → false (0x100 ≠ 0x200)
s1 == s3  → true  (0x100 == 0x100)
```

**equals() 직접 구현**:
```java
class Student {
    String name;
    int studentId;

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (!(obj instanceof Student)) return false;

        Student other = (Student) obj;
        return this.studentId == other.studentId;  // 학번으로 비교
    }
}
```

**실무 팁**:
💡 객체를 Set/Map에 넣을 때는 `equals()`와 `hashCode()`를 함께 구현해야 합니다.

</details>

<details>
<summary><strong>Q6: 클래스는 몇 개까지 만들 수 있나요? 너무 많으면 안 좋나요?</strong></summary>

**A**: **개수 제한은 없지만, 역할이 명확한 클래스를 적절히 만드는 것이 좋습니다.**

**나쁜 예 1: 클래스가 너무 적음 (God Class)**
```java
// 하나의 클래스가 모든 기능을 다 함 (안티패턴)
class Everything {
    // 사용자 관련
    String userName;
    String userEmail;

    // 주문 관련
    String orderId;
    int orderAmount;

    // 배송 관련
    String deliveryAddress;
    String trackingNumber;

    // 100개의 메서드...
}
```

**좋은 예: 역할별로 분리**
```java
// 각 클래스가 명확한 역할을 가짐
class User {
    String name;
    String email;
}

class Order {
    String orderId;
    int amount;
    User customer;
}

class Delivery {
    String address;
    String trackingNumber;
    Order order;
}
```

**클래스 개수 가이드**:

| 프로젝트 규모 | 적정 클래스 수 | 예시 |
|--------------|---------------|------|
| 입문 프로젝트 | 3-5개 | Student, Course, Grade |
| 소규모 | 10-20개 | 도서관 시스템 |
| 중규모 | 50-100개 | 쇼핑몰 |
| 대규모 | 1000개 이상 | 배달의민족 |

**실무 팁**:
💡 **단일 책임 원칙(SRP)**: 한 클래스는 한 가지 책임만 가져야 합니다.

</details>

<details>
<summary><strong>Q7: static이 없는 메서드와 있는 메서드의 차이는 뭔가요?</strong></summary>

**A**: **static 메서드는 클래스에 속하고, 인스턴스 메서드는 객체에 속합니다.**

**인스턴스 메서드 (static 없음)**:
```java
class Calculator {
    int result;  // 인스턴스 변수

    // 인스턴스 메서드: 객체마다 다른 동작
    void add(int num) {
        result += num;
    }
}

// 사용: 객체 생성 필요
Calculator calc1 = new Calculator();
calc1.add(10);
System.out.println(calc1.result);  // 10

Calculator calc2 = new Calculator();
calc2.add(20);
System.out.println(calc2.result);  // 20 (다른 객체, 다른 결과)
```

**static 메서드**:
```java
class MathUtil {
    // static 메서드: 모든 객체가 공유
    static int add(int a, int b) {
        return a + b;
    }
}

// 사용: 객체 생성 없이 클래스 이름으로 호출
int result = MathUtil.add(10, 20);  // 30
```

**차이점 비교**:

| 구분 | 인스턴스 메서드 | static 메서드 |
|------|----------------|--------------|
| 호출 방법 | `객체.메서드()` | `클래스.메서드()` |
| 객체 생성 | 필요 | 불필요 |
| 인스턴스 변수 접근 | 가능 | 불가능 |
| 메모리 | 객체마다 별도 | 클래스당 1개 |
| 사용 시기 | 객체 상태 사용 | 유틸리티 기능 |

**실무 예시**:
```java
// String 클래스의 static 메서드
String str = String.valueOf(123);  // 객체 생성 없이 사용

// System 클래스의 static 메서드
System.out.println("Hello");  // System 객체 생성 안 함

// Math 클래스의 static 메서드
double result = Math.sqrt(25);  // Math 객체 생성 안 함
```

**실무 팁**:
💡 객체의 상태(필드)를 사용하지 않는 메서드는 static으로 만드는 것을 고려하세요.

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. 클래스와 객체의 차이를 설명해주세요</strong></summary>

**모범 답안 포인트**
- 클래스는 설계도/틀, 객체는 실체
- 클래스는 1개, 객체는 여러 개 생성 가능
- 실생활 비유 사용

**예시 답변**
> "클래스는 객체를 만들기 위한 설계도입니다. 예를 들어, 붕어빵 틀이 클래스라면 실제로 만들어진 붕어빵들이 객체입니다.
> 하나의 클래스로 필요한 만큼의 객체를 생성할 수 있고, 각 객체는 같은 구조를 가지지만 다른 값을 저장할 수 있습니다.
>
> 코드로 예를 들면, `class Student`로 학생 클래스를 정의하고, `new Student()`로 김철수, 이영희 등 여러 학생 객체를 생성할 수 있습니다."

**꼬리 질문**
- Q: 인스턴스(instance)는 무엇인가요?
- A: "인스턴스는 특정 클래스로 만든 객체를 지칭할 때 사용하는 용어입니다. '이 객체는 Student 클래스의 인스턴스다'라고 표현합니다."

**실무 연관**
- 실무에서는 수백 개의 클래스와 수천 개의 객체를 다룹니다
- 클래스 설계가 좋아야 유지보수가 쉬워집니다

</details>

<details>
<summary><strong>2. new 키워드의 역할을 설명해주세요</strong></summary>

**모범 답안 포인트**
- Heap 메모리에 객체 생성
- 생성자 호출
- 주소 반환

**예시 답변**
> "`new` 키워드는 객체를 생성할 때 사용합니다. 구체적으로 세 가지 일을 합니다.
>
> 첫째, Heap 메모리 영역에 객체 크기만큼 공간을 할당합니다.
> 둘째, 생성자를 호출하여 객체를 초기화합니다.
> 셋째, 생성된 객체의 메모리 주소를 반환합니다.
>
> 예를 들어 `Student student = new Student();`라고 하면, Heap에 Student 객체가 만들어지고 그 주소가 student 변수에 저장됩니다."

**꼬리 질문**
- Q: new 없이 객체를 만들 수 있나요?
- A: "리플렉션(Reflection)이나 Clone, 역직렬화를 사용하면 new 없이도 객체를 만들 수 있지만, 일반적인 경우에는 new를 사용합니다."

**실무 연관**
- 객체 생성은 메모리와 성능에 영향을 줍니다
- 불필요한 객체 생성은 GC 부담을 증가시킵니다

</details>

<details>
<summary><strong>3. 생성자(Constructor)의 역할은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 객체 초기화
- 필수 값 설정 강제
- 객체를 안전한 상태로 만듦

**예시 답변**
> "생성자는 객체가 생성될 때 자동으로 호출되어 객체를 초기화하는 특별한 메서드입니다.
>
> 주요 역할은 세 가지입니다.
> 첫째, 필드에 초기값을 설정합니다.
> 둘째, 필수 값을 생성자 매개변수로 요구하여 불완전한 객체 생성을 방지합니다.
> 셋째, 유효성 검사를 수행하여 잘못된 값으로 객체가 만들어지는 것을 막습니다.
>
> 예를 들어, 은행 계좌를 생성할 때 계좌번호는 필수이므로 생성자에서 반드시 받도록 설계할 수 있습니다."

**꼬리 질문**
- Q: 생성자를 여러 개 만들 수 있나요?
- A: "네, 생성자 오버로딩이 가능합니다. 매개변수 개수나 타입이 다르면 여러 생성자를 정의할 수 있습니다."

**실무 연관**
- 실무에서는 Builder 패턴, Factory 패턴 등 다양한 객체 생성 방법을 사용합니다
- 생성자에서 유효성 검사를 하면 버그를 사전에 방지할 수 있습니다

</details>

<details>
<summary><strong>4. this 키워드는 언제 사용하나요?</strong></summary>

**모범 답안 포인트**
- 현재 객체를 가리킴
- 필드와 매개변수 구분
- 다른 생성자 호출

**예시 답변**
> "`this`는 현재 객체 자신을 가리키는 키워드입니다.
>
> 주로 세 가지 상황에서 사용합니다.
> 첫째, 필드와 매개변수 이름이 같을 때 구분하기 위해 사용합니다. `this.name = name;`에서 `this.name`은 필드이고 `name`은 매개변수입니다.
> 둘째, 같은 클래스의 다른 생성자를 호출할 때 사용합니다. `this(name, 0);` 같은 형태입니다.
> 셋째, 메서드 체이닝을 위해 자기 자신을 반환할 때 `return this;`로 사용합니다."

**꼬리 질문**
- Q: this를 생략할 수 있나요?
- A: "필드와 매개변수 이름이 다르면 생략 가능하지만, 명확성을 위해 붙이는 것을 권장합니다."

**실무 연관**
- 현대적인 Java 코딩 스타일에서는 this를 명시적으로 사용합니다
- IDE가 this 사용을 권장합니다

</details>

<details>
<summary><strong>5. 객체를 메서드의 매개변수로 전달할 수 있나요?</strong></summary>

**모범 답안 포인트**
- 가능함
- 참조 전달 (Pass by Reference)
- 실무 활용 예시

**예시 답변**
> "네, 가능합니다. Java에서는 객체를 메서드의 매개변수로 전달할 수 있습니다.
>
> Java는 객체를 전달할 때 '참조를 전달'합니다. 즉, 객체의 주소값이 전달되므로 메서드 내에서 객체를 수정하면 원본 객체도 변경됩니다.
>
> 예를 들어:
> ```java
> void updateStudent(Student s) {
>     s.age = 21;  // 원본 객체의 age가 변경됨
> }
>
> Student student = new Student();
> student.age = 20;
> updateStudent(student);  // student.age는 이제 21
> ```"

**꼬리 질문**
- Q: 배열로도 객체를 여러 개 전달할 수 있나요?
- A: "네, `Student[]` 같은 객체 배열을 매개변수로 전달할 수 있습니다."

**실무 연관**
- 실무에서는 DTO, VO 등의 객체를 메서드로 주고받습니다
- 서비스 계층에서 엔티티 객체를 전달하는 것이 일반적입니다

</details>

<details>
<summary><strong>6. NullPointerException은 왜 발생하나요?</strong></summary>

**모범 답안 포인트**
- null 객체에 접근할 때 발생
- 예방 방법
- 실무 대처법

**예시 답변**
> "`NullPointerException`은 null 상태의 참조 변수로 객체의 필드나 메서드에 접근하려고 할 때 발생합니다.
>
> 예를 들어:
> ```java
> Student student = null;
> student.name = "김철수";  // NullPointerException!
> ```
>
> 예방 방법은 두 가지입니다.
> 첫째, 객체를 사용하기 전에 null 체크를 합니다. `if (student != null)`
> 둘째, 객체를 선언할 때 반드시 초기화합니다. `Student student = new Student();`
>
> 실무에서는 Java 8의 Optional을 사용하거나, IDE의 @Nullable/@NotNull 어노테이션으로 null 안정성을 높입니다."

**꼬리 질문**
- Q: Optional이란 무엇인가요?
- A: "Optional은 null을 안전하게 다루기 위한 Wrapper 클래스입니다. `Optional.ofNullable(value)`로 생성하고 `isPresent()`로 확인할 수 있습니다."

**실무 연관**
- NullPointerException은 실무에서 가장 흔한 에러입니다
- 프로덕션 코드에서는 null 체크를 철저히 해야 합니다

</details>

<details>
<summary><strong>7. 여러 개의 생성자를 만드는 이유는 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 생성자 오버로딩
- 다양한 초기화 방법 제공
- 유연성 향상

**예시 답변**
> "생성자 오버로딩을 통해 객체를 다양한 방법으로 초기화할 수 있도록 하기 위해서입니다.
>
> 예를 들어, Student 클래스에서:
> ```java
> Student() { ... }                    // 기본 생성자
> Student(String name) { ... }         // 이름만으로 생성
> Student(String name, int age) { ... } // 이름과 나이로 생성
> ```
>
> 이렇게 하면 사용자가 상황에 따라 적절한 생성자를 선택할 수 있어 편리합니다.
>
> 또한 `this()`를 사용해 한 생성자에서 다른 생성자를 호출하면 코드 중복을 줄일 수 있습니다."

**꼬리 질문**
- Q: 생성자가 없으면 어떻게 되나요?
- A: "컴파일러가 자동으로 기본 생성자(매개변수 없는 생성자)를 만들어줍니다. 하지만 다른 생성자를 하나라도 정의하면 기본 생성자는 자동 생성되지 않습니다."

**실무 연관**
- 실무에서는 Builder 패턴으로 복잡한 객체 생성을 간편하게 합니다
- Lombok의 @AllArgsConstructor, @NoArgsConstructor로 생성자를 자동 생성합니다

</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. 객체지향의 4대 특징 중 캡슐화와 클래스의 관계를 설명해주세요</strong></summary>

**모범 답안 포인트**
- 캡슐화의 정의
- 접근 제어자 활용
- 정보 은닉

**예시 답변**
> "캡슐화는 데이터(필드)와 그 데이터를 다루는 메서드를 하나의 단위로 묶고, 외부로부터 숨기는 것입니다.
>
> 클래스는 캡슐화를 구현하는 핵심 도구입니다. `private` 접근 제어자로 필드를 숨기고, `public` getter/setter로 제한된 접근만 허용합니다.
>
> ```java
> class BankAccount {
>     private long balance;  // 외부 직접 접근 불가
>
>     public void deposit(long amount) {
>         if (amount > 0) {  // 유효성 검사
>             balance += amount;
>         }
>     }
>
>     public long getBalance() {
>         return balance;  // 읽기만 허용
>     }
> }
> ```
>
> 이렇게 하면 외부에서 balance를 직접 수정할 수 없고, deposit 메서드를 통해서만 안전하게 변경할 수 있습니다."

**실무 예시**
```java
// ✅ 좋은 캡슐화
class User {
    private String password;  // 외부 접근 차단

    public void setPassword(String newPassword) {
        if (newPassword.length() < 8) {
            throw new IllegalArgumentException("비밀번호는 8자 이상");
        }
        this.password = encrypt(newPassword);  // 암호화
    }

    private String encrypt(String text) {
        // 암호화 로직
        return "encrypted_" + text;
    }
}
```

**꼬리 질문**
- Q: getter/setter를 무조건 만들어야 하나요?
- A: "아닙니다. 필요한 경우에만 만들어야 합니다. 모든 필드에 getter/setter를 만들면 캡슐화의 의미가 없어집니다. 불변 객체의 경우 setter를 아예 만들지 않는 것이 좋습니다."

**실무 연관**
- 실무에서는 DTO에는 getter/setter를 만들지만, 도메인 객체에는 비즈니스 메서드만 노출합니다
- Spring의 @Getter/@Setter Lombok 어노테이션을 활용합니다

</details>

<details>
<summary><strong>2. 클래스 설계 시 SOLID 원칙 중 단일 책임 원칙을 어떻게 적용하나요?</strong></summary>

**모범 답안 포인트**
- SRP(Single Responsibility Principle) 정의
- 변경 이유가 하나여야 함
- 실무 적용 사례

**예시 답변**
> "단일 책임 원칙(SRP)은 '한 클래스는 하나의 책임만 가져야 한다'는 원칙입니다. 더 정확히는 '변경의 이유가 하나여야 한다'는 의미입니다.
>
> 나쁜 예:
> ```java
> // ❌ SRP 위반: User 클래스가 너무 많은 책임
> class User {
>     String name;
>     String email;
>
>     void saveToDatabase() { ... }      // DB 책임
>     void sendEmail() { ... }           // 이메일 책임
>     void generateReport() { ... }      // 리포트 책임
>     void validateInput() { ... }       // 검증 책임
> }
> ```
>
> 좋은 예:
> ```java
> // ✅ SRP 준수: 책임 분리
> class User {
>     String name;
>     String email;
> }
>
> class UserRepository {
>     void save(User user) { ... }  // DB 책임만
> }
>
> class EmailService {
>     void send(User user) { ... }  // 이메일 책임만
> }
>
> class UserValidator {
>     boolean validate(User user) { ... }  // 검증 책임만
> }
> ```"

**실무 예시**
- Spring에서 Controller, Service, Repository 계층 분리
- 각 클래스가 명확한 역할 하나만 수행

**꼬리 질문**
- Q: 책임을 어떻게 구분하나요?
- A: "클래스가 변경되어야 하는 이유를 생각해보면 됩니다. 'DB 구조가 바뀌면', '이메일 발송 방식이 바뀌면' 등 여러 이유가 있다면 책임이 과도한 것입니다."

**실무 연관**
- 마이크로서비스 아키텍처에서 서비스 분리의 기준이 됩니다
- 테스트 작성이 쉬워지고 유지보수가 용이해집니다

</details>

<details>
<summary><strong>3. 불변 객체(Immutable Object)란 무엇이고 왜 사용하나요?</strong></summary>

**모범 답안 포인트**
- 불변 객체의 정의
- 장점 (Thread-safe, 예측 가능)
- 구현 방법

**예시 답변**
> "불변 객체는 생성 후 상태를 변경할 수 없는 객체입니다. 한 번 만들어지면 필드 값을 절대 바꿀 수 없습니다.
>
> 구현 방법:
> ```java
> public final class ImmutableUser {
>     private final String name;  // final로 선언
>     private final int age;
>
>     public ImmutableUser(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
>
>     // getter만 제공, setter 없음
>     public String getName() { return name; }
>     public int getAge() { return age; }
>
>     // 값을 바꾸려면 새 객체를 생성
>     public ImmutableUser withAge(int newAge) {
>         return new ImmutableUser(this.name, newAge);
>     }
> }
> ```
>
> 장점:
> 1. **Thread-safe**: 여러 스레드가 동시에 접근해도 안전
> 2. **예측 가능**: 상태가 변하지 않아 버그가 적음
> 3. **Hash 키로 안전**: HashMap의 키로 사용 가능
> 4. **방어적 복사 불필요**: 참조를 그대로 공유해도 안전"

**실무 예시**
```java
// Java의 대표적인 불변 객체
String str = "Hello";  // String은 불변
str.toUpperCase();     // 새 객체 반환, 원본 불변

// LocalDate도 불변
LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plusDays(1);  // 새 객체 생성
```

**꼬리 질문**
- Q: 불변 객체의 단점은 무엇인가요?
- A: "값을 변경할 때마다 새 객체를 생성하므로 메모리 사용량이 증가할 수 있습니다. 하지만 대부분의 경우 이 단점보다 Thread-safe 장점이 더 큽니다."

**실무 연관**
- DTO, VO를 불변으로 만들면 안전합니다
- Functional Programming 패러다임에서 필수입니다

</details>

<details>
<summary><strong>4. 객체 생성 비용이 높을 때 어떤 패턴을 사용할 수 있나요?</strong></summary>

**모범 답안 포인트**
- 싱글톤 패턴
- 객체 풀링
- 프로토타입 패턴

**예시 답변**
> "객체 생성 비용이 높을 때 사용할 수 있는 패턴은 크게 세 가지입니다.
>
> **1. 싱글톤 패턴**: 객체를 1개만 생성해서 재사용
> ```java
> class DatabaseConnection {
>     private static DatabaseConnection instance;
>
>     private DatabaseConnection() {}  // private 생성자
>
>     public static DatabaseConnection getInstance() {
>         if (instance == null) {
>             instance = new DatabaseConnection();
>         }
>         return instance;
>     }
> }
> ```
>
> **2. 객체 풀링**: 미리 객체를 여러 개 만들어두고 재사용
> ```java
> class ConnectionPool {
>     private Queue<Connection> pool = new LinkedList<>();
>
>     public ConnectionPool(int size) {
>         for (int i = 0; i < size; i++) {
>             pool.add(new Connection());  // 미리 생성
>         }
>     }
>
>     public Connection getConnection() {
>         return pool.poll();  // 꺼내 쓰기
>     }
>
>     public void returnConnection(Connection conn) {
>         pool.offer(conn);  // 반납
>     }
> }
> ```
>
> **3. 프로토타입 패턴**: 기존 객체를 복제해서 사용
> ```java
> class Document implements Cloneable {
>     String content;
>
>     @Override
>     public Document clone() {
>         try {
>             return (Document) super.clone();
>         } catch (CloneNotSupportedException e) {
>             return null;
>         }
>     }
> }
> ```"

**실무 예시**
- 데이터베이스 커넥션 풀 (HikariCP, Apache Commons DBCP)
- 스레드 풀 (ExecutorService)
- 문자열 상수 풀 (String Pool)

**꼬리 질문**
- Q: 싱글톤 패턴의 문제점은?
- A: "멀티스레드 환경에서 동기화 문제, 테스트 어려움, 전역 상태로 인한 결합도 증가 등이 있습니다. 실무에서는 Spring의 DI 컨테이너를 사용해 해결합니다."

**실무 연관**
- Spring Bean은 기본적으로 싱글톤 스코프입니다
- 성능 최적화에 필수적인 기법입니다

</details>

<details>
<summary><strong>5. 클래스 간 결합도를 낮추는 방법은 무엇인가요?</strong></summary>

**모범 답안 포인트**
- 인터페이스 활용
- 의존성 주입
- 추상화

**예시 답변**
> "클래스 간 결합도를 낮추는 방법은 크게 세 가지입니다.
>
> **1. 인터페이스 활용**
> ```java
> // ❌ 높은 결합도: 구체 클래스에 의존
> class UserService {
>     private MySQLRepository repo = new MySQLRepository();
> }
>
> // ✅ 낮은 결합도: 인터페이스에 의존
> interface Repository {
>     void save(User user);
> }
>
> class UserService {
>     private Repository repo;  // 인터페이스 의존
>
>     public UserService(Repository repo) {
>         this.repo = repo;  // 주입받음
>     }
> }
> ```
>
> **2. 의존성 주입(DI)**
> - 객체를 직접 생성하지 않고 외부에서 주입받음
> - Spring의 @Autowired가 대표적
>
> **3. 이벤트 기반 아키텍처**
> ```java
> // 직접 호출 대신 이벤트 발행
> class OrderService {
>     public void createOrder(Order order) {
>         // 주문 생성
>         eventPublisher.publish(new OrderCreatedEvent(order));
>     }
> }
>
> class EmailService {
>     @EventListener
>     public void onOrderCreated(OrderCreatedEvent event) {
>         // 이메일 전송
>     }
> }
> ```"

**실무 예시**
```java
// Spring에서의 의존성 주입
@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired  // 생성자 주입
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

**꼬리 질문**
- Q: 결합도가 낮으면 어떤 장점이 있나요?
- A: "테스트가 쉬워지고, 코드 변경 시 영향 범위가 줄어들며, 재사용성이 높아집니다. 예를 들어 MySQL에서 MongoDB로 교체할 때 UserService는 수정할 필요가 없습니다."

**실무 연관**
- 마이크로서비스 아키텍처의 핵심 원칙입니다
- TDD(Test-Driven Development)를 위한 필수 조건입니다

</details>

---

## 📝 핵심 정리

### 이 장에서 배운 핵심 개념

| 개념 | 설명 | 핵심 키워드 |
|------|------|-------------|
| 클래스 | 객체를 만들기 위한 설계도 | class, 틀, 레시피 |
| 객체 | 클래스로 만든 실체 | new, 인스턴스, Heap |
| 필드 | 객체의 속성/데이터 | 변수, 상태, 데이터 |
| 메서드 | 객체의 동작/기능 | 함수, 행위, 기능 |
| 생성자 | 객체를 초기화하는 특별한 메서드 | Constructor, 초기화 |
| this | 현재 객체 자신을 가리키는 키워드 | 자기참조, 구분 |
| new | 객체를 생성하는 연산자 | 할당, 생성, 주소 |
| 캡슐화 | 데이터와 메서드를 묶고 숨김 | private, getter/setter |

### 필수 명령어/코드 정리

| 명령어/코드 | 용도 | 예시 |
|-------------|------|------|
| `class 클래스명 { }` | 클래스 정의 | `class Student { }` |
| `new 클래스명()` | 객체 생성 | `new Student()` |
| `클래스명 변수 = new 클래스명()` | 객체 생성 및 할당 | `Student s = new Student()` |
| `this.필드명` | 필드 접근 | `this.name = "김철수"` |
| `객체.필드명` | 필드 접근 | `student.name` |
| `객체.메서드명()` | 메서드 호출 | `student.study()` |
| `클래스명(매개변수) { }` | 생성자 정의 | `Student(String name) { }` |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] **명확한 클래스명 사용** (명사, 단수형)
- [ ] **필드는 private, 메서드는 public** (캡슐화)
- [ ] **생성자에서 필수 값 요구**
- [ ] **this 키워드 명시적 사용**
- [ ] **불변 객체 선호** (final 필드)
- [ ] **한 클래스는 하나의 책임** (SRP)
- [ ] **의미 있는 메서드명** (동사로 시작)

#### ❌ 하지 말아야 할 것
- [ ] **God Class 만들기** (모든 기능을 한 클래스에)
- [ ] **모든 필드를 public으로** (캡슐화 위반)
- [ ] **null 체크 생략**
- [ ] **생성자에서 복잡한 로직 수행**
- [ ] **필드를 직접 수정** (setter 없이)
- [ ] **의미 없는 변수명** (a, b, c 등)

### 성능/보안 체크리스트

#### 성능
- [ ] **불필요한 객체 생성 최소화** (루프 안에서 new 주의)
- [ ] **불변 객체 재사용** (String pool 활용)
- [ ] **무거운 객체는 싱글톤/풀링** (DB 연결 등)
- [ ] **final 키워드 적극 활용** (JVM 최적화)

#### 보안
- [ ] **민감 정보는 private으로** (비밀번호, 개인정보)
- [ ] **생성자에서 유효성 검사**
- [ ] **방어적 복사** (가변 객체 반환 시)
- [ ] **불변 객체 사용** (Thread-safe)

### 메모리 관리

```
객체 생성 시 메모리 흐름

1. new Student() 호출
   ↓
2. Method Area에서 Student.class 정보 확인
   ↓
3. Heap에 메모리 할당 (필드 크기 계산)
   ↓
4. 생성자 호출하여 초기화
   ↓
5. Heap 주소를 Stack의 참조 변수에 저장
   ↓
6. 사용 완료 후 참조 끊김
   ↓
7. GC(Garbage Collector)가 Heap 메모리 회수
```

**메모리 누수 방지**:
```java
// ✅ 좋은 예: 사용 후 참조 해제
Student student = new Student();
// ... 사용 ...
student = null;  // 참조 해제 (GC 대상)

// ❌ 나쁜 예: 무한히 객체 생성
List<Student> students = new ArrayList<>();
while (true) {
    students.add(new Student());  // 메모리 누수!
}
```

---

## 🔗 관련 기술

**이 기술과 함께 사용하는 기술들**

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| 상속 (Inheritance) | 클래스 간 관계 형성 | ⭐⭐⭐ (다음 장) |
| 다형성 (Polymorphism) | 객체의 다양한 형태 | ⭐⭐⭐ |
| 인터페이스 (Interface) | 추상화 및 다중 상속 | ⭐⭐⭐ |
| 추상 클래스 (Abstract Class) | 공통 기능 정의 | ⭐⭐⭐ |
| 컬렉션 (Collection) | 여러 객체 관리 | ⭐⭐⭐ |
| 예외 처리 (Exception) | 객체 사용 중 에러 처리 | ⭐⭐⭐ |
| 제네릭 (Generic) | 타입 안전성 | ⭐⭐ |
| 람다 (Lambda) | 함수형 프로그래밍 | ⭐⭐ |
| Stream API | 객체 컬렉션 처리 | ⭐⭐ |
| 디자인 패턴 | 객체 설계 방법론 | ⭐⭐ |

**학습 순서 추천**:
```
클래스와 객체 (현재) ✅
    ↓
상속과 다형성 (10장)
    ↓
인터페이스와 추상 클래스 (11장)
    ↓
컬렉션 프레임워크 (12장)
    ↓
예외 처리 (13장)
    ↓
제네릭과 람다 (14-15장)
```

---

## 🚀 다음 단계

### 다음 장 미리보기: 10장 상속 (Inheritance)

**배울 내용**:
- **상속의 개념**: 기존 클래스를 확장하여 새 클래스 만들기
- **extends 키워드**: 부모-자식 관계 형성
- **메서드 오버라이딩**: 부모 메서드를 자식이 재정의
- **super 키워드**: 부모 클래스 접근
- **다형성 기초**: 하나의 참조로 여러 객체 다루기

**실전 프로젝트**:
- 🎮 게임 캐릭터 시스템 (전사, 마법사, 궁수 상속)
- 🏦 은행 계좌 상속 (입출금 계좌, 예금 계좌, 적금 계좌)

### 이 장과의 연결점

```
09장: 클래스와 객체
    ↓
클래스를 만드는 방법을 배웠음
    ↓
10장: 상속
    ↓
기존 클래스를 확장하는 방법 배움
    ↓
최종적으로
    ↓
효율적인 코드 재사용 달성
```

### 준비하면 좋을 것들

```bash
# 09장 복습 - 클래스 설계 연습
# 다음 클래스들을 직접 설계해보세요

# 1. Animal 클래스
# - 필드: name, age, sound
# - 메서드: makeSound(), eat()

# 2. Vehicle 클래스
# - 필드: brand, model, year
# - 메서드: start(), stop(), info()

# 3. Employee 클래스
# - 필드: name, id, salary, department
# - 메서드: work(), getSalary(), promote()

# 이 클래스들을 10장에서 상속으로 확장합니다!
```

---

## 📚 추가 학습 자료

### 공식 문서
- [Oracle Java Documentation - Classes and Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/)
- [Oracle Java Tutorial - Object-Oriented Programming Concepts](https://docs.oracle.com/javase/tutorial/java/concepts/)
- [Java Language Specification](https://docs.oracle.com/javase/specs/)

### 추천 블로그/아티클
- [백기선님 - 자바 객체지향의 원리와 이해](https://github.com/whiteship/live-study)
- [우아한형제들 기술 블로그 - 객체지향 생활 체조](https://techblog.woowahan.com/)
- [마틴 파울러 - Refactoring](https://refactoring.com/)
- [조영호님 - 객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021)

### 영상 강의
- [인프런 - 김영한의 자바 입문](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8)
- [YouTube - 코딩애플 Java OOP](https://www.youtube.com/@codingapple)
- [YouTube - 생활코딩 Java Object](https://www.youtube.com/watch?v=CirYLIkzLZU)

### 도서
- **"Effective Java" (조슈아 블로크)** ⭐⭐⭐⭐⭐
  - 객체 생성과 파괴 (2장)
  - 클래스와 인터페이스 (4장)

- **"Head First Java" (케이시 시에라)** ⭐⭐⭐⭐
  - 객체지향 개념을 재미있게 설명

- **"클린 코드" (로버트 C. 마틴)** ⭐⭐⭐⭐⭐
  - 클래스 설계 원칙 (10장)

- **"객체지향의 사실과 오해" (조영호)** ⭐⭐⭐⭐
  - 객체지향 철학과 원리

### 컨퍼런스 발표
- [우아콘 2020 - 우아한객체지향](https://www.youtube.com/watch?v=dJ5C4qRqAgA)
- [NHN FORWARD - 객체지향 프로그래밍](https://forward.nhn.com/)

### 오픈소스 프로젝트
- [Spring Framework](https://github.com/spring-projects/spring-framework) - 우수한 클래스 설계 사례
- [Google Guava](https://github.com/google/guava) - 불변 객체 예제
- [Apache Commons](https://commons.apache.org/) - 유틸리티 클래스 참고

### 연습 문제 사이트
- [프로그래머스 - Java 연습문제](https://programmers.co.kr/learn/challenges)
- [백준 - 객체지향 문제](https://www.acmicpc.net/)
- [LeetCode - OOP Problems](https://leetcode.com/)

### 커뮤니티
- [OKKY - Java 게시판](https://okky.kr/articles/community?query=topic_code%3A3000)
- [Reddit - r/learnjava](https://www.reddit.com/r/learnjava/)
- [Stack Overflow - Java 태그](https://stackoverflow.com/questions/tagged/java)
- [자바 카페](https://cafe.naver.com/javachobostudy)

---

## 🎉 축하합니다!

**09장 클래스와 객체 완전 마스터!**

**이제 여러분은**:
✅ 클래스와 객체의 모든 개념을 완벽히 이해했습니다
✅ 실생활 비유로 누구에게나 설명할 수 있습니다
✅ 기본 클래스를 설계하고 구현할 수 있습니다
✅ 생성자와 this 키워드를 자유롭게 사용합니다
✅ 실무 사례와 패턴을 이해했습니다
✅ 주니어 개발자의 흔한 실수를 피할 수 있습니다
✅ 도서관 관리 시스템을 구현했습니다
✅ FAQ 7개 질문에 답할 수 있습니다
✅ 면접 질문 12개를 준비했습니다
✅ 캡슐화와 SOLID 원칙을 이해했습니다

**다음 단계**:
- [ ] 09장 실전 프로젝트 복습하기
- [ ] 자신만의 클래스 설계해보기
- [ ] 면접 질문 답변 연습하기
- [ ] 10장 "상속"으로 진행하기

---

## 💬 학습 후 체크리스트

### 기초 개념 (09-1장)
- [ ] 클래스와 객체의 차이를 설명할 수 있다
- [ ] 5가지 실생활 비유를 이해했다
- [ ] new 키워드의 동작 원리를 안다
- [ ] 생성자의 역할을 이해했다
- [ ] this 키워드를 올바르게 사용할 수 있다
- [ ] 도서관 관리 시스템을 구현했다

### 심화 개념 (09-2장)
- [ ] FAQ 7개 질문에 답할 수 있다
- [ ] 주니어 면접 질문 7개를 준비했다
- [ ] 중급 면접 질문 5개를 이해했다
- [ ] 캡슐화를 코드로 구현할 수 있다
- [ ] 단일 책임 원칙을 적용할 수 있다
- [ ] 불변 객체를 만들 수 있다

### 실무 역량
- [ ] 클래스를 설계할 때 SRP를 고려한다
- [ ] private/public을 적절히 사용한다
- [ ] null 체크를 습관화했다
- [ ] 의미 있는 이름을 사용한다
- [ ] 생성자에서 유효성 검사를 한다

---

**💪 "객체지향의 첫 걸음을 완벽히 마스터했습니다!"**

**📖 다음 장에서 만나요!**

[← 이전: 09-1장 기초편](09-1-클래스와-객체-기초편.md) | [다음: 10장 상속 →](10-상속.md)

[📚 전체 목차로 돌아가기](README.md)

---

**🌟 Java 마스터의 길, 계속 전진하세요! 🚀**

*"The best way to learn is by doing." - Richard Branson*