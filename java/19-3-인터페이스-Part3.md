# 19-3. ì¸í„°í˜ì´ìŠ¤ Part 3: ì‹¤ì „ í”„ë¡œì íŠ¸, FAQ, ë©´ì ‘ ì§ˆë¬¸

## ğŸš€ ì‹¤ì „ í”„ë¡œì íŠ¸: í”ŒëŸ¬ê·¸ì¸ ê¸°ë°˜ ì•Œë¦¼ ì‹œìŠ¤í…œ

ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ í™œìš©í•˜ì—¬ **í™•ì¥ ê°€ëŠ¥í•œ ì•Œë¦¼ ì‹œìŠ¤í…œ**ì„ êµ¬ì¶•í•˜ê² ìŠµë‹ˆë‹¤. ì´ ì‹œìŠ¤í…œì€ ë‹¤ì–‘í•œ ì•Œë¦¼ ì±„ë„(ì´ë©”ì¼, SMS, í‘¸ì‹œ, ìŠ¬ë™ ë“±)ì„ í”ŒëŸ¬ê·¸ì¸ ë°©ì‹ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆìœ¼ë©°, ì‹¤ë¬´ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ë””ìì¸ íŒ¨í„´ì„ ì ìš©í•©ë‹ˆë‹¤.

### ğŸ“‹ í”„ë¡œì íŠ¸ ìš”êµ¬ì‚¬í•­

1. **ë‹¤ì–‘í•œ ì•Œë¦¼ ì±„ë„ ì§€ì›**
   - ì´ë©”ì¼, SMS, í‘¸ì‹œ ì•Œë¦¼, ìŠ¬ë™ ë©”ì‹œì§€ ë“±
   - ìƒˆë¡œìš´ ì±„ë„ì„ ì½”ë“œ ìˆ˜ì • ì—†ì´ ì¶”ê°€ ê°€ëŠ¥

2. **ì•Œë¦¼ ìš°ì„ ìˆœìœ„ ë° íƒ€ì…**
   - ê¸´ê¸‰(URGENT), ì¤‘ìš”(HIGH), ì¼ë°˜(NORMAL), ì •ë³´(LOW)
   - íƒ€ì…ë³„ ë‹¤ë¥¸ ì „ì†¡ ì „ëµ

3. **í…œí”Œë¦¿ ì‹œìŠ¤í…œ**
   - ì•Œë¦¼ ë‚´ìš©ì„ í…œí”Œë¦¿ìœ¼ë¡œ ê´€ë¦¬
   - ë³€ìˆ˜ ì¹˜í™˜ ê¸°ëŠ¥

4. **ì „ì†¡ ì´ë ¥ ê´€ë¦¬**
   - ì „ì†¡ ì„±ê³µ/ì‹¤íŒ¨ ê¸°ë¡
   - ì¬ì „ì†¡ ê¸°ëŠ¥

5. **í•„í„°ë§ ë° ë¼ìš°íŒ…**
   - ì¡°ê±´ì— ë”°ë¼ ì ì ˆí•œ ì±„ë„ ì„ íƒ
   - ë³µìˆ˜ ì±„ë„ ë™ì‹œ ì „ì†¡

### ğŸ’» í”„ë¡œì íŠ¸ êµ¬í˜„

```java
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

/**
 * ============================================
 * 1ë‹¨ê³„: í•µì‹¬ ì¸í„°í˜ì´ìŠ¤ ì •ì˜
 * ============================================
 */

/**
 * ì•Œë¦¼ ì±„ë„ ì¸í„°í˜ì´ìŠ¤ - ëª¨ë“  ì•Œë¦¼ ì±„ë„ì´ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ê³„ì•½
 */
interface NotificationChannel {
    /**
     * ì•Œë¦¼ ì „ì†¡
     * @return ì „ì†¡ ì„±ê³µ ì—¬ë¶€
     */
    boolean send(Notification notification);

    /**
     * ì±„ë„ ì´ë¦„
     */
    String getChannelName();

    /**
     * ì±„ë„ì´ í•´ë‹¹ ì•Œë¦¼ íƒ€ì…ì„ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸
     */
    boolean supports(NotificationType type);

    /**
     * ì±„ë„ í™œì„±í™” ìƒíƒœ
     */
    boolean isEnabled();

    /**
     * ì „ì†¡ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ (rate limit ë“±)
     */
    boolean canSend();
}

/**
 * í…œí”Œë¦¿ ì—”ì§„ ì¸í„°í˜ì´ìŠ¤
 */
interface TemplateEngine {
    String render(String template, Map<String, Object> variables);
}

/**
 * ì•Œë¦¼ í•„í„° ì¸í„°í˜ì´ìŠ¤
 */
interface NotificationFilter {
    boolean shouldSend(Notification notification);
}

/**
 * ì „ì†¡ ì´ë ¥ ì €ì¥ì†Œ ì¸í„°í˜ì´ìŠ¤
 */
interface NotificationRepository {
    void save(NotificationRecord record);
    List<NotificationRecord> findByRecipient(String recipient);
    List<NotificationRecord> findByStatus(DeliveryStatus status);
}

/**
 * ì•Œë¦¼ ë¼ìš°í„° ì¸í„°í˜ì´ìŠ¤
 */
interface NotificationRouter {
    List<NotificationChannel> route(Notification notification);
}

/**
 * ============================================
 * 2ë‹¨ê³„: ë°ì´í„° ëª¨ë¸
 * ============================================
 */

/**
 * ì•Œë¦¼ íƒ€ì…
 */
enum NotificationType {
    URGENT,    // ê¸´ê¸‰
    HIGH,      // ì¤‘ìš”
    NORMAL,    // ì¼ë°˜
    LOW        // ì •ë³´
}

/**
 * ì „ì†¡ ìƒíƒœ
 */
enum DeliveryStatus {
    PENDING,   // ëŒ€ê¸°
    SENDING,   // ì „ì†¡ ì¤‘
    SUCCESS,   // ì„±ê³µ
    FAILED,    // ì‹¤íŒ¨
    RETRYING   // ì¬ì‹œë„ ì¤‘
}

/**
 * ì•Œë¦¼ ê°ì²´
 */
class Notification {
    private String id;
    private String recipient;
    private String title;
    private String message;
    private NotificationType type;
    private Map<String, Object> metadata;
    private LocalDateTime createdAt;

    public Notification(String recipient, String title, String message, NotificationType type) {
        this.id = UUID.randomUUID().toString();
        this.recipient = recipient;
        this.title = title;
        this.message = message;
        this.type = type;
        this.metadata = new HashMap<>();
        this.createdAt = LocalDateTime.now();
    }

    // Getters and Setters
    public String getId() { return id; }
    public String getRecipient() { return recipient; }
    public String getTitle() { return title; }
    public String getMessage() { return message; }
    public NotificationType getType() { return type; }
    public Map<String, Object> getMetadata() { return metadata; }
    public LocalDateTime getCreatedAt() { return createdAt; }

    public void addMetadata(String key, Object value) {
        metadata.put(key, value);
    }

    @Override
    public String toString() {
        return String.format("Notification[id=%s, type=%s, recipient=%s, title=%s]",
            id, type, recipient, title);
    }
}

/**
 * ì „ì†¡ ê¸°ë¡
 */
class NotificationRecord {
    private String notificationId;
    private String channelName;
    private DeliveryStatus status;
    private LocalDateTime sentAt;
    private String errorMessage;
    private int retryCount;

    public NotificationRecord(String notificationId, String channelName) {
        this.notificationId = notificationId;
        this.channelName = channelName;
        this.status = DeliveryStatus.PENDING;
        this.sentAt = LocalDateTime.now();
        this.retryCount = 0;
    }

    // Getters and Setters
    public String getNotificationId() { return notificationId; }
    public String getChannelName() { return channelName; }
    public DeliveryStatus getStatus() { return status; }
    public void setStatus(DeliveryStatus status) { this.status = status; }
    public LocalDateTime getSentAt() { return sentAt; }
    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    public int getRetryCount() { return retryCount; }
    public void incrementRetryCount() { this.retryCount++; }

    @Override
    public String toString() {
        return String.format("Record[channel=%s, status=%s, retries=%d]",
            channelName, status, retryCount);
    }
}

/**
 * ============================================
 * 3ë‹¨ê³„: ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ - ì•Œë¦¼ ì±„ë„ë“¤
 * ============================================
 */

/**
 * ì´ë©”ì¼ ì±„ë„
 */
class EmailChannel implements NotificationChannel {
    private boolean enabled = true;
    private int sentCount = 0;
    private static final int RATE_LIMIT = 100; // ì‹œê°„ë‹¹ 100ê°œ ì œí•œ

    @Override
    public boolean send(Notification notification) {
        System.out.println("\nğŸ“§ [Email] ì „ì†¡ ì¤‘...");
        System.out.println("  To: " + notification.getRecipient());
        System.out.println("  Subject: " + notification.getTitle());
        System.out.println("  Body: " + notification.getMessage());

        // ì „ì†¡ ì‹œë®¬ë ˆì´ì…˜
        try {
            Thread.sleep(100);
            sentCount++;
            System.out.println("  âœ“ ì´ë©”ì¼ ì „ì†¡ ì„±ê³µ");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  âœ— ì´ë©”ì¼ ì „ì†¡ ì‹¤íŒ¨");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Email";
    }

    @Override
    public boolean supports(NotificationType type) {
        // ì´ë©”ì¼ì€ ëª¨ë“  íƒ€ì… ì§€ì›
        return true;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return sentCount < RATE_LIMIT;
    }
}

/**
 * SMS ì±„ë„
 */
class SmsChannel implements NotificationChannel {
    private boolean enabled = true;

    @Override
    public boolean send(Notification notification) {
        System.out.println("\nğŸ“± [SMS] ì „ì†¡ ì¤‘...");
        System.out.println("  To: " + notification.getRecipient());
        System.out.println("  Message: " + notification.getMessage());

        try {
            Thread.sleep(50);
            System.out.println("  âœ“ SMS ì „ì†¡ ì„±ê³µ");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  âœ— SMS ì „ì†¡ ì‹¤íŒ¨");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "SMS";
    }

    @Override
    public boolean supports(NotificationType type) {
        // SMSëŠ” ê¸´ê¸‰, ì¤‘ìš” ì•Œë¦¼ë§Œ ì§€ì› (ë¹„ìš© ë•Œë¬¸ì—)
        return type == NotificationType.URGENT || type == NotificationType.HIGH;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * í‘¸ì‹œ ì•Œë¦¼ ì±„ë„
 */
class PushChannel implements NotificationChannel {
    private boolean enabled = true;

    @Override
    public boolean send(Notification notification) {
        System.out.println("\nğŸ”” [Push] ì „ì†¡ ì¤‘...");
        System.out.println("  Device: " + notification.getRecipient());
        System.out.println("  Title: " + notification.getTitle());
        System.out.println("  Body: " + notification.getMessage());

        try {
            Thread.sleep(30);
            System.out.println("  âœ“ í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  âœ— í‘¸ì‹œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Push";
    }

    @Override
    public boolean supports(NotificationType type) {
        // í‘¸ì‹œëŠ” ê¸´ê¸‰, ì¤‘ìš”, ì¼ë°˜ë§Œ ì§€ì› (ì •ë³´ì„± ì œì™¸)
        return type != NotificationType.LOW;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * ìŠ¬ë™ ì±„ë„
 */
class SlackChannel implements NotificationChannel {
    private boolean enabled = true;
    private String webhookUrl;

    public SlackChannel(String webhookUrl) {
        this.webhookUrl = webhookUrl;
    }

    @Override
    public boolean send(Notification notification) {
        System.out.println("\nğŸ’¬ [Slack] ì „ì†¡ ì¤‘...");
        System.out.println("  Webhook: " + webhookUrl);
        System.out.println("  Channel: " + notification.getRecipient());
        System.out.println("  Message: " + notification.getTitle());

        try {
            Thread.sleep(40);
            System.out.println("  âœ“ ìŠ¬ë™ ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ");
            return true;
        } catch (InterruptedException e) {
            System.out.println("  âœ— ìŠ¬ë™ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨");
            return false;
        }
    }

    @Override
    public String getChannelName() {
        return "Slack";
    }

    @Override
    public boolean supports(NotificationType type) {
        // ìŠ¬ë™ì€ ì¤‘ìš” ì´ìƒë§Œ
        return type == NotificationType.URGENT || type == NotificationType.HIGH;
    }

    @Override
    public boolean isEnabled() {
        return enabled;
    }

    @Override
    public boolean canSend() {
        return true;
    }
}

/**
 * ============================================
 * 4ë‹¨ê³„: í…œí”Œë¦¿ ì—”ì§„ êµ¬í˜„
 * ============================================
 */

/**
 * ê°„ë‹¨í•œ í…œí”Œë¦¿ ì—”ì§„ êµ¬í˜„
 */
class SimpleTemplateEngine implements TemplateEngine {

    @Override
    public String render(String template, Map<String, Object> variables) {
        String result = template;

        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            String placeholder = "{{" + entry.getKey() + "}}";
            result = result.replace(placeholder, entry.getValue().toString());
        }

        return result;
    }
}

/**
 * ============================================
 * 5ë‹¨ê³„: í•„í„° êµ¬í˜„
 * ============================================
 */

/**
 * ì‹œê°„ëŒ€ í•„í„° - ì•¼ê°„ì—ëŠ” ê¸´ê¸‰ ì•Œë¦¼ë§Œ
 */
class TimeBasedFilter implements NotificationFilter {

    @Override
    public boolean shouldSend(Notification notification) {
        LocalTime now = LocalTime.now();
        boolean isNightTime = now.isAfter(LocalTime.of(22, 0)) || now.isBefore(LocalTime.of(8, 0));

        if (isNightTime && notification.getType() != NotificationType.URGENT) {
            System.out.println("  [Filter] ì•¼ê°„ ì‹œê°„ëŒ€: ê¸´ê¸‰ ì•Œë¦¼ë§Œ í—ˆìš©");
            return false;
        }

        return true;
    }
}

/**
 * ì¤‘ë³µ ë°©ì§€ í•„í„°
 */
class DuplicateFilter implements NotificationFilter {
    private Set<String> recentNotifications = new HashSet<>();
    private Map<String, LocalDateTime> sentTimes = new HashMap<>();
    private static final Duration COOLDOWN = Duration.ofMinutes(5);

    @Override
    public boolean shouldSend(Notification notification) {
        String key = notification.getRecipient() + ":" + notification.getTitle();

        if (sentTimes.containsKey(key)) {
            LocalDateTime lastSent = sentTimes.get(key);
            if (Duration.between(lastSent, LocalDateTime.now()).compareTo(COOLDOWN) < 0) {
                System.out.println("  [Filter] ì¤‘ë³µ ì•Œë¦¼ ì°¨ë‹¨: 5ë¶„ ì´ë‚´ ë™ì¼ ì•Œë¦¼");
                return false;
            }
        }

        sentTimes.put(key, LocalDateTime.now());
        return true;
    }
}

/**
 * ============================================
 * 6ë‹¨ê³„: ë¼ìš°í„° êµ¬í˜„
 * ============================================
 */

/**
 * ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë¼ìš°í„°
 */
class PriorityBasedRouter implements NotificationRouter {
    private List<NotificationChannel> channels;

    public PriorityBasedRouter(List<NotificationChannel> channels) {
        this.channels = channels;
    }

    @Override
    public List<NotificationChannel> route(Notification notification) {
        List<NotificationChannel> selectedChannels = new ArrayList<>();

        switch (notification.getType()) {
            case URGENT:
                // ê¸´ê¸‰: ëª¨ë“  ì±„ë„ ì‚¬ìš©
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled() && ch.canSend())
                    .collect(Collectors.toList());
                System.out.println("  [Router] ê¸´ê¸‰ ì•Œë¦¼ â†’ ëª¨ë“  ì±„ë„ ì‚¬ìš©");
                break;

            case HIGH:
                // ì¤‘ìš”: í‘¸ì‹œ + ì´ë©”ì¼
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Push") || ch.getChannelName().equals("Email"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] ì¤‘ìš” ì•Œë¦¼ â†’ í‘¸ì‹œ + ì´ë©”ì¼");
                break;

            case NORMAL:
                // ì¼ë°˜: í‘¸ì‹œë§Œ
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Push"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] ì¼ë°˜ ì•Œë¦¼ â†’ í‘¸ì‹œ");
                break;

            case LOW:
                // ì •ë³´: ì´ë©”ì¼ë§Œ
                selectedChannels = channels.stream()
                    .filter(ch -> ch.supports(notification.getType()) && ch.isEnabled())
                    .filter(ch -> ch.getChannelName().equals("Email"))
                    .collect(Collectors.toList());
                System.out.println("  [Router] ì •ë³´ ì•Œë¦¼ â†’ ì´ë©”ì¼");
                break;
        }

        return selectedChannels;
    }
}

/**
 * ============================================
 * 7ë‹¨ê³„: ì €ì¥ì†Œ êµ¬í˜„
 * ============================================
 */

/**
 * ì¸ë©”ëª¨ë¦¬ ì €ì¥ì†Œ
 */
class InMemoryNotificationRepository implements NotificationRepository {
    private List<NotificationRecord> records = new ArrayList<>();

    @Override
    public void save(NotificationRecord record) {
        records.add(record);
    }

    @Override
    public List<NotificationRecord> findByRecipient(String recipient) {
        return records.stream()
            .filter(r -> r.getNotificationId().contains(recipient))
            .collect(Collectors.toList());
    }

    @Override
    public List<NotificationRecord> findByStatus(DeliveryStatus status) {
        return records.stream()
            .filter(r -> r.getStatus() == status)
            .collect(Collectors.toList());
    }

    public List<NotificationRecord> getAll() {
        return new ArrayList<>(records);
    }
}

/**
 * ============================================
 * 8ë‹¨ê³„: ì•Œë¦¼ ì„œë¹„ìŠ¤ (ëª¨ë“  ì»´í¬ë„ŒíŠ¸ í†µí•©)
 * ============================================
 */

/**
 * ì•Œë¦¼ ì„œë¹„ìŠ¤ - ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì²´ë¥¼ ì¡°í•©í•˜ì—¬ ì‚¬ìš©
 */
class NotificationService {
    private List<NotificationChannel> channels;
    private NotificationRouter router;
    private List<NotificationFilter> filters;
    private NotificationRepository repository;
    private TemplateEngine templateEngine;

    public NotificationService(
        List<NotificationChannel> channels,
        NotificationRouter router,
        List<NotificationFilter> filters,
        NotificationRepository repository,
        TemplateEngine templateEngine
    ) {
        this.channels = channels;
        this.router = router;
        this.filters = filters;
        this.repository = repository;
        this.templateEngine = templateEngine;
    }

    /**
     * ì•Œë¦¼ ì „ì†¡
     */
    public void send(Notification notification) {
        System.out.println("\n" + "=".repeat(60));
        System.out.println("ğŸ“¨ ì•Œë¦¼ ì „ì†¡ ì‹œì‘: " + notification);
        System.out.println("=".repeat(60));

        // 1. í•„í„°ë§
        for (NotificationFilter filter : filters) {
            if (!filter.shouldSend(notification)) {
                System.out.println("  âš ï¸  í•„í„°ì— ì˜í•´ ì°¨ë‹¨ë¨");
                return;
            }
        }

        // 2. ë¼ìš°íŒ…
        List<NotificationChannel> selectedChannels = router.route(notification);

        if (selectedChannels.isEmpty()) {
            System.out.println("  âš ï¸  ì‚¬ìš© ê°€ëŠ¥í•œ ì±„ë„ ì—†ìŒ");
            return;
        }

        // 3. ê° ì±„ë„ë¡œ ì „ì†¡
        for (NotificationChannel channel : selectedChannels) {
            NotificationRecord record = new NotificationRecord(
                notification.getId(),
                channel.getChannelName()
            );

            record.setStatus(DeliveryStatus.SENDING);

            boolean success = channel.send(notification);

            if (success) {
                record.setStatus(DeliveryStatus.SUCCESS);
            } else {
                record.setStatus(DeliveryStatus.FAILED);
                record.setErrorMessage("ì „ì†¡ ì‹¤íŒ¨");
            }

            repository.save(record);
        }

        System.out.println("\nâœ… ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ\n");
    }

    /**
     * í…œí”Œë¦¿ì„ ì‚¬ìš©í•œ ì•Œë¦¼ ì „ì†¡
     */
    public void sendWithTemplate(String recipient, String template, Map<String, Object> variables, NotificationType type) {
        String message = templateEngine.render(template, variables);
        Notification notification = new Notification(recipient, "ì•Œë¦¼", message, type);
        send(notification);
    }

    /**
     * ì „ì†¡ í†µê³„
     */
    public void printStatistics() {
        System.out.println("\n" + "=".repeat(60));
        System.out.println("ğŸ“Š ì „ì†¡ í†µê³„");
        System.out.println("=".repeat(60));

        if (repository instanceof InMemoryNotificationRepository) {
            InMemoryNotificationRepository repo = (InMemoryNotificationRepository) repository;
            List<NotificationRecord> allRecords = repo.getAll();

            Map<DeliveryStatus, Long> statusCount = allRecords.stream()
                .collect(Collectors.groupingBy(NotificationRecord::getStatus, Collectors.counting()));

            Map<String, Long> channelCount = allRecords.stream()
                .collect(Collectors.groupingBy(NotificationRecord::getChannelName, Collectors.counting()));

            System.out.println("\nìƒíƒœë³„ í†µê³„:");
            statusCount.forEach((status, count) ->
                System.out.println("  " + status + ": " + count + "ê±´"));

            System.out.println("\nì±„ë„ë³„ í†µê³„:");
            channelCount.forEach((channel, count) ->
                System.out.println("  " + channel + ": " + count + "ê±´"));

            System.out.println("\nì´ ì „ì†¡: " + allRecords.size() + "ê±´");
        }
    }
}

/**
 * ============================================
 * 9ë‹¨ê³„: í…ŒìŠ¤íŠ¸ ë° ì‹¤í–‰
 * ============================================
 */

/**
 * ì•Œë¦¼ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
 */
public class NotificationSystemTest {

    public static void main(String[] args) {

        System.out.println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        System.out.println("â•‘     í”ŒëŸ¬ê·¸ì¸ ê¸°ë°˜ ì•Œë¦¼ ì‹œìŠ¤í…œ - ì‹¤ì „ í”„ë¡œì íŠ¸          â•‘");
        System.out.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        // 1. ì•Œë¦¼ ì±„ë„ ìƒì„± (ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì²´ë“¤)
        List<NotificationChannel> channels = Arrays.asList(
            new EmailChannel(),
            new SmsChannel(),
            new PushChannel(),
            new SlackChannel("https://hooks.slack.com/services/YOUR/WEBHOOK/URL")
        );

        // 2. ë¼ìš°í„° ìƒì„±
        NotificationRouter router = new PriorityBasedRouter(channels);

        // 3. í•„í„° ìƒì„±
        List<NotificationFilter> filters = Arrays.asList(
            new TimeBasedFilter(),
            new DuplicateFilter()
        );

        // 4. ì €ì¥ì†Œ ìƒì„±
        NotificationRepository repository = new InMemoryNotificationRepository();

        // 5. í…œí”Œë¦¿ ì—”ì§„ ìƒì„±
        TemplateEngine templateEngine = new SimpleTemplateEngine();

        // 6. ì•Œë¦¼ ì„œë¹„ìŠ¤ ìƒì„± (ì˜ì¡´ì„± ì£¼ì…)
        NotificationService service = new NotificationService(
            channels, router, filters, repository, templateEngine
        );

        // ========================================
        // í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
        // ========================================

        // í…ŒìŠ¤íŠ¸ 1: ê¸´ê¸‰ ì•Œë¦¼
        test1_UrgentNotification(service);

        // í…ŒìŠ¤íŠ¸ 2: ì¤‘ìš” ì•Œë¦¼
        test2_HighPriorityNotification(service);

        // í…ŒìŠ¤íŠ¸ 3: ì¼ë°˜ ì•Œë¦¼
        test3_NormalNotification(service);

        // í…ŒìŠ¤íŠ¸ 4: ì •ë³´ ì•Œë¦¼
        test4_LowPriorityNotification(service);

        // í…ŒìŠ¤íŠ¸ 5: í…œí”Œë¦¿ ì‚¬ìš©
        test5_TemplateNotification(service, templateEngine);

        // í†µê³„ ì¶œë ¥
        service.printStatistics();

        // ìµœì¢… ìš”ì•½
        printSummary();
    }

    static void test1_UrgentNotification(NotificationService service) {
        System.out.println("\n\n### í…ŒìŠ¤íŠ¸ 1: ê¸´ê¸‰ ì•Œë¦¼ ###");
        Notification urgent = new Notification(
            "user@example.com",
            "ì‹œìŠ¤í…œ ì¥ì•  ë°œìƒ",
            "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì¦‰ì‹œ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.",
            NotificationType.URGENT
        );
        service.send(urgent);
    }

    static void test2_HighPriorityNotification(NotificationService service) {
        System.out.println("\n\n### í…ŒìŠ¤íŠ¸ 2: ì¤‘ìš” ì•Œë¦¼ ###");
        Notification high = new Notification(
            "admin@example.com",
            "ë³´ì•ˆ ê²½ê³ ",
            "ë¹„ì •ìƒì ì¸ ë¡œê·¸ì¸ ì‹œë„ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.",
            NotificationType.HIGH
        );
        service.send(high);
    }

    static void test3_NormalNotification(NotificationService service) {
        System.out.println("\n\n### í…ŒìŠ¤íŠ¸ 3: ì¼ë°˜ ì•Œë¦¼ ###");
        Notification normal = new Notification(
            "user@example.com",
            "ìƒˆ ë©”ì‹œì§€",
            "ì•ˆë…•í•˜ì„¸ìš”! ìƒˆë¡œìš´ ë©”ì‹œì§€ê°€ ë„ì°©í–ˆìŠµë‹ˆë‹¤.",
            NotificationType.NORMAL
        );
        service.send(normal);
    }

    static void test4_LowPriorityNotification(NotificationService service) {
        System.out.println("\n\n### í…ŒìŠ¤íŠ¸ 4: ì •ë³´ ì•Œë¦¼ ###");
        Notification low = new Notification(
            "user@example.com",
            "ì£¼ê°„ ë¦¬í¬íŠ¸",
            "ì´ë²ˆ ì£¼ í™œë™ ìš”ì•½ì„ í™•ì¸í•˜ì„¸ìš”.",
            NotificationType.LOW
        );
        service.send(low);
    }

    static void test5_TemplateNotification(NotificationService service, TemplateEngine templateEngine) {
        System.out.println("\n\n### í…ŒìŠ¤íŠ¸ 5: í…œí”Œë¦¿ ì•Œë¦¼ ###");

        String template = "ì•ˆë…•í•˜ì„¸ìš” {{name}}ë‹˜!\n" +
                          "ê·€í•˜ì˜ ì£¼ë¬¸ {{orderId}}ê°€ {{status}} ìƒíƒœì…ë‹ˆë‹¤.\n" +
                          "ì˜ˆìƒ ë°°ì†¡ì¼: {{deliveryDate}}";

        Map<String, Object> variables = new HashMap<>();
        variables.put("name", "í™ê¸¸ë™");
        variables.put("orderId", "ORD-12345");
        variables.put("status", "ë°°ì†¡ ì¤‘");
        variables.put("deliveryDate", "2024-01-20");

        service.sendWithTemplate(
            "customer@example.com",
            template,
            variables,
            NotificationType.NORMAL
        );
    }

    static void printSummary() {
        System.out.println("\n\n" + "=".repeat(60));
        System.out.println("ğŸ¯ í”„ë¡œì íŠ¸ í•µì‹¬ í¬ì¸íŠ¸");
        System.out.println("=".repeat(60));

        System.out.println("\nâœ… ì¸í„°í˜ì´ìŠ¤ í™œìš©:");
        System.out.println("  1. NotificationChannel - ë‹¤ì–‘í•œ ì•Œë¦¼ ì±„ë„ ì¶”ìƒí™”");
        System.out.println("  2. NotificationRouter - ë¼ìš°íŒ… ì „ëµ ë¶„ë¦¬");
        System.out.println("  3. NotificationFilter - í•„í„°ë§ ë¡œì§ ë¶„ë¦¬");
        System.out.println("  4. NotificationRepository - ì €ì¥ì†Œ ì¶”ìƒí™”");
        System.out.println("  5. TemplateEngine - í…œí”Œë¦¿ ì—”ì§„ ì¶”ìƒí™”");

        System.out.println("\nâœ… ë””ìì¸ íŒ¨í„´:");
        System.out.println("  1. Strategy Pattern - ì±„ë„ ì„ íƒ ì „ëµ");
        System.out.println("  2. Chain of Responsibility - í•„í„° ì²´ì¸");
        System.out.println("  3. Dependency Injection - ì˜ì¡´ì„± ì£¼ì…");
        System.out.println("  4. Repository Pattern - ë°ì´í„° ì•¡ì„¸ìŠ¤");
        System.out.println("  5. Template Method - í…œí”Œë¦¿ ì²˜ë¦¬");

        System.out.println("\nâœ… í™•ì¥ì„±:");
        System.out.println("  â€¢ ìƒˆë¡œìš´ ì±„ë„ ì¶”ê°€: NotificationChannel êµ¬í˜„ë§Œ ì¶”ê°€");
        System.out.println("  â€¢ ìƒˆë¡œìš´ í•„í„° ì¶”ê°€: NotificationFilter êµ¬í˜„ë§Œ ì¶”ê°€");
        System.out.println("  â€¢ ìƒˆë¡œìš´ ë¼ìš°íŒ… ì „ëµ: NotificationRouter êµ¬í˜„ êµì²´");
        System.out.println("  â€¢ ì½”ë“œ ìˆ˜ì • ì—†ì´ í”ŒëŸ¬ê·¸ì¸ ë°©ì‹ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥!");

        System.out.println("\nâœ… ì‹¤ë¬´ ì ìš©:");
        System.out.println("  â€¢ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ì˜ ì•Œë¦¼ ì„œë¹„ìŠ¤");
        System.out.println("  â€¢ ì´ì»¤ë¨¸ìŠ¤ ì£¼ë¬¸/ë°°ì†¡ ì•Œë¦¼");
        System.out.println("  â€¢ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì˜ ê²½ê³  ì•Œë¦¼");
        System.out.println("  â€¢ ì†Œì…œ ë¯¸ë””ì–´ ì•Œë¦¼ ì‹œìŠ¤í…œ");
    }
}
```

### ğŸ¯ í”„ë¡œì íŠ¸ í•™ìŠµ í¬ì¸íŠ¸

1. **ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ ì„¤ê³„ì˜ ì¥ì **
   - ìƒˆë¡œìš´ ì±„ë„ ì¶”ê°€ê°€ ë§¤ìš° ì‰¬ì›€ (OCP - Open/Closed Principle)
   - ê° ì»´í¬ë„ŒíŠ¸ê°€ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥
   - Mock ê°ì²´ë¡œ ì‰½ê²Œ ëŒ€ì²´ ê°€ëŠ¥

2. **ë‹¤ì¤‘ ì¸í„°í˜ì´ìŠ¤ í™œìš©**
   - ê° ê´€ì‹¬ì‚¬ë¥¼ ë³„ë„ ì¸í„°í˜ì´ìŠ¤ë¡œ ë¶„ë¦¬
   - ë‹¨ì¼ ì±…ì„ ì›ì¹™ ì¤€ìˆ˜

3. **ì˜ì¡´ì„± ì£¼ì…**
   - ìƒì„±ìë¥¼ í†µí•œ ì˜ì¡´ì„± ì£¼ì…
   - ëŠìŠ¨í•œ ê²°í•©ìœ¼ë¡œ ìœ ì—°í•œ êµ¬ì¡°

4. **í™•ì¥ ì‹œë‚˜ë¦¬ì˜¤**
   ```java
   // ìƒˆë¡œìš´ ì±„ë„ ì¶”ê°€ ì˜ˆ: ì¹´ì¹´ì˜¤í†¡
   class KakaoTalkChannel implements NotificationChannel {
       @Override
       public boolean send(Notification notification) {
           // ì¹´ì¹´ì˜¤í†¡ ì „ì†¡ ë¡œì§
           return true;
       }

       @Override
       public String getChannelName() {
           return "KakaoTalk";
       }

       @Override
       public boolean supports(NotificationType type) {
           return true;
       }

       @Override
       public boolean isEnabled() {
           return true;
       }

       @Override
       public boolean canSend() {
           return true;
       }
   }

   // ì‚¬ìš©: channels ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ë§Œ í•˜ë©´ ë¨!
   channels.add(new KakaoTalkChannel());
   ```

---

## â“ FAQ (ìì£¼ ë¬»ëŠ” ì§ˆë¬¸)

### Q1. ì¸í„°í˜ì´ìŠ¤ì™€ ì¶”ìƒ í´ë˜ìŠ¤ ì¤‘ ì–´ëŠ ê²ƒì„ ì„ íƒí•´ì•¼ í•˜ë‚˜ìš”?

**A:** ë‹¤ìŒ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨í•˜ì„¸ìš”:

**ì¸í„°í˜ì´ìŠ¤ ì„ íƒ:**
- ê´€ë ¨ ì—†ëŠ” í´ë˜ìŠ¤ë“¤ì´ ê°™ì€ í–‰ë™ì„ í•´ì•¼ í•  ë•Œ
- ë‹¤ì¤‘ ìƒì†(êµ¬í˜„)ì´ í•„ìš”í•  ë•Œ
- "can-do" ê´€ê³„ (ë‚  ìˆ˜ ìˆë‹¤, ìˆ˜ì˜í•  ìˆ˜ ìˆë‹¤)
- ê³µí†µ êµ¬í˜„ ì½”ë“œê°€ ì—†ê±°ë‚˜ ì ì„ ë•Œ

**ì¶”ìƒ í´ë˜ìŠ¤ ì„ íƒ:**
- ê´€ë ¨ëœ í´ë˜ìŠ¤ë“¤ ê°„ ì½”ë“œë¥¼ ê³µìœ í•˜ê³  ì‹¶ì„ ë•Œ
- ê³µí†µ í•„ë“œì™€ ë©”ì„œë“œê°€ ë§ì„ ë•Œ
- "is-a" ê´€ê³„ (ê°•ì•„ì§€ëŠ” ë™ë¬¼ì´ë‹¤)
- ìƒì„±ìë‚˜ ìƒíƒœê°€ í•„ìš”í•  ë•Œ

**ì‹¤ë¬´ íŒ:**
```java
// ì¢‹ì€ ì¡°í•©: ì¶”ìƒ í´ë˜ìŠ¤ + ì¸í„°í˜ì´ìŠ¤
abstract class Animal {
    protected String name; // ê³µí†µ í•„ë“œ

    public void sleep() { // ê³µí†µ êµ¬í˜„
        System.out.println(name + " is sleeping");
    }

    abstract void eat(); // ì„œë¸Œí´ë˜ìŠ¤ê°€ êµ¬í˜„
}

interface Flyable {
    void fly(); // ëŠ¥ë ¥ ì •ì˜
}

class Bird extends Animal implements Flyable {
    // Animalì˜ ê³µí†µ ê¸°ëŠ¥ + Flyable ëŠ¥ë ¥
}
```

---

### Q2. ì¸í„°í˜ì´ìŠ¤ì— default ë©”ì„œë“œë¥¼ ì–¸ì œ ì‚¬ìš©í•´ì•¼ í•˜ë‚˜ìš”?

**A:** default ë©”ì„œë“œëŠ” ë‹¤ìŒ ìƒí™©ì—ì„œ ìœ ìš©í•©ë‹ˆë‹¤:

1. **ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ì— ë©”ì„œë“œ ì¶”ê°€ (í•˜ìœ„ í˜¸í™˜ì„±)**
   ```java
   interface PaymentProcessor {
       boolean process(Payment payment);

       // ë‚˜ì¤‘ì— ì¶”ê°€ëœ ë©”ì„œë“œ - ê¸°ì¡´ êµ¬í˜„ì²´ë¥¼ ê¹¨ì§€ ì•ŠìŒ
       default void refund(Payment payment) {
           System.out.println("Refund not implemented");
       }
   }
   ```

2. **ê³µí†µ ê¸°ë³¸ êµ¬í˜„ ì œê³µ**
   ```java
   interface Logger {
       void log(String message);

       default void logError(String message) {
           log("ERROR: " + message);
       }

       default void logWarning(String message) {
           log("WARNING: " + message);
       }
   }
   ```

3. **ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œ**
   ```java
   interface Comparable<T> {
       int compareTo(T other);

       default boolean lessThan(T other) {
           return compareTo(other) < 0;
       }

       default boolean greaterThan(T other) {
           return compareTo(other) > 0;
       }
   }
   ```

**ì£¼ì˜ì‚¬í•­:**
- ë„ˆë¬´ ë§ì€ default ë©”ì„œë“œëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ë¬´ê²ê²Œ ë§Œë“¦
- ìƒíƒœë¥¼ ê°€ì§ˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í•œê³„ê°€ ìˆìŒ
- ì¶©ëŒ ê°€ëŠ¥ì„±ì„ í•­ìƒ ê³ ë ¤

---

### Q3. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤(Functional Interface)ë€ ë¬´ì—‡ì¸ê°€ìš”?

**A:** ì¶”ìƒ ë©”ì„œë“œê°€ ì •í™•íˆ 1ê°œì¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.

**ê¸°ë³¸ ê°œë…:**
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    // ì¶”ìƒ ë©”ì„œë“œê°€ 1ê°œë§Œ ìˆì–´ì•¼ í•¨
}

// ëŒë‹¤ì‹ ì‚¬ìš© ê°€ëŠ¥
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));      // 8
System.out.println(multiply.calculate(5, 3)); // 15
```

**Java í‘œì¤€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤:**

| ì¸í„°í˜ì´ìŠ¤ | ë©”ì„œë“œ | ì„¤ëª… | ì˜ˆì œ |
|-----------|--------|------|------|
| `Predicate<T>` | `boolean test(T t)` | ì¡°ê±´ ê²€ì‚¬ | `x -> x > 0` |
| `Function<T,R>` | `R apply(T t)` | ë³€í™˜ | `x -> x * 2` |
| `Consumer<T>` | `void accept(T t)` | ì†Œë¹„ | `x -> System.out.println(x)` |
| `Supplier<T>` | `T get()` | ê³µê¸‰ | `() -> new Random().nextInt()` |

**ì‹¤ë¬´ í™œìš©:**
```java
// í•„í„°ë§
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)  // Predicate
    .collect(Collectors.toList());

// ë³€í™˜
List<String> strings = numbers.stream()
    .map(n -> "Number: " + n)  // Function
    .collect(Collectors.toList());

// ì¶œë ¥
numbers.forEach(n -> System.out.println(n));  // Consumer
```

---

### Q4. ì¸í„°í˜ì´ìŠ¤ì— static ë©”ì„œë“œëŠ” ì–¸ì œ ì‚¬ìš©í•˜ë‚˜ìš”?

**A:** ì¸í„°í˜ì´ìŠ¤ ê´€ë ¨ ìœ í‹¸ë¦¬í‹° ë©”ì„œë“œë¥¼ ì œê³µí•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.

**ì‚¬ìš© ì˜ˆ:**
```java
interface MathOperations {
    int calculate(int a, int b);

    // ìœ í‹¸ë¦¬í‹° static ë©”ì„œë“œ
    static MathOperations add() {
        return (a, b) -> a + b;
    }

    static MathOperations subtract() {
        return (a, b) -> a - b;
    }

    static MathOperations multiply() {
        return (a, b) -> a * b;
    }

    // íŒ©í† ë¦¬ ë©”ì„œë“œ
    static MathOperations create(String operation) {
        switch (operation) {
            case "add": return add();
            case "subtract": return subtract();
            case "multiply": return multiply();
            default: throw new IllegalArgumentException();
        }
    }
}

// ì‚¬ìš©
MathOperations op = MathOperations.create("add");
System.out.println(op.calculate(5, 3)); // 8
```

**ì‹¤ì œ Java API ì˜ˆ:**
```java
// Comparator ì¸í„°í˜ì´ìŠ¤ì˜ static ë©”ì„œë“œ
List<String> names = Arrays.asList("Charlie", "Alice", "Bob");

// naturalOrder() - static ë©”ì„œë“œ
names.sort(Comparator.naturalOrder());

// comparing() - static ë©”ì„œë“œ
List<Person> people = ...;
people.sort(Comparator.comparing(Person::getName));
```

---

### Q5. ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤(Marker Interface)ë€ ë¬´ì—‡ì¸ê°€ìš”?

**A:** ë©”ì„œë“œê°€ ì—†ëŠ” ë¹ˆ ì¸í„°í˜ì´ìŠ¤ë¡œ, íƒ€ì…ì„ í‘œì‹œí•˜ëŠ” ìš©ë„ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.

**Javaì˜ ëŒ€í‘œì ì¸ ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤:**
```java
// Serializable - ì§ë ¬í™” ê°€ëŠ¥í•¨ì„ í‘œì‹œ
public interface Serializable {
    // ë©”ì„œë“œ ì—†ìŒ
}

// Cloneable - ë³µì œ ê°€ëŠ¥í•¨ì„ í‘œì‹œ
public interface Cloneable {
    // ë©”ì„œë“œ ì—†ìŒ
}

// ì‚¬ìš© ì˜ˆ
class User implements Serializable {
    private String name;
    private int age;
    // ì´ì œ ì§ë ¬í™” ê°€ëŠ¥
}
```

**ì»¤ìŠ¤í…€ ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤:**
```java
// ì‚­ì œ ê°€ëŠ¥í•œ ì—”í‹°í‹° í‘œì‹œ
interface Deletable {
}

// ê°ì‚¬ ëŒ€ìƒ í‘œì‹œ
interface Auditable {
}

class Document implements Deletable, Auditable {
    // ...
}

// íƒ€ì… ì²´í¬ë¡œ í™œìš©
public void deleteIfPossible(Object obj) {
    if (obj instanceof Deletable) {
        // ì‚­ì œ ë¡œì§
        System.out.println("Deleting: " + obj);
    } else {
        throw new IllegalArgumentException("Not deletable");
    }
}
```

**í˜„ëŒ€ì  ëŒ€ì•ˆ - ì–´ë…¸í…Œì´ì…˜:**
```java
// ë§ˆì»¤ ì¸í„°í˜ì´ìŠ¤ ëŒ€ì‹  ì–´ë…¸í…Œì´ì…˜ ì‚¬ìš© (ë” ê¶Œì¥ë¨)
@interface Deletable {
}

@interface Auditable {
}

@Deletable
@Auditable
class Document {
    // ...
}
```

---

### Q6. ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ìœ¼ë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒì´ ì™œ ì¢‹ì€ê°€ìš”?

**A:** ìœ ì—°ì„±ê³¼ ë‹¤í˜•ì„±ì„ ìœ„í•´ì„œì…ë‹ˆë‹¤.

**ì¢‹ì€ ì˜ˆ (ì¸í„°í˜ì´ìŠ¤ íƒ€ì…):**
```java
// ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸
List<String> names = new ArrayList<>();

// ë‚˜ì¤‘ì— êµ¬í˜„ì²´ êµì²´ ê°€ëŠ¥
names = new LinkedList<>();  // OK!
names = new Vector<>();      // OK!

// ë©”ì„œë“œ íŒŒë¼ë¯¸í„°ë„ ì¸í„°í˜ì´ìŠ¤ íƒ€ì…
public void processNames(List<String> names) {
    // ArrayListë“  LinkedListë“  ìƒê´€ì—†ì´ ë™ì‘
    names.forEach(System.out::println);
}
```

**ë‚˜ìœ ì˜ˆ (êµ¬ì²´ í´ë˜ìŠ¤ íƒ€ì…):**
```java
// êµ¬ì²´ í´ë˜ìŠ¤ë¡œ ì„ ì–¸
ArrayList<String> names = new ArrayList<>();

// ë‹¤ë¥¸ êµ¬í˜„ì²´ë¡œ êµì²´ ë¶ˆê°€
names = new LinkedList<>();  // ì»´íŒŒì¼ ì—ëŸ¬!

// ë©”ì„œë“œê°€ íŠ¹ì • êµ¬í˜„ì— ì˜ì¡´
public void processNames(ArrayList<String> names) {
    // ArrayListë§Œ ë°›ì„ ìˆ˜ ìˆìŒ - ìœ ì—°ì„± ë–¨ì–´ì§
}
```

**ì‹¤ë¬´ ê°€ì´ë“œ:**
```java
// âœ… ì¢‹ìŒ: ì¸í„°í˜ì´ìŠ¤ íƒ€ì…
Map<String, User> userMap = new HashMap<>();
Set<String> tags = new HashSet<>();
Collection<Item> items = new ArrayList<>();

// âŒ ë‚˜ì¨: êµ¬ì²´ í´ë˜ìŠ¤ íƒ€ì…
HashMap<String, User> userMap = new HashMap<>();
HashSet<String> tags = new HashSet<>();
ArrayList<Item> items = new ArrayList<>();

// âœ… ì˜ˆì™¸: êµ¬ì²´ í´ë˜ìŠ¤ì˜ íŠ¹ì • ê¸°ëŠ¥ì´ í•„ìš”í•œ ê²½ìš°
LinkedList<Task> tasks = new LinkedList<>();
tasks.addFirst(task);  // LinkedListë§Œì˜ ë©”ì„œë“œ
```

---

### Q7. ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•  ë•Œ ë©”ì„œë“œ ì´ë¦„ì´ ì¶©ëŒí•˜ë©´ ì–´ë–»ê²Œ í•˜ë‚˜ìš”?

**A:** ì¶©ëŒ ìœ í˜•ì— ë”°ë¼ í•´ê²° ë°©ë²•ì´ ë‹¤ë¦…ë‹ˆë‹¤.

**ì¼€ì´ìŠ¤ 1: ê°™ì€ ì‹œê·¸ë‹ˆì²˜, ê°™ì€ ë°˜í™˜ íƒ€ì…**
```java
interface A {
    String getValue();
}

interface B {
    String getValue();
}

class MyClass implements A, B {
    @Override
    public String getValue() {
        // í•˜ë‚˜ë§Œ êµ¬í˜„í•˜ë©´ ë‘ ì¸í„°í˜ì´ìŠ¤ ëª¨ë‘ ë§Œì¡±
        return "value";
    }
}
```

**ì¼€ì´ìŠ¤ 2: default ë©”ì„œë“œ ì¶©ëŒ**
```java
interface A {
    default void process() {
        System.out.println("A");
    }
}

interface B {
    default void process() {
        System.out.println("B");
    }
}

class MyClass implements A, B {
    @Override
    public void process() {
        // ëª…ì‹œì ìœ¼ë¡œ ì˜¤ë²„ë¼ì´ë“œ í•„ìˆ˜
        A.super.process();  // Aì˜ default í˜¸ì¶œ
        B.super.process();  // Bì˜ default í˜¸ì¶œ
        // ë˜ëŠ” ìƒˆë¡œìš´ êµ¬í˜„
    }
}
```

**ì¼€ì´ìŠ¤ 3: ë°˜í™˜ íƒ€ì…ì´ ë‹¤ë¥¸ ê²½ìš° (í•´ê²° ë¶ˆê°€)**
```java
interface A {
    String getData();
}

interface B {
    int getData();  // ê°™ì€ ì´ë¦„, ë‹¤ë¥¸ ë°˜í™˜ íƒ€ì…
}

// ì»´íŒŒì¼ ì—ëŸ¬! êµ¬í˜„ ë¶ˆê°€ëŠ¥
// class MyClass implements A, B {
// }

// í•´ê²°: ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ì„ ëª…í™•íˆ ë¶„ë¦¬
interface A {
    String getStringData();
}

interface B {
    int getIntData();
}
```

---

## ğŸ¤ ë©´ì ‘ ì§ˆë¬¸

### ì£¼ë‹ˆì–´ ê°œë°œì ë©´ì ‘ ì§ˆë¬¸ (7ë¬¸ì œ)

#### Q1. ì¸í„°í˜ì´ìŠ¤ë€ ë¬´ì—‡ì´ë©°, ì™œ ì‚¬ìš©í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

ì¸í„°í˜ì´ìŠ¤ëŠ” í´ë˜ìŠ¤ê°€ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ë©”ì„œë“œë“¤ì˜ ì§‘í•©ì„ ì •ì˜í•˜ëŠ” ì¶”ìƒ íƒ€ì…ì…ë‹ˆë‹¤.

**ì‚¬ìš© ì´ìœ :**
1. **ì¶”ìƒí™”**: êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ì„ ìˆ¨ê¸°ê³  ê³„ì•½ë§Œ ì •ì˜
2. **ë‹¤ì¤‘ êµ¬í˜„**: JavaëŠ” ë‹¨ì¼ ìƒì†ë§Œ ì§€ì›í•˜ì§€ë§Œ, ì¸í„°í˜ì´ìŠ¤ëŠ” ì—¬ëŸ¬ ê°œ êµ¬í˜„ ê°€ëŠ¥
3. **ëŠìŠ¨í•œ ê²°í•©**: êµ¬í˜„ì²´ê°€ ì•„ë‹Œ ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´í•˜ì—¬ ìœ ì—°í•œ ì„¤ê³„
4. **ë‹¤í˜•ì„±**: í•˜ë‚˜ì˜ ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ìœ¼ë¡œ ì—¬ëŸ¬ êµ¬í˜„ì²´ë¥¼ ë‹¤ë£° ìˆ˜ ìˆìŒ

**ì˜ˆì œ:**
```java
// ê²°ì œ ì¸í„°í˜ì´ìŠ¤
interface Payment {
    boolean process(double amount);
}

// ë‹¤ì–‘í•œ êµ¬í˜„
class CreditCardPayment implements Payment {
    public boolean process(double amount) {
        // ì‹ ìš©ì¹´ë“œ ê²°ì œ ë¡œì§
        return true;
    }
}

class KakaoPayment implements Payment {
    public boolean process(double amount) {
        // ì¹´ì¹´ì˜¤í˜ì´ ê²°ì œ ë¡œì§
        return true;
    }
}

// ë‹¤í˜•ì„± í™œìš©
Payment payment = new CreditCardPayment();
payment.process(10000);  // ì–´ë–¤ êµ¬í˜„ì²´ë“  ë™ì¼í•˜ê²Œ ì‚¬ìš©
```

---

#### Q2. ì¸í„°í˜ì´ìŠ¤ì™€ ì¶”ìƒ í´ë˜ìŠ¤ì˜ ì°¨ì´ì ì„ ì„¤ëª…í•˜ì„¸ìš”.

**ëª¨ë²” ë‹µë³€:**

| êµ¬ë¶„ | ì¸í„°í˜ì´ìŠ¤ | ì¶”ìƒ í´ë˜ìŠ¤ |
|------|------------|-------------|
| **ìƒì†/êµ¬í˜„** | ì—¬ëŸ¬ ê°œ êµ¬í˜„ ê°€ëŠ¥ | í•˜ë‚˜ë§Œ ìƒì† ê°€ëŠ¥ |
| **í•„ë“œ** | ìƒìˆ˜ë§Œ ê°€ëŠ¥ (public static final) | ëª¨ë“  ì¢…ë¥˜ì˜ í•„ë“œ ê°€ëŠ¥ |
| **ìƒì„±ì** | ì—†ìŒ | ìˆìŒ |
| **ë©”ì„œë“œ** | ì¶”ìƒ ë©”ì„œë“œ + default/static | ì¶”ìƒ/êµ¬ì²´ ë©”ì„œë“œ ëª¨ë‘ ê°€ëŠ¥ |
| **ì ‘ê·¼ ì œì–´ì** | publicë§Œ (ê¸°ë³¸) | ëª¨ë“  ì ‘ê·¼ ì œì–´ì ì‚¬ìš© ê°€ëŠ¥ |
| **ê´€ê³„** | can-do (ëŠ¥ë ¥) | is-a (ê³„ì¸µ) |
| **ëª©ì ** | ê³„ì•½ ì •ì˜ | ê³µí†µ êµ¬í˜„ ì œê³µ |

**ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤:**
```java
// ì¶”ìƒ í´ë˜ìŠ¤: ê³µí†µ ì½”ë“œê°€ ë§ì„ ë•Œ
abstract class Animal {
    protected String name;  // ê³µí†µ í•„ë“œ

    public Animal(String name) {  // ìƒì„±ì
        this.name = name;
    }

    public void sleep() {  // ê³µí†µ êµ¬í˜„
        System.out.println(name + " is sleeping");
    }

    abstract void eat();  // ì„œë¸Œí´ë˜ìŠ¤ê°€ êµ¬í˜„
}

// ì¸í„°í˜ì´ìŠ¤: ëŠ¥ë ¥ì„ ì •ì˜í•  ë•Œ
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

// ì¡°í•© ì‚¬ìš©
class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    void eat() { /* ... */ }
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

---

#### Q3. ì¸í„°í˜ì´ìŠ¤ì˜ ëª¨ë“  ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì§€ ì•Šìœ¼ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

ì¸í„°í˜ì´ìŠ¤ì˜ ëª¨ë“  ì¶”ìƒ ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì§€ ì•Šìœ¼ë©´ **ì»´íŒŒì¼ ì—ëŸ¬**ê°€ ë°œìƒí•©ë‹ˆë‹¤.

**ì˜ˆì œ:**
```java
interface MediaPlayer {
    void play();
    void pause();
    void stop();
}

// âŒ ì»´íŒŒì¼ ì—ëŸ¬!
class SimplePlayer implements MediaPlayer {
    public void play() {
        System.out.println("Playing");
    }
    // pause()ì™€ stop()ì„ êµ¬í˜„í•˜ì§€ ì•ŠìŒ!
}
```

**ì—ëŸ¬ ë©”ì‹œì§€:**
```
Error: SimplePlayer is not abstract and does not override abstract method
pause() in MediaPlayer
```

**í•´ê²° ë°©ë²•:**

1. **ëª¨ë“  ë©”ì„œë“œ êµ¬í˜„:**
   ```java
   class SimplePlayer implements MediaPlayer {
       public void play() { /* êµ¬í˜„ */ }
       public void pause() { /* êµ¬í˜„ */ }
       public void stop() { /* êµ¬í˜„ */ }
   }
   ```

2. **ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ë§Œë“¤ê¸°:**
   ```java
   abstract class SimplePlayer implements MediaPlayer {
       public void play() { /* êµ¬í˜„ */ }
       // ë‚˜ë¨¸ì§€ëŠ” ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ êµ¬í˜„
   }
   ```

3. **ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ (ISP):**
   ```java
   interface BasicPlayer {
       void play();
   }

   interface AdvancedPlayer extends BasicPlayer {
       void pause();
       void stop();
   }

   // í•„ìš”í•œ ê²ƒë§Œ êµ¬í˜„
   class SimplePlayer implements BasicPlayer {
       public void play() { /* êµ¬í˜„ */ }
   }
   ```

---

#### Q4. default ë©”ì„œë“œëŠ” ë¬´ì—‡ì´ë©°, ì™œ Java 8ì— ì¶”ê°€ë˜ì—ˆë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

default ë©”ì„œë“œëŠ” ì¸í„°í˜ì´ìŠ¤ì— ê¸°ë³¸ êµ¬í˜„ì„ ì œê³µí•˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.

**ì¶”ê°€ëœ ì´ìœ :**
1. **í•˜ìœ„ í˜¸í™˜ì„±**: ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ì— ìƒˆ ë©”ì„œë“œë¥¼ ì¶”ê°€í•´ë„ ê¸°ì¡´ êµ¬í˜„ì²´ê°€ ê¹¨ì§€ì§€ ì•ŠìŒ
2. **ê³µí†µ ê¸°ëŠ¥ ì œê³µ**: ì¸í„°í˜ì´ìŠ¤ì—ì„œë„ ê³µí†µ êµ¬í˜„ ì½”ë“œë¥¼ ì œê³µ ê°€ëŠ¥
3. **ì„ íƒì  êµ¬í˜„**: í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì˜¤ë²„ë¼ì´ë“œ

**ì˜ˆì œ:**
```java
interface Collection<E> {
    // ê¸°ì¡´ ë©”ì„œë“œë“¤...
    boolean add(E e);
    boolean remove(Object o);

    // Java 8ì— ì¶”ê°€ëœ default ë©”ì„œë“œ
    default void forEach(Consumer<? super E> action) {
        for (E element : this) {
            action.accept(element);
        }
    }

    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
}

// ê¸°ì¡´ êµ¬í˜„ì²´ë“¤ì€ ìˆ˜ì • ì—†ì´ë„ ìƒˆ ë©”ì„œë“œ ì‚¬ìš© ê°€ëŠ¥!
List<String> list = new ArrayList<>();
list.add("A");
list.add("B");
list.forEach(System.out::println);  // default ë©”ì„œë“œ ì‚¬ìš©
```

**ì‹¤ë¬´ í™œìš©:**
```java
interface Logger {
    void log(String message);

    // í¸ì˜ ë©”ì„œë“œë“¤
    default void logInfo(String message) {
        log("INFO: " + message);
    }

    default void logError(String message) {
        log("ERROR: " + message);
    }

    default void logDebug(String message) {
        log("DEBUG: " + message);
    }
}

// êµ¬í˜„ í´ë˜ìŠ¤ëŠ” log()ë§Œ êµ¬í˜„í•˜ë©´ ë¨
class ConsoleLogger implements Logger {
    public void log(String message) {
        System.out.println(message);
    }
    // logInfo, logError, logDebugëŠ” ìë™ìœ¼ë¡œ ì‚¬ìš© ê°€ëŠ¥
}
```

---

#### Q5. ì¸í„°í˜ì´ìŠ¤ë¥¼ ì§ì ‘ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ìˆë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

**ì•„ë‹ˆìš”, ì¸í„°í˜ì´ìŠ¤ëŠ” ì§ì ‘ ì¸ìŠ¤í„´ìŠ¤í™”í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.**

ì¸í„°í˜ì´ìŠ¤ëŠ” ì¶”ìƒ íƒ€ì…ì´ë¯€ë¡œ êµ¬í˜„ì²´ë¥¼ í†µí•´ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì˜ëª»ëœ ì‹œë„:**
```java
interface Runnable {
    void run();
}

// âŒ ì»´íŒŒì¼ ì—ëŸ¬!
Runnable r = new Runnable();
```

**ì˜¬ë°”ë¥¸ ë°©ë²•:**

1. **êµ¬í˜„ í´ë˜ìŠ¤ ì‚¬ìš©:**
   ```java
   class MyRunnable implements Runnable {
       public void run() {
           System.out.println("Running");
       }
   }

   Runnable r = new MyRunnable();
   r.run();
   ```

2. **ìµëª… í´ë˜ìŠ¤ ì‚¬ìš©:**
   ```java
   Runnable r = new Runnable() {
       @Override
       public void run() {
           System.out.println("Running");
       }
   };
   r.run();
   ```

3. **ëŒë‹¤ì‹ ì‚¬ìš© (í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì¸ ê²½ìš°):**
   ```java
   Runnable r = () -> System.out.println("Running");
   r.run();
   ```

**ì™œ ì¸ìŠ¤í„´ìŠ¤í™”ê°€ ë¶ˆê°€ëŠ¥í•œê°€?**
- ì¸í„°í˜ì´ìŠ¤ëŠ” êµ¬í˜„ ì½”ë“œê°€ ì—†ëŠ” ì¶”ìƒ ë©”ì„œë“œë¥¼ í¬í•¨
- ê°ì²´ë¥¼ ë§Œë“¤ë ¤ë©´ ëª¨ë“  ë©”ì„œë“œê°€ êµ¬í˜„ë˜ì–´ ìˆì–´ì•¼ í•¨
- ë”°ë¼ì„œ êµ¬í˜„ í´ë˜ìŠ¤ê°€ í•„ìš”í•¨

---

#### Q6. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤(Functional Interface)ë€ ë¬´ì—‡ì¸ê°€ìš”?

**ëª¨ë²” ë‹µë³€:**

í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” **ì¶”ìƒ ë©”ì„œë“œê°€ ì •í™•íˆ í•˜ë‚˜ë§Œ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤**ì…ë‹ˆë‹¤.

ëŒë‹¤ì‹ê³¼ í•¨ê»˜ ì‚¬ìš©ë˜ë©°, `@FunctionalInterface` ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**íŠ¹ì§•:**
- ì¶”ìƒ ë©”ì„œë“œ 1ê°œ
- default ë©”ì„œë“œëŠ” ì—¬ëŸ¬ ê°œ ê°€ëŠ¥
- static ë©”ì„œë“œë„ ì—¬ëŸ¬ ê°œ ê°€ëŠ¥
- ëŒë‹¤ì‹ìœ¼ë¡œ ê°„ê²°í•˜ê²Œ êµ¬í˜„ ê°€ëŠ¥

**ì˜ˆì œ:**
```java
// í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ ì •ì˜
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // ì¶”ìƒ ë©”ì„œë“œ 1ê°œ

    // defaultì™€ staticì€ ê°œìˆ˜ ì œí•œ ì—†ìŒ
    default void printResult(int result) {
        System.out.println("Result: " + result);
    }

    static Calculator add() {
        return (a, b) -> a + b;
    }
}

// ëŒë‹¤ì‹ìœ¼ë¡œ êµ¬í˜„
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));      // 8
System.out.println(multiply.calculate(5, 3)); // 15
```

**Java í‘œì¤€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤:**
```java
// Predicate<T> - ì¡°ê±´ ê²€ì‚¬
Predicate<Integer> isPositive = n -> n > 0;
System.out.println(isPositive.test(5));  // true

// Function<T,R> - ë³€í™˜
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Hello"));  // 5

// Consumer<T> - ì†Œë¹„
Consumer<String> printer = s -> System.out.println(s);
printer.accept("Hello");  // Hello

// Supplier<T> - ê³µê¸‰
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());  // ëœë¤ ê°’
```

**ì‹¤ë¬´ í™œìš©:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// í•„í„°ë§ (Predicate)
numbers.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);  // 2, 4

// ë³€í™˜ (Function)
numbers.stream()
    .map(n -> n * 2)
    .forEach(System.out::println);  // 2, 4, 6, 8, 10
```

---

#### Q7. ì¸í„°í˜ì´ìŠ¤ì—ì„œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´ ì–´ë–»ê²Œ ë˜ë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

ì¸í„°í˜ì´ìŠ¤ì—ì„œ ì„ ì–¸í•˜ëŠ” ëª¨ë“  ë³€ìˆ˜ëŠ” **ìë™ìœ¼ë¡œ `public static final`**ì´ ë©ë‹ˆë‹¤. ì¦‰, **ìƒìˆ˜**ê°€ ë©ë‹ˆë‹¤.

**íŠ¹ì§•:**
- `public`: ì–´ë””ì„œë‚˜ ì ‘ê·¼ ê°€ëŠ¥
- `static`: ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ìœ¼ë¡œ ì§ì ‘ ì ‘ê·¼
- `final`: ê°’ ë³€ê²½ ë¶ˆê°€ëŠ¥ (ìƒìˆ˜)

**ì˜ˆì œ:**
```java
interface Constants {
    // ëª¨ë‘ ë™ì¼: public static finalì´ ìë™ ì¶”ê°€ë¨
    int MAX_SIZE = 100;
    public static final int MIN_SIZE = 0;
    String DEFAULT_NAME = "Unknown";
}

// ì‚¬ìš©
class Test {
    public static void main(String[] args) {
        System.out.println(Constants.MAX_SIZE);      // 100
        System.out.println(Constants.DEFAULT_NAME);  // Unknown

        // âŒ ì»´íŒŒì¼ ì—ëŸ¬! ê°’ ë³€ê²½ ë¶ˆê°€
        // Constants.MAX_SIZE = 200;
    }
}
```

**ì‹¤ì œ ì‚¬ìš© ì‚¬ë¡€:**
```java
// HTTP ìƒíƒœ ì½”ë“œ
interface HttpStatus {
    int OK = 200;
    int CREATED = 201;
    int BAD_REQUEST = 400;
    int UNAUTHORIZED = 401;
    int NOT_FOUND = 404;
    int INTERNAL_SERVER_ERROR = 500;
}

// ì‚¬ìš©
if (statusCode == HttpStatus.NOT_FOUND) {
    System.out.println("Page not found");
}
```

**Enumê³¼ì˜ ë¹„êµ:**
```java
// ì˜ˆì „ ë°©ì‹: ì¸í„°í˜ì´ìŠ¤ ìƒìˆ˜
interface Color {
    int RED = 0;
    int GREEN = 1;
    int BLUE = 2;
}

// í˜„ëŒ€ì  ë°©ì‹: Enum (ë” ê¶Œì¥ë¨)
enum Color {
    RED, GREEN, BLUE
}

// Enumì´ ë” ì¢‹ì€ ì´ìœ :
// 1. íƒ€ì… ì•ˆì •ì„±
// 2. ë©”ì„œë“œ ì¶”ê°€ ê°€ëŠ¥
// 3. switch ë¬¸ì—ì„œ ì‚¬ìš© í¸ë¦¬
```

---

### ì¤‘ê¸‰ ê°œë°œì ë©´ì ‘ ì§ˆë¬¸ (5ë¬¸ì œ)

#### Q8. ì¸í„°í˜ì´ìŠ¤ ê¸°ë°˜ ì„¤ê³„ì˜ SOLID ì›ì¹™ ì¤‘ ì–´ë–¤ ê²ƒì„ ë§Œì¡±í•˜ë‚˜ìš”?

**ëª¨ë²” ë‹µë³€:**

ì¸í„°í˜ì´ìŠ¤ëŠ” SOLID ì›ì¹™ì˜ ì—¬ëŸ¬ í•­ëª©ì„ ë§Œì¡±í•˜ëŠ” í•µì‹¬ ë„êµ¬ì…ë‹ˆë‹¤.

**1. SRP (Single Responsibility Principle) - ë‹¨ì¼ ì±…ì„ ì›ì¹™**
```java
// âŒ ë‚˜ìœ ì˜ˆ: í•˜ë‚˜ì˜ ì¸í„°í˜ì´ìŠ¤ì— ë„ˆë¬´ ë§ì€ ì±…ì„
interface UserService {
    void createUser();
    void deleteUser();
    void sendEmail();
    void generateReport();
    void processPayment();
}

// âœ… ì¢‹ì€ ì˜ˆ: ì±…ì„ë³„ë¡œ ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬
interface UserRepository {
    void createUser();
    void deleteUser();
}

interface EmailService {
    void sendEmail();
}

interface ReportGenerator {
    void generateReport();
}
```

**2. OCP (Open/Closed Principle) - ê°œë°©/íì‡„ ì›ì¹™**
```java
// í™•ì¥ì—ëŠ” ì—´ë ¤ìˆê³ , ìˆ˜ì •ì—ëŠ” ë‹«í˜€ìˆìŒ
interface PaymentProcessor {
    boolean process(Payment payment);
}

// ìƒˆë¡œìš´ ê²°ì œ ë°©ì‹ ì¶”ê°€ ì‹œ ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ì—†ì´ í™•ì¥
class CreditCardProcessor implements PaymentProcessor { }
class PayPalProcessor implements PaymentProcessor { }
class KakaoPayProcessor implements PaymentProcessor { }  // ìƒˆë¡œ ì¶”ê°€

// ì‚¬ìš©í•˜ëŠ” ì½”ë“œëŠ” ë³€ê²½ ë¶ˆí•„ìš”
class OrderService {
    private PaymentProcessor processor;

    public void processOrder(Payment payment) {
        processor.process(payment);  // ì–´ë–¤ êµ¬í˜„ì²´ë“  ë™ì‘
    }
}
```

**3. LSP (Liskov Substitution Principle) - ë¦¬ìŠ¤ì½”í”„ ì¹˜í™˜ ì›ì¹™**
```java
interface Shape {
    double area();
}

class Circle implements Shape {
    public double area() { return Math.PI * radius * radius; }
}

class Rectangle implements Shape {
    public double area() { return width * height; }
}

// Shape íƒ€ì…ìœ¼ë¡œ Circleê³¼ Rectangleì„ ë™ì¼í•˜ê²Œ ì‚¬ìš© ê°€ëŠ¥
void printArea(Shape shape) {
    System.out.println(shape.area());  // ì–´ë–¤ êµ¬í˜„ì²´ë“  ì •ìƒ ë™ì‘
}
```

**4. ISP (Interface Segregation Principle) - ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™**
```java
// âŒ ë‚˜ìœ ì˜ˆ: ê±°ëŒ€í•œ ì¸í„°í˜ì´ìŠ¤
interface Worker {
    void work();
    void eat();
    void sleep();
    void getPaid();
}

// âœ… ì¢‹ì€ ì˜ˆ: ì‘ê³  êµ¬ì²´ì ì¸ ì¸í„°í˜ì´ìŠ¤ë“¤
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

interface Payable {
    void getPaid();
}

// í•„ìš”í•œ ê²ƒë§Œ êµ¬í˜„
class Robot implements Workable {
    public void work() { /* ... */ }
    // Robotì€ ë¨¹ê±°ë‚˜ ìì§€ ì•Šìœ¼ë¯€ë¡œ ë‹¤ë¥¸ ì¸í„°í˜ì´ìŠ¤ëŠ” êµ¬í˜„ ì•ˆ í•¨
}

class Human implements Workable, Eatable, Sleepable, Payable {
    // ëª¨ë“  ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„
}
```

**5. DIP (Dependency Inversion Principle) - ì˜ì¡´ì„± ì—­ì „ ì›ì¹™**
```java
// âŒ ë‚˜ìœ ì˜ˆ: êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´
class OrderService {
    private MySQLDatabase database;  // êµ¬ì²´ í´ë˜ìŠ¤ì— ì˜ì¡´

    public void saveOrder(Order order) {
        database.save(order);
    }
}

// âœ… ì¢‹ì€ ì˜ˆ: ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´
interface Database {
    void save(Order order);
}

class OrderService {
    private Database database;  // ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´

    public OrderService(Database database) {
        this.database = database;
    }

    public void saveOrder(Order order) {
        database.save(order);  // MySQLì´ë“  MongoDBë“  ìƒê´€ì—†ìŒ
    }
}

class MySQLDatabase implements Database { }
class MongoDatabase implements Database { }
```

---

#### Q9. ì¸í„°í˜ì´ìŠ¤ì™€ ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ í•¨ê»˜ ì‚¬ìš©í•˜ëŠ” ë””ìì¸ íŒ¨í„´ì„ ì„¤ëª…í•˜ì„¸ìš”.

**ëª¨ë²” ë‹µë³€:**

ì¸í„°í˜ì´ìŠ¤ì™€ ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì¡°í•©í•˜ë©´ **ìœ ì—°ì„±**ê³¼ **ì½”ë“œ ì¬ì‚¬ìš©**ì„ ëª¨ë‘ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**íŒ¨í„´: ì¸í„°í˜ì´ìŠ¤ + ì¶”ìƒ ê³¨ê²© í´ë˜ìŠ¤ (Skeletal Implementation)**

Javaì˜ ì»¬ë ‰ì…˜ í”„ë ˆì„ì›Œí¬ì—ì„œ ë§ì´ ì‚¬ìš©í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

**êµ¬ì¡°:**
```java
// 1. ì¸í„°í˜ì´ìŠ¤ ì •ì˜ (ê³„ì•½)
interface List<E> {
    boolean add(E element);
    E get(int index);
    int size();
    boolean isEmpty();
    // ... ë§ì€ ë©”ì„œë“œë“¤
}

// 2. ì¶”ìƒ ê³¨ê²© í´ë˜ìŠ¤ (ê³µí†µ êµ¬í˜„ ì œê³µ)
abstract class AbstractList<E> implements List<E> {

    // ê³µí†µ êµ¬í˜„ ë©”ì„œë“œ
    @Override
    public boolean isEmpty() {
        return size() == 0;
    }

    @Override
    public boolean contains(E element) {
        for (int i = 0; i < size(); i++) {
            if (get(i).equals(element)) {
                return true;
            }
        }
        return false;
    }

    // ì„œë¸Œí´ë˜ìŠ¤ê°€ êµ¬í˜„í•´ì•¼ í•˜ëŠ” í•µì‹¬ ë©”ì„œë“œë§Œ ì¶”ìƒìœ¼ë¡œ
    @Override
    public abstract E get(int index);

    @Override
    public abstract int size();
}

// 3. êµ¬ì²´ í´ë˜ìŠ¤ (ìµœì†Œí•œì˜ êµ¬í˜„ë§Œ)
class ArrayList<E> extends AbstractList<E> {
    private Object[] elements;
    private int size;

    @Override
    public boolean add(E element) {
        elements[size++] = element;
        return true;
    }

    @Override
    public E get(int index) {
        return (E) elements[index];
    }

    @Override
    public int size() {
        return size;
    }

    // isEmpty(), contains()ëŠ” AbstractListì—ì„œ ìƒì†ë°›ì•„ ì‚¬ìš©
}
```

**ì‹¤ë¬´ ì˜ˆì œ:**
```java
// ì•Œë¦¼ ì‹œìŠ¤í…œ ì˜ˆì œ
interface NotificationChannel {
    boolean send(Notification notification);
    String getChannelName();
    boolean supports(NotificationType type);
}

// ê³µí†µ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ì¶”ìƒ í´ë˜ìŠ¤
abstract class AbstractNotificationChannel implements NotificationChannel {
    protected boolean enabled = true;
    protected int retryCount = 3;

    @Override
    public boolean send(Notification notification) {
        // ê³µí†µ ì „ì²˜ë¦¬
        if (!enabled) {
            System.out.println("Channel disabled");
            return false;
        }

        if (!supports(notification.getType())) {
            System.out.println("Type not supported");
            return false;
        }

        // ì¬ì‹œë„ ë¡œì§
        for (int i = 0; i < retryCount; i++) {
            if (doSend(notification)) {
                return true;
            }
            System.out.println("Retry " + (i + 1));
        }

        return false;
    }

    // ì„œë¸Œí´ë˜ìŠ¤ê°€ êµ¬í˜„í•  í•µì‹¬ ë©”ì„œë“œ
    protected abstract boolean doSend(Notification notification);
}

// êµ¬ì²´ í´ë˜ìŠ¤ëŠ” í•µì‹¬ ë¡œì§ë§Œ êµ¬í˜„
class EmailChannel extends AbstractNotificationChannel {
    @Override
    protected boolean doSend(Notification notification) {
        // ì´ë©”ì¼ ì „ì†¡ ë¡œì§ë§Œ êµ¬í˜„
        System.out.println("Sending email: " + notification.getMessage());
        return true;
    }

    @Override
    public String getChannelName() {
        return "Email";
    }

    @Override
    public boolean supports(NotificationType type) {
        return true;  // ëª¨ë“  íƒ€ì… ì§€ì›
    }
}

class SmsChannel extends AbstractNotificationChannel {
    @Override
    protected boolean doSend(Notification notification) {
        // SMS ì „ì†¡ ë¡œì§ë§Œ êµ¬í˜„
        System.out.println("Sending SMS: " + notification.getMessage());
        return true;
    }

    @Override
    public String getChannelName() {
        return "SMS";
    }

    @Override
    public boolean supports(NotificationType type) {
        return type == NotificationType.URGENT;  // ê¸´ê¸‰ë§Œ ì§€ì›
    }
}
```

**ì¥ì :**
1. ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ì—°ì„± ìœ ì§€ (ë‹¤ì¤‘ êµ¬í˜„ ê°€ëŠ¥)
2. ê³µí†µ ì½”ë“œ ì¬ì‚¬ìš© (ì¶”ìƒ í´ë˜ìŠ¤)
3. ìµœì†Œí•œì˜ êµ¬í˜„ìœ¼ë¡œ ìƒˆë¡œìš´ í´ë˜ìŠ¤ ì¶”ê°€ ê°€ëŠ¥
4. í…œí”Œë¦¿ ë©”ì„œë“œ íŒ¨í„´ í™œìš© ê°€ëŠ¥

---

#### Q10. Java 8 ì´í›„ ì¸í„°í˜ì´ìŠ¤ì— default ë©”ì„œë“œê°€ ì¶”ê°€ë˜ë©´ì„œ ì¶”ìƒ í´ë˜ìŠ¤ì™€ì˜ ì°¨ì´ê°€ ì¤„ì–´ë“¤ì—ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¼ì—ë„ ì¶”ìƒ í´ë˜ìŠ¤ê°€ í•„ìš”í•œ ì´ìœ ëŠ”?

**ëª¨ë²” ë‹µë³€:**

default ë©”ì„œë“œê°€ ì¶”ê°€ë˜ì—ˆì§€ë§Œ, ì¶”ìƒ í´ë˜ìŠ¤ëŠ” ì—¬ì „íˆ ì¤‘ìš”í•œ ì—­í• ì„ í•©ë‹ˆë‹¤.

**ì¶”ìƒ í´ë˜ìŠ¤ë§Œ í•  ìˆ˜ ìˆëŠ” ê²ƒë“¤:**

**1. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ (ìƒíƒœ) ë³´ìœ **
```java
// ì¸í„°í˜ì´ìŠ¤: ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ë¶ˆê°€ëŠ¥
interface Drawable {
    // int x, y;  // âŒ ë¶ˆê°€ëŠ¥ (ìƒìˆ˜ë§Œ ê°€ëŠ¥)

    default void draw() {
        // âŒ ìƒíƒœë¥¼ ì €ì¥í•  ë°©ë²•ì´ ì—†ìŒ
    }
}

// ì¶”ìƒ í´ë˜ìŠ¤: ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ê°€ëŠ¥
abstract class Shape {
    protected int x, y;  // âœ… ìƒíƒœ ë³´ìœ  ê°€ëŠ¥
    protected String color;

    public Shape(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void moveTo(int newX, int newY) {
        this.x = newX;
        this.y = newY;
    }

    abstract void draw();
}
```

**2. ìƒì„±ì**
```java
// ì¸í„°í˜ì´ìŠ¤: ìƒì„±ì ì—†ìŒ
interface Animal {
    // âŒ ìƒì„±ì ë¶ˆê°€ëŠ¥
}

// ì¶”ìƒ í´ë˜ìŠ¤: ìƒì„±ì ìˆìŒ
abstract class Animal {
    private String name;
    private int age;

    // âœ… ìƒì„±ìë¡œ í•„ìˆ˜ í•„ë“œ ì´ˆê¸°í™”
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    abstract void makeSound();
}

class Dog extends Animal {
    public Dog(String name, int age) {
        super(name, age);  // ë¶€ëª¨ ìƒì„±ì í˜¸ì¶œ
    }

    void makeSound() {
        System.out.println("Woof!");
    }
}
```

**3. protected ë©¤ë²„**
```java
// ì¸í„°í˜ì´ìŠ¤: publicë§Œ ê°€ëŠ¥
interface Processor {
    // âŒ protected ë¶ˆê°€ëŠ¥
    void process();
}

// ì¶”ìƒ í´ë˜ìŠ¤: ëª¨ë“  ì ‘ê·¼ ì œì–´ì ì‚¬ìš© ê°€ëŠ¥
abstract class DataProcessor {
    // âœ… ì„œë¸Œí´ë˜ìŠ¤ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥í•œ protected ë©”ì„œë“œ
    protected void validateData(String data) {
        if (data == null) {
            throw new IllegalArgumentException();
        }
    }

    // âœ… ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©í•˜ëŠ” private ë©”ì„œë“œ
    private void log(String message) {
        System.out.println(message);
    }

    public abstract void process(String data);
}
```

**4. final ë©”ì„œë“œ (ì˜¤ë²„ë¼ì´ë“œ ë°©ì§€)**
```java
// ì¶”ìƒ í´ë˜ìŠ¤: final ë©”ì„œë“œë¡œ ë³€ê²½ ë°©ì§€
abstract class PaymentProcessor {
    // âœ… ì„œë¸Œí´ë˜ìŠ¤ê°€ ì ˆëŒ€ ì˜¤ë²„ë¼ì´ë“œí•  ìˆ˜ ì—†ìŒ
    public final void processPayment(Payment payment) {
        validatePayment(payment);
        deductAmount(payment);
        sendReceipt(payment);
    }

    protected abstract void validatePayment(Payment payment);
    protected abstract void deductAmount(Payment payment);

    private void sendReceipt(Payment payment) {
        // ì˜ìˆ˜ì¦ ë°œì†¡
    }
}
```

**5. ëª…í™•í•œ ìƒì† ê³„ì¸µ**
```java
// ì¶”ìƒ í´ë˜ìŠ¤: is-a ê´€ê³„ í‘œí˜„
abstract class Vehicle {
    private String brand;
    private int maxSpeed;

    public Vehicle(String brand, int maxSpeed) {
        this.brand = brand;
        this.maxSpeed = maxSpeed;
    }

    public void start() {
        System.out.println(brand + " starting...");
    }

    abstract void move();
}

class Car extends Vehicle {
    public Car(String brand) {
        super(brand, 200);
    }

    void move() {
        System.out.println("Driving on road");
    }
}

// Car IS-A Vehicle (ëª…í™•í•œ ìƒì† ê´€ê³„)
```

**ì‹¤ë¬´ ê°€ì´ë“œ:**

| ìƒí™© | ì„ íƒ |
|------|------|
| ê³µí†µ ìƒíƒœ(í•„ë“œ)ê°€ í•„ìš”í•¨ | ì¶”ìƒ í´ë˜ìŠ¤ |
| ìƒì„±ìê°€ í•„ìš”í•¨ | ì¶”ìƒ í´ë˜ìŠ¤ |
| protected ë©¤ë²„ê°€ í•„ìš”í•¨ | ì¶”ìƒ í´ë˜ìŠ¤ |
| ë‹¤ì¤‘ êµ¬í˜„ì´ í•„ìš”í•¨ | ì¸í„°í˜ì´ìŠ¤ |
| ê´€ë ¨ ì—†ëŠ” í´ë˜ìŠ¤ë“¤ì˜ ê³µí†µ í–‰ë™ | ì¸í„°í˜ì´ìŠ¤ |
| is-a ê´€ê³„ | ì¶”ìƒ í´ë˜ìŠ¤ |
| can-do ê´€ê³„ | ì¸í„°í˜ì´ìŠ¤ |

**ìµœì„ ì˜ ì¡°í•©:**
```java
// ì¸í„°í˜ì´ìŠ¤ë¡œ ëŠ¥ë ¥ ì •ì˜
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

// ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ê³µí†µ ìƒíƒœì™€ êµ¬í˜„ ì œê³µ
abstract class Animal {
    protected String name;
    protected int energy;

    public Animal(String name) {
        this.name = name;
        this.energy = 100;
    }

    public void rest() {
        energy += 20;
    }

    abstract void eat();
}

// ì¡°í•© ì‚¬ìš©
class Duck extends Animal implements Flyable, Swimmable {
    public Duck(String name) {
        super(name);
    }

    void eat() { /* ... */ }
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

---

#### Q11. ì „ëµ íŒ¨í„´(Strategy Pattern)ê³¼ ì¸í„°í˜ì´ìŠ¤ì˜ ê´€ê³„ë¥¼ ì„¤ëª…í•˜ê³ , ì‹¤ì œ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì œì‹œí•˜ì„¸ìš”.

**ëª¨ë²” ë‹µë³€:**

ì „ëµ íŒ¨í„´ì€ **ì•Œê³ ë¦¬ì¦˜ì„ ìº¡ìŠí™”í•˜ê³  êµì²´ ê°€ëŠ¥í•˜ê²Œ ë§Œë“œëŠ” ë””ìì¸ íŒ¨í„´**ìœ¼ë¡œ, ì¸í„°í˜ì´ìŠ¤ë¥¼ í•µì‹¬ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.

**êµ¬ì¡°:**
1. Strategy ì¸í„°í˜ì´ìŠ¤: ì•Œê³ ë¦¬ì¦˜ì˜ ê³µí†µ ì¸í„°í˜ì´ìŠ¤
2. Concrete Strategy: ë‹¤ì–‘í•œ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„
3. Context: ì „ëµì„ ì‚¬ìš©í•˜ëŠ” í´ë˜ìŠ¤

**ê¸°ë³¸ ì˜ˆì œ:**
```java
// 1. ì „ëµ ì¸í„°í˜ì´ìŠ¤
interface PaymentStrategy {
    boolean pay(double amount);
    String getPaymentMethod();
}

// 2. êµ¬ì²´ì  ì „ëµë“¤
class CreditCardStrategy implements PaymentStrategy {
    private String cardNumber;

    public CreditCardStrategy(String cardNumber) {
        this.cardNumber = cardNumber;
    }

    @Override
    public boolean pay(double amount) {
        System.out.println("ì‹ ìš©ì¹´ë“œ " + cardNumber + "ë¡œ " + amount + "ì› ê²°ì œ");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Credit Card";
    }
}

class KakaoPayStrategy implements PaymentStrategy {
    private String phoneNumber;

    public KakaoPayStrategy(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    @Override
    public boolean pay(double amount) {
        System.out.println("ì¹´ì¹´ì˜¤í˜ì´ë¡œ " + amount + "ì› ê²°ì œ");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Kakao Pay";
    }
}

class NaverPayStrategy implements PaymentStrategy {
    @Override
    public boolean pay(double amount) {
        System.out.println("ë„¤ì´ë²„í˜ì´ë¡œ " + amount + "ì› ê²°ì œ");
        return true;
    }

    @Override
    public String getPaymentMethod() {
        return "Naver Pay";
    }
}

// 3. Context í´ë˜ìŠ¤
class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    private PaymentStrategy paymentStrategy;

    public void addItem(Item item) {
        items.add(item);
    }

    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }

    public void checkout() {
        double total = items.stream()
            .mapToDouble(Item::getPrice)
            .sum();

        System.out.println("\nì´ ê¸ˆì•¡: " + total + "ì›");
        System.out.println("ê²°ì œ ìˆ˜ë‹¨: " + paymentStrategy.getPaymentMethod());

        boolean success = paymentStrategy.pay(total);

        if (success) {
            System.out.println("âœ“ ê²°ì œ ì™„ë£Œ!");
            items.clear();
        } else {
            System.out.println("âœ— ê²°ì œ ì‹¤íŒ¨!");
        }
    }
}

// ì‚¬ìš©
ShoppingCart cart = new ShoppingCart();
cart.addItem(new Item("ë…¸íŠ¸ë¶", 1500000));
cart.addItem(new Item("ë§ˆìš°ìŠ¤", 30000));

// ëŸ°íƒ€ì„ì— ì „ëµ ë³€ê²½ ê°€ëŠ¥!
cart.setPaymentStrategy(new CreditCardStrategy("1234-5678-9012-3456"));
cart.checkout();

// ë‹¤ë¥¸ ê²°ì œ ìˆ˜ë‹¨ìœ¼ë¡œ ë³€ê²½
cart.addItem(new Item("í‚¤ë³´ë“œ", 80000));
cart.setPaymentStrategy(new KakaoPayStrategy("010-1234-5678"));
cart.checkout();
```

**ì‹¤ë¬´ ì‚¬ë¡€ 1: ì •ë ¬ ì•Œê³ ë¦¬ì¦˜**
```java
// ì •ë ¬ ì „ëµ ì¸í„°í˜ì´ìŠ¤
interface SortStrategy<T> {
    void sort(List<T> list, Comparator<T> comparator);
}

// ë²„ë¸” ì •ë ¬
class BubbleSortStrategy<T> implements SortStrategy<T> {
    @Override
    public void sort(List<T> list, Comparator<T> comparator) {
        System.out.println("Bubble Sort ì‚¬ìš©");
        // ë²„ë¸” ì •ë ¬ êµ¬í˜„
        for (int i = 0; i < list.size() - 1; i++) {
            for (int j = 0; j < list.size() - i - 1; j++) {
                if (comparator.compare(list.get(j), list.get(j + 1)) > 0) {
                    T temp = list.get(j);
                    list.set(j, list.get(j + 1));
                    list.set(j + 1, temp);
                }
            }
        }
    }
}

// í€µ ì •ë ¬
class QuickSortStrategy<T> implements SortStrategy<T> {
    @Override
    public void sort(List<T> list, Comparator<T> comparator) {
        System.out.println("Quick Sort ì‚¬ìš©");
        // í€µ ì •ë ¬ êµ¬í˜„
        quickSort(list, 0, list.size() - 1, comparator);
    }

    private void quickSort(List<T> list, int low, int high, Comparator<T> comparator) {
        // í€µ ì •ë ¬ ë¡œì§...
    }
}

// Context
class Sorter<T> {
    private SortStrategy<T> strategy;

    public void setStrategy(SortStrategy<T> strategy) {
        this.strategy = strategy;
    }

    public void sort(List<T> list, Comparator<T> comparator) {
        // ë°ì´í„° í¬ê¸°ì— ë”°ë¼ ì „ëµ ì„ íƒ
        if (list.size() < 10) {
            setStrategy(new BubbleSortStrategy<>());
        } else {
            setStrategy(new QuickSortStrategy<>());
        }

        strategy.sort(list, comparator);
    }
}
```

**ì‹¤ë¬´ ì‚¬ë¡€ 2: íŒŒì¼ ì••ì¶•**
```java
// ì••ì¶• ì „ëµ
interface CompressionStrategy {
    byte[] compress(byte[] data);
    byte[] decompress(byte[] data);
    String getAlgorithmName();
}

class ZipCompression implements CompressionStrategy {
    @Override
    public byte[] compress(byte[] data) {
        System.out.println("ZIP ì••ì¶• ì¤‘...");
        // ZIP ì••ì¶• ë¡œì§
        return data;
    }

    @Override
    public byte[] decompress(byte[] data) {
        System.out.println("ZIP ì••ì¶• í•´ì œ ì¤‘...");
        return data;
    }

    @Override
    public String getAlgorithmName() {
        return "ZIP";
    }
}

class GzipCompression implements CompressionStrategy {
    @Override
    public byte[] compress(byte[] data) {
        System.out.println("GZIP ì••ì¶• ì¤‘...");
        return data;
    }

    @Override
    public byte[] decompress(byte[] data) {
        System.out.println("GZIP ì••ì¶• í•´ì œ ì¤‘...");
        return data;
    }

    @Override
    public String getAlgorithmName() {
        return "GZIP";
    }
}

// Context
class FileCompressor {
    private CompressionStrategy strategy;

    public void setCompressionStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void compressFile(String filename, byte[] data) {
        System.out.println("\níŒŒì¼ ì••ì¶•: " + filename);
        System.out.println("ì•Œê³ ë¦¬ì¦˜: " + strategy.getAlgorithmName());

        byte[] compressed = strategy.compress(data);

        System.out.println("ì›ë³¸ í¬ê¸°: " + data.length + " bytes");
        System.out.println("ì••ì¶• í¬ê¸°: " + compressed.length + " bytes");
    }
}

// ì‚¬ìš©
FileCompressor compressor = new FileCompressor();

// ì‘ì€ íŒŒì¼ì€ ZIP
compressor.setCompressionStrategy(new ZipCompression());
compressor.compressFile("small.txt", smallData);

// í° íŒŒì¼ì€ GZIP
compressor.setCompressionStrategy(new GzipCompression());
compressor.compressFile("large.txt", largeData);
```

**ì „ëµ íŒ¨í„´ì˜ ì¥ì :**
1. **ê°œë°©/íì‡„ ì›ì¹™ (OCP)**: ìƒˆë¡œìš´ ì „ëµ ì¶”ê°€ê°€ ì‰¬ì›€
2. **ëŸ°íƒ€ì„ ë³€ê²½**: ì‹¤í–‰ ì¤‘ì— ì•Œê³ ë¦¬ì¦˜ êµì²´ ê°€ëŠ¥
3. **ì¡°ê±´ë¬¸ ì œê±°**: if-else ëŒ€ì‹  ë‹¤í˜•ì„± ì‚¬ìš©
4. **í…ŒìŠ¤íŠ¸ ìš©ì´**: ê° ì „ëµì„ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥

**Before (ì „ëµ íŒ¨í„´ ì—†ì´):**
```java
class PaymentProcessor {
    public void processPayment(String type, double amount) {
        if (type.equals("credit")) {
            // ì‹ ìš©ì¹´ë“œ ë¡œì§
        } else if (type.equals("kakao")) {
            // ì¹´ì¹´ì˜¤í˜ì´ ë¡œì§
        } else if (type.equals("naver")) {
            // ë„¤ì´ë²„í˜ì´ ë¡œì§
        }
        // ìƒˆë¡œìš´ ê²°ì œ ìˆ˜ë‹¨ ì¶”ê°€ ì‹œ ì´ í´ë˜ìŠ¤ë¥¼ ìˆ˜ì •í•´ì•¼ í•¨ (OCP ìœ„ë°˜)
    }
}
```

**After (ì „ëµ íŒ¨í„´ ì‚¬ìš©):**
```java
class PaymentProcessor {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPayment(double amount) {
        strategy.pay(amount);
        // ìƒˆë¡œìš´ ê²°ì œ ìˆ˜ë‹¨ ì¶”ê°€ ì‹œ PaymentStrategy êµ¬í˜„ë§Œ ì¶”ê°€ (OCP ì¤€ìˆ˜)
    }
}
```

---

#### Q12. ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•œ Dependency Injection(ì˜ì¡´ì„± ì£¼ì…)ì˜ ì›ë¦¬ì™€ ì¥ì ì„ ì„¤ëª…í•˜ì„¸ìš”.

**ëª¨ë²” ë‹µë³€:**

ì˜ì¡´ì„± ì£¼ì…ì€ **ê°ì²´ê°€ í•„ìš”ë¡œ í•˜ëŠ” ì˜ì¡´ì„±ì„ ì™¸ë¶€ì—ì„œ ì£¼ì…ë°›ëŠ” ë””ìì¸ íŒ¨í„´**ìœ¼ë¡œ, ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ëŠìŠ¨í•œ ê²°í•©ì„ ë‹¬ì„±í•©ë‹ˆë‹¤.

**ì˜ì¡´ì„± ì£¼ì…ì˜ 3ê°€ì§€ ë°©ë²•:**

**1. ìƒì„±ì ì£¼ì… (Constructor Injection) - ê°€ì¥ ê¶Œì¥**
```java
interface UserRepository {
    User findById(int id);
    void save(User user);
}

class UserService {
    private final UserRepository repository;  // finalë¡œ ë¶ˆë³€ì„± ë³´ì¥

    // ìƒì„±ìë¡œ ì£¼ì…
    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }
}

// ì‚¬ìš©
UserRepository repo = new JdbcUserRepository();
UserService service = new UserService(repo);  // ì˜ì¡´ì„± ì£¼ì…
```

**2. ì„¸í„° ì£¼ì… (Setter Injection)**
```java
class UserService {
    private UserRepository repository;

    // ì„¸í„°ë¡œ ì£¼ì…
    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }
}

// ì‚¬ìš©
UserService service = new UserService();
service.setRepository(new JdbcUserRepository());  // ì˜ì¡´ì„± ì£¼ì…
```

**3. ì¸í„°í˜ì´ìŠ¤ ì£¼ì… (Interface Injection) - ì˜ ì•ˆ ì”€**
```java
interface RepositoryInjector {
    void injectRepository(UserRepository repository);
}

class UserService implements RepositoryInjector {
    private UserRepository repository;

    @Override
    public void injectRepository(UserRepository repository) {
        this.repository = repository;
    }
}
```

**ì˜ì¡´ì„± ì£¼ì… ì—†ì´ (ë‚˜ìœ ì˜ˆ):**
```java
// âŒ ê°•í•œ ê²°í•©: UserServiceê°€ JdbcUserRepositoryì— ì§ì ‘ ì˜ì¡´
class UserService {
    private JdbcUserRepository repository = new JdbcUserRepository();

    public User getUser(int id) {
        return repository.findById(id);
    }

    // ë¬¸ì œì :
    // 1. ë‹¤ë¥¸ êµ¬í˜„ì²´ë¡œ êµì²´ ë¶ˆê°€ëŠ¥
    // 2. í…ŒìŠ¤íŠ¸ ì‹œ Mock ê°ì²´ ì‚¬ìš© ë¶ˆê°€ëŠ¥
    // 3. UserServiceê°€ JdbcUserRepositoryì˜ ìƒì„± ë°©ë²•ì„ ì•Œì•„ì•¼ í•¨
}
```

**ì˜ì¡´ì„± ì£¼ì… ì‚¬ìš© (ì¢‹ì€ ì˜ˆ):**
```java
// âœ… ëŠìŠ¨í•œ ê²°í•©: ì¸í„°í˜ì´ìŠ¤ì—ë§Œ ì˜ì¡´
interface UserRepository {
    User findById(int id);
    void save(User user);
}

class UserService {
    private final UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public User getUser(int id) {
        return repository.findById(id);
    }

    // ì¥ì :
    // 1. ë‹¤ì–‘í•œ êµ¬í˜„ì²´ë¡œ êµì²´ ê°€ëŠ¥
    // 2. í…ŒìŠ¤íŠ¸ ìš©ì´
    // 3. ìœ ì—°í•œ ì„¤ê³„
}

// ë‹¤ì–‘í•œ êµ¬í˜„ì²´
class JdbcUserRepository implements UserRepository { /* JDBC êµ¬í˜„ */ }
class JpaUserRepository implements UserRepository { /* JPA êµ¬í˜„ */ }
class MongoUserRepository implements UserRepository { /* MongoDB êµ¬í˜„ */ }
class MockUserRepository implements UserRepository { /* í…ŒìŠ¤íŠ¸ìš© */ }

// ì‚¬ìš© - ëŸ°íƒ€ì„ì— êµ¬í˜„ì²´ ì„ íƒ
UserRepository repo = new JdbcUserRepository();  // í”„ë¡œë•ì…˜
// UserRepository repo = new MockUserRepository();  // í…ŒìŠ¤íŠ¸
UserService service = new UserService(repo);
```

**ì‹¤ë¬´ ì˜ˆì œ: ë‹¤ì¸µ ì•„í‚¤í…ì²˜**
```java
// === ì¸í„°í˜ì´ìŠ¤ ì •ì˜ ===

interface OrderRepository {
    Order findById(int id);
    void save(Order order);
}

interface PaymentGateway {
    boolean processPayment(Payment payment);
}

interface NotificationService {
    void sendOrderConfirmation(Order order);
}

// === êµ¬í˜„ì²´ë“¤ ===

class JdbcOrderRepository implements OrderRepository {
    @Override
    public Order findById(int id) {
        // JDBCë¡œ ì£¼ë¬¸ ì¡°íšŒ
        return null;
    }

    @Override
    public void save(Order order) {
        // JDBCë¡œ ì£¼ë¬¸ ì €ì¥
    }
}

class StripePaymentGateway implements PaymentGateway {
    @Override
    public boolean processPayment(Payment payment) {
        System.out.println("Stripeë¡œ ê²°ì œ ì²˜ë¦¬");
        return true;
    }
}

class EmailNotificationService implements NotificationService {
    @Override
    public void sendOrderConfirmation(Order order) {
        System.out.println("ì´ë©”ì¼ ë°œì†¡: ì£¼ë¬¸ í™•ì¸");
    }
}

// === ì„œë¹„ìŠ¤ ê³„ì¸µ (ì˜ì¡´ì„± ì£¼ì… ë°›ìŒ) ===

class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    private final NotificationService notificationService;

    // ìƒì„±ì ì£¼ì…
    public OrderService(
        OrderRepository orderRepository,
        PaymentGateway paymentGateway,
        NotificationService notificationService
    ) {
        this.orderRepository = orderRepository;
        this.paymentGateway = paymentGateway;
        this.notificationService = notificationService;
    }

    public boolean placeOrder(Order order, Payment payment) {
        // 1. ê²°ì œ ì²˜ë¦¬
        boolean paymentSuccess = paymentGateway.processPayment(payment);
        if (!paymentSuccess) {
            return false;
        }

        // 2. ì£¼ë¬¸ ì €ì¥
        orderRepository.save(order);

        // 3. ì•Œë¦¼ ë°œì†¡
        notificationService.sendOrderConfirmation(order);

        return true;
    }
}

// === ì‚¬ìš© (ìˆ˜ë™ DI) ===

class Main {
    public static void main(String[] args) {
        // ì˜ì¡´ì„±ë“¤ì„ ìƒì„±
        OrderRepository orderRepo = new JdbcOrderRepository();
        PaymentGateway paymentGateway = new StripePaymentGateway();
        NotificationService notificationService = new EmailNotificationService();

        // OrderServiceì— ì£¼ì…
        OrderService orderService = new OrderService(
            orderRepo,
            paymentGateway,
            notificationService
        );

        // ì‚¬ìš©
        Order order = new Order(/*...*/);
        Payment payment = new Payment(/*...*/);
        orderService.placeOrder(order, payment);
    }
}

// === í…ŒìŠ¤íŠ¸ (Mock ê°ì²´ ì‚¬ìš©) ===

class OrderServiceTest {
    @Test
    public void testPlaceOrder() {
        // Mock ê°ì²´ë“¤ ìƒì„±
        OrderRepository mockRepo = new OrderRepository() {
            @Override
            public Order findById(int id) { return null; }

            @Override
            public void save(Order order) {
                System.out.println("Mock: ì£¼ë¬¸ ì €ì¥ë¨");
            }
        };

        PaymentGateway mockPayment = payment -> {
            System.out.println("Mock: ê²°ì œ ì„±ê³µ");
            return true;
        };

        NotificationService mockNotification = order -> {
            System.out.println("Mock: ì•Œë¦¼ ë°œì†¡ë¨");
        };

        // OrderServiceì— Mock ì£¼ì…
        OrderService service = new OrderService(
            mockRepo,
            mockPayment,
            mockNotification
        );

        // í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        Order order = new Order(/*...*/);
        Payment payment = new Payment(/*...*/);
        boolean result = service.placeOrder(order, payment);

        // ê²€ì¦
        assertTrue(result);
    }
}
```

**Spring Frameworkì—ì„œì˜ DI:**
```java
// Springì˜ @Autowiredë¥¼ ì‚¬ìš©í•œ ìë™ DI
@Service
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentGateway paymentGateway;
    private final NotificationService notificationService;

    @Autowired  // Springì´ ìë™ìœ¼ë¡œ ì£¼ì…
    public OrderService(
        OrderRepository orderRepository,
        PaymentGateway paymentGateway,
        NotificationService notificationService
    ) {
        this.orderRepository = orderRepository;
        this.paymentGateway = paymentGateway;
        this.notificationService = notificationService;
    }

    // ...
}

// Bean ë“±ë¡
@Configuration
public class AppConfig {
    @Bean
    public OrderRepository orderRepository() {
        return new JdbcOrderRepository();
    }

    @Bean
    public PaymentGateway paymentGateway() {
        return new StripePaymentGateway();
    }

    @Bean
    public NotificationService notificationService() {
        return new EmailNotificationService();
    }
}
```

**ì˜ì¡´ì„± ì£¼ì…ì˜ ì¥ì :**

1. **í…ŒìŠ¤íŠ¸ ìš©ì´ì„±**
   - Mock ê°ì²´ë¡œ ì‰½ê²Œ ëŒ€ì²´ ê°€ëŠ¥
   - ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±ì´ ê°„í¸

2. **ìœ ì—°ì„±**
   - ëŸ°íƒ€ì„ì— êµ¬í˜„ì²´ êµì²´ ê°€ëŠ¥
   - ì„¤ì •ë§Œìœ¼ë¡œ ë‹¤ë¥¸ êµ¬í˜„ ì‚¬ìš© ê°€ëŠ¥

3. **ì¬ì‚¬ìš©ì„±**
   - ì»´í¬ë„ŒíŠ¸ë¥¼ ë‹¤ì–‘í•œ í™˜ê²½ì—ì„œ ì¬ì‚¬ìš©

4. **ë‹¨ì¼ ì±…ì„ ì›ì¹™**
   - ê°ì²´ ìƒì„± ì±…ì„ì´ ë¶„ë¦¬ë¨
   - ê° í´ë˜ìŠ¤ëŠ” ìì‹ ì˜ ì—­í• ì—ë§Œ ì§‘ì¤‘

5. **ê°œë°©/íì‡„ ì›ì¹™**
   - ìƒˆë¡œìš´ êµ¬í˜„ì²´ ì¶”ê°€ê°€ ì‰¬ì›€
   - ê¸°ì¡´ ì½”ë“œ ìˆ˜ì • ë¶ˆí•„ìš”

---

## ğŸ¯ ìµœì¢… ì •ë¦¬

### ì¸í„°í˜ì´ìŠ¤ í•µì‹¬ ê°œë…

1. **ì¸í„°í˜ì´ìŠ¤ëŠ” ê³„ì•½(Contract)**
   - ë¬´ì—‡ì„ í• ì§€ ì •ì˜ (howê°€ ì•„ë‹Œ what)
   - êµ¬í˜„ í´ë˜ìŠ¤ê°€ ë°˜ë“œì‹œ ì§€ì¼œì•¼ í•  ì•½ì†

2. **ë‹¤í˜•ì„±ì˜ í•µì‹¬**
   - í•˜ë‚˜ì˜ ì¸í„°í˜ì´ìŠ¤ë¡œ ì—¬ëŸ¬ êµ¬í˜„ì²´ ë‹¤ë£¨ê¸°
   - ëŸ°íƒ€ì„ì— ë™ì‘ ë³€ê²½ ê°€ëŠ¥

3. **ëŠìŠ¨í•œ ê²°í•©**
   - êµ¬ì²´ì ì¸ êµ¬í˜„ì´ ì•„ë‹Œ ì¸í„°í˜ì´ìŠ¤ì— ì˜ì¡´
   - ìœ ì—°í•˜ê³  í™•ì¥ ê°€ëŠ¥í•œ ì„¤ê³„

4. **ë‹¤ì¤‘ êµ¬í˜„**
   - ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë™ì‹œì— êµ¬í˜„ ê°€ëŠ¥
   - ëŠ¥ë ¥(capability) ì¡°í•©

### ì‹¤ë¬´ ì ìš© ê°€ì´ë“œ

1. **ì¸í„°í˜ì´ìŠ¤ íƒ€ì…ìœ¼ë¡œ ë³€ìˆ˜ ì„ ì–¸**
   ```java
   List<String> list = new ArrayList<>();  // âœ…
   ArrayList<String> list = new ArrayList<>();  // âŒ
   ```

2. **ì˜ì¡´ì„± ì£¼ì… í™œìš©**
   ```java
   class Service {
       private final Repository repo;

       public Service(Repository repo) {  // ì¸í„°í˜ì´ìŠ¤ë¡œ ë°›ê¸°
           this.repo = repo;
       }
   }
   ```

3. **ì¸í„°í˜ì´ìŠ¤ëŠ” ì‘ê³  êµ¬ì²´ì ìœ¼ë¡œ**
   - ISP (Interface Segregation Principle) ì¤€ìˆ˜
   - ì—­í• ë³„ë¡œ ë¶„ë¦¬

4. **default ë©”ì„œë“œëŠ” ì‹ ì¤‘í•˜ê²Œ**
   - í•˜ìœ„ í˜¸í™˜ì„±ì´ë‚˜ ê³µí†µ ê¸°ëŠ¥ ì œê³µì—ë§Œ ì‚¬ìš©
   - ë„ˆë¬´ ë§ìœ¼ë©´ ì¸í„°í˜ì´ìŠ¤ê°€ ë¬´ê±°ì›Œì§

ë‹¤ìŒ Chapter 20ì—ì„œëŠ” **Enum (ì—´ê±°í˜•)**ì„ ë‹¤ë£¨ê² ìŠµë‹ˆë‹¤! ğŸš€
