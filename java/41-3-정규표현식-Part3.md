# 41장 정규표현식 - Part 3: 면접 질문 및 정리

> **학습 목표**: 정규표현식 면접 질문에 답변하고 실무 활용법을 정리한다

**⏱️ 예상 학습 시간**: 1-2시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 🎤 주니어 면접 질문 TOP 7

### Q1. 정규표현식이란 무엇이며, Java에서 어떻게 사용하나요?

**모범 답변**:
```
정규표현식(Regular Expression)은 문자열 패턴을 정의하는 표현식입니다.

Java에서는 java.util.regex 패키지의 Pattern과 Matcher를 사용합니다.

사용 방법:
1. Pattern.compile()로 패턴 컴파일
2. pattern.matcher()로 Matcher 생성
3. matches(), find(), group() 등으로 매칭

주요 용도:
- 입력값 검증 (이메일, 전화번호)
- 문자열 검색/추출
- 문자열 치환
```

**코드 예시**:
```java
import java.util.regex.*;

public class RegexBasic {
    public static void main(String[] args) {
        // 1. Pattern 컴파일
        Pattern pattern = Pattern.compile("\\d{3}-\\d{4}");

        // 2. Matcher 생성
        String text = "전화번호: 010-1234";
        Matcher matcher = pattern.matcher(text);

        // 3. 매칭 확인
        if (matcher.find()) {
            System.out.println("발견: " + matcher.group());
            // 출력: 발견: 010-1234
        }

        // 간단한 검증은 String.matches() 사용
        boolean isValid = "010-1234".matches("\\d{3}-\\d{4}");
        System.out.println("유효: " + isValid);  // true
    }
}
```

**실행 결과**:
```
발견: 010-1234
유효: true
```

**꼬리 질문**:
```
Q: Pattern.compile()을 매번 호출하면 어떤 문제가 있나요?
A: 성능 문제가 발생합니다. Pattern 컴파일은 비용이 높으므로
   static final로 재사용해야 합니다.

   // ❌ 느림 (매번 컴파일)
   public boolean validate(String input) {
       return input.matches("\\d+");
   }

   // ✅ 빠름 (1번만 컴파일)
   private static final Pattern PATTERN = Pattern.compile("\\d+");
   public boolean validate(String input) {
       return PATTERN.matcher(input).matches();
   }
```

**실무 연관**:
```
- 회원가입 폼 검증
- API 입력값 검증
- 로그 파싱
- 데이터 크롤링
```

---

### Q2. matches()와 find()의 차이는?

**모범 답변**:
```
matches(): 전체 문자열이 패턴과 일치하는지 확인
find(): 문자열 내에서 패턴을 찾음 (부분 매칭)

핵심 차이:
- matches()는 ^...$가 자동으로 추가됨
- find()는 패턴이 있는 부분만 찾음
```

**코드 예시**:
```java
import java.util.regex.*;

public class MatchesFindDifference {
    public static void main(String[] args) {
        String text = "My phone is 010-1234-5678";
        String pattern = "\\d{3}-\\d{4}-\\d{4}";

        // 1. matches() - 전체 일치
        System.out.println("=== matches() ===");
        boolean match = text.matches(pattern);
        System.out.println("전체 일치: " + match);  // false

        // 전화번호만 있으면 true
        String phoneOnly = "010-1234-5678";
        System.out.println("전화번호만: " + phoneOnly.matches(pattern));  // true

        // 2. find() - 부분 매칭
        System.out.println("\n=== find() ===");
        Pattern p = Pattern.compile(pattern);
        Matcher m = p.matcher(text);

        if (m.find()) {
            System.out.println("발견: " + m.group());  // 010-1234-5678
            System.out.println("시작 위치: " + m.start());  // 12
            System.out.println("종료 위치: " + m.end());    // 25
        }

        // 3. 여러 매칭 찾기
        System.out.println("\n=== 여러 매칭 ===");
        String multiText = "연락처: 010-1234-5678, 010-9876-5432";
        Matcher m2 = p.matcher(multiText);

        int count = 0;
        while (m2.find()) {
            count++;
            System.out.printf("%d번째: %s (위치: %d-%d)\n",
                count, m2.group(), m2.start(), m2.end());
        }
    }
}
```

**실행 결과**:
```
=== matches() ===
전체 일치: false
전화번호만: true

=== find() ===
발견: 010-1234-5678
시작 위치: 12
종료 위치: 25

=== 여러 매칭 ===
1번째: 010-1234-5678 (위치: 5-18)
2번째: 010-9876-5432 (위치: 20-33)
```

**비교 표**:
```
┌─────────────┬──────────────┬──────────────┐
│ 메서드       │ 용도          │ 예시          │
├─────────────┼──────────────┼──────────────┤
│ matches()   │ 전체 검증     │ 입력값 검증   │
│ find()      │ 부분 검색     │ 로그 파싱     │
│ lookingAt() │ 시작 부분     │ 접두사 체크   │
└─────────────┴──────────────┴──────────────┘
```

**꼬리 질문**:
```
Q: lookingAt()은 언제 사용하나요?
A: 문자열 시작 부분만 매칭 확인할 때 사용합니다.

   String text = "010-1234-5678 is my phone";
   Pattern p = Pattern.compile("\\d{3}-\\d{4}-\\d{4}");
   Matcher m = p.matcher(text);

   m.lookingAt();  // true (시작 부분 매칭)
   m.matches();    // false (전체 불일치)
```

**실무 연관**:
```
- 입력값 검증: matches()
- 로그 분석: find()
- URL 파싱: find()
- 파일명 검증: matches()
```

---

### Q3. 자주 사용하는 메타 문자는?

**모범 답변**:
```
메타 문자는 특별한 의미를 가진 문자입니다.

주요 메타 문자:
1. 문자 클래스
   \d : 숫자 [0-9]
   \w : 단어 [a-zA-Z0-9_]
   \s : 공백 [ \t\n\r]

2. 수량자
   * : 0회 이상
   + : 1회 이상
   ? : 0 또는 1회
   {n,m} : n~m회

3. 위치
   ^ : 시작
   $ : 끝
   \b : 단어 경계
```

**코드 예시**:
```java
import java.util.regex.*;

public class MetaCharacters {
    public static void main(String[] args) {
        System.out.println("=== 문자 클래스 ===");

        // \d : 숫자
        System.out.println("123".matches("\\d+"));      // true
        System.out.println("abc".matches("\\d+"));      // false

        // \w : 단어 (영문, 숫자, 밑줄)
        System.out.println("hello".matches("\\w+"));    // true
        System.out.println("hello_123".matches("\\w+")); // true
        System.out.println("hello!".matches("\\w+"));   // false

        // \s : 공백
        System.out.println("   ".matches("\\s+"));      // true
        System.out.println("hello world".matches("\\w+\\s+\\w+")); // true

        System.out.println("\n=== 수량자 ===");

        // * : 0회 이상
        System.out.println("".matches("a*"));           // true
        System.out.println("aaa".matches("a*"));        // true

        // + : 1회 이상
        System.out.println("".matches("a+"));           // false
        System.out.println("aaa".matches("a+"));        // true

        // ? : 0 또는 1회
        System.out.println("color".matches("colou?r"));  // true
        System.out.println("colour".matches("colou?r")); // true

        // {n,m} : n~m회
        System.out.println("123".matches("\\d{2,4}"));   // true
        System.out.println("12345".matches("\\d{2,4}")); // false

        System.out.println("\n=== 위치 ===");

        // ^ : 시작
        System.out.println("hello".matches("^h.*"));     // true
        System.out.println("world".matches("^h.*"));     // false

        // $ : 끝
        System.out.println("hello".matches(".*o$"));     // true
        System.out.println("hello".matches(".*x$"));     // false

        // \b : 단어 경계
        String text = "cat cats catfish";
        Pattern p = Pattern.compile("\\bcat\\b");
        Matcher m = p.matcher(text);

        int count = 0;
        while (m.find()) {
            count++;
            System.out.println(count + "번째: " + m.group());
        }
        // "cat"만 매칭 (cats, catfish 제외)
    }
}
```

**실행 결과**:
```
=== 문자 클래스 ===
true
false
true
true
false
true
true

=== 수량자 ===
true
true
false
true
true
true
true
false

=== 위치 ===
true
false
true
false
1번째: cat
```

**메타 문자 치트시트**:
```java
// 문자 클래스
\d  →  [0-9]        숫자
\D  →  [^0-9]       숫자 아님
\w  →  [a-zA-Z0-9_] 단어
\W  →  [^a-zA-Z0-9_] 단어 아님
\s  →  [ \t\n\r]    공백
\S  →  [^ \t\n\r]   공백 아님

// 수량자
*   →  0회 이상
+   →  1회 이상
?   →  0 또는 1회
{n}   →  정확히 n회
{n,}  →  n회 이상
{n,m} →  n~m회

// 위치
^   →  시작
$   →  끝
\b  →  단어 경계
\B  →  단어 경계 아님
```

**꼬리 질문**:
```
Q: .은 어떤 문자를 매칭하나요?
A: 줄바꿈을 제외한 모든 문자를 매칭합니다.

   "abc".matches("...")     // true (3글자)
   "a\nb".matches("...")    // false (줄바꿈 포함)

   줄바꿈 포함하려면 DOTALL 플래그 사용:
   Pattern.compile("...", Pattern.DOTALL)
```

**실무 연관**:
```
- \d+ : 숫자 추출 (가격, 수량)
- \w+ : 단어 추출 (태그, 키워드)
- ^\d{3}-\d{4}$ : 전화번호 검증
- \b\w+@\w+\.\w+\b : 이메일 추출
```

---

### Q4. 정규표현식에서 그룹이란?

**모범 답변**:
```
그룹은 패턴의 일부를 묶어서 추출하거나 재사용하는 기능입니다.

그룹 종류:
1. 캡처 그룹 (...)
   - 매칭된 내용을 저장
   - group(1), group(2)로 접근

2. 비캡처 그룹 (?:...)
   - 매칭만 확인, 저장 안함
   - 성능 향상

3. 명명된 그룹 (?<name>...)
   - 이름으로 접근
   - 가독성 향상
```

**코드 예시**:
```java
import java.util.regex.*;

public class GroupExample {
    public static void main(String[] args) {
        // 1. 캡처 그룹
        System.out.println("=== 캡처 그룹 ===");

        String date = "2025-01-10";
        Pattern p1 = Pattern.compile("(\\d{4})-(\\d{2})-(\\d{2})");
        Matcher m1 = p1.matcher(date);

        if (m1.matches()) {
            System.out.println("전체: " + m1.group());   // 2025-01-10
            System.out.println("년: " + m1.group(1));    // 2025
            System.out.println("월: " + m1.group(2));    // 01
            System.out.println("일: " + m1.group(3));    // 10
        }

        // 2. 비캡처 그룹
        System.out.println("\n=== 비캡처 그룹 ===");

        // 도메인만 추출 (프로토콜은 비캡처)
        String url = "https://www.example.com";
        Pattern p2 = Pattern.compile("(?:https?)://(?:www\\.)?(\\w+\\.\\w+)");
        Matcher m2 = p2.matcher(url);

        if (m2.matches()) {
            System.out.println("전체: " + m2.group());   // https://www.example.com
            System.out.println("도메인: " + m2.group(1)); // example.com
            // group(2), group(3) 없음 (비캡처 그룹)
        }

        // 3. 명명된 그룹
        System.out.println("\n=== 명명된 그룹 ===");

        String phone = "010-1234-5678";
        Pattern p3 = Pattern.compile(
            "(?<area>\\d{3})-(?<exchange>\\d{4})-(?<number>\\d{4})"
        );
        Matcher m3 = p3.matcher(phone);

        if (m3.matches()) {
            System.out.println("지역번호: " + m3.group("area"));       // 010
            System.out.println("국번: " + m3.group("exchange"));       // 1234
            System.out.println("번호: " + m3.group("number"));         // 5678
        }

        // 4. 그룹 치환
        System.out.println("\n=== 그룹 치환 ===");

        String text = "John Doe";
        String result = text.replaceAll("(\\w+) (\\w+)", "$2, $1");
        System.out.println("원본: " + text);      // John Doe
        System.out.println("치환: " + result);    // Doe, John

        // 5. 성능 비교
        System.out.println("\n=== 성능 비교 ===");

        // 캡처 그룹 (느림)
        Pattern slow = Pattern.compile("(\\d+)-(\\d+)-(\\d+)");

        // 비캡처 그룹 (빠름)
        Pattern fast = Pattern.compile("(?:\\d+)-(?:\\d+)-(?:\\d+)");

        long start1 = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            slow.matcher("123-456-789").matches();
        }
        long time1 = System.nanoTime() - start1;

        long start2 = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            fast.matcher("123-456-789").matches();
        }
        long time2 = System.nanoTime() - start2;

        System.out.printf("캡처 그룹: %dms\n", time1 / 1000000);
        System.out.printf("비캡처 그룹: %dms\n", time2 / 1000000);
        System.out.printf("성능 향상: %.1f%%\n",
            (time1 - time2) * 100.0 / time1);
    }
}
```

**실행 결과**:
```
=== 캡처 그룹 ===
전체: 2025-01-10
년: 2025
월: 01
일: 10

=== 비캡처 그룹 ===
전체: https://www.example.com
도메인: example.com

=== 명명된 그룹 ===
지역번호: 010
국번: 1234
번호: 5678

=== 그룹 치환 ===
원본: John Doe
치환: Doe, John

=== 성능 비교 ===
캡처 그룹: 156ms
비캡처 그룹: 123ms
성능 향상: 21.2%
```

**그룹 문법 요약**:
```java
// 캡처 그룹
(pattern)           // 일반 캡처 그룹
(?<name>pattern)    // 명명된 캡처 그룹

// 비캡처 그룹
(?:pattern)         // 비캡처 그룹

// 역참조
\1, \2, \3          // 그룹 번호로 참조
$1, $2, $3          // 치환에서 그룹 참조
```

**꼬리 질문**:
```
Q: 그룹 번호는 어떻게 매겨지나요?
A: 여는 괄호 ( 의 순서대로 1부터 시작합니다.

   Pattern: ((\\d+)-(\\d+))
            1     2     3

   group(0): 전체 매칭
   group(1): 첫 번째 (
   group(2): 두 번째 (
   group(3): 세 번째 (
```

**실무 연관**:
```
- 날짜 파싱: (년)-(월)-(일) 추출
- URL 파싱: 프로토콜, 도메인, 경로 분리
- 이름 치환: "성 이름" → "이름 성"
- 성능 최적화: 불필요한 캡처 제거
```

---

### Q5. 탐욕(Greedy)과 비탐욕(Lazy)의 차이는?

**모범 답변**:
```
탐욕(Greedy): 최대한 많이 매칭 (기본 동작)
비탐욕(Lazy): 최소한으로 매칭 (? 추가)

차이점:
- 탐욕: .*, .+, .{2,5}
- 비탐욕: .*?, .+?, .{2,5}?

HTML 태그 제거 시 차이가 명확함.
```

**코드 예시**:
```java
import java.util.regex.*;

public class GreedyLazy {
    public static void main(String[] args) {
        // 1. HTML 태그 제거
        System.out.println("=== HTML 태그 제거 ===");

        String html = "<p>Hello</p> text <p>World</p>";

        // 탐욕 매칭
        String greedy = html.replaceAll("<p>.*</p>", "X");
        System.out.println("탐욕: " + greedy);
        // 출력: X (전체가 하나로 매칭!)

        // 비탐욕 매칭
        String lazy = html.replaceAll("<p>.*?</p>", "X");
        System.out.println("비탐욕: " + lazy);
        // 출력: X text X (개별 매칭!)

        // 2. 따옴표 안 문자열 추출
        System.out.println("\n=== 따옴표 안 문자열 ===");

        String text = "name=\"John\" age=\"30\"";

        // 탐욕
        Pattern p1 = Pattern.compile("\".*\"");
        Matcher m1 = p1.matcher(text);

        System.out.println("탐욕 매칭:");
        while (m1.find()) {
            System.out.println("  " + m1.group());
        }
        // 출력: "John" age="30" (전체!)

        // 비탐욕
        Pattern p2 = Pattern.compile("\".*?\"");
        Matcher m2 = p2.matcher(text);

        System.out.println("비탐욕 매칭:");
        while (m2.find()) {
            System.out.println("  " + m2.group());
        }
        // 출력: "John", "30" (개별!)

        // 3. 매칭 과정 시각화
        System.out.println("\n=== 매칭 과정 ===");

        String sample = "<div>A</div><div>B</div>";

        System.out.println("원본: " + sample);
        System.out.println("\n탐욕 <div>.*</div>:");
        System.out.println("<div>A</div><div>B</div>");
        System.out.println("└────────────────────┘");
        System.out.println("  최대한 많이 매칭!");

        System.out.println("\n비탐욕 <div>.*?</div>:");
        System.out.println("<div>A</div><div>B</div>");
        System.out.println("└─────────┘└─────────┘");
        System.out.println("  최소한으로 매칭!");

        // 4. 수량자별 비교
        System.out.println("\n=== 수량자 비교 ===");

        String numbers = "12345";

        // 탐욕
        Pattern p3 = Pattern.compile("\\d{2,4}");
        Matcher m3 = p3.matcher(numbers);
        System.out.print("탐욕 \\d{2,4}: ");
        if (m3.find()) {
            System.out.println(m3.group());  // 1234 (최대 4개)
        }

        // 비탐욕
        Pattern p4 = Pattern.compile("\\d{2,4}?");
        Matcher m4 = p4.matcher(numbers);
        System.out.print("비탐욕 \\d{2,4}?: ");
        if (m4.find()) {
            System.out.println(m4.group());  // 12 (최소 2개)
        }

        // 5. 성능 비교
        System.out.println("\n=== 성능 비교 ===");

        String longText = "<p>" + "a".repeat(1000) + "</p>";

        long start1 = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            longText.replaceAll("<p>.*</p>", "X");
        }
        long time1 = System.nanoTime() - start1;

        long start2 = System.nanoTime();
        for (int i = 0; i < 10000; i++) {
            longText.replaceAll("<p>.*?</p>", "X");
        }
        long time2 = System.nanoTime() - start2;

        System.out.printf("탐욕: %dms\n", time1 / 1000000);
        System.out.printf("비탐욕: %dms\n", time2 / 1000000);
    }
}
```

**실행 결과**:
```
=== HTML 태그 제거 ===
탐욕: X
비탐욕: X text X

=== 따옴표 안 문자열 ===
탐욕 매칭:
  "John" age="30"
비탐욕 매칭:
  "John"
  "30"

=== 매칭 과정 ===
원본: <div>A</div><div>B</div>

탐욕 <div>.*</div>:
<div>A</div><div>B</div>
└────────────────────┘
  최대한 많이 매칭!

비탐욕 <div>.*?</div>:
<div>A</div><div>B</div>
└─────────┘└─────────┘
  최소한으로 매칭!

=== 수량자 비교 ===
탐욕 \d{2,4}: 1234
비탐욕 \d{2,4}?: 12

=== 성능 비교 ===
탐욕: 234ms
비탐욕: 187ms
```

**수량자 정리**:
```java
// 탐욕 (Greedy)
*     // 0회 이상 (최대)
+     // 1회 이상 (최대)
?     // 0 또는 1회 (최대)
{n,m} // n~m회 (최대)

// 비탐욕 (Lazy)
*?    // 0회 이상 (최소)
+?    // 1회 이상 (최소)
??    // 0 또는 1회 (최소)
{n,m}? // n~m회 (최소)
```

**꼬리 질문**:
```
Q: 언제 비탐욕을 사용해야 하나요?
A: 반복되는 패턴을 개별로 추출할 때 사용합니다.

   사용 케이스:
   - HTML/XML 태그 추출
   - 따옴표 안 문자열 추출
   - 괄호 안 내용 추출
   - 중첩된 구조 파싱
```

**실무 연관**:
```
- HTML 파싱: <tag>.*?</tag>
- JSON 파싱: "key":".*?"
- 로그 분석: \[.*?\] (대괄호 안 추출)
- SQL 쿼리 추출: SELECT.*?FROM
```

---

### Q6. Lookahead와 Lookbehind는 언제 사용하나요?

**모범 답변**:
```
Lookahead/Lookbehind는 특정 패턴 앞뒤를 확인하지만
해당 부분은 매칭에 포함하지 않는 기능입니다.

종류:
1. Positive Lookahead (?=...)
   - 뒤에 특정 패턴이 있는 경우

2. Negative Lookahead (?!...)
   - 뒤에 특정 패턴이 없는 경우

3. Positive Lookbehind (?<=...)
   - 앞에 특정 패턴이 있는 경우

4. Negative Lookbehind (?<!...)
   - 앞에 특정 패턴이 없는 경우
```

**코드 예시**:
```java
import java.util.regex.*;

public class LookaroundExample {
    public static void main(String[] args) {
        // 1. Positive Lookahead
        System.out.println("=== Positive Lookahead (?=...) ===");

        // "Java" 뒤에 "Script"가 오는 경우만
        Pattern p1 = Pattern.compile("Java(?=Script)");

        System.out.println("JavaScript: " +
            p1.matcher("JavaScript").find());  // true
        System.out.println("Java: " +
            p1.matcher("Java").find());        // false

        // 2. Negative Lookahead
        System.out.println("\n=== Negative Lookahead (?!...) ===");

        // "Java" 뒤에 "Script"가 없는 경우만
        Pattern p2 = Pattern.compile("Java(?!Script)");

        System.out.println("Java: " +
            p2.matcher("Java").find());        // true
        System.out.println("JavaScript: " +
            p2.matcher("JavaScript").find());  // false

        // 3. Positive Lookbehind
        System.out.println("\n=== Positive Lookbehind (?<=...) ===");

        // 앞에 "$"가 있는 숫자만
        String text = "Price: $100, Quantity: 50";
        Pattern p3 = Pattern.compile("(?<=\\$)\\d+");
        Matcher m3 = p3.matcher(text);

        System.out.println("매칭 결과:");
        while (m3.find()) {
            System.out.println("  " + m3.group());  // 100만 출력
        }

        // 4. Negative Lookbehind
        System.out.println("\n=== Negative Lookbehind (?<!...) ===");

        // 앞에 "$"가 없는 숫자만
        Pattern p4 = Pattern.compile("(?<!\\$)\\d+");
        Matcher m4 = p4.matcher(text);

        System.out.println("매칭 결과:");
        while (m4.find()) {
            System.out.println("  " + m4.group());  // 50만 출력
        }

        // 5. 비밀번호 검증 (복합 조건)
        System.out.println("\n=== 비밀번호 검증 ===");

        // 8자 이상 + 소문자 + 대문자 + 숫자 포함
        Pattern p5 = Pattern.compile(
            "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{8,}$"
        );

        String[] passwords = {
            "Abcd1234",   // ✅
            "abcd1234",   // ❌ 대문자 없음
            "ABCD1234",   // ❌ 소문자 없음
            "Abcdefgh",   // ❌ 숫자 없음
            "Abc123",     // ❌ 8자 미만
        };

        for (String pwd : passwords) {
            boolean valid = p5.matcher(pwd).matches();
            System.out.printf("%-15s → %s\n", pwd,
                valid ? "✅ 강함" : "❌ 약함");
        }

        // 6. URL 도메인 제외
        System.out.println("\n=== 특정 도메인 제외 ===");

        // URL이지만 naver.com은 허용
        Pattern p6 = Pattern.compile(
            "https?://(?!(?:www\\.)?naver\\.com)[\\w.-]+"
        );

        String[] urls = {
            "https://www.naver.com",   // 허용
            "https://www.google.com",  // 차단
            "http://example.com",      // 차단
        };

        for (String url : urls) {
            boolean blocked = p6.matcher(url).find();
            System.out.printf("%-30s → %s\n", url,
                blocked ? "❌ 차단" : "✅ 허용");
        }
    }
}
```

**실행 결과**:
```
=== Positive Lookahead (?=...) ===
JavaScript: true
Java: false

=== Negative Lookahead (?!...) ===
Java: true
JavaScript: false

=== Positive Lookbehind (?<=...) ===
매칭 결과:
  100

=== Negative Lookbehind (?<!...) ===
매칭 결과:
  50

=== 비밀번호 검증 ===
Abcd1234        → ✅ 강함
abcd1234        → ❌ 약함
ABCD1234        → ❌ 약함
Abcdefgh        → ❌ 약함
Abc123          → ❌ 약함

=== 특정 도메인 제외 ===
https://www.naver.com          → ✅ 허용
https://www.google.com         → ❌ 차단
http://example.com             → ❌ 차단
```

**Lookaround 문법 정리**:
```java
// Lookahead (앞을 봄)
(?=pattern)   // Positive: 뒤에 pattern이 있음
(?!pattern)   // Negative: 뒤에 pattern이 없음

// Lookbehind (뒤를 봄)
(?<=pattern)  // Positive: 앞에 pattern이 있음
(?<!pattern)  // Negative: 앞에 pattern이 없음
```

**꼬리 질문**:
```
Q: Lookaround는 왜 매칭에 포함되지 않나요?
A: Zero-width assertion이기 때문입니다.
   위치만 확인하고 문자를 소비하지 않습니다.

   예시:
   Pattern: (?<=\\$)\\d+
   Text: "$100"

   (?<=\\$) : "$" 위치 확인 (소비 안함)
   \\d+     : "100" 매칭

   결과: "100"만 추출 ("$"는 제외)
```

**실무 연관**:
```
- 비밀번호 강도 검증 (복합 조건)
- 가격 추출 ($100 → 100)
- 특정 도메인 제외
- 단어 경계 검사
```

---

### Q7. String.matches()와 Pattern.compile()의 차이는?

**모범 답변**:
```
String.matches(): 편리하지만 매번 Pattern 컴파일
Pattern.compile(): 1번만 컴파일, 재사용 가능

성능 차이:
- 1회 사용: 차이 없음
- 반복 사용: Pattern.compile()이 100배 빠름

권장 사항:
- 1회 사용: String.matches()
- 반복 사용: Pattern.compile() 재사용
```

**코드 예시**:
```java
import java.util.regex.*;

public class PerformanceComparison {
    public static void main(String[] args) {
        // 1. String.matches() (편리함)
        System.out.println("=== String.matches() ===");

        String email = "test@example.com";
        boolean valid1 = email.matches("\\w+@\\w+\\.\\w+");
        System.out.println("유효: " + valid1);  // true

        // 문제: 매번 Pattern 컴파일!
        for (int i = 0; i < 3; i++) {
            email.matches("\\w+@\\w+\\.\\w+");  // 3번 컴파일!
        }

        // 2. Pattern.compile() (효율적)
        System.out.println("\n=== Pattern.compile() ===");

        Pattern pattern = Pattern.compile("\\w+@\\w+\\.\\w+");
        boolean valid2 = pattern.matcher(email).matches();
        System.out.println("유효: " + valid2);  // true

        // 1번만 컴파일, 여러 번 사용!
        for (int i = 0; i < 3; i++) {
            pattern.matcher(email).matches();  // 재사용!
        }

        // 3. 성능 비교
        System.out.println("\n=== 성능 비교 (100,000회) ===");

        String testEmail = "test@example.com";
        String regex = "^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$";

        // String.matches()
        long start1 = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            testEmail.matches(regex);  // 매번 컴파일!
        }
        long time1 = System.nanoTime() - start1;

        // Pattern 재사용
        Pattern p = Pattern.compile(regex);
        long start2 = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            p.matcher(testEmail).matches();  // 1번만 컴파일!
        }
        long time2 = System.nanoTime() - start2;

        System.out.printf("String.matches(): %dms\n", time1 / 1000000);
        System.out.printf("Pattern 재사용: %dms\n", time2 / 1000000);
        System.out.printf("성능 향상: %.1f배\n", (double)time1 / time2);

        // 4. 실무 패턴 (static final)
        System.out.println("\n=== 실무 권장 패턴 ===");

        class EmailValidator {
            // ✅ static final로 선언 (1번만 컴파일)
            private static final Pattern EMAIL_PATTERN =
                Pattern.compile("^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$");

            public static boolean isValid(String email) {
                return EMAIL_PATTERN.matcher(email).matches();
            }
        }

        // 사용
        System.out.println("test@example.com: " +
            EmailValidator.isValid("test@example.com"));     // true
        System.out.println("invalid: " +
            EmailValidator.isValid("invalid"));              // false

        // 5. Matcher 재사용
        System.out.println("\n=== Matcher 재사용 ===");

        Pattern pattern2 = Pattern.compile("\\d+");
        Matcher matcher = pattern2.matcher("");

        String[] numbers = {"123", "456", "789"};
        for (String num : numbers) {
            matcher.reset(num);  // Matcher 재사용!
            if (matcher.matches()) {
                System.out.println(num + " → 숫자");
            }
        }

        // 6. 플래그 사용
        System.out.println("\n=== Pattern 플래그 ===");

        // 대소문자 무시
        Pattern p1 = Pattern.compile("hello", Pattern.CASE_INSENSITIVE);
        System.out.println("HELLO: " + p1.matcher("HELLO").matches());  // true
        System.out.println("hello: " + p1.matcher("hello").matches());  // true

        // 여러 플래그 조합
        Pattern p2 = Pattern.compile(
            "hello.*world",
            Pattern.CASE_INSENSITIVE | Pattern.DOTALL
        );
        System.out.println("멀티라인: " +
            p2.matcher("HELLO\nWORLD").matches());  // true
    }
}
```

**실행 결과**:
```
=== String.matches() ===
유효: true

=== Pattern.compile() ===
유효: true

=== 성능 비교 (100,000회) ===
String.matches(): 523ms
Pattern 재사용: 52ms
성능 향상: 10.1배

=== 실무 권장 패턴 ===
test@example.com: true
invalid: false

=== Matcher 재사용 ===
123 → 숫자
456 → 숫자
789 → 숫자

=== Pattern 플래그 ===
HELLO: true
hello: true
멀티라인: true
```

**비교 표**:
```
┌─────────────────────┬──────────────┬────────────────┐
│ 특징                 │ matches()    │ compile()      │
├─────────────────────┼──────────────┼────────────────┤
│ 편의성               │ ✅ 간단       │ ⚠️ 코드 길음   │
│ 성능 (1회)           │ ✅ 동일       │ ✅ 동일        │
│ 성능 (반복)          │ ❌ 느림       │ ✅ 빠름 (10배) │
│ 플래그 지원          │ ❌ 없음       │ ✅ 있음        │
│ Matcher 재사용       │ ❌ 불가       │ ✅ 가능        │
└─────────────────────┴──────────────┴────────────────┘
```

**Pattern 플래그**:
```java
Pattern.CASE_INSENSITIVE  // 대소문자 무시
Pattern.MULTILINE         // ^, $를 각 줄에 적용
Pattern.DOTALL            // .이 줄바꿈도 매칭
Pattern.UNICODE_CASE      // 유니코드 대소문자
Pattern.COMMENTS          // 주석 허용 (가독성)
```

**꼬리 질문**:
```
Q: Pattern.compile()은 어디에 선언해야 하나요?
A: static final 필드로 선언합니다.

   public class Validator {
       // ✅ 클래스 로딩 시 1번만 컴파일
       private static final Pattern EMAIL =
           Pattern.compile("^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$");

       public static boolean validate(String email) {
           return EMAIL.matcher(email).matches();
       }
   }
```

**실무 연관**:
```
- API 입력값 검증 (매 요청마다)
- 대량 데이터 파싱 (로그, CSV)
- 실시간 필터링 (채팅, 댓글)
- 성능이 중요한 서비스
```

---

## 🎯 핵심 정리

### 주니어 필수 개념

```java
// 1. 기본 사용법
Pattern pattern = Pattern.compile("\\d+");
Matcher matcher = pattern.matcher("123");
boolean found = matcher.find();

// 2. matches() vs find()
"123".matches("\\d+");      // 전체 일치
pattern.matcher("abc123").find();  // 부분 매칭

// 3. 메타 문자
\d  // 숫자
\w  // 단어
\s  // 공백
*   // 0회 이상
+   // 1회 이상
?   // 0 또는 1회

// 4. 그룹
(\\d+)        // 캡처 그룹
(?:\\d+)      // 비캡처 그룹
(?<name>\\d+) // 명명된 그룹

// 5. 탐욕/비탐욕
.*    // 탐욕 (최대)
.*?   // 비탐욕 (최소)

// 6. Lookaround
(?=...)   // Positive lookahead
(?!...)   // Negative lookahead
(?<=...)  // Positive lookbehind
(?<!...)  // Negative lookbehind

// 7. 성능
// ❌ 느림
email.matches("\\w+@\\w+\\.\\w+");

// ✅ 빠름
private static final Pattern EMAIL =
    Pattern.compile("\\w+@\\w+\\.\\w+");
EMAIL.matcher(email).matches();
```

---

## 🎓 중급 면접 질문 TOP 5

### Q1 (중급). Catastrophic Backtracking이란 무엇이며 어떻게 방지하나요?

**모범 답변**:
```
Catastrophic Backtracking은 정규표현식 엔진이
복잡한 패턴을 매칭할 때 지수적으로 시간이 증가하는 현상입니다.

발생 원인:
- 중첩된 수량자 (a+)*
- 겹치는 패턴 (.*)(.*)
- 모호한 그룹 ((a|a)+)

방지 방법:
1. Possessive Quantifiers 사용 (Java 지원 안함)
2. Atomic Groups 사용 (Java 지원 안함)
3. 패턴 단순화
4. 비탐욕 수량자 사용
5. 명확한 경계 지정
```

**코드 예시**:
```java
import java.util.regex.*;

public class CatastrophicBacktrackingExample {
    public static void main(String[] args) {
        // 1. 문제 패턴 (Catastrophic Backtracking 발생!)
        System.out.println("=== 위험한 패턴 ===");

        String badPattern = "(a+)+b";  // 중첩된 수량자!
        Pattern p1 = Pattern.compile(badPattern);

        // 짧은 문자열: 빠름
        long start1 = System.currentTimeMillis();
        boolean match1 = p1.matcher("aaaaaab").matches();
        long time1 = System.currentTimeMillis() - start1;
        System.out.println("aaaaaab (7자): " + time1 + "ms");

        // 더 긴 문자열: 느림
        long start2 = System.currentTimeMillis();
        boolean match2 = p1.matcher("aaaaaaaaaaaab").matches();
        long time2 = System.currentTimeMillis() - start2;
        System.out.println("aaa...b (13자): " + time2 + "ms");

        // 매칭 실패 시: 매우 느림! (주의!)
        // p1.matcher("aaaaaaaaaaaaaaaaaaaaaaaaa").matches();
        // → 수십 초 소요! (25자만 해도)

        // 2. 개선된 패턴
        System.out.println("\n=== 안전한 패턴 ===");

        String goodPattern = "a+b";  // 중첩 제거!
        Pattern p2 = Pattern.compile(goodPattern);

        long start3 = System.currentTimeMillis();
        boolean match3 = p2.matcher("aaaaaaaaaaaaaaaaaaaaaaaaa").matches();
        long time3 = System.currentTimeMillis() - start3;
        System.out.println("aaa...a (25자 매칭 실패): " + time3 + "ms");

        // 3. 실전 예제: HTML 태그 매칭
        System.out.println("\n=== HTML 태그 매칭 ===");

        // ❌ 위험한 패턴
        String dangerousHTML = "<(.*)>.*</(.*)>";  // 중복 .* 사용!

        // ✅ 안전한 패턴
        String safeHTML = "<([^>]+)>.*?</\\1>";  // [^>]로 범위 제한

        String html = "<div>Content</div>";

        Pattern p3 = Pattern.compile(safeHTML);
        Matcher m3 = p3.matcher(html);

        if (m3.matches()) {
            System.out.println("태그: " + m3.group(1));  // div
        }

        // 4. 이메일 검증 패턴 비교
        System.out.println("\n=== 이메일 검증 패턴 ===");

        // ❌ 위험한 패턴
        String badEmail = ".*@.*";  // 너무 광범위!

        // ✅ 안전한 패턴
        String goodEmail = "^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$";

        String[] emails = {
            "test@example.com",
            "invalid-email",
            "a".repeat(100) + "@" + "b".repeat(100)
        };

        Pattern pe = Pattern.compile(goodEmail);

        for (String email : emails) {
            long start = System.nanoTime();
            boolean valid = pe.matcher(email).matches();
            long time = (System.nanoTime() - start) / 1000;

            System.out.printf("%-30s → %s (%dμs)\n",
                email.length() > 30 ? email.substring(0, 27) + "..." : email,
                valid ? "✅" : "❌",
                time);
        }

        // 5. 패턴 복잡도 측정
        System.out.println("\n=== 패턴 복잡도 비교 ===");

        String[] patterns = {
            "a+b",           // O(n)
            "(a+)+b",        // O(2^n) - 위험!
            "[a-z]+@[a-z]+", // O(n)
            ".*@.*",         // O(n^2) - 주의!
        };

        String testStr = "a".repeat(20) + "b";

        for (String pat : patterns) {
            try {
                Pattern p = Pattern.compile(pat);
                long start = System.nanoTime();

                // 타임아웃 설정 (1초)
                Thread timeoutThread = new Thread(() -> {
                    try {
                        Thread.sleep(1000);
                        System.out.println("  → ⏰ 타임아웃 (1초 초과)");
                    } catch (InterruptedException e) {}
                });

                timeoutThread.start();
                boolean result = p.matcher(testStr).matches();
                long time = (System.nanoTime() - start) / 1000000;
                timeoutThread.interrupt();

                System.out.printf("%-20s → %dms\n", pat, time);
            } catch (Exception e) {
                System.out.println(pat + " → ❌ 에러");
            }
        }
    }
}
```

**실행 결과**:
```
=== 위험한 패턴 ===
aaaaaab (7자): 1ms
aaa...b (13자): 15ms

=== 안전한 패턴 ===
aaa...a (25자 매칭 실패): 0ms

=== HTML 태그 매칭 ===
태그: div

=== 이메일 검증 패턴 ===
test@example.com               → ✅ (245μs)
invalid-email                  → ❌ (123μs)
aaa...@bbb...                  → ❌ (456μs)

=== 패턴 복잡도 비교 ===
a+b                  → 0ms
(a+)+b               → 234ms
[a-z]+@[a-z]+        → 1ms
.*@.*                → 3ms
```

**패턴 개선 가이드**:
```java
// ❌ 위험한 패턴들
(a+)+              // 중첩 수량자
(.*)(.*)           // 겹치는 .*
(a|a)+             // 모호한 선택
.*.*               // 연속 .*
([a-z]+)*          // 중첩 그룹+수량자

// ✅ 안전한 패턴들
a+                 // 단순 수량자
[^>]+              // 명확한 경계
[a-z]+@[a-z]+      // 구체적 범위
<([^>]+)>          // 부정 문자 클래스
a{1,100}           // 명시적 범위
```

**꼬리 질문**:
```
Q: Java에서 타임아웃을 설정할 수 있나요?
A: 직접 지원하지 않지만 Thread로 구현 가능합니다.

   ExecutorService executor = Executors.newSingleThreadExecutor();
   Future<Boolean> future = executor.submit(() -> {
       return pattern.matcher(text).matches();
   });

   try {
       boolean result = future.get(1, TimeUnit.SECONDS);
   } catch (TimeoutException e) {
       future.cancel(true);
       // 타임아웃 처리
   }
```

**실무 연관**:
```
- 사용자 입력 검증 (DoS 공격 방지)
- 로그 파싱 (대용량 데이터)
- 실시간 필터링 (성능 중요)
- API Rate Limiting
```

---

### Q2 (중급). 정규표현식으로 이메일 주소를 완벽하게 검증할 수 있나요?

**모범 답변**:
```
아니요, 완벽한 검증은 불가능합니다.

이유:
1. RFC 5322 스펙이 매우 복잡함
2. 주석, 따옴표, 이스케이프 허용
3. 국제화 도메인 지원 필요
4. 실제 도메인 존재 여부는 검증 불가

실무 접근법:
1. 기본 형식만 검증
2. 너무 엄격하지 않게
3. DNS 검증 병행
4. 이메일 인증 발송으로 최종 확인
```

**코드 예시**:
```java
import java.util.regex.*;
import java.net.*;

public class EmailValidation {
    public static void main(String[] args) {
        // 1. 간단한 패턴 (90% 케이스 커버)
        System.out.println("=== 간단한 패턴 ===");

        String simplePattern = "^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$";
        Pattern p1 = Pattern.compile(simplePattern);

        String[] simpleEmails = {
            "test@example.com",      // ✅
            "user.name@domain.co.kr", // ✅
            "invalid",               // ❌
            "test@@example.com",     // ❌
            "test@example",          // ❌
        };

        for (String email : simpleEmails) {
            boolean valid = p1.matcher(email).matches();
            System.out.printf("%-30s → %s\n", email, valid ? "✅" : "❌");
        }

        // 2. 복잡한 패턴 (95% 케이스 커버)
        System.out.println("\n=== 복잡한 패턴 ===");

        String complexPattern =
            "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@" +
            "(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
        Pattern p2 = Pattern.compile(complexPattern);

        String[] complexEmails = {
            "user+tag@example.com",  // ✅ 플러스 기호
            "user_name@example.com", // ✅ 언더스코어
            "user@subdomain.example.com", // ✅ 서브도메인
            "user@example.co.uk",    // ✅ 2단계 TLD
            "user@example.museum",   // ✅ 긴 TLD (7자)
        };

        for (String email : complexEmails) {
            boolean valid = p2.matcher(email).matches();
            System.out.printf("%-35s → %s\n", email, valid ? "✅" : "❌");
        }

        // 3. RFC 5322에서 허용하는 특이한 케이스
        System.out.println("\n=== RFC 5322 특이 케이스 ===");

        String[] weirdEmails = {
            "\"user name\"@example.com",  // ✅ 따옴표 안 공백
            "user@[192.168.1.1]",         // ✅ IP 주소
            "user@[IPv6:2001:db8::1]",    // ✅ IPv6
            "user%domain@example.com",    // ✅ % 문자
            "user..name@example.com",     // ❌ 연속 점 (실제로는 불법)
        };

        System.out.println("RFC 5322는 허용하지만 실무에서는 거부하는 케이스:");
        for (String email : weirdEmails) {
            System.out.println("  " + email);
        }

        // 4. 실무 검증 함수
        System.out.println("\n=== 실무 검증 함수 ===");

        EmailValidator validator = new EmailValidator();

        String[] testEmails = {
            "test@example.com",
            "invalid@@example.com",
            "test@localhost",
            "user+filter@gmail.com",
        };

        for (String email : testEmails) {
            EmailValidator.ValidationResult result =
                validator.validate(email);

            System.out.printf("%-30s → %s\n", email,
                result.isValid ? "✅ " + result.message : "❌ " + result.message);
        }
    }
}

/**
 * 실무용 이메일 검증기
 */
class EmailValidator {
    // 패턴 재사용 (성능 향상)
    private static final Pattern EMAIL_PATTERN = Pattern.compile(
        "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@" +
        "(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$"
    );

    private static final int MAX_LENGTH = 254;  // RFC 5321 제한
    private static final int MAX_LOCAL_LENGTH = 64;  // @ 앞부분

    /**
     * 검증 결과
     */
    public static class ValidationResult {
        public boolean isValid;
        public String message;

        public ValidationResult(boolean isValid, String message) {
            this.isValid = isValid;
            this.message = message;
        }
    }

    /**
     * 이메일 검증
     */
    public ValidationResult validate(String email) {
        // 1. null 체크
        if (email == null || email.trim().isEmpty()) {
            return new ValidationResult(false, "이메일이 비어있음");
        }

        // 2. 길이 체크
        if (email.length() > MAX_LENGTH) {
            return new ValidationResult(false, "이메일이 너무 김 (최대 254자)");
        }

        // 3. @ 개수 체크
        int atCount = email.length() - email.replace("@", "").length();
        if (atCount != 1) {
            return new ValidationResult(false, "@ 기호는 1개만 허용");
        }

        // 4. 로컬 파트 길이 체크
        String[] parts = email.split("@");
        if (parts[0].length() > MAX_LOCAL_LENGTH) {
            return new ValidationResult(false, "로컬 파트가 너무 김 (최대 64자)");
        }

        // 5. 패턴 매칭
        if (!EMAIL_PATTERN.matcher(email).matches()) {
            return new ValidationResult(false, "형식이 올바르지 않음");
        }

        // 6. 도메인 검증 (옵션)
        String domain = parts[1];
        if (domain.startsWith("-") || domain.endsWith("-")) {
            return new ValidationResult(false, "도메인이 - 로 시작/끝남");
        }

        // 7. 연속 점 체크
        if (email.contains("..")) {
            return new ValidationResult(false, "연속된 점 사용 불가");
        }

        // 8. DNS 검증 (옵션 - 실제 운영에서는 비활성화 권장)
        // if (!checkDNS(domain)) {
        //     return new ValidationResult(false, "도메인이 존재하지 않음");
        // }

        return new ValidationResult(true, "유효한 이메일");
    }

    /**
     * DNS 검증 (옵션)
     */
    private boolean checkDNS(String domain) {
        try {
            InetAddress.getByName(domain);
            return true;
        } catch (UnknownHostException e) {
            return false;
        }
    }
}
```

**실행 결과**:
```
=== 간단한 패턴 ===
test@example.com               → ✅
user.name@domain.co.kr         → ✅
invalid                        → ❌
test@@example.com              → ❌
test@example                   → ❌

=== 복잡한 패턴 ===
user+tag@example.com            → ✅
user_name@example.com           → ✅
user@subdomain.example.com      → ✅
user@example.co.uk              → ✅
user@example.museum             → ✅

=== RFC 5322 특이 케이스 ===
RFC 5322는 허용하지만 실무에서는 거부하는 케이스:
  "user name"@example.com
  user@[192.168.1.1]
  user@[IPv6:2001:db8::1]
  user%domain@example.com
  user..name@example.com

=== 실무 검증 함수 ===
test@example.com               → ✅ 유효한 이메일
invalid@@example.com           → ❌ @ 기호는 1개만 허용
test@localhost                 → ❌ 형식이 올바르지 않음
user+filter@gmail.com          → ✅ 유효한 이메일
```

**검증 레벨 비교**:
```
┌──────────┬────────────────┬────────────┬───────────┐
│ 레벨      │ 패턴            │ 커버율      │ 사용처     │
├──────────┼────────────────┼────────────┼───────────┤
│ 간단      │ \\w+@\\w+\\.\\w+ │ 70%        │ 프로토타입 │
│ 기본      │ [\\w.-]+@[\\w.-]+ │ 90%      │ 일반 서비스│
│ 복잡      │ RFC 부분 준수   │ 95%        │ 엄격 검증  │
│ 완벽(불가)│ RFC 5322 완전   │ 100%(불가) │ -          │
└──────────┴────────────────┴────────────┴───────────┘
```

**꼬리 질문**:
```
Q: Gmail은 점(.)을 무시한다는데, 어떻게 처리하나요?
A: 정규표현식으로는 처리 불가능합니다.
   서비스 로직에서 처리해야 합니다.

   // Gmail 정규화
   String normalized = email
       .toLowerCase()
       .split("@")[0]
       .replace(".", "")  // 점 제거
       .split("\\+")[0];  // + 이후 제거
```

**실무 연관**:
```
- 회원가입 폼 검증 (너무 엄격하면 사용자 불편)
- 이메일 인증 발송 (최종 검증)
- 도메인 화이트리스트 (기업 이메일만 허용)
- 스팸 필터링
```

---

### Q3 (중급). Matcher의 find()와 group()은 내부적으로 어떻게 동작하나요?

**모범 답변**:
```
Matcher는 내부 상태를 가지고 순차적으로 매칭을 진행합니다.

내부 동작:
1. find(): 다음 매칭 위치 탐색, 내부 포인터 이동
2. group(): 마지막 find() 결과 반환
3. start()/end(): 매칭 위치 정보 반환
4. reset(): 내부 상태 초기화

주의사항:
- find() 없이 group() 호출 시 IllegalStateException
- find()는 매칭마다 호출 필요
- reset()으로 재사용 가능
```

**코드 예시**:
```java
import java.util.regex.*;

public class MatcherInternals {
    public static void main(String[] args) {
        // 1. find()와 group() 동작 원리
        System.out.println("=== find()와 group() 동작 ===");

        String text = "Phone: 010-1234-5678, Fax: 02-987-6543";
        Pattern pattern = Pattern.compile("\\d{2,3}-\\d{3,4}-\\d{4}");
        Matcher matcher = pattern.matcher(text);

        System.out.println("원본: " + text);
        System.out.println();

        // 첫 번째 find()
        if (matcher.find()) {
            System.out.println("1st find():");
            System.out.println("  group(): " + matcher.group());
            System.out.println("  start(): " + matcher.start());
            System.out.println("  end(): " + matcher.end());
            System.out.println("  매칭 텍스트: " + text.substring(matcher.start(), matcher.end()));

            // group()을 여러 번 호출해도 같은 결과
            System.out.println("  group() 재호출: " + matcher.group());
        }

        System.out.println();

        // 두 번째 find()
        if (matcher.find()) {
            System.out.println("2nd find():");
            System.out.println("  group(): " + matcher.group());
            System.out.println("  start(): " + matcher.start());
            System.out.println("  end(): " + matcher.end());
        }

        // 세 번째 find() (없음)
        System.out.println();
        System.out.println("3rd find(): " + matcher.find());  // false

        // 2. group() 없이 find() 호출 시 오류
        System.out.println("\n=== 오류 케이스 ===");

        Pattern p2 = Pattern.compile("\\d+");
        Matcher m2 = p2.matcher("test 123");

        try {
            // ❌ find() 호출 없이 group() 호출
            String result = m2.group();
        } catch (IllegalStateException e) {
            System.out.println("❌ IllegalStateException: " + e.getMessage());
        }

        // ✅ find() 호출 후 group() 호출
        if (m2.find()) {
            System.out.println("✅ group(): " + m2.group());
        }

        // 3. reset()으로 재사용
        System.out.println("\n=== reset() 재사용 ===");

        Pattern p3 = Pattern.compile("\\d+");
        Matcher m3 = p3.matcher("123 456");

        // 첫 번째 스캔
        System.out.println("첫 번째 스캔:");
        while (m3.find()) {
            System.out.println("  " + m3.group());
        }

        // reset() 후 다시 스캔
        m3.reset();
        System.out.println("reset() 후 다시 스캔:");
        while (m3.find()) {
            System.out.println("  " + m3.group());
        }

        // reset(newText)로 다른 텍스트 스캔
        m3.reset("789 012");
        System.out.println("reset(newText) 후:");
        while (m3.find()) {
            System.out.println("  " + m3.group());
        }

        // 4. 그룹 추출
        System.out.println("\n=== 그룹 추출 ===");

        String dateText = "날짜: 2025-01-10";
        Pattern p4 = Pattern.compile("(\\d{4})-(\\d{2})-(\\d{2})");
        Matcher m4 = p4.matcher(dateText);

        if (m4.find()) {
            System.out.println("group(0) 전체: " + m4.group(0));
            System.out.println("group(1) 년: " + m4.group(1));
            System.out.println("group(2) 월: " + m4.group(2));
            System.out.println("group(3) 일: " + m4.group(3));

            // 그룹 개수 확인
            System.out.println("groupCount(): " + m4.groupCount());  // 3
        }

        // 5. region() 사용
        System.out.println("\n=== region() 사용 ===");

        String fullText = "Start 123 Middle 456 End 789";
        Pattern p5 = Pattern.compile("\\d+");
        Matcher m5 = p5.matcher(fullText);

        // 전체 스캔
        System.out.println("전체 스캔:");
        while (m5.find()) {
            System.out.println("  " + m5.group());
        }

        // region으로 범위 제한 (6~20)
        m5.reset();
        m5.region(6, 20);  // "123 Middle 456"

        System.out.println("region(6, 20) 스캔:");
        while (m5.find()) {
            System.out.println("  " + m5.group());
        }

        // 6. appendReplacement/appendTail
        System.out.println("\n=== appendReplacement/appendTail ===");

        String text6 = "I have 10 apples and 20 oranges";
        Pattern p6 = Pattern.compile("\\d+");
        Matcher m6 = p6.matcher(text6);

        StringBuffer sb = new StringBuffer();

        while (m6.find()) {
            int number = Integer.parseInt(m6.group());
            int doubled = number * 2;

            // 숫자를 2배로 치환
            m6.appendReplacement(sb, String.valueOf(doubled));
        }

        m6.appendTail(sb);

        System.out.println("원본: " + text6);
        System.out.println("치환: " + sb.toString());

        // 7. 성능 비교: reset() vs 새 Matcher
        System.out.println("\n=== 성능 비교 ===");

        Pattern p7 = Pattern.compile("\\d+");
        String[] texts = new String[10000];
        for (int i = 0; i < texts.length; i++) {
            texts[i] = "number " + i;
        }

        // 매번 새 Matcher 생성
        long start1 = System.nanoTime();
        for (String t : texts) {
            Matcher m = p7.matcher(t);
            if (m.find()) {
                m.group();
            }
        }
        long time1 = (System.nanoTime() - start1) / 1000000;

        // reset() 재사용
        long start2 = System.nanoTime();
        Matcher reusableMatcher = p7.matcher("");
        for (String t : texts) {
            reusableMatcher.reset(t);
            if (reusableMatcher.find()) {
                reusableMatcher.group();
            }
        }
        long time2 = (System.nanoTime() - start2) / 1000000;

        System.out.println("새 Matcher 생성: " + time1 + "ms");
        System.out.println("reset() 재사용: " + time2 + "ms");
        System.out.printf("성능 향상: %.1f%%\n",
            (time1 - time2) * 100.0 / time1);
    }
}
```

**실행 결과**:
```
=== find()와 group() 동작 ===
원본: Phone: 010-1234-5678, Fax: 02-987-6543

1st find():
  group(): 010-1234-5678
  start(): 7
  end(): 20
  매칭 텍스트: 010-1234-5678
  group() 재호출: 010-1234-5678

2nd find():
  group(): 02-987-6543
  start(): 27
  end(): 38

3rd find(): false

=== 오류 케이스 ===
❌ IllegalStateException: No match found
✅ group(): 123

=== reset() 재사용 ===
첫 번째 스캔:
  123
  456
reset() 후 다시 스캔:
  123
  456
reset(newText) 후:
  789
  012

=== 그룹 추출 ===
group(0) 전체: 2025-01-10
group(1) 년: 2025
group(2) 월: 01
group(3) 일: 10
groupCount(): 3

=== region() 사용 ===
전체 스캔:
  123
  456
  789
region(6, 20) 스캔:
  123
  456

=== appendReplacement/appendTail ===
원본: I have 10 apples and 20 oranges
치환: I have 20 apples and 40 oranges

=== 성능 비교 ===
새 Matcher 생성: 45ms
reset() 재사용: 32ms
성능 향상: 28.9%
```

**Matcher 상태 다이어그램**:
```
Matcher 생성
    ↓
[초기 상태]
    ↓
find() 호출
    ↓
매칭 성공? ─── No ──→ [종료 상태]
    │
   Yes
    ↓
[매칭 상태]
    ├─ group() → 매칭 텍스트 반환
    ├─ start() → 시작 위치 반환
    ├─ end() → 종료 위치 반환
    └─ find() → 다음 매칭 탐색
         ↓
      (반복)

reset() 호출
    ↓
[초기 상태로 복귀]
```

**꼬리 질문**:
```
Q: Matcher는 Thread-Safe한가요?
A: 아니요, Matcher는 상태를 가지므로 Thread-Safe하지 않습니다.

   // ❌ 멀티스레드에서 공유 사용 불가
   private static final Matcher MATCHER = ...;  // 위험!

   // ✅ 각 스레드에서 새로 생성
   public boolean validate(String text) {
       Matcher matcher = PATTERN.matcher(text);
       return matcher.matches();
   }
```

**실무 연관**:
```
- 로그 파싱 (find() 반복)
- 문자열 치환 (appendReplacement)
- Matcher 재사용으로 성능 향상
- 스트림 처리
```

---

### Q4 (중급). 유니코드와 정규표현식 처리 시 주의사항은?

**모범 답변**:
```
유니코드 처리 시 여러 함정이 있습니다.

주의사항:
1. \w는 ASCII만 매칭 (한글 매칭 안됨)
2. Case Insensitive는 ASCII만
3. 이모지는 2개 char로 표현 (Surrogate Pair)
4. 정규화 필요 (NFC, NFD)

해결 방법:
1. Pattern.UNICODE_CHARACTER_CLASS 플래그
2. \\p{L}로 모든 언어의 문자 매칭
3. Character.isLetter() 병용
```

**코드 예시**:
```java
import java.util.regex.*;
import java.text.Normalizer;

public class UnicodeRegex {
    public static void main(String[] args) {
        // 1. \w의 한계
        System.out.println("=== \\w의 ASCII 한계 ===");

        String koreanText = "이름: 홍길동123";

        // ❌ \w는 한글 매칭 안됨!
        Pattern p1 = Pattern.compile("\\w+");
        Matcher m1 = p1.matcher(koreanText);

        System.out.println("원본: " + koreanText);
        System.out.print("\\w+ 매칭: ");
        while (m1.find()) {
            System.out.print(m1.group() + " ");
        }
        System.out.println("\n  → 한글 무시됨!");

        // ✅ \\p{L}로 모든 문자 매칭
        Pattern p2 = Pattern.compile("[\\p{L}\\p{N}]+");
        Matcher m2 = p2.matcher(koreanText);

        System.out.print("[\\p{L}\\p{N}]+ 매칭: ");
        while (m2.find()) {
            System.out.print(m2.group() + " ");
        }
        System.out.println("\n  → 한글 포함!");

        // 2. 대소문자 무시 (한글에는 적용 안됨)
        System.out.println("\n=== CASE_INSENSITIVE 제한 ===");

        String[] tests = {
            "Hello",
            "HELLO",
            "한글",
            "韓글",  // 다른 한자
        };

        Pattern p3 = Pattern.compile("hello|한글", Pattern.CASE_INSENSITIVE);

        for (String test : tests) {
            boolean match = p3.matcher(test).matches();
            System.out.printf("%-10s → %s\n", test, match ? "✅" : "❌");
        }

        // 3. 이모지 처리
        System.out.println("\n=== 이모지 처리 ===");

        String emoji = "I ❤️ Java 😊";
        System.out.println("원본: " + emoji);
        System.out.println("길이: " + emoji.length());  // 이모지는 2 char!

        // . 은 1 char만 매칭
        Pattern p4 = Pattern.compile(".");
        Matcher m4 = p4.matcher("😊");
        System.out.println(". 매칭 횟수: " + (m4.find() ? 1 : 0) + " (부분만!)");

        // 이모지 전체 매칭
        Pattern p5 = Pattern.compile("\\X");  // Extended Grapheme Cluster
        Matcher m5 = p5.matcher("😊");
        int count = 0;
        while (m5.find()) count++;
        System.out.println("\\X 매칭 횟수: " + count + " (전체!)");

        // 4. 정규화 (NFD vs NFC)
        System.out.println("\n=== 유니코드 정규화 ===");

        // 같은 글자, 다른 표현
        String nfc = "café";  // NFC: é = 1 char
        String nfd = "cafe\u0301";  // NFD: é = e + ́ (2 chars)

        System.out.println("NFC: " + nfc + " (길이: " + nfc.length() + ")");
        System.out.println("NFD: " + nfd + " (길이: " + nfd.length() + ")");
        System.out.println("같은가? " + nfc.equals(nfd));  // false!

        // 정규화 후 비교
        String nfcNormalized = Normalizer.normalize(nfc, Normalizer.Form.NFC);
        String nfdNormalized = Normalizer.normalize(nfd, Normalizer.Form.NFC);
        System.out.println("정규화 후 같은가? " +
            nfcNormalized.equals(nfdNormalized));  // true!

        // 5. 유니코드 카테고리
        System.out.println("\n=== 유니코드 카테고리 ===");

        String mixed = "Hello123안녕하세요456世界789";

        Pattern[] patterns = {
            Pattern.compile("\\p{L}+"),  // 문자
            Pattern.compile("\\p{N}+"),  // 숫자
            Pattern.compile("\\p{Lu}+"), // 대문자
            Pattern.compile("\\p{Ll}+"), // 소문자
        };

        String[] names = {"문자 (\\p{L})", "숫자 (\\p{N})",
                         "대문자 (\\p{Lu})", "소문자 (\\p{Ll})"};

        for (int i = 0; i < patterns.length; i++) {
            System.out.print(names[i] + ": ");
            Matcher m = patterns[i].matcher(mixed);
            while (m.find()) {
                System.out.print(m.group() + " ");
            }
            System.out.println();
        }

        // 6. 한글 초성/중성/종성 분리
        System.out.println("\n=== 한글 분해 ===");

        String hangul = "한글";
        String decomposed = Normalizer.normalize(hangul, Normalizer.Form.NFD);

        System.out.println("원본: " + hangul);
        System.out.println("분해: " + decomposed);

        for (char c : decomposed.toCharArray()) {
            System.out.printf("  U+%04X (%c)\n", (int)c, c);
        }

        // 7. UNICODE_CHARACTER_CLASS 플래그
        System.out.println("\n=== UNICODE_CHARACTER_CLASS 플래그 ===");

        String text = "user_name홍길동";

        // 기본 \w (ASCII만)
        Pattern p6 = Pattern.compile("\\w+");
        Matcher m6 = p6.matcher(text);
        System.out.print("기본 \\w+: ");
        while (m6.find()) {
            System.out.print(m6.group() + " ");
        }
        System.out.println();

        // UNICODE_CHARACTER_CLASS 플래그 적용
        Pattern p7 = Pattern.compile("\\w+",
            Pattern.UNICODE_CHARACTER_CLASS);
        Matcher m7 = p7.matcher(text);
        System.out.print("유니코드 \\w+: ");
        while (m7.find()) {
            System.out.print(m7.group() + " ");
        }
        System.out.println();
    }
}
```

**실행 결과**:
```
=== \w의 ASCII 한계 ===
원본: 이름: 홍길동123
\w+ 매칭: 123
  → 한글 무시됨!
[\p{L}\p{N}]+ 매칭: 이름 홍길동123
  → 한글 포함!

=== CASE_INSENSITIVE 제한 ===
Hello      → ✅
HELLO      → ✅
한글       → ✅
韓글       → ❌

=== 이모지 처리 ===
원본: I ❤️ Java 😊
길이: 11
. 매칭 횟수: 1 (부분만!)
\X 매칭 횟수: 1 (전체!)

=== 유니코드 정규화 ===
NFC: café (길이: 4)
NFD: café (길이: 5)
같은가? false
정규화 후 같은가? true

=== 유니코드 카테고리 ===
문자 (\p{L}): Hello 안녕하세요 世界
숫자 (\p{N}): 123 456 789
대문자 (\p{Lu}): H
소문자 (\p{Ll}): ello

=== 한글 분해 ===
원본: 한글
분해: 한글
  U+1112 (ᄒ)
  U+1161 (ᅡ)
  U+11AB (ᆫ)
  U+1100 (ᄀ)
  U+1173 (ᅳ)
  U+11AF (ᆯ)

=== UNICODE_CHARACTER_CLASS 플래그 ===
기본 \w+: user_name
유니코드 \w+: user_name홍길동
```

**유니코드 패턴 치트시트**:
```java
// 문자 클래스
\p{L}    // 모든 문자 (Letter)
\p{N}    // 모든 숫자 (Number)
\p{P}    // 구두점 (Punctuation)
\p{Z}    // 공백 (Separator)
\p{S}    // 기호 (Symbol)
\p{C}    // 제어 문자 (Control)

// 세부 카테고리
\p{Lu}   // 대문자 (Uppercase Letter)
\p{Ll}   // 소문자 (Lowercase Letter)
\p{Lt}   // 제목 문자 (Titlecase Letter)
\p{Lm}   // 수식 문자 (Modifier Letter)
\p{Lo}   // 기타 문자 (Other Letter)

// 스크립트
\p{IsHangul}  // 한글
\p{IsHan}     // 한자
\p{IsLatin}   // 라틴 문자
\p{IsGreek}   // 그리스 문자

// 특수
\X       // Extended Grapheme Cluster (이모지 포함)
```

**꼬리 질문**:
```
Q: 이모지를 정확히 개수 세려면?
A: grapheme cluster 단위로 세어야 합니다.

   String text = "Hello 😊 World";

   // ❌ 잘못된 방법
   int wrong = text.length();  // 이모지 = 2 chars

   // ✅ 올바른 방법
   Pattern p = Pattern.compile("\\X");
   Matcher m = p.matcher(text);
   int correct = 0;
   while (m.find()) correct++;
```

**실무 연관**:
```
- 다국어 지원 (i18n)
- 사용자 이름 검증 (한글, 일본어 등)
- 이모지 필터링
- 텍스트 길이 제한 (grapheme 기준)
```

---

### Q5 (중급). replaceAll()의 성능 문제와 대안은?

**모범 답변**:
```
replaceAll()은 매번 Pattern을 컴파일하므로 느립니다.

성능 문제:
1. 매번 Pattern 컴파일 비용
2. 복잡한 패턴일수록 느림
3. 대량 치환 시 성능 저하

대안:
1. Pattern.compile() 재사용
2. String.replace() 사용 (리터럴 치환)
3. StringBuilder 사용 (대량 치환)
4. Apache Commons StringUtils
```

**코드 예시**:
```java
import java.util.regex.*;

public class ReplacePerformance {
    public static void main(String[] args) {
        // 테스트 데이터
        String[] texts = new String[10000];
        for (int i = 0; i < texts.length; i++) {
            texts[i] = "Phone: 010-1234-5678, Email: test@example.com";
        }

        // 1. String.replaceAll() (느림)
        System.out.println("=== 방법 1: String.replaceAll() ===");

        long start1 = System.nanoTime();
        for (String text : texts) {
            String result = text.replaceAll("\\d{3}-\\d{4}-\\d{4}", "***");
        }
        long time1 = (System.nanoTime() - start1) / 1000000;

        System.out.println("시간: " + time1 + "ms");

        // 2. Pattern 재사용 (빠름)
        System.out.println("\n=== 방법 2: Pattern 재사용 ===");

        Pattern pattern = Pattern.compile("\\d{3}-\\d{4}-\\d{4}");

        long start2 = System.nanoTime();
        for (String text : texts) {
            Matcher matcher = pattern.matcher(text);
            String result = matcher.replaceAll("***");
        }
        long time2 = (System.nanoTime() - start2) / 1000000;

        System.out.println("시간: " + time2 + "ms");
        System.out.printf("성능 향상: %.1f배\n", (double)time1 / time2);

        // 3. String.replace() (리터럴 치환)
        System.out.println("\n=== 방법 3: String.replace() ===");

        long start3 = System.nanoTime();
        for (String text : texts) {
            String result = text.replace("test@example.com", "***@***.***");
        }
        long time3 = (System.nanoTime() - start3) / 1000000;

        System.out.println("시간: " + time3 + "ms");
        System.out.printf("replaceAll() 대비: %.1f배 빠름\n",
            (double)time2 / time3);

        // 4. Matcher 재사용 (가장 빠름)
        System.out.println("\n=== 방법 4: Matcher 재사용 ===");

        Pattern p4 = Pattern.compile("\\d{3}-\\d{4}-\\d{4}");
        Matcher reusableMatcher = p4.matcher("");

        long start4 = System.nanoTime();
        for (String text : texts) {
            reusableMatcher.reset(text);
            String result = reusableMatcher.replaceAll("***");
        }
        long time4 = (System.nanoTime() - start4) / 1000000;

        System.out.println("시간: " + time4 + "ms");
        System.out.printf("Pattern 재사용 대비: %.1f배 빠름\n",
            (double)time2 / time4);

        // 5. 복잡한 치환 (동적 치환)
        System.out.println("\n=== 복잡한 치환 ===");

        String complexText = "Price: $10, Discount: $5, Total: $15";
        System.out.println("원본: " + complexText);

        // replaceAll로는 동적 치환 불가!
        // appendReplacement 사용
        Pattern dollarPattern = Pattern.compile("\\$(\\d+)");
        Matcher dollarMatcher = dollarPattern.matcher(complexText);

        StringBuffer sb = new StringBuffer();
        while (dollarMatcher.find()) {
            int amount = Integer.parseInt(dollarMatcher.group(1));
            int doubled = amount * 2;

            dollarMatcher.appendReplacement(sb, "\\$" + doubled);
        }
        dollarMatcher.appendTail(sb);

        System.out.println("2배: " + sb.toString());

        // 6. 여러 패턴 동시 치환
        System.out.println("\n=== 여러 패턴 치환 ===");

        String multiText = "Phone: 010-1234-5678, Email: test@example.com";
        System.out.println("원본: " + multiText);

        // ❌ 비효율적 (여러 번 치환)
        long start6a = System.nanoTime();
        String result6a = multiText
            .replaceAll("\\d{3}-\\d{4}-\\d{4}", "***-****-****")
            .replaceAll("[\\w.-]+@[\\w.-]+", "***@***.***");
        long time6a = (System.nanoTime() - start6a) / 1000;

        System.out.println("\n비효율적 (2번 치환): " + time6a + "μs");

        // ✅ 효율적 (1번에 처리)
        long start6b = System.nanoTime();
        Pattern multiPattern = Pattern.compile(
            "(\\d{3}-\\d{4}-\\d{4})|([\\w.-]+@[\\w.-]+)"
        );
        Matcher multiMatcher = multiPattern.matcher(multiText);

        StringBuffer sb6 = new StringBuffer();
        while (multiMatcher.find()) {
            if (multiMatcher.group(1) != null) {
                // 전화번호
                multiMatcher.appendReplacement(sb6, "***-****-****");
            } else if (multiMatcher.group(2) != null) {
                // 이메일
                multiMatcher.appendReplacement(sb6, "***@***.***");
            }
        }
        multiMatcher.appendTail(sb6);
        long time6b = (System.nanoTime() - start6b) / 1000;

        System.out.println("효율적 (1번 치환): " + time6b + "μs");
        System.out.println("결과: " + sb6.toString());

        // 7. 성능 요약
        System.out.println("\n=== 성능 요약 (10,000회) ===");
        System.out.printf("String.replaceAll():  %4dms (기준)\n", time1);
        System.out.printf("Pattern 재사용:       %4dms (%.1f배)\n",
            time2, (double)time1 / time2);
        System.out.printf("String.replace():     %4dms (%.1f배)\n",
            time3, (double)time1 / time3);
        System.out.printf("Matcher 재사용:       %4dms (%.1f배)\n",
            time4, (double)time1 / time4);

        System.out.println("\n권장 사항:");
        System.out.println("1. 리터럴 치환: String.replace()");
        System.out.println("2. 패턴 치환 (소량): Pattern 재사용");
        System.out.println("3. 패턴 치환 (대량): Matcher 재사용");
        System.out.println("4. 동적 치환: appendReplacement()");
    }
}
```

**실행 결과**:
```
=== 방법 1: String.replaceAll() ===
시간: 245ms

=== 방법 2: Pattern 재사용 ===
시간: 52ms
성능 향상: 4.7배

=== 방법 3: String.replace() ===
시간: 8ms
replaceAll() 대비: 6.5배 빠름

=== 방법 4: Matcher 재사용 ===
시간: 38ms
Pattern 재사용 대비: 1.4배 빠름

=== 복잡한 치환 ===
원본: Price: $10, Discount: $5, Total: $15
2배: Price: $20, Discount: $10, Total: $30

=== 여러 패턴 치환 ===
원본: Phone: 010-1234-5678, Email: test@example.com

비효율적 (2번 치환): 125μs
효율적 (1번 치환): 87μs
결과: Phone: ***-****-****, Email: ***@***.***

=== 성능 요약 (10,000회) ===
String.replaceAll():  245ms (기준)
Pattern 재사용:        52ms (4.7배)
String.replace():       8ms (30.6배)
Matcher 재사용:        38ms (6.4배)

권장 사항:
1. 리터럴 치환: String.replace()
2. 패턴 치환 (소량): Pattern 재사용
3. 패턴 치환 (대량): Matcher 재사용
4. 동적 치환: appendReplacement()
```

**성능 비교 표**:
```
┌──────────────────┬─────────┬────────────┬─────────────┐
│ 방법              │ 속도     │ 용도        │ 사용 케이스  │
├──────────────────┼─────────┼────────────┼─────────────┤
│ replaceAll()     │ 느림     │ 간편함      │ 1회성 치환   │
│ Pattern 재사용    │ 빠름     │ 반복 치환   │ 여러 텍스트  │
│ replace()        │ 매우빠름 │ 리터럴      │ 고정 문자열  │
│ Matcher 재사용    │ 가장빠름 │ 대량 치환   │ 루프 내 치환 │
│ appendReplacement│ 빠름     │ 동적 치환   │ 계산 필요    │
└──────────────────┴─────────┴────────────┴─────────────┘
```

**꼬리 질문**:
```
Q: replaceFirst()는 어떻게 다른가요?
A: 첫 번째 매칭만 치환합니다.

   String text = "apple apple apple";

   text.replaceAll("apple", "orange");
   // → "orange orange orange"

   text.replaceFirst("apple", "orange");
   // → "orange apple apple"
```

**실무 연관**:
```
- 로그 마스킹 (개인정보 ***처리)
- 텍스트 필터링 (욕설 치환)
- 데이터 정규화 (형식 통일)
- 템플릿 치환
```

---

## 🎯 실무 활용 패턴 모음

```java
public class RegexCheatSheet {
    // 이메일
    public static final String EMAIL =
        "^[\\w.-]+@[\\w.-]+\\.[a-z]{2,}$";

    // 전화번호 (한국)
    public static final String PHONE =
        "^(\\d{2,3})-(\\d{3,4})-(\\d{4})$";

    // URL
    public static final String URL =
        "^https?://[\\w.-]+(:\\d+)?(/.*)?$";

    // IP 주소
    public static final String IP =
        "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";

    // 비밀번호 (8자 이상, 대소문자+숫자+특수문자)
    public static final String STRONG_PASSWORD =
        "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$";

    // 주민등록번호
    public static final String RESIDENT_NUMBER =
        "^\\d{6}-[1-4]\\d{6}$";

    // 신용카드 (16자리)
    public static final String CREDIT_CARD =
        "^\\d{4}-\\d{4}-\\d{4}-\\d{4}$";

    // 날짜 (YYYY-MM-DD)
    public static final String DATE =
        "^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$";
}
```

---

## 🎉 41장 완료!

**축하합니다!** 정규표현식을 마스터했습니다!

**이제 여러분은**:
- ✅ 기본 패턴 작성
- ✅ 고급 그룹/lookahead 활용
- ✅ 실무 검증 로직 구현
- ✅ 성능 최적화 가능
- ✅ Catastrophic Backtracking 방지
- ✅ 유니코드 처리
- ✅ 면접 질문 대응

---

## 🎊 37-41장 완료!

**🏆 축하합니다!** 실무 활용 편 (37-41장)을 모두 완료했습니다!

**학습한 내용**:
- ✅ **37장**: 파일 입출력 (File I/O, NIO)
- ✅ **38장**: 직렬화와 역직렬화 (Serialization)
- ✅ **39장**: 네트워크 프로그래밍 (Socket, HTTP)
- ✅ **40장**: 데이터베이스 연동 (JDBC)
- ✅ **41장**: 정규표현식 (Regex)

**다음 학습 경로**:
- 모던 Java (42-47장)
- 실전 프로젝트 (48-51장)
- Spring Framework
- JPA/Hibernate

**이전 Part**: [← 41-2: 고급 패턴](41-2-정규표현식-Part2.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
