# 24장 제네릭 Part 1 - 실생활 비유로 이해하기 🎁

## 🌟 실생활 비유로 이해하기

제네릭(Generics)은 클래스나 메서드를 정의할 때 타입을 파라미터로 받아 사용하는 기능입니다. 마치 "어떤 것이든 담을 수 있는 상자"처럼, 하나의 코드로 다양한 타입을 안전하게 다룰 수 있습니다.

---

## 비유 1: 택배 상자 시스템 📦

택배 상자는 옷, 책, 전자제품 등 다양한 물건을 담을 수 있지만, 한 번 담으면 그 물건의 종류가 명확합니다. 제네릭은 이런 "타입이 명확한 범용 상자"와 같습니다.

### 실생활 상황
- **일반 상자(Object)**: 무엇이든 담지만, 꺼낼 때 뭔지 확인해야 함
- **라벨이 붙은 상자(Generic)**: "의류 전용", "전자제품 전용"처럼 타입이 명확
- **안전성**: 라벨 덕분에 잘못된 물건을 넣거나 꺼낼 위험 감소

### 코드 예시

```java
// 제네릭 없이 - 일반 상자
class OldBox {
    private Object item;

    public void pack(Object item) {
        this.item = item;
    }

    public Object unpack() {
        return item;
    }
}

// 제네릭 사용 - 타입이 명확한 상자
class Box<T> {
    private T item;

    public void pack(T item) {
        this.item = item;
        System.out.println("📦 포장 완료: " + item);
    }

    public T unpack() {
        System.out.println("📭 개봉: " + item);
        return item;
    }

    public void showInfo() {
        System.out.println("상자 내용물 타입: " + item.getClass().getSimpleName());
    }
}

// 배송 물품 클래스들
class Electronics {
    private String name;
    private int warranty; // 보증 기간(개월)

    public Electronics(String name, int warranty) {
        this.name = name;
        this.warranty = warranty;
    }

    @Override
    public String toString() {
        return name + " (보증 " + warranty + "개월)";
    }

    public int getWarranty() { return warranty; }
}

class Clothing {
    private String name;
    private String size;

    public Clothing(String name, String size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public String toString() {
        return name + " (사이즈: " + size + ")";
    }

    public String getSize() { return size; }
}

class Book {
    private String title;
    private String author;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    @Override
    public String toString() {
        return "《" + title + "》 - " + author;
    }

    public String getAuthor() { return author; }
}

public class DeliverySystemExample {
    public static void main(String[] args) {
        System.out.println("=== 제네릭 없는 일반 상자 ===\n");

        OldBox oldBox1 = new OldBox();
        oldBox1.pack(new Electronics("노트북", 24));

        // 꺼낼 때 타입 캐스팅 필요 (위험!)
        Object item = oldBox1.unpack();
        if (item instanceof Electronics) {
            Electronics electronics = (Electronics) item;
            System.out.println("보증 기간: " + electronics.getWarranty() + "개월\n");
        }

        // 잘못된 타입을 넣어도 컴파일 시점에 알 수 없음
        OldBox oldBox2 = new OldBox();
        oldBox2.pack("문자열도 들어감"); // 문제 발생 가능성!

        System.out.println("=== 제네릭 사용한 타입별 상자 ===\n");

        // 1. 전자제품 상자
        Box<Electronics> electronicsBox = new Box<>();
        Electronics laptop = new Electronics("MacBook Pro", 12);
        electronicsBox.pack(laptop);
        electronicsBox.showInfo();

        Electronics unpackedLaptop = electronicsBox.unpack(); // 타입 캐스팅 불필요!
        System.out.println("보증 기간: " + unpackedLaptop.getWarranty() + "개월\n");

        // 2. 의류 상자
        Box<Clothing> clothingBox = new Box<>();
        Clothing jacket = new Clothing("겨울 패딩", "L");
        clothingBox.pack(jacket);
        clothingBox.showInfo();

        Clothing unpackedJacket = clothingBox.unpack();
        System.out.println("사이즈: " + unpackedJacket.getSize() + "\n");

        // 3. 도서 상자
        Box<Book> bookBox = new Box<>();
        Book book = new Book("Effective Java", "Joshua Bloch");
        bookBox.pack(book);
        bookBox.showInfo();

        Book unpackedBook = bookBox.unpack();
        System.out.println("저자: " + unpackedBook.getAuthor() + "\n");

        // 컴파일 오류! 타입 안전성 보장
        // electronicsBox.pack(new Clothing("셔츠", "M")); // ❌ 컴파일 에러

        System.out.println("✅ 제네릭의 장점:");
        System.out.println("1. 타입 안전성: 컴파일 시점에 타입 체크");
        System.out.println("2. 타입 캐스팅 불필요: 꺼낼 때 자동으로 올바른 타입");
        System.out.println("3. 코드 재사용: 하나의 Box 클래스로 모든 타입 처리");
    }
}
```

### 실행 결과
```
=== 제네릭 없는 일반 상자 ===

보증 기간: 24개월

=== 제네릭 사용한 타입별 상자 ===

📦 포장 완료: MacBook Pro (보증 12개월)
상자 내용물 타입: Electronics
📭 개봉: MacBook Pro (보증 12개월)
보증 기간: 12개월

📦 포장 완료: 겨울 패딩 (사이즈: L)
상자 내용물 타입: Clothing
📭 개봉: 겨울 패딩 (사이즈: L)
사이즈: L

📦 포장 완료: 《Effective Java》 - Joshua Bloch
상자 내용물 타입: Book
📭 개봉: 《Effective Java》 - Joshua Bloch
저자: Joshua Bloch

✅ 제네릭의 장점:
1. 타입 안전성: 컴파일 시점에 타입 체크
2. 타입 캐스팅 불필요: 꺼낼 때 자동으로 올바른 타입
3. 코드 재사용: 하나의 Box 클래스로 모든 타입 처리
```

### 핵심 정리
- **제네릭 없음**: `Object` 사용 → 타입 캐스팅 필요, 런타임 에러 가능
- **제네릭 사용**: `<T>` 타입 파라미터 → 컴파일 타임 타입 체크, 안전성 보장
- **실생활 비유**: 라벨이 붙은 택배 상자 = 타입이 명확한 제네릭 컨테이너

---

## 비유 2: 김치냉장고 칸 시스템 🥬

김치냉장고는 배추김치, 깍두기, 총각김치 등 다양한 김치를 보관하지만, 각 칸마다 어떤 김치가 들어있는지 명확히 관리합니다. 제네릭 메서드는 이런 "타입별 처리 기능"과 같습니다.

### 실생활 상황
- **냉장고 칸**: 각 칸은 어떤 타입의 음식이든 보관 가능
- **온도/습도 조절**: 담긴 음식 종류에 맞춰 자동 설정
- **관리 시스템**: 김치 종류별로 최적의 보관 방법 적용

### 코드 예시

```java
// 김치 종류들
abstract class Kimchi {
    protected String name;
    protected int fermentationDays; // 숙성 일수

    public Kimchi(String name, int fermentationDays) {
        this.name = name;
        this.fermentationDays = fermentationDays;
    }

    public abstract String getOptimalTemperature();

    @Override
    public String toString() {
        return name + " (숙성 " + fermentationDays + "일)";
    }

    public int getFermentationDays() { return fermentationDays; }
}

class BaechuKimchi extends Kimchi {
    public BaechuKimchi(int fermentationDays) {
        super("배추김치", fermentationDays);
    }

    @Override
    public String getOptimalTemperature() {
        return "-1°C ~ 5°C";
    }
}

class Kkakdugi extends Kimchi {
    public Kkakdugi(int fermentationDays) {
        super("깍두기", fermentationDays);
    }

    @Override
    public String getOptimalTemperature() {
        return "0°C ~ 4°C";
    }
}

class ChonggakKimchi extends Kimchi {
    public ChonggakKimchi(int fermentationDays) {
        super("총각김치", fermentationDays);
    }

    @Override
    public String getOptimalTemperature() {
        return "-2°C ~ 3°C";
    }
}

// 제네릭 메서드를 사용하는 김치냉장고
class KimchiFridge {
    // 제네릭 메서드: 어떤 타입의 김치든 보관 가능
    public <T extends Kimchi> void store(T kimchi, int compartment) {
        System.out.println("🥬 " + compartment + "번 칸에 보관: " + kimchi);
        System.out.println("   최적 온도: " + kimchi.getOptimalTemperature());
        System.out.println("   숙성도: " + getFermentationLevel(kimchi.getFermentationDays()));
    }

    // 제네릭 메서드: 두 김치의 숙성도 비교
    public <T extends Kimchi> T selectMoreFermented(T kimchi1, T kimchi2) {
        System.out.println("\n🔍 숙성도 비교:");
        System.out.println("   " + kimchi1.name + ": " + kimchi1.fermentationDays + "일");
        System.out.println("   " + kimchi2.name + ": " + kimchi2.fermentationDays + "일");

        T selected = kimchi1.fermentationDays > kimchi2.fermentationDays ? kimchi1 : kimchi2;
        System.out.println("   ✅ 더 숙성된 김치: " + selected.name);
        return selected;
    }

    // 제네릭 메서드: 배열의 모든 김치 정보 출력
    public <T extends Kimchi> void displayAll(T[] kimchiArray) {
        System.out.println("\n📋 냉장고 전체 김치 목록:");
        for (int i = 0; i < kimchiArray.length; i++) {
            System.out.println("   " + (i+1) + ". " + kimchiArray[i] +
                             " | 온도: " + kimchiArray[i].getOptimalTemperature());
        }
    }

    // 제네릭 메서드: 평균 숙성일 계산
    public <T extends Kimchi> double calculateAverageFermentation(T[] kimchiArray) {
        int total = 0;
        for (T kimchi : kimchiArray) {
            total += kimchi.getFermentationDays();
        }
        return (double) total / kimchiArray.length;
    }

    private String getFermentationLevel(int days) {
        if (days < 3) return "덜 익음";
        else if (days < 7) return "적당히 익음";
        else if (days < 14) return "잘 익음";
        else return "묵은지";
    }
}

public class KimchiFridgeExample {
    public static void main(String[] args) {
        KimchiFridge fridge = new KimchiFridge();

        System.out.println("=== 김치냉장고 관리 시스템 ===\n");

        // 다양한 김치 보관
        Baechu kimchi baechu = new Baechu("배추김치", 5);
        Kkakdugi kkakdugi = new Kkakdugi(10);
        ChonggakKimchi chonggak = new ChonggakKimchi(3);

        fridge.store(baechu, 1);
        System.out.println();
        fridge.store(kkakdugi, 2);
        System.out.println();
        fridge.store(chonggak, 3);

        // 숙성도 비교
        Kimchi moreRipe = fridge.selectMoreFermented(baechu, kkakdugi);

        // 전체 목록 출력
        Kimchi[] allKimchi = {baechu, kkakdugi, chonggak};
        fridge.displayAll(allKimchi);

        // 평균 숙성일 계산
        double avgDays = fridge.calculateAverageFermentation(allKimchi);
        System.out.println("\n📊 평균 숙성일: " + String.format("%.1f", avgDays) + "일");

        System.out.println("\n✅ 제네릭 메서드의 장점:");
        System.out.println("1. 메서드 레벨 타입 파라미터: 클래스 전체가 아닌 메서드만 제네릭");
        System.out.println("2. 타입 추론: fridge.<Baechu>store(...) 대신 fridge.store(...) 가능");
        System.out.println("3. 유연성: 다양한 김치 타입을 하나의 메서드로 처리");
    }
}
```

### 실행 결과
```
=== 김치냉장고 관리 시스템 ===

🥬 1번 칸에 보관: 배추김치 (숙성 5일)
   최적 온도: -1°C ~ 5°C
   숙성도: 적당히 익음

🥬 2번 칸에 보관: 깍두기 (숙성 10일)
   최적 온도: 0°C ~ 4°C
   숙성도: 잘 익음

🥬 3번 칸에 보관: 총각김치 (숙성 3일)
   최적 온도: -2°C ~ 3°C
   숙성도: 적당히 익음

🔍 숙성도 비교:
   배추김치: 5일
   깍두기: 10일
   ✅ 더 숙성된 김치: 깍두기

📋 냉장고 전체 김치 목록:
   1. 배추김치 (숙성 5일) | 온도: -1°C ~ 5°C
   2. 깍두기 (숙성 10일) | 온도: 0°C ~ 4°C
   3. 총각김치 (숙성 3일) | 온도: -2°C ~ 3°C

📊 평균 숙성일: 6.0일

✅ 제네릭 메서드의 장점:
1. 메서드 레벨 타입 파라미터: 클래스 전체가 아닌 메서드만 제네릭
2. 타입 추론: fridge.<Baechu>store(...) 대신 fridge.store(...) 가능
3. 유연성: 다양한 김치 타입을 하나의 메서드로 처리
```

### 핵심 정리
- **제네릭 메서드**: `<T extends Kimchi>` - 특정 타입의 하위 타입만 허용
- **타입 제약**: `extends` 키워드로 상한(upper bound) 지정
- **실생활 비유**: 김치냉장고 칸 = 다양한 타입을 처리하는 제네릭 메서드

---

## 비유 3: 회의실 예약 시스템 🏢

회사 회의실 예약 시스템은 임원 회의, 팀 미팅, 고객 미팅 등 다양한 유형의 회의를 관리합니다. 와일드카드(?)는 이런 "제한적 접근 권한"과 같습니다.

### 실생활 상황
- **읽기 전용 조회**: 어떤 회의든 일정 확인 가능 (`? extends`)
- **쓰기 전용 등록**: 특정 레벨 이상만 등록 가능 (`? super`)
- **무제한 조회**: 모든 예약 현황 조회 (`?`)

### 코드 예시

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

// 회의 타입 계층
abstract class Meeting {
    protected String title;
    protected LocalDateTime dateTime;
    protected int participants;

    public Meeting(String title, LocalDateTime dateTime, int participants) {
        this.title = title;
        this.dateTime = dateTime;
        this.participants = participants;
    }

    public abstract String getMeetingType();
    public abstract int getRequiredRoomSize();

    @Override
    public String toString() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd HH:mm");
        return getMeetingType() + " - " + title +
               " (" + dateTime.format(formatter) + ", " + participants + "명)";
    }

    public int getParticipants() { return participants; }
}

class ExecutiveMeeting extends Meeting {
    public ExecutiveMeeting(String title, LocalDateTime dateTime, int participants) {
        super(title, dateTime, participants);
    }

    @Override
    public String getMeetingType() { return "임원 회의"; }

    @Override
    public int getRequiredRoomSize() { return 20; } // 대형 회의실
}

class TeamMeeting extends Meeting {
    private String teamName;

    public TeamMeeting(String title, String teamName, LocalDateTime dateTime, int participants) {
        super(title, dateTime, participants);
        this.teamName = teamName;
    }

    @Override
    public String getMeetingType() { return "팀 회의[" + teamName + "]"; }

    @Override
    public int getRequiredRoomSize() { return 10; } // 중형 회의실
}

class ClientMeeting extends Meeting {
    private String clientCompany;

    public ClientMeeting(String title, String clientCompany, LocalDateTime dateTime, int participants) {
        super(title, dateTime, participants);
        this.clientCompany = clientCompany;
    }

    @Override
    public String getMeetingType() { return "고객 미팅[" + clientCompany + "]"; }

    @Override
    public int getRequiredRoomSize() { return 8; } // 소형 회의실
}

// 회의실 예약 시스템
class MeetingRoomSystem {

    // 와일드카드 ?: 무제한 - 어떤 회의든 조회 가능
    public void displayAllMeetings(List<?> meetings) {
        System.out.println("📋 전체 예약 현황 조회 (읽기 전용):");
        if (meetings.isEmpty()) {
            System.out.println("   예약된 회의가 없습니다.\n");
            return;
        }
        for (Object meeting : meetings) {
            System.out.println("   - " + meeting);
        }
        System.out.println();
    }

    // 와일드카드 ? extends Meeting: 상한 제한 - Meeting 및 하위 타입 읽기
    public int calculateTotalParticipants(List<? extends Meeting> meetings) {
        System.out.println("📊 총 참석 인원 계산 (읽기 전용):");
        int total = 0;
        for (Meeting meeting : meetings) {
            total += meeting.getParticipants();
            System.out.println("   - " + meeting.getMeetingType() + ": " +
                             meeting.getParticipants() + "명");
        }
        System.out.println("   ✅ 총 인원: " + total + "명\n");
        return total;
    }

    // 와일드카드 ? super TeamMeeting: 하한 제한 - TeamMeeting 및 상위 타입에 쓰기
    public void addTeamMeetings(List<? super TeamMeeting> meetings, TeamMeeting newMeeting) {
        System.out.println("➕ 팀 회의 추가 (쓰기 가능):");
        meetings.add(newMeeting);
        System.out.println("   " + newMeeting + " 추가 완료\n");

        // 주의: super는 쓰기는 가능하지만, 읽을 때는 Object로만 읽을 수 있음
        // TeamMeeting tm = meetings.get(0); // ❌ 컴파일 에러
        Object obj = meetings.get(0); // ✅ Object로는 가능
    }

    // 일반 제네릭: 읽기/쓰기 모두 가능
    public <T extends Meeting> void organizeByType(List<T> meetings) {
        System.out.println("🔄 회의 정렬 (읽기/쓰기 가능):");
        meetings.sort((m1, m2) -> m1.getParticipants() - m2.getParticipants());
        System.out.println("   참석 인원 기준으로 정렬 완료\n");
    }
}

public class MeetingRoomExample {
    public static void main(String[] args) {
        MeetingRoomSystem system = new MeetingRoomSystem();
        LocalDateTime now = LocalDateTime.now();

        System.out.println("=== 회의실 예약 시스템 ===\n");

        // 1. 다양한 회의 생성
        List<Meeting> allMeetings = new ArrayList<>();
        allMeetings.add(new ExecutiveMeeting("2025 전략 회의", now.plusDays(1), 15));
        allMeetings.add(new TeamMeeting("스프린트 계획", "개발팀", now.plusHours(2), 8));
        allMeetings.add(new ClientMeeting("계약 협상", "네이버", now.plusDays(2), 5));

        // 2. ? 무제한 와일드카드 - 어떤 타입이든 조회
        system.displayAllMeetings(allMeetings);

        // 3. ? extends Meeting - 읽기 전용 (공변성)
        List<TeamMeeting> teamMeetings = new ArrayList<>();
        teamMeetings.add(new TeamMeeting("주간 회의", "마케팅팀", now.plusDays(3), 6));
        teamMeetings.add(new TeamMeeting("월간 회의", "영업팀", now.plusDays(4), 10));

        system.calculateTotalParticipants(teamMeetings); // TeamMeeting은 Meeting의 하위
        system.calculateTotalParticipants(allMeetings);   // Meeting도 가능

        // 4. ? super TeamMeeting - 쓰기 가능 (반공변성)
        List<Meeting> meetingList = new ArrayList<>();
        TeamMeeting newTeamMeeting = new TeamMeeting("긴급 회의", "CS팀", now.plusHours(1), 4);
        system.addTeamMeetings(meetingList, newTeamMeeting);

        // List<ClientMeeting>에는 추가 불가
        // List<ClientMeeting> clientMeetings = new ArrayList<>();
        // system.addTeamMeetings(clientMeetings, newTeamMeeting); // ❌ 컴파일 에러

        // 5. 일반 제네릭 - 읽기/쓰기 모두 가능
        system.organizeByType(allMeetings);
        system.displayAllMeetings(allMeetings);

        System.out.println("✅ 와일드카드 정리:");
        System.out.println("1. <?> : 무제한, 읽기만 가능 (Object로 읽음)");
        System.out.println("2. <? extends T> : 상한 제한, 읽기 전용 (공변성/Producer)");
        System.out.println("3. <? super T> : 하한 제한, 쓰기 전용 (반공변성/Consumer)");
        System.out.println("4. PECS 원칙: Producer-Extends, Consumer-Super");
    }
}
```

### 실행 결과
```
=== 회의실 예약 시스템 ===

📋 전체 예약 현황 조회 (읽기 전용):
   - 임원 회의 - 2025 전략 회의 (10/11 [시간], 15명)
   - 팀 회의[개발팀] - 스프린트 계획 (10/10 [시간], 8명)
   - 고객 미팅[네이버] - 계약 협상 (10/12 [시간], 5명)

📊 총 참석 인원 계산 (읽기 전용):
   - 팀 회의[마케팅팀]: 6명
   - 팀 회의[영업팀]: 10명
   ✅ 총 인원: 16명

📊 총 참석 인원 계산 (읽기 전용):
   - 임원 회의: 15명
   - 팀 회의[개발팀]: 8명
   - 고객 미팅[네이버]: 5명
   ✅ 총 인원: 28명

➕ 팀 회의 추가 (쓰기 가능):
   팀 회의[CS팀] - 긴급 회의 (10/10 [시간], 4명) 추가 완료

🔄 회의 정렬 (읽기/쓰기 가능):
   참석 인원 기준으로 정렬 완료

📋 전체 예약 현황 조회 (읽기 전용):
   - 고객 미팅[네이버] - 계약 협상 (10/12 [시간], 5명)
   - 팀 회의[개발팀] - 스프린트 계획 (10/10 [시간], 8명)
   - 임원 회의 - 2025 전략 회의 (10/11 [시간], 15명)

✅ 와일드카드 정리:
1. <?> : 무제한, 읽기만 가능 (Object로 읽음)
2. <? extends T> : 상한 제한, 읽기 전용 (공변성/Producer)
3. <? super T> : 하한 제한, 쓰기 전용 (반공변성/Consumer)
4. PECS 원칙: Producer-Extends, Consumer-Super
```

### 핵심 정리
- **`<?>` 무제한**: 어떤 타입이든 허용, 읽기만 가능 (Object로)
- **`<? extends T>` 상한**: T와 하위 타입, 읽기 전용 (Producer)
- **`<? super T>` 하한**: T와 상위 타입, 쓰기 전용 (Consumer)
- **PECS 원칙**: Producer는 extends, Consumer는 super

---

## 비유 4: 게임 인벤토리 시스템 🎮

RPG 게임의 인벤토리는 무기, 방어구, 소비아이템 등 다양한 아이템을 관리합니다. 다중 타입 파라미터는 이런 "복잡한 관계 관리"와 같습니다.

### 실생활 상황
- **아이템-수량 쌍**: 아이템과 그 개수를 함께 관리
- **Key-Value 저장**: 아이템 ID와 실제 객체 매핑
- **복잡한 제약**: 여러 타입 파라미터 간의 관계 정의

### 코드 예시

```java
import java.util.*;

// 아이템 타입 정의
interface Item {
    String getName();
    int getValue();
    String getCategory();
}

class Weapon implements Item {
    private String name;
    private int damage;
    private int value;

    public Weapon(String name, int damage, int value) {
        this.name = name;
        this.damage = damage;
        this.value = value;
    }

    @Override public String getName() { return name; }
    @Override public int getValue() { return value; }
    @Override public String getCategory() { return "무기"; }

    public int getDamage() { return damage; }

    @Override
    public String toString() {
        return name + " (공격력: " + damage + ", 가치: " + value + "G)";
    }
}

class Armor implements Item {
    private String name;
    private int defense;
    private int value;

    public Armor(String name, int defense, int value) {
        this.name = name;
        this.defense = defense;
        this.value = value;
    }

    @Override public String getName() { return name; }
    @Override public int getValue() { return value; }
    @Override public String getCategory() { return "방어구"; }

    public int getDefense() { return defense; }

    @Override
    public String toString() {
        return name + " (방어력: " + defense + ", 가치: " + value + "G)";
    }
}

class Potion implements Item {
    private String name;
    private int healAmount;
    private int value;

    public Potion(String name, int healAmount, int value) {
        this.name = name;
        this.healAmount = healAmount;
        this.value = value;
    }

    @Override public String getName() { return name; }
    @Override public int getValue() { return value; }
    @Override public String getCategory() { return "소비아이템"; }

    public int getHealAmount() { return healAmount; }

    @Override
    public String toString() {
        return name + " (회복량: " + healAmount + "HP, 가치: " + value + "G)";
    }
}

// 다중 타입 파라미터 - 아이템과 수량을 함께 관리
class ItemStack<T extends Item, N extends Number> {
    private T item;
    private N quantity;

    public ItemStack(T item, N quantity) {
        this.item = item;
        this.quantity = quantity;
    }

    public T getItem() { return item; }
    public N getQuantity() { return quantity; }

    public int getTotalValue() {
        return item.getValue() * quantity.intValue();
    }

    @Override
    public String toString() {
        return item + " x " + quantity + " (총 가치: " + getTotalValue() + "G)";
    }
}

// 다중 타입 파라미터 - 인벤토리 슬롯
class InventorySlot<K, V extends Item> {
    private K slotId;
    private V item;
    private boolean isLocked;

    public InventorySlot(K slotId, V item) {
        this.slotId = slotId;
        this.item = item;
        this.isLocked = false;
    }

    public K getSlotId() { return slotId; }
    public V getItem() { return item; }

    public void lock() { this.isLocked = true; }
    public void unlock() { this.isLocked = false; }

    public boolean isLocked() { return isLocked; }

    @Override
    public String toString() {
        String lockStatus = isLocked ? "🔒" : "🔓";
        return lockStatus + " 슬롯 " + slotId + ": " + item;
    }
}

// 인벤토리 관리 시스템
class Inventory<T extends Item> {
    private List<ItemStack<T, Integer>> items = new ArrayList<>();
    private String ownerName;

    public Inventory(String ownerName) {
        this.ownerName = ownerName;
    }

    public void addItem(T item, int quantity) {
        items.add(new ItemStack<>(item, quantity));
        System.out.println("✅ " + item.getName() + " x" + quantity + " 추가됨");
    }

    public void displayInventory() {
        System.out.println("\n📦 " + ownerName + "의 인벤토리:");
        if (items.isEmpty()) {
            System.out.println("   (비어있음)");
            return;
        }

        int totalValue = 0;
        for (int i = 0; i < items.size(); i++) {
            ItemStack<T, Integer> stack = items.get(i);
            System.out.println("   " + (i+1) + ". " + stack);
            totalValue += stack.getTotalValue();
        }
        System.out.println("   💰 총 가치: " + totalValue + "G");
    }

    public int getTotalValue() {
        return items.stream()
                   .mapToInt(ItemStack::getTotalValue)
                   .sum();
    }
}

// 제네릭 유틸리티 클래스
class InventoryUtils {
    // 다중 타입 파라미터 메서드: 두 인벤토리 비교
    public static <T extends Item, U extends Item> void compareInventories(
            Inventory<T> inv1, Inventory<U> inv2) {
        System.out.println("\n⚖️ 인벤토리 가치 비교:");
        int value1 = inv1.getTotalValue();
        int value2 = inv2.getTotalValue();
        System.out.println("   인벤토리 1: " + value1 + "G");
        System.out.println("   인벤토리 2: " + value2 + "G");

        if (value1 > value2) {
            System.out.println("   ✅ 인벤토리 1이 더 가치있음 (+" + (value1-value2) + "G)");
        } else if (value2 > value1) {
            System.out.println("   ✅ 인벤토리 2가 더 가치있음 (+" + (value2-value1) + "G)");
        } else {
            System.out.println("   ✅ 두 인벤토리의 가치가 동일");
        }
    }

    // 다중 타입 파라미터 메서드: 슬롯 정보 출력
    public static <K, V extends Item> void displaySlot(InventorySlot<K, V> slot) {
        System.out.println(slot);
    }
}

public class GameInventoryExample {
    public static void main(String[] args) {
        System.out.println("=== 게임 인벤토리 시스템 ===\n");

        // 1. 무기 인벤토리
        Inventory<Weapon> weaponInv = new Inventory<>("전사");
        weaponInv.addItem(new Weapon("엑스칼리버", 150, 5000), 1);
        weaponInv.addItem(new Weapon("단검", 30, 500), 3);
        weaponInv.displayInventory();

        // 2. 소비아이템 인벤토리
        Inventory<Potion> potionInv = new Inventory<>("힐러");
        potionInv.addItem(new Potion("체력 물약", 50, 100), 10);
        potionInv.addItem(new Potion("마나 물약", 30, 80), 15);
        potionInv.displayInventory();

        // 3. 두 인벤토리 비교 (서로 다른 타입)
        InventoryUtils.compareInventories(weaponInv, potionInv);

        // 4. 인벤토리 슬롯 시스템 (다중 타입 파라미터)
        System.out.println("\n🎒 슬롯 기반 인벤토리:");

        InventorySlot<Integer, Weapon> slot1 = new InventorySlot<>(1, new Weapon("롱소드", 80, 1500));
        InventorySlot<String, Armor> slot2 = new InventorySlot<>("A-1", new Armor("플레이트 아머", 120, 3000));
        InventorySlot<Integer, Potion> slot3 = new InventorySlot<>(3, new Potion("엘릭서", 100, 500));

        InventoryUtils.displaySlot(slot1);
        InventoryUtils.displaySlot(slot2);
        slot2.lock(); // 중요 아이템 잠금
        InventoryUtils.displaySlot(slot2);
        InventoryUtils.displaySlot(slot3);

        // 5. ItemStack 예시 (아이템 + 수량)
        System.out.println("\n📦 아이템 스택 시스템:");
        ItemStack<Weapon, Integer> weaponStack =
            new ItemStack<>(new Weapon("화살", 10, 50), 99);
        ItemStack<Potion, Double> fractionalPotion =
            new ItemStack<>(new Potion("농축 물약", 200, 1000), 2.5);

        System.out.println(weaponStack);
        System.out.println(fractionalPotion);

        System.out.println("\n✅ 다중 타입 파라미터의 장점:");
        System.out.println("1. 복잡한 관계 표현: <K, V>로 키-값 쌍 관리");
        System.out.println("2. 타입 안전성: 각 타입 파라미터가 독립적으로 제약");
        System.out.println("3. 유연성: 서로 다른 타입의 조합 가능 (Integer-Weapon, String-Armor 등)");
    }
}
```

### 실행 결과
```
=== 게임 인벤토리 시스템 ===

✅ 엑스칼리버 x1 추가됨
✅ 단검 x3 추가됨

📦 전사의 인벤토리:
   1. 엑스칼리버 (공격력: 150, 가치: 5000G) x 1 (총 가치: 5000G)
   2. 단검 (공격력: 30, 가치: 500G) x 3 (총 가치: 1500G)
   💰 총 가치: 6500G
✅ 체력 물약 x10 추가됨
✅ 마나 물약 x15 추가됨

📦 힐러의 인벤토리:
   1. 체력 물약 (회복량: 50HP, 가치: 100G) x 10 (총 가치: 1000G)
   2. 마나 물약 (회복량: 30HP, 가치: 80G) x 15 (총 가치: 1200G)
   💰 총 가치: 2200G

⚖️ 인벤토리 가치 비교:
   인벤토리 1: 6500G
   인벤토리 2: 2200G
   ✅ 인벤토리 1이 더 가치있음 (+4300G)

🎒 슬롯 기반 인벤토리:
🔓 슬롯 1: 롱소드 (공격력: 80, 가치: 1500G)
🔓 슬롯 A-1: 플레이트 아머 (방어력: 120, 가치: 3000G)
🔒 슬롯 A-1: 플레이트 아머 (방어력: 120, 가치: 3000G)
🔓 슬롯 3: 엘릭서 (회복량: 100HP, 가치: 500G)

📦 아이템 스택 시스템:
화살 (공격력: 10, 가치: 50G) x 99 (총 가치: 4950G)
농축 물약 (회복량: 200HP, 가치: 1000G) x 2.5 (총 가치: 2500G)

✅ 다중 타입 파라미터의 장점:
1. 복잡한 관계 표현: <K, V>로 키-값 쌍 관리
2. 타입 안전성: 각 타입 파라미터가 독립적으로 제약
3. 유연성: 서로 다른 타입의 조합 가능 (Integer-Weapon, String-Armor 등)
```

### 핵심 정리
- **다중 타입 파라미터**: `<T, U>`, `<K, V>` - 여러 타입을 동시에 관리
- **독립적 제약**: 각 타입 파라미터에 개별적으로 `extends` 적용 가능
- **실생활 비유**: 게임 인벤토리 = 복잡한 아이템-수량 관계를 관리하는 다중 제네릭

---

## 비유 5: 실험 시약 보관함 🧪

화학 실험실의 시약 보관함은 위험도와 종류에 따라 엄격히 분리 보관합니다. 타입 소거(Type Erasure)는 이런 "런타임의 단순화"와 같습니다.

### 실생활 상황
- **라벨링 시스템**: 컴파일 시점에는 상세한 라벨(제네릭 타입)
- **실제 보관**: 런타임에는 "화학물질"이라는 일반 카테고리로 통합
- **안전성 유지**: 컴파일 타임 체크로 잘못된 혼합 방지

### 코드 예시

```java
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.*;

// 시약 타입 정의
abstract class Chemical {
    protected String name;
    protected String formula;
    protected int dangerLevel; // 1-5단계

    public Chemical(String name, String formula, int dangerLevel) {
        this.name = name;
        this.formula = formula;
        this.dangerLevel = dangerLevel;
    }

    public abstract String getCategory();

    @Override
    public String toString() {
        return name + " (" + formula + ") [위험도: " + dangerLevel + "]";
    }

    public int getDangerLevel() { return dangerLevel; }
}

class Acid extends Chemical {
    public Acid(String name, String formula, int dangerLevel) {
        super(name, formula, dangerLevel);
    }

    @Override
    public String getCategory() { return "산성 물질"; }
}

class Base extends Chemical {
    public Base(String name, String formula, int dangerLevel) {
        super(name, formula, dangerLevel);
    }

    @Override
    public String getCategory() { return "염기성 물질"; }
}

class Solvent extends Chemical {
    public Solvent(String name, String formula, int dangerLevel) {
        super(name, formula, dangerLevel);
    }

    @Override
    public String getCategory() { return "용매"; }
}

// 제네릭 시약 보관함
class ChemicalStorage<T extends Chemical> {
    private List<T> chemicals = new ArrayList<>();
    private String storageName;

    public ChemicalStorage(String storageName) {
        this.storageName = storageName;
    }

    public void store(T chemical) {
        chemicals.add(chemical);
        System.out.println("✅ " + storageName + "에 보관: " + chemical);
    }

    public void displayContents() {
        System.out.println("\n📦 " + storageName + " 내용물:");
        for (int i = 0; i < chemicals.size(); i++) {
            System.out.println("   " + (i+1) + ". " + chemicals.get(i));
        }
    }

    // 제네릭 타입은 런타임에 소거됨!
    public void checkRuntimeType() {
        System.out.println("\n🔍 런타임 타입 검사:");
        System.out.println("   컴파일 타임: ChemicalStorage<T extends Chemical>");
        System.out.println("   런타임 타입: " + this.getClass().getName());

        // 제네릭 타입 정보는 런타임에 사라짐
        System.out.println("   제네릭 타입 파라미터: (타입 소거로 인해 불가)");

        // chemicals 리스트의 실제 타입
        if (!chemicals.isEmpty()) {
            System.out.println("   실제 저장된 객체 타입: " +
                             chemicals.get(0).getClass().getSimpleName());
        }
    }
}

// 타입 소거 실험 클래스
class TypeErasureDemo {

    // 컴파일 타임에는 다른 메서드처럼 보이지만...
    public static void processAcids(List<Acid> acids) {
        System.out.println("🧪 산성 물질 처리: " + acids.size() + "개");
    }

    // 타입 소거 후에는 같은 시그니처! (컴파일 에러)
    // public static void processBases(List<Base> bases) { // ❌ 불가능
    //     System.out.println("처리: " + bases.size() + "개");
    // }

    // 해결책: 와일드카드나 다른 메서드명 사용
    public static void processChemicals(List<? extends Chemical> chemicals, String type) {
        System.out.println("🧪 " + type + " 처리: " + chemicals.size() + "개");
    }

    // 제네릭 배열 생성 불가 예시
    public static <T extends Chemical> void demonstrateArrayLimitation() {
        System.out.println("\n⚠️ 제네릭 배열 생성 제한:");

        // T[] array = new T[10]; // ❌ 컴파일 에러: 타입 소거로 인해 불가능
        // List<String>[] arrays = new List<String>[10]; // ❌ 컴파일 에러

        List<String>[] workaround = (List<String>[]) new List[10]; // ⚠️ 경고 발생
        System.out.println("   제네릭 배열 직접 생성: 불가능 (타입 소거)");
        System.out.println("   우회 방법: 미검증 형변환 (경고 발생)");
    }

    // 런타임 타입 체크 제한
    public static void demonstrateRuntimeCheck(Object obj) {
        System.out.println("\n🔍 런타임 타입 체크 제한:");

        // if (obj instanceof List<String>) { // ❌ 컴파일 에러
        //     System.out.println("List<String>입니다");
        // }

        if (obj instanceof List) { // ✅ 가능 (raw type만 체크)
            System.out.println("   List 타입입니다 (구체적 타입 파라미터는 알 수 없음)");
            List<?> list = (List<?>) obj;
            System.out.println("   크기: " + list.size());
        }
    }
}

// 브리지 메서드 예시
class StorageWithBridge<T extends Chemical> {
    private T chemical;

    // 제네릭 메서드 (컴파일 타임)
    public void set(T chemical) {
        this.chemical = chemical;
        System.out.println("제네릭 set 호출: " + chemical.getClass().getSimpleName());
    }

    // 타입 소거 후, 컴파일러가 자동으로 브리지 메서드 생성:
    // public void set(Chemical chemical) { // 자동 생성됨
    //     set((T) chemical); // 원래 메서드 호출
    // }

    public T get() {
        return chemical;
    }
}

public class ChemicalStorageExample {
    public static void main(String[] args) {
        System.out.println("=== 시약 보관함 시스템 (타입 소거) ===\n");

        // 1. 산성 물질 보관함
        ChemicalStorage<Acid> acidStorage = new ChemicalStorage<>("산성 보관함");
        acidStorage.store(new Acid("염산", "HCl", 4));
        acidStorage.store(new Acid("황산", "H2SO4", 5));
        acidStorage.displayContents();
        acidStorage.checkRuntimeType();

        // 2. 염기성 물질 보관함
        ChemicalStorage<Base> baseStorage = new ChemicalStorage<>("염기 보관함");
        baseStorage.store(new Base("수산화나트륨", "NaOH", 4));
        baseStorage.displayContents();

        // 3. 타입 소거로 인한 제약
        System.out.println("\n=== 타입 소거(Type Erasure) 동작 ===");

        // 런타임에는 둘 다 ChemicalStorage로 동일
        System.out.println("\n런타임 클래스 비교:");
        System.out.println("   acidStorage: " + acidStorage.getClass().getName());
        System.out.println("   baseStorage: " + baseStorage.getClass().getName());
        System.out.println("   같은 클래스? " +
            (acidStorage.getClass() == baseStorage.getClass())); // true!

        // 4. 타입 소거 제약 사항
        TypeErasureDemo.demonstrateArrayLimitation();

        List<String> stringList = Arrays.asList("A", "B", "C");
        TypeErasureDemo.demonstrateRuntimeCheck(stringList);

        // 5. 브리지 메서드
        System.out.println("\n🌉 브리지 메서드:");
        StorageWithBridge<Acid> storage = new StorageWithBridge<>();
        storage.set(new Acid("질산", "HNO3", 4));

        System.out.println("\n✅ 타입 소거(Type Erasure) 정리:");
        System.out.println("1. 컴파일 타임: 제네릭 타입으로 타입 체크 수행");
        System.out.println("2. 런타임: 제네릭 타입 정보 제거 (Object 또는 bound로 대체)");
        System.out.println("3. 이유: Java 하위 호환성 (Java 5 이전 코드와 호환)");
        System.out.println("4. 제약: instanceof, new T[], 런타임 타입 체크 불가");
        System.out.println("5. 보완: 브리지 메서드로 다형성 유지");

        System.out.println("\n📚 타입 소거 과정:");
        System.out.println("   List<String> → List");
        System.out.println("   <T extends Chemical> → Chemical");
        System.out.println("   <T> → Object");
    }
}
```

### 실행 결과
```
=== 시약 보관함 시스템 (타입 소거) ===

✅ 산성 보관함에 보관: 염산 (HCl) [위험도: 4]
✅ 산성 보관함에 보관: 황산 (H2SO4) [위험도: 5]

📦 산성 보관함 내용물:
   1. 염산 (HCl) [위험도: 4]
   2. 황산 (H2SO4) [위험도: 5]

🔍 런타임 타입 검사:
   컴파일 타임: ChemicalStorage<T extends Chemical>
   런타임 타입: ChemicalStorage
   제네릭 타입 파라미터: (타입 소거로 인해 불가)
   실제 저장된 객체 타입: Acid
✅ 염기 보관함에 보관: 수산화나트륨 (NaOH) [위험도: 4]

📦 염기 보관함 내용물:
   1. 수산화나트륨 (NaOH) [위험도: 4]

=== 타입 소거(Type Erasure) 동작 ===

런타임 클래스 비교:
   acidStorage: ChemicalStorage
   baseStorage: ChemicalStorage
   같은 클래스? true

⚠️ 제네릭 배열 생성 제한:
   제네릭 배열 직접 생성: 불가능 (타입 소거)
   우회 방법: 미검증 형변환 (경고 발생)

🔍 런타임 타입 체크 제한:
   List 타입입니다 (구체적 타입 파라미터는 알 수 없음)
   크기: 3

🌉 브리지 메서드:
제네릭 set 호출: Acid

✅ 타입 소거(Type Erasure) 정리:
1. 컴파일 타임: 제네릭 타입으로 타입 체크 수행
2. 런타임: 제네릭 타입 정보 제거 (Object 또는 bound로 대체)
3. 이유: Java 하위 호환성 (Java 5 이전 코드와 호환)
4. 제약: instanceof, new T[], 런타임 타입 체크 불가
5. 보완: 브리지 메서드로 다형성 유지

📚 타입 소거 과정:
   List<String> → List
   <T extends Chemical> → Chemical
   <T> → Object
```

### 핵심 정리
- **타입 소거**: 컴파일 후 제네릭 타입 정보 제거 → Object 또는 bound로 대체
- **하위 호환성**: Java 5 이전 코드와 호환성 유지 목적
- **제약 사항**: instanceof, 제네릭 배열, 런타임 타입 체크 불가
- **브리지 메서드**: 컴파일러가 자동 생성하여 다형성 유지
- **실생활 비유**: 상세 라벨(컴파일) → 일반 분류(런타임) 단순화

---

## 🎯 Part 1 핵심 요약

### 제네릭의 5가지 핵심 개념

1. **제네릭 클래스** (`Box<T>`)
   - 타입을 파라미터로 받는 클래스
   - 타입 안전성과 재사용성 제공
   - 비유: 라벨이 붙은 택배 상자

2. **제네릭 메서드** (`<T extends Kimchi>`)
   - 메서드 레벨의 타입 파라미터
   - 타입 제약(bounds)으로 상한 지정
   - 비유: 김치 종류별 최적 보관 기능

3. **와일드카드** (`?`, `? extends`, `? super`)
   - PECS: Producer-Extends, Consumer-Super
   - 공변성/반공변성 표현
   - 비유: 회의실 예약 권한 시스템

4. **다중 타입 파라미터** (`<K, V>`, `<T, U>`)
   - 여러 타입을 동시에 관리
   - 복잡한 관계 표현
   - 비유: 게임 아이템-수량 관리

5. **타입 소거** (Type Erasure)
   - 컴파일 후 타입 정보 제거
   - 하위 호환성 유지
   - 비유: 런타임의 단순화된 분류

### 제네릭 사용 시 핵심 원칙
- ✅ 컴파일 타임 타입 안전성 확보
- ✅ 불필요한 타입 캐스팅 제거
- ✅ 코드 재사용성 극대화
- ⚠️ 타입 소거로 인한 제약 이해
- ⚠️ PECS 원칙 준수

다음 Part 2에서는 실제 기업에서 사용하는 제네릭 패턴과 주니어 개발자가 흔히 하는 실수를 다룹니다! 🚀
