# 34ì¥ ë™ì‹œì„± í”„ë¡œê·¸ë˜ë° - Part 1: Concurrent íŒ¨í‚¤ì§€

## ğŸ” java.util.concurrent íŒ¨í‚¤ì§€

**ê³ ìˆ˜ì¤€ ë™ì‹œì„± ìœ í‹¸ë¦¬í‹° ì œê³µ**

---

## ğŸ“– ExecutorService

### ìŠ¤ë ˆë“œ í’€ ê´€ë¦¬
```java
// ê³ ì • í¬ê¸° ìŠ¤ë ˆë“œ í’€
ExecutorService executor = Executors.newFixedThreadPool(10);

// ì‘ì—… ì œì¶œ
executor.submit(() -> {
    System.out.println("ì‘ì—… ì‹¤í–‰");
});

// ì¢…ë£Œ
executor.shutdown();
```

---

## ğŸ“– ì£¼ìš” Concurrent ì»¬ë ‰ì…˜

### 1. ConcurrentHashMap
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

// ìŠ¤ë ˆë“œ ì•ˆì „
map.put("key", 1);
map.computeIfAbsent("key", k -> 0);
```

### 2. CopyOnWriteArrayList
```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

// ì½ê¸°ê°€ ë§ê³  ì“°ê¸°ê°€ ì ì„ ë•Œ ìœ ë¦¬
list.add("item");
```

### 3. BlockingQueue
```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// ìƒì‚°ì
queue.put("item");

// ì†Œë¹„ì
String item = queue.take();  // ë¹„ì–´ìˆìœ¼ë©´ ëŒ€ê¸°
```

---

## ğŸ“– Atomic í´ë˜ìŠ¤

```java
AtomicInteger count = new AtomicInteger(0);

// ìŠ¤ë ˆë“œ ì•ˆì „í•œ ì¦ê°€
count.incrementAndGet();
count.addAndGet(5);

// CAS (Compare-And-Swap)
count.compareAndSet(expected, newValue);
```

---

## ğŸ“– CountDownLatch

```java
CountDownLatch latch = new CountDownLatch(3);

// 3ê°œ ì‘ì—… ì‹¤í–‰
for (int i = 0; i < 3; i++) {
    new Thread(() -> {
        // ì‘ì—… ìˆ˜í–‰
        latch.countDown();  // ì¹´ìš´íŠ¸ ê°ì†Œ
    }).start();
}

// ëª¨ë“  ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
latch.await();
System.out.println("ëª¨ë“  ì‘ì—… ì™„ë£Œ");
```

---

## ğŸ“– CompletableFuture

```java
// ë¹„ë™ê¸° ì‘ì—…
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    return "ê²°ê³¼";
});

// ê²°ê³¼ ì²˜ë¦¬
future.thenAccept(result -> {
    System.out.println(result);
});

// ì—¬ëŸ¬ ì‘ì—… ì¡°í•©
CompletableFuture<String> combined = future1
    .thenCombine(future2, (r1, r2) -> r1 + r2);
```

**ë‹¤ìŒ Part 2**: ì‹¤ì „ íŒ¨í„´
