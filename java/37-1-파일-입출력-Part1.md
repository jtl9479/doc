# 37장 파일 입출력 - Part 1: 기초 개념

> **학습 목표**: 파일 시스템의 기본 개념과 Java의 파일 입출력 API를 이해하고 활용할 수 있다

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐☆☆ (3/5)

---

## 📚 목차
- [왜 파일 입출력이 필요한가](#왜-파일-입출력이-필요한가)
- [실생활 비유로 이해하기](#실생활-비유로-이해하기)
- [핵심 개념](#핵심-개념)
- [기본 실습](#기본-실습)

---

## 🤔 왜 파일 입출력이 필요한가?

### 실무 배경
데이터는 프로그램이 종료되면 메모리에서 사라집니다. 하지만 우리는 데이터를 영구적으로 저장하고, 다시 불러와서 사용해야 합니다.

#### ❌ 파일 입출력을 모르면 발생하는 문제
```
문제 1: 데이터 손실
- 증상: 프로그램 종료 시 모든 데이터 소멸
- 영향: 사용자 설정, 게임 저장, 로그 기록 불가
- 비용: 고객 이탈, 데이터 복구 불가

문제 2: 대용량 데이터 처리 불가
- 증상: 메모리에 모든 데이터 적재 시 OutOfMemoryError
- 영향: 대용량 로그 분석, CSV 파일 처리 불가
- 비용: 시스템 다운, 처리 속도 저하

문제 3: 설정 관리 불가
- 증상: 하드코딩된 설정 값, 배포 시마다 재컴파일
- 영향: 유연성 저하, 유지보수 어려움
- 비용: 개발 시간 증가, 배포 리스크
```

#### ✅ 파일 입출력을 사용하면
```
해결책 1: 영구 저장
- 방법: 파일에 데이터 저장
- 효과: 프로그램 재시작 후에도 데이터 유지
- 절감: 데이터 손실 0%, 사용자 만족도 상승

해결책 2: 스트림 처리
- 방법: 파일을 한 줄씩 읽어서 처리
- 효과: 10GB 파일도 메모리 100MB로 처리 가능
- 절감: 메모리 사용량 99%↓

해결책 3: 설정 파일 분리
- 방법: properties, json, yaml 파일로 설정 관리
- 효과: 코드 수정 없이 설정 변경 가능
- 절감: 배포 시간 80%↓
```

### 📊 수치로 보는 효과

| 지표 | 메모리 전용 | 파일 사용 | 개선율 |
|------|------------|----------|--------|
| 데이터 보존 | 0% | 100% | **∞** |
| 대용량 처리 | 불가 | 가능 | **100%↑** |
| 메모리 사용 | 10GB | 100MB | **99%↓** |
| 설정 변경 시간 | 30분 | 1분 | **97%↓** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: 도서관 시스템 📚

```
파일 입출력 = 도서관 대출/반납 시스템

┌─────────────────────────────────┐
│       도서관 (저장소)            │
├─────────────────────────────────┤
│  📕 book1.txt                   │
│  📗 book2.txt                   │
│  📘 book3.txt                   │
└─────────────────────────────────┘
         ↑         ↓
    대출(Read)  반납(Write)
         ↑         ↓
    ┌──────────────────┐
    │   독자 (프로그램)   │
    │   📖 읽기          │
    │   ✍️ 쓰기          │
    └──────────────────┘

- FileReader = 책 대출 (읽기)
- FileWriter = 책 기증 (쓰기)
- BufferedReader = 여러 권 한 번에 대출
- close() = 도서관 문 닫기 (필수!)
```

### 비유 2: 택배 시스템 📦

```
파일 입출력 = 택배 발송/수령

보내기 (Write):
┌──────┐    포장    ┌──────┐    운송    ┌──────┐
│ 물건 │ --------> │ 택배 │ --------> │ 창고 │
└──────┘   Writer  └──────┘   Stream  └──────┘

받기 (Read):
┌──────┐    개봉    ┌──────┐    배송    ┌──────┐
│ 창고 │ --------> │ 택배 │ --------> │ 물건 │
└──────┘   Reader  └──────┘   Stream  └──────┘

- OutputStream = 포장 상자
- InputStream = 개봉 도구
- Buffer = 대량 배송 트럭
```

### 비유 3: 노트 필기 ✏️

```
파일 = 노트
Writer = 펜
Reader = 눈으로 읽기

┌──────────────────────┐
│      노트 (파일)      │
├──────────────────────┤
│ 1. 수학 공식          │
│ 2. 영어 단어          │
│ 3. 과학 개념          │
└──────────────────────┘
       ↑       ↑
     쓰기     읽기
     (Write) (Read)

- 한 줄씩 쓰기 = PrintWriter.println()
- 한 줄씩 읽기 = BufferedReader.readLine()
- 전체 읽기 = Files.readAllLines()
```

---

## 📖 핵심 개념

### 개념 설명 (3단계 깊이)

#### 1️⃣ 초보자 수준 설명
```
파일 입출력:
- 파일에 데이터를 저장하고 읽어오는 것
- 프로그램이 꺼져도 데이터가 남아있음
- 텍스트 파일, 이미지, 동영상 모두 파일

예: 메모장에 글 쓰고 저장하기
```

#### 2️⃣ 중급자 수준 설명
```
파일 입출력:
- Stream 기반: 데이터를 물 흐르듯 처리
- Reader/Writer: 문자 데이터 (텍스트)
- InputStream/OutputStream: 바이트 데이터 (이진)
- Buffer: 성능 향상을 위한 중간 저장소

특징:
1. 순차 접근: 파일을 처음부터 끝까지 읽음
2. 랜덤 접근: RandomAccessFile로 임의 위치 접근
3. NIO: Java 7+의 현대적 파일 API
```

#### 3️⃣ 고급자 수준 설명
```
파일 입출력 계층 구조:

                InputStream/OutputStream
                Reader/Writer
                      ↓
        ┌─────────────┴─────────────┐
        ↓                           ↓
  FileInputStream              BufferedInputStream
  FileReader                   BufferedReader
  FileOutputStream             PrintWriter
  FileWriter                   BufferedWriter
        ↓                           ↓
    저장소                        메모리
    (Disk)                       (Buffer)

성능 고려사항:
- Buffer 사용: 시스템 콜 횟수 감소 (100배 빠름)
- try-with-resources: 자동 close() 보장
- NIO.2: 비동기, 대용량 파일 처리 최적화
- Memory-mapped file: 초고속 대용량 처리
```

### 주요 용어 정리

| 용어 | 영문 | 설명 | 예시 |
|------|------|------|------|
| 스트림 | Stream | 데이터의 흐름, 순차적 처리 | FileInputStream |
| 버퍼 | Buffer | 데이터를 임시 저장하는 메모리 | BufferedReader |
| 인코딩 | Encoding | 문자를 바이트로 변환 | UTF-8, EUC-KR |
| 경로 | Path | 파일의 위치 | C:/data/file.txt |
| 절대경로 | Absolute Path | 최상위 디렉토리부터 시작 | /home/user/file.txt |
| 상대경로 | Relative Path | 현재 위치 기준 | ./data/file.txt |

### 기술 아키텍처

```
┌─────────────────────────────────────────┐
│          Java Application               │
├─────────────────────────────────────────┤
│  Reader/Writer (문자)                    │
│  InputStream/OutputStream (바이트)       │
├─────────────────────────────────────────┤
│         Java I/O Library                │
├─────────────────────────────────────────┤
│    Buffered I/O (성능 최적화)            │
├─────────────────────────────────────────┤
│           OS File System                │
│  (Windows: NTFS, Linux: ext4)           │
├─────────────────────────────────────────┤
│       Physical Storage (Disk)           │
│  HDD, SSD, Network Storage              │
└─────────────────────────────────────────┘

데이터 흐름:
1. Application → Writer → Buffer
2. Buffer 가득 참 → OS에 전달
3. OS → File System → Disk 저장

읽기 흐름:
1. Disk → File System → OS
2. OS → Buffer로 로드
3. Buffer → Reader → Application
```

---

## 💻 기본 실습

### 📋 사전 체크리스트
```bash
# 1. Java 버전 확인
java -version
# Java 8 이상 필요

# 2. 작업 디렉토리 확인
pwd

# 3. 실습 폴더 생성
mkdir java-io-practice
cd java-io-practice
```

### 실습 1: 파일 쓰기 기본
**난이도**: ⭐☆☆☆☆

#### 코드
```java
import java.io.FileWriter;
import java.io.IOException;

public class FileWriteBasic {
    public static void main(String[] args) {
        // 1. 파일 경로 지정
        String filePath = "output.txt";

        // 2. try-with-resources로 자동 close
        try (FileWriter writer = new FileWriter(filePath)) {
            // 3. 파일에 데이터 쓰기
            writer.write("Hello, File I/O!\n");
            writer.write("This is line 2\n");
            writer.write("한글도 가능합니다\n");

            System.out.println("파일 쓰기 완료: " + filePath);
        } catch (IOException e) {
            System.err.println("파일 쓰기 실패: " + e.getMessage());
        }
    }
}
```

#### 실행
```bash
javac FileWriteBasic.java
java FileWriteBasic
```

#### 예상 출력
```
파일 쓰기 완료: output.txt
```

#### 생성된 파일 확인
```bash
cat output.txt
# 또는 메모장으로 열기
```

**output.txt 내용**:
```
Hello, File I/O!
This is line 2
한글도 가능합니다
```

#### 코드 설명
- **라인 9**: `FileWriter` - 문자 데이터를 파일에 쓰는 클래스
- **라인 9**: `try-with-resources` - 자동으로 close() 호출
- **라인 11-13**: `write()` - 문자열을 파일에 씀
- **라인 16**: `IOException` - 파일 관련 예외 처리

---

### 실습 2: 파일 읽기 기본
**난이도**: ⭐⭐☆☆☆

#### 코드
```java
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;

public class FileReadBasic {
    public static void main(String[] args) {
        String filePath = "output.txt";

        // BufferedReader: 한 줄씩 읽기 위해 사용
        try (FileReader fr = new FileReader(filePath);
             BufferedReader br = new BufferedReader(fr)) {

            String line;
            int lineNumber = 1;

            // 파일 끝까지 한 줄씩 읽기
            while ((line = br.readLine()) != null) {
                System.out.println(lineNumber + ": " + line);
                lineNumber++;
            }

        } catch (IOException e) {
            System.err.println("파일 읽기 실패: " + e.getMessage());
        }
    }
}
```

#### 실행
```bash
javac FileReadBasic.java
java FileReadBasic
```

#### 예상 출력
```
1: Hello, File I/O!
2: This is line 2
3: 한글도 가능합니다
```

#### 코드 설명
- **라인 10**: `FileReader` - 파일에서 문자 데이터 읽기
- **라인 11**: `BufferedReader` - 한 줄씩 효율적으로 읽기
- **라인 17**: `readLine()` - 한 줄 읽기, 파일 끝이면 null 반환
- **라인 17**: `while` 조건에서 대입과 null 체크 동시 수행

---

### 실습 3: 파일 추가 쓰기 (Append)
**난이도**: ⭐⭐☆☆☆

#### 코드
```java
import java.io.FileWriter;
import java.io.IOException;

public class FileAppendExample {
    public static void main(String[] args) {
        String filePath = "output.txt";

        // FileWriter의 두 번째 인자 true: 추가 모드
        try (FileWriter writer = new FileWriter(filePath, true)) {
            writer.write("=== 추가된 내용 ===\n");
            writer.write("4번째 줄입니다\n");
            writer.write("5번째 줄입니다\n");

            System.out.println("파일에 내용 추가 완료");
        } catch (IOException e) {
            System.err.println("파일 쓰기 실패: " + e.getMessage());
        }
    }
}
```

#### 실행
```bash
javac FileAppendExample.java
java FileAppendExample
```

#### 예상 출력
```
파일에 내용 추가 완료
```

#### 확인
```bash
cat output.txt
```

**output.txt 내용**:
```
Hello, File I/O!
This is line 2
한글도 가능합니다
=== 추가된 내용 ===
4번째 줄입니다
5번째 줄입니다
```

#### 코드 설명
- **라인 9**: `FileWriter(path, true)` - 두 번째 인자 `true`는 append 모드
- **false 또는 생략**: 기존 내용 삭제 후 새로 쓰기
- **true**: 기존 내용 유지하고 끝에 추가

---

### 실습 4: BufferedWriter로 성능 향상
**난이도**: ⭐⭐⭐☆☆

#### 코드
```java
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.IOException;

public class BufferedWriteExample {
    public static void main(String[] args) {
        String filePath = "numbers.txt";

        // BufferedWriter: 버퍼 사용으로 성능 향상
        try (FileWriter fw = new FileWriter(filePath);
             BufferedWriter bw = new BufferedWriter(fw)) {

            // 1000줄 쓰기
            for (int i = 1; i <= 1000; i++) {
                bw.write("Line " + i + ": " + (i * i));
                bw.newLine();  // 개행 문자 추가
            }

            System.out.println("1000줄 파일 생성 완료");
        } catch (IOException e) {
            System.err.println("파일 쓰기 실패: " + e.getMessage());
        }
    }
}
```

#### 실행
```bash
javac BufferedWriteExample.java
java BufferedWriteExample
```

#### 예상 출력
```
1000줄 파일 생성 완료
```

#### 파일 확인
```bash
head -5 numbers.txt
```

**numbers.txt 내용 (처음 5줄)**:
```
Line 1: 1
Line 2: 4
Line 3: 9
Line 4: 16
Line 5: 25
```

#### 코드 설명
- **라인 11**: `BufferedWriter` - 내부 버퍼 사용 (기본 8KB)
- **라인 16**: `newLine()` - OS에 맞는 개행 문자 자동 추가
  - Windows: `\r\n`
  - Unix/Linux: `\n`
  - Mac: `\r` (구버전)

---

### 좋은 예 vs 나쁜 예

#### ❌ 나쁜 예: close() 누락
```java
public void badExample() {
    FileWriter writer = new FileWriter("bad.txt");
    writer.write("Hello");
    // close() 호출 안 함!
    // 문제: 파일이 잠기고, 데이터 손실 가능
}
```

**문제점**:
- 문제 1: 파일 핸들 누수 → 시스템 리소스 고갈
- 문제 2: 버퍼 데이터 손실 → 파일에 쓰이지 않음
- 문제 3: 다른 프로세스가 파일 접근 불가

#### ✅ 좋은 예: try-with-resources
```java
public void goodExample() {
    try (FileWriter writer = new FileWriter("good.txt")) {
        writer.write("Hello");
        // 자동으로 close() 호출됨!
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

**장점**:
- 장점 1: 자동 close() 보장 → 리소스 누수 방지
- 장점 2: 예외 발생해도 close() 호출됨
- 장점 3: 코드 간결, 실수 방지

---

#### ❌ 나쁜 예: Buffer 미사용
```java
// 10,000줄 쓰기 → 약 2초 소요
try (FileWriter writer = new FileWriter("slow.txt")) {
    for (int i = 0; i < 10000; i++) {
        writer.write("Line " + i + "\n");
        // 매번 디스크 접근! (느림)
    }
}
```

**문제점**:
- 문제 1: 매 write()마다 시스템 콜 발생
- 문제 2: 디스크 I/O 횟수 증가 → 성능 저하
- 문제 3: 10,000번 디스크 접근

#### ✅ 좋은 예: BufferedWriter 사용
```java
// 10,000줄 쓰기 → 약 0.02초 소요 (100배 빠름!)
try (FileWriter fw = new FileWriter("fast.txt");
     BufferedWriter bw = new BufferedWriter(fw)) {

    for (int i = 0; i < 10000; i++) {
        bw.write("Line " + i);
        bw.newLine();
        // 버퍼에 모아서 한 번에 쓰기!
    }
}
```

**장점**:
- 장점 1: 버퍼에 데이터 모음 → 시스템 콜 감소
- 장점 2: 성능 100배 향상 (10,000 → 약 10번 디스크 접근)
- 장점 3: 메모리와 속도의 균형

---

## 🎯 핵심 정리

### 파일 입출력 기본 공식

```java
// ✅ 파일 쓰기 기본
try (FileWriter writer = new FileWriter("file.txt")) {
    writer.write("내용");
}

// ✅ 파일 읽기 기본
try (BufferedReader reader = new BufferedReader(
        new FileReader("file.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
}

// ✅ 추가 모드
try (FileWriter writer = new FileWriter("file.txt", true)) {
    writer.write("추가 내용");
}

// ✅ 성능 향상 (Buffer 사용)
try (BufferedWriter writer = new BufferedWriter(
        new FileWriter("file.txt"))) {
    writer.write("빠른 쓰기");
    writer.newLine();
}
```

---

**다음 Part에서 계속**: [37-2: NIO와 고급 파일 처리 →](37-2-파일-입출력-Part2.md)

**이전 장**: [← 36장: 가비지 컬렉션](36-3-가비지-컬렉션-Part3.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)