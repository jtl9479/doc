# 06장: 반복문

> **"반복문은 프로그램의 근육, 같은 일을 효율적으로 반복한다"**

**⏱️ 예상 학습 시간**: 3-6시간
**난이도**: ⭐⭐⭐☆☆ (보통)

---

## 📚 목차
- [이 장에서 배울 내용](#-이-장에서-배울-내용)
- [왜 반복문이 중요한가](#-왜-반복문이-중요한가)
- [실생활 비유로 이해하기](#-실생활-비유로-이해하기)
- [반복문이란 무엇인가](#-반복문이란-무엇인가)
- [실습 1: while문](#-실습-1-while문)
- [실습 2: for문](#-실습-2-for문)
- [실습 3: do-while문](#-실습-3-do-while문)
- [실습 4: 중첩 반복문](#-실습-4-중첩-반복문)
- [실습 5: break와 continue](#-실습-5-break와-continue)
- [실무에서 자주 쓰는 반복문 패턴](#-실무에서-자주-쓰는-반복문-패턴)
- [주니어 개발자 실무 시나리오](#-주니어-개발자-실무-시나리오)
- [흔한 실수와 해결 방법](#-흔한-실수와-해결-방법)
- [실전 프로젝트: 숫자 맞추기 게임](#-실전-프로젝트-숫자-맞추기-게임)
- [FAQ (자주 묻는 질문)](#-faq-자주-묻는-질문)
- [면접 질문 리스트](#-면접-질문-리스트)
- [핵심 내용 정리](#-핵심-내용-정리)
- [관련 기술 스택](#-관련-기술-스택)
- [다음 단계](#-다음-단계)
- [추가 학습 자료](#-추가-학습-자료)

---

## 📚 이 장에서 배울 내용

이 장을 완료하면 다음을 할 수 있습니다:

- ✅ while문으로 조건 기반 반복 구현
- ✅ for문으로 횟수 기반 반복 구현
- ✅ do-while문 사용 (최소 1회 실행)
- ✅ 중첩 반복문 작성
- ✅ break로 반복 중단
- ✅ continue로 다음 반복으로 건너뛰기
- ✅ 무한 루프 처리
- ✅ 반복문 실무 패턴 적용

---

## 🎯 왜 반복문이 중요한가?

### 실무 배경

```
😰 신입 개발자 E씨의 비효율

요구사항:
"1부터 100까지 합을 구해주세요"

// ❌ 반복문 없이
int sum = 1 + 2 + 3 + 4 + 5 + ... + 100;  // 불가능!

// ✅ 반복문으로
int sum = 0;
for (int i = 1; i <= 100; i++) {
    sum += i;
}

💡 반복문 = 효율적인 반복 작업!
```

**실제 사례:**
- 📊 배달의민족: **주문 목록** 순회하며 처리
- 📊 넷플릭스: **영화 목록** 반복하며 추천 계산
- 📊 게임: **프레임마다** 화면 업데이트 (무한 루프)

### 📊 수치로 보는 효과

| 지표 | 반복문 없이 | 반복문 사용 | 개선율 |
|------|-------------|-------------|--------|
| 코드 작성 시간 | 100줄 작성 (2시간) | 5줄 작성 (5분) | **96%↓** |
| 코드 유지보수 | 100줄 수정 필요 | 5줄만 수정 | **95%↓** |
| 에러 발생률 | 100줄에서 버그 | 5줄만 검증 | **95%↓** |
| 대용량 처리 | 불가능 | 100만 건 처리 가능 | **무한대↑** |

---

## 🌟 실생활 비유로 이해하기

### 비유 1: while = 신호등 대기

```
🚦 신호등이 바뀔 때까지 대기

while (신호등 == 빨간불) {
    "대기 중..."
}
// 초록불이면 건너감

💡 조건이 true인 동안 반복!
```

### 비유 2: for = 계단 오르기

```
🪜 1층부터 10층까지 오르기

for (int 층 = 1; 층 <= 10; 층++) {
    System.out.println(층 + "층 도착");
}

// 1층, 2층, 3층... 10층까지

💡 정해진 횟수만큼 반복!
```

### 비유 3: break = 엘리베이터 비상정지

```
🛗 원하는 층에서 멈추기

for (int 층 = 1; 층 <= 100; 층++) {
    if (층 == 7) {
        break;  // 7층에서 멈춤!
    }
}

💡 반복을 중간에 중단!
```

### 비유 4: continue = 지하철 급행열차

```
🚇 급행열차는 일부 역만 정차

for (int 역 = 1; 역 <= 10; 역++) {
    if (역 % 3 != 0) {  // 3의 배수가 아니면
        continue;  // 건너뛰기!
    }
    System.out.println(역 + "번역 정차");
}
// 출력: 3번역, 6번역, 9번역만 정차

💡 특정 조건일 때만 건너뛰기!
```

### 비유 5: 중첩 반복문 = 아파트 각 가구 방문

```
🏢 아파트 전체 가구 방문

for (int 동 = 1; 동 <= 3; 동++) {
    for (int 층 = 1; 층 <= 5; 층++) {
        System.out.println(동 + "동 " + 층 + "층 방문");
    }
}

// 1동 1층, 1동 2층, ... 3동 5층까지
// 총 15가구 방문

💡 반복 안에 반복!
```

### 🎯 종합 비교표

```
┌──────────┬──────────────┬────────────────┬──────────────┐
│ 반복문    │ 실생활 비유   │ 사용 상황       │ 특징          │
├──────────┼──────────────┼────────────────┼──────────────┤
│ while    │ 신호등 대기   │ 조건 만족까지   │ 0회 이상      │
│ for      │ 계단 오르기   │ 정해진 횟수     │ 가장 많이 사용│
│ do-while │ 식당 메뉴판   │ 최소 1회 필요   │ 드물게 사용   │
│ break    │ 엘리베이터    │ 조건 충족 중단  │ 탈출          │
│ continue │ 급행열차      │ 일부만 건너뛰기 │ 필터링        │
└──────────┴──────────────┴────────────────┴──────────────┘
```

---

## 📖 반복문이란 무엇인가?

### 반복문의 정의

```java
// 반복문 = 같은 코드를 여러 번 실행

// 예시: "안녕하세요" 5번 출력
for (int i = 0; i < 5; i++) {
    System.out.println("안녕하세요");
}

// 출력:
// 안녕하세요
// 안녕하세요
// 안녕하세요
// 안녕하세요
// 안녕하세요
```

### 반복문의 종류

```
Java 반복문 종류

1. while문
   - 조건이 true인 동안 반복
   - 횟수 모를 때

2. for문
   - 정해진 횟수만큼 반복
   - 가장 많이 사용 ⭐

3. do-while문
   - 최소 1회는 실행
   - 잘 안 쓰임

4. for-each문 (향상된 for)
   - 배열/컬렉션 순회
   - 다음 장에서 배움
```

---

## 💻 실습 1: while문

### 기본 while문

```java
public class WhileBasic {
    public static void main(String[] args) {
        // while (조건) { 코드 }

        // 예시 1: 1부터 5까지 출력
        int i = 1;
        while (i <= 5) {
            System.out.println(i);
            i++;  // 증가 필수! (안 하면 무한 루프)
        }

        // 예시 2: 합 계산
        int sum = 0;
        int num = 1;
        while (num <= 10) {
            sum += num;
            num++;
        }
        System.out.println("1~10 합: " + sum);  // 55

        // 예시 3: 조건 만족까지 반복
        int count = 0;
        while (count < 3) {
            System.out.println("카운트: " + count);
            count++;
        }

        // 예시 4: boolean 조건
        boolean running = true;
        int seconds = 0;

        while (running) {
            System.out.println(seconds + "초");
            seconds++;

            if (seconds >= 5) {
                running = false;  // 조건을 false로
            }
        }
    }
}
```

**출력:**
```
1
2
3
4
5
1~10 합: 55
카운트: 0
카운트: 1
카운트: 2
0초
1초
2초
3초
4초
```

### 무한 루프 (Infinite Loop)

```java
import java.util.Scanner;

public class InfiniteLoop {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // ⚠️ 무한 루프 (의도적)
        System.out.println("=== 메뉴 ===");
        System.out.println("1. 시작");
        System.out.println("2. 설정");
        System.out.println("0. 종료");

        while (true) {  // 항상 true
            System.out.print("\n선택: ");
            int choice = scanner.nextInt();

            if (choice == 1) {
                System.out.println("시작합니다");
            } else if (choice == 2) {
                System.out.println("설정 화면");
            } else if (choice == 0) {
                System.out.println("종료합니다");
                break;  // 반복 탈출!
            } else {
                System.out.println("잘못된 선택");
            }
        }

        scanner.close();
    }
}
```

### while문 주의사항

```java
public class WhileCaution {
    public static void main(String[] args) {
        // ⚠️ 실수 1: 무한 루프 (의도하지 않음)
        int i = 1;
        // while (i <= 5) {
        //     System.out.println(i);
        //     // i++; 누락! → 무한 루프
        // }

        // ⚠️ 실수 2: 조건이 처음부터 false
        int j = 10;
        while (j < 5) {  // 처음부터 false
            System.out.println(j);  // 한 번도 실행 안 됨
            j++;
        }

        // ⚠️ 실수 3: 세미콜론
        int k = 0;
        while (k < 5);  // ← 세미콜론! (빈 루프)
        {
            System.out.println(k);  // 한 번만 실행 (루프 아님)
            k++;
        }

        // ✅ 올바른 사용
        int m = 0;
        while (m < 5) {
            System.out.println(m);
            m++;
        }
    }
}
```

---

## 💻 실습 2: for문

### 기본 for문

```java
public class ForBasic {
    public static void main(String[] args) {
        // for (초기화; 조건; 증감) { 코드 }

        // 예시 1: 0부터 4까지
        for (int i = 0; i < 5; i++) {
            System.out.println(i);
        }

        // 예시 2: 1부터 10까지
        for (int i = 1; i <= 10; i++) {
            System.out.println(i);
        }

        // 예시 3: 2씩 증가
        for (int i = 0; i <= 10; i += 2) {
            System.out.println(i);  // 0, 2, 4, 6, 8, 10
        }

        // 예시 4: 감소
        for (int i = 5; i >= 1; i--) {
            System.out.println(i);  // 5, 4, 3, 2, 1
        }

        // 예시 5: 합 계산
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        System.out.println("1~100 합: " + sum);  // 5050

        // 예시 6: 구구단
        int dan = 7;
        for (int i = 1; i <= 9; i++) {
            System.out.println(dan + " × " + i + " = " + (dan * i));
        }
    }
}
```

**출력:**
```
0
1
2
3
4
1
2
3
...
10
0
2
4
6
8
10
5
4
3
2
1
1~100 합: 5050
7 × 1 = 7
7 × 2 = 14
...
7 × 9 = 63
```

### for문의 구조

```java
public class ForStructure {
    public static void main(String[] args) {
        // for문 분해

        // for (①초기화; ②조건; ④증감) {
        //     ③코드
        // }

        // 실행 순서: ① → ② → ③ → ④ → ② → ③ → ④ → ...

        for (int i = 0; i < 3; i++) {
            System.out.println("i = " + i);
        }

        /*
        실행 과정:
        1. int i = 0 (초기화, 1번만)
        2. i < 3 (조건 체크) → true
        3. 코드 실행 (i = 0 출력)
        4. i++ (i = 1)
        5. i < 3 (조건 체크) → true
        6. 코드 실행 (i = 1 출력)
        7. i++ (i = 2)
        8. i < 3 (조건 체크) → true
        9. 코드 실행 (i = 2 출력)
        10. i++ (i = 3)
        11. i < 3 (조건 체크) → false
        12. 반복 종료
        */

        // 변형 1: 초기화 밖에서
        int j = 0;
        for (; j < 3; j++) {
            System.out.println("j = " + j);
        }

        // 변형 2: 증감 안에서
        int k = 0;
        for (; k < 3;) {
            System.out.println("k = " + k);
            k++;
        }

        // 변형 3: 무한 루프
        // for (;;) {  // 모두 생략 가능
        //     System.out.println("무한");
        //     // break 필요
        // }

        // 변형 4: 여러 변수
        for (int a = 0, b = 10; a < 5; a++, b--) {
            System.out.println("a=" + a + ", b=" + b);
        }
    }
}
```

### while vs for 선택

```java
public class WhileVsFor {
    public static void main(String[] args) {
        // ✅ for문 적합: 횟수가 정해진 경우
        // "1부터 10까지"
        for (int i = 1; i <= 10; i++) {
            System.out.println(i);
        }

        // ✅ while문 적합: 조건이 중요한 경우
        // "특정 조건까지"
        int num = 1;
        while (num * num <= 100) {  // 제곱이 100 이하인 동안
            System.out.println(num);
            num++;
        }

        // 예시 1: 배열 순회 (for 권장)
        int[] numbers = {10, 20, 30, 40, 50};
        for (int i = 0; i < numbers.length; i++) {
            System.out.println(numbers[i]);
        }

        // 예시 2: 사용자 입력 (while 권장)
        // Scanner scanner = new Scanner(System.in);
        // while (scanner.hasNextInt()) {
        //     int input = scanner.nextInt();
        //     // 처리...
        // }

        // 💡 가이드:
        // - 횟수 정해짐 → for
        // - 조건 기반 → while
        // - 둘 다 가능 → for (더 간결)
    }
}
```

---

## 💻 실습 3: do-while문

### 기본 do-while문

```java
import java.util.Scanner;

public class DoWhileBasic {
    public static void main(String[] args) {
        // do { 코드 } while (조건);
        // 최소 1회는 실행!

        // 예시 1: 기본 사용
        int i = 0;
        do {
            System.out.println("i = " + i);
            i++;
        } while (i < 5);

        // 예시 2: 조건이 처음부터 false여도 1회 실행
        int j = 10;
        do {
            System.out.println("j = " + j);  // 1회 실행됨!
            j++;
        } while (j < 5);  // false

        // 예시 3: 사용자 입력 (전형적 사용)
        Scanner scanner = new Scanner(System.in);
        int choice;

        do {
            System.out.println("\n=== 메뉴 ===");
            System.out.println("1. 옵션 1");
            System.out.println("2. 옵션 2");
            System.out.println("0. 종료");
            System.out.print("선택: ");

            choice = scanner.nextInt();

            if (choice == 1) {
                System.out.println("옵션 1 실행");
            } else if (choice == 2) {
                System.out.println("옵션 2 실행");
            } else if (choice != 0) {
                System.out.println("잘못된 선택");
            }

        } while (choice != 0);

        System.out.println("프로그램 종료");
        scanner.close();
    }
}
```

### while vs do-while 차이

```java
public class WhileVsDoWhile {
    public static void main(String[] args) {
        System.out.println("=== while ===");
        int i = 10;
        while (i < 5) {  // 조건 먼저 체크
            System.out.println("while: " + i);  // 실행 안 됨
            i++;
        }

        System.out.println("\n=== do-while ===");
        int j = 10;
        do {  // 일단 실행
            System.out.println("do-while: " + j);  // 1회 실행됨!
            j++;
        } while (j < 5);  // 조건 나중에 체크

        // 💡 차이점:
        // while: 조건 먼저 → 0회 이상 실행
        // do-while: 코드 먼저 → 1회 이상 실행

        // ✅ do-while 적합한 경우:
        // - 메뉴 선택 (최소 1회는 보여줘야 함)
        // - 입력 검증 (최소 1회는 물어봐야 함)

        // 예시: 비밀번호 입력
        // String password;
        // do {
        //     password = input("비밀번호:");
        // } while (!isValidPassword(password));
    }
}
```

---

## 💻 실습 4: 중첩 반복문

### 기본 중첩 반복문

```java
public class NestedLoop {
    public static void main(String[] args) {
        // for 안에 for

        // 예시 1: 2중 반복
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                System.out.println("i=" + i + ", j=" + j);
            }
        }
        /*
        출력:
        i=1, j=1
        i=1, j=2
        i=1, j=3
        i=2, j=1
        i=2, j=2
        i=2, j=3
        i=3, j=1
        i=3, j=2
        i=3, j=3
        */

        // 예시 2: 구구단 전체
        System.out.println("\n=== 구구단 ===");
        for (int dan = 2; dan <= 9; dan++) {
            System.out.println("\n[" + dan + "단]");
            for (int num = 1; num <= 9; num++) {
                System.out.println(dan + " × " + num + " = " + (dan * num));
            }
        }

        // 예시 3: 별 찍기 (정사각형)
        System.out.println("\n=== 별 찍기 ===");
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                System.out.print("* ");
            }
            System.out.println();
        }
        /*
        * * * * *
        * * * * *
        * * * * *
        * * * * *
        * * * * *
        */

        // 예시 4: 별 찍기 (삼각형)
        System.out.println("\n=== 삼각형 ===");
        for (int i = 1; i <= 5; i++) {
            for (int j = 1; j <= i; j++) {
                System.out.print("* ");
            }
            System.out.println();
        }
        /*
        *
        * *
        * * *
        * * * *
        * * * * *
        */
    }
}
```

### 복잡한 패턴

```java
public class ComplexPattern {
    public static void main(String[] args) {
        // 패턴 1: 역삼각형
        System.out.println("=== 역삼각형 ===");
        for (int i = 5; i >= 1; i--) {
            for (int j = 1; j <= i; j++) {
                System.out.print("* ");
            }
            System.out.println();
        }
        /*
        * * * * *
        * * * *
        * * *
        * *
        *
        */

        // 패턴 2: 피라미드
        System.out.println("\n=== 피라미드 ===");
        for (int i = 1; i <= 5; i++) {
            // 공백 출력
            for (int j = 5; j > i; j--) {
                System.out.print(" ");
            }
            // 별 출력
            for (int k = 1; k <= (2 * i - 1); k++) {
                System.out.print("*");
            }
            System.out.println();
        }
        /*
            *
           ***
          *****
         *******
        *********
        */

        // 패턴 3: 다이아몬드
        System.out.println("\n=== 다이아몬드 ===");
        int n = 5;

        // 위쪽
        for (int i = 1; i <= n; i++) {
            for (int j = n; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= (2 * i - 1); k++) {
                System.out.print("*");
            }
            System.out.println();
        }

        // 아래쪽
        for (int i = n - 1; i >= 1; i--) {
            for (int j = n; j > i; j--) {
                System.out.print(" ");
            }
            for (int k = 1; k <= (2 * i - 1); k++) {
                System.out.print("*");
            }
            System.out.println();
        }
    }
}
```

### 3중 반복문

```java
public class TripleLoop {
    public static void main(String[] args) {
        // 3중 반복문 (자주 안 씀, 복잡도 높음)

        // 예시: 좌표계
        for (int x = 0; x < 2; x++) {
            for (int y = 0; y < 2; y++) {
                for (int z = 0; z < 2; z++) {
                    System.out.println("(" + x + "," + y + "," + z + ")");
                }
            }
        }

        // ⚠️ 주의: 3중 이상은 성능 문제!
        // O(n³) → n=100이면 100만 번 실행

        // 💡 실무: 2중까지만 권장
        //    3중 필요하면 리팩토링 고려
    }
}
```

---

## 💻 실습 5: break와 continue

### break문

```java
public class BreakStatement {
    public static void main(String[] args) {
        // break: 반복 즉시 종료

        // 예시 1: 특정 조건에서 중단
        for (int i = 1; i <= 10; i++) {
            if (i == 5) {
                break;  // 5에서 멈춤
            }
            System.out.println(i);
        }
        // 출력: 1, 2, 3, 4

        // 예시 2: 검색
        int[] numbers = {10, 20, 30, 40, 50};
        int target = 30;
        int index = -1;

        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == target) {
                index = i;
                break;  // 찾으면 중단!
            }
        }
        System.out.println("30의 위치: " + index);  // 2

        // 예시 3: 무한 루프 탈출
        int count = 0;
        while (true) {
            System.out.println("카운트: " + count);
            count++;

            if (count >= 5) {
                break;  // 탈출!
            }
        }

        // 예시 4: 중첩 반복문에서 break
        System.out.println("\n=== 중첩 break ===");
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    break;  // 안쪽 반복만 종료
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
        /*
        i=1, j=1
        i=2, j=1
        i=3, j=1
        */
    }
}
```

### continue문

```java
public class ContinueStatement {
    public static void main(String[] args) {
        // continue: 현재 반복 건너뛰고 다음 반복으로

        // 예시 1: 홀수만 출력
        for (int i = 1; i <= 10; i++) {
            if (i % 2 == 0) {
                continue;  // 짝수면 건너뜀
            }
            System.out.println(i);
        }
        // 출력: 1, 3, 5, 7, 9

        // 예시 2: 3의 배수 제외
        for (int i = 1; i <= 10; i++) {
            if (i % 3 == 0) {
                continue;  // 3의 배수 건너뜀
            }
            System.out.println(i);
        }
        // 출력: 1, 2, 4, 5, 7, 8, 10

        // 예시 3: 조건에 맞는 것만 처리
        int[] scores = {85, 92, 45, 78, 95, 55};
        int passCount = 0;

        for (int score : scores) {
            if (score < 60) {
                continue;  // 60점 미만 건너뜀
            }
            passCount++;
            System.out.println("합격: " + score);
        }
        System.out.println("합격자 수: " + passCount);

        // 예시 4: 중첩 반복문에서 continue
        System.out.println("\n=== 중첩 continue ===");
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    continue;  // j=2일 때만 건너뜀
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
        /*
        i=1, j=1
        i=1, j=3
        i=2, j=1
        i=2, j=3
        i=3, j=1
        i=3, j=3
        */
    }
}
```

### Label과 break/continue

```java
public class LabeledLoop {
    public static void main(String[] args) {
        // Label: 중첩 반복문 제어

        // 예시 1: 바깥 반복문 break
        outer:  // Label
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                if (i == 2 && j == 2) {
                    break outer;  // 바깥 반복문까지 종료!
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
        /*
        i=1, j=1
        i=1, j=2
        i=1, j=3
        i=2, j=1
        (i=2, j=2에서 전체 종료)
        */

        System.out.println("\n=== Label continue ===");

        // 예시 2: 바깥 반복문 continue
        outer2:
        for (int i = 1; i <= 3; i++) {
            for (int j = 1; j <= 3; j++) {
                if (j == 2) {
                    continue outer2;  // 바깥 반복문의 다음으로!
                }
                System.out.println("i=" + i + ", j=" + j);
            }
        }
        /*
        i=1, j=1
        i=2, j=1
        i=3, j=1
        */

        // 💡 실무에서는 잘 안 씀 (복잡도 증가)
        //    메서드로 분리하는 게 더 나음
    }
}
```

---

## 🏢 실무에서 자주 쓰는 반복문 패턴

### 패턴 1: 컬렉션 순회

```java
public class CollectionIteration {
    public static void main(String[] args) {
        // 배열 순회

        int[] numbers = {10, 20, 30, 40, 50};

        // 방법 1: 인덱스 사용 (전통적)
        for (int i = 0; i < numbers.length; i++) {
            System.out.println("numbers[" + i + "] = " + numbers[i]);
        }

        // 방법 2: 향상된 for문 (권장)
        for (int num : numbers) {
            System.out.println(num);
        }

        // 예시: 합 계산
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        System.out.println("합: " + sum);

        // 예시: 최댓값 찾기
        int max = numbers[0];
        for (int num : numbers) {
            if (num > max) {
                max = num;
            }
        }
        System.out.println("최댓값: " + max);

        // 예시: 특정 값 찾기
        int target = 30;
        boolean found = false;
        for (int num : numbers) {
            if (num == target) {
                found = true;
                break;
            }
        }
        System.out.println("30 존재? " + found);
    }
}
```

### 패턴 2: 누적 계산

```java
public class AccumulationPattern {
    public static void main(String[] args) {
        // 패턴 1: 합 (Sum)
        int sum = 0;
        for (int i = 1; i <= 100; i++) {
            sum += i;
        }
        System.out.println("1~100 합: " + sum);  // 5050

        // 패턴 2: 곱 (Product)
        int product = 1;
        for (int i = 1; i <= 5; i++) {
            product *= i;  // 팩토리얼
        }
        System.out.println("5! = " + product);  // 120

        // 패턴 3: 개수 세기 (Count)
        int[] scores = {85, 92, 45, 78, 95, 55};
        int passCount = 0;
        for (int score : scores) {
            if (score >= 60) {
                passCount++;
            }
        }
        System.out.println("합격자: " + passCount);

        // 패턴 4: 평균 (Average)
        int totalScore = 0;
        for (int score : scores) {
            totalScore += score;
        }
        double average = (double) totalScore / scores.length;
        System.out.println("평균: " + average);

        // 패턴 5: 문자열 연결 (StringBuilder 권장)
        String result = "";
        for (int i = 1; i <= 5; i++) {
            result += i + " ";  // ⚠️ 비효율 (많으면)
        }
        System.out.println("결과: " + result);

        // ✅ StringBuilder 사용
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= 5; i++) {
            sb.append(i).append(" ");
        }
        System.out.println("결과: " + sb.toString());
    }
}
```

### 패턴 3: 탐색 (Search)

```java
public class SearchPattern {
    public static void main(String[] args) {
        int[] numbers = {10, 20, 30, 40, 50};

        // 패턴 1: 선형 탐색 (Linear Search)
        int target = 30;
        int index = -1;

        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == target) {
                index = i;
                break;  // 찾으면 중단
            }
        }

        if (index != -1) {
            System.out.println("30 발견! 위치: " + index);
        } else {
            System.out.println("30 없음");
        }

        // 패턴 2: 존재 여부 확인
        boolean exists = false;
        for (int num : numbers) {
            if (num == target) {
                exists = true;
                break;
            }
        }
        System.out.println("존재? " + exists);

        // 패턴 3: 모든 위치 찾기
        System.out.println("20 이상인 수:");
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] >= 20) {
                System.out.println("index " + i + ": " + numbers[i]);
            }
        }

        // 패턴 4: 최대/최소 찾기
        int max = numbers[0];
        int min = numbers[0];

        for (int num : numbers) {
            if (num > max) max = num;
            if (num < min) min = num;
        }

        System.out.println("최댓값: " + max);
        System.out.println("최솟값: " + min);
    }
}
```

### 패턴 4: 변환 (Transformation)

```java
public class TransformationPattern {
    public static void main(String[] args) {
        // 패턴 1: 배열 복사
        int[] original = {1, 2, 3, 4, 5};
        int[] copy = new int[original.length];

        for (int i = 0; i < original.length; i++) {
            copy[i] = original[i];
        }

        // 패턴 2: 배열 변환 (각 요소 * 2)
        int[] doubled = new int[original.length];
        for (int i = 0; i < original.length; i++) {
            doubled[i] = original[i] * 2;
        }

        System.out.print("2배: ");
        for (int num : doubled) {
            System.out.print(num + " ");
        }
        System.out.println();

        // 패턴 3: 필터링
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int evenCount = 0;

        // 짝수 개수 세기
        for (int num : numbers) {
            if (num % 2 == 0) {
                evenCount++;
            }
        }

        // 짝수만 추출
        int[] evenNumbers = new int[evenCount];
        int index = 0;
        for (int num : numbers) {
            if (num % 2 == 0) {
                evenNumbers[index++] = num;
            }
        }

        System.out.print("짝수: ");
        for (int num : evenNumbers) {
            System.out.print(num + " ");
        }
        System.out.println();

        // 패턴 4: 배열 역순
        int[] reversed = new int[original.length];
        for (int i = 0; i < original.length; i++) {
            reversed[i] = original[original.length - 1 - i];
        }

        System.out.print("역순: ");
        for (int num : reversed) {
            System.out.print(num + " ");
        }
    }
}
```

---

## 👨‍💻 주니어 개발자 실무 시나리오

### 시나리오 1: 무한 루프 실수

```java
😰 상황: 프로그램이 멈추지 않음!

// ❌ 신입 개발자 코드
int i = 0;
while (i < 10) {
    System.out.println(i);
    // i++; 누락!  → 무한 루프!
}

문제:
- 프로그램이 계속 실행됨
- CPU 100% 사용
- 강제 종료해야 함

// ✅ 수정
int i = 0;
while (i < 10) {
    System.out.println(i);
    i++;  // 증가 필수!
}

💡 교훈:
- 반복 변수 증가/감소 필수
- 종료 조건 명확히
- 무한 루프는 의도적으로만
```

### 시나리오 2: off-by-one 오류

```java
😰 상황: 배열 인덱스 초과

int[] numbers = {10, 20, 30};

// ❌ 잘못된 조건
for (int i = 0; i <= numbers.length; i++) {  // <=
    System.out.println(numbers[i]);
}
// ArrayIndexOutOfBoundsException!
// i=3일 때 numbers[3] 접근 (존재 안 함!)

// ✅ 올바른 조건
for (int i = 0; i < numbers.length; i++) {  // <
    System.out.println(numbers[i]);
}

일반적 실수:
// ❌ 1부터 시작
for (int i = 1; i <= arr.length; i++) { ... }

// ✅ 0부터 시작
for (int i = 0; i < arr.length; i++) { ... }

💡 교훈:
- 배열 인덱스는 0부터!
- < vs <= 주의
- length 값은 개수 (마지막 인덱스 + 1)
```

### 시나리오 3: 중첩 반복문 성능 문제

```java
😰 상황: 프로그램이 너무 느림

// ❌ 비효율적 (O(n²))
int[] arr = new int[10000];  // 1만 개
int[] result = new int[10000];

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr.length; j++) {
        // 1억 번 실행! (10000 × 10000)
        result[i] += arr[j];
    }
}

문제:
- 너무 많은 반복 (1억 번)
- 실행 시간 오래 걸림

// ✅ 최적화 (O(n))
int sum = 0;
for (int j = 0; j < arr.length; j++) {
    sum += arr[j];  // 1만 번만 실행
}
for (int i = 0; i < result.length; i++) {
    result[i] = sum;  // 1만 번
}
// 총 2만 번 (1억 번 → 2만 번!)

💡 교훈:
- 중첩 반복문은 성능 주의
- 불필요한 중복 제거
- 알고리즘 개선 고려
```

### 시나리오 4: 반복문에서 예외 처리 실수

```java
😰 상황: 배열 처리 중 일부 에러로 전체 중단됨

// ❌ 전체 중단
int[] numbers = {10, 20, 0, 40, 50};
int[] results = new int[5];

for (int i = 0; i < numbers.length; i++) {
    results[i] = 100 / numbers[i];  // numbers[2]가 0이라 예외 발생!
    // 여기서 프로그램 중단! results[3], results[4]는 처리 안 됨
}

문제:
- 하나의 에러로 전체 처리 중단
- 일부만 처리되고 나머지는 누락
- 사용자에게 불친절한 에러 메시지

// ✅ 개별 처리 + 에러 로깅
int[] numbers = {10, 20, 0, 40, 50};
int[] results = new int[5];
int successCount = 0;
int errorCount = 0;

for (int i = 0; i < numbers.length; i++) {
    try {
        results[i] = 100 / numbers[i];
        successCount++;
        System.out.println("✅ [" + i + "] 처리 완료: " + results[i]);
    } catch (ArithmeticException e) {
        results[i] = -1;  // 에러 표시
        errorCount++;
        System.out.println("⚠️ [" + i + "] 처리 실패: " + numbers[i] + " (0으로 나눌 수 없음)");
    }
}

System.out.println("\n처리 완료: " + successCount + "건, 실패: " + errorCount + "건");

💡 교훈:
- 반복문 내부에서 예외 처리
- 일부 실패해도 계속 진행
- 에러 로깅으로 문제 파악
- 최종 결과 요약 제공
```

---

## ⚠️ 흔한 실수와 해결 방법

### 실수 1: 세미콜론 실수

```java
// ❌ 세미콜론 위치
for (int i = 0; i < 5; i++);  // ← 세미콜론!
{
    System.out.println(i);  // 한 번만 실행 (i=5)
}

// ✅ 올바른 위치
for (int i = 0; i < 5; i++) {
    System.out.println(i);  // 5번 실행
}
```

### 실수 2: 변수 범위 (Scope)

```java
// ❌ 변수 접근 불가
for (int i = 0; i < 5; i++) {
    int sum = 0;
    sum += i;
}
// System.out.println(i);    // ❌ 에러! (i는 for 안에서만)
// System.out.println(sum);  // ❌ 에러! (sum도 마찬가지)

// ✅ 밖에서 선언
int sum = 0;
for (int i = 0; i < 5; i++) {
    sum += i;
}
System.out.println(sum);  // ✅ OK
```

### 실수 3: break/continue 위치

```java
// ❌ 도달 불가능한 코드
for (int i = 0; i < 5; i++) {
    break;
    System.out.println(i);  // ⚠️ 도달 불가 (Unreachable)
}

// ✅ 조건부 break
for (int i = 0; i < 5; i++) {
    if (i == 3) break;
    System.out.println(i);  // ✅ OK
}
```

### 실수 4: 부동소수점 반복 변수

```java
// ⚠️ 비권장: double/float 반복 변수
for (double d = 0.0; d < 1.0; d += 0.1) {
    System.out.println(d);  // 오차 발생 가능!
}

// ✅ 권장: 정수 사용
for (int i = 0; i < 10; i++) {
    double d = i * 0.1;
    System.out.println(d);
}

// 💡 부동소수점은 정확하지 않음!
```

### 실수 5: 컬렉션 수정 중 반복

```java
import java.util.ArrayList;

// ❌ 위험: 반복 중 제거
ArrayList<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);

// for (Integer num : list) {
//     if (num == 2) {
//         list.remove(num);  // ConcurrentModificationException!
//     }
// }

// ✅ Iterator 사용 또는 역순
for (int i = list.size() - 1; i >= 0; i--) {
    if (list.get(i) == 2) {
        list.remove(i);  // ✅ 안전
    }
}
```

---

## 🛠️ 실전 프로젝트: 숫자 맞추기 게임

### 프로젝트 목표

```
반복문을 활용한 숫자 맞추기 게임
- 1~100 사이 랜덤 숫자 생성
- 사용자 입력
- 힌트 제공 (UP/DOWN)
- 시도 횟수 카운트
- 정답 시 종료
```

### 구현 코드

```java
import java.util.Scanner;
import java.util.Random;

public class NumberGuessingGame {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();

        System.out.println("=".repeat(50));
        System.out.println("           숫자 맞추기 게임");
        System.out.println("=".repeat(50));
        System.out.println();

        boolean playAgain = true;

        while (playAgain) {
            // 랜덤 숫자 생성 (1~100)
            int answer = random.nextInt(100) + 1;
            int attempts = 0;
            int maxAttempts = 10;
            boolean correct = false;

            System.out.println("1부터 100 사이의 숫자를 맞춰보세요!");
            System.out.println("기회는 " + maxAttempts + "번입니다.");
            System.out.println();

            // 게임 루프
            while (attempts < maxAttempts && !correct) {
                attempts++;

                System.out.print("시도 " + attempts + "/" + maxAttempts + " - 숫자 입력: ");
                int guess = scanner.nextInt();

                // 입력 유효성 검사
                if (guess < 1 || guess > 100) {
                    System.out.println("⚠️ 1~100 사이의 숫자를 입력하세요!");
                    attempts--;  // 횟수 차감 안 함
                    continue;
                }

                // 정답 확인
                if (guess == answer) {
                    correct = true;
                    System.out.println();
                    System.out.println("🎉 정답입니다!");
                    System.out.println("✨ " + attempts + "번 만에 맞추셨습니다!");

                    // 등급 판정
                    String grade;
                    if (attempts <= 3) {
                        grade = "천재! 🏆";
                    } else if (attempts <= 5) {
                        grade = "우수! 🥇";
                    } else if (attempts <= 7) {
                        grade = "보통 🥈";
                    } else {
                        grade = "아쉬워요 🥉";
                    }
                    System.out.println("등급: " + grade);

                } else if (guess < answer) {
                    System.out.println("⬆️ UP! 더 큰 숫자입니다.");

                    // 힌트
                    int diff = answer - guess;
                    if (diff <= 5) {
                        System.out.println("💡 힌트: 아주 가까워요!");
                    } else if (diff <= 10) {
                        System.out.println("💡 힌트: 가까워요!");
                    }

                } else {
                    System.out.println("⬇️ DOWN! 더 작은 숫자입니다.");

                    // 힌트
                    int diff = guess - answer;
                    if (diff <= 5) {
                        System.out.println("💡 힌트: 아주 가까워요!");
                    } else if (diff <= 10) {
                        System.out.println("💡 힌트: 가까워요!");
                    }
                }

                System.out.println();
            }

            // 실패 시
            if (!correct) {
                System.out.println("😢 기회를 모두 사용했습니다!");
                System.out.println("정답은 " + answer + "입니다.");
            }

            // 재시작 여부
            System.out.println();
            System.out.print("다시 하시겠습니까? (y/n): ");
            String input = scanner.next();

            if (!input.equalsIgnoreCase("y")) {
                playAgain = false;
            }

            System.out.println();
        }

        System.out.println("=".repeat(50));
        System.out.println("      게임을 종료합니다. 감사합니다!");
        System.out.println("=".repeat(50));

        scanner.close();
    }
}
```

### 실행 결과 예시

```
==================================================
           숫자 맞추기 게임
==================================================

1부터 100 사이의 숫자를 맞춰보세요!
기회는 10번입니다.

시도 1/10 - 숫자 입력: 50
⬆️ UP! 더 큰 숫자입니다.

시도 2/10 - 숫자 입력: 75
⬇️ DOWN! 더 작은 숫자입니다.
💡 힌트: 가까워요!

시도 3/10 - 숫자 입력: 63
⬆️ UP! 더 큰 숫자입니다.
💡 힌트: 아주 가까워요!

시도 4/10 - 숫자 입력: 67

🎉 정답입니다!
✨ 4번 만에 맞추셨습니다!
등급: 우수! 🥇

다시 하시겠습니까? (y/n): n

==================================================
      게임을 종료합니다. 감사합니다!
==================================================
```

### 도전 과제

```
💪 스스로 추가해보기

1. 난이도 선택
   - 쉬움: 1~50, 15회
   - 보통: 1~100, 10회
   - 어려움: 1~200, 7회

2. 기록 저장
   - 최고 기록 (최소 시도 횟수)
   - 게임 횟수

3. 범위 힌트
   - "정답은 60~70 사이입니다"

4. 타이머 추가
   - 제한 시간 내에 맞추기

5. 2인 모드
   - 교대로 입력
   - 누가 먼저 맞추나
```

---

## ❓ FAQ (자주 묻는 질문)

### Q1. while과 for 중 어떤 것을 써야 하나요?

```
A: 상황에 따라 다름!

for문 사용:
✅ 횟수가 정해진 경우
✅ 카운터 변수 필요
✅ 배열/컬렉션 순회

// "10번 반복"
for (int i = 0; i < 10; i++) { ... }

// 배열 순회
for (int i = 0; i < arr.length; i++) { ... }

while문 사용:
✅ 횟수 모를 때
✅ 조건이 중요할 때
✅ 무한 루프

// "조건 만족까지"
while (scanner.hasNext()) { ... }

// 메뉴 루프
while (true) {
    // 선택 처리
    if (quit) break;
}

가이드라인:
- 횟수 정해짐 → for
- 조건 기반 → while
- 둘 다 가능 → for (더 간결)

실무 통계:
- for: 70%
- while: 25%
- do-while: 5%
```

### Q2. 무한 루프는 언제 사용하나요?

```
A: 의도적인 경우에만!

사용 케이스:

1. 게임 메인 루프
while (true) {
    updateGame();
    renderGame();
    if (gameOver) break;
}

2. 서버 프로그램
while (true) {
    Connection conn = acceptConnection();
    handleRequest(conn);
}

3. 메뉴 시스템
while (true) {
    displayMenu();
    int choice = getInput();
    if (choice == 0) break;
    processChoice(choice);
}

4. 이벤트 루프
while (running) {
    Event event = waitForEvent();
    handleEvent(event);
}

주의사항:
✅ 반드시 탈출 조건 있어야 함
✅ break 또는 return 필요
✅ CPU 과부하 방지 (적절한 대기)

❌ 의도하지 않은 무한 루프:
while (i < 10) {
    System.out.println(i);
    // i++ 누락! (버그!)
}

디버깅:
- 반복 변수 확인
- 종료 조건 확인
- Ctrl+C로 강제 종료
```

### Q3. break와 continue의 차이는?

```
A: break는 종료, continue는 건너뛰기!

break:
- 반복문 완전 종료
- 반복문 밖으로 나감

for (int i = 1; i <= 10; i++) {
    if (i == 5) break;  // 5에서 멈춤
    System.out.println(i);
}
// 출력: 1, 2, 3, 4

continue:
- 현재 반복만 건너뜀
- 다음 반복으로 이동

for (int i = 1; i <= 10; i++) {
    if (i == 5) continue;  // 5만 건너뜀
    System.out.println(i);
}
// 출력: 1, 2, 3, 4, 6, 7, 8, 9, 10

실무 활용:

break:
- 검색 (찾으면 중단)
- 에러 발생 시
- 특정 조건 충족 시

for (int i = 0; i < arr.length; i++) {
    if (arr[i] == target) {
        found = true;
        break;  // 찾았으니 중단
    }
}

continue:
- 조건 불만족 건너뛰기
- 필터링
- 유효성 검사

for (int score : scores) {
    if (score < 0) continue;  // 음수 무시
    process(score);
}

기억법:
break = 부러뜨리다 (반복 중단)
continue = 계속하다 (다음으로)
```

### Q4. 중첩 반복문은 몇 단계까지 허용되나요?

```
A: 실무에서는 2단계까지!

1단계: 일반적
for (int i = 0; i < n; i++) {
    // O(n)
}

2단계: 흔함
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        // O(n×m)
    }
}

3단계: 주의
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        for (int k = 0; k < p; k++) {
            // O(n×m×p) - 성능 문제!
        }
    }
}

4단계 이상: ❌ 금지
- 가독성 저하
- 성능 심각
- 리팩토링 필수

성능 영향:
n = 100일 때
- 1중: 100번
- 2중: 10,000번
- 3중: 1,000,000번
- 4중: 100,000,000번 (1억!)

해결 방법:
1. 메서드로 분리
for (int i = 0; i < n; i++) {
    processRow(i);  // 내부는 메서드에서
}

2. 알고리즘 개선
// 3중 루프 → 1중 루프로 최적화

3. 자료구조 변경
// 배열 → HashMap으로 O(1) 탐색

코드 리뷰:
- 2중까지: 허용
- 3중: 정당성 설명 필요
- 4중 이상: 거부
```

### Q5. off-by-one 오류를 방지하는 방법은?

```
A: 경계 조건 신경 쓰기!

off-by-one = 1 차이 나는 오류

흔한 실수:

❌ 배열 초과
int[] arr = new int[10];  // 0~9
for (int i = 0; i <= arr.length; i++) {  // <=
    arr[i] = i;  // i=10일 때 에러!
}

✅ 올바름
for (int i = 0; i < arr.length; i++) {  // <
    arr[i] = i;
}

❌ 1부터 시작
int[] arr = new int[5];
for (int i = 1; i <= arr.length; i++) {
    arr[i] = i;  // arr[5] 에러!
}

✅ 0부터 시작
for (int i = 0; i < arr.length; i++) {
    arr[i] = i;
}

규칙:

1. < vs <=
< length  ✅ (0 ~ length-1)
<= length-1 ✅ (동일)
<= length ❌ (초과!)

2. 시작 인덱스
0부터 ✅ (Java 배열은 0부터)
1부터 ❌ (첫 요소 누락)

3. 경계 테스트
// 항상 테스트
- 첫 요소 (0)
- 마지막 요소 (length-1)
- 빈 배열 (length=0)

예방 방법:
1. 향상된 for 사용
for (int item : arr) { ... }  // 인덱스 불필요

2. 테스트 작성
@Test
void testArrayAccess() {
    int[] arr = {1, 2, 3};
    assertEquals(3, arr[arr.length-1]);
}

3. IDE 경고 확인
// IntelliJ: 배열 초과 경고
```

### Q6. 반복문 성능 최적화 팁은?

```
A: 불필요한 연산 제거!

팁 1: 반복 밖으로 이동
❌ 비효율
for (int i = 0; i < arr.length; i++) {
    int size = arr.length;  // 매번 계산!
    // ...
}

✅ 효율
int size = arr.length;  // 한 번만
for (int i = 0; i < size; i++) {
    // ...
}

팁 2: 메서드 호출 최소화
❌ 비효율
for (int i = 0; i < list.size(); i++) {
    // size() 매번 호출
}

✅ 효율
int size = list.size();
for (int i = 0; i < size; i++) {
    // size() 한 번만
}

팁 3: StringBuilder 사용
❌ 비효율 (String 연결)
String result = "";
for (int i = 0; i < 1000; i++) {
    result += i;  // 매번 새 String 생성!
}

✅ 효율
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    sb.append(i);  // 효율적
}

팁 4: 조기 종료
✅ 찾으면 바로 break
for (int i = 0; i < arr.length; i++) {
    if (arr[i] == target) {
        found = true;
        break;  // 더 이상 안 봄
    }
}

팁 5: 캐시 활용
❌ 반복 계산
for (int i = 0; i < n; i++) {
    double result = Math.sqrt(i);  // 매번 계산
}

✅ 캐싱
double[] cache = new double[n];
for (int i = 0; i < n; i++) {
    cache[i] = Math.sqrt(i);  // 한 번만
}

주의:
- 조기 최적화는 악의 근원
- 측정 후 최적화
- 가독성 > 성능 (대부분)
```

### Q7. do-while은 언제 사용하나요?

```
A: 최소 1회 실행이 필요할 때!

while vs do-while:

while:
while (조건) { ... }
// 조건 먼저 → 0회 이상

do-while:
do { ... } while (조건);
// 코드 먼저 → 1회 이상

사용 케이스:

1. 메뉴 입력
do {
    displayMenu();
    choice = getInput();
    processChoice(choice);
} while (choice != 0);

// 메뉴는 최소 1회는 보여줘야 함!

2. 입력 검증
do {
    password = input("비밀번호:");
} while (!isValid(password));

// 최소 1회는 물어봐야 함!

3. 재시작 확인
do {
    playGame();
    answer = ask("다시? (y/n)");
} while (answer.equals("y"));

실무에서는?
- while: 90%
- do-while: 10%

이유:
- while이 더 직관적
- do-while은 특수 상황
- 대부분 while로 가능

예시:
// do-while
do {
    // ...
} while (cond);

// while로 전환 가능
// ... (한 번 실행)
while (cond) {
    // ...
}

💡 최소 1회 실행 필요하면 do-while!
```

### Q8. 반복문 안에서 변수 선언, 밖에서 선언 차이는?

```
A: 성능과 스코프의 차이!

❌ 반복 안에서 선언
for (int i = 0; i < 1000000; i++) {
    StringBuilder sb = new StringBuilder();  // 100만 번 생성!
    sb.append("Hello");
}

문제:
- 100만 번 객체 생성
- 메모리 낭비
- GC 부담 증가

✅ 반복 밖에서 선언
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 1000000; i++) {
    sb.setLength(0);  // 재사용
    sb.append("Hello");
}

장점:
- 1번만 생성
- 메모리 효율
- 성능 향상

단, 기본 타입은 큰 차이 없음:
// 성능 차이 거의 없음
for (int i = 0; i < n; i++) {
    int temp = i * 2;  // OK
}

실무 가이드:
- 객체: 밖에서 선언 (재사용)
- 기본 타입: 어디든 OK
- 가독성 우선
```

### Q9. 향상된 for문 (for-each)의 장단점은?

```
A: 간결하지만 제한적!

기본 for문:
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}

향상된 for문 (for-each):
for (int item : arr) {
    System.out.println(item);
}

장점:
✅ 간결함
✅ 인덱스 에러 없음
✅ 가독성 좋음
✅ 컬렉션 순회 편리

단점:
❌ 인덱스 접근 불가
❌ 수정 불가 (배열 요소 변경 불가)
❌ 역순 순회 불가
❌ 일부만 순회 불가

사용 예시:

✅ 읽기 전용 순회
for (String name : names) {
    System.out.println(name);
}

❌ 배열 요소 수정
for (int num : numbers) {
    num = num * 2;  // 원본 배열 안 바뀜!
}

✅ 일반 for로 수정
for (int i = 0; i < numbers.length; i++) {
    numbers[i] = numbers[i] * 2;  // 원본 수정 ✅
}

실무 가이드:
- 단순 순회: for-each
- 인덱스 필요: 일반 for
- 수정 필요: 일반 for
- 역순: 일반 for
```

---

## 💼 면접 질문 리스트

### 주니어/신입 개발자용 (기본 개념)

**Q1. for문과 while문의 차이점을 설명해주세요.**

<details>
<summary>💡 모범 답안 포인트</summary>

```
구조적 차이:

for문:
for (초기화; 조건; 증감) {
    코드
}
- 초기화, 조건, 증감이 한 곳에
- 횟수 기반 반복

while문:
초기화
while (조건) {
    코드
    증감
}
- 조건만 명시
- 조건 기반 반복

사용 시점:

for 선택:
✅ 반복 횟수 명확
✅ 배열/컬렉션 순회
✅ 카운터 필요

for (int i = 0; i < 10; i++) { ... }
for (int i = 0; i < arr.length; i++) { ... }

while 선택:
✅ 반복 횟수 모름
✅ 조건 중심
✅ 무한 루프

while (scanner.hasNext()) { ... }
while (true) { ... }

변환 가능:
// for → while
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}

// 동일
int i = 0;
while (i < 5) {
    System.out.println(i);
    i++;
}

실무 권장:
- 횟수 정해짐 → for (더 간결)
- 조건 기반 → while (더 명확)
```

꼬리 질문:
- do-while은 언제 쓰나?
- 향상된 for문은?
</details>

**Q2. break와 continue의 차이와 사용 시점은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
기본 차이:

break:
- 반복문 즉시 종료
- 반복문 밖으로 나감

for (int i = 1; i <= 10; i++) {
    if (i == 5) break;
    System.out.println(i);
}
// 출력: 1, 2, 3, 4
// i=5에서 반복 완전 중단

continue:
- 현재 반복만 건너뜀
- 다음 반복으로 이동

for (int i = 1; i <= 10; i++) {
    if (i == 5) continue;
    System.out.println(i);
}
// 출력: 1, 2, 3, 4, 6, 7, 8, 9, 10
// i=5만 건너뜀

사용 시점:

break 사용:
1. 검색 (찾으면 중단)
for (int i = 0; i < arr.length; i++) {
    if (arr[i] == target) {
        found = true;
        break;
    }
}

2. 에러 시 중단
while (true) {
    if (error) break;
}

3. 조건 충족 시
for (int i = 0; i < n; i++) {
    if (sum >= target) break;
    sum += i;
}

continue 사용:
1. 조건 불만족 건너뛰기
for (int num : numbers) {
    if (num < 0) continue;  // 음수 무시
    process(num);
}

2. 필터링
for (int score : scores) {
    if (score < 60) continue;  // 불합격 제외
    passCount++;
}

3. 유효성 검사
for (String item : items) {
    if (item == null) continue;
    processItem(item);
}

중첩 반복문:
// break는 가장 가까운 반복만
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) break;  // 안쪽만 종료
    }
}

// Label로 바깥 반복 제어
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) break outer;  // 전체 종료
    }
}
```

꼬리 질문:
- Label은 실무에서 쓰나?
- return과의 차이는?
</details>

**Q3. 무한 루프가 발생하는 원인과 해결 방법은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
발생 원인:

1. 증감 누락
❌ while (i < 10) {
    System.out.println(i);
    // i++ 없음!
}

2. 잘못된 증감
❌ while (i < 10) {
    System.out.println(i);
    i--;  // 감소! (영원히 < 10)
}

3. 조건 항상 true
❌ while (true) {
    // break 없음!
}

4. 논리 오류
❌ while (count != 10) {
    count += 2;  // 10을 건너뜀 (8→10→12)
}

5. 부동소수점 비교
❌ double d = 0.0;
while (d != 1.0) {
    d += 0.1;  // 정확히 1.0 안 될 수 있음
}

해결 방법:

1. 증감 확인
✅ while (i < 10) {
    System.out.println(i);
    i++;  // 증가 필수
}

2. 종료 조건 명확히
✅ while (true) {
    // ...
    if (quit) break;  // 탈출구
}

3. 카운터 제한
✅ int safety = 0;
while (condition && safety++ < 1000) {
    // 최대 1000번만
}

4. 범위 조건 사용
✅ while (count < 10) {  // != 대신 <
    count += 2;
}

5. 디버깅 출력
while (condition) {
    System.out.println("Loop: " + i);  // 확인용
    i++;
}

예방:
- for문 사용 (증감 자동)
- 조건 단순하게
- break 조건 명확히
- 테스트 작성

실무 팁:
- IDE 경고 확인
- 코드 리뷰
- 단위 테스트
- Ctrl+C로 강제 종료
```

꼬리 질문:
- 의도적 무한 루프는?
- 디버깅 방법은?
</details>

**Q4. 중첩 반복문의 시간 복잡도는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
시간 복잡도 (Big-O):

1중 반복: O(n)
for (int i = 0; i < n; i++) {
    // n번 실행
}

2중 반복: O(n²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // n × n = n² 번
    }
}

3중 반복: O(n³)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            // n × n × n = n³ 번
        }
    }
}

실행 횟수:

n = 10:
- O(n): 10번
- O(n²): 100번
- O(n³): 1,000번

n = 100:
- O(n): 100번
- O(n²): 10,000번
- O(n³): 1,000,000번

n = 1000:
- O(n): 1,000번
- O(n²): 1,000,000번
- O(n³): 1,000,000,000번 (10억!)

다른 크기:
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        // O(n × m)
    }
}

실무 가이드:

허용 가능:
- O(n): 항상 OK
- O(n log n): 정렬 알고리즘
- O(n²): n < 1000

주의:
- O(n³): n < 100
- O(2ⁿ): n < 20

금지:
- O(n⁴) 이상

최적화:
// ❌ O(n³)
for (i) {
    for (j) {
        for (k) {
            if (arr[i][j] == arr[k]) ...
        }
    }
}

// ✅ O(n²) - HashMap 사용
Map<Integer, Integer> map = new HashMap<>();
for (i) {
    for (j) {
        if (map.containsKey(arr[i][j])) ...
    }
}

성능 측정:
long start = System.currentTimeMillis();
// 반복문
long end = System.currentTimeMillis();
System.out.println("Time: " + (end - start) + "ms");
```

</details>

**Q5. 배열 순회 시 인덱스 실수를 방지하는 방법은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
흔한 실수:

1. 범위 초과
❌ int[] arr = new int[10];
for (int i = 0; i <= arr.length; i++) {  // <=
    arr[i] = i;  // i=10일 때 에러!
}

2. 1부터 시작
❌ for (int i = 1; i <= arr.length; i++) {
    arr[i] = i;  // arr[10] 에러!
}

3. 끝 인덱스 혼동
❌ for (int i = 0; i <= arr.length - 1; i++)
// 복잡함

올바른 방법:

1. < 사용 (권장)
✅ for (int i = 0; i < arr.length; i++) {
    arr[i] = i;
}

2. 향상된 for (인덱스 불필요 시)
✅ for (int item : arr) {
    System.out.println(item);
}

3. 역순 (인덱스 확실)
✅ for (int i = arr.length - 1; i >= 0; i--) {
    arr[i] = i;
}

규칙:

시작: 0
끝: < length (또는 <= length-1)

// ✅ 표준 패턴
for (int i = 0; i < arr.length; i++)

// ❌ 피해야 할 패턴
for (int i = 1; i <= arr.length; i++)
for (int i = 0; i <= arr.length; i++)

경계 테스트:
// 항상 확인
- 첫 요소: arr[0]
- 마지막: arr[arr.length - 1]
- 빈 배열: arr.length == 0

향상된 for 활용:
// 인덱스 필요 없으면
for (int num : numbers) {
    sum += num;
}

// 인덱스 필요하면
for (int i = 0; i < numbers.length; i++) {
    System.out.println(i + ": " + numbers[i]);
}

IDE 도움:
// IntelliJ: fori 단축키
for (int i = 0; i < ; i++) {
    // 자동 완성
}

// iter 단축키
for (int number : numbers) {
    // 자동 완성
}
```

</details>

**Q6. 반복문에서 i++와 ++i의 차이는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
기본 개념:

i++: 후위 증감 (사용 후 증가)
++i: 전위 증감 (증가 후 사용)

예시:

int i = 5;
int a = i++;  // a = 5, i = 6 (먼저 대입, 나중에 증가)

int j = 5;
int b = ++j;  // b = 6, j = 6 (먼저 증가, 나중에 대입)

for문에서는?

// 둘 다 동일!
for (int i = 0; i < 10; i++) { ... }
for (int i = 0; i < 10; ++i) { ... }

이유:
- for문 증감부에서는 값을 사용하지 않음
- 단순히 증가만 하므로 결과 동일

차이가 나는 경우:

❌ 주의 필요
int[] arr = new int[5];
int i = 0;
arr[i++] = 10;  // arr[0] = 10, 그 다음 i = 1
arr[++i] = 20;  // i = 2, 그 다음 arr[2] = 20 (arr[1]은 건너뜀!)

실무 권장:
- for문: i++ 사용 (관례)
- 복잡한 표현식: 피하기
- 가독성 우선

성능:
- 기본 타입: 차이 없음
- 객체: ++i가 약간 빠름 (극미세)
- 실무: 무시해도 됨

코드 리뷰:
// ✅ 명확함
i++;
result = arr[i];

// ❌ 혼란스러움
result = arr[i++];
```

꼬리 질문:
- for문에서 i+=2는?
- A: 2씩 증가. i++보다 명확할 때 사용
</details>

**Q7. 무한 루프를 의도적으로 사용하는 실무 사례는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
실무 사용 사례:

1. 서버 애플리케이션
while (true) {
    Socket client = serverSocket.accept();
    handleClient(client);
    // 종료 전까지 계속 실행
}

2. 게임 메인 루프
while (running) {
    processInput();
    updateGame();
    render();
    // 게임이 종료될 때까지
}

3. 이벤트 리스너
while (true) {
    Event event = eventQueue.poll();
    if (event != null) {
        handleEvent(event);
    }
    Thread.sleep(10);
}

4. 메뉴 시스템
while (true) {
    displayMenu();
    int choice = getChoice();
    if (choice == 0) break;
    processChoice(choice);
}

5. 작업 큐 처리
while (true) {
    Task task = queue.take();
    if (task == POISON_PILL) break;
    processTask(task);
}

필수 요소:

✅ 탈출 조건
while (true) {
    if (shouldStop) break;
    // 또는 return
}

✅ 적절한 대기
while (true) {
    doWork();
    Thread.sleep(1000);  // CPU 과부하 방지
}

✅ 예외 처리
while (true) {
    try {
        doWork();
    } catch (Exception e) {
        log.error("Error", e);
        // 계속 진행
    }
}

주의사항:

❌ 탈출구 없음
while (true) {
    doWork();  // 영원히 실행!
}

❌ CPU 과부하
while (true) {
    // 바쁜 대기 (busy waiting)
}

✅ 올바른 패턴
while (running) {
    if (hasWork()) {
        processWork();
    } else {
        Thread.sleep(100);  // 대기
    }
}

실무 팁:
- volatile boolean 사용
- graceful shutdown 구현
- 로깅으로 상태 추적
- 모니터링 추가
```

꼬리 질문:
- 무한 루프 종료는 어떻게?
- A: break, return, 또는 외부 플래그 변경
</details>

---

### 중급 개발자용 (심화 개념, 실무)

**Q1. 반복문 최적화 기법과 실무 적용 사례는?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
최적화 기법:

1. 루프 불변 코드 이동 (LICM)
❌ 비효율
for (int i = 0; i < n; i++) {
    int size = arr.length;  // 매번 계산
    int constant = x * y;   // 매번 계산
    arr[i] = size + constant;
}

✅ 효율
int size = arr.length;
int constant = x * y;
for (int i = 0; i < n; i++) {
    arr[i] = size + constant;
}

2. 강도 감소 (Strength Reduction)
❌ 비효율
for (int i = 0; i < n; i++) {
    result[i] = i * 5;  // 곱셈
}

✅ 효율
int sum = 0;
for (int i = 0; i < n; i++) {
    result[i] = sum;
    sum += 5;  // 덧셈 (더 빠름)
}

3. 루프 융합 (Loop Fusion)
❌ 비효율
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
}
for (int i = 0; i < n; i++) {
    c[i] = a[i] * 2;
}

✅ 효율
for (int i = 0; i < n; i++) {
    a[i] = b[i] + 1;
    c[i] = a[i] * 2;
}

4. 루프 언롤링 (Loop Unrolling)
❌ 일반
for (int i = 0; i < n; i++) {
    sum += arr[i];
}

✅ 언롤링 (컴파일러가 자동)
for (int i = 0; i < n; i += 4) {
    sum += arr[i];
    sum += arr[i+1];
    sum += arr[i+2];
    sum += arr[i+3];
}

5. 조기 종료
for (int i = 0; i < n; i++) {
    if (arr[i] == target) {
        result = i;
        break;  // 찾으면 중단
    }
}

실무 사례:

1. 이미지 처리
// 픽셀 순회
for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
        processPixel(x, y);
    }
}

2. 데이터베이스 배치
// 배치 처리 (1000개씩)
for (int i = 0; i < totalRecords; i += 1000) {
    List<Record> batch = records.subList(i,
        Math.min(i + 1000, totalRecords));
    processBatch(batch);
}

3. 캐시 효율
// ✅ 행 우선 (캐시 친화적)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        arr[i][j] = ...;
    }
}

// ❌ 열 우선 (캐시 미스)
for (int j = 0; j < m; j++) {
    for (int i = 0; i < n; i++) {
        arr[i][j] = ...;
    }
}

주의사항:
- 조기 최적화는 악의 근원
- 프로파일링 후 최적화
- JIT 컴파일러 신뢰
- 가독성 우선
```

</details>

**Q2. Stream API vs 전통 반복문, 실무에서의 선택 기준은?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
전통 반복문 vs Stream:

전통 반복문:
int sum = 0;
for (int num : numbers) {
    if (num > 0) {
        sum += num * 2;
    }
}

Stream API (Java 8+):
int sum = numbers.stream()
    .filter(num -> num > 0)
    .map(num -> num * 2)
    .mapToInt(Integer::intValue)
    .sum();

장단점 비교:

전통 반복문:
✅ 성능 (약간 빠름)
✅ 디버깅 쉬움
✅ 복잡한 로직
✅ 조기 종료 (break)
❌ 가독성 (길어지면)
❌ 병렬화 어려움

Stream API:
✅ 가독성 (선언적)
✅ 함수형 프로그래밍
✅ 병렬화 쉬움
✅ 체이닝
❌ 성능 (약간 느림)
❌ 디버깅 어려움
❌ 복잡한 상태 관리

실무 선택 기준:

전통 반복문 선택:
1. 성능 중요
for (int i = 0; i < huge.length; i++) {
    // 대량 데이터
}

2. 조기 종료 필요
for (int i = 0; i < arr.length; i++) {
    if (arr[i] == target) break;
}

3. 인덱스 필요
for (int i = 0; i < arr.length; i++) {
    result[i] = arr[i] * i;
}

4. 복잡한 상태
int count = 0;
for (...) {
    if (...) count++;
    else count--;
}

Stream 선택:
1. 간단한 변환
list.stream()
    .filter(x -> x > 0)
    .collect(Collectors.toList());

2. 집계 연산
int sum = list.stream()
    .mapToInt(Integer::intValue)
    .sum();

3. 병렬 처리
list.parallelStream()
    .map(this::heavyProcess)
    .collect(Collectors.toList());

4. 가독성 우선
// 명확한 의도
users.stream()
    .filter(User::isActive)
    .filter(User::isPremium)
    .map(User::getName)
    .collect(Collectors.toList());

성능 비교:
// 소량 데이터 (< 1000): 비슷
// 대량 데이터: 전통 반복문 약간 빠름
// 병렬 처리: Stream 유리

실무 권장:
- 간단한 변환: Stream
- 성능 중요: 전통 반복문
- 복잡한 로직: 전통 반복문
- 코드 리뷰: 팀 기준 따르기

병렬 Stream 주의:
// 작은 데이터는 오히려 느림
// 스레드 오버헤드
list.parallelStream()  // n > 10000일 때 고려
```

</details>

**Q3. 반복문에서 예외 처리는 어떻게 하나요?**

<details>
<summary>💡 모범 답안 포인트</summary>

```
예외 처리 패턴:

1. 루프 안에서 처리
for (String item : items) {
    try {
        processItem(item);
    } catch (Exception e) {
        log.error("Failed: " + item, e);
        // 계속 진행
    }
}

2. 루프 밖에서 처리
try {
    for (String item : items) {
        processItem(item);  // 예외 발생 시 중단
    }
} catch (Exception e) {
    log.error("Loop failed", e);
}

실무 패턴:

패턴 1: 부분 실패 허용
// 일부 실패해도 계속
List<Result> results = new ArrayList<>();
for (Task task : tasks) {
    try {
        Result r = task.execute();
        results.add(r);
    } catch (Exception e) {
        log.warn("Task failed: " + task, e);
        results.add(Result.FAILED);
        // 계속 진행
    }
}

패턴 2: 첫 실패 시 중단
try {
    for (File file : files) {
        processFile(file);  // 예외 전파
    }
} catch (IOException e) {
    log.error("File processing failed", e);
    throw new ProcessingException(e);
}

패턴 3: 재시도 로직
for (int i = 0; i < items.size(); i++) {
    Item item = items.get(i);
    int retries = 0;
    boolean success = false;

    while (!success && retries < MAX_RETRIES) {
        try {
            processItem(item);
            success = true;
        } catch (TransientException e) {
            retries++;
            log.warn("Retry " + retries, e);
            Thread.sleep(1000 * retries);
        } catch (PermanentException e) {
            log.error("Permanent failure", e);
            break;  // 재시도 안 함
        }
    }
}

패턴 4: 에러 수집
List<Exception> errors = new ArrayList<>();
for (String input : inputs) {
    try {
        validate(input);
    } catch (ValidationException e) {
        errors.add(e);
    }
}

if (!errors.isEmpty()) {
    throw new BatchValidationException(errors);
}

트랜잭션 고려:
// DB 배치 처리
try {
    connection.setAutoCommit(false);

    for (Record record : records) {
        updateDatabase(record);
    }

    connection.commit();  // 전체 성공
} catch (SQLException e) {
    connection.rollback();  // 전체 롤백
    throw e;
}

성능 고려:
// ❌ try-catch가 루프 밖
// 예외 발생 시 전체 중단

// ✅ try-catch가 루프 안
// 예외 발생해도 계속 처리
// 하지만 성능 오버헤드

실무 권장:
- 예외 드문 경우: 루프 밖
- 예외 빈번한 경우: 루프 안
- 부분 실패 허용: 루프 안
- 전체 성공 필요: 루프 밖
```

</details>

---

## 📊 핵심 내용 정리

### 반복문 비교표

| 구분 | while | for | do-while |
|------|-------|-----|----------|
| **구조** | while (조건) | for (초기화;조건;증감) | do...while (조건) |
| **실행** | 0회 이상 | 0회 이상 | 1회 이상 |
| **사용** | 조건 기반 | 횟수 기반 | 최소 1회 필요 |
| **비중** | 25% | 70% | 5% |

### 제어문 요약

```
break:     반복 즉시 종료
continue:  다음 반복으로 건너뛰기
return:    메서드 종료 (반복도 종료)
```

### 필수 체크리스트

- [ ] while문 사용 (조건 기반)
- [ ] for문 사용 (횟수 기반)
- [ ] 증감 연산자 올바르게 사용
- [ ] 무한 루프 방지
- [ ] 배열 인덱스 범위 확인 (< length)
- [ ] break/continue 적절히 사용
- [ ] 중첩 2단계로 제한
- [ ] 향상된 for문 활용 (인덱스 불필요 시)
- [ ] 성능 고려 (불필요한 연산 제거)
- [ ] 가독성 > 성능 (대부분)

---

## 🔗 관련 기술 스택

```
반복문 완료!
    ↓
┌───────┼───────┬───────┐
│       │       │       │
배열   메서드  컬렉션  알고리즘
[]     함수   List,    정렬,
              Map     탐색
```

**다음 장과의 연결:**
- 07장 배열: 반복문으로 배열 순회
- 08장 메서드: 반복 로직을 메서드로 추상화
- 25장 컬렉션: List, Set, Map 순회

---

## 🎯 다음 단계

**다음 장 예고:**
- 📘 07장: 배열
- 배열 선언과 초기화
- 배열 순회
- 다차원 배열
- 배열 활용 패턴

**지금 당장 해볼 것:**
1. ✅ 구구단 전체 출력
2. ✅ 1~100 소수 찾기
3. ✅ 별 찍기 패턴 10개
4. ✅ 숫자 맞추기 게임 완성
5. ✅ 무한 루프 만들고 탈출하기

---

## 📚 추가 학습 자료

### 📖 공식 문서
- [Oracle Java Tutorial - Control Flow](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/flow.html)
- [Java Language Specification - Statements](https://docs.oracle.com/javase/specs/jls/se17/html/jls-14.html)

### 🎥 추천 영상
- [Java 반복문 완벽 가이드](https://youtube.com)
- [알고리즘과 반복문](https://youtube.com)

### 📝 연습 문제
- [프로그래머스 - 반복문](https://programmers.co.kr/)
- [백준 - for문, while문](https://www.acmicpc.net/)

---

## 🎉 축하합니다!

**06장 반복문 학습을 완료하셨습니다!**

### 이제 여러분은:

✅ **while문**으로 조건 기반 반복을 구현할 수 있습니다
✅ **for문**으로 정해진 횟수만큼 효율적으로 반복할 수 있습니다
✅ **do-while문**으로 최소 1회 실행을 보장할 수 있습니다
✅ **중첩 반복문**으로 다차원 데이터를 처리할 수 있습니다
✅ **break/continue**로 반복 흐름을 제어할 수 있습니다
✅ **무한 루프**를 안전하게 사용할 수 있습니다
✅ **실무 반복문 패턴**을 적용할 수 있습니다

### 학습 완료 체크리스트

#### 기본 개념 (필수)
- [ ] while문의 구조와 사용법 이해
- [ ] for문의 구조와 사용법 이해
- [ ] do-while문과 while문의 차이 이해
- [ ] break와 continue의 차이 이해
- [ ] 무한 루프의 위험성과 활용법 이해

#### 실습 (필수)
- [ ] 1부터 100까지 합 계산 (for문)
- [ ] 구구단 전체 출력 (중첩 반복문)
- [ ] 별 찍기 패턴 3가지 이상 구현
- [ ] 배열 순회 및 검색 구현
- [ ] 숫자 맞추기 게임 완성

#### 실수 방지 (필수)
- [ ] off-by-one 오류 방지 (< vs <=)
- [ ] 무한 루프 방지 (증감 연산 필수)
- [ ] 배열 인덱스 범위 체크
- [ ] 변수 스코프 이해
- [ ] 성능 고려 (중첩 깊이 제한)

#### 면접 대비 (권장)
- [ ] while vs for 차이 설명
- [ ] break vs continue 차이 설명
- [ ] 무한 루프 발생 원인 3가지
- [ ] 시간 복잡도 (O(n), O(n²)) 이해
- [ ] 실무 활용 사례 3가지 숙지

#### 심화 학습 (선택)
- [ ] Stream API와 전통 반복문 비교
- [ ] 반복문 최적화 기법 학습
- [ ] Label 사용법 이해
- [ ] 병렬 처리 개념 이해
- [ ] 알고리즘 문제 10개 이상 풀이

### 다음 단계

**즉시 실습해보세요:**
1. ✅ 백준 또는 프로그래머스에서 반복문 문제 5개 풀기
2. ✅ 자신만의 미니 게임 만들기 (가위바위보, 로또 번호 생성 등)
3. ✅ 배열과 반복문을 결합한 프로그램 만들기
4. ✅ 성능 측정 프로그램 작성 (1중 vs 2중 vs 3중 반복문)
5. ✅ 실무 패턴을 활용한 데이터 처리 프로그램 작성

**다음 장 예고: 07장 배열**
- 배열이 왜 필요한가?
- 배열 선언과 초기화
- 배열과 반복문의 완벽한 조합
- 다차원 배열
- 배열 실무 활용 패턴
- 실전 프로젝트: 성적 관리 시스템

### 학습 시간 기록

- **이 장 학습 시작**: ___월 ___일 ___시
- **이 장 학습 완료**: ___월 ___일 ___시
- **총 소요 시간**: ___시간 ___분
- **복습 예정일**: ___월 ___일

### 자기 평가

**이해도 체크** (5점 만점):
- while문: ⭐⭐⭐⭐⭐
- for문: ⭐⭐⭐⭐⭐
- do-while문: ⭐⭐⭐⭐⭐
- 중첩 반복문: ⭐⭐⭐⭐⭐
- break/continue: ⭐⭐⭐⭐⭐

**어려웠던 부분**:
- ______________________________
- ______________________________
- ______________________________

**다시 복습할 부분**:
- ______________________________
- ______________________________
- ______________________________

---

**💬 학습 후기를 남겨주세요!**

이 장에서 가장 유익했던 부분은 무엇인가요?
개선이 필요한 부분이 있다면 알려주세요.

---

**🎊 반복문 마스터를 축하합니다!**
**이제 Java 프로그래밍의 핵심 도구를 손에 넣었습니다!**

**다음 단계로 이동**: [→ 07장: 배열](07-배열.md)

**이전 장 복습**: [← 05장: 조건문](05-조건문.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)

---

**마지막 당부:**

> "반복문은 프로그래밍의 근육입니다.
> 매일 조금씩 연습하면 자연스럽게 손에 익습니다.
> 100줄의 반복 코드보다 5줄의 반복문이 더 강력합니다.
> 계속 전진하세요!"

**Happy Coding! 🚀**
