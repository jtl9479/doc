# 17-3. 다형성 (Polymorphism) - Part 3

## 📋 목차
1. [실전 프로젝트: 쇼핑몰 통합 결제 시스템](#실전-프로젝트)
2. [FAQ](#faq)
3. [면접 질문](#면접-질문)

---

## 💳 실전 프로젝트: 쇼핑몰 통합 결제 시스템 {#실전-프로젝트}

### 프로젝트 개요
온라인 쇼핑몰에서 신용카드, 계좌이체, 카카오페이, 네이버페이, 토스, 페이팔 등 다양한 결제 수단을 통합 관리하는 시스템을 구현합니다. 다형성을 활용하여 결제 수단이 추가되어도 기존 코드 수정 없이 확장 가능한 구조를 만듭니다.

### 요구사항

#### 기능적 요구사항
1. 다양한 결제 수단 지원
2. 결제 수단별 수수료 계산
3. 결제 승인/취소 처리
4. 할부/포인트 적용
5. 결제 내역 관리

#### 비기능적 요구사항
1. 확장 가능한 구조 (새로운 결제 수단 추가 용이)
2. 타입 안전성
3. 코드 재사용성
4. 유지보수 용이성

### 전체 코드 구현

```java
/**
 * 모든 결제 수단의 부모 클래스
 */
public abstract class PaymentMethod {
    protected String paymentId;
    protected String paymentName;
    protected long amount;
    protected String status;  // PENDING, PROCESSING, APPROVED, CANCELLED, FAILED

    public PaymentMethod(String paymentId, String paymentName) {
        this.paymentId = paymentId;
        this.paymentName = paymentName;
        this.status = "PENDING";
    }

    // 추상 메서드 - 각 결제 수단마다 다른 처리 방식
    public abstract boolean processPayment(long amount);
    public abstract boolean cancelPayment();
    public abstract long calculateFee(long amount);
    public abstract String getPaymentType();
    public abstract void showPaymentDetails();

    public String getStatus() {
        return status;
    }

    protected String formatAmount(long amount) {
        return String.format("%,d", amount) + "원";
    }
}

/**
 * 신용카드 결제
 */
public class CreditCardPayment extends PaymentMethod {
    private String cardNumber;
    private String cardHolder;
    private String expiryDate;
    private String cvv;
    private String cardType;  // VISA, MASTER, AMEX
    private int installmentMonths;

    public CreditCardPayment(String paymentId, String cardNumber, String cardHolder,
                            String expiryDate, String cvv, String cardType) {
        super(paymentId, "신용카드");
        this.cardNumber = maskCardNumber(cardNumber);
        this.cardHolder = cardHolder;
        this.expiryDate = expiryDate;
        this.cvv = cvv;
        this.cardType = cardType;
        this.installmentMonths = 0;
    }

    @Override
    public boolean processPayment(long amount) {
        System.out.println("\n💳 신용카드 결제 처리");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        this.amount = amount;
        status = "PROCESSING";

        // 카드 유효성 검증
        System.out.println("1. 카드 유효성 검증...");
        if (!validateCard()) {
            status = "FAILED";
            System.out.println("❌ 카드 유효성 검증 실패");
            return false;
        }
        System.out.println("   ✅ 카드 유효");

        // 한도 확인
        System.out.println("2. 한도 확인...");
        System.out.println("   ✅ 한도 충분");

        // PG사 승인 요청
        System.out.println("3. PG사 승인 요청...");
        String approvalNumber = generateApprovalNumber();
        System.out.println("   ✅ 승인번호: " + approvalNumber);

        // 할부 정보
        if (installmentMonths > 0) {
            long monthlyPayment = amount / installmentMonths;
            System.out.println("4. 할부: " + installmentMonths + "개월");
            System.out.println("   월 납입액: " + formatAmount(monthlyPayment));
        }

        status = "APPROVED";
        System.out.println("\n✅ 결제 승인 완료");
        System.out.println("결제 금액: " + formatAmount(amount));

        return true;
    }

    @Override
    public boolean cancelPayment() {
        if (!status.equals("APPROVED")) {
            System.out.println("❌ 취소할 수 없는 상태입니다: " + status);
            return false;
        }

        System.out.println("\n🔄 신용카드 결제 취소");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("취소 금액: " + formatAmount(amount));

        status = "CANCELLED";
        System.out.println("✅ 취소 완료 (3-5영업일 내 환불)");

        return true;
    }

    @Override
    public long calculateFee(long amount) {
        // 신용카드 수수료: 2.5%
        // 해외 카드는 추가 1%
        double feeRate = 0.025;

        if (cardType.equals("AMEX")) {
            feeRate += 0.01;  // AMEX는 수수료 높음
        }

        return (long)(amount * feeRate);
    }

    @Override
    public String getPaymentType() {
        return "신용카드 (" + cardType + ")";
    }

    @Override
    public void showPaymentDetails() {
        System.out.println("\n💳 결제 상세");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제 수단: " + getPaymentType());
        System.out.println("카드번호: " + cardNumber);
        System.out.println("카드 소유자: " + cardHolder);
        System.out.println("유효기간: " + expiryDate);
        System.out.println("결제 금액: " + formatAmount(amount));
        System.out.println("수수료: " + formatAmount(calculateFee(amount)));

        if (installmentMonths > 0) {
            System.out.println("할부: " + installmentMonths + "개월");
        }

        System.out.println("상태: " + status);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void setInstallment(int months) {
        this.installmentMonths = months;
    }

    private boolean validateCard() {
        // 실제로는 Luhn 알고리즘 등으로 검증
        return cardNumber.length() >= 16 && !expiryDate.isEmpty() && cvv.length() == 3;
    }

    private String maskCardNumber(String cardNumber) {
        if (cardNumber.length() >= 16) {
            return cardNumber.substring(0, 4) + "-****-****-" + cardNumber.substring(12);
        }
        return cardNumber;
    }

    private String generateApprovalNumber() {
        return "AP" + System.currentTimeMillis() % 100000000;
    }
}

/**
 * 계좌이체 결제
 */
public class BankTransferPayment extends PaymentMethod {
    private String bankName;
    private String accountNumber;
    private String accountHolder;
    private boolean isCmsAgreed;  // 자동이체 동의

    public BankTransferPayment(String paymentId, String bankName,
                               String accountNumber, String accountHolder) {
        super(paymentId, "계좌이체");
        this.bankName = bankName;
        this.accountNumber = maskAccountNumber(accountNumber);
        this.accountHolder = accountHolder;
        this.isCmsAgreed = false;
    }

    @Override
    public boolean processPayment(long amount) {
        System.out.println("\n🏦 계좌이체 결제 처리");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        this.amount = amount;
        status = "PROCESSING";

        // 계좌 유효성 검증
        System.out.println("1. 계좌 유효성 검증...");
        System.out.println("   은행: " + bankName);
        System.out.println("   계좌: " + accountNumber);
        System.out.println("   ✅ 계좌 확인 완료");

        // 잔액 확인
        System.out.println("2. 잔액 확인...");
        System.out.println("   ✅ 잔액 충분");

        // 이체 실행
        System.out.println("3. 이체 실행 중...");
        System.out.println("   송금인: " + accountHolder);
        System.out.println("   금액: " + formatAmount(amount));

        status = "APPROVED";
        System.out.println("\n✅ 이체 완료");

        return true;
    }

    @Override
    public boolean cancelPayment() {
        if (!status.equals("APPROVED")) {
            System.out.println("❌ 취소할 수 없는 상태입니다: " + status);
            return false;
        }

        System.out.println("\n🔄 계좌이체 취소");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("환불 금액: " + formatAmount(amount));
        System.out.println("환불 계좌: " + accountNumber);

        status = "CANCELLED";
        System.out.println("✅ 환불 처리 완료 (즉시 입금)");

        return true;
    }

    @Override
    public long calculateFee(long amount) {
        // 계좌이체 수수료: 500원 고정
        return 500;
    }

    @Override
    public String getPaymentType() {
        return "계좌이체 (" + bankName + ")";
    }

    @Override
    public void showPaymentDetails() {
        System.out.println("\n🏦 결제 상세");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제 수단: " + getPaymentType());
        System.out.println("계좌번호: " + accountNumber);
        System.out.println("예금주: " + accountHolder);
        System.out.println("결제 금액: " + formatAmount(amount));
        System.out.println("수수료: " + formatAmount(calculateFee(amount)));
        System.out.println("상태: " + status);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    private String maskAccountNumber(String accountNumber) {
        if (accountNumber.length() >= 10) {
            return accountNumber.substring(0, 3) + "-****-" +
                   accountNumber.substring(accountNumber.length() - 3);
        }
        return accountNumber;
    }
}

/**
 * 간편결제 (카카오페이, 네이버페이, 토스 등)
 */
public class SimplePayment extends PaymentMethod {
    private String provider;  // KAKAO, NAVER, TOSS
    private String userId;
    private boolean hasBiometric;
    private int pointsToUse;

    public SimplePayment(String paymentId, String provider, String userId) {
        super(paymentId, "간편결제");
        this.provider = provider;
        this.userId = userId;
        this.hasBiometric = true;
        this.pointsToUse = 0;
    }

    @Override
    public boolean processPayment(long amount) {
        System.out.println("\n📱 " + getProviderName() + " 결제 처리");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        this.amount = amount;
        status = "PROCESSING";

        // 생체 인증
        if (hasBiometric) {
            System.out.println("1. 생체 인증...");
            System.out.println("   🔐 지문 인증 성공");
        }

        // 포인트 사용
        long finalAmount = amount;
        if (pointsToUse > 0) {
            finalAmount = amount - pointsToUse;
            System.out.println("2. 포인트 사용: " + formatAmount(pointsToUse));
        }

        // 결제 승인
        System.out.println("3. 결제 승인 요청...");
        System.out.println("   최종 결제: " + formatAmount(finalAmount));

        status = "APPROVED";
        System.out.println("\n✅ 결제 완료");

        // 포인트 적립
        long earnedPoints = amount / 100;  // 1% 적립
        System.out.println("💰 적립 포인트: " + earnedPoints + "P");

        return true;
    }

    @Override
    public boolean cancelPayment() {
        if (!status.equals("APPROVED")) {
            System.out.println("❌ 취소할 수 없는 상태입니다: " + status);
            return false;
        }

        System.out.println("\n🔄 " + getProviderName() + " 결제 취소");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("취소 금액: " + formatAmount(amount));

        if (pointsToUse > 0) {
            System.out.println("포인트 복구: " + pointsToUse + "P");
        }

        status = "CANCELLED";
        System.out.println("✅ 취소 완료 (즉시 환불)");

        return true;
    }

    @Override
    public long calculateFee(long amount) {
        // 간편결제 수수료: 3.3%
        return (long)(amount * 0.033);
    }

    @Override
    public String getPaymentType() {
        return "간편결제 (" + getProviderName() + ")";
    }

    @Override
    public void showPaymentDetails() {
        System.out.println("\n📱 결제 상세");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제 수단: " + getPaymentType());
        System.out.println("사용자 ID: " + userId);
        System.out.println("결제 금액: " + formatAmount(amount));

        if (pointsToUse > 0) {
            System.out.println("포인트 사용: " + pointsToUse + "P");
            System.out.println("실결제: " + formatAmount(amount - pointsToUse));
        }

        System.out.println("수수료: " + formatAmount(calculateFee(amount)));
        System.out.println("생체 인증: " + (hasBiometric ? "활성화" : "비활성화"));
        System.out.println("상태: " + status);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void usePoints(int points) {
        this.pointsToUse = points;
    }

    private String getProviderName() {
        switch (provider) {
            case "KAKAO": return "카카오페이";
            case "NAVER": return "네이버페이";
            case "TOSS": return "토스";
            default: return provider;
        }
    }
}

/**
 * 해외 결제 (PayPal)
 */
public class PayPalPayment extends PaymentMethod {
    private String email;
    private String currency;  // USD, EUR, JPY 등
    private double exchangeRate;

    public PayPalPayment(String paymentId, String email, String currency, double exchangeRate) {
        super(paymentId, "PayPal");
        this.email = email;
        this.currency = currency;
        this.exchangeRate = exchangeRate;
    }

    @Override
    public boolean processPayment(long amount) {
        System.out.println("\n🌐 PayPal 결제 처리");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        this.amount = amount;
        status = "PROCESSING";

        // 환율 적용
        double foreignAmount = amount / exchangeRate;
        System.out.println("1. 환율 적용...");
        System.out.println("   KRW: " + formatAmount(amount));
        System.out.println("   " + currency + ": " + String.format("%.2f", foreignAmount));
        System.out.println("   환율: " + exchangeRate);

        // PayPal 인증
        System.out.println("2. PayPal 계정 인증...");
        System.out.println("   이메일: " + email);
        System.out.println("   ✅ 인증 완료");

        // 결제 승인
        System.out.println("3. 결제 승인...");

        status = "APPROVED";
        System.out.println("\n✅ 결제 완료");

        return true;
    }

    @Override
    public boolean cancelPayment() {
        if (!status.equals("APPROVED")) {
            System.out.println("❌ 취소할 수 없는 상태입니다: " + status);
            return false;
        }

        System.out.println("\n🔄 PayPal 결제 취소");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        double foreignAmount = amount / exchangeRate;
        System.out.println("환불 금액: " + String.format("%.2f", foreignAmount) + " " + currency);
        System.out.println("(약 " + formatAmount(amount) + ")");

        status = "CANCELLED";
        System.out.println("✅ 환불 처리 중 (2-3일 소요)");

        return true;
    }

    @Override
    public long calculateFee(long amount) {
        // PayPal 수수료: 4.4% + 환전 수수료 1%
        return (long)(amount * 0.054);
    }

    @Override
    public String getPaymentType() {
        return "PayPal (" + currency + ")";
    }

    @Override
    public void showPaymentDetails() {
        System.out.println("\n🌐 결제 상세");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제 수단: " + getPaymentType());
        System.out.println("PayPal 이메일: " + email);
        System.out.println("결제 금액 (KRW): " + formatAmount(amount));

        double foreignAmount = amount / exchangeRate;
        System.out.println("결제 금액 (" + currency + "): " + String.format("%.2f", foreignAmount));
        System.out.println("환율: " + exchangeRate);
        System.out.println("수수료: " + formatAmount(calculateFee(amount)));
        System.out.println("상태: " + status);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 쇼핑몰 결제 시스템

```java
/**
 * 주문 정보
 */
class Order {
    private String orderId;
    private String customerId;
    private long totalAmount;
    private List<String> items;

    public Order(String orderId, String customerId, long totalAmount) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.totalAmount = totalAmount;
        this.items = new ArrayList<>();
    }

    public void addItem(String item) {
        items.add(item);
    }

    public String getOrderId() {
        return orderId;
    }

    public String getCustomerId() {
        return customerId;
    }

    public long getTotalAmount() {
        return totalAmount;
    }

    public List<String> getItems() {
        return items;
    }

    public void showOrderSummary() {
        System.out.println("\n📦 주문 요약");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("주문번호: " + orderId);
        System.out.println("고객ID: " + customerId);
        System.out.println("상품 목록:");

        for (String item : items) {
            System.out.println("  - " + item);
        }

        System.out.println("총 금액: " + String.format("%,d", totalAmount) + "원");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 쇼핑몰 결제 시스템 - 다형성 활용
 */
public class PaymentSystem {
    private String systemName;
    private List<PaymentMethod> paymentHistory;
    private long totalRevenue;
    private long totalFees;

    public PaymentSystem(String systemName) {
        this.systemName = systemName;
        this.paymentHistory = new ArrayList<>();
        this.totalRevenue = 0;
        this.totalFees = 0;
    }

    /**
     * 결제 처리 - 다형성의 핵심!
     * PaymentMethod 타입으로 모든 결제 수단 처리
     */
    public boolean processOrder(Order order, PaymentMethod paymentMethod) {
        System.out.println("\n💳 ═══════════════════════════");
        System.out.println("   " + systemName);
        System.out.println("═══════════════════════════");

        // 주문 요약
        order.showOrderSummary();

        // 결제 수단 정보
        System.out.println("\n💰 결제 수단: " + paymentMethod.getPaymentType());

        // 수수료 계산
        long fee = paymentMethod.calculateFee(order.getTotalAmount());
        long finalAmount = order.getTotalAmount() + fee;

        System.out.println("주문 금액: " + String.format("%,d", order.getTotalAmount()) + "원");
        System.out.println("결제 수수료: " + String.format("%,d", fee) + "원");
        System.out.println("최종 결제: " + String.format("%,d", finalAmount) + "원");

        // 결제 처리 (다형성!)
        boolean success = paymentMethod.processPayment(finalAmount);

        if (success) {
            // 결제 내역 저장
            paymentHistory.add(paymentMethod);
            totalRevenue += order.getTotalAmount();
            totalFees += fee;

            System.out.println("\n✅ 주문이 완료되었습니다!");
            System.out.println("주문번호: " + order.getOrderId());
        } else {
            System.out.println("\n❌ 결제 실패!");
        }

        return success;
    }

    /**
     * 결제 취소
     */
    public boolean cancelOrder(PaymentMethod paymentMethod) {
        System.out.println("\n🔄 ═══════════════════════════");
        System.out.println("   결제 취소 요청");
        System.out.println("═══════════════════════════");

        // 결제 취소 처리 (다형성!)
        boolean success = paymentMethod.cancelPayment();

        if (success) {
            System.out.println("\n✅ 취소가 완료되었습니다!");
        }

        return success;
    }

    /**
     * 결제 상세 조회
     */
    public void showPaymentDetails(PaymentMethod paymentMethod) {
        // 다형성! 각 결제 수단에 맞는 상세 정보 표시
        paymentMethod.showPaymentDetails();
    }

    /**
     * 결제 수단별 통계
     */
    public void showStatistics() {
        System.out.println("\n📊 결제 통계");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        Map<String, Integer> paymentCounts = new HashMap<>();
        Map<String, Long> paymentAmounts = new HashMap<>();

        for (PaymentMethod payment : paymentHistory) {
            String type = payment.getPaymentType();
            paymentCounts.put(type, paymentCounts.getOrDefault(type, 0) + 1);
            paymentAmounts.put(type,
                paymentAmounts.getOrDefault(type, 0L) + payment.amount);
        }

        System.out.println("총 거래 건수: " + paymentHistory.size());
        System.out.println("총 매출: " + String.format("%,d", totalRevenue) + "원");
        System.out.println("총 수수료: " + String.format("%,d", totalFees) + "원");

        System.out.println("\n결제 수단별:");
        for (String type : paymentCounts.keySet()) {
            System.out.println("- " + type + ": " +
                             paymentCounts.get(type) + "건, " +
                             String.format("%,d", paymentAmounts.get(type)) + "원");
        }

        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    /**
     * 결제 수단 비교
     */
    public void comparePaymentMethods(long amount) {
        System.out.println("\n💰 결제 수단 비교 (" + String.format("%,d", amount) + "원 결제 시)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        PaymentMethod[] methods = {
            new CreditCardPayment("test1", "1234567890123456", "홍길동",
                                "12/25", "123", "VISA"),
            new BankTransferPayment("test2", "국민은행", "12345678901", "홍길동"),
            new SimplePayment("test3", "KAKAO", "user123"),
            new PayPalPayment("test4", "user@example.com", "USD", 1300.0)
        };

        for (PaymentMethod method : methods) {
            long fee = method.calculateFee(amount);
            System.out.println(String.format("%-20s 수수료: %,10d원 (%.2f%%)",
                method.getPaymentType(), fee, (fee / (double)amount * 100)));
        }

        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 실행 테스트

```java
public class ShoppingMallTest {
    public static void main(String[] args) {
        System.out.println("🛒 ═══════════════════════════════");
        System.out.println("   쇼핑몰 통합 결제 시스템");
        System.out.println("═══════════════════════════════\n");

        // 결제 시스템 생성
        PaymentSystem paymentSystem = new PaymentSystem("마켓컬리");

        // 주문 1: 신용카드 결제 (할부)
        Order order1 = new Order("ORD-001", "user123", 350000);
        order1.addItem("노트북 파우치");
        order1.addItem("무선 마우스");
        order1.addItem("키보드");

        CreditCardPayment creditCard = new CreditCardPayment(
            "PAY-001",
            "1234567890123456",
            "김민수",
            "12/25",
            "123",
            "VISA"
        );
        creditCard.setInstallment(3);  // 3개월 할부

        paymentSystem.processOrder(order1, creditCard);
        paymentSystem.showPaymentDetails(creditCard);

        // 주문 2: 계좌이체 결제
        Order order2 = new Order("ORD-002", "user456", 125000);
        order2.addItem("유기농 과일 세트");
        order2.addItem("생수 2박스");

        BankTransferPayment bankTransfer = new BankTransferPayment(
            "PAY-002",
            "국민은행",
            "12345678901",
            "이영희"
        );

        paymentSystem.processOrder(order2, bankTransfer);

        // 주문 3: 간편결제 (포인트 사용)
        Order order3 = new Order("ORD-003", "user789", 85000);
        order3.addItem("샐러드");
        order3.addItem("닭가슴살");

        SimplePayment kakao = new SimplePayment("PAY-003", "KAKAO", "user789");
        kakao.usePoints(5000);  // 5000P 사용

        paymentSystem.processOrder(order3, kakao);

        // 주문 4: PayPal 결제
        Order order4 = new Order("ORD-004", "user321", 230000);
        order4.addItem("수입 와인");
        order4.addItem("치즈 세트");

        PayPalPayment paypal = new PayPalPayment(
            "PAY-004",
            "user@example.com",
            "USD",
            1300.0
        );

        paymentSystem.processOrder(order4, paypal);

        // 결제 취소 테스트
        System.out.println("\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("결제 취소 시나리오");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        paymentSystem.cancelOrder(bankTransfer);

        // 통계
        paymentSystem.showStatistics();

        // 결제 수단 비교
        paymentSystem.comparePaymentMethods(100000);

        // 다형성의 강력함 시연
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   다형성 활용 예시");
        System.out.println("═══════════════════════════\n");

        PaymentMethod[] allPayments = {creditCard, bankTransfer, kakao, paypal};

        System.out.println("모든 결제 수단 정보:");
        for (PaymentMethod payment : allPayments) {
            System.out.println("\n[" + payment.getPaymentType() + "]");
            System.out.println("- 상태: " + payment.getStatus());
            System.out.println("- 100,000원 결제 시 수수료: " +
                             String.format("%,d", payment.calculateFee(100000)) + "원");
        }

        System.out.println("\n\n💡 다형성의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ PaymentMethod 타입으로 모든 결제 수단 통합 처리");
        System.out.println("✅ 결제 수단별 다른 처리 방식 자동 적용");
        System.out.println("✅ 새로운 결제 수단 추가 시 기존 코드 수정 불필요");
        System.out.println("✅ 수수료 계산, 승인, 취소 로직이 각자 독립적");
        System.out.println("✅ 실제 쇼핑몰의 핵심 설계 패턴!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 프로젝트 핵심 포인트

#### 1. 다형성 활용
```java
// 하나의 메서드로 모든 결제 수단 처리
public boolean processOrder(Order order, PaymentMethod paymentMethod) {
    // PaymentMethod 타입으로 받지만
    // 실제로는 CreditCard, BankTransfer, SimplePay 등의 메서드가 호출됨
    paymentMethod.processPayment(amount);  // 다형성!
    paymentMethod.calculateFee(amount);    // 다형성!
}
```

#### 2. 확장성
새로운 결제 수단 추가 시:
- `PaymentMethod`를 상속받는 새 클래스만 작성
- `PaymentSystem` 코드는 전혀 수정 불필요
- Open-Closed Principle (OCP) 준수

#### 3. 타입 안전성
- 컴파일 타임에 타입 체크
- 런타임 에러 최소화
- instanceof로 안전한 다운캐스팅

#### 4. 유지보수성
- 각 결제 수단의 로직이 독립적
- 수정 시 해당 클래스만 변경
- 사이드 이펙트 최소화

---

## ❓ FAQ {#faq}

### Q1. 다형성과 메서드 오버로딩의 차이는?

**A:** 완전히 다른 개념입니다!

```java
// 메서드 오버로딩 (컴파일타임 다형성)
class Calculator {
    public int add(int a, int b) { return a + b; }
    public double add(double a, double b) { return a + b; }  // 오버로딩
}

// 다형성 (런타임 다형성)
class Animal {
    public void makeSound() { }
}

class Dog extends Animal {
    @Override
    public void makeSound() { }  // 오버라이딩
}

Animal animal = new Dog();
animal.makeSound();  // Dog의 메서드 호출 - 다형성!
```

**차이점:**
- **오버로딩**: 같은 이름, 다른 매개변수, 컴파일 시 결정
- **다형성**: 상속 관계, 메서드 오버라이딩, 런타임 시 결정

---

### Q2. 다형성을 사용하면 성능이 느려지나요?

**A:** 미세하게 느릴 수 있지만 실무에서는 무시할 수준입니다.

```java
// 다형성 사용 시
Animal animal = new Dog();
animal.makeSound();  // 동적 바인딩 (런타임에 메서드 결정)

// 다형성 미사용 시
Dog dog = new Dog();
dog.makeSound();  // 정적 바인딩 (컴파일 시 결정)
```

**성능 차이:**
- 다형성 사용 시 가상 메서드 테이블(vtable) 조회 발생
- 나노초 단위의 차이 (보통 무시 가능)
- JIT 컴파일러가 최적화

**결론:**
- 성능보다 **설계의 유연성**이 훨씬 중요
- 실제 병목은 다형성이 아닌 I/O, DB 쿼리 등

---

### Q3. 언제 다형성을 사용해야 하나요?

**A:** 다음과 같은 상황에서 사용하세요:

#### 사용해야 할 때 ✅
```java
// 1. 비슷한 객체들을 통일된 방식으로 처리
PaymentMethod[] payments = {creditCard, bankTransfer, kakao};
for (PaymentMethod payment : payments) {
    payment.process();  // 다형성!
}

// 2. 코드 확장이 예상될 때
// 새로운 결제 수단 추가 시 기존 코드 수정 불필요

// 3. 전략 패턴, 팩토리 패턴 등에서
Strategy strategy = getStrategy(type);
strategy.execute();
```

#### 사용하지 말아야 할 때 ❌
```java
// 1. 단순한 유틸리티 메서드
public static int add(int a, int b) {
    return a + b;  // 다형성 불필요
}

// 2. 상속 관계가 없는 경우
// 억지로 상속 구조를 만들지 마세요
```

---

### Q4. instanceof 사용이 안티패턴인가요?

**A:** 상황에 따라 다릅니다.

#### 안티패턴인 경우 ❌
```java
// 나쁜 예 - 다형성을 사용해야 할 곳에 instanceof 남발
public void process(Animal animal) {
    if (animal instanceof Dog) {
        ((Dog) animal).bark();
    } else if (animal instanceof Cat) {
        ((Cat) animal).meow();
    } else if (animal instanceof Bird) {
        ((Bird) animal).chirp();
    }
    // 새로운 동물 추가 시 이 메서드를 계속 수정해야 함!
}

// 좋은 예 - 다형성 활용
public void process(Animal animal) {
    animal.makeSound();  // 각 동물이 알아서 처리
}
```

#### 정당한 사용 ✅
```java
// 좋은 예 - 특정 타입의 고유 기능 사용 시
public void processLiveStream(YouTubeContent content) {
    content.play();  // 공통 기능

    // LiveStream만의 특별한 기능
    if (content instanceof LiveStream) {
        LiveStream stream = (LiveStream) content;
        stream.sendSuperChat("응원합니다!", 5000);
    }
}
```

**원칙:**
- 공통 기능은 다형성으로
- 특정 타입 고유 기능만 instanceof 사용

---

### Q5. 다형성 배열에서 자식 고유 메서드를 호출하려면?

**A:** instanceof로 타입 확인 후 다운캐스팅하세요.

```java
Animal[] animals = {new Dog("바둑이"), new Cat("나비"), new Bird("짹짹이")};

// 방법 1: instanceof + 다운캐스팅
for (Animal animal : animals) {
    animal.makeSound();  // 공통 메서드

    // 개만 꼬리 흔들기
    if (animal instanceof Dog) {
        Dog dog = (Dog) animal;
        dog.wagTail();  // Dog 고유 메서드
    }
}

// 방법 2: Pattern Matching (Java 16+)
for (Animal animal : animals) {
    animal.makeSound();

    if (animal instanceof Dog dog) {  // 자동으로 dog 변수 생성
        dog.wagTail();
    }
}

// 방법 3: 더 나은 설계 - 공통 메서드로 만들기
abstract class Animal {
    public abstract void makeSound();
    public void doSpecialAction() {  // 기본 구현
        // 특별한 행동 없음
    }
}

class Dog extends Animal {
    @Override
    public void doSpecialAction() {
        wagTail();  // 꼬리 흔들기
    }
}

// 이제 다형성으로 모두 처리 가능
for (Animal animal : animals) {
    animal.makeSound();
    animal.doSpecialAction();  // 각 동물이 자신의 특별 행동
}
```

---

### Q6. final 메서드와 다형성의 관계는?

**A:** final 메서드는 오버라이딩할 수 없어 다형성이 제한됩니다.

```java
class Animal {
    // final 메서드 - 오버라이딩 불가
    public final void breathe() {
        System.out.println("숨을 쉽니다");
    }

    // 일반 메서드 - 오버라이딩 가능
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    // ❌ 컴파일 에러!
    @Override
    public void breathe() {  // final 메서드 오버라이딩 시도
        System.out.println("개가 숨쉽니다");
    }

    // ✅ OK
    @Override
    public void makeSound() {
        System.out.println("멍멍!");
    }
}
```

**final 사용 시기:**
- 보안상 중요한 메서드 (절대 변경 불가)
- 성능 최적화 (컴파일러가 인라인 가능)
- 템플릿 메서드 패턴에서 고정된 알고리즘

```java
abstract class GameCharacter {
    // 템플릿 메서드 - 고정된 실행 순서
    public final void performAction() {
        prepare();    // 다형성
        execute();    // 다형성
        cleanup();    // 다형성
    }

    protected abstract void prepare();
    protected abstract void execute();
    protected abstract void cleanup();
}
```

---

### Q7. 다형성과 제네릭의 차이는?

**A:** 목적과 동작 방식이 완전히 다릅니다.

```java
// 다형성 - 런타임에 타입 결정
Animal animal = new Dog();
animal.makeSound();  // 실행 시점에 Dog의 메서드 호출

// 제네릭 - 컴파일 타임에 타입 결정
List<String> names = new ArrayList<>();
names.add("홍길동");  // String만 가능 (컴파일 시 체크)
// names.add(123);  // 컴파일 에러
```

**차이점:**

| 구분 | 다형성 | 제네릭 |
|------|--------|--------|
| **목적** | 같은 코드로 다른 동작 | 같은 코드로 다른 타입 |
| **시점** | 런타임 | 컴파일 타임 |
| **상속** | 필요 | 불필요 |
| **타입 소거** | 없음 | 있음 (런타임에 타입 정보 사라짐) |

**함께 사용 예:**
```java
// 다형성 + 제네릭
class Container<T extends Animal> {  // 제네릭 + 상한 제한
    private T animal;

    public void makeAnimalSound() {
        animal.makeSound();  // 다형성!
    }
}

Container<Dog> dogContainer = new Container<>();
Container<Cat> catContainer = new Container<>();
```

---

## 🎤 면접 질문 {#면접-질문}

### 주니어 개발자 면접 질문 (7개)

#### Q1. 다형성이 무엇인지 실생활 비유를 들어 설명해주세요.

**예시 답변:**
```
다형성은 "하나의 리모컨으로 TV, 에어컨, 셋톱박스 등 여러 가전제품을 제어하는 것"에 비유할 수 있습니다.

리모컨의 '전원' 버튼을 누르면:
- TV는 화면을 켜고
- 에어컨은 냉방을 시작하고
- 셋톱박스는 부팅을 시작합니다

같은 버튼(메서드)을 누르지만, 실제 기기(객체)에 따라 다른 동작이 실행됩니다.
이것이 다형성의 핵심입니다.

Java 코드로 표현하면:
Appliance[] devices = {tv, ac, setTopBox};
for (Appliance device : devices) {
    device.powerOn();  // 각 기기마다 다른 방식으로 켜짐
}
```

**채점 포인트:**
- 개념 이해도 ✅
- 실생활 비유 능력 ✅
- 코드로 연결 ✅

---

#### Q2. 업캐스팅과 다운캐스팅의 차이를 설명하고, 언제 사용하는지 말해주세요.

**예시 답변:**
```
업캐스팅(Upcasting):
- 자식 → 부모 타입으로 형변환
- 자동으로 이루어짐 (명시적 캐스팅 불필요)
- 사용 시기: 여러 타입의 객체를 통일되게 처리할 때

Animal animal = new Dog();  // 업캐스팅 (자동)

다운캐스팅(Downcasting):
- 부모 → 자식 타입으로 형변환
- 명시적 캐스팅 필요
- instanceof로 타입 체크 필수
- 사용 시기: 자식 클래스 고유의 메서드를 호출할 때

if (animal instanceof Dog) {
    Dog dog = (Dog) animal;  // 다운캐스팅 (명시적)
    dog.bark();  // Dog만의 메서드
}
```

**주의사항:**
- 다운캐스팅 시 instanceof 체크 안 하면 ClassCastException 발생 가능
- 가능하면 다형성으로 해결하고, 다운캐스팅은 최소화

---

#### Q3. 다음 코드의 출력 결과를 예측하고 이유를 설명하세요.

```java
class Animal {
    public void makeSound() {
        System.out.println("동물 소리");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("멍멍");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.makeSound();
    }
}
```

**정답:**
```
출력: 멍멍

이유:
1. animal 변수의 타입은 Animal이지만, 실제 객체는 Dog입니다.
2. Java는 동적 바인딩(Dynamic Binding)을 사용합니다.
3. 런타임에 실제 객체 타입(Dog)의 메서드가 호출됩니다.
4. 따라서 Dog의 makeSound()가 실행되어 "멍멍"이 출력됩니다.

이것이 다형성의 핵심입니다!
```

**추가 질문 대비:**
- Q: 만약 Dog에 makeSound()가 없다면?
- A: Animal의 makeSound()가 호출되어 "동물 소리" 출력

---

#### Q4. 다형성 사용 시 장점과 단점을 각각 2가지씩 말해주세요.

**예시 답변:**
```
장점:
1. 코드 재사용성: 부모 타입 하나로 여러 자식 객체 처리 가능
   PaymentMethod[] payments = {card, bank, kakao};
   for (PaymentMethod p : payments) p.process();

2. 확장성(OCP): 새로운 타입 추가 시 기존 코드 수정 불필요
   새 결제 수단 추가 → PaymentMethod 상속만 하면 끝

단점:
1. 이해하기 어려움: 초보자는 "어떤 메서드가 호출될지" 혼란
   런타임에 결정되므로 디버깅도 어려움

2. 성능: 동적 바인딩으로 인한 미세한 오버헤드
   (하지만 실무에서는 무시할 수준)
```

---

#### Q5. instanceof를 사용하지 않고 타입별로 다른 처리를 하려면 어떻게 해야 하나요?

**예시 답변:**
```
방법 1: 다형성 활용 (가장 좋은 방법)
```java
abstract class Animal {
    public abstract void makeSound();
    public abstract void doSpecialAction();  // 공통 메서드로 만들기
}

class Dog extends Animal {
    public void doSpecialAction() {
        System.out.println("꼬리 흔들기");
    }
}

class Cat extends Animal {
    public void doSpecialAction() {
        System.out.println("그르릉 소리");
    }
}

// instanceof 없이 처리
Animal[] animals = {new Dog(), new Cat()};
for (Animal animal : animals) {
    animal.makeSound();
    animal.doSpecialAction();  // 각자 다른 동작
}
```

방법 2: Visitor 패턴 (고급)
```java
interface AnimalVisitor {
    void visit(Dog dog);
    void visit(Cat cat);
}

abstract class Animal {
    public abstract void accept(AnimalVisitor visitor);
}

class Dog extends Animal {
    public void accept(AnimalVisitor visitor) {
        visitor.visit(this);  // Double Dispatch
    }
}
```

---

#### Q6. 다형성을 사용한 실제 프로젝트 경험을 말해주세요.

**예시 답변 (학생/신입):**
```
학교 프로젝트에서 쇼핑몰 결제 시스템을 만들었습니다.

상황:
- 신용카드, 계좌이체, 카카오페이 등 여러 결제 수단 지원 필요
- 각 결제 수단마다 처리 방식, 수수료가 다름

해결:
1. PaymentMethod 추상 클래스 생성
2. 각 결제 수단을 자식 클래스로 구현
3. PaymentSystem에서 PaymentMethod 타입으로 통합 처리

결과:
- 새로운 결제 수단 추가 시 기존 코드 수정 불필요
- 테스트 코드 작성이 쉬워짐
- 유지보수성 향상

배운 점:
- 처음에는 if-else로 타입 구분했는데, 다형성 적용 후 코드가 훨씬 깔끔해짐
- 디자인 패턴(전략 패턴)의 중요성을 깨달음
```

---

#### Q7. 다형성과 인터페이스의 관계를 설명해주세요.

**예시 답변:**
```
다형성은 추상 클래스와 인터페이스 모두에서 구현 가능합니다.

추상 클래스로 다형성:
abstract class Animal {
    public abstract void makeSound();
}

Animal animal = new Dog();  // 다형성
animal.makeSound();

인터페이스로 다형성:
interface Drivable {
    void drive();
}

Drivable vehicle = new Car();  // 다형성
vehicle.drive();

차이점:
- 추상 클래스: "is-a" 관계, 단일 상속
- 인터페이스: "can-do" 관계, 다중 구현

실무에서는:
- 상속 구조가 명확하면 추상 클래스
- 여러 클래스가 같은 기능을 구현하면 인터페이스
- 요즘은 인터페이스를 더 선호 (유연성 때문)
```

---

### 중급 개발자 면접 질문 (5개)

#### Q8. Java의 동적 바인딩(Dynamic Binding) 원리를 설명하고, vtable의 역할을 말해주세요.

**예시 답변:**
```
동적 바인딩:
- 메서드 호출 시 어떤 메서드를 실행할지 런타임에 결정
- 참조 타입이 아닌 실제 객체 타입을 기준으로 메서드 선택

vtable (Virtual Method Table):
- 각 클래스마다 메서드 포인터를 저장하는 테이블
- 객체 생성 시 해당 클래스의 vtable을 가리킴
- 메서드 호출 시 vtable을 통해 실제 메서드 주소 찾음

작동 원리:
```java
Animal animal = new Dog();
animal.makeSound();  // 1. animal 객체의 vtable 확인
                     // 2. Dog 클래스의 vtable에서 makeSound() 주소 찾음
                     // 3. 해당 주소의 메서드 실행
```

최적화:
- JIT 컴파일러가 자주 호출되는 메서드는 인라인 최적화
- Monomorphic call site (한 타입만 호출)는 정적 바인딩으로 최적화
```

---

#### Q9. Covariant Return Type이 무엇인지 설명하고, 다형성과의 관계를 말해주세요.

**예시 답변:**
```
Covariant Return Type (공변 반환 타입):
- 오버라이딩 시 부모보다 더 구체적인(자식) 타입을 반환 가능
- Java 5부터 지원

예시:
```java
class Animal {
    public Animal reproduce() {
        return new Animal();
    }
}

class Dog extends Animal {
    @Override
    public Dog reproduce() {  // Animal 대신 Dog 반환 (공변)
        return new Dog();
    }
}

Dog dog = new Dog();
Dog puppy = dog.reproduce();  // 캐스팅 불필요!
```

다형성과의 관계:
```java
Animal animal = new Dog();
Animal baby = animal.reproduce();  // 다형성 유지

// instanceof로 확인하면
if (baby instanceof Dog) {
    System.out.println("강아지입니다!");
}
```

장점:
1. 타입 안전성 향상
2. 불필요한 캐스팅 제거
3. 코드 가독성 향상
```

---

#### Q10. SOLID 원칙 중 LSP(Liskov Substitution Principle)를 설명하고, 다형성과의 관계를 말해주세요.

**예시 답변:**
```
LSP (리스코프 치환 원칙):
"자식 클래스는 부모 클래스를 완전히 대체할 수 있어야 한다"

올바른 예:
```java
class Rectangle {
    protected int width;
    protected int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}

// ❌ LSP 위반 예시
class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;  // 정사각형은 width = height
    }

    @Override
    public void setHeight(int height) {
        this.width = height;
        this.height = height;
    }
}

// 문제 발생
void test(Rectangle rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    assert rect.getArea() == 20;  // Square면 실패! (25)
}
```

LSP를 지키는 설계:
```java
interface Shape {
    int getArea();
}

class Rectangle implements Shape {
    private int width;
    private int height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}

class Square implements Shape {
    private int side;

    public Square(int side) {
        this.side = side;
    }

    public int getArea() {
        return side * side;
    }
}
```

다형성과의 관계:
- LSP를 지켜야 안전한 다형성 구현 가능
- 부모 타입으로 자식 객체를 사용해도 문제없어야 함
```

---

#### Q11. 다형성을 사용한 디자인 패턴 3가지를 설명해주세요.

**예시 답변:**
```
1. 전략 패턴 (Strategy Pattern)
- 알고리즘을 캡슐화하고 교체 가능하게 만듦
```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardStrategy implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("신용카드 결제: " + amount);
    }
}

class KakaoPayStrategy implements PaymentStrategy {
    public void pay(int amount) {
        System.out.println("카카오페이 결제: " + amount);
    }
}

class PaymentService {
    private PaymentStrategy strategy;

    public void setStrategy(PaymentStrategy strategy) {
        this.strategy = strategy;
    }

    public void processPayment(int amount) {
        strategy.pay(amount);  // 다형성!
    }
}
```

2. 팩토리 메서드 패턴 (Factory Method Pattern)
- 객체 생성을 서브클래스에 위임
```java
abstract class AnimalFactory {
    public abstract Animal createAnimal();

    public void makeAnimalSound() {
        Animal animal = createAnimal();  // 다형성!
        animal.makeSound();
    }
}

class DogFactory extends AnimalFactory {
    public Animal createAnimal() {
        return new Dog();
    }
}

class CatFactory extends AnimalFactory {
    public Animal createAnimal() {
        return new Cat();
    }
}
```

3. 템플릿 메서드 패턴 (Template Method Pattern)
- 알고리즘 구조를 정의하고, 세부 단계는 서브클래스에서 구현
```java
abstract class DataProcessor {
    // 템플릿 메서드
    public final void process() {
        readData();    // 다형성
        processData(); // 다형성
        saveData();    // 다형성
    }

    protected abstract void readData();
    protected abstract void processData();
    protected abstract void saveData();
}

class CSVProcessor extends DataProcessor {
    protected void readData() {
        System.out.println("CSV 읽기");
    }

    protected void processData() {
        System.out.println("CSV 처리");
    }

    protected void saveData() {
        System.out.println("CSV 저장");
    }
}
```
```

---

#### Q12. 다형성 사용 시 주의해야 할 점과 안티패턴을 설명해주세요.

**예시 답변:**
```
주의점:

1. 다운캐스팅 남발 금지
❌ 안티패턴:
```java
public void process(Animal animal) {
    if (animal instanceof Dog) {
        ((Dog) animal).bark();
    } else if (animal instanceof Cat) {
        ((Cat) animal).meow();
    }
    // 새 동물 추가마다 if 추가 필요 - OCP 위반!
}
```

✅ 올바른 방법:
```java
public void process(Animal animal) {
    animal.makeSound();  // 다형성으로 해결
}
```

2. 부적절한 상속 구조
❌ 안티패턴:
```java
class Circle {
    public void draw() { }
}

class ColoredCircle extends Circle {
    // Color를 위해 상속? - 잘못된 설계
}
```

✅ 올바른 방법:
```java
class Circle {
    private Color color;  // 구성(Composition) 사용
    public void draw() { }
}
```

3. LSP 위반
- 자식 클래스가 부모의 계약을 위반
- 예외 던지기, 반환 타입 변경 등

4. 과도한 추상화
❌ 안티패턴:
```java
// 너무 많은 레벨의 상속
Animal → Mammal → Canine → Dog → Poodle
```

✅ 올바른 방법:
- 3-4레벨 이내로 제한
- 필요시 인터페이스 사용

5. instanceof 체크 후 별도 로직
❌ 안티패턴:
```java
if (payment instanceof CreditCard) {
    // 신용카드만을 위한 복잡한 로직 200줄
    // ...
}
```

✅ 올바른 방법:
- 해당 로직을 자식 클래스로 이동
- 전략 패턴 고려
```

**실무 팁:**
- Effective Java의 "상속보다 조합(Composition)을 선호하라" 원칙
- 다형성은 도구일 뿐, 남용하지 말 것
- 코드 리뷰 시 다형성 설계 점검

---

## 📚 학습 마무리

### 핵심 요약
1. **다형성의 본질**: 하나의 타입으로 여러 객체를 다루는 능력
2. **실전 활용**: 결제 시스템, 쇼핑몰, 게임 등 모든 곳에서 사용
3. **설계 원칙**: LSP, OCP를 지키며 확장 가능한 구조 설계
4. **주의사항**: instanceof 남발 금지, 다운캐스팅 최소화

### 다음 학습 주제
- **Chapter 18**: 추상 클래스 (Abstract Class)
  - 다형성의 기반이 되는 추상 클래스 심화
  - 템플릿 메서드 패턴
  - 추상 클래스 vs 인터페이스

---

**작성일**: 2025-01-10
**챕터**: 17. 다형성 (Polymorphism) - Part 3
