# 33장 멀티스레드 기초 - Part 3: 면접 질문

## 🎤 면접 질문 TOP 3

### Q1. 프로세스와 스레드의 차이는?

**답변**:
```
프로세스:
- 독립적인 실행 단위
- 별도의 메모리 공간
- 프로세스 간 통신 복잡 (IPC)
- 생성/전환 비용 큼

스레드:
- 프로세스 내 실행 단위
- 메모리 공간 공유
- 스레드 간 통신 쉬움
- 생성/전환 비용 작음

비유:
- 프로세스: 회사
- 스레드: 회사 내 직원
```

### Q2. synchronized의 동작 원리는?

**답변**:
```
Monitor Lock 사용:
1. 메서드/블록에 진입 시 락 획득
2. 다른 스레드는 대기
3. 메서드/블록 종료 시 락 해제

예시:
public synchronized void method() {
    // 한 번에 한 스레드만 실행
}

장점:
- 간단한 동기화
- 자동 락 관리

단점:
- 성능 저하 (대기 시간)
- 데드락 가능성

대안:
- ReentrantLock
- Atomic 클래스
- ConcurrentHashMap
```

### Q3. 데드락이란? 어떻게 방지하나?

**답변**:
```
데드락:
- 두 개 이상의 스레드가 서로 대기
- 진행 불가능한 상태

발생 조건 (4가지 모두 충족):
1. 상호 배제: 리소스를 공유 불가
2. 점유와 대기: 리소스 보유하면서 대기
3. 비선점: 강제로 빼앗을 수 없음
4. 순환 대기: 순환 구조

방지 방법:
1. 잠금 순서 일치
   - 모든 스레드가 같은 순서로 락 획득

2. 타임아웃 설정
   - tryLock(timeout) 사용

3. 데드락 감지
   - JConsole, VisualVM으로 모니터링

예시:
// ❌ 데드락 위험
synchronized(A) {
    synchronized(B) { }
}
synchronized(B) {
    synchronized(A) { }
}

// ✅ 순서 일치
synchronized(A) {
    synchronized(B) { }
}
synchronized(A) {
    synchronized(B) { }
}
```

---

## 🎓 Best Practices

```java
// ✅ ExecutorService 사용
ExecutorService executor = Executors.newFixedThreadPool(10);
executor.execute(() -> {
    // 작업
});
executor.shutdown();

// ✅ Concurrent 컬렉션 사용
ConcurrentHashMap<K, V> map = new ConcurrentHashMap<>();
CopyOnWriteArrayList<T> list = new CopyOnWriteArrayList<>();

// ✅ Atomic 클래스 사용
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();  // 스레드 안전
```

**시리즈 완료**: 33장 멀티스레드 마스터! 🎊
