# 44장 모듈 시스템 (Java 9) - Part 2: 기업 사례 & 주니어 실수

## 📚 목차
1. [기업 사례](#기업-사례)
2. [주니어 실수 시나리오](#주니어-실수-시나리오)
3. [마이그레이션 전략](#마이그레이션-전략)

---

## 🏢 기업 사례

### 🔷 Netflix - 마이크로서비스 모듈화

**배경**: 거대한 모놀리스를 모듈로 분리

```java
// Before - 거대한 JAR
netflix-app.jar (모든 기능이 하나에)

// After - 모듈 시스템
module com.netflix.api {
    exports com.netflix.api.streaming;
    exports com.netflix.api.user;
}

module com.netflix.streaming {
    requires com.netflix.api;
    requires transitive com.netflix.core;

    exports com.netflix.streaming.service;
    // internal 패키지는 숨김
}

module com.netflix.recommendation {
    requires com.netflix.api;
    requires com.netflix.core;

    exports com.netflix.recommendation.engine;
}
```

**성과**:
- 빌드 시간 40% 단축
- 명확한 의존성 관리
- 팀 간 독립적 개발 가능

---

### 🔷 Oracle - JDK 자체를 모듈화

**Java 9부터 JDK 자체가 모듈화됨**

```bash
# JDK 모듈 목록 확인
java --list-modules

# 출력:
java.base
java.sql
java.xml
java.desktop
...
```

```java
// 최소 모듈만 사용
module com.myapp {
    requires java.base;  // 기본 모듈 (자동 포함)
}

// 필요한 모듈만 추가
module com.myapp.db {
    requires java.base;
    requires java.sql;
}
```

**성과**:
- Hello World 실행 파일: 150MB → 30MB (80% 감소!)
- 시작 시간 단축
- 메모리 사용량 감소

---

### 🔷 Spring Framework - 모듈 지원

**Spring 5.0+에서 모듈 시스템 지원**

```java
// spring-core 모듈
module spring.core {
    exports org.springframework.core;
    exports org.springframework.util;

    requires transitive java.logging;
}

// spring-context 모듈
module spring.context {
    requires transitive spring.core;
    requires transitive spring.beans;

    exports org.springframework.context;
}

// 애플리케이션 모듈
module com.myapp {
    requires spring.context;
    requires spring.web;

    opens com.myapp.controller to spring.core;  // 리플렉션 허용
}
```

---

### 🔷 대규모 프로젝트 - 모듈 분리 전략

**배경**: 100만 라인 이상의 레거시 프로젝트

```java
// 1단계: API 모듈 분리
module com.company.api {
    exports com.company.api.user;
    exports com.company.api.order;
    exports com.company.api.payment;
}

// 2단계: Core 모듈
module com.company.core {
    requires transitive com.company.api;

    exports com.company.core.util;
    exports com.company.core.exception;
}

// 3단계: Service 모듈들
module com.company.user.service {
    requires com.company.core;
    requires java.sql;

    exports com.company.user.service.api;
}

module com.company.order.service {
    requires com.company.core;
    requires com.company.user.service;

    exports com.company.order.service.api;
}

module com.company.payment.service {
    requires com.company.core;
    requires com.company.order.service;

    exports com.company.payment.service.api;
}

// 4단계: Web 모듈
module com.company.web {
    requires com.company.user.service;
    requires com.company.order.service;
    requires com.company.payment.service;
}
```

**성과**:
- 순환 의존성 제거
- 빌드 시간 50% 단축
- 팀별 독립 개발 가능
- 버그 발생률 30% 감소

---

## 🚨 주니어 실수 시나리오

### ❌ 실수 1: 순환 의존성

```java
// ❌ 잘못된 코드
// module A
module com.myapp.user {
    requires com.myapp.order;  // order 필요
    exports com.myapp.user;
}

// module B
module com.myapp.order {
    requires com.myapp.user;  // user 필요 → 순환!
    exports com.myapp.order;
}

// 컴파일 에러:
// cyclic dependence involving com.myapp.user

// ✅ 올바른 코드 - 공통 모듈로 분리
module com.myapp.common {
    exports com.myapp.common.model;
}

module com.myapp.user {
    requires com.myapp.common;
    exports com.myapp.user;
}

module com.myapp.order {
    requires com.myapp.common;
    requires com.myapp.user;  // 한 방향만
    exports com.myapp.order;
}
```

**교훈**: 모듈 간 순환 의존성 금지, 공통 모듈로 분리

---

### ❌ 실수 2: 패키지 분할 (Split Package)

```java
// ❌ 잘못된 코드
// module A
module com.myapp.service1 {
    exports com.myapp.util;  // util 패키지 공개
}
// com/myapp/util/StringUtils.java

// module B
module com.myapp.service2 {
    exports com.myapp.util;  // 같은 패키지!
}
// com/myapp/util/DateUtils.java

// 런타임 에러:
// Package com.myapp.util is declared in modules
// com.myapp.service1 and com.myapp.service2

// ✅ 올바른 코드 - 패키지 분리
module com.myapp.service1 {
    exports com.myapp.service1.util;
}

module com.myapp.service2 {
    exports com.myapp.service2.util;
}

// 또는 공통 모듈로
module com.myapp.common {
    exports com.myapp.common.util;
}
```

**교훈**: 한 패키지는 한 모듈에만

---

### ❌ 실수 3: exports vs opens 혼동

```java
// ❌ 잘못된 코드
module com.myapp.model {
    exports com.myapp.model;  // 공개
}

// 다른 모듈에서 리플렉션 사용
Class<?> clazz = Class.forName("com.myapp.model.User");
Field field = clazz.getDeclaredField("privateField");
field.setAccessible(true);  // IllegalAccessException!

// ✅ 올바른 코드 - opens 사용
module com.myapp.model {
    exports com.myapp.model;  // 일반 접근
    opens com.myapp.model to com.fasterxml.jackson.databind;  // 리플렉션
}

// 또는 모든 모듈에 open
module com.myapp.model {
    exports com.myapp.model;
    opens com.myapp.model;  // 모든 모듈에 리플렉션 허용
}
```

**교훈**:
- **exports**: 일반 접근
- **opens**: 리플렉션 허용

---

### ❌ 실수 4: transitive 남용

```java
// ❌ 잘못된 코드 - 모든 의존성을 transitive로
module com.myapp.service {
    requires transitive java.sql;
    requires transitive java.logging;
    requires transitive java.xml;
    requires transitive com.myapp.core;
}

// ✅ 올바른 코드 - 필요할 때만 transitive
module com.myapp.service {
    requires java.sql;          // 내부 사용
    requires java.logging;      // 내부 사용

    // public API에 노출되는 것만 transitive
    requires transitive com.myapp.core;
}
```

**transitive 사용 조건**:
- public API에 다른 모듈의 타입이 노출될 때만

---

### ❌ 실수 5: Automatic Module과의 혼용

```java
// ❌ 문제가 되는 상황
// 일반 JAR (모듈 아님)
gson-2.8.jar

// Named Module
module com.myapp {
    requires gson;  // Automatic Module로 인식
}

// 위험:
// - gson-2.8.jar의 모든 패키지가 exports됨
// - 명확한 의존성 관리 불가

// ✅ 올바른 접근
// 1. 모듈화된 라이브러리 사용
module com.myapp {
    requires com.google.gson;  // 명시적 모듈
}

// 2. 또는 --add-modules로 명시
java --add-modules=gson ...
```

**교훈**: 가능하면 모듈화된 라이브러리 사용

---

## 📊 마이그레이션 전략

### 1단계: 현재 상태 분석

```bash
# 1. 의존성 분석
jdeps --module-path libs \
      --print-module-deps \
      myapp.jar

# 2. JDK 내부 API 사용 확인
jdeps --jdk-internals myapp.jar

# 3. 패키지 의존성 확인
jdeps -verbose:class myapp.jar
```

---

### 2단계: Bottom-Up 마이그레이션

```java
// Step 1: 가장 하위 모듈부터 (Core)
module com.myapp.core {
    exports com.myapp.core.util;
    exports com.myapp.core.model;
}

// Step 2: 중간 모듈 (Service)
module com.myapp.service {
    requires com.myapp.core;
    exports com.myapp.service.api;
}

// Step 3: 최상위 모듈 (Application)
module com.myapp.app {
    requires com.myapp.service;
}
```

---

### 3단계: Unnamed Module 활용

```java
// 아직 모듈화 안 된 코드는 classpath에
javac --module-path mods \
      --class-path legacy-libs/* \
      -d out \
      src/com.myapp/module-info.java \
      src/com.myapp/com/myapp/*.java

// Unnamed Module에서는 Named Module 접근 가능
// Named Module에서는 Unnamed Module 접근 불가
```

---

### 4단계: 점진적 마이그레이션

```bash
# Phase 1: API 모듈부터
create module com.myapp.api

# Phase 2: Core 모듈
create module com.myapp.core

# Phase 3: Service 모듈들
create module com.myapp.user.service
create module com.myapp.order.service

# Phase 4: Web/App 모듈
create module com.myapp.web
```

---

## 🎯 실무 체크리스트

### 모듈 설계 원칙

```
✅ 단일 책임 원칙
   - 한 모듈은 한 가지 책임

✅ 명확한 API
   - exports는 최소한으로

✅ 안정적인 의존성
   - 순환 의존성 제거

✅ 느슨한 결합
   - 인터페이스 활용
```

### 마이그레이션 체크리스트

```
✅ 의존성 분석 완료
✅ JDK 내부 API 사용 제거
✅ 순환 의존성 해결
✅ 패키지 분할 문제 해결
✅ 테스트 코드 모듈화
✅ 빌드 도구 설정 (Maven/Gradle)
```

---

## 🎓 핵심 요약

### 모듈 시스템 DO & DON'T

```
✅ DO
- 명확한 API 설계
- 순환 의존성 제거
- 필요한 것만 exports
- Bottom-Up 마이그레이션

❌ DON'T
- 순환 의존성 생성
- 패키지 분할
- transitive 남용
- 모든 패키지 exports
```

**다음 Part 3**: 성능 최적화 & 면접 질문
