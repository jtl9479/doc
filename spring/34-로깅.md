# 34장: 로깅 - 애플리케이션의 블랙박스

> **"로그는 과거를 말해주고, 미래를 예측하게 합니다"**

---

## 📋 학습 목표

이 장을 학습하면 다음을 할 수 있습니다:

- 로깅의 중요성과 레벨 체계를 이해합니다
- SLF4J와 Logback을 효과적으로 활용합니다
- 환경별로 다른 로깅 전략을 적용할 수 있습니다
- 구조화된 로그(Structured Logging)를 생성합니다
- ELK Stack과 연동하여 로그를 중앙화합니다

**예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐ (중급)

---

## 🤔 왜 로깅이 필요한가?

### 문제 상황: System.out.println의 한계

#### 문제 1: 정보 부족

```java
// ❌ 나쁜 예
System.out.println("사용자 로그인");
System.out.println("주문 생성");

// 누가? 언제? 어디서? 왜?
// 아무 정보도 없음
```

#### 문제 2: 운영 환경에서 확인 불가

```java
// 개발 환경
System.out.println("디버그: " + data);
// → 콘솔에 출력됨

// 운영 환경
System.out.println("디버그: " + data);
// → 어디로 갔는지 모름
// → 파일에 저장 안 됨
```

#### 문제 3: 성능 저하

```java
// 항상 실행됨
System.out.println("디버그: " + expensiveOperation());
// → 디버그가 필요 없어도 실행
// → 성능 낭비
```

### 로깅의 해결책

```java
// ✅ 좋은 예
@Slf4j
@Service
public class UserService {

    public User login(String username, String password) {
        log.info("Login attempt - username: {}", username);

        try {
            User user = authenticate(username, password);
            log.info("Login successful - userId: {}, username: {}",
                user.getId(), user.getUsername());
            return user;

        } catch (AuthenticationException e) {
            log.warn("Login failed - username: {}, reason: {}",
                username, e.getMessage());
            throw e;
        }
    }
}
```

**출력 예시:**
```
2025-01-15 10:30:00.123 INFO  [http-nio-8080-exec-1] c.e.UserService : Login attempt - username: hong
2025-01-15 10:30:00.456 INFO  [http-nio-8080-exec-1] c.e.UserService : Login successful - userId: 123, username: hong
```

---

## 🌍 실생활 비유로 이해하는 로깅

### 비유 1: 항공기 블랙박스

**로그 없는 시스템:**
```
비행기 추락
→ 원인을 알 수 없음
→ 재발 방지 불가능
```

**로그 있는 시스템 (블랙박스):**
```
[10:00:00] 이륙
[10:15:00] 고도 10,000ft
[10:30:00] 엔진 경고
[10:31:00] 엔진 출력 감소
[10:32:00] 비상 착륙 시도
→ 정확한 원인 파악 가능
```

### 비유 2: 의료 차트

**System.out.println:**
```
환자가 아프다고 함
→ 언제부터? 어디가? 얼마나?
→ 정보 부족
```

**로깅 (의료 차트):**
```
[2025-01-15 09:00] 체온: 38.5°C, 두통 호소
[2025-01-15 12:00] 체온: 39.0°C, 증상 악화
[2025-01-15 15:00] 해열제 투여
[2025-01-15 18:00] 체온: 37.2°C, 증상 호전
→ 정확한 진료 기록
```

### 비유 3: CCTV

**로그 없음:**
```
도난 사건 발생
→ 누가? 언제? 어떻게?
→ 수사 불가능
```

**로그 (CCTV):**
```
[23:45] 정문 열림 감지
[23:46] 1층 복도 이동 감지
[23:47] 금고실 출입 감지
[23:50] 비상구 통과
→ 범인 동선 파악
```

---

## 💡 로깅 핵심 개념

### 1️⃣ 초급: 로그 레벨

```
TRACE (가장 상세)
  ↓
DEBUG (디버그 정보)
  ↓
INFO  (일반 정보)
  ↓
WARN  (경고)
  ↓
ERROR (에러)
  ↓
FATAL (치명적)
```

#### 레벨별 사용 예시

```java
@Slf4j
@Service
public class OrderService {

    public Order createOrder(OrderRequest request) {
        // TRACE: 매우 상세한 정보
        log.trace("Method called: createOrder, request: {}", request);

        // DEBUG: 개발 시 필요한 정보
        log.debug("Validating order request: {}", request);

        // INFO: 정상적인 비즈니스 플로우
        log.info("Creating order for user: {}, amount: {}",
            request.getUserId(), request.getAmount());

        try {
            Order order = processOrder(request);

            log.info("Order created successfully: orderId={}", order.getId());
            return order;

        } catch (InsufficientStockException e) {
            // WARN: 비즈니스 예외 (복구 가능)
            log.warn("Insufficient stock for product: {}", request.getProductId());
            throw e;

        } catch (Exception e) {
            // ERROR: 시스템 에러 (복구 어려움)
            log.error("Failed to create order: {}", e.getMessage(), e);
            throw e;
        }
    }
}
```

### 2️⃣ 중급: Logback 설정

#### logback-spring.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <!-- 변수 정의 -->
    <property name="LOG_PATH" value="./logs"/>
    <property name="LOG_FILE_NAME" value="application"/>

    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${LOG_FILE_NAME}.log</file>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>

        <!-- 롤링 정책 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 일별 로그 파일 -->
            <fileNamePattern>${LOG_PATH}/${LOG_FILE_NAME}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy
                class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <!-- 파일 크기 -->
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <!-- 보관 기간 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <!-- Error 전용 Appender -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/error.log</file>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>90</maxHistory>
        </rollingPolicy>
    </appender>

    <!-- 프로파일별 설정 -->
    <springProfile name="dev">
        <root level="DEBUG">
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>

    <springProfile name="prod">
        <root level="INFO">
            <appender-ref ref="FILE"/>
            <appender-ref ref="ERROR_FILE"/>
        </root>
    </springProfile>

    <!-- 패키지별 로그 레벨 -->
    <logger name="com.example.myapp" level="DEBUG"/>
    <logger name="org.springframework" level="INFO"/>
    <logger name="org.hibernate" level="WARN"/>

</configuration>
```

#### application.yml 설정

```yaml
logging:
  level:
    root: INFO
    com.example.myapp: DEBUG
    org.springframework.web: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"

  file:
    name: logs/application.log
    max-size: 10MB
    max-history: 30
```

### 3️⃣ 고급: 구조화된 로그 (Structured Logging)

#### Logstash Encoder

```gradle
dependencies {
    implementation 'net.logstash.logback:logstash-logback-encoder:7.3'
}
```

```xml
<!-- logback-spring.xml -->
<appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/application.json</file>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <includeMdcKeyName>traceId</includeMdcKeyName>
        <includeMdcKeyName>spanId</includeMdcKeyName>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <fileNamePattern>logs/application.%d{yyyy-MM-dd}.json</fileNamePattern>
        <maxHistory>30</maxHistory>
    </rollingPolicy>
</appender>
```

**출력 예시:**
```json
{
  "timestamp": "2025-01-15T10:30:00.123Z",
  "level": "INFO",
  "thread": "http-nio-8080-exec-1",
  "logger": "com.example.OrderService",
  "message": "Order created",
  "context": {
    "userId": 123,
    "orderId": 456,
    "amount": 50000
  },
  "traceId": "abc123",
  "spanId": "def456"
}
```

#### MDC (Mapped Diagnostic Context)

```java
@Component
public class RequestLoggingFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                     HttpServletResponse response,
                                     FilterChain filterChain) throws ServletException, IOException {

        // 요청 ID를 MDC에 저장
        String requestId = UUID.randomUUID().toString();
        MDC.put("requestId", requestId);
        MDC.put("userId", getCurrentUserId());

        try {
            filterChain.doFilter(request, response);
        } finally {
            MDC.clear();
        }
    }
}
```

```xml
<pattern>
    %d{yyyy-MM-dd HH:mm:ss} [%X{requestId}] [%X{userId}] - %msg%n
</pattern>
```

**출력:**
```
2025-01-15 10:30:00 [req-abc123] [user-456] - Order created
2025-01-15 10:30:01 [req-abc123] [user-456] - Payment processed
```

---

## 🛠️ 기본 실습

### 실습 1: Lombok @Slf4j 활용

```java
@Slf4j
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        log.info("Received order request: userId={}, productId={}",
            request.getUserId(), request.getProductId());

        try {
            Order order = orderService.createOrder(request);
            log.info("Order created successfully: orderId={}", order.getId());
            return ResponseEntity.ok(order);

        } catch (Exception e) {
            log.error("Failed to create order: userId={}, error={}",
                request.getUserId(), e.getMessage(), e);
            return ResponseEntity.status(500).build();
        }
    }
}
```

### 실습 2: 조건부 로깅

```java
@Slf4j
@Service
public class AnalyticsService {

    public void processData(List<Data> dataList) {
        // ❌ 나쁜 예 - 항상 실행
        log.debug("Processing data: " + dataList.toString());

        // ✅ 좋은 예 - DEBUG 레벨일 때만 실행
        if (log.isDebugEnabled()) {
            log.debug("Processing data: {}", expensiveToString(dataList));
        }

        // ✅ 더 좋은 예 - lazy evaluation
        log.debug("Processing data: {}", () -> expensiveToString(dataList));
    }
}
```

### 실습 3: 로그 레벨 동적 변경

```yaml
# application.yml
management:
  endpoint:
    loggers:
      enabled: true
  endpoints:
    web:
      exposure:
        include: loggers
```

```bash
# 현재 로그 레벨 확인
curl http://localhost:8080/actuator/loggers/com.example

# 로그 레벨 변경 (재시작 불필요!)
curl -X POST http://localhost:8080/actuator/loggers/com.example \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel":"DEBUG"}'
```

---

## 👨‍💻 주니어 개발자 실전 시나리오

### 시나리오: "운영 장애 로그 분석"

**상황:**
```
새벽 3시, 장애 발생
"결제가 안 돼요!"
```

**로그 확인:**

```bash
# 에러 로그 확인
tail -f logs/error.log
```

```
2025-01-15 03:00:00 ERROR [http-nio-8080-exec-5] c.e.PaymentService - Payment failed: userId=123
java.net.ConnectException: Connection refused: connect
    at com.example.PaymentService.processPayment(PaymentService.java:45)
    ...
```

**원인 파악:**
```java
// PaymentService.java:45
@Slf4j
@Service
public class PaymentService {

    public void processPayment(Payment payment) {
        log.info("Processing payment: paymentId={}, amount={}",
            payment.getId(), payment.getAmount());

        try {
            // 외부 API 호출
            paymentGateway.charge(payment);

        } catch (ConnectException e) {
            // ← 여기서 에러 발생
            log.error("Payment gateway connection failed: paymentId={}",
                payment.getId(), e);
            throw new PaymentException("Payment service unavailable", e);
        }
    }
}
```

**해결:**
```java
// Retry 로직 추가
@Retryable(
    value = ConnectException.class,
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000)
)
public void processPayment(Payment payment) {
    log.info("Attempting payment: attempt={}", RetryContext.getRetryCount());
    paymentGateway.charge(payment);
}
```

---

## 🏢 기업 사례: Airbnb

### 배경

Airbnb는 수백 개의 마이크로서비스에서 일일 수 TB의 로그를 생성합니다.

**문제:**
- 로그가 분산되어 있음
- 특정 요청 추적 어려움
- 로그 검색 느림

### 해결책: ELK Stack

```yaml
# logback-spring.xml
<appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
    <destination>logstash:5000</destination>
    <encoder class="net.logstash.logback.encoder.LogstashEncoder">
        <customFields>{"service":"booking-service"}</customFields>
    </encoder>
</appender>
```

**효과:**
- 로그 검색 시간: 30분 → 10초
- 장애 원인 파악: 2시간 → 5분
- 중앙화된 로그 관리

---

## ❓ FAQ

### Q1. 로그를 너무 많이 남기면 성능이 나빠지나요?

**A:** 네, 적절한 레벨 사용이 중요합니다.

```java
// ❌ 나쁜 예
for (int i = 0; i < 1000000; i++) {
    log.debug("Processing: {}", i);  // 100만 번 로그
}

// ✅ 좋은 예
log.debug("Processing {} items", list.size());
for (Item item : list) {
    processItem(item);
}
log.debug("Processing completed");
```

### Q2. 운영 환경에서 로그 레벨은?

**A:**

```yaml
# 개발
logging:
  level:
    root: DEBUG

# 운영
logging:
  level:
    root: INFO
    com.example: DEBUG  # 우리 코드만 DEBUG
```

### Q3. 민감 정보(비밀번호 등)를 로그에 남기면?

**A:** 절대 안 됩니다! 필터링 필수

```java
@Slf4j
public class User {
    private String username;
    private String password;

    @Override
    public String toString() {
        return "User{username='" + username + "', password='***'}";
    }
}

// ❌ 나쁜 예
log.info("User: {}", user);  // password 노출 위험

// ✅ 좋은 예
log.info("User login: username={}", user.getUsername());
```

### Q4. 로그 파일이 너무 커지면?

**A:** Rolling Policy 사용

```xml
<rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
    <!-- 일별 롤링 -->
    <fileNamePattern>logs/app.%d{yyyy-MM-dd}.log</fileNamePattern>

    <!-- 30일 보관 -->
    <maxHistory>30</maxHistory>

    <!-- 전체 크기 제한 -->
    <totalSizeCap>3GB</totalSizeCap>
</rollingPolicy>
```

### Q5. 여러 서버의 로그를 통합하려면?

**A:** 중앙 로그 수집 시스템 사용

```
[Server 1] ─┐
[Server 2] ─┼→ [Logstash] → [Elasticsearch] → [Kibana]
[Server 3] ─┘
```

---

## 💼 면접 질문 TOP 5

### ⭐ 초급 1: 로그 레벨의 종류는?

**답변:**
```
TRACE < DEBUG < INFO < WARN < ERROR < FATAL

- TRACE: 가장 상세한 정보
- DEBUG: 디버깅 정보
- INFO: 일반 정보
- WARN: 경고
- ERROR: 에러
```

### ⭐ 초급 2: SLF4J란?

**답변:**
Simple Logging Facade for Java의 약자로, 로깅 프레임워크의 추상화 계층입니다.

```java
// SLF4J (인터페이스)
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// 실제 구현체
// - Logback
// - Log4j2
// - JUL
```

### ⭐⭐ 중급 1: 로그 패턴의 주요 요소는?

**답변:**

```xml
<pattern>
    %d{yyyy-MM-dd HH:mm:ss}  <!-- 날짜/시간 -->
    [%thread]                 <!-- 쓰레드 이름 -->
    %-5level                  <!-- 로그 레벨 -->
    %logger{36}               <!-- 로거 이름 -->
    - %msg%n                  <!-- 메시지 -->
</pattern>
```

### ⭐⭐ 중급 2: MDC란?

**답변:**
Mapped Diagnostic Context로, 쓰레드별로 컨텍스트 정보를 저장하는 맵입니다.

```java
MDC.put("userId", "123");
MDC.put("requestId", "abc");

// 로그에 자동 포함
log.info("Processing...");
// → [userId=123] [requestId=abc] Processing...

MDC.clear();
```

### ⭐⭐ 중급 3: 비동기 로깅의 장점은?

**답변:**

```xml
<!-- 동기 로깅: 로그 쓸 때까지 대기 -->
<appender name="FILE" class="...">

<!-- 비동기 로깅: 별도 쓰레드에서 처리 -->
<appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="FILE"/>
    <queueSize>512</queueSize>
</appender>
```

**장점:**
- 애플리케이션 성능 영향 최소화
- 처리량 향상

---

## 🎯 다음 단계

로깅을 마쳤다면:

1. **35장: 테스트** - 단위/통합 테스트
2. **ELK Stack** - 로그 수집/분석
3. **알람 시스템** - 에러 로그 자동 알림

---

**🎓 학습 완료 체크리스트:**

- [ ] 로그 레벨 이해 및 활용
- [ ] Logback 설정
- [ ] 구조화된 로그 작성
- [ ] MDC 활용
- [ ] 프로파일별 로그 전략
- [ ] 로그 레벨 동적 변경

**다음 장에서는 효과적인 테스트 전략을 배웁니다!** 🚀
