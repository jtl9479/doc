# 18-1. 추상 클래스 (Abstract Class) - Part 1

## 📋 목차
1. [추상 클래스란?](#추상-클래스란)
2. [실생활 비유 1: 자동차 설계도](#비유1-자동차-설계도)
3. [실생활 비유 2: 요리 레시피](#비유2-요리-레시피)
4. [실생활 비유 3: 건축 청사진](#비유3-건축-청사진)
5. [실생활 비유 4: 대학 강의 계획서](#비유4-강의-계획서)
6. [실생활 비유 5: 게임 캐릭터 기본 틀](#비유5-게임-캐릭터)

---

## 🎯 추상 클래스란? {#추상-클래스란}

### 정의
추상 클래스(Abstract Class)는 **불완전한 클래스**로, 직접 객체를 생성할 수 없습니다. 자식 클래스가 반드시 구현해야 할 메서드(추상 메서드)를 정의하여, **공통된 구조를 강제**하는 역할을 합니다.

### 핵심 개념

```java
// 추상 클래스 - 직접 생성 불가
public abstract class Vehicle {
    protected String name;
    protected int speed;

    // 일반 메서드 - 구현 완료
    public void showInfo() {
        System.out.println("차량명: " + name);
        System.out.println("속도: " + speed + "km/h");
    }

    // 추상 메서드 - 구현 없음, 자식이 반드시 구현
    public abstract void startEngine();
    public abstract void stopEngine();
}

// 구체 클래스 - 추상 메서드 구현
public class Car extends Vehicle {
    @Override
    public void startEngine() {
        System.out.println("🚗 자동차 시동: 부릉부릉!");
    }

    @Override
    public void stopEngine() {
        System.out.println("🚗 자동차 정지");
    }
}

// 사용
// Vehicle v = new Vehicle();  // ❌ 에러! 추상 클래스는 객체 생성 불가
Vehicle v = new Car();  // ✅ OK! 자식 클래스로 생성
v.startEngine();
```

### 추상 클래스의 특징

#### 1. 객체 생성 불가
```java
abstract class Animal {
    public abstract void makeSound();
}

// Animal animal = new Animal();  // ❌ 컴파일 에러!
Animal animal = new Dog();  // ✅ OK
```

#### 2. 추상 메서드 포함 가능
```java
abstract class Shape {
    // 추상 메서드 - 구현 없음
    public abstract double getArea();
    public abstract double getPerimeter();

    // 일반 메서드 - 구현 있음
    public void showInfo() {
        System.out.println("도형 정보");
    }
}
```

#### 3. 일반 메서드, 필드, 생성자 모두 가능
```java
abstract class Employee {
    protected String name;  // 필드
    protected int salary;

    // 생성자
    public Employee(String name, int salary) {
        this.name = name;
        this.salary = salary;
    }

    // 일반 메서드
    public void showSalary() {
        System.out.println("급여: " + salary);
    }

    // 추상 메서드
    public abstract void work();
}
```

#### 4. 자식 클래스는 추상 메서드 반드시 구현
```java
class Developer extends Employee {
    public Developer(String name, int salary) {
        super(name, salary);
    }

    @Override
    public void work() {  // 반드시 구현!
        System.out.println("코딩 중...");
    }
}

// 구현 안 하면?
class Designer extends Employee {
    // ❌ 컴파일 에러!
    // work() 메서드를 구현하지 않음
}
```

### 추상 클래스 vs 일반 클래스 vs 인터페이스

| 특성 | 추상 클래스 | 일반 클래스 | 인터페이스 |
|------|------------|-----------|----------|
| 객체 생성 | ❌ 불가 | ✅ 가능 | ❌ 불가 |
| 추상 메서드 | ✅ 가능 | ❌ 불가 | ✅ 가능 |
| 일반 메서드 | ✅ 가능 | ✅ 가능 | ✅ 가능 (default) |
| 필드 | ✅ 가능 | ✅ 가능 | ❌ 불가 (상수만) |
| 생성자 | ✅ 가능 | ✅ 가능 | ❌ 불가 |
| 다중 상속 | ❌ 불가 | ❌ 불가 | ✅ 가능 (구현) |

### 언제 추상 클래스를 사용하나?

#### 사용해야 할 때 ✅
1. **공통 기능 + 강제 구현**이 필요할 때
2. **IS-A 관계**가 명확할 때
3. **코드 재사용**이 필요할 때
4. **일부 메서드만 강제**하고 싶을 때

#### 사용하지 말아야 할 때 ❌
1. **다중 상속**이 필요할 때 → 인터페이스 사용
2. **완전히 독립적인 기능**들 → 인터페이스 사용
3. **상속 관계가 없을 때** → 일반 클래스 사용

---

## 🚗 실생활 비유 1: 자동차 설계도 {#비유1-자동차-설계도}

### 비유 설명
자동차 제조사는 "자동차"라는 공통 설계도를 가지고 있습니다. 이 설계도에는 "시동 걸기", "브레이크 작동" 등의 필수 기능이 정의되어 있지만, 구체적인 구현 방법은 각 차종(세단, SUV, 트럭)마다 다릅니다.

추상 클래스는 이 "공통 설계도"와 같습니다.

### Java 코드로 구현

```java
/**
 * 자동차 추상 클래스 - 모든 자동차의 기본 틀
 */
public abstract class Vehicle {
    // 공통 필드
    protected String manufacturer;  // 제조사
    protected String model;         // 모델명
    protected int year;            // 연식
    protected int currentSpeed;    // 현재 속도
    protected int fuel;            // 연료 (%)
    protected boolean engineOn;    // 시동 상태

    // 생성자
    public Vehicle(String manufacturer, String model, int year) {
        this.manufacturer = manufacturer;
        this.model = model;
        this.year = year;
        this.currentSpeed = 0;
        this.fuel = 100;
        this.engineOn = false;
    }

    // 추상 메서드 - 자식이 반드시 구현
    public abstract void startEngine();
    public abstract void stopEngine();
    public abstract void accelerate(int speed);
    public abstract void brake();
    public abstract void showSpecs();  // 사양 표시

    // 일반 메서드 - 공통 기능 (구현 완료)
    public void showInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("제조사: " + manufacturer);
        System.out.println("모델: " + model);
        System.out.println("연식: " + year + "년형");
        System.out.println("현재 속도: " + currentSpeed + "km/h");
        System.out.println("연료: " + fuel + "%");
        System.out.println("시동: " + (engineOn ? "ON 🟢" : "OFF 🔴"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void refuel() {
        fuel = 100;
        System.out.println("⛽ 연료 주입 완료!");
    }

    protected void consumeFuel(int amount) {
        fuel = Math.max(0, fuel - amount);
        if (fuel == 0) {
            System.out.println("⚠️ 연료 부족!");
            stopEngine();
        }
    }
}

/**
 * 세단 - Vehicle을 상속받아 구현
 */
public class Sedan extends Vehicle {
    private boolean sunroof;
    private String driveMode;  // ECO, NORMAL, SPORT

    public Sedan(String manufacturer, String model, int year, boolean sunroof) {
        super(manufacturer, model, year);
        this.sunroof = sunroof;
        this.driveMode = "NORMAL";
    }

    @Override
    public void startEngine() {
        if (fuel == 0) {
            System.out.println("❌ 연료가 없어 시동을 걸 수 없습니다.");
            return;
        }

        engineOn = true;
        System.out.println("\n🚗 세단 시동 시작");
        System.out.println("부드러운 엔진 소리: 부우웅~");
        System.out.println("계기판 점등 ✅");
        System.out.println("안전벨트를 착용해주세요 🔔");
    }

    @Override
    public void stopEngine() {
        if (!engineOn) {
            System.out.println("이미 시동이 꺼져있습니다.");
            return;
        }

        currentSpeed = 0;
        engineOn = false;
        System.out.println("\n🚗 세단 시동 정지");
        System.out.println("엔진 냉각 중...");
        System.out.println("모든 시스템 OFF");
    }

    @Override
    public void accelerate(int speed) {
        if (!engineOn) {
            System.out.println("❌ 시동을 먼저 걸어주세요.");
            return;
        }

        if (fuel == 0) {
            System.out.println("❌ 연료가 부족합니다.");
            return;
        }

        currentSpeed += speed;

        if (driveMode.equals("SPORT")) {
            currentSpeed += 10;  // 스포츠 모드는 가속 빠름
            consumeFuel(3);
        } else if (driveMode.equals("ECO")) {
            currentSpeed = Math.min(currentSpeed, 100);  // 에코 모드는 최대 100km/h
            consumeFuel(1);
        } else {
            consumeFuel(2);
        }

        System.out.println("🏎️ 가속 중... 현재 속도: " + currentSpeed + "km/h");
    }

    @Override
    public void brake() {
        if (currentSpeed == 0) {
            System.out.println("이미 정지 상태입니다.");
            return;
        }

        int reduction = Math.min(currentSpeed, 20);
        currentSpeed -= reduction;

        System.out.println("🛑 브레이크 작동");
        System.out.println("감속: -" + reduction + "km/h");
        System.out.println("현재 속도: " + currentSpeed + "km/h");

        if (currentSpeed == 0) {
            System.out.println("완전 정지 ✅");
        }
    }

    @Override
    public void showSpecs() {
        System.out.println("\n📋 세단 사양");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("차종: 세단");
        System.out.println("제조사: " + manufacturer);
        System.out.println("모델: " + model);
        System.out.println("선루프: " + (sunroof ? "있음" : "없음"));
        System.out.println("주행 모드: " + driveMode);
        System.out.println("최고 속도: 230km/h");
        System.out.println("연비: 15km/L");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void setDriveMode(String mode) {
        this.driveMode = mode;
        System.out.println("🔧 주행 모드 변경: " + mode);
    }

    public void openSunroof() {
        if (sunroof) {
            System.out.println("☀️ 선루프 개방");
        } else {
            System.out.println("❌ 선루프가 없습니다.");
        }
    }
}

/**
 * SUV - Vehicle을 상속받아 구현
 */
public class SUV extends Vehicle {
    private boolean fourWheelDrive;
    private int clearance;  // 지상고 (mm)

    public SUV(String manufacturer, String model, int year, boolean fourWheelDrive, int clearance) {
        super(manufacturer, model, year);
        this.fourWheelDrive = fourWheelDrive;
        this.clearance = clearance;
    }

    @Override
    public void startEngine() {
        if (fuel == 0) {
            System.out.println("❌ 연료가 없어 시동을 걸 수 없습니다.");
            return;
        }

        engineOn = true;
        System.out.println("\n🚙 SUV 시동 시작");
        System.out.println("강력한 엔진 소리: 부르릉!!!");
        System.out.println("AWD 시스템 체크 중...");

        if (fourWheelDrive) {
            System.out.println("4륜구동 준비 완료 ✅");
        }

        System.out.println("높은 시야 확보 👍");
    }

    @Override
    public void stopEngine() {
        if (!engineOn) {
            System.out.println("이미 시동이 꺼져있습니다.");
            return;
        }

        currentSpeed = 0;
        engineOn = false;
        System.out.println("\n🚙 SUV 시동 정지");
        System.out.println("터보 냉각 중...");
    }

    @Override
    public void accelerate(int speed) {
        if (!engineOn) {
            System.out.println("❌ 시동을 먼저 걸어주세요.");
            return;
        }

        if (fuel == 0) {
            System.out.println("❌ 연료가 부족합니다.");
            return;
        }

        currentSpeed += speed;
        consumeFuel(3);  // SUV는 연비가 낮음

        System.out.println("💪 힘차게 가속 중... 현재 속도: " + currentSpeed + "km/h");

        if (fourWheelDrive && currentSpeed > 60) {
            System.out.println("🌲 험로 주행 가능 상태");
        }
    }

    @Override
    public void brake() {
        if (currentSpeed == 0) {
            System.out.println("이미 정지 상태입니다.");
            return;
        }

        int reduction = Math.min(currentSpeed, 15);  // SUV는 무거워서 제동 거리 길음
        currentSpeed -= reduction;

        System.out.println("🛑 브레이크 작동 (대형 차량)");
        System.out.println("감속: -" + reduction + "km/h");
        System.out.println("현재 속도: " + currentSpeed + "km/h");
    }

    @Override
    public void showSpecs() {
        System.out.println("\n📋 SUV 사양");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("차종: SUV");
        System.out.println("제조사: " + manufacturer);
        System.out.println("모델: " + model);
        System.out.println("구동: " + (fourWheelDrive ? "4WD" : "2WD"));
        System.out.println("지상고: " + clearance + "mm");
        System.out.println("최고 속도: 200km/h");
        System.out.println("연비: 10km/L");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void activateOffRoadMode() {
        if (fourWheelDrive) {
            System.out.println("🏔️ 오프로드 모드 활성화");
            System.out.println("4륜 구동 최적화");
            System.out.println("지상고: " + clearance + "mm - 험로 통과 가능");
        } else {
            System.out.println("❌ 2륜 구동은 오프로드 모드를 지원하지 않습니다.");
        }
    }
}

/**
 * 트럭 - Vehicle을 상속받아 구현
 */
public class Truck extends Vehicle {
    private int loadCapacity;  // 적재량 (kg)
    private int currentLoad;   // 현재 적재량

    public Truck(String manufacturer, String model, int year, int loadCapacity) {
        super(manufacturer, model, year);
        this.loadCapacity = loadCapacity;
        this.currentLoad = 0;
    }

    @Override
    public void startEngine() {
        if (fuel == 0) {
            System.out.println("❌ 연료가 없어 시동을 걸 수 없습니다.");
            return;
        }

        engineOn = true;
        System.out.println("\n🚚 트럭 시동 시작");
        System.out.println("디젤 엔진: 드르르르릉!!!");
        System.out.println("공기압 확인 중...");
        System.out.println("현재 적재량: " + currentLoad + "kg / " + loadCapacity + "kg");
        System.out.println("적재 비율: " + (currentLoad * 100 / loadCapacity) + "%");
    }

    @Override
    public void stopEngine() {
        if (!engineOn) {
            System.out.println("이미 시동이 꺼져있습니다.");
            return;
        }

        currentSpeed = 0;
        engineOn = false;
        System.out.println("\n🚚 트럭 시동 정지");
        System.out.println("에어 브레이크 해제");
    }

    @Override
    public void accelerate(int speed) {
        if (!engineOn) {
            System.out.println("❌ 시동을 먼저 걸어주세요.");
            return;
        }

        if (fuel == 0) {
            System.out.println("❌ 연료가 부족합니다.");
            return;
        }

        // 적재량에 따라 가속 속도 변화
        int actualSpeed = speed;
        if (currentLoad > loadCapacity * 0.7) {
            actualSpeed = speed / 2;  // 많이 실으면 느림
            System.out.println("⚠️ 과적재로 가속이 느립니다.");
        }

        currentSpeed += actualSpeed;
        consumeFuel(5);  // 트럭은 연비가 매우 낮음

        System.out.println("🐌 천천히 가속 중... 현재 속도: " + currentSpeed + "km/h");
    }

    @Override
    public void brake() {
        if (currentSpeed == 0) {
            System.out.println("이미 정지 상태입니다.");
            return;
        }

        int reduction = Math.min(currentSpeed, 10);  // 트럭은 제동 거리가 매우 김
        currentSpeed -= reduction;

        System.out.println("🛑 에어 브레이크 작동");
        System.out.println("쉭- 쉭- (공기 소리)");
        System.out.println("감속: -" + reduction + "km/h");
        System.out.println("현재 속도: " + currentSpeed + "km/h");
    }

    @Override
    public void showSpecs() {
        System.out.println("\n📋 트럭 사양");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("차종: 트럭");
        System.out.println("제조사: " + manufacturer);
        System.out.println("모델: " + model);
        System.out.println("최대 적재량: " + loadCapacity + "kg");
        System.out.println("현재 적재량: " + currentLoad + "kg");
        System.out.println("최고 속도: 120km/h");
        System.out.println("연비: 7km/L");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void loadCargo(int weight) {
        if (currentLoad + weight > loadCapacity) {
            System.out.println("❌ 적재량 초과! (최대: " + loadCapacity + "kg)");
            return;
        }

        currentLoad += weight;
        System.out.println("📦 화물 적재: +" + weight + "kg");
        System.out.println("현재 적재량: " + currentLoad + "kg");
    }

    public void unloadCargo() {
        System.out.println("📦 화물 하역");
        currentLoad = 0;
        System.out.println("✅ 모든 화물 하역 완료");
    }
}

/**
 * 전기차 - Vehicle을 상속받아 구현
 */
public class ElectricCar extends Vehicle {
    private int batteryCapacity;  // 배터리 용량 (kWh)
    private int currentBattery;   // 현재 배터리 (%)
    private boolean autopilot;

    public ElectricCar(String manufacturer, String model, int year, int batteryCapacity) {
        super(manufacturer, model, year);
        this.batteryCapacity = batteryCapacity;
        this.currentBattery = 100;
        this.autopilot = false;
        this.fuel = 0;  // 전기차는 연료 없음
    }

    @Override
    public void startEngine() {
        if (currentBattery == 0) {
            System.out.println("❌ 배터리가 방전되었습니다.");
            return;
        }

        engineOn = true;
        System.out.println("\n⚡ 전기차 시동 시작");
        System.out.println("조용한 전기 모터: (무음)");
        System.out.println("배터리 잔량: " + currentBattery + "%");
        System.out.println("예상 주행 거리: " + (currentBattery * 4) + "km");
        System.out.println("전자 시스템 활성화 ✅");
    }

    @Override
    public void stopEngine() {
        if (!engineOn) {
            System.out.println("이미 시동이 꺼져있습니다.");
            return;
        }

        currentSpeed = 0;
        engineOn = false;
        System.out.println("\n⚡ 전기차 시동 정지");
        System.out.println("회생 제동으로 배터리 충전 +2%");
        currentBattery = Math.min(100, currentBattery + 2);
    }

    @Override
    public void accelerate(int speed) {
        if (!engineOn) {
            System.out.println("❌ 시동을 먼저 걸어주세요.");
            return;
        }

        if (currentBattery == 0) {
            System.out.println("❌ 배터리가 부족합니다.");
            return;
        }

        currentSpeed += speed * 1.2;  // 전기차는 가속이 빠름!
        consumeBattery(2);

        System.out.println("⚡ 순간 가속! 현재 속도: " + (int)currentSpeed + "km/h");
        System.out.println("배터리: " + currentBattery + "%");
    }

    @Override
    public void brake() {
        if (currentSpeed == 0) {
            System.out.println("이미 정지 상태입니다.");
            return;
        }

        int reduction = Math.min(currentSpeed, 25);
        currentSpeed -= reduction;

        // 회생 제동으로 배터리 충전
        currentBattery = Math.min(100, currentBattery + 1);

        System.out.println("🔋 회생 제동 작동");
        System.out.println("감속: -" + reduction + "km/h");
        System.out.println("배터리 충전 +1%");
        System.out.println("현재 속도: " + currentSpeed + "km/h");
    }

    @Override
    public void showSpecs() {
        System.out.println("\n📋 전기차 사양");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("차종: 전기차");
        System.out.println("제조사: " + manufacturer);
        System.out.println("모델: " + model);
        System.out.println("배터리: " + batteryCapacity + "kWh");
        System.out.println("최대 주행거리: " + (batteryCapacity * 5) + "km");
        System.out.println("최고 속도: 250km/h");
        System.out.println("0→100km/h: 3.2초");
        System.out.println("자율주행: " + (autopilot ? "지원" : "미지원"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    public void chargeBattery() {
        System.out.println("🔌 충전 중...");
        currentBattery = 100;
        System.out.println("✅ 충전 완료! 배터리: 100%");
    }

    public void activateAutopilot() {
        if (!engineOn || currentSpeed == 0) {
            System.out.println("❌ 주행 중에만 자율주행을 활성화할 수 있습니다.");
            return;
        }

        autopilot = true;
        System.out.println("🤖 자율주행 모드 활성화");
        System.out.println("AI가 운전을 대신합니다.");
        System.out.println("손을 핸들에 올려놓아주세요.");
    }

    private void consumeBattery(int amount) {
        currentBattery = Math.max(0, currentBattery - amount);
        if (currentBattery == 0) {
            System.out.println("⚠️ 배터리 방전!");
            stopEngine();
        }
    }
}
```

### 실행 테스트

```java
public class VehicleTest {
    public static void main(String[] args) {
        System.out.println("🚗 ═══════════════════════════════");
        System.out.println("   자동차 시뮬레이터");
        System.out.println("═══════════════════════════════\n");

        // ❌ 추상 클래스는 객체 생성 불가
        // Vehicle vehicle = new Vehicle("Test", "Model", 2025);  // 컴파일 에러!

        // ✅ 자식 클래스로 객체 생성
        Sedan sedan = new Sedan("현대", "아반떼", 2025, true);
        SUV suv = new SUV("기아", "쏘렌토", 2025, true, 220);
        Truck truck = new Truck("타타대우", "노부스", 2025, 5000);
        ElectricCar tesla = new ElectricCar("Tesla", "Model 3", 2025, 75);

        // 세단 테스트
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("1. 세단 테스트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        sedan.showSpecs();
        sedan.startEngine();
        sedan.setDriveMode("SPORT");
        sedan.accelerate(50);
        sedan.accelerate(30);
        sedan.openSunroof();
        sedan.showInfo();
        sedan.brake();
        sedan.brake();
        sedan.stopEngine();

        // SUV 테스트
        System.out.println("\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("2. SUV 테스트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        suv.showSpecs();
        suv.startEngine();
        suv.accelerate(40);
        suv.accelerate(30);
        suv.activateOffRoadMode();
        suv.showInfo();
        suv.stopEngine();

        // 트럭 테스트
        System.out.println("\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("3. 트럭 테스트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        truck.showSpecs();
        truck.loadCargo(2000);
        truck.loadCargo(1500);
        truck.startEngine();
        truck.accelerate(30);
        truck.showInfo();
        truck.unloadCargo();
        truck.stopEngine();

        // 전기차 테스트
        System.out.println("\n\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("4. 전기차 테스트");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        tesla.showSpecs();
        tesla.startEngine();
        tesla.accelerate(60);
        tesla.activateAutopilot();
        tesla.showInfo();
        tesla.brake();
        tesla.stopEngine();

        // 다형성 테스트
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   다형성 테스트");
        System.out.println("═══════════════════════════");

        Vehicle[] vehicles = {sedan, suv, truck, tesla};

        System.out.println("\n모든 차량 시동 걸기:");
        for (Vehicle v : vehicles) {
            v.startEngine();
            System.out.println();
        }

        System.out.println("\n\n💡 추상 클래스의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ Vehicle는 직접 생성 불가 (추상 클래스)");
        System.out.println("✅ 각 차종은 반드시 startEngine() 등을 구현해야 함");
        System.out.println("✅ 공통 기능(showInfo, refuel)은 재사용");
        System.out.println("✅ 차종별 고유 기능도 추가 가능");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **Vehicle은 추상 클래스** - 직접 객체 생성 불가
2. **추상 메서드 강제** - 모든 자식은 startEngine, stopEngine 등을 반드시 구현
3. **공통 기능 재사용** - showInfo, refuel 등은 모든 차종이 사용
4. **확장성** - 새로운 차종 추가 시 Vehicle 상속만 하면 됨

---

## 🍳 실생활 비유 2: 요리 레시피 {#비유2-요리-레시피}

### 비유 설명
요리 레시피는 "재료 준비", "조리", "플레이팅"이라는 공통 단계를 가지고 있습니다. 하지만 파스타, 스테이크, 샐러드마다 구체적인 조리 방법은 완전히 다릅니다.

추상 클래스는 이 "공통 레시피 틀"과 같습니다.

### Java 코드로 구현

```java
/**
 * 요리 추상 클래스 - 모든 요리의 기본 틀
 */
public abstract class Recipe {
    protected String dishName;
    protected int prepTime;  // 준비 시간 (분)
    protected int cookTime;  // 조리 시간 (분)
    protected String difficulty;  // EASY, MEDIUM, HARD

    public Recipe(String dishName, int prepTime, int cookTime, String difficulty) {
        this.dishName = dishName;
        this.prepTime = prepTime;
        this.cookTime = cookTime;
        this.difficulty = difficulty;
    }

    // 템플릿 메서드 - 요리의 전체 과정
    public final void cook() {
        System.out.println("\n🍳 ═══════════════════════════");
        System.out.println("   " + dishName + " 조리 시작");
        System.out.println("═══════════════════════════");

        prepareIngredients();  // 추상 메서드
        prepareTools();        // 추상 메서드
        cookFood();            // 추상 메서드
        plating();             // 추상 메서드

        System.out.println("\n✅ " + dishName + " 완성!");
        System.out.println("총 소요 시간: " + (prepTime + cookTime) + "분");
    }

    // 추상 메서드 - 자식이 반드시 구현
    protected abstract void prepareIngredients();
    protected abstract void prepareTools();
    protected abstract void cookFood();
    protected abstract void plating();

    // 일반 메서드 - 공통 기능
    public void showRecipeInfo() {
        System.out.println("\n📋 레시피 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("요리명: " + dishName);
        System.out.println("난이도: " + getDifficultyKorean());
        System.out.println("준비 시간: " + prepTime + "분");
        System.out.println("조리 시간: " + cookTime + "분");
        System.out.println("총 시간: " + (prepTime + cookTime) + "분");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }

    private String getDifficultyKorean() {
        switch (difficulty) {
            case "EASY": return "쉬움 ⭐";
            case "MEDIUM": return "보통 ⭐⭐";
            case "HARD": return "어려움 ⭐⭐⭐";
            default: return difficulty;
        }
    }
}

/**
 * 파스타 요리
 */
public class PastaRecipe extends Recipe {
    private String pastaType;  // 스파게티, 펜네, 푸실리 등

    public PastaRecipe(String dishName, String pastaType) {
        super(dishName, 10, 15, "MEDIUM");
        this.pastaType = pastaType;
    }

    @Override
    protected void prepareIngredients() {
        System.out.println("\n📦 재료 준비");
        System.out.println("- " + pastaType + " 면: 100g");
        System.out.println("- 올리브 오일: 2스푼");
        System.out.println("- 마늘: 3쪽");
        System.out.println("- 토마토 소스: 200g");
        System.out.println("- 파르메산 치즈: 30g");
        System.out.println("- 소금, 후추");
        System.out.println("✅ 재료 준비 완료");
    }

    @Override
    protected void prepareTools() {
        System.out.println("\n🔪 조리 도구 준비");
        System.out.println("- 큰 냄비 (물 끓이기용)");
        System.out.println("- 프라이팬");
        System.out.println("- 집게");
        System.out.println("- 접시");
        System.out.println("✅ 도구 준비 완료");
    }

    @Override
    protected void cookFood() {
        System.out.println("\n👨‍🍳 조리");
        System.out.println("1. 냄비에 물을 끓인다 (소금 약간 추가)");
        System.out.println("2. " + pastaType + " 면을 8분간 삶는다");
        System.out.println("3. 프라이팬에 올리브 오일과 마늘을 볶는다");
        System.out.println("4. 토마토 소스를 넣고 끓인다");
        System.out.println("5. 삶은 면을 소스에 넣고 버무린다");
        System.out.println("6. 파르메산 치즈를 뿌린다");
        System.out.println("✅ 조리 완료");
    }

    @Override
    protected void plating() {
        System.out.println("\n🍽️ 플레이팅");
        System.out.println("1. 따뜻한 접시에 파스타를 담는다");
        System.out.println("2. 파르메산 치즈를 추가로 뿌린다");
        System.out.println("3. 바질 잎을 올린다");
        System.out.println("4. 올리브 오일을 살짝 뿌린다");
        System.out.println("✅ 플레이팅 완료");
    }
}

/**
 * 스테이크 요리
 */
public class SteakRecipe extends Recipe {
    private String cookLevel;  // RARE, MEDIUM, WELL_DONE

    public SteakRecipe(String dishName, String cookLevel) {
        super(dishName, 5, 12, "HARD");
        this.cookLevel = cookLevel;
    }

    @Override
    protected void prepareIngredients() {
        System.out.println("\n📦 재료 준비");
        System.out.println("- 등심 스테이크: 250g");
        System.out.println("- 소금, 후추");
        System.out.println("- 버터: 30g");
        System.out.println("- 로즈마리: 2줄기");
        System.out.println("- 마늘: 3쪽");
        System.out.println("✅ 재료 준비 완료");
    }

    @Override
    protected void prepareTools() {
        System.out.println("\n🔪 조리 도구 준비");
        System.out.println("- 무쇠 팬 (또는 그릴 팬)");
        System.out.println("- 집게");
        System.out.println("- 온도계");
        System.out.println("- 도마, 칼");
        System.out.println("✅ 도구 준비 완료");
    }

    @Override
    protected void cookFood() {
        System.out.println("\n👨‍🍳 조리");
        System.out.println("1. 스테이크를 실온에 30분 둔다");
        System.out.println("2. 소금, 후추로 간한다");
        System.out.println("3. 팬을 강불로 달군다 (연기 날 정도)");

        switch (cookLevel) {
            case "RARE":
                System.out.println("4. 양면 각 2분씩 굽는다 (레어)");
                System.out.println("   중심 온도: 50-52°C");
                break;
            case "MEDIUM":
                System.out.println("4. 양면 각 3-4분씩 굽는다 (미디엄)");
                System.out.println("   중심 온도: 57-60°C");
                break;
            case "WELL_DONE":
                System.out.println("4. 양면 각 5-6분씩 굽는다 (웰던)");
                System.out.println("   중심 온도: 70°C 이상");
                break;
        }

        System.out.println("5. 버터, 마늘, 로즈마리를 넣고 베이스팅");
        System.out.println("6. 3분간 휴지시킨다");
        System.out.println("✅ 조리 완료");
    }

    @Override
    protected void plating() {
        System.out.println("\n🍽️ 플레이팅");
        System.out.println("1. 따뜻한 접시에 스테이크를 올린다");
        System.out.println("2. 로즈마리로 장식한다");
        System.out.println("3. 팬의 육즙을 위에 뿌린다");
        System.out.println("4. 으깬 감자와 구운 채소를 곁들인다");
        System.out.println("✅ 플레이팅 완료");
    }
}

/**
 * 샐러드 요리
 */
public class SaladRecipe extends Recipe {
    private String dressingType;  // CAESAR, BALSAMIC, RANCH

    public SaladRecipe(String dishName, String dressingType) {
        super(dishName, 15, 0, "EASY");
        this.dressingType = dressingType;
    }

    @Override
    protected void prepareIngredients() {
        System.out.println("\n📦 재료 준비");
        System.out.println("- 로메인 상추: 200g");
        System.out.println("- 방울 토마토: 10개");
        System.out.println("- 오이: 1개");
        System.out.println("- 아보카도: 1개");
        System.out.println("- " + getDressingName() + " 드레싱");
        System.out.println("- 크루통");
        System.out.println("✅ 재료 준비 완료");
    }

    @Override
    protected void prepareTools() {
        System.out.println("\n🔪 조리 도구 준비");
        System.out.println("- 큰 볼");
        System.out.println("- 샐러드 서버");
        System.out.println("- 도마, 칼");
        System.out.println("✅ 도구 준비 완료");
    }

    @Override
    protected void cookFood() {
        System.out.println("\n👨‍🍳 조리 (불 사용 없음)");
        System.out.println("1. 상추를 한입 크기로 자른다");
        System.out.println("2. 토마토를 반으로 자른다");
        System.out.println("3. 오이를 얇게 썬다");
        System.out.println("4. 아보카도를 큐브로 자른다");
        System.out.println("5. 볼에 모든 재료를 담는다");
        System.out.println("6. " + getDressingName() + " 드레싱을 뿌린다");
        System.out.println("7. 골고루 버무린다");
        System.out.println("✅ 조리 완료");
    }

    @Override
    protected void plating() {
        System.out.println("\n🍽️ 플레이팅");
        System.out.println("1. 차가운 접시에 샐러드를 담는다");
        System.out.println("2. 크루통을 올린다");
        System.out.println("3. 드레싱을 추가로 뿌린다");
        System.out.println("4. 파르메산 치즈를 갈아서 뿌린다");
        System.out.println("✅ 플레이팅 완료");
    }

    private String getDressingName() {
        switch (dressingType) {
            case "CAESAR": return "시저";
            case "BALSAMIC": return "발사믹";
            case "RANCH": return "랜치";
            default: return dressingType;
        }
    }
}
```

### 실행 테스트

```java
public class RecipeTest {
    public static void main(String[] args) {
        System.out.println("🍳 ═══════════════════════════════");
        System.out.println("   요리 레시피 시스템");
        System.out.println("═══════════════════════════════\n");

        // 레시피 생성
        PastaRecipe pasta = new PastaRecipe("까르보나라", "스파게티");
        SteakRecipe steak = new SteakRecipe("립아이 스테이크", "MEDIUM");
        SaladRecipe salad = new SaladRecipe("시저 샐러드", "CAESAR");

        // 파스타 조리
        pasta.showRecipeInfo();
        pasta.cook();

        // 스테이크 조리
        steak.showRecipeInfo();
        steak.cook();

        // 샐러드 조리
        salad.showRecipeInfo();
        salad.cook();

        // 다형성 테스트
        System.out.println("\n\n🔄 ═══════════════════════════");
        System.out.println("   코스 요리 (다형성)");
        System.out.println("═══════════════════════════");

        Recipe[] course = {salad, pasta, steak};

        for (int i = 0; i < course.length; i++) {
            System.out.println("\n[" + (i + 1) + "번째 코스]");
            course[i].cook();
            System.out.println();
        }

        System.out.println("\n\n💡 추상 클래스의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ Recipe는 조리 순서(템플릿)를 정의");
        System.out.println("✅ 각 요리는 자신만의 방식으로 구현");
        System.out.println("✅ cook() 메서드는 final - 순서 변경 불가");
        System.out.println("✅ 템플릿 메서드 패턴의 좋은 예시");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **템플릿 메서드 패턴** - cook() 메서드가 전체 조리 과정 정의
2. **추상 메서드로 강제** - 모든 레시피는 4단계를 반드시 구현
3. **일관된 프로세스** - 모든 요리가 동일한 순서로 조리됨
4. **유연한 구현** - 각 요리는 자신만의 방식으로 구현

---

## 🏗️ 실생활 비유 3: 건축 청사진 {#비유3-건축-청사진}

### 비유 설명
건축 청사진은 모든 건물이 가져야 할 기본 구조(기초 공사, 골조, 마감)를 정의하지만, 아파트, 단독주택, 상가 건물마다 구체적인 시공 방법은 다릅니다.

### Java 코드로 구현

```java
/**
 * 건축물 추상 클래스
 */
public abstract class Building {
    protected String buildingName;
    protected String location;
    protected int floors;
    protected double area;  // 면적 (m²)
    protected int constructionProgress;  // 공정률 (%)

    public Building(String buildingName, String location, int floors, double area) {
        this.buildingName = buildingName;
        this.location = location;
        this.floors = floors;
        this.area = area;
        this.constructionProgress = 0;
    }

    // 추상 메서드 - 건물마다 다른 시공
    public abstract void layFoundation();
    public abstract void buildFrame();
    public abstract void installUtilities();
    public abstract void doInteriorWork();
    public abstract void doExteriorWork();

    // 템플릿 메서드 - 건축 순서
    public final void construct() {
        System.out.println("\n🏗️ " + buildingName + " 건축 시작");
        System.out.println("위치: " + location);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        layFoundation();
        updateProgress(20);

        buildFrame();
        updateProgress(50);

        installUtilities();
        updateProgress(70);

        doInteriorWork();
        updateProgress(90);

        doExteriorWork();
        updateProgress(100);

        System.out.println("\n✅ " + buildingName + " 건축 완료!");
        System.out.println("총 층수: " + floors + "층");
        System.out.println("총 면적: " + area + "m²");
    }

    protected void updateProgress(int progress) {
        constructionProgress = progress;
        System.out.println("📊 공정률: " + constructionProgress + "%\n");
    }

    public void showBuildingInfo() {
        System.out.println("\n🏢 건물 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
        System.out.println("건물명: " + buildingName);
        System.out.println("위치: " + location);
        System.out.println("층수: " + floors + "층");
        System.out.println("면적: " + area + "m²");
        System.out.println("공정률: " + constructionProgress + "%");
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 아파트
 */
public class Apartment extends Building {
    private int households;  // 세대수
    private boolean hasElevator;

    public Apartment(String buildingName, String location, int floors,
                    double area, int households) {
        super(buildingName, location, floors, area);
        this.households = households;
        this.hasElevator = floors > 5;
    }

    @Override
    public void layFoundation() {
        System.out.println("🔨 기초 공사 (아파트)");
        System.out.println("- 굴착 작업");
        System.out.println("- 지하 주차장 구조물");
        System.out.println("- 철근 콘크리트 기초");
    }

    @Override
    public void buildFrame() {
        System.out.println("🏗️ 골조 공사 (아파트)");
        System.out.println("- 철근 콘크리트 벽식 구조");
        System.out.println("- " + floors + "개 층 시공");
        System.out.println("- 각 층당 " + (households / floors) + "세대");
    }

    @Override
    public void installUtilities() {
        System.out.println("🔧 설비 공사 (아파트)");
        System.out.println("- 전기 배선");
        System.out.println("- 급수/배수 시스템");
        System.out.println("- 난방 시스템 (보일러)");
        if (hasElevator) {
            System.out.println("- 엘리베이터 설치");
        }
    }

    @Override
    public void doInteriorWork() {
        System.out.println("🎨 내부 마감 (아파트)");
        System.out.println("- 벽지 시공");
        System.out.println("- 바닥재 시공 (마루)");
        System.out.println("- 주방/욕실 타일");
        System.out.println("- " + households + "세대 일괄 시공");
    }

    @Override
    public void doExteriorWork() {
        System.out.println("🏢 외부 마감 (아파트)");
        System.out.println("- 외벽 단열재");
        System.out.println("- 외벽 도색");
        System.out.println("- 창호 설치");
        System.out.println("- 조경 공사");
    }
}

/**
 * 단독주택
 */
public class House extends Building {
    private int rooms;
    private boolean hasGarden;

    public House(String buildingName, String location, int floors,
                double area, int rooms, boolean hasGarden) {
        super(buildingName, location, floors, area);
        this.rooms = rooms;
        this.hasGarden = hasGarden;
    }

    @Override
    public void layFoundation() {
        System.out.println("🔨 기초 공사 (단독주택)");
        System.out.println("- 땅 고르기");
        System.out.println("- 줄기초 (콘크리트)");
        System.out.println("- 방습 처리");
    }

    @Override
    public void buildFrame() {
        System.out.println("🏗️ 골조 공사 (단독주택)");
        System.out.println("- 경량 목구조");
        System.out.println("- " + floors + "층 구조");
        System.out.println("- 방 " + rooms + "개 구획");
    }

    @Override
    public void installUtilities() {
        System.out.println("🔧 설비 공사 (단독주택)");
        System.out.println("- 전기 배선 (가정용)");
        System.out.println("- 상하수도 연결");
        System.out.println("- 개별 보일러 설치");
        System.out.println("- 인터넷/TV 배선");
    }

    @Override
    public void doInteriorWork() {
        System.out.println("🎨 내부 마감 (단독주택)");
        System.out.println("- 맞춤형 벽지/페인트");
        System.out.println("- 원목 마루");
        System.out.println("- 붙박이장 설치");
        System.out.println("- " + rooms + "개 방 개별 디자인");
    }

    @Override
    public void doExteriorWork() {
        System.out.println("🏡 외부 마감 (단독주택)");
        System.out.println("- 외벽 마감 (벽돌/사이딩)");
        System.out.println("- 지붕 시공 (기와/슁글)");
        if (hasGarden) {
            System.out.println("- 정원 조성");
            System.out.println("- 잔디 식재");
        }
        System.out.println("- 대문 설치");
    }
}

/**
 * 상가 건물
 */
public class CommercialBuilding extends Building {
    private int shops;  // 상가 개수
    private boolean hasParking;

    public CommercialBuilding(String buildingName, String location, int floors,
                             double area, int shops) {
        super(buildingName, location, floors, area);
        this.shops = shops;
        this.hasParking = true;
    }

    @Override
    public void layFoundation() {
        System.out.println("🔨 기초 공사 (상가)");
        System.out.println("- 대규모 굴착");
        System.out.println("- 지하 2층 주차장 기초");
        System.out.println("- 하중 강화 기초");
    }

    @Override
    public void buildFrame() {
        System.out.println("🏗️ 골조 공사 (상가)");
        System.out.println("- 철골 구조");
        System.out.println("- 넓은 공간 확보 (기둥 최소화)");
        System.out.println("- " + shops + "개 점포 구획");
    }

    @Override
    public void installUtilities() {
        System.out.println("🔧 설비 공사 (상가)");
        System.out.println("- 3상 전기 시스템 (고용량)");
        System.out.println("- 소방 설비 (스프링클러)");
        System.out.println("- 중앙 냉난방");
        System.out.println("- 환기 시스템");
    }

    @Override
    public void doInteriorWork() {
        System.out.println("🎨 내부 마감 (상가)");
        System.out.println("- 점포별 칸막이");
        System.out.println("- 공용 복도 타일");
        System.out.println("- 각 점포 전기/수도 분리");
        System.out.println("- 화장실 공사");
    }

    @Override
    public void doExteriorWork() {
        System.out.println("🏪 외부 마감 (상가)");
        System.out.println("- 유리 커튼월");
        System.out.println("- 대형 간판 설치 공간");
        System.out.println("- 주차장 라인 도색");
        System.out.println("- 주 출입구 자동문");
    }
}
```

### 실행 테스트

```java
public class BuildingTest {
    public static void main(String[] args) {
        Apartment apt = new Apartment("래미안 아파트", "서울 강남구", 25, 15000, 200);
        House house = new House("드림하우스", "경기 성남시", 2, 150, 4, true);
        CommercialBuilding mall = new CommercialBuilding("타임스퀘어", "서울 영등포구",
                                                        12, 30000, 150);

        // 아파트 건축
        apt.construct();

        // 단독주택 건축
        house.construct();

        // 상가 건축
        mall.construct();

        System.out.println("\n\n💡 추상 클래스의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ Building은 건축 순서(템플릿)를 정의");
        System.out.println("✅ 각 건물은 자신만의 방식으로 시공");
        System.out.println("✅ construct()는 final - 순서 변경 불가");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **템플릿 메서드** - construct()가 건축 순서 정의
2. **단계별 강제** - 모든 건물은 5단계를 반드시 구현
3. **순서 보장** - final 메서드로 순서 변경 방지

---

## 📚 실생활 비유 4: 대학 강의 계획서 {#비유4-강의-계획서}

### 비유 설명
모든 대학 강의는 "출석", "강의", "과제", "평가"라는 공통 구조를 가지지만, 프로그래밍, 수학, 영어 등 과목마다 구체적인 진행 방식은 다릅니다.

### Java 코드로 구현

```java
/**
 * 강의 추상 클래스
 */
public abstract class Course {
    protected String courseName;
    protected String professor;
    protected int credits;
    protected int[] scores;  // 학생 점수
    protected int studentCount;

    public Course(String courseName, String professor, int credits) {
        this.courseName = courseName;
        this.professor = professor;
        this.credits = credits;
        this.scores = new int[50];
        this.studentCount = 0;
    }

    // 추상 메서드
    public abstract void takeAttendance();
    public abstract void lecture();
    public abstract void assignHomework();
    public abstract void evaluate();

    // 템플릿 메서드
    public final void conductClass() {
        System.out.println("\n📖 " + courseName + " 수업 진행");
        System.out.println("담당교수: " + professor);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");

        takeAttendance();
        lecture();
        assignHomework();

        System.out.println("\n수업 종료");
    }

    // 공통 메서드
    public void showCourseInfo() {
        System.out.println("\n📚 강의 정보");
        System.out.println("과목명: " + courseName);
        System.out.println("교수: " + professor);
        System.out.println("학점: " + credits);
        System.out.println("수강생: " + studentCount + "명");
    }
}

/**
 * 프로그래밍 강의
 */
public class ProgrammingCourse extends Course {
    private String language;

    public ProgrammingCourse(String courseName, String professor,
                            int credits, String language) {
        super(courseName, professor, credits);
        this.language = language;
    }

    @Override
    public void takeAttendance() {
        System.out.println("\n✅ 출석 체크");
        System.out.println("GitHub 계정으로 자동 출석 확인");
        studentCount = 30;
        System.out.println("출석: " + studentCount + "명");
    }

    @Override
    public void lecture() {
        System.out.println("\n💻 강의 진행");
        System.out.println("언어: " + language);
        System.out.println("1. 이론 설명 (30분)");
        System.out.println("2. 라이브 코딩 (60분)");
        System.out.println("3. 실습 (30분)");
    }

    @Override
    public void assignHomework() {
        System.out.println("\n📝 과제 부여");
        System.out.println("- 알고리즘 구현 (3문제)");
        System.out.println("- GitHub에 제출");
        System.out.println("- 마감: 1주일 후");
    }

    @Override
    public void evaluate() {
        System.out.println("\n📊 평가");
        System.out.println("중간고사(30%) + 기말고사(30%) + 과제(30%) + 출석(10%)");
        System.out.println("코딩 테스트로 진행");
    }
}

/**
 * 수학 강의
 */
public class MathCourse extends Course {
    private String mathField;

    public MathCourse(String courseName, String professor,
                     int credits, String mathField) {
        super(courseName, professor, credits);
        this.mathField = mathField;
    }

    @Override
    public void takeAttendance() {
        System.out.println("\n✅ 출석 체크");
        System.out.println("종이 출석부에 서명");
        studentCount = 40;
        System.out.println("출석: " + studentCount + "명");
    }

    @Override
    public void lecture() {
        System.out.println("\n📐 강의 진행");
        System.out.println("분야: " + mathField);
        System.out.println("1. 개념 설명 (40분)");
        System.out.println("2. 예제 풀이 (40분)");
        System.out.println("3. 연습 문제 (40분)");
    }

    @Override
    public void assignHomework() {
        System.out.println("\n📝 과제 부여");
        System.out.println("- 교재 연습문제 20문제");
        System.out.println("- 손으로 풀어서 제출");
        System.out.println("- 마감: 3일 후");
    }

    @Override
    public void evaluate() {
        System.out.println("\n📊 평가");
        System.out.println("중간(40%) + 기말(40%) + 과제(15%) + 출석(5%)");
        System.out.println("서술형 시험");
    }
}
```

### 핵심 포인트
1. **공통 수업 진행 절차** - conductClass()
2. **과목별 특화** - 프로그래밍은 코딩, 수학은 문제 풀이
3. **일관된 구조** - 모든 강의가 같은 단계를 거침

---

## 🎮 실생활 비유 5: 게임 캐릭터 기본 틀 {#비유5-게임-캐릭터}

### 비유 설명
RPG 게임의 모든 캐릭터는 "이동", "공격", "스킬 사용"이라는 공통 행동을 하지만, 전사, 마법사, 궁수마다 구체적인 동작과 효과가 다릅니다.

### Java 코드로 구현

```java
/**
 * 게임 캐릭터 추상 클래스
 */
public abstract class GameCharacter {
    protected String name;
    protected int level;
    protected int hp;
    protected int maxHp;
    protected int mp;
    protected int maxMp;
    protected int attack;
    protected int defense;

    public GameCharacter(String name, int level) {
        this.name = name;
        this.level = level;
        initializeStats();
    }

    // 추상 메서드
    protected abstract void initializeStats();
    public abstract void normalAttack(GameCharacter target);
    public abstract void useSkill(GameCharacter target);
    public abstract void useUltimate(GameCharacter target);

    // 공통 메서드
    public void move(int x, int y) {
        System.out.println(name + " 이동: (" + x + ", " + y + ")");
    }

    public void takeDamage(int damage) {
        int actualDamage = Math.max(1, damage - defense);
        hp = Math.max(0, hp - actualDamage);

        System.out.println(name + " 피해: -" + actualDamage + " HP");
        System.out.println("남은 HP: " + hp + "/" + maxHp);

        if (hp == 0) {
            die();
        }
    }

    protected void die() {
        System.out.println("💀 " + name + " 사망!");
    }

    public void showStatus() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━");
        System.out.println("이름: " + name);
        System.out.println("레벨: " + level);
        System.out.println("HP: " + hp + "/" + maxHp);
        System.out.println("MP: " + mp + "/" + maxMp);
        System.out.println("공격력: " + attack);
        System.out.println("방어력: " + defense);
        System.out.println("━━━━━━━━━━━━━━━━━━━━");
    }
}

/**
 * 전사
 */
public class Warrior extends GameCharacter {
    private int rage;  // 분노 게이지

    public Warrior(String name, int level) {
        super(name, level);
        this.rage = 0;
    }

    @Override
    protected void initializeStats() {
        maxHp = 500 + (level * 50);
        hp = maxHp;
        maxMp = 100 + (level * 10);
        mp = maxMp;
        attack = 50 + (level * 5);
        defense = 30 + (level * 3);
    }

    @Override
    public void normalAttack(GameCharacter target) {
        System.out.println("\n⚔️ " + name + "의 일반 공격!");
        rage = Math.min(100, rage + 10);

        int damage = attack;
        target.takeDamage(damage);
        System.out.println("분노: +" + 10 + " (현재: " + rage + "/100)");
    }

    @Override
    public void useSkill(GameCharacter target) {
        if (mp < 20) {
            System.out.println("❌ MP 부족!");
            return;
        }

        System.out.println("\n🗡️ " + name + "의 강타!");
        mp -= 20;

        int damage = attack * 2;
        target.takeDamage(damage);
        rage = Math.min(100, rage + 20);
    }

    @Override
    public void useUltimate(GameCharacter target) {
        if (rage < 100) {
            System.out.println("❌ 분노 게이지 부족!");
            return;
        }

        System.out.println("\n💥 " + name + "의 광전사 난무!");
        System.out.println("필살기 발동!");

        rage = 0;
        int damage = attack * 5;

        for (int i = 0; i < 5; i++) {
            System.out.println((i + 1) + "타: " + damage);
            target.takeDamage(damage);
            if (target.hp == 0) break;
        }
    }
}

/**
 * 마법사
 */
public class Mage extends GameCharacter {
    private String element;  // 속성

    public Mage(String name, int level, String element) {
        super(name, level);
        this.element = element;
    }

    @Override
    protected void initializeStats() {
        maxHp = 300 + (level * 30);
        hp = maxHp;
        maxMp = 200 + (level * 20);
        mp = maxMp;
        attack = 70 + (level * 7);
        defense = 10 + (level * 1);
    }

    @Override
    public void normalAttack(GameCharacter target) {
        System.out.println("\n🪄 " + name + "의 마법 화살!");

        int damage = attack / 2;
        target.takeDamage(damage);
    }

    @Override
    public void useSkill(GameCharacter target) {
        if (mp < 40) {
            System.out.println("❌ MP 부족!");
            return;
        }

        System.out.println("\n🔥 " + name + "의 " + element + " 마법!");
        mp -= 40;

        int damage = attack * 3;
        System.out.println("마법 폭발!");
        target.takeDamage(damage);
    }

    @Override
    public void useUltimate(GameCharacter target) {
        if (mp < 100) {
            System.out.println("❌ MP 부족!");
            return;
        }

        System.out.println("\n⭐ " + name + "의 메테오!");
        System.out.println("하늘에서 운석이 떨어진다!");

        mp -= 100;
        int damage = attack * 10;
        target.takeDamage(damage);
    }
}

/**
 * 궁수
 */
public class Archer extends GameCharacter {
    private int arrows;

    public Archer(String name, int level) {
        super(name, level);
        this.arrows = 30;
    }

    @Override
    protected void initializeStats() {
        maxHp = 400 + (level * 40);
        hp = maxHp;
        maxMp = 150 + (level * 15);
        mp = maxMp;
        attack = 60 + (level * 6);
        defense = 20 + (level * 2);
    }

    @Override
    public void normalAttack(GameCharacter target) {
        if (arrows == 0) {
            System.out.println("❌ 화살이 없습니다!");
            return;
        }

        System.out.println("\n🏹 " + name + "의 화살 발사!");
        arrows--;

        int damage = attack;
        target.takeDamage(damage);
        System.out.println("남은 화살: " + arrows);
    }

    @Override
    public void useSkill(GameCharacter target) {
        if (mp < 30 || arrows < 3) {
            System.out.println("❌ MP 또는 화살 부족!");
            return;
        }

        System.out.println("\n🎯 " + name + "의 연발!");
        mp -= 30;
        arrows -= 3;

        for (int i = 0; i < 3; i++) {
            int damage = attack;
            System.out.println((i + 1) + "발!");
            target.takeDamage(damage);
            if (target.hp == 0) break;
        }
    }

    @Override
    public void useUltimate(GameCharacter target) {
        if (mp < 80) {
            System.out.println("❌ MP 부족!");
            return;
        }

        System.out.println("\n💫 " + name + "의 관통샷!");
        System.out.println("마법 화살 생성!");

        mp -= 80;
        int damage = attack * 8;
        target.takeDamage(damage);
    }
}
```

### 실행 테스트

```java
public class GameTest {
    public static void main(String[] args) {
        Warrior warrior = new Warrior("아서스", 10);
        Mage mage = new Mage("간달프", 10, "불");
        Archer archer = new Archer("레골라스", 10);

        System.out.println("⚔️ 전투 시작!");

        warrior.showStatus();
        mage.showStatus();

        // 전사의 공격
        warrior.normalAttack(mage);
        warrior.normalAttack(mage);
        warrior.useSkill(mage);

        // 마법사의 반격
        mage.useSkill(warrior);

        // 궁수 합류
        archer.useSkill(mage);

        System.out.println("\n\n💡 추상 클래스의 핵심:");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ GameCharacter는 모든 캐릭터의 틀");
        System.out.println("✅ 각 직업은 고유한 스킬 구현");
        System.out.println("✅ 공통 기능(이동, 피해)은 재사용");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

### 핵심 포인트
1. **캐릭터 기본 틀** - 모든 캐릭터가 가져야 할 속성/메서드
2. **직업별 특화** - 전사는 분노, 마법사는 MP, 궁수는 화살
3. **확장 가능** - 새로운 직업 추가 용이

---

## 📚 다음 단계

Part 2에서는 다음 내용을 다룹니다:
- **기업 사례 1**: Spring Framework의 추상 클래스 활용
- **기업 사례 2**: Android Activity 생명주기
- **기업 사례 3**: 게임 엔진의 GameObject
- **주니어 개발자 시나리오**: 추상 클래스 관련 흔한 실수 4가지

---

**작성일**: 2025-01-10
**챕터**: 18. 추상 클래스 (Abstract Class) - Part 1
