# 39장 네트워크 프로그래밍 - Part 3: 면접 질문 및 채팅 프로젝트

> **학습 목표**: 네트워크 면접 질문에 답변하고 실시간 채팅 서버를 구현한다

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐⭐ (5/5)

---

## 🎤 주니어 면접 질문 (7개)

### Q1. TCP와 UDP의 차이는?

**모범 답변**:
```
TCP (Transmission Control Protocol):
- 연결 지향 (3-way handshake)
- 신뢰성 보장 (재전송, 순서 보장, 에러 검출)
- 느림 (오버헤드)
- 1:1 통신
- 예: HTTP, FTP, 이메일

UDP (User Datagram Protocol):
- 비연결 (연결 설정 없음)
- 신뢰성 미보장 (패킷 손실 가능)
- 빠름 (오버헤드 적음)
- 1:1, 1:N, N:N 가능
- 예: DNS, 실시간 스트리밍, 온라인 게임

선택 기준:
- 데이터 무결성 중요 → TCP
- 실시간성 중요 → UDP
```

**코드 예시**:
```java
// TCP (Socket)
Socket socket = new Socket("localhost", 8080);
OutputStream out = socket.getOutputStream();
out.write("Hello".getBytes());  // 신뢰성 보장

// UDP (DatagramSocket)
DatagramSocket socket = new DatagramSocket();
byte[] data = "Hello".getBytes();
DatagramPacket packet = new DatagramPacket(
    data, data.length,
    InetAddress.getByName("localhost"), 8080);
socket.send(packet);  // 빠르지만 손실 가능
```

**꼬리 질문**:
- Q: TCP의 3-way handshake 과정을 설명해주세요.
- A: ① 클라이언트 → 서버: SYN, ② 서버 → 클라이언트: SYN+ACK, ③ 클라이언트 → 서버: ACK

**실무 연관**:
- 카카오톡 메시지 → TCP (메시지 무결성)
- 넷플릭스 스트리밍 → UDP (실시간성, 일부 프레임 손실 허용)

---

### Q2. Socket과 ServerSocket의 차이는?

**모범 답변**:
```
ServerSocket:
- 서버 측에서 사용
- 특정 포트를 바인딩
- accept()로 클라이언트 연결 대기 (블로킹)
- 연결 수립 시 Socket 반환

Socket:
- 클라이언트/서버 양쪽 사용
- 실제 데이터 송수신
- InputStream/OutputStream 제공
- 연결 종료 시 close()

역할:
ServerSocket → 전화기 (걸려오는 전화 대기)
Socket → 통화 (실제 대화)
```

**코드 예시**:
```java
// 서버: ServerSocket으로 연결 대기
ServerSocket serverSocket = new ServerSocket(8080);
System.out.println("서버 대기 중...");

Socket clientSocket = serverSocket.accept();  // 블로킹
System.out.println("클라이언트 연결됨!");

// 이후 Socket으로 통신
InputStream in = clientSocket.getInputStream();
OutputStream out = clientSocket.getOutputStream();

// 클라이언트: Socket으로 연결
Socket socket = new Socket("localhost", 8080);
System.out.println("서버 연결 성공!");

// 양쪽 모두 Socket으로 통신
```

**꼬리 질문**:
- Q: accept()가 블로킹 메서드인데, 여러 클라이언트를 어떻게 처리하나요?
- A: 멀티스레드를 사용합니다. accept() 후 새로운 스레드에서 Socket 처리

**실무 연관**:
- 웹 서버: ServerSocket으로 HTTP 요청 대기
- 각 요청은 별도 스레드에서 Socket으로 처리

---

### Q3. Java에서 Socket 프로그래밍의 기본 흐름은?

**모범 답변**:
```
서버:
1. ServerSocket 생성 (포트 바인딩)
2. accept()로 클라이언트 대기
3. Socket 획득
4. InputStream/OutputStream 획득
5. 데이터 송수신
6. close()

클라이언트:
1. Socket 생성 (서버 주소, 포트)
2. InputStream/OutputStream 획득
3. 데이터 송수신
4. close()
```

**코드 예시**:
```java
// 서버
ServerSocket serverSocket = new ServerSocket(8080);
Socket socket = serverSocket.accept();

BufferedReader in = new BufferedReader(
    new InputStreamReader(socket.getInputStream()));
PrintWriter out = new PrintWriter(
    socket.getOutputStream(), true);

String message = in.readLine();  // 수신
out.println("응답: " + message);  // 송신

socket.close();

// 클라이언트
Socket socket = new Socket("localhost", 8080);

PrintWriter out = new PrintWriter(
    socket.getOutputStream(), true);
BufferedReader in = new BufferedReader(
    new InputStreamReader(socket.getInputStream()));

out.println("안녕하세요");  // 송신
String response = in.readLine();  // 수신
System.out.println(response);

socket.close();
```

**꼬리 질문**:
- Q: try-with-resources를 사용하면 어떤 이점이 있나요?
- A: 자동으로 close() 호출되어 리소스 누수 방지

**실무 연관**:
- 모든 네트워크 통신의 기본 패턴
- Spring Boot 내부에서도 Tomcat이 이 방식으로 HTTP 처리

---

### Q4. InputStream과 OutputStream의 역할은?

**모범 답변**:
```
InputStream (입력 스트림):
- 데이터를 읽는 추상 클래스
- Socket → 애플리케이션 (수신)
- read() 메서드로 바이트 읽기
- 블로킹 메서드 (데이터 올 때까지 대기)

OutputStream (출력 스트림):
- 데이터를 쓰는 추상 클래스
- 애플리케이션 → Socket (송신)
- write() 메서드로 바이트 쓰기

관계:
Socket.getInputStream() → 상대방이 보낸 데이터 읽기
Socket.getOutputStream() → 상대방에게 데이터 쓰기
```

**코드 예시**:
```java
Socket socket = new Socket("localhost", 8080);

// InputStream: 서버에서 받은 데이터 읽기
InputStream in = socket.getInputStream();
int data = in.read();  // 1바이트 읽기
System.out.println("받은 데이터: " + data);

// OutputStream: 서버로 데이터 쓰기
OutputStream out = socket.getOutputStream();
out.write(65);  // 'A' 전송
out.flush();    // 버퍼 비우기

// 바이트 배열로 읽기/쓰기
byte[] buffer = new byte[1024];
int bytesRead = in.read(buffer);
out.write(buffer, 0, bytesRead);
```

**꼬리 질문**:
- Q: flush()는 왜 필요한가요?
- A: 버퍼에 쌓인 데이터를 즉시 전송하기 위해. 안 하면 버퍼가 차거나 close()될 때까지 전송 안 될 수 있음

**실무 연관**:
- 파일 업로드/다운로드
- 이미지 전송
- 바이너리 프로토콜 (Protobuf, Thrift)

---

### Q5. BufferedReader/PrintWriter를 사용하는 이유는?

**모범 답변**:
```
장점:
1. 성능 향상 (버퍼링)
2. 편의성 (readLine(), println())
3. 문자 인코딩 처리 (InputStreamReader)

BufferedReader:
- readLine()으로 한 줄씩 읽기
- 내부 버퍼로 I/O 횟수 감소

PrintWriter:
- println()으로 줄 단위 쓰기
- 자동 flush 옵션
- 포맷팅 지원
```

**코드 예시**:
```java
Socket socket = new Socket("localhost", 8080);

// ❌ 비효율적 (바이트 단위)
InputStream in = socket.getInputStream();
int ch;
while ((ch = in.read()) != -1) {  // 1바이트씩 읽기 (느림)
    System.out.print((char) ch);
}

// ✅ 효율적 (버퍼링 + 줄 단위)
BufferedReader reader = new BufferedReader(
    new InputStreamReader(socket.getInputStream()));

String line;
while ((line = reader.readLine()) != null) {  // 한 줄씩 읽기
    System.out.println(line);
}

// ✅ PrintWriter (자동 flush)
PrintWriter writer = new PrintWriter(
    socket.getOutputStream(), true);  // true = auto flush

writer.println("안녕하세요");  // 자동으로 flush!
```

**꼬리 질문**:
- Q: BufferedReader의 버퍼 크기는 얼마나 되나요?
- A: 기본 8KB (8192 바이트). 생성자로 변경 가능

**실무 연관**:
- HTTP 프로토콜 파싱 (헤더는 줄 단위)
- 채팅 서버 (메시지는 줄 단위)
- 로그 파일 읽기

---

### Q6. 포트 번호(Port)는 무엇인가요?

**모범 답변**:
```
포트 번호:
- IP 주소 내에서 프로세스를 구분하는 번호
- 16비트 정수 (0~65535)
- IP = 아파트 주소, 포트 = 호수

범위:
- 0~1023: Well-known ports (HTTP=80, HTTPS=443, FTP=21)
- 1024~49151: Registered ports
- 49152~65535: Dynamic ports (임시 사용)

역할:
하나의 서버에서 여러 서비스 운영 가능
- 웹 서버: 80번 포트
- SSH: 22번 포트
- MySQL: 3306번 포트
```

**코드 예시**:
```java
// 서버: 특정 포트에 바인딩
ServerSocket serverSocket = new ServerSocket(8080);
System.out.println("서버 포트: " + serverSocket.getLocalPort());

// 클라이언트: 서버 포트에 연결
Socket socket = new Socket("localhost", 8080);
System.out.println("로컬 포트: " + socket.getLocalPort());     // 50123 (임시)
System.out.println("원격 포트: " + socket.getPort());          // 8080

// 포트 충돌
try {
    ServerSocket s1 = new ServerSocket(8080);
    ServerSocket s2 = new ServerSocket(8080);  // ❌ 예외!
} catch (BindException e) {
    System.err.println("포트 이미 사용 중!");
}
```

**꼬리 질문**:
- Q: 로컬 포트는 왜 50123 같은 큰 숫자인가요?
- A: OS가 자동으로 할당하는 임시 포트 (Ephemeral Port). 연결마다 다름

**실무 연관**:
- 개발 환경: 8080, 3000 등 사용
- 운영 환경: 80 (HTTP), 443 (HTTPS)
- Docker: 포트 매핑 (호스트:컨테이너)

---

### Q7. localhost와 127.0.0.1의 차이는?

**모범 답변**:
```
공통점:
- 둘 다 자기 자신(loopback)을 가리킴
- 네트워크 카드 거치지 않음 (가상 인터페이스)

차이점:
localhost:
- 호스트명 (hostname)
- DNS 조회 필요 (hosts 파일 참조)
- IPv6도 가능 (::1)

127.0.0.1:
- IPv4 주소
- DNS 조회 불필요 (더 빠름)
- IPv4만 가능

/etc/hosts 파일:
127.0.0.1  localhost
::1        localhost
```

**코드 예시**:
```java
// localhost (호스트명)
Socket s1 = new Socket("localhost", 8080);
// DNS 조회: localhost → 127.0.0.1

// 127.0.0.1 (IP 주소)
Socket s2 = new Socket("127.0.0.1", 8080);
// DNS 조회 없음 (약간 더 빠름)

// IP 주소 확인
InetAddress addr1 = InetAddress.getByName("localhost");
System.out.println(addr1.getHostAddress());  // 127.0.0.1

InetAddress addr2 = InetAddress.getByName("127.0.0.1");
System.out.println(addr2.getHostName());     // localhost

// IPv6 loopback
Socket s3 = new Socket("::1", 8080);  // IPv6
```

**꼬리 질문**:
- Q: 0.0.0.0은 무엇인가요?
- A: "모든 네트워크 인터페이스"를 의미. 서버 바인딩 시 외부 접속 허용

**실무 연관**:
- 개발 환경: localhost 또는 127.0.0.1 사용
- Docker: host.docker.internal (Mac/Windows)
- 외부 접속 차단: 보안을 위해 127.0.0.1만 바인딩

---

## 🎤 중급 면접 질문 (5개)

### Q1. 블로킹(Blocking)과 논블로킹(Non-blocking) I/O의 차이는?

**모범 답변**:
```
블로킹 I/O (BIO):
- 데이터 준비될 때까지 대기
- 스레드 블로킹 (CPU 낭비)
- 간단한 코드
- 클라이언트 수 = 스레드 수
- 예: Socket, ServerSocket

논블로킹 I/O (NIO):
- 즉시 반환 (데이터 없어도)
- 스레드 블로킹 안 됨
- 복잡한 코드 (Selector, Channel)
- 하나의 스레드로 다수 클라이언트 처리
- 예: Java NIO, Netty

성능:
- 클라이언트 < 100명 → BIO 충분
- 클라이언트 > 1000명 → NIO 필수 (C10K 문제)
```

**코드 예시**:
```java
// ❌ 블로킹 I/O (1 클라이언트 = 1 스레드)
ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket socket = serverSocket.accept();  // 블로킹
    new Thread(() -> {
        try {
            InputStream in = socket.getInputStream();
            int data = in.read();  // 블로킹
            // 처리...
        } catch (IOException e) {
            e.printStackTrace();
        }
    }).start();
}
// 10,000명 접속 → 10,000개 스레드 (메모리 부족!)

// ✅ 논블로킹 I/O (1 스레드 = N 클라이언트)
Selector selector = Selector.open();
ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false);  // 논블로킹!
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();  // 이벤트 대기
    Set<SelectionKey> keys = selector.selectedKeys();

    for (SelectionKey key : keys) {
        if (key.isAcceptable()) {
            // 연결 수락
        } else if (key.isReadable()) {
            // 데이터 읽기
        }
    }
    keys.clear();
}
// 10,000명 접속 → 1개 스레드!
```

**꼬리 질문**:
- Q: NIO가 더 좋은데 왜 BIO를 쓰나요?
- A: 코드 간결성. 소규모 서비스는 BIO로 충분. NIO는 복잡하고 디버깅 어려움

**실무 연관**:
- Tomcat: BIO (기본, 간단) / NIO (고성능)
- Netty: NIO 기반 프레임워크 (카카오톡, LINE 서버)
- Redis: 단일 스레드 + NIO (초당 10만 요청)

---

### Q2. 멀티스레드 서버에서 발생할 수 있는 동시성 문제는?

**모범 답변**:
```
문제점:
1. 공유 자원 경쟁 (Race Condition)
   - 여러 스레드가 동시에 접근
   - 데이터 불일치

2. 데드락 (Deadlock)
   - 서로 자원 대기
   - 무한 대기

3. 메모리 가시성 (Visibility)
   - CPU 캐시 문제
   - 변경사항 다른 스레드에 안 보임

해결 방법:
1. synchronized
2. ReentrantLock
3. ConcurrentHashMap
4. AtomicInteger
5. volatile
```

**코드 예시**:
```java
// ❌ 동시성 문제
public class ChatServer {
    private static List<PrintWriter> clients = new ArrayList<>();  // 위험!

    public static void addClient(PrintWriter writer) {
        clients.add(writer);  // 여러 스레드가 동시 접근 → ConcurrentModificationException
    }

    public static void broadcast(String message) {
        for (PrintWriter writer : clients) {  // 반복 중 다른 스레드가 add() 호출 시 예외
            writer.println(message);
        }
    }
}

// ✅ 해결 방법 1: synchronized
public class ChatServer {
    private static List<PrintWriter> clients = new ArrayList<>();

    public static synchronized void addClient(PrintWriter writer) {
        clients.add(writer);
    }

    public static synchronized void broadcast(String message) {
        for (PrintWriter writer : clients) {
            writer.println(message);
        }
    }
}

// ✅ 해결 방법 2: CopyOnWriteArrayList (권장)
public class ChatServer {
    private static List<PrintWriter> clients =
        new CopyOnWriteArrayList<>();  // 쓰레드 안전!

    public static void addClient(PrintWriter writer) {
        clients.add(writer);  // synchronized 불필요
    }

    public static void broadcast(String message) {
        for (PrintWriter writer : clients) {
            writer.println(message);
        }
    }
}
```

**꼬리 질문**:
- Q: CopyOnWriteArrayList는 왜 안전한가요?
- A: 쓰기 시 배열 복사. 읽기는 락 없이 안전. 읽기가 많고 쓰기가 적을 때 적합

**실무 연관**:
- 채팅 서버: 접속자 목록 관리
- 게임 서버: 플레이어 동기화
- 웹 서버: 세션 관리

---

### Q3. HTTP 통신과 Socket 통신의 차이는?

**모범 답변**:
```
Socket 통신:
- Low-level (Transport Layer)
- 연결 유지 (Persistent Connection)
- 양방향 통신 (Full-duplex)
- 프로토콜 자유 (직접 정의)
- 복잡한 구현
- 예: 채팅, 게임, IoT

HTTP 통신:
- High-level (Application Layer)
- 연결 비유지 (Stateless)
- 요청/응답 (Request/Response)
- HTTP 프로토콜 (표준)
- 간단한 구현
- 예: REST API, 웹 페이지

관계:
HTTP는 Socket 위에 구현된 프로토콜
Socket → TCP → HTTP
```

**코드 예시**:
```java
// Socket 통신 (Raw)
Socket socket = new Socket("example.com", 80);
PrintWriter out = new PrintWriter(socket.getOutputStream());
BufferedReader in = new BufferedReader(
    new InputStreamReader(socket.getInputStream()));

// HTTP 요청 직접 작성
out.println("GET / HTTP/1.1");
out.println("Host: example.com");
out.println("Connection: close");
out.println();
out.flush();

// 응답 읽기
String line;
while ((line = in.readLine()) != null) {
    System.out.println(line);
}

socket.close();

// HTTP 통신 (HttpURLConnection)
URL url = new URL("http://example.com/");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod("GET");

int responseCode = conn.getResponseCode();
BufferedReader reader = new BufferedReader(
    new InputStreamReader(conn.getInputStream()));

String responseLine;
while ((responseLine = reader.readLine()) != null) {
    System.out.println(responseLine);
}

conn.disconnect();
```

**꼬리 질문**:
- Q: WebSocket은 HTTP인가요, Socket인가요?
- A: 둘 다. HTTP로 Handshake 후 Socket 통신으로 전환

**실무 연관**:
- REST API → HTTP (HttpClient, RestTemplate)
- 실시간 채팅 → WebSocket (HTTP → Socket 업그레이드)
- 스트리밍 → Socket (RTMP, HLS)

---

### Q4. Connection Pool은 무엇이고 왜 필요한가요?

**모범 답변**:
```
Connection Pool:
- 미리 연결을 생성하여 재사용
- 연결 생성/해제 비용 절감
- 동시 연결 수 제한

필요한 이유:
1. 성능: 연결 재사용 (3-way handshake 생략)
2. 자원 관리: 연결 수 제한 (서버 과부하 방지)
3. 안정성: 연결 상태 관리

종류:
- DB Connection Pool: HikariCP, DBCP
- HTTP Connection Pool: Apache HttpClient
```

**코드 예시**:
```java
// ❌ Connection Pool 없음 (비효율)
public class APIClient {
    public String request(String url) throws IOException {
        // 매번 새로운 연결 생성 (3-way handshake)
        Socket socket = new Socket("api.example.com", 80);

        // 요청 송수신
        PrintWriter out = new PrintWriter(socket.getOutputStream());
        out.println("GET " + url + " HTTP/1.1");
        out.println("Host: api.example.com");
        out.println();
        out.flush();

        // 응답 읽기
        BufferedReader in = new BufferedReader(
            new InputStreamReader(socket.getInputStream()));
        String response = in.readLine();

        socket.close();  // 연결 종료

        return response;
    }

    // 100번 호출 → 100번 연결/해제 (느림!)
}

// ✅ Connection Pool 사용 (효율적)
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;

public class APIClient {
    private static CloseableHttpClient httpClient;

    static {
        PoolingHttpClientConnectionManager cm =
            new PoolingHttpClientConnectionManager();
        cm.setMaxTotal(100);  // 최대 100개 연결
        cm.setDefaultMaxPerRoute(20);  // 호스트당 20개

        httpClient = HttpClients.custom()
            .setConnectionManager(cm)
            .build();
    }

    public String request(String url) throws IOException {
        HttpGet httpGet = new HttpGet(url);

        // Pool에서 연결 가져옴 (재사용!)
        CloseableHttpResponse response = httpClient.execute(httpGet);

        // 응답 처리
        String result = EntityUtils.toString(response.getEntity());

        response.close();  // Pool에 반납

        return result;
    }

    // 100번 호출 → 연결 재사용 (빠름!)
}
```

**꼬리 질문**:
- Q: Pool 크기는 어떻게 정하나요?
- A: 동시 요청 수, 서버 사양 고려. 보통 CPU 코어 수 × 2 ~ 10배

**실무 연관**:
- Spring Boot: HikariCP (DB 연결 풀)
- Apache HttpClient: HTTP 연결 풀
- Redis: Jedis Pool

---

### Q5. NIO (New I/O)와 기존 I/O의 차이는?

**모범 답변**:
```
기존 I/O (Java IO):
- 스트림 기반 (Stream-oriented)
- 블로킹 (Blocking)
- 단방향 (InputStream/OutputStream)
- 바이트 단위 처리
- 간단한 API

NIO (Java New I/O):
- 버퍼 기반 (Buffer-oriented)
- 논블로킹 (Non-blocking)
- 양방향 (Channel)
- 블록 단위 처리 (Buffer)
- 복잡한 API
- Selector (다중화)

성능:
- 소규모: I/O가 간단하고 빠름
- 대규모: NIO가 효율적 (C10K 해결)
```

**코드 예시**:
```java
// 기존 I/O (블로킹)
ServerSocket serverSocket = new ServerSocket(8080);
while (true) {
    Socket socket = serverSocket.accept();  // 블로킹

    InputStream in = socket.getInputStream();
    byte[] buffer = new byte[1024];
    int bytesRead = in.read(buffer);  // 블로킹

    String data = new String(buffer, 0, bytesRead);
    System.out.println("받은 데이터: " + data);
}

// NIO (논블로킹 + Selector)
Selector selector = Selector.open();

ServerSocketChannel serverChannel = ServerSocketChannel.open();
serverChannel.bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false);  // 논블로킹!

// Selector에 등록
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

ByteBuffer buffer = ByteBuffer.allocate(1024);

while (true) {
    selector.select();  // 이벤트 대기 (블로킹이지만 1개 스레드로 다수 처리)

    Set<SelectionKey> keys = selector.selectedKeys();
    Iterator<SelectionKey> iter = keys.iterator();

    while (iter.hasNext()) {
        SelectionKey key = iter.next();
        iter.remove();

        if (key.isAcceptable()) {
            // 새 연결
            ServerSocketChannel server = (ServerSocketChannel) key.channel();
            SocketChannel client = server.accept();
            client.configureBlocking(false);
            client.register(selector, SelectionKey.OP_READ);

        } else if (key.isReadable()) {
            // 데이터 읽기
            SocketChannel client = (SocketChannel) key.channel();
            buffer.clear();
            int bytesRead = client.read(buffer);  // 논블로킹!

            if (bytesRead > 0) {
                buffer.flip();
                byte[] data = new byte[buffer.remaining()];
                buffer.get(data);
                System.out.println("받은 데이터: " + new String(data));
            }
        }
    }
}
```

**꼬리 질문**:
- Q: Netty는 무엇인가요?
- A: NIO 기반 고성능 네트워크 프레임워크. 복잡한 NIO를 쉽게 사용

**실무 연관**:
- Tomcat: BIO (기본) / NIO (고성능 모드)
- Netty: 카카오톡, LINE, Elasticsearch
- Kafka: NIO 기반 메시징

---

## 🛠️ 실전 프로젝트: 멀티 채팅 서버

### 프로젝트 구조

```
ChatServer:
- 여러 클라이언트 동시 연결
- 메시지 브로드캐스팅 (전체 전송)
- 닉네임 설정
- 입장/퇴장 알림
- 명령어 (/list, /quit)

ChatClient:
- 서버 연결
- 메시지 송수신
- 별도 스레드로 메시지 수신
```

---

### ChatServer.java

```java
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

public class ChatServer {
    private static final int PORT = 9999;
    private static List<ClientHandler> clients = new CopyOnWriteArrayList<>();

    public static void main(String[] args) {
        System.out.println("=== 채팅 서버 시작 ===");
        System.out.println("포트: " + PORT);

        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            while (true) {
                Socket socket = serverSocket.accept();
                System.out.println("새 연결: " + socket.getInetAddress());

                ClientHandler handler = new ClientHandler(socket);
                clients.add(handler);
                new Thread(handler).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void broadcast(String message, ClientHandler sender) {
        for (ClientHandler client : clients) {
            if (client != sender) {
                client.sendMessage(message);
            }
        }
    }

    public static void broadcastAll(String message) {
        for (ClientHandler client : clients) {
            client.sendMessage(message);
        }
    }

    public static void removeClient(ClientHandler client) {
        clients.remove(client);
    }

    public static String getClientList() {
        StringBuilder sb = new StringBuilder("=== 접속자 목록 ===\n");
        for (ClientHandler client : clients) {
            sb.append("- ").append(client.getNickname()).append("\n");
        }
        sb.append("총 ").append(clients.size()).append("명");
        return sb.toString();
    }
}

class ClientHandler implements Runnable {
    private Socket socket;
    private PrintWriter out;
    private BufferedReader in;
    private String nickname;

    public ClientHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try {
            in = new BufferedReader(
                new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(socket.getOutputStream(), true);

            // 닉네임 설정
            out.println("닉네임을 입력하세요:");
            nickname = in.readLine();

            String enterMessage = "✅ " + nickname + "님이 입장했습니다.";
            System.out.println(enterMessage);
            ChatServer.broadcastAll(enterMessage);

            // 메시지 수신 루프
            String message;
            while ((message = in.readLine()) != null) {
                System.out.println("[" + nickname + "] " + message);

                if (message.startsWith("/")) {
                    handleCommand(message);
                } else {
                    String chatMessage = "[" + nickname + "] " + message;
                    ChatServer.broadcast(chatMessage, this);
                }
            }

        } catch (IOException e) {
            System.out.println(nickname + " 연결 끊김");
        } finally {
            cleanup();
        }
    }

    private void handleCommand(String command) {
        if (command.equals("/quit")) {
            sendMessage("안녕히 가세요!");
            cleanup();
        } else if (command.equals("/list")) {
            sendMessage(ChatServer.getClientList());
        } else {
            sendMessage("알 수 없는 명령어입니다.");
        }
    }

    public void sendMessage(String message) {
        if (out != null) {
            out.println(message);
        }
    }

    public String getNickname() {
        return nickname;
    }

    private void cleanup() {
        try {
            String exitMessage = "❌ " + nickname + "님이 퇴장했습니다.";
            ChatServer.broadcastAll(exitMessage);
            ChatServer.removeClient(this);

            if (socket != null) socket.close();
            if (in != null) in.close();
            if (out != null) out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

### ChatClient.java

```java
import java.io.*;
import java.net.*;
import java.util.Scanner;

public class ChatClient {
    private static final String SERVER_HOST = "localhost";
    private static final int SERVER_PORT = 9999;

    public static void main(String[] args) {
        try {
            Socket socket = new Socket(SERVER_HOST, SERVER_PORT);
            System.out.println("✅ 서버 연결 성공");

            // 수신 스레드 시작
            new Thread(new ReceiveHandler(socket)).start();

            // 송신 (메인 스레드)
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            Scanner scanner = new Scanner(System.in);

            while (true) {
                String message = scanner.nextLine();
                out.println(message);

                if (message.equals("/quit")) {
                    break;
                }
            }

            socket.close();
            System.out.println("연결 종료");

        } catch (IOException e) {
            System.err.println("서버 연결 실패: " + e.getMessage());
        }
    }
}

class ReceiveHandler implements Runnable {
    private Socket socket;

    public ReceiveHandler(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        try (BufferedReader in = new BufferedReader(
                new InputStreamReader(socket.getInputStream()))) {

            String message;
            while ((message = in.readLine()) != null) {
                System.out.println(message);
            }

        } catch (IOException e) {
            System.out.println("서버 연결 끊김");
        }
    }
}
```

---

### 실행 예시

**터미널 1 (서버)**:
```bash
javac ChatServer.java
java ChatServer

=== 채팅 서버 시작 ===
포트: 9999
새 연결: /127.0.0.1
✅ 철수님이 입장했습니다.
새 연결: /127.0.0.1
✅ 영희님이 입장했습니다.
[철수] 안녕하세요!
[영희] 반가워요~
```

**터미널 2 (클라이언트 1)**:
```bash
javac ChatClient.java
java ChatClient

✅ 서버 연결 성공
닉네임을 입력하세요:
철수
✅ 철수님이 입장했습니다.
안녕하세요!
[영희] 반가워요~
/list
=== 접속자 목록 ===
- 철수
- 영희
총 2명
```

**터미널 3 (클라이언트 2)**:
```bash
java ChatClient

✅ 서버 연결 성공
닉네임을 입력하세요:
영희
✅ 영희님이 입장했습니다.
[철수] 안녕하세요!
반가워요~
```

---

## 🎯 핵심 정리

### 네트워크 프로그래밍 체크리스트

```java
// ✅ 완벽한 Socket 서버 템플릿
public class Server {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8080)) {
            System.out.println("서버 시작: 포트 8080");

            while (true) {
                Socket socket = serverSocket.accept();

                // 멀티스레드 처리
                new Thread(() -> {
                    try (
                        BufferedReader in = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                        PrintWriter out = new PrintWriter(
                            socket.getOutputStream(), true)
                    ) {
                        String message = in.readLine();
                        out.println("응답: " + message);

                    } catch (IOException e) {
                        e.printStackTrace();
                    } finally {
                        try {
                            socket.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 주요 개념 정리

| 개념 | 설명 | 사용 시기 |
|------|------|----------|
| TCP | 연결 지향, 신뢰성 보장 | HTTP, 채팅, 파일 전송 |
| UDP | 비연결, 빠름 | 스트리밍, 게임 |
| Socket | 양방향 통신 | 실시간 통신 |
| HTTP | 요청/응답, Stateless | REST API |
| BIO | 블로킹, 간단 | 소규모 서버 |
| NIO | 논블로킹, 복잡 | 대규모 서버 (C10K) |

---

## 🎉 39장 완료!

**축하합니다!** 네트워크 프로그래밍을 마스터했습니다!

**이제 여러분은**:
- ✅ TCP/UDP 차이 이해
- ✅ Socket 프로그래밍 구현
- ✅ HTTP API 호출
- ✅ 멀티스레드 서버 구축
- ✅ 실시간 채팅 서버 개발 가능

**다음 장으로**: [40장: 데이터베이스 연동 (JDBC) →](40-1-데이터베이스-연동-JDBC-Part1.md)

**이전 Part**: [← 39-2: HTTP와 URL](39-2-네트워크-프로그래밍-Part2.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
