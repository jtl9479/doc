# 11-2장: JVM 메모리 구조 (심화편)

> **이전 내용 요약**: 11-1장에서는 Stack, Heap, Method Area의 개념과 기본 동작, 실전 프로젝트를 다뤘습니다.

> **이번 장의 목표**: GC 알고리즘, 메모리 튜닝, 프로파일링을 학습하고, FAQ와 면접 질문으로 완벽하게 마스터합니다.

**⏱️ 예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐⭐⭐ (5/5)

---

## 📚 목차
- [Garbage Collection 심화](#-garbage-collection-심화)
- [JVM 메모리 튜닝](#-jvm-메모리-튜닝)
- [메모리 프로파일링](#-메모리-프로파일링)
- [FAQ (자주 묻는 질문)](#-faq)
- [면접 질문 리스트](#-면접-질문-리스트)
- [핵심 정리](#-핵심-정리)
- [다음 단계](#-다음-단계)
- [추가 학습 자료](#-추가-학습-자료)

---

## 🗑️ Garbage Collection 심화

### GC의 동작 원리

**Mark-Sweep-Compact 알고리즘**:

```
1단계: Mark (표시)
   - Root에서 도달 가능한 객체 표시
   - Root: Stack의 지역 변수, static 변수, JNI 참조

2단계: Sweep (제거)
   - 표시되지 않은 객체(Garbage) 제거

3단계: Compact (압축)
   - 살아있는 객체를 한쪽으로 모음
   - 메모리 단편화 방지
```

### Heap 세대별 구조

```
┌─────────────────────────────────────────────────┐
│                  Java Heap                      │
├─────────────────────────────────────────────────┤
│                                                 │
│  Young Generation (1/3)                         │
│  ┌──────────────────────────────────────────┐  │
│  │ Eden Space (8/10)                        │  │
│  │  - 새 객체 생성                           │  │
│  │  - Minor GC 발생                         │  │
│  ├──────────────────────────────────────────┤  │
│  │ Survivor 0 (1/10)                        │  │
│  │  - Eden에서 살아남은 객체                 │  │
│  ├──────────────────────────────────────────┤  │
│  │ Survivor 1 (1/10)                        │  │
│  │  - S0에서 이동한 객체                     │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
│  Old Generation (2/3)                           │
│  ┌──────────────────────────────────────────┐  │
│  │  - 오래 살아남은 객체 (age threshold)     │  │
│  │  - Major GC / Full GC 발생               │  │
│  │  - 큰 객체 직접 할당 가능                 │  │
│  └──────────────────────────────────────────┘  │
│                                                 │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│  Metaspace (Java 8+, Native Memory 영역)       │
│  - 클래스 메타데이터                             │
│  - static 변수 (Java 8+는 Heap으로 이동)        │
└─────────────────────────────────────────────────┘
```

### GC 알고리즘 비교

| GC 종류 | 특징 | 사용 시나리오 | 옵션 |
|---------|------|--------------|------|
| **Serial GC** | 단일 스레드, Stop-the-World | 소규모 애플리케이션 | -XX:+UseSerialGC |
| **Parallel GC** | 멀티 스레드, 처리량 중시 | 배치 처리 | -XX:+UseParallelGC |
| **CMS GC** | 동시 수집, 지연 시간 중시 | 웹 애플리케이션 (deprecated) | -XX:+UseConcMarkSweepGC |
| **G1 GC** | 리전 기반, 예측 가능한 일시 정지 | Java 9+ 기본, 대부분 | -XX:+UseG1GC |
| **ZGC** | 초저지연 (<10ms), 대용량 Heap | 실시간 시스템 | -XX:+UseZGC |
| **Shenandoah** | 동시 압축, 저지연 | 클라우드 네이티브 | -XX:+UseShenandoahGC |

---

## ⚙️ JVM 메모리 튜닝

### 주요 JVM 옵션

```bash
# Heap 크기 설정
-Xms2g              # 초기 Heap 크기 (2GB)
-Xmx4g              # 최대 Heap 크기 (4GB)
-XX:NewRatio=2      # Young:Old 비율 (1:2)
-XX:SurvivorRatio=8 # Eden:Survivor 비율 (8:1:1)

# GC 알고리즘 선택
-XX:+UseG1GC                    # G1 GC 사용
-XX:MaxGCPauseMillis=200        # 목표 GC 일시 정지 시간 (200ms)
-XX:G1HeapRegionSize=16m        # G1 리전 크기

# GC 로그
-Xlog:gc*:file=gc.log:time,uptime:filecount=5,filesize=100m

# Metaspace 크기
-XX:MetaspaceSize=256m          # 초기 Metaspace
-XX:MaxMetaspaceSize=512m       # 최대 Metaspace

# Stack 크기
-Xss1m                          # 스레드당 Stack 크기 (1MB)

# OutOfMemory 시 Heap Dump
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/tmp/heapdump.hprof
```

### 실전 튜닝 예시

```bash
# 웹 애플리케이션 (응답 속도 중시)
java -Xms4g -Xmx4g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:+HeapDumpOnOutOfMemoryError \
     -jar app.jar

# 배치 처리 (처리량 중시)
java -Xms8g -Xmx8g \
     -XX:+UseParallelGC \
     -XX:ParallelGCThreads=8 \
     -jar batch.jar

# 실시간 시스템 (초저지연)
java -Xms16g -Xmx16g \
     -XX:+UseZGC \
     -XX:ZAllocationSpikeTolerance=5 \
     -jar realtime-app.jar
```

---

## 📊 메모리 프로파일링

### VisualVM 사용법

```bash
# VisualVM 실행
jvisualvm

# 모니터링 항목
1. Heap 사용량 실시간 그래프
2. GC 활동 추적
3. 스레드 상태 확인
4. Heap Dump 분석
```

### Heap Dump 분석

```bash
# Heap Dump 생성
jmap -dump:live,format=b,file=heap.bin <PID>

# Eclipse MAT로 분석
# 1. Dominator Tree: 메모리 점유율 높은 객체
# 2. Leak Suspects: 메모리 누수 의심 지점
# 3. Histogram: 클래스별 인스턴스 개수
```

---

## ❓ FAQ

<details>
<summary><strong>Q1: Stack Overflow와 OutOfMemory의 차이는?</strong></summary>

**A**: **발생 위치와 원인이 다릅니다.**

**StackOverflowError**:
```java
// Stack 메모리 초과 (기본 1MB)
public class StackOverflowDemo {
    public void recursion(int depth) {
        System.out.println("Depth: " + depth);
        recursion(depth + 1);  // 무한 재귀
        // 약 5000-10000번 호출 시 Stack 초과
        // java.lang.StackOverflowError
    }
}
```

**원인**:
- 재귀 호출이 너무 깊음
- Stack Frame이 계속 쌓임
- Stack 영역 초과

**해결책**:
```java
// 1. 재귀를 반복문으로 변경
// 2. Stack 크기 증가: -Xss2m
// 3. 재귀 깊이 제한
```

**OutOfMemoryError: Java heap space**:
```java
// Heap 메모리 초과
public class OutOfMemoryDemo {
    public static void main(String[] args) {
        List<byte[]> list = new ArrayList<>();
        while (true) {
            list.add(new byte[1024 * 1024]);  // 1MB씩 추가
            // Heap 크기 초과 시
            // java.lang.OutOfMemoryError: Java heap space
        }
    }
}
```

**원인**:
- Heap에 객체를 계속 추가
- GC가 회수할 객체 없음
- Heap 영역 초과

**해결책**:
```java
// 1. Heap 크기 증가: -Xmx4g
// 2. 메모리 누수 제거
// 3. 스트리밍 방식 사용
```

**비교표**:

| 구분 | StackOverflowError | OutOfMemoryError |
|------|-------------------|------------------|
| 발생 영역 | Stack | Heap |
| 주요 원인 | 깊은 재귀 | 메모리 누수 |
| 기본 크기 | 1MB | 물리 메모리의 1/4 |
| 튜닝 옵션 | -Xss | -Xmx |
| 예방 방법 | 재귀 제한 | 참조 제거 |

**실무 팁**:
💡 **StackOverflow는 코드 수정**으로, **OutOfMemory는 메모리 튜닝**으로 해결합니다.

</details>

<details>
<summary><strong>Q2: Minor GC와 Major GC의 차이는?</strong></summary>

**A**: **발생 위치와 영향 범위가 다릅니다.**

**Minor GC (Young GC)**:
```
발생 위치: Young Generation (Eden + Survivor)
발생 시점: Eden 영역이 가득 찼을 때
동작 방식:
1. Eden의 살아있는 객체 → Survivor 0로 이동
2. Survivor 0/1 간 복사 (age 증가)
3. age threshold 도달 시 → Old로 승격

소요 시간: 매우 짧음 (수 ms ~ 수십 ms)
빈도: 매우 자주 발생 (초당 여러 번)
영향: Stop-the-World 시간 짧음
```

**Major GC (Old GC / Full GC)**:
```
발생 위치: Old Generation
발생 시점: Old 영역이 가득 찼을 때
동작 방식:
1. Old 전체 영역 스캔
2. Mark-Sweep-Compact
3. 살아있는 객체만 유지

소요 시간: 길음 (수백 ms ~ 수 초)
빈도: 드물게 발생 (분당 1회 이하)
영향: Stop-the-World 시간 김 (성능 저하)
```

**Full GC**:
```
발생 위치: Young + Old + Metaspace
발생 시점:
- Old가 가득 참
- Metaspace가 부족
- System.gc() 호출

소요 시간: 매우 길음 (초 단위)
영향: 모든 애플리케이션 스레드 정지
```

**실제 예시**:
```java
// Minor GC 발생
for (int i = 0; i < 1000000; i++) {
    String s = new String("Temp");  // Eden에 생성
    // 메서드 종료 시 GC 대상
}
// Minor GC가 여러 번 발생 (빠름)

// Major GC 유발
static List<byte[]> list = new ArrayList<>();
for (int i = 0; i < 1000; i++) {
    list.add(new byte[1024 * 1024]);  // Old로 직접 할당
}
// Major GC 발생 (느림, 서비스 지연)
```

**GC 로그 예시**:
```
[GC (Allocation Failure) [PSYoungGen: 512K->64K(1024K)] 512K->200K(4096K), 0.001 secs]
                          ↑ Minor GC  ↑ Young 영역    ↑ 전체 Heap     ↑ 매우 빠름

[Full GC (Ergonomics) [PSYoungGen: 64K->0K][ParOldGen: 2000K->1800K] 2064K->1800K, 0.5 secs]
 ↑ Full GC                                  ↑ Old 영역                           ↑ 느림
```

**실무 팁**:
💡 **Minor GC는 자주 발생해도 괜찮지만, Major/Full GC는 최소화**해야 합니다.

**최적화 방법**:
```bash
# Minor GC 최적화: Young 영역 크기 조정
-Xmn1g  # Young Generation 크기

# Major GC 최소화: 적절한 Heap 크기
-Xmx4g -Xms4g  # 초기=최대로 설정 (동적 조정 방지)
```

</details>

<details>
<summary><strong>Q3: G1 GC가 기본값인 이유는?</strong></summary>

**A**: **예측 가능한 일시 정지 시간과 대용량 Heap 지원 때문입니다.**

**G1 GC의 특징**:

```
Region 기반 메모리 관리:
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ E │ E │ S │ O │ O │ E │ H │   │
└───┴───┴───┴───┴───┴───┴───┴───┘
E: Eden, S: Survivor, O: Old, H: Humongous

- Heap을 동일한 크기의 Region으로 분할 (기본 2MB)
- Region별로 Young/Old 역할 동적 할당
- 큰 객체는 Humongous Region에 저장
```

**장점**:

1. **예측 가능한 일시 정지**:
```bash
-XX:MaxGCPauseMillis=200

# 목표: GC 일시 정지를 200ms 이하로 유지
# G1은 통계를 기반으로 목표 달성 시도
# CMS는 예측 불가능
```

2. **대용량 Heap 지원** (6GB+):
```
Parallel GC: Heap > 8GB 시 Full GC가 수 초 소요
G1 GC: 수십 GB Heap도 효율적 관리
```

3. **동시 수집**:
```
애플리케이션 스레드 실행 중 백그라운드에서 GC
Stop-the-World 시간 최소화
```

4. **단편화 방지**:
```
Compaction을 점진적으로 수행
메모리 단편화 문제 해결
```

**다른 GC와 비교**:

```java
// Parallel GC
-XX:+UseParallelGC
// 장점: 처리량 높음
// 단점: Full GC 시 긴 일시 정지 (수 초)
// 적합: 배치 처리, 백그라운드 작업

// CMS GC (deprecated in Java 14)
-XX:+UseConcMarkSweepGC
// 장점: 낮은 지연 시간
// 단점: CPU 많이 사용, Compaction 없음
// 문제: 단편화로 Full GC 발생

// G1 GC
-XX:+UseG1GC
// 장점: 예측 가능, 대용량 Heap, Compaction
// 단점: 작은 Heap(<6GB)에서는 오버헤드
// 적합: 대부분의 애플리케이션
```

**실무 사용 예시**:

```bash
# 웹 애플리케이션 (Java 11+)
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=16m \
     -jar webapp.jar

# 목표: 응답 시간 200ms 이내 유지
# 효과: 99% 요청이 목표 달성
```

**G1 GC 선택 기준**:

```
G1 GC 사용:
✅ Heap > 6GB
✅ 낮은 지연 시간 필요
✅ 예측 가능한 일시 정지 중요
✅ 웹 애플리케이션, 마이크로서비스

다른 GC 고려:
- Heap < 2GB → Serial GC
- 배치 처리 → Parallel GC
- 초저지연 (<10ms) → ZGC
```

**실무 팁**:
💡 **Java 9+ 프로젝트는 G1 GC를 기본으로 사용**하고, 특별한 요구사항이 있을 때만 다른 GC를 고려합니다.

</details>

<details>
<summary><strong>Q4: 메모리 누수를 어떻게 찾나요?</strong></summary>

**A**: **Heap Dump 분석과 메모리 프로파일링 도구를 사용합니다.**

**메모리 누수 증상**:
```
1. 시간이 지날수록 메모리 사용량 증가
2. GC 후에도 메모리가 줄어들지 않음
3. OutOfMemoryError 발생
4. 응답 시간 점진적 증가
```

**탐지 방법 1: Heap Dump 분석**

```bash
# 1. 실행 중인 프로세스의 Heap Dump 생성
jmap -dump:live,format=b,file=heap.bin <PID>

# 2. Eclipse MAT로 열기
# https://www.eclipse.org/mat/

# 3. Leak Suspects Report 확인
# - Dominator Tree에서 메모리 점유율 높은 객체 확인
# - Retained Heap 크기 분석
```

**Eclipse MAT 분석 예시**:
```
Dominator Tree:
┌────────────────────────────────────────┐
│ com.example.Cache                      │
│ Retained Heap: 500 MB (80% of total)   │ ← 메모리 누수 의심!
│                                        │
│ └─ HashMap<String, Data>               │
│    └─ Entry[100,000]                   │
│        └─ Data[] (각 5KB)              │
└────────────────────────────────────────┘

# Cache 객체가 메모리의 80%를 차지
# → static 변수로 선언되어 GC 안 됨!
```

**탐지 방법 2: VisualVM 프로파일링**

```bash
# 1. VisualVM 실행
jvisualvm

# 2. 애플리케이션 연결

# 3. Monitor 탭
# - Heap 사용량 그래프 확인
# - GC 후에도 사용량이 계속 증가? → 누수 의심

# 4. Sampler 탭
# - CPU/Memory 샘플링
# - 메모리 점유율 높은 클래스 확인
```

**실제 메모리 누수 사례**:

```java
// ❌ 메모리 누수 1: static 컬렉션
public class CacheManager {
    private static Map<String, Object> cache = new HashMap<>();

    public void addToCache(String key, Object value) {
        cache.put(key, value);  // 계속 쌓임, GC 안 됨!
    }
}

// ✅ 해결책: 크기 제한 + LRU
public class FixedCacheManager {
    private static final int MAX_SIZE = 1000;
    private static Map<String, Object> cache =
        new LinkedHashMap<>(16, 0.75f, true) {
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > MAX_SIZE;  // 오래된 항목 자동 제거
            }
        };
}
```

```java
// ❌ 메모리 누수 2: Listener 등록 후 미제거
public class EventManager {
    private List<EventListener> listeners = new ArrayList<>();

    public void addListener(EventListener listener) {
        listeners.add(listener);  // 등록만 하고 제거 안 함!
    }
}

// ✅ 해결책: 명시적 제거
public class FixedEventManager {
    private List<EventListener> listeners = new ArrayList<>();

    public void addListener(EventListener listener) {
        listeners.add(listener);
    }

    public void removeListener(EventListener listener) {
        listeners.remove(listener);  // 사용 완료 후 제거
    }
}
```

```java
// ❌ 메모리 누수 3: ThreadLocal 정리 안 함
public class UserContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);  // 스레드 풀에서 스레드 재사용 시 누수!
    }
}

// ✅ 해결책: finally에서 제거
public class FixedUserContext {
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();

    public static void setUser(User user) {
        currentUser.set(user);
    }

    public static void clear() {
        currentUser.remove();  // 반드시 제거!
    }
}

// 사용 패턴
try {
    UserContext.setUser(user);
    // 작업 수행
} finally {
    UserContext.clear();  // 스레드 풀 재사용 대비
}
```

**자동 탐지 도구**:

```bash
# JProfiler
# - 메모리 누수 자동 탐지
# - 할당 경로 추적

# YourKit
# - Leak Detection
# - Snapshot 비교

# Java Flight Recorder (JFR)
java -XX:+UnlockCommercialFeatures \
     -XX:+FlightRecorder \
     -XX:StartFlightRecording=duration=60s,filename=recording.jfr \
     -jar app.jar
```

**실무 팁**:
💡 **정기적인 Heap Dump 비교**로 메모리 누수를 조기 발견하세요.

```bash
# 주기적으로 Heap Dump 생성
jmap -dump:live,format=b,file=heap_$(date +%Y%m%d_%H%M%S).bin <PID>

# MAT에서 두 Dump 비교
# File → Compare Baskets
# 증가한 객체 확인
```

</details>

<details>
<summary><strong>Q5: -Xms와 -Xmx를 같게 설정하는 이유는?</strong></summary>

**A**: **Heap 크기 동적 조정으로 인한 성능 저하를 방지하기 위함입니다.**

**-Xms vs -Xmx**:
```bash
-Xms2g  # 초기 Heap 크기 (2GB)
-Xmx4g  # 최대 Heap 크기 (4GB)
```

**다른 값으로 설정 시 문제**:

```java
// -Xms512m -Xmx4g 로 실행

시작 시:
┌────────────┐
│ Heap: 512MB│  ← 작은 초기 크기
└────────────┘

메모리 부족 감지:
→ JVM이 Heap 확장 (512MB → 1GB)
→ Full GC 발생 (모든 객체 재배치)
→ 애플리케이션 일시 정지 (수백 ms ~ 수 초)

다시 부족:
→ Heap 확장 (1GB → 2GB)
→ Full GC
→ 또 일시 정지

반복적인 확장 + Full GC
→ 성능 저하, 예측 불가능한 지연
```

**같은 값으로 설정 시 장점**:

```bash
# ✅ 권장 설정
-Xms4g -Xmx4g  # 초기=최대

장점:
1. Heap 크기 고정 → 동적 조정 없음
2. Full GC 빈도 감소
3. 예측 가능한 성능
4. 메모리 단편화 방지
```

**실제 성능 비교**:

```
설정 A: -Xms512m -Xmx4g
- 서버 시작 후 1시간: Heap 512MB → 3.5GB로 증가
- Full GC 발생: 15회
- 평균 응답 시간: 150ms
- 최대 응답 시간: 3000ms (Full GC 중)

설정 B: -Xms4g -Xmx4g
- 서버 시작부터 Heap 4GB 고정
- Full GC 발생: 2회
- 평균 응답 시간: 100ms
- 최대 응답 시간: 500ms

→ 설정 B가 훨씬 안정적!
```

**메모리 여유가 있을 때**:

```bash
# 서버 물리 메모리: 16GB
# OS + 기타: 2GB 사용
# 여유: 14GB

# ✅ 권장
-Xms12g -Xmx12g  # 여유분 (2GB) 남기고 최대 할당

# ❌ 비권장
-Xms1g -Xmx12g   # 초기는 작게, 최대만 크게
```

**컨테이너 환경 (Docker/Kubernetes)**:

```yaml
# Kubernetes Pod 설정
resources:
  requests:
    memory: "4Gi"  # 최소 메모리
  limits:
    memory: "4Gi"  # 최대 메모리 (같게!)

# Java 옵션
-Xms4g -Xmx4g     # 컨테이너 메모리와 일치
```

**예외 상황**:

```bash
# 개발 환경: 메모리 절약
-Xms512m -Xmx2g   # 필요 시 확장

# 메모리 제한 환경
-Xms256m -Xmx1g   # 작은 서버

# 일반적인 프로덕션
-Xms4g -Xmx4g     # 동일하게 설정!
```

**실무 팁**:
💡 **프로덕션 환경에서는 항상 -Xms와 -Xmx를 같게** 설정하세요. 초기 시작 시간이 약간 길어지는 것보다 안정적인 성능이 중요합니다.

</details>

<details>
<summary><strong>Q6: Java 8과 Java 11+의 메모리 구조 차이는?</strong></summary>

**A**: **PermGen이 Metaspace로 변경되었습니다.**

**Java 7 이하: PermGen**:

```
┌──────────────────────────────────┐
│ Heap (고정 크기)                  │
│ - Young Generation               │
│ - Old Generation                 │
└──────────────────────────────────┘

┌──────────────────────────────────┐
│ PermGen (Permanent Generation)   │
│ - 클래스 메타데이터               │
│ - static 변수                    │
│ - String Pool (Java 6)           │
│ - JVM 옵션: -XX:PermSize=64m     │
│            -XX:MaxPermSize=256m  │
└──────────────────────────────────┘

문제점:
❌ 고정 크기 → 클래스 많으면 부족
❌ OutOfMemoryError: PermGen space
❌ 메모리 낭비 (크게 설정 시)
```

**Java 8+: Metaspace**:

```
┌──────────────────────────────────┐
│ Heap                             │
│ - Young Generation               │
│ - Old Generation                 │
│ - String Pool (Java 7+)          │
│ - static 변수 (Java 8+)          │
└──────────────────────────────────┘

┌──────────────────────────────────┐
│ Metaspace (Native Memory)        │
│ - 클래스 메타데이터만             │
│ - 동적 크기 조정                  │
│ - JVM 옵션: -XX:MetaspaceSize    │
│            -XX:MaxMetaspaceSize  │
└──────────────────────────────────┘

장점:
✅ 동적 크기 조정 (Native Memory 사용)
✅ OutOfMemoryError 감소
✅ 메모리 효율성 향상
```

**주요 차이점**:

| 항목 | Java 7 (PermGen) | Java 8+ (Metaspace) |
|------|------------------|---------------------|
| 위치 | JVM Heap 영역 | Native Memory |
| 크기 | 고정 (기본 64-82MB) | 동적 (제한 없음) |
| String Pool | PermGen | Heap |
| static 변수 | PermGen | Heap |
| 클래스 메타데이터 | PermGen | Metaspace |
| OOM 발생 | 빈번 | 드물음 |

**실제 영향**:

```java
// Java 7에서 문제가 되던 코드
public class ClassLoaderLeak {
    public static void main(String[] args) {
        for (int i = 0; i < 100000; i++) {
            // 동적 클래스 생성
            ClassLoader loader = new URLClassLoader(new URL[]{...});
            Class<?> clazz = loader.loadClass("DynamicClass");
            // ...
        }
        // Java 7: OutOfMemoryError: PermGen space
        // Java 8+: 정상 작동 (Metaspace 자동 확장)
    }
}
```

**마이그레이션 가이드**:

```bash
# Java 7 옵션
-XX:PermSize=128m
-XX:MaxPermSize=512m

# Java 8+ 옵션 (동일한 효과)
-XX:MetaspaceSize=128m      # 초기 크기
-XX:MaxMetaspaceSize=512m   # 최대 크기 (선택)

# 무제한 (기본값)
# MaxMetaspaceSize 미지정 시 시스템 메모리까지 사용
```

**Spring Boot 애플리케이션 예시**:

```bash
# Java 7
java -Xms2g -Xmx2g \
     -XX:PermSize=256m \
     -XX:MaxPermSize=512m \
     -jar app.jar

# Java 11
java -Xms2g -Xmx2g \
     -XX:MetaspaceSize=256m \
     -XX:MaxMetaspaceSize=512m \
     -jar app.jar

# 또는 Metaspace 무제한
java -Xms2g -Xmx2g \
     -jar app.jar
```

**컨테이너 환경 주의사항**:

```yaml
# Kubernetes에서 Java 8+ 실행
# Metaspace가 Native Memory 사용
# → 컨테이너 메모리 제한 고려!

resources:
  limits:
    memory: "4Gi"  # 컨테이너 전체 메모리

# JVM 옵션
-Xmx3g              # Heap: 3GB
-XX:MaxMetaspaceSize=512m  # Metaspace: 512MB
# 총 3.5GB (여유 500MB)
```

**실무 팁**:
💡 **Java 8 이상에서는 Metaspace 크기를 명시적으로 제한**하세요. 컨테이너 환경에서는 필수입니다!

</details>

<details>
<summary><strong>Q7: String Pool은 어느 메모리 영역에 있나요?</strong></summary>

**A**: **Java 버전에 따라 다릅니다.**

**Java 6 이하: PermGen**

```
┌────────────────────────────────┐
│ PermGen (Permanent Generation) │
│                                │
│ ┌────────────────────────────┐ │
│ │ String Pool                │ │
│ │ "Hello", "World", ...      │ │
│ └────────────────────────────┘ │
│                                │
│ - 클래스 메타데이터            │
│ - static 변수                 │
└────────────────────────────────┘

문제점:
❌ PermGen 크기 고정 (기본 64-82MB)
❌ String Pool 크기 제한
❌ intern() 많이 사용 시 OOM
```

**Java 7+: Heap**

```
┌───────────────────────────────┐
│ Heap                          │
│                               │
│ ┌───────────────────────────┐ │
│ │ String Pool (Java 7+)     │ │
│ │ "Hello", "World", ...     │ │
│ └───────────────────────────┘ │
│                               │
│ - Young Generation            │
│ - Old Generation              │
│ - 동적 크기 조정              │
└───────────────────────────────┘

장점:
✅ Heap 크기만큼 사용 가능
✅ GC 대상 (Java 7+)
✅ intern() 안전하게 사용
```

**실제 영향**:

```java
// Java 6: PermGen에 String Pool
String s1 = "Hello";  // PermGen의 Pool에 저장
String s2 = "Hello";  // Pool에서 재사용

// 문제 코드
for (int i = 0; i < 1000000; i++) {
    String s = ("String" + i).intern();
    // PermGen 부족 → OOM!
}

// Java 7+: Heap에 String Pool
String s1 = "Hello";  // Heap의 Pool에 저장
String s2 = "Hello";  // Pool에서 재사용

// 같은 코드가 안전
for (int i = 0; i < 1000000; i++) {
    String s = ("String" + i).intern();
    // Heap 크기만큼 사용 가능
    // 필요 시 GC로 회수
}
```

**String Pool 크기 조정**:

```bash
# Java 7+
-XX:StringTableSize=100003  # String Pool 해시 테이블 크기

# 기본값:
# Java 7u40-: 1009
# Java 7u40+: 60013
# Java 8+: 60013

# 크기 증가 시 장점
-XX:StringTableSize=1000003
→ intern() 성능 향상 (충돌 감소)
```

**메모리 위치 확인**:

```java
// String Pool 위치 테스트
public class StringPoolLocation {
    public static void main(String[] args) {
        String s1 = "Test";           // String Pool
        String s2 = new String("Test"); // Heap (Pool 외부)

        System.out.println(s1 == s2);  // false

        String s3 = s2.intern();  // Pool에 추가 또는 조회
        System.out.println(s1 == s3);  // true (같은 Pool 객체)

        // Java 6: PermGen에서 비교
        // Java 7+: Heap에서 비교
    }
}
```

**GC와의 관계**:

```java
// Java 6: String Pool은 GC 안 됨
String s = new String("Dynamic").intern();
s = null;
// Pool에 "Dynamic" 남아있음 (GC 안 됨)

// Java 7+: String Pool도 GC 대상
String s = new String("Dynamic").intern();
s = null;
// 참조 없으면 GC로 회수 가능
```

**실무 가이드**:

```java
// ✅ String Pool 활용 (Java 7+)
// 제한된 값 집합
enum Status { ACTIVE, INACTIVE, PENDING }
String status = userInput.intern();  // 3개 값만 재사용

// ✅ 고정된 카테고리
Set<String> categories = Set.of("전자", "의류", "식품");
String category = input.intern();  // 카테고리 재사용

// ❌ 피해야 할 사용
// 무한한 값
String userId = UUID.randomUUID().toString().intern();
// → Pool이 계속 증가!
```

**실무 팁**:
💡 **Java 7 이상에서는 String Pool이 Heap에 있어 안전**하지만, 무분별한 `intern()` 사용은 여전히 피해야 합니다.

</details>

---

## 💼 면접 질문 리스트

### 📘 주니어/신입 개발자용

<details>
<summary><strong>1. JVM의 주요 메모리 영역 3가지를 설명해주세요</strong></summary>

**모범 답안 포인트**
- Stack, Heap, Method Area
- 각 영역의 역할과 저장 내용
- 공유 여부

**예시 답변**
> "JVM의 주요 메모리 영역은 Stack, Heap, Method Area입니다.
>
> **Stack**은 각 스레드마다 독립적으로 생성되며, 메서드 호출 정보와 지역 변수를 저장합니다. 메서드가 끝나면 자동으로 정리됩니다.
>
> **Heap**은 모든 스레드가 공유하며, new 키워드로 생성한 객체와 배열을 저장합니다. Garbage Collector가 미사용 객체를 자동으로 제거합니다.
>
> **Method Area**는 클래스 메타데이터, static 변수, 메서드 코드를 저장하며 모든 스레드가 공유합니다. Java 8부터는 Metaspace로 불립니다."

**꼬리 질문**
- Q: 지역 변수와 인스턴스 변수는 어디에 저장되나요?
- A: "지역 변수는 Stack에, 인스턴스 변수는 Heap의 객체 안에 저장됩니다. static 변수는 Method Area에 저장됩니다."

**실무 연관**
- 메모리 에러 디버깅 시 어느 영역 문제인지 파악
- StackOverflowError vs OutOfMemoryError 구분

</details>

<details>
<summary><strong>2. Garbage Collection이 무엇인지 설명해주세요</strong></summary>

**모범 답안 포인트**
- 자동 메모리 관리
- 미사용 객체 제거
- Stop-the-World

**예시 답변**
> "Garbage Collection은 Heap 영역의 미사용 객체를 자동으로 제거하는 메모리 관리 기법입니다.
>
> 더 이상 참조되지 않는 객체를 찾아 메모리에서 해제함으로써, 개발자가 수동으로 메모리를 관리할 필요가 없게 합니다.
>
> GC가 실행되면 애플리케이션 스레드가 잠시 멈추는 Stop-the-World 현상이 발생하므로, GC 시간을 최소화하는 것이 성능 최적화의 핵심입니다.
>
> Java에는 Serial, Parallel, G1, ZGC 등 다양한 GC 알고리즘이 있으며, Java 9부터는 G1 GC가 기본값입니다."

**꼬리 질문**
- Q: GC는 언제 발생하나요?
- A: "Heap 메모리가 부족할 때 자동으로 발생합니다. Eden 영역이 가득 차면 Minor GC, Old 영역이 가득 차면 Major GC가 발생합니다."

**실무 연관**
- GC 로그 분석으로 성능 튜닝
- GC 일시 정지 시간 모니터링

</details>

<details>
<summary><strong>3. StackOverflowError와 OutOfMemoryError의 차이는?</strong></summary>

**모범 답안 포인트**
- 발생 메모리 영역
- 발생 원인
- 해결 방법

**예시 답변**
> "두 에러는 발생하는 메모리 영역이 다릅니다.
>
> **StackOverflowError**는 Stack 메모리가 부족할 때 발생합니다. 주로 깊은 재귀 호출이나 무한 재귀가 원인이며, Stack 크기를 `-Xss` 옵션으로 늘리거나 재귀를 반복문으로 변경하여 해결합니다.
>
> **OutOfMemoryError**는 Heap 메모리가 부족할 때 발생합니다. 메모리 누수나 대량의 객체 생성이 원인이며, Heap 크기를 `-Xmx` 옵션으로 늘리거나 메모리 누수를 제거하여 해결합니다."

**코드 예시**:
```java
// StackOverflowError
public void recursion() {
    recursion();  // 무한 재귀
}

// OutOfMemoryError
List<byte[]> list = new ArrayList<>();
while (true) {
    list.add(new byte[1024 * 1024]);  // 1MB씩 추가
}
```

**실무 연관**
- 로그에서 에러 타입 확인으로 원인 파악
- 적절한 JVM 옵션 설정

</details>

<details>
<summary><strong>4. static 변수는 어느 메모리 영역에 저장되나요?</strong></summary>

**모범 답안 포인트**
- Method Area (Metaspace)
- Java 8+ 변경사항
- 생명 주기

**예시 답변**
> "static 변수는 Method Area에 저장됩니다. Java 8 이상에서는 Metaspace라고 불리며, Java 7 이하에서는 PermGen이었습니다.
>
> 단, Java 8부터는 static 변수가 Heap으로 이동했고, Metaspace에는 클래스 메타데이터만 저장됩니다.
>
> static 변수는 클래스가 로드될 때 생성되어 프로그램 종료까지 유지되므로, 모든 인스턴스가 공유하며 GC 대상이 아닙니다. 따라서 static 컬렉션에 객체를 계속 추가하면 메모리 누수가 발생할 수 있습니다."

**코드 예시**:
```java
class Counter {
    static int count = 0;  // Method Area (Java 8+는 Heap)
    int instance = 0;      // Heap (각 객체마다)
}
```

**실무 연관**
- static 변수 남용으로 인한 메모리 누수 주의
- 싱글톤 패턴에서 static 활용

</details>

<details>
<summary><strong>5. Minor GC와 Major GC의 차이를 설명해주세요</strong></summary>

**모범 답안 포인트**
- 발생 위치
- 빈도와 소요 시간
- 성능 영향

**예시 답변**
> "Minor GC는 Young Generation에서 발생하고, Major GC는 Old Generation에서 발생합니다.
>
> **Minor GC**는 Eden 영역이 가득 찰 때 자주 발생하며, 수 밀리초 정도로 매우 빠릅니다. 대부분의 객체가 금방 GC되기 때문에 성능 영향이 적습니다.
>
> **Major GC**는 Old 영역이 가득 찰 때 드물게 발생하지만, 수백 밀리초에서 수 초가 걸려 성능에 큰 영향을 줍니다. Full GC는 Young과 Old 전체를 대상으로 하여 더 오래 걸립니다.
>
> 따라서 성능 최적화에서는 Major/Full GC를 최소화하는 것이 중요합니다."

**실무 연관**
- GC 로그로 Minor/Major GC 빈도 모니터링
- Major GC 빈번하면 Heap 크기 조정 고려

</details>

<details>
<summary><strong>6. 메모리 누수가 무엇인지 설명해주세요</strong></summary>

**모범 답안 포인트**
- 미사용 객체가 GC되지 않음
- 주요 원인
- 예방 방법

**예시 답변**
> "메모리 누수는 더 이상 사용하지 않는 객체가 GC에 의해 제거되지 않고 메모리에 계속 남아있는 현상입니다.
>
> 주요 원인은 static 컬렉션에 객체를 계속 추가하거나, Event Listener를 등록 후 제거하지 않거나, ThreadLocal을 정리하지 않는 경우입니다.
>
> 증상으로는 시간이 지날수록 메모리 사용량이 증가하고, GC 후에도 메모리가 줄어들지 않으며, 결국 OutOfMemoryError가 발생합니다.
>
> 예방하려면 사용 완료 후 참조를 null로 설정하거나, WeakReference를 사용하거나, 명시적으로 clear() 메서드를 호출해야 합니다."

**코드 예시**:
```java
// ❌ 메모리 누수
static List<Object> cache = new ArrayList<>();
cache.add(obj);  // 계속 쌓임

// ✅ 해결
cache.clear();
cache = null;
```

**실무 연관**
- Heap Dump 분석으로 누수 탐지
- VisualVM으로 메모리 사용 패턴 모니터링

</details>

<details>
<summary><strong>7. -Xms와 -Xmx 옵션이 무엇인지 설명해주세요</strong></summary>

**모범 답안 포인트**
- Heap 크기 설정
- 초기 vs 최대
- 권장 설정

**예시 답변**
> "`-Xms`는 JVM의 초기 Heap 크기를, `-Xmx`는 최대 Heap 크기를 설정하는 옵션입니다.
>
> 예를 들어 `-Xms2g -Xmx4g`는 초기 2GB로 시작하여 필요 시 4GB까지 확장할 수 있다는 의미입니다.
>
> 실무에서는 두 값을 같게 설정하는 것을 권장합니다. 예를 들어 `-Xms4g -Xmx4g`로 설정하면 Heap 크기가 고정되어 동적 조정으로 인한 Full GC를 방지하고 성능을 예측 가능하게 만듭니다.
>
> 서버의 물리 메모리를 고려하여 적절한 크기를 설정해야 하며, 너무 크면 GC 시간이 길어지고 너무 작으면 OutOfMemoryError가 발생합니다."

**실무 연관**
- 서버 스펙에 맞는 Heap 크기 설정
- 컨테이너 환경에서 메모리 제한 고려

</details>

---

### 📗 중급 개발자용

<details>
<summary><strong>1. G1 GC의 동작 원리를 설명해주세요</strong></summary>

**모범 답안 포인트**
- Region 기반 구조
- 예측 가능한 일시 정지
- Young/Old GC 과정

**예시 답변**
> "G1 GC는 Heap을 동일한 크기의 Region(기본 2MB)으로 나누어 관리하는 GC입니다.
>
> 각 Region은 Eden, Survivor, Old, Humongous 역할을 동적으로 할당받습니다. 큰 객체(Region 크기의 50% 이상)는 Humongous Region에 저장됩니다.
>
> G1 GC의 핵심은 예측 가능한 일시 정지 시간입니다. `-XX:MaxGCPauseMillis=200` 옵션으로 목표 일시 정지 시간을 설정하면, G1은 통계를 기반으로 GC할 Region을 선택하여 목표를 달성하려고 시도합니다.
>
> Young GC는 모든 Young Region을 대상으로 하며, Mixed GC는 Young과 일부 Old Region을 함께 수집합니다. 동시 마킹(Concurrent Marking)을 통해 애플리케이션 실행 중에도 GC를 준비하여 일시 정지 시간을 최소화합니다."

**실무 예시**:
```bash
java -Xms8g -Xmx8g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:G1HeapRegionSize=16m \
     -jar webapp.jar
```

**실무 연관**
- 대용량 Heap (6GB+) 애플리케이션에 적합
- 웹 애플리케이션의 응답 시간 최적화

</details>

<details>
<summary><strong>2. Metaspace와 PermGen의 차이를 설명해주세요</strong></summary>

**모범 답안 포인트**
- 메모리 위치 (Heap vs Native)
- 크기 조정 방식
- Java 8 변경 이유

**예시 답변**
> "PermGen은 Java 7까지 사용된 Heap 영역의 일부로, 클래스 메타데이터와 static 변수를 저장했습니다. 고정 크기로 설정되어 클래스가 많은 애플리케이션에서 OutOfMemoryError: PermGen space가 자주 발생했습니다.
>
> Java 8부터는 Metaspace로 대체되었으며, Native Memory 영역을 사용합니다. 주요 차이점은 크기가 동적으로 조정된다는 것입니다. 기본적으로 시스템 메모리까지 확장 가능하여 PermGen의 크기 제한 문제가 해결되었습니다.
>
> 또한 String Pool과 static 변수는 Heap으로 이동하여 GC 대상이 되었고, Metaspace에는 순수 클래스 메타데이터만 저장됩니다. 이로 인해 메모리 관리가 더 유연해지고 효율적이 되었습니다."

**마이그레이션**:
```bash
# Java 7
-XX:PermSize=256m -XX:MaxPermSize=512m

# Java 8+
-XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m
```

**실무 연관**
- Spring Boot 같은 클래스 로딩이 많은 애플리케이션
- 컨테이너 환경에서 Metaspace 제한 필수

</details>

<details>
<summary><strong>3. Young Generation의 구조와 Minor GC 과정을 설명해주세요</strong></summary>

**모범 답안 포인트**
- Eden, Survivor 0, Survivor 1
- 객체 이동 과정
- Age threshold

**예시 답변**
> "Young Generation은 Eden과 두 개의 Survivor 영역(S0, S1)으로 구성됩니다. 기본 비율은 Eden:S0:S1 = 8:1:1입니다.
>
> Minor GC 과정은 다음과 같습니다:
> 1. 새 객체는 Eden에 생성됩니다.
> 2. Eden이 가득 차면 Minor GC 발생
> 3. Eden의 살아있는 객체를 Survivor 0로 이동 (age = 1)
> 4. 다음 GC 시 Eden과 S0의 살아있는 객체를 S1로 이동 (age++)
> 5. 다음 GC 시 S1에서 S0로 이동 (ping-pong)
> 6. age가 threshold(기본 15)에 도달하면 Old로 승격
>
> 이 방식으로 짧게 사용되는 객체는 Young에서 빠르게 제거되고, 오래 살아남는 객체만 Old로 이동하여 GC 효율을 높입니다."

**실무 연관**
- Young 영역 크기 튜닝 (`-Xmn`)
- Survivor 비율 조정 (`-XX:SurvivorRatio`)

</details>

<details>
<summary><strong>4. 메모리 프로파일링 방법과 도구를 설명해주세요</strong></summary>

**모범 답안 포인트**
- Heap Dump 분석
- 프로파일링 도구
- 실시간 모니터링

**예시 답변**
> "메모리 프로파일링은 크게 두 가지 방식으로 진행됩니다.
>
> 첫째, Heap Dump 분석입니다. `jmap` 명령으로 Heap 스냅샷을 생성하고, Eclipse MAT나 JProfiler로 분석합니다. Dominator Tree를 통해 메모리를 많이 차지하는 객체를 찾고, Leak Suspects Report로 메모리 누수를 탐지합니다.
>
> 둘째, 실시간 모니터링입니다. VisualVM, JConsole, Java Mission Control 등을 사용하여 Heap 사용량, GC 활동, 스레드 상태를 실시간으로 확인합니다.
>
> 상용 도구로는 JProfiler, YourKit이 있으며, 할당 경로 추적, 메모리 누수 자동 탐지 등 고급 기능을 제공합니다. 프로덕션 환경에서는 Java Flight Recorder (JFR)로 오버헤드 없이 프로파일링할 수 있습니다."

**명령어 예시**:
```bash
# Heap Dump 생성
jmap -dump:live,format=b,file=heap.bin <PID>

# GC 로그 활성화
-Xlog:gc*:file=gc.log:time,uptime

# JFR 레코딩
jcmd <PID> JFR.start duration=60s filename=recording.jfr
```

**실무 연관**
- 프로덕션 메모리 이슈 분석
- 성능 튜닝 전 현황 파악

</details>

<details>
<summary><strong>5. JVM 메모리 튜닝 전략을 설명해주세요</strong></summary>

**모범 답안 포인트**
- 애플리케이션 특성 분석
- GC 알고리즘 선택
- 지표 기반 튜닝

**예시 답변**
> "JVM 메모리 튜닝은 애플리케이션 특성에 따라 전략이 다릅니다.
>
> **웹 애플리케이션** (응답 속도 중시):
> - G1 GC 사용으로 예측 가능한 지연 시간 확보
> - MaxGCPauseMillis를 200ms 이하로 설정
> - Heap은 물리 메모리의 50-75% 할당
>
> **배치 처리** (처리량 중시):
> - Parallel GC로 멀티 코어 활용
> - Young 영역을 크게 설정하여 Minor GC 빈도 감소
> - GC 일시 정지는 덜 중요
>
> **실시간 시스템** (초저지연):
> - ZGC 사용으로 10ms 이하 일시 정지
> - 대용량 Heap (16GB+) 지원
>
> 튜닝 절차는 1) 현재 상태 측정 → 2) 목표 설정 → 3) 파라미터 조정 → 4) 모니터링 → 5) 반복입니다. GC 로그를 분석하여 Minor/Major GC 빈도, 일시 정지 시간을 확인하고 점진적으로 개선합니다."

**튜닝 체크리스트**:
```
✅ Heap 크기 적정한가? (-Xms, -Xmx)
✅ GC 알고리즘이 적합한가?
✅ GC 일시 정지 시간이 목표 내인가?
✅ Full GC 빈도가 낮은가? (시간당 1회 이하)
✅ 메모리 누수는 없는가?
```

**실무 연관**
- 신규 서비스 런칭 시 초기 튜닝
- 성능 문제 발생 시 원인 분석 및 개선

</details>

---

## 📝 핵심 정리

### GC 알고리즘 비교

| GC | 장점 | 단점 | 사용 시나리오 |
|----|------|------|--------------|
| Serial GC | 단순, 메모리 효율 | 단일 스레드, 느림 | 소규모 앱 |
| Parallel GC | 높은 처리량 | 긴 일시 정지 | 배치 처리 |
| G1 GC | 예측 가능, 대용량 | 오버헤드 | 대부분 앱 |
| ZGC | 초저지연 (<10ms) | Java 11+ 필요 | 실시간 시스템 |

### 메모리 영역별 특징

| 영역 | 크기 조정 | GC 대상 | 주요 옵션 |
|------|---------|---------|----------|
| Stack | -Xss | 자동 제거 | -Xss1m |
| Heap | -Xms, -Xmx | GC 관리 | -Xmx4g |
| Metaspace | -XX:MaxMetaspaceSize | 거의 안 됨 | -XX:MaxMetaspaceSize=512m |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [ ] **-Xms와 -Xmx 동일하게** 설정 (프로덕션)
- [ ] **GC 로그 활성화**: 성능 분석을 위해
- [ ] **정기적인 모니터링**: Heap 사용률, GC 빈도
- [ ] **OOM 시 Heap Dump**: `-XX:+HeapDumpOnOutOfMemoryError`
- [ ] **적절한 GC 선택**: 애플리케이션 특성에 맞게

#### ❌ 하지 말아야 할 것
- [ ] **System.gc() 호출**: GC를 JVM에 맡기기
- [ ] **과도한 static 사용**: 메모리 누수 위험
- [ ] **튜닝 없이 운영**: 기본값이 항상 최적은 아님
- [ ] **Heap 너무 크게**: GC 시간 증가
- [ ] **메모리 문제 방치**: 조기 발견과 해결

---

## 🔗 관련 기술

| 기술 | 관계 | 학습 우선순위 |
|------|------|---------------|
| GC 알고리즘 | 메모리 자동 관리 | ⭐⭐⭐⭐⭐ |
| JVM 프로파일링 | 성능 분석 | ⭐⭐⭐⭐ |
| APM 도구 | 실시간 모니터링 | ⭐⭐⭐⭐ |
| JMX | 메트릭 수집 | ⭐⭐⭐ |
| Heap Dump 분석 | 메모리 누수 탐지 | ⭐⭐⭐⭐ |

---

## 🚀 다음 단계

### 다음 장 미리보기: 12장 클래스와 객체

**배울 내용**:
- 객체지향 프로그래밍의 시작
- 클래스 정의와 객체 생성
- 메서드와 필드
- this 키워드
- 실전 프로젝트

---

**💪 "JVM 메모리 구조를 완벽히 마스터했습니다!"**

**📖 다음 장에서 만나요!**

[← 이전: 11-1장 JVM 메모리 구조 기초편](11-1-JVM-메모리-구조-기초편.md) | [다음: 12-1장 클래스와 객체 기초편 →](12-1-클래스와-객체-기초편.md)

[📚 전체 목차로 돌아가기](README.md)
