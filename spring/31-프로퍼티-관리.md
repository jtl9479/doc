# 31장: 프로퍼티 관리 - 환경별 설정의 완벽한 분리

> **"하드코딩은 이제 그만, 설정은 외부에서 관리하세요"**

---

## 📋 학습 목표

이 장을 학습하면 다음을 할 수 있습니다:

- application.properties와 application.yml을 효과적으로 활용합니다
- @Value와 @ConfigurationProperties의 차이를 이해하고 적절히 사용합니다
- 프로파일별로 설정을 분리하여 관리할 수 있습니다
- 외부 설정 파일과 환경 변수를 활용합니다
- 민감한 정보를 안전하게 관리하는 방법을 습득합니다

**예상 학습 시간**: 3-4시간
**난이도**: ⭐⭐⭐ (중급)

---

## 🤔 왜 프로퍼티 관리가 필요한가?

### 문제 상황: 하드코딩의 악몽

#### 문제 1: 환경별 배포 지옥

```java
// ❌ 하드코딩
@Service
public class PaymentService {
    private static final String API_URL = "https://api.payment.com";
    private static final String API_KEY = "sk_live_abc123def456";
    private static final int TIMEOUT = 5000;

    public void processPayment() {
        // 개발 환경에서 테스트하려면?
        // → 코드 수정 후 다시 빌드
        // 운영 환경으로 배포할 때?
        // → 또 코드 수정 후 빌드
        // API 키가 Git에 노출!
    }
}
```

**개발자의 고통:**
- "환경 바꿀 때마다 빌드해야 해요"
- "API 키가 Git에 올라갔어요!"
- "개발/스테이징/운영 설정이 뒤죽박죽이에요"

#### 문제 2: 변경의 어려움

```java
// 타임아웃을 변경하려면?
// 1. 코드 수정
private static final int TIMEOUT = 10000;  // 5000 → 10000

// 2. 컴파일
// 3. 빌드
// 4. 배포
// 5. 서버 재시작
// → 단순 설정 변경에 30분 소요
```

### 프로퍼티 관리의 해결책

```yaml
# application.yml - 설정 외부화
payment:
  api:
    url: https://api.payment.com
    timeout: 5000

# application-dev.yml - 개발 환경
payment:
  api:
    url: https://dev-api.payment.com
    timeout: 10000

# application-prod.yml - 운영 환경
payment:
  api:
    url: https://api.payment.com
    timeout: 3000
```

```java
// ✅ 설정 주입
@Service
@RequiredArgsConstructor
public class PaymentService {
    private final PaymentProperties properties;

    public void processPayment() {
        String url = properties.getApi().getUrl();
        int timeout = properties.getApi().getTimeout();
        // 코드 수정 없이 설정만 변경!
    }
}
```

---

## 🌍 실생활 비유로 이해하는 프로퍼티 관리

### 비유 1: 리모컨 vs 고정 버튼

**하드코딩 (고정 버튼):**
```
TV 앞에 고정된 버튼 3개
[켜기] [끄기] [채널 5]

채널을 7로 바꾸려면?
→ TV 뜯어서 버튼 교체
→ 다시 조립
```

**프로퍼티 (리모컨):**
```
리모컨으로 원격 제어
숫자 버튼으로 원하는 채널 선택
→ TV 건드리지 않고 설정 변경
```

### 비유 2: 건물 벽 vs 가구 배치

**하드코딩 (벽):**
```
방 크기를 바꾸려면?
→ 벽 허물고 다시 짓기
→ 큰 공사 필요
```

**프로퍼티 (가구):**
```
가구 배치만 변경
→ 즉시 변경 가능
→ 언제든 원복 가능
```

### 비유 3: 식당 레시피

**하드코딩:**
```
셰프가 레시피를 외워서 조리
→ 맛 조절 어려움
→ 새 셰프는 다시 배워야 함
```

**프로퍼티:**
```
레시피북에 기록
- 소금: 1스푼
- 설탕: 2스푼
→ 쉽게 조절 가능
→ 누구나 같은 맛 재현
```

---

## 💡 프로퍼티 관리 핵심 개념

### 1️⃣ 초급: application.properties vs application.yml

#### Properties 형식

```properties
# application.properties
server.port=8080
server.servlet.context-path=/api

spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password

logging.level.root=INFO
logging.level.com.example=DEBUG
```

#### YAML 형식 (권장)

```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: password

logging:
  level:
    root: INFO
    com.example: DEBUG
```

**YAML의 장점:**
- 가독성 높음 (계층 구조 명확)
- 중복 제거 (접두사 반복 불필요)
- 리스트/배열 표현 가능

#### 리스트와 맵 표현

```yaml
# 리스트
app:
  servers:
    - prod-server-1
    - prod-server-2
    - prod-server-3

# 맵
app:
  users:
    admin: admin@example.com
    support: support@example.com
```

### 2️⃣ 중급: @Value vs @ConfigurationProperties

#### @Value - 단순 값 주입

```java
@Component
public class AppConfig {

    @Value("${server.port}")
    private int port;

    @Value("${app.name:MyApp}")  // 기본값 지정
    private String appName;

    @Value("${app.features}")
    private List<String> features;

    @Value("#{${app.timeout} * 1000}")  // SpEL 표현식
    private long timeoutMillis;
}
```

#### @ConfigurationProperties - 타입 안전 (권장)

**Step 1: Properties 클래스 작성**

```java
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {

    /**
     * 애플리케이션 이름
     */
    @NotBlank
    private String name = "MyApp";

    /**
     * 활성화된 기능 목록
     */
    private List<String> features = new ArrayList<>();

    /**
     * 타임아웃 (초)
     */
    @Min(1)
    @Max(300)
    private int timeout = 30;

    /**
     * API 설정
     */
    private Api api = new Api();

    // Getter, Setter

    public static class Api {
        private String url;
        private String key;
        private int retryCount = 3;

        // Getter, Setter
    }
}
```

**Step 2: 활성화**

```java
@SpringBootApplication
@EnableConfigurationProperties(AppProperties.class)
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

**Step 3: 사용**

```java
@Service
@RequiredArgsConstructor
public class MyService {

    private final AppProperties properties;

    public void doSomething() {
        String apiUrl = properties.getApi().getUrl();
        int timeout = properties.getTimeout();
        // 타입 안전하게 사용
    }
}
```

**비교표:**

| 특징 | @Value | @ConfigurationProperties |
|-----|--------|--------------------------|
| 타입 안전성 | 낮음 | 높음 (컴파일 타임 체크) |
| 유효성 검증 | 불가능 | 가능 (@Validated) |
| IDE 지원 | 없음 | 자동완성 지원 |
| 중첩 구조 | 어려움 | 쉬움 |
| 권장 사용 | 단순 값 1-2개 | 복잡한 설정 그룹 |

### 3️⃣ 고급: 프로파일 관리

#### 프로파일별 파일 분리

```
src/main/resources/
├── application.yml              # 공통 설정
├── application-dev.yml          # 개발 환경
├── application-staging.yml      # 스테이징 환경
└── application-prod.yml         # 운영 환경
```

**application.yml (공통)**
```yaml
spring:
  application:
    name: my-app

app:
  name: MyApp
  features:
    - feature-1
    - feature-2
```

**application-dev.yml**
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:devdb
  jpa:
    show-sql: true

app:
  api:
    url: https://dev-api.example.com
    timeout: 10

logging:
  level:
    root: DEBUG
```

**application-prod.yml**
```yaml
spring:
  datasource:
    url: jdbc:mysql://prod-db:3306/mydb
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  jpa:
    show-sql: false

app:
  api:
    url: https://api.example.com
    timeout: 3

logging:
  level:
    root: WARN
    com.example: INFO
```

#### 프로파일 활성화 방법

**방법 1: application.yml**
```yaml
spring:
  profiles:
    active: dev
```

**방법 2: 실행 시 지정**
```bash
java -jar app.jar --spring.profiles.active=prod
```

**방법 3: 환경 변수**
```bash
export SPRING_PROFILES_ACTIVE=prod
java -jar app.jar
```

**방법 4: IDE 설정**
```
IntelliJ IDEA:
Run → Edit Configurations → Active profiles: dev
```

#### 다중 프로파일

```bash
# 여러 프로파일 동시 활성화
java -jar app.jar --spring.profiles.active=prod,monitoring,cache
```

```yaml
# application-monitoring.yml
management:
  endpoints:
    web:
      exposure:
        include: "*"

# application-cache.yml
spring:
  cache:
    type: redis
```

---

## 🛠️ 기본 실습

### 실습 1: 데이터베이스 설정 관리

```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5

# application-dev.yml
spring:
  datasource:
    url: jdbc:h2:mem:devdb
    driver-class-name: org.h2.Driver
  h2:
    console:
      enabled: true

# application-prod.yml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST:localhost}:3306/${DB_NAME:mydb}
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:}
    hikari:
      maximum-pool-size: 50
      connection-timeout: 3000
```

### 실습 2: 커스텀 프로퍼티 클래스

```java
@ConfigurationProperties(prefix = "payment")
@Validated
public class PaymentProperties {

    /**
     * 결제 게이트웨이 설정
     */
    @NotNull
    private Gateway gateway;

    /**
     * 재시도 정책
     */
    private Retry retry = new Retry();

    /**
     * 알림 설정
     */
    private Notification notification = new Notification();

    // Getter, Setter

    @Data
    public static class Gateway {
        @NotBlank
        private String url;

        @NotBlank
        private String apiKey;

        @Min(1000)
        @Max(30000)
        private int timeout = 5000;
    }

    @Data
    public static class Retry {
        @Min(0)
        @Max(5)
        private int maxAttempts = 3;

        @Min(100)
        private long backoffMs = 1000;
    }

    @Data
    public static class Notification {
        @Email
        private String email;

        private boolean smsEnabled = false;
    }
}
```

```yaml
# application.yml
payment:
  gateway:
    url: https://api.payment.com
    api-key: ${PAYMENT_API_KEY}
    timeout: 5000
  retry:
    max-attempts: 3
    backoff-ms: 1000
  notification:
    email: admin@example.com
    sms-enabled: true
```

### 실습 3: 환경 변수와 시스템 프로퍼티

```yaml
# 우선순위 (높은 순)
# 1. 명령행 인자
java -jar app.jar --server.port=9090

# 2. 환경 변수
export SERVER_PORT=9090

# 3. application-{profile}.yml
server:
  port: 9090

# 4. application.yml
server:
  port: 8080
```

---

## 👨‍💻 주니어 개발자 실전 시나리오

### 시나리오: "민감 정보 안전하게 관리하기"

**문제:**
```yaml
# ❌ Git에 올라가면 안 되는 정보
spring:
  datasource:
    password: my_secret_password123!
payment:
  api-key: sk_live_abc123def456
aws:
  access-key: AKIAIOSFODNN7EXAMPLE
  secret-key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

**해결 방법:**

#### 1. 환경 변수 사용

```yaml
# application.yml - Git에 커밋
spring:
  datasource:
    password: ${DB_PASSWORD}
payment:
  api-key: ${PAYMENT_API_KEY}
```

```bash
# 환경 변수 설정 (서버에서만)
export DB_PASSWORD=my_secret_password123!
export PAYMENT_API_KEY=sk_live_abc123def456
```

#### 2. 외부 설정 파일

```yaml
# application.yml
spring:
  config:
    import: optional:file:./config/secrets.yml
```

```yaml
# config/secrets.yml (Git 제외)
spring:
  datasource:
    password: my_secret_password123!
```

```gitignore
# .gitignore
config/secrets.yml
```

#### 3. Spring Cloud Config (권장)

```yaml
# bootstrap.yml
spring:
  cloud:
    config:
      uri: https://config-server.example.com
      fail-fast: true
```

#### 4. AWS Secrets Manager / Vault

```java
@Configuration
public class SecretsConfig {

    @Bean
    public DataSource dataSource(
            @Value("${aws.secretsmanager.secret-name}") String secretName) {

        // AWS Secrets Manager에서 가져오기
        String password = awsSecretsManager.getSecret(secretName);

        return DataSourceBuilder.create()
            .password(password)
            .build();
    }
}
```

---

## 🏢 기업 사례: Airbnb

### 배경

Airbnb는 200+ 마이크로서비스를 운영하며, 일관된 설정 관리가 필수였습니다.

**문제:**
- 서비스마다 설정 방식 다름
- 민감 정보 관리 어려움
- 설정 변경 시 배포 필요

### 해결책: 중앙화된 설정 관리

```yaml
# 공통 라이브러리: airbnb-spring-boot-starter
airbnb:
  service:
    name: ${SERVICE_NAME}
    version: ${SERVICE_VERSION}
  monitoring:
    enabled: true
    datadog:
      api-key: ${DATADOG_API_KEY}
  database:
    connection-pool:
      max-size: 50
      min-idle: 10
```

**효과:**
- 설정 표준화로 온보딩 시간 50% 단축
- 민감 정보 유출 사고 0건
- 설정 변경 배포 시간 10분 → 1분

---

## ❓ FAQ

### Q1. application.properties와 application.yml을 동시에 사용하면?

**A:** properties가 우선순위가 더 높습니다.

```
우선순위 (높은 순):
1. application.properties
2. application.yml
```

**권장:** 하나만 사용 (yml 권장)

### Q2. 프로파일별 설정이 중복되면?

**A:** 프로파일 설정이 공통 설정을 오버라이드합니다.

```yaml
# application.yml
server:
  port: 8080
app:
  timeout: 30

# application-dev.yml (dev 프로파일 활성화 시)
server:
  port: 9090  # 오버라이드

# 결과
server.port = 9090 (dev 설정)
app.timeout = 30 (공통 설정)
```

### Q3. @ConfigurationProperties 변경 시 재시작 필요?

**A:** 기본적으로 필요하지만, @RefreshScope로 해결 가능

```java
@Component
@RefreshScope
@ConfigurationProperties(prefix = "app")
public class AppProperties {
    // 설정 변경 시 /actuator/refresh 호출하면 즉시 적용
}
```

```bash
# 설정 변경 후
curl -X POST http://localhost:8080/actuator/refresh
```

### Q4. 리스트 프로퍼티는 어떻게 오버라이드하나요?

**A:** 인덱스 기반으로 오버라이드

```yaml
# application.yml
app:
  servers:
    - server1
    - server2

# application-prod.yml
app:
  servers[0]: prod-server1  # 첫 번째만 변경
  servers[1]: prod-server2
```

**명령행:**
```bash
java -jar app.jar --app.servers[0]=custom-server
```

### Q5. 암호화된 프로퍼티를 사용하려면?

**A:** Jasypt 라이브러리 사용

```gradle
implementation 'com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5'
```

```yaml
spring:
  datasource:
    password: ENC(encrypted_value_here)
```

```java
@Configuration
public class JasyptConfig {
    @Bean
    public StringEncryptor stringEncryptor() {
        PooledPBEStringEncryptor encryptor = new PooledPBEStringEncryptor();
        encryptor.setPassword(System.getenv("JASYPT_PASSWORD"));
        return encryptor;
    }
}
```

---

## 💼 면접 질문 TOP 5

### ⭐ 초급 1: @Value와 @ConfigurationProperties의 차이는?

**답변:**

| 특징 | @Value | @ConfigurationProperties |
|-----|--------|--------------------------|
| 용도 | 단순 값 주입 | 복잡한 설정 그룹 |
| 타입 안전성 | 낮음 | 높음 |
| 유효성 검증 | 불가능 | 가능 |
| 중첩 구조 | 어려움 | 쉬움 |

### ⭐ 초급 2: 프로파일을 활성화하는 방법은?

**답변:**

```bash
# 1. 명령행
java -jar app.jar --spring.profiles.active=prod

# 2. 환경 변수
export SPRING_PROFILES_ACTIVE=prod

# 3. application.yml
spring:
  profiles:
    active: prod
```

### ⭐⭐ 중급 1: 설정 우선순위는?

**답변:**
```
높음 ← 낮음
1. 명령행 인자
2. SPRING_APPLICATION_JSON
3. ServletConfig/ServletContext
4. JNDI
5. System.getProperties()
6. 환경 변수
7. application-{profile}.yml
8. application.yml
```

### ⭐⭐ 중급 2: 민감 정보를 안전하게 관리하는 방법은?

**답변:**

```
1. 환경 변수 사용
   ${DB_PASSWORD}

2. 외부 파일 (Git 제외)
   spring.config.import=file:./secrets.yml

3. Secrets Manager
   - AWS Secrets Manager
   - HashiCorp Vault

4. 암호화
   - Jasypt
```

### ⭐⭐ 중급 3: @ConfigurationProperties의 장점은?

**답변:**

```java
// 1. 타입 안전
private int timeout;  // 컴파일 타임 체크

// 2. 유효성 검증
@Min(1) @Max(100)
private int maxConnections;

// 3. IDE 지원
properties.getApi().getUrl();  // 자동완성

// 4. 중첩 구조
private Api api;
public static class Api {
    private String url;
}
```

---

## 🎯 다음 단계

프로퍼티 관리를 마쳤다면:

1. **32장: Actuator** - 운영 모니터링
2. **36장: 프로파일 관리 심화** - 고급 전략
3. **Spring Cloud Config** - 중앙화된 설정 서버

---

**🎓 학습 완료 체크리스트:**

- [ ] application.yml 작성
- [ ] @ConfigurationProperties 활용
- [ ] 프로파일별 설정 분리
- [ ] 환경 변수 사용
- [ ] 민감 정보 안전 관리
- [ ] 설정 우선순위 이해

**다음 장에서는 Actuator로 애플리케이션을 모니터링하는 방법을 배웁니다!** 🚀
