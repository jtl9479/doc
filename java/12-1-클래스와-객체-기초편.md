# 12-1. 클래스와 객체 (기초편)

## 학습 목표
- 클래스와 객체의 개념을 이해한다
- 클래스를 정의하고 객체를 생성할 수 있다
- 필드와 메서드를 활용할 수 있다
- 참조 타입과 null을 이해한다
- 객체 지향 프로그래밍의 기초를 다진다

---

## 1. 클래스와 객체란?

### 클래스(Class)
객체를 생성하기 위한 설계도, 틀, 템플릿입니다.

### 객체(Object)
클래스로부터 만들어진 실체, 인스턴스입니다.

```
클래스 = 설계도
객체 = 설계도로 만든 실제 제품
```

---

## 2. 실생활 비유로 이해하기

### 비유 1: 붕어빵 틀과 붕어빵 🧇

```
붕어빵 틀 (클래스)
    ↓ 반죽을 넣고 굽기
붕어빵1, 붕어빵2, 붕어빵3... (객체들)

- 붕어빵 틀 = 클래스 (설계도)
- 실제 붕어빵 = 객체 (인스턴스)
- 한 개의 틀로 여러 개의 붕어빵을 만들 수 있음
```

**Java 코드로 표현:**

```java
// 붕어빵 틀 (클래스)
class Bungeoppang {
    String filling;  // 앙금 종류
    int price;       // 가격
}

// 붕어빵 만들기 (객체 생성)
Bungeoppang bread1 = new Bungeoppang();
bread1.filling = "팥";
bread1.price = 1000;

Bungeoppang bread2 = new Bungeoppang();
bread2.filling = "슈크림";
bread2.price = 1200;

Bungeoppang bread3 = new Bungeoppang();
bread3.filling = "초코";
bread3.price = 1300;
```

**대응 관계:**
- 붕어빵 틀 = Class (한 번만 만듦)
- 붕어빵 = Object (여러 개 생성 가능)
- 틀의 모양 = 필드(변수) 정의
- 붕어빵 만드는 과정 = 생성자
- 완성된 붕어빵 = 인스턴스

---

### 비유 2: 자동차 설계도와 실제 자동차 🚗

```
현대 소나타 설계도 (클래스)
    ↓ 공장에서 생산
차량번호 12가3456 소나타 (객체1)
차량번호 34나5678 소나타 (객체2)
차량번호 56다7890 소나타 (객체3)

- 같은 설계도로 만들어졌지만
- 각 차는 독립적인 개체
- 각각 다른 색상, 옵션, 주행거리를 가짐
```

**Java 코드:**

```java
class Car {
    String brand;       // 브랜드
    String model;       // 모델명
    String color;       // 색상
    int year;           // 연식
    int mileage;        // 주행거리

    void drive() {
        mileage += 10;
        System.out.println("주행 중... 현재 주행거리: " + mileage + "km");
    }

    void displayInfo() {
        System.out.println("=== 차량 정보 ===");
        System.out.println("브랜드: " + brand);
        System.out.println("모델: " + model);
        System.out.println("색상: " + color);
        System.out.println("연식: " + year);
        System.out.println("주행거리: " + mileage + "km");
    }
}

// 객체 생성
Car car1 = new Car();
car1.brand = "현대";
car1.model = "소나타";
car1.color = "화이트";
car1.year = 2024;
car1.mileage = 0;

Car car2 = new Car();
car2.brand = "기아";
car2.model = "K5";
car2.color = "블랙";
car2.year = 2023;
car2.mileage = 15000;

// 각 객체는 독립적
car1.drive();  // car1의 주행거리만 증가
car2.drive();  // car2의 주행거리만 증가
```

**왜 이 비유가 좋은가:**
- 설계도 1개로 수천 대의 차량 생산 가능
- 각 차량은 같은 구조지만 다른 주인, 다른 색상 (다른 값)
- 설계도만 바꾸면 모든 차량의 구조 변경 가능

---

### 비유 3: 건축 설계도와 아파트 🏢

```
래미안 101동 설계도 (클래스)
    ↓ 시공
101동 301호 (객체1) - 김씨 가족 거주, 파란색 도배
101동 302호 (객체2) - 박씨 가족 거주, 흰색 도배
101동 303호 (객체3) - 이씨 가족 거주, 베이지 도배

- 같은 설계도지만
- 각 집마다 다른 가구, 인테리어, 거주자
```

**Java 코드:**

```java
class Apartment {
    int rooms;          // 방 개수
    double area;        // 평수
    int floor;          // 층수
    String owner;       // 소유자
    long price;         // 가격

    void displayInfo() {
        System.out.println("=== 아파트 정보 ===");
        System.out.println("방 개수: " + rooms + "개");
        System.out.println("평수: " + area + "평");
        System.out.println("층수: " + floor + "층");
        System.out.println("소유자: " + owner);
        System.out.println("가격: " + price + "만원");
    }
}

Apartment apt301 = new Apartment();
apt301.rooms = 3;
apt301.area = 84.5;
apt301.floor = 3;
apt301.owner = "김철수";
apt301.price = 50000;

Apartment apt302 = new Apartment();
apt302.rooms = 4;
apt302.area = 104.2;
apt302.floor = 3;
apt302.owner = "박영희";
apt302.price = 65000;
```

---

### 비유 4: 쿠키 커터와 쿠키들 🍪

```
별 모양 쿠키 커터 (클래스)
    ↓ 반죽을 찍기
쿠키1 - 초콜릿 맛 (객체1)
쿠키2 - 바닐라 맛 (객체2)
쿠키3 - 딸기 맛 (객체3)

- 같은 모양(구조)을 가지지만
- 각각 다른 맛(데이터)을 가질 수 있음
```

**Java 코드:**

```java
class Cookie {
    String shape;       // 모양
    String flavor;      // 맛
    int calories;       // 칼로리
    boolean hasChips;   // 초코칩 유무

    void eat() {
        System.out.println(flavor + " 맛 쿠키를 먹었습니다!");
        System.out.println("칼로리: " + calories + "kcal 섭취");
    }
}

Cookie cookie1 = new Cookie();
cookie1.shape = "별";
cookie1.flavor = "초콜릿";
cookie1.calories = 150;
cookie1.hasChips = true;

Cookie cookie2 = new Cookie();
cookie2.shape = "별";
cookie2.flavor = "바닐라";
cookie2.calories = 120;
cookie2.hasChips = false;

cookie1.eat();  // 초콜릿 맛 쿠키를 먹었습니다!
cookie2.eat();  // 바닐라 맛 쿠키를 먹었습니다!
```

---

### 비유 5: 스마트폰 모델과 개별 기기 📱

```
갤럭시 S24 모델 (클래스)
    ↓ 출시
철수의 갤럭시 S24 (객체1) - 배경화면: 고양이, 앱 50개
영희의 갤럭시 S24 (객체2) - 배경화면: 풍경, 앱 30개
민수의 갤럭시 S24 (객체3) - 배경화면: 가족, 앱 80개

- 같은 모델이지만
- 각 기기는 독립적인 데이터와 상태를 가짐
```

**Java 코드:**

```java
class Smartphone {
    String model;           // 모델명
    String owner;           // 소유자
    String wallpaper;       // 배경화면
    int appCount;           // 앱 개수
    int batteryLevel;       // 배터리 잔량

    void installApp(String appName) {
        appCount++;
        System.out.println(appName + " 앱 설치 완료!");
        System.out.println("총 앱 개수: " + appCount);
    }

    void useBattery(int usage) {
        batteryLevel -= usage;
        System.out.println("배터리 " + usage + "% 소모");
        System.out.println("남은 배터리: " + batteryLevel + "%");
    }

    void displayInfo() {
        System.out.println("=== 스마트폰 정보 ===");
        System.out.println("모델: " + model);
        System.out.println("소유자: " + owner);
        System.out.println("배경화면: " + wallpaper);
        System.out.println("앱 개수: " + appCount);
        System.out.println("배터리: " + batteryLevel + "%");
    }
}

Smartphone phone1 = new Smartphone();
phone1.model = "갤럭시 S24";
phone1.owner = "김철수";
phone1.wallpaper = "고양이";
phone1.appCount = 50;
phone1.batteryLevel = 100;

Smartphone phone2 = new Smartphone();
phone2.model = "갤럭시 S24";
phone2.owner = "이영희";
phone2.wallpaper = "풍경";
phone2.appCount = 30;
phone2.batteryLevel = 75;

phone1.installApp("카카오톡");  // phone1에만 영향
phone2.useBattery(20);         // phone2에만 영향
```

---

### 종합 비교표

| 개념 | 비유 1 | 비유 2 | 비유 3 | 비유 4 | 비유 5 |
|------|--------|--------|--------|--------|--------|
| **클래스** | 붕어빵 틀 | 자동차 설계도 | 아파트 설계도 | 쿠키 커터 | 스마트폰 모델 |
| **객체** | 실제 붕어빵 | 생산된 자동차 | 각 호수 | 찍어낸 쿠키 | 개별 기기 |
| **필드** | 앙금 종류, 가격 | 색상, 주행거리 | 소유자, 평수 | 맛, 칼로리 | 배경화면, 앱 개수 |
| **메서드** | - | 주행하기 | 정보 표시 | 먹기 | 앱 설치, 배터리 소모 |
| **핵심** | 한 틀로 여러 빵 | 설계도로 대량생산 | 같은 구조, 다른 거주자 | 같은 모양, 다른 맛 | 같은 모델, 다른 설정 |

**공통 핵심:**
- **클래스는 1번만 정의**
- **객체는 필요한 만큼 무한 생성 가능**
- **같은 클래스로 만든 객체들은 구조는 같지만 값은 다름**

---

## 3. 클래스 정의하기

### 기본 문법

```java
public class 클래스명 {
    // 필드 (Field) - 객체의 속성/상태
    타입 변수명;

    // 메서드 (Method) - 객체의 동작/행위
    반환타입 메서드명(매개변수) {
        // 실행할 코드
    }
}
```

### 실제 예제: Student 클래스

```java
public class Student {
    // 필드 (객체의 속성)
    String name;        // 이름
    int studentId;      // 학번
    String major;       // 전공
    double gpa;         // 학점
    int age;            // 나이

    // 메서드 (객체의 동작)
    void study() {
        System.out.println(name + " 학생이 공부합니다.");
    }

    void takeExam() {
        System.out.println(name + " 학생이 시험을 봅니다.");
    }

    void displayInfo() {
        System.out.println("=== 학생 정보 ===");
        System.out.println("이름: " + name);
        System.out.println("학번: " + studentId);
        System.out.println("전공: " + major);
        System.out.println("학점: " + gpa);
        System.out.println("나이: " + age);
    }
}
```

---

## 4. 객체 생성하기

### 객체 생성 문법

```java
클래스명 변수명 = new 클래스명();
```

### 단계별 이해

```java
// 1단계: 참조 변수 선언
Student student;

// 2단계: 객체 생성 및 할당
student = new Student();

// 또는 한 줄로
Student student = new Student();
```

### 메모리 구조

```
Stack 영역              Heap 영역
┌─────────┐         ┌──────────────────┐
│ student │────────>│ Student 객체      │
│ (참조)  │         │ name: null        │
└─────────┘         │ studentId: 0      │
                    │ major: null       │
                    │ gpa: 0.0          │
                    │ age: 0            │
                    │ study()           │
                    │ takeExam()        │
                    │ displayInfo()     │
                    └──────────────────┘
```

### 객체 사용 예시

```java
public class StudentTest {
    public static void main(String[] args) {
        // 객체 생성
        Student student1 = new Student();

        // 필드에 값 설정
        student1.name = "김철수";
        student1.studentId = 2024001;
        student1.major = "컴퓨터공학";
        student1.gpa = 3.8;
        student1.age = 20;

        // 메서드 호출
        student1.study();        // 김철수 학생이 공부합니다.
        student1.takeExam();     // 김철수 학생이 시험을 봅니다.
        student1.displayInfo();  // 학생 정보 출력

        // 두 번째 학생 객체
        Student student2 = new Student();
        student2.name = "이영희";
        student2.studentId = 2024002;
        student2.major = "경영학";
        student2.gpa = 4.0;
        student2.age = 21;

        student2.displayInfo();
    }
}
```

출력:
```
김철수 학생이 공부합니다.
김철수 학생이 시험을 봅니다.
=== 학생 정보 ===
이름: 김철수
학번: 2024001
전공: 컴퓨터공학
학점: 3.8
나이: 20
=== 학생 정보 ===
이름: 이영희
학번: 2024002
전공: 경영학
학점: 4.0
나이: 21
```

---

## 5. 기업 사례로 배우는 클래스 설계

### 사례 1: 카카오톡 - User 클래스 설계 💬

**배경:**
카카오톡은 9천만 명의 사용자를 관리합니다. 각 사용자는 고유한 정보와 상태를 가져야 합니다.

**문제 상황:**
초기에는 배열로 사용자 정보를 관리했습니다:
```java
String[] usernames = new String[90000000];
String[] profileImages = new String[90000000];
String[] statusMessages = new String[90000000];
boolean[] isOnline = new boolean[90000000];
```

**문제점:**
- 관련 데이터가 흩어져 있음
- 인덱스 관리가 복잡
- 데이터 정합성 보장 어려움
- 확장성 부족

**해결책: User 클래스 설계**

```java
public class User {
    // 필드
    String userId;
    String username;
    String profileImage;
    String statusMessage;
    boolean isOnline;
    int friendCount;

    // 메서드
    void sendMessage(User receiver, String message) {
        if (!this.isOnline) {
            System.out.println("오프라인 상태에서는 메시지를 보낼 수 없습니다.");
            return;
        }
        System.out.println(this.username + " -> " + receiver.username + ": " + message);
    }

    void setOnlineStatus(boolean status) {
        this.isOnline = status;
        if (status) {
            System.out.println(username + "님이 접속했습니다.");
        } else {
            System.out.println(username + "님이 오프라인 상태입니다.");
        }
    }

    void updateStatusMessage(String message) {
        this.statusMessage = message;
        System.out.println("상태 메시지가 '" + message + "'로 변경되었습니다.");
    }
}
```

**사용 예시:**

```java
public class KakaoTalkSimulator {
    public static void main(String[] args) {
        // 사용자 객체 생성
        User user1 = new User();
        user1.userId = "kakao001";
        user1.username = "철수";
        user1.profileImage = "profile1.jpg";
        user1.isOnline = false;

        User user2 = new User();
        user2.userId = "kakao002";
        user2.username = "영희";
        user2.profileImage = "profile2.jpg";
        user2.isOnline = true;

        // 기능 사용
        user1.setOnlineStatus(true);
        user1.updateStatusMessage("오늘 날씨 좋네요!");
        user1.sendMessage(user2, "안녕하세요!");

        user2.sendMessage(user1, "네, 반갑습니다!");
    }
}
```

**효과:**
- 관련 데이터를 하나의 단위로 관리
- 코드 가독성 향상
- 유지보수 용이
- 9천만 사용자를 효율적으로 관리

---

### 사례 2: 배달의민족 - Order 클래스 설계 🍔

**배경:**
배달의민족은 하루 수백만 건의 주문을 처리합니다. 각 주문은 복잡한 정보와 상태를 가집니다.

**Order 클래스 설계:**

```java
public class Order {
    // 주문 정보
    String orderId;
    String customerId;
    String restaurantId;
    String[] menuItems;
    int totalPrice;
    String deliveryAddress;

    // 주문 상태
    String status;  // "주문접수", "조리중", "배달중", "배달완료"
    String riderId;

    // 시간 정보
    String orderTime;
    String estimatedDeliveryTime;

    // 메서드
    void updateStatus(String newStatus) {
        this.status = newStatus;
        System.out.println("[주문 " + orderId + "] 상태 변경: " + newStatus);

        if (newStatus.equals("조리중")) {
            System.out.println("고객님의 음식이 맛있게 조리되고 있어요!");
        } else if (newStatus.equals("배달중")) {
            System.out.println("라이더님이 출발했어요! 곧 도착합니다.");
        } else if (newStatus.equals("배달완료")) {
            System.out.println("맛있게 드세요!");
        }
    }

    void assignRider(String riderId) {
        this.riderId = riderId;
        System.out.println("라이더 배정 완료: " + riderId);
    }

    void displayOrderInfo() {
        System.out.println("=== 주문 정보 ===");
        System.out.println("주문번호: " + orderId);
        System.out.println("배달주소: " + deliveryAddress);
        System.out.println("총 금액: " + totalPrice + "원");
        System.out.println("현재 상태: " + status);
        System.out.println("예상 도착: " + estimatedDeliveryTime);
    }
}
```

**시뮬레이션:**

```java
public class BaeminSimulator {
    public static void main(String[] args) {
        // 주문 생성
        Order order = new Order();
        order.orderId = "ORDER-20241009-001";
        order.customerId = "USER-12345";
        order.restaurantId = "REST-67890";
        order.menuItems = new String[]{"치킨", "콜라"};
        order.totalPrice = 18000;
        order.deliveryAddress = "서울시 강남구 테헤란로 123";
        order.orderTime = "19:30";
        order.estimatedDeliveryTime = "20:15";
        order.status = "주문접수";

        // 주문 정보 확인
        order.displayOrderInfo();

        System.out.println("\n=== 주문 진행 과정 ===");

        // 조리 시작
        try { Thread.sleep(1000); } catch (Exception e) {}
        order.updateStatus("조리중");

        // 라이더 배정
        try { Thread.sleep(2000); } catch (Exception e) {}
        order.assignRider("RIDER-456");
        order.updateStatus("배달중");

        // 배달 완료
        try { Thread.sleep(2000); } catch (Exception e) {}
        order.updateStatus("배달완료");
    }
}
```

**효과:**
- 주문의 전체 생명주기를 객체로 관리
- 상태 변화 추적 용이
- 고객 경험 개선
- 하루 수백만 건의 주문을 안정적으로 처리

---

### 사례 3: 토스 - Account 클래스 설계 💰

**배경:**
토스는 수천만 개의 계좌를 관리하며, 각 계좌는 잔액, 거래 내역, 보안 정보를 가집니다.

**Account 클래스 설계:**

```java
public class Account {
    // 계좌 정보
    String accountNumber;
    String ownerName;
    long balance;
    String accountType;  // "입출금", "저축", "투자"
    boolean isActive;

    // 보안
    String pin;
    int failedAttempts;

    // 메서드
    void deposit(long amount) {
        if (amount <= 0) {
            System.out.println("❌ 입금액은 0보다 커야 합니다.");
            return;
        }

        balance += amount;
        System.out.println("✅ 입금 완료: " + amount + "원");
        System.out.println("현재 잔액: " + balance + "원");
    }

    boolean withdraw(long amount, String inputPin) {
        // PIN 확인
        if (!pin.equals(inputPin)) {
            failedAttempts++;
            System.out.println("❌ PIN이 일치하지 않습니다. (" + failedAttempts + "/5)");

            if (failedAttempts >= 5) {
                isActive = false;
                System.out.println("⚠️ 계좌가 잠겼습니다. 고객센터에 문의하세요.");
            }
            return false;
        }

        // 잔액 확인
        if (amount > balance) {
            System.out.println("❌ 잔액이 부족합니다.");
            System.out.println("현재 잔액: " + balance + "원");
            return false;
        }

        // 출금 처리
        balance -= amount;
        failedAttempts = 0;  // 성공 시 실패 횟수 초기화
        System.out.println("✅ 출금 완료: " + amount + "원");
        System.out.println("현재 잔액: " + balance + "원");
        return true;
    }

    void transfer(Account targetAccount, long amount, String inputPin) {
        System.out.println("\n=== 계좌 이체 ===");
        System.out.println(this.ownerName + " -> " + targetAccount.ownerName);

        // 출금 시도
        if (this.withdraw(amount, inputPin)) {
            // 출금 성공 시 상대방 계좌에 입금
            targetAccount.deposit(amount);
            System.out.println("✅ 이체가 완료되었습니다.");
        } else {
            System.out.println("❌ 이체에 실패했습니다.");
        }
    }

    void displayAccountInfo() {
        System.out.println("=== 계좌 정보 ===");
        System.out.println("계좌번호: " + accountNumber);
        System.out.println("예금주: " + ownerName);
        System.out.println("잔액: " + balance + "원");
        System.out.println("계좌 유형: " + accountType);
        System.out.println("계좌 상태: " + (isActive ? "정상" : "잠김"));
    }
}
```

**시뮬레이션:**

```java
public class TossSimulator {
    public static void main(String[] args) {
        // 계좌 생성
        Account account1 = new Account();
        account1.accountNumber = "1002-1234-5678";
        account1.ownerName = "김철수";
        account1.balance = 100000;
        account1.accountType = "입출금";
        account1.pin = "1234";
        account1.isActive = true;
        account1.failedAttempts = 0;

        Account account2 = new Account();
        account2.accountNumber = "1002-8765-4321";
        account2.ownerName = "이영희";
        account2.balance = 50000;
        account2.accountType = "입출금";
        account2.pin = "5678";
        account2.isActive = true;
        account2.failedAttempts = 0;

        // 계좌 정보 확인
        account1.displayAccountInfo();

        System.out.println("\n=== 입금 테스트 ===");
        account1.deposit(50000);

        System.out.println("\n=== 출금 테스트 (잘못된 PIN) ===");
        account1.withdraw(10000, "0000");  // 실패

        System.out.println("\n=== 출금 테스트 (올바른 PIN) ===");
        account1.withdraw(10000, "1234");  // 성공

        System.out.println("\n=== 계좌 이체 테스트 ===");
        account1.transfer(account2, 30000, "1234");

        System.out.println("\n=== 최종 잔액 확인 ===");
        account1.displayAccountInfo();
        System.out.println();
        account2.displayAccountInfo();
    }
}
```

**효과:**
- 계좌별 독립적인 상태 관리
- 보안 로직을 객체 내부에 캡슐화
- 계좌 간 이체 로직 명확화
- 금융 서비스의 신뢰성 확보

---

## 6. 주니어 개발자 시나리오

### 시나리오 1: NullPointerException으로 고생한 신입 개발자 😰

**상황:**
신입 개발자 민수는 회원 관리 시스템을 개발 중입니다.

**문제 코드:**

```java
public class UserService {
    public static void main(String[] args) {
        User user;  // 선언만 하고 객체 생성 안 함

        System.out.println("사용자 이름: " + user.username);  // ❌ 컴파일 에러
    }
}
```

컴파일 에러:
```
error: variable user might not have been initialized
```

**수정 1: null로 초기화**

```java
public class UserService {
    public static void main(String[] args) {
        User user = null;  // null로 초기화

        System.out.println("사용자 이름: " + user.username);  // ❌ NullPointerException!
    }
}
```

런타임 에러:
```
Exception in thread "main" java.lang.NullPointerException
    at UserService.main(UserService.java:5)
```

**올바른 해결:**

```java
public class UserService {
    public static void main(String[] args) {
        // 해결 1: 객체 생성
        User user = new User();
        user.username = "김민수";
        System.out.println("사용자 이름: " + user.username);  // ✅ 정상 작동

        // 해결 2: null 체크
        User user2 = null;
        if (user2 != null) {
            System.out.println("사용자 이름: " + user2.username);
        } else {
            System.out.println("사용자 정보가 없습니다.");  // ✅ 안전
        }
    }
}
```

**교훈:**
- 참조 변수는 반드시 객체를 생성해야 사용 가능
- null 체크는 필수
- 명확한 초기화가 중요

---

### 시나리오 2: 클래스와 객체를 구분 못해서 혼란스러웠던 경험 😵

**상황:**
신입 개발자 지수는 클래스와 객체의 차이를 이해하지 못했습니다.

**잘못된 이해:**

```java
// 지수의 착각: 클래스 자체가 하나의 데이터라고 생각
public class Student {
    String name = "김철수";
    int age = 20;
}

// 메인에서
Student.name = "이영희";  // ❌ 컴파일 에러!
```

에러:
```
error: non-static variable name cannot be referenced from a static context
```

**지수의 혼란:**
- "왜 Student.name으로 접근이 안 되지?"
- "클래스 이름으로 바로 쓸 수 없나?"
- "객체를 왜 만들어야 하는 거지?"

**선배의 설명:**

```java
// 클래스는 설계도일 뿐!
public class Student {
    String name;  // 설계도의 필드
    int age;
}

public class Main {
    public static void main(String[] args) {
        // 객체를 만들어야 실제 사용 가능
        Student student1 = new Student();  // 첫 번째 학생
        student1.name = "김철수";
        student1.age = 20;

        Student student2 = new Student();  // 두 번째 학생
        student2.name = "이영희";
        student2.age = 22;

        // 각각 독립적인 데이터
        System.out.println("학생1: " + student1.name + ", " + student1.age + "세");
        System.out.println("학생2: " + student2.name + ", " + student2.age + "세");
    }
}
```

**비유로 이해:**

```
붕어빵 틀 (클래스)     →  실제로 먹을 수 없음
     ↓
붕어빵 (객체)          →  실제로 먹을 수 있음
```

**교훈:**
- 클래스는 설계도 (Class = Blueprint)
- 객체는 실제 제품 (Object = Instance)
- 반드시 new로 객체를 생성해야 사용 가능

---

### 시나리오 3: 객체 참조 이해 부족으로 데이터 공유 문제 😱

**상황:**
신입 개발자 수진은 두 개의 독립적인 계좌를 만들려고 했습니다.

**문제 코드:**

```java
public class BankTest {
    public static void main(String[] args) {
        Account account1 = new Account();
        account1.ownerName = "김수진";
        account1.balance = 10000;

        // 수진의 생각: account2는 새로운 계좌
        Account account2 = account1;  // ❌ 같은 객체를 가리킴!
        account2.ownerName = "박민호";
        account2.balance = 20000;

        // 결과 확인
        System.out.println("Account1: " + account1.ownerName + ", " + account1.balance);
        System.out.println("Account2: " + account2.ownerName + ", " + account2.balance);
    }
}
```

**실행 결과 (수진의 예상과 다름):**
```
Account1: 박민호, 20000
Account2: 박민호, 20000
```

**왜 이런 일이?**

메모리 구조:
```
Stack                   Heap
┌──────────┐         ┌─────────────────┐
│account1  │────────>│ Account 객체     │
├──────────┤    ┌───>│ ownerName: 박민호│
│account2  │────┘    │ balance: 20000  │
└──────────┘         └─────────────────┘

account1과 account2가 같은 객체를 가리킴!
```

**올바른 코드:**

```java
public class BankTest {
    public static void main(String[] args) {
        // 첫 번째 계좌 생성
        Account account1 = new Account();  // new!
        account1.ownerName = "김수진";
        account1.balance = 10000;

        // 두 번째 계좌 생성
        Account account2 = new Account();  // 또 new!
        account2.ownerName = "박민호";
        account2.balance = 20000;

        // 결과 확인
        System.out.println("Account1: " + account1.ownerName + ", " + account1.balance);
        System.out.println("Account2: " + account2.ownerName + ", " + account2.balance);
    }
}
```

**실행 결과:**
```
Account1: 김수진, 10000
Account2: 박민호, 20000
```

**교훈:**
- `=` 연산자는 참조를 복사 (객체를 복사하는 게 아님)
- 새로운 객체가 필요하면 반드시 `new` 사용
- 참조 타입의 동작 원리 이해 중요

---

### 시나리오 4: 객체 배열 초기화 실수 😓

**상황:**
신입 개발자 현우는 5명의 학생 정보를 저장하려고 객체 배열을 만들었습니다.

**문제 코드:**

```java
public class StudentManager {
    public static void main(String[] args) {
        // 학생 배열 생성
        Student[] students = new Student[5];

        // 현우의 생각: 배열만 만들면 학생 객체도 자동 생성?
        students[0].name = "김철수";  // ❌ NullPointerException!
    }
}
```

**에러:**
```
Exception in thread "main" java.lang.NullPointerException
    at StudentManager.main(StudentManager.java:7)
```

**현우의 혼란:**
- "배열을 만들었는데 왜 에러가?"
- "students[0]이 없다고?"

**선배의 설명:**

```java
// 문제 상황
Student[] students = new Student[5];

// 현재 상태:
// students[0] = null
// students[1] = null
// students[2] = null
// students[3] = null
// students[4] = null

// 배열은 만들어졌지만, 각 요소는 null!
```

**올바른 해결:**

```java
public class StudentManager {
    public static void main(String[] args) {
        // 1단계: 배열 생성
        Student[] students = new Student[5];

        // 2단계: 각 요소에 객체 생성
        students[0] = new Student();
        students[0].name = "김철수";
        students[0].age = 20;

        students[1] = new Student();
        students[1].name = "이영희";
        students[1].age = 21;

        students[2] = new Student();
        students[2].name = "박민수";
        students[2].age = 22;

        // 반복문으로 초기화
        for (int i = 0; i < students.length; i++) {
            if (students[i] != null) {
                System.out.println(students[i].name + " (" + students[i].age + "세)");
            }
        }
    }
}
```

**교훈:**
- 배열 생성 ≠ 객체 생성
- 배열의 각 요소는 기본값 null
- 사용 전 반드시 객체 생성 필요
- null 체크는 필수

---

## 7. 실전 프로젝트: 도서관 관리 시스템 📚

### 프로젝트 개요

도서관 관리 시스템을 만들어봅시다. 책, 회원, 대출 정보를 관리하는 시스템입니다.

### 요구사항
1. 도서 정보 관리 (Book 클래스)
2. 회원 정보 관리 (Member 클래스)
3. 대출 정보 관리 (Loan 클래스)
4. 도서관 운영 (Library 클래스)
5. 메뉴 시스템 (LibrarySystem 메인 클래스)

---

### 1단계: Book 클래스

```java
/**
 * 도서 정보를 관리하는 클래스
 */
public class Book {
    // 필드
    String bookId;          // 도서 ID (예: B001)
    String title;           // 도서명
    String author;          // 저자
    String publisher;       // 출판사
    int publicationYear;    // 출판연도
    boolean isAvailable;    // 대출 가능 여부

    // 메서드
    void displayInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📖 도서 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("도서 ID: " + bookId);
        System.out.println("제목: " + title);
        System.out.println("저자: " + author);
        System.out.println("출판사: " + publisher);
        System.out.println("출판연도: " + publicationYear);
        System.out.println("대출 상태: " + (isAvailable ? "✅ 대출 가능" : "❌ 대출중"));
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
    }

    boolean checkOut() {
        if (!isAvailable) {
            System.out.println("❌ 이미 대출중인 도서입니다.");
            return false;
        }

        isAvailable = false;
        System.out.println("✅ 대출 처리되었습니다: " + title);
        return true;
    }

    void returnBook() {
        isAvailable = true;
        System.out.println("✅ 반납 처리되었습니다: " + title);
    }
}
```

---

### 2단계: Member 클래스

```java
/**
 * 도서관 회원 정보를 관리하는 클래스
 */
public class Member {
    // 필드
    String memberId;        // 회원 ID (예: M001)
    String name;            // 회원 이름
    String phone;           // 전화번호
    int age;                // 나이
    int borrowedCount;      // 현재 대출중인 도서 수
    int maxBorrowLimit;     // 최대 대출 가능 수

    // 메서드
    void displayInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("👤 회원 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("회원 ID: " + memberId);
        System.out.println("이름: " + name);
        System.out.println("전화번호: " + phone);
        System.out.println("나이: " + age);
        System.out.println("대출중인 도서: " + borrowedCount + "/" + maxBorrowLimit + "권");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
    }

    boolean canBorrow() {
        return borrowedCount < maxBorrowLimit;
    }

    void increaseBorrowCount() {
        borrowedCount++;
    }

    void decreaseBorrowCount() {
        if (borrowedCount > 0) {
            borrowedCount--;
        }
    }
}
```

---

### 3단계: Loan 클래스

```java
/**
 * 대출 정보를 관리하는 클래스
 */
public class Loan {
    // 필드
    String loanId;          // 대출 ID
    String memberId;        // 회원 ID
    String bookId;          // 도서 ID
    String memberName;      // 회원 이름 (표시용)
    String bookTitle;       // 도서명 (표시용)
    String loanDate;        // 대출일
    String dueDate;         // 반납 예정일
    String returnDate;      // 실제 반납일
    boolean isReturned;     // 반납 여부

    // 메서드
    void displayInfo() {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📋 대출 정보");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("대출 ID: " + loanId);
        System.out.println("회원: " + memberName + " (" + memberId + ")");
        System.out.println("도서: " + bookTitle + " (" + bookId + ")");
        System.out.println("대출일: " + loanDate);
        System.out.println("반납 예정일: " + dueDate);

        if (isReturned) {
            System.out.println("반납일: " + returnDate);
            System.out.println("상태: ✅ 반납 완료");
        } else {
            System.out.println("상태: ⏳ 대출중");
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━");
    }

    void returnLoan(String returnDate) {
        this.returnDate = returnDate;
        this.isReturned = true;
        System.out.println("✅ 반납 처리 완료");
    }
}
```

---

### 4단계: Library 클래스

```java
/**
 * 도서관 전체를 관리하는 클래스
 */
public class Library {
    // 필드
    String libraryName;
    Book[] books;           // 도서 목록
    Member[] members;       // 회원 목록
    Loan[] loans;           // 대출 기록
    int bookCount;          // 현재 도서 수
    int memberCount;        // 현재 회원 수
    int loanCount;          // 대출 기록 수

    // 메서드
    void displayLibraryInfo() {
        System.out.println("\n╔════════════════════════════════╗");
        System.out.println("║   " + libraryName + "   ║");
        System.out.println("╚════════════════════════════════╝");
        System.out.println("📚 전체 도서: " + bookCount + "권");
        System.out.println("👥 전체 회원: " + memberCount + "명");
        System.out.println("📋 대출 기록: " + loanCount + "건");
        System.out.println();
    }

    void addBook(Book book) {
        if (bookCount < books.length) {
            books[bookCount] = book;
            bookCount++;
            System.out.println("✅ 도서가 추가되었습니다: " + book.title);
        } else {
            System.out.println("❌ 도서관이 가득 찼습니다.");
        }
    }

    void addMember(Member member) {
        if (memberCount < members.length) {
            members[memberCount] = member;
            memberCount++;
            System.out.println("✅ 회원이 등록되었습니다: " + member.name);
        } else {
            System.out.println("❌ 회원 등록이 가득 찼습니다.");
        }
    }

    Book findBookById(String bookId) {
        for (int i = 0; i < bookCount; i++) {
            if (books[i].bookId.equals(bookId)) {
                return books[i];
            }
        }
        return null;
    }

    Member findMemberById(String memberId) {
        for (int i = 0; i < memberCount; i++) {
            if (members[i].memberId.equals(memberId)) {
                return members[i];
            }
        }
        return null;
    }

    void borrowBook(String memberId, String bookId, String loanDate, String dueDate) {
        System.out.println("\n=== 도서 대출 처리 ===");

        // 회원 찾기
        Member member = findMemberById(memberId);
        if (member == null) {
            System.out.println("❌ 회원을 찾을 수 없습니다: " + memberId);
            return;
        }

        // 대출 가능 여부 확인
        if (!member.canBorrow()) {
            System.out.println("❌ 대출 한도를 초과했습니다. (" + member.borrowedCount + "/" + member.maxBorrowLimit + ")");
            return;
        }

        // 도서 찾기
        Book book = findBookById(bookId);
        if (book == null) {
            System.out.println("❌ 도서를 찾을 수 없습니다: " + bookId);
            return;
        }

        // 도서 대출 처리
        if (book.checkOut()) {
            // 대출 기록 생성
            Loan loan = new Loan();
            loan.loanId = "L" + String.format("%03d", loanCount + 1);
            loan.memberId = memberId;
            loan.bookId = bookId;
            loan.memberName = member.name;
            loan.bookTitle = book.title;
            loan.loanDate = loanDate;
            loan.dueDate = dueDate;
            loan.isReturned = false;

            loans[loanCount] = loan;
            loanCount++;

            member.increaseBorrowCount();

            System.out.println("\n✅ 대출이 완료되었습니다!");
            System.out.println("회원: " + member.name);
            System.out.println("도서: " + book.title);
            System.out.println("반납 예정일: " + dueDate);
        }
    }

    void returnBook(String memberId, String bookId, String returnDate) {
        System.out.println("\n=== 도서 반납 처리 ===");

        // 대출 기록 찾기
        Loan foundLoan = null;
        for (int i = 0; i < loanCount; i++) {
            if (loans[i].memberId.equals(memberId) &&
                loans[i].bookId.equals(bookId) &&
                !loans[i].isReturned) {
                foundLoan = loans[i];
                break;
            }
        }

        if (foundLoan == null) {
            System.out.println("❌ 대출 기록을 찾을 수 없습니다.");
            return;
        }

        // 도서 반납 처리
        Book book = findBookById(bookId);
        book.returnBook();

        // 회원 대출 수 감소
        Member member = findMemberById(memberId);
        member.decreaseBorrowCount();

        // 대출 기록 업데이트
        foundLoan.returnLoan(returnDate);

        System.out.println("\n✅ 반납이 완료되었습니다!");
        System.out.println("회원: " + member.name);
        System.out.println("도서: " + book.title);
    }

    void displayAllBooks() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📚 전체 도서 목록 (" + bookCount + "권)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        if (bookCount == 0) {
            System.out.println("등록된 도서가 없습니다.");
            return;
        }

        for (int i = 0; i < bookCount; i++) {
            Book book = books[i];
            String status = book.isAvailable ? "✅ 가능" : "❌ 대출중";
            System.out.printf("[%s] %s - %s (%s)%n",
                book.bookId, book.title, book.author, status);
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    void displayAllMembers() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("👥 전체 회원 목록 (" + memberCount + "명)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        if (memberCount == 0) {
            System.out.println("등록된 회원이 없습니다.");
            return;
        }

        for (int i = 0; i < memberCount; i++) {
            Member member = members[i];
            System.out.printf("[%s] %s - 대출: %d/%d권%n",
                member.memberId, member.name,
                member.borrowedCount, member.maxBorrowLimit);
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }

    void displayAllLoans() {
        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("📋 전체 대출 기록 (" + loanCount + "건)");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

        if (loanCount == 0) {
            System.out.println("대출 기록이 없습니다.");
            return;
        }

        for (int i = 0; i < loanCount; i++) {
            Loan loan = loans[i];
            String status = loan.isReturned ? "✅ 반납완료" : "⏳ 대출중";
            System.out.printf("[%s] %s - %s (%s) | 대출일: %s%n",
                loan.loanId, loan.memberName, loan.bookTitle,
                status, loan.loanDate);
        }
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

---

### 5단계: LibrarySystem 메인 클래스

```java
/**
 * 도서관 관리 시스템 메인 프로그램
 */
public class LibrarySystem {
    public static void main(String[] args) {
        System.out.println("╔════════════════════════════════════════╗");
        System.out.println("║   도서관 관리 시스템 v1.0 시작        ║");
        System.out.println("╚════════════════════════════════════════╝\n");

        // 도서관 생성
        Library library = new Library();
        library.libraryName = "서울 시립 도서관";
        library.books = new Book[100];
        library.members = new Member[50];
        library.loans = new Loan[200];
        library.bookCount = 0;
        library.memberCount = 0;
        library.loanCount = 0;

        // 초기 데이터 설정
        setupInitialData(library);

        // 도서관 정보 출력
        library.displayLibraryInfo();

        // 시뮬레이션 시작
        runSimulation(library);
    }

    static void setupInitialData(Library library) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🔧 초기 데이터 설정 중...");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");

        // 도서 추가
        System.out.println("📚 도서 등록:");

        Book book1 = new Book();
        book1.bookId = "B001";
        book1.title = "자바의 정석";
        book1.author = "남궁성";
        book1.publisher = "도우출판";
        book1.publicationYear = 2022;
        book1.isAvailable = true;
        library.addBook(book1);

        Book book2 = new Book();
        book2.bookId = "B002";
        book2.title = "클린 코드";
        book2.author = "로버트 C. 마틴";
        book2.publisher = "인사이트";
        book2.publicationYear = 2013;
        book2.isAvailable = true;
        library.addBook(book2);

        Book book3 = new Book();
        book3.bookId = "B003";
        book3.title = "이펙티브 자바";
        book3.author = "조슈아 블로크";
        book3.publisher = "인사이트";
        book3.publicationYear = 2018;
        book3.isAvailable = true;
        library.addBook(book3);

        Book book4 = new Book();
        book4.bookId = "B004";
        book4.title = "모던 자바 인 액션";
        book4.author = "라울-게이브리얼 우르마";
        book4.publisher = "한빛미디어";
        book4.publicationYear = 2019;
        book4.isAvailable = true;
        library.addBook(book4);

        Book book5 = new Book();
        book5.bookId = "B005";
        book5.title = "헤드 퍼스트 디자인 패턴";
        book5.author = "에릭 프리먼";
        book5.publisher = "한빛미디어";
        book5.publicationYear = 2022;
        book5.isAvailable = true;
        library.addBook(book5);

        // 회원 추가
        System.out.println("\n👥 회원 등록:");

        Member member1 = new Member();
        member1.memberId = "M001";
        member1.name = "김철수";
        member1.phone = "010-1234-5678";
        member1.age = 25;
        member1.borrowedCount = 0;
        member1.maxBorrowLimit = 3;
        library.addMember(member1);

        Member member2 = new Member();
        member2.memberId = "M002";
        member2.name = "이영희";
        member2.phone = "010-2345-6789";
        member2.age = 30;
        member2.borrowedCount = 0;
        member2.maxBorrowLimit = 5;
        library.addMember(member2);

        Member member3 = new Member();
        member3.memberId = "M003";
        member3.name = "박민수";
        member3.phone = "010-3456-7890";
        member3.age = 22;
        member3.borrowedCount = 0;
        member3.maxBorrowLimit = 3;
        library.addMember(member3);

        System.out.println("\n✅ 초기 데이터 설정 완료!\n");
    }

    static void runSimulation(Library library) {
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("🎬 도서관 운영 시뮬레이션 시작");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n");

        // 전체 도서 목록 보기
        library.displayAllBooks();

        // 전체 회원 목록 보기
        library.displayAllMembers();

        // 시나리오 1: 김철수가 "자바의 정석" 대출
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 1: 도서 대출           │");
        System.out.println("└────────────────────────────────┘");
        library.borrowBook("M001", "B001", "2024-10-09", "2024-10-23");

        // 시나리오 2: 이영희가 "클린 코드"와 "이펙티브 자바" 대출
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 2: 여러 권 대출        │");
        System.out.println("└────────────────────────────────┘");
        library.borrowBook("M002", "B002", "2024-10-09", "2024-10-23");
        library.borrowBook("M002", "B003", "2024-10-09", "2024-10-23");

        // 현재 상태 확인
        library.displayAllBooks();
        library.displayAllMembers();
        library.displayAllLoans();

        // 시나리오 3: 박민수가 이미 대출중인 책 대출 시도
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 3: 대출중인 책 시도    │");
        System.out.println("└────────────────────────────────┘");
        library.borrowBook("M003", "B001", "2024-10-09", "2024-10-23");

        // 시나리오 4: 김철수가 "자바의 정석" 반납
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 4: 도서 반납           │");
        System.out.println("└────────────────────────────────┘");
        library.returnBook("M001", "B001", "2024-10-15");

        // 시나리오 5: 이제 박민수가 "자바의 정석" 대출 가능
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 5: 반납된 책 대출      │");
        System.out.println("└────────────────────────────────┘");
        library.borrowBook("M003", "B001", "2024-10-15", "2024-10-29");

        // 시나리오 6: 회원 정보 상세 보기
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 6: 회원 정보 조회      │");
        System.out.println("└────────────────────────────────┘");
        Member member = library.findMemberById("M002");
        if (member != null) {
            member.displayInfo();
        }

        // 시나리오 7: 도서 정보 상세 보기
        System.out.println("\n┌────────────────────────────────┐");
        System.out.println("│ 시나리오 7: 도서 정보 조회      │");
        System.out.println("└────────────────────────────────┘");
        Book book = library.findBookById("B002");
        if (book != null) {
            book.displayInfo();
        }

        // 최종 상태
        System.out.println("\n╔════════════════════════════════════════╗");
        System.out.println("║        최종 도서관 상태               ║");
        System.out.println("╚════════════════════════════════════════╝");
        library.displayLibraryInfo();
        library.displayAllBooks();
        library.displayAllMembers();
        library.displayAllLoans();

        System.out.println("\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        System.out.println("✅ 시뮬레이션 완료!");
        System.out.println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    }
}
```

---

### 프로젝트 핵심 포인트

#### 1. 객체 지향 설계
- **Book**: 도서 정보와 대출 상태 관리
- **Member**: 회원 정보와 대출 가능 여부 관리
- **Loan**: 대출 기록 관리
- **Library**: 전체 시스템 조율

#### 2. 클래스 간 협력
```java
// Library가 다른 클래스들을 조합
library.borrowBook()
    ├─> member.canBorrow()  // Member 객체 활용
    ├─> book.checkOut()     // Book 객체 활용
    └─> new Loan()          // Loan 객체 생성
```

#### 3. 데이터 캡슐화
각 클래스가 자신의 데이터를 관리:
- Book이 대출 가능 여부 판단
- Member가 대출 한도 체크
- Loan이 반납 처리

#### 4. 확장 가능성
```java
// 새로운 기능 추가 예시
class Book {
    void reserve() { /* 예약 기능 */ }
}

class Member {
    void extendLoan() { /* 대출 연장 */ }
}
```

---

## 8. 핵심 요약

### 클래스와 객체의 관계

```
클래스 (Class)
├─ 설계도, 틀, 템플릿
├─ 필드: 객체의 속성 정의
├─ 메서드: 객체의 동작 정의
└─ 한 번 정의하면 여러 객체 생성 가능

객체 (Object)
├─ 클래스로부터 생성된 실체
├─ new 키워드로 생성
├─ 각 객체는 독립적인 데이터
└─ 힙(Heap) 영역에 저장
```

### 핵심 개념 체크리스트

✅ **클래스 정의**
```java
public class ClassName {
    // 필드
    타입 fieldName;

    // 메서드
    void methodName() { }
}
```

✅ **객체 생성**
```java
ClassName obj = new ClassName();
```

✅ **필드 접근**
```java
obj.fieldName = value;
```

✅ **메서드 호출**
```java
obj.methodName();
```

✅ **null 체크**
```java
if (obj != null) {
    obj.method();
}
```

✅ **객체 배열**
```java
ClassName[] arr = new ClassName[size];
for (int i = 0; i < size; i++) {
    arr[i] = new ClassName();  // 각 요소 초기화!
}
```

---

## 다음 단계

다음 장에서는 **클래스와 객체 심화편**에서 다음 내용을 학습합니다:

- **자주 묻는 질문 (FAQ 7개)**
- **면접 질문 (주니어 7개 + 중급 5개)**

---

## 학습 체크

이 장을 완료했다면:

- [ ] 클래스와 객체의 차이를 설명할 수 있다
- [ ] 클래스를 정의하고 객체를 생성할 수 있다
- [ ] 필드와 메서드를 사용할 수 있다
- [ ] null과 NullPointerException을 이해한다
- [ ] 객체 배열을 올바르게 초기화할 수 있다
- [ ] 도서관 관리 시스템을 구현하고 이해했다

**축하합니다! 객체 지향 프로그래밍의 첫 걸음을 내디뎠습니다!** 🎉
