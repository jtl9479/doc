# 29ì¥ ëŒë‹¤ í‘œí˜„ì‹ - Part 3: ì„±ëŠ¥ ìµœì í™” & ê³ ê¸‰ í™œìš©

## ğŸ“š ëª©ì°¨
1. [ëŒë‹¤ ì„±ëŠ¥ ìµœì í™”](#ì„±ëŠ¥-ìµœì í™”)
2. [ê³ ê¸‰ í™œìš© ê¸°ë²•](#ê³ ê¸‰-í™œìš©-ê¸°ë²•)
3. [ì‹¤ì „ Best Practices](#ì‹¤ì „-best-practices)
4. [ìì£¼ ë¬»ëŠ” ë©´ì ‘ ì§ˆë¬¸ TOP 10](#ë©´ì ‘-ì§ˆë¬¸)
5. [ì¢…í•© ì •ë¦¬](#ì¢…í•©-ì •ë¦¬)

---

## ğŸš€ ì„±ëŠ¥ ìµœì í™”

### ğŸ“Š ëŒë‹¤ vs ìµëª… í´ë˜ìŠ¤ vs ë©”ì„œë“œ ì°¸ì¡° ì„±ëŠ¥ ë¹„êµ

```java
package lambda.performance;

import java.util.*;
import java.util.function.Function;

/**
 * ëŒë‹¤ ì„±ëŠ¥ ë¹„êµ
 */
public class LambdaPerformanceTest {
    private static final int ITERATIONS = 10_000_000;

    public static void main(String[] args) {
        System.out.println("=== ëŒë‹¤ vs ìµëª… í´ë˜ìŠ¤ vs ë©”ì„œë“œ ì°¸ì¡° ì„±ëŠ¥ ë¹„êµ ===\n");

        List<String> testData = Arrays.asList("a", "b", "c", "d", "e");

        // 1. ìµëª… í´ë˜ìŠ¤
        long start1 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = new Function<String, String>() {
                @Override
                public String apply(String s) {
                    return s.toUpperCase();
                }
            };
            function.apply("test");
        }
        long end1 = System.nanoTime();

        // 2. ëŒë‹¤
        long start2 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = s -> s.toUpperCase();
            function.apply("test");
        }
        long end2 = System.nanoTime();

        // 3. ë©”ì„œë“œ ì°¸ì¡°
        long start3 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            Function<String, String> function = String::toUpperCase;
            function.apply("test");
        }
        long end3 = System.nanoTime();

        // 4. ëŒë‹¤ ì¬ì‚¬ìš© (ìµœì í™”)
        Function<String, String> reusableFunction = s -> s.toUpperCase();

        long start4 = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            reusableFunction.apply("test");
        }
        long end4 = System.nanoTime();

        // ê²°ê³¼ ì¶œë ¥
        System.out.println("1000ë§Œ ë²ˆ ì‹¤í–‰ ê²°ê³¼:");
        System.out.println("1. ìµëª… í´ë˜ìŠ¤: " + String.format("%.2f", (end1 - start1) / 1_000_000.0) + "ms");
        System.out.println("2. ëŒë‹¤: " + String.format("%.2f", (end2 - start2) / 1_000_000.0) + "ms");
        System.out.println("3. ë©”ì„œë“œ ì°¸ì¡°: " + String.format("%.2f", (end3 - start3) / 1_000_000.0) + "ms");
        System.out.println("4. ëŒë‹¤ ì¬ì‚¬ìš©: " + String.format("%.2f", (end4 - start4) / 1_000_000.0) + "ms");

        System.out.println("\nğŸ“Š ê²°ë¡ :");
        System.out.println("- ëŒë‹¤ ì¬ì‚¬ìš©ì´ ê°€ì¥ ë¹ ë¦„");
        System.out.println("- ë©”ì„œë“œ ì°¸ì¡° â‰ˆ ëŒë‹¤");
        System.out.println("- ìµëª… í´ë˜ìŠ¤ê°€ ê°€ì¥ ëŠë¦¼");
        System.out.println();

        // Stream ì„±ëŠ¥ ë¹„êµ
        System.out.println("=== Stream ì²˜ë¦¬ ì„±ëŠ¥ ===\n");

        List<Integer> numbers = new ArrayList<>();
        for (int i = 0; i < 1_000_000; i++) {
            numbers.add(i);
        }

        // forë¬¸
        long startFor = System.nanoTime();
        int sumFor = 0;
        for (int n : numbers) {
            if (n % 2 == 0) {
                sumFor += n;
            }
        }
        long endFor = System.nanoTime();

        // Stream (ëŒë‹¤)
        long startStream = System.nanoTime();
        int sumStream = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToInt(Integer::intValue)
            .sum();
        long endStream = System.nanoTime();

        // Parallel Stream
        long startParallel = System.nanoTime();
        int sumParallel = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .mapToInt(Integer::intValue)
            .sum();
        long endParallel = System.nanoTime();

        System.out.println("100ë§Œ ê°œ ì§ìˆ˜ í•©ê³„:");
        System.out.println("forë¬¸: " + String.format("%.2f", (endFor - startFor) / 1_000_000.0) + "ms");
        System.out.println("Stream: " + String.format("%.2f", (endStream - startStream) / 1_000_000.0) + "ms");
        System.out.println("Parallel Stream: " + String.format("%.2f", (endParallel - startParallel) / 1_000_000.0) + "ms");

        System.out.println("\nğŸ“Š ì„±ëŠ¥ íŒ:");
        System.out.println("âœ… ëŒë‹¤ëŠ” ë§¤ë²ˆ ìƒì„±í•˜ì§€ ë§ê³  ì¬ì‚¬ìš©");
        System.out.println("âœ… ì†ŒëŸ‰ ë°ì´í„°ëŠ” forë¬¸ì´ ë¹ ë¦„");
        System.out.println("âœ… ëŒ€ëŸ‰ ë°ì´í„°ëŠ” Parallel Stream ê³ ë ¤");
        System.out.println("âœ… ë©”ì„œë“œ ì°¸ì¡° > ëŒë‹¤ > ìµëª… í´ë˜ìŠ¤");
    }
}
```

### ğŸ¯ í•µì‹¬ í¬ì¸íŠ¸

**1. ëŒë‹¤ ì¬ì‚¬ìš©**:
```java
// âŒ ë‚˜ìœ ì˜ˆ: ë§¤ë²ˆ ëŒë‹¤ ìƒì„±
for (int i = 0; i < 1000000; i++) {
    Function<String, String> f = s -> s.toUpperCase();  // ë§¤ë²ˆ ìƒì„±!
    f.apply("test");
}

// âœ… ì¢‹ì€ ì˜ˆ: í•œ ë²ˆ ìƒì„±í•˜ì—¬ ì¬ì‚¬ìš©
Function<String, String> f = s -> s.toUpperCase();  // í•œ ë²ˆë§Œ ìƒì„±
for (int i = 0; i < 1000000; i++) {
    f.apply("test");
}
```

**2. ë©”ì„œë“œ ì°¸ì¡° ìš°ì„ **:
```java
// ëŒë‹¤
list.stream().map(s -> s.toUpperCase())

// ë©”ì„œë“œ ì°¸ì¡° (ë” ë¹ ë¥´ê³  ê°„ê²°)
list.stream().map(String::toUpperCase)
```

---

### ğŸ“Š ëŒë‹¤ ë©”ëª¨ë¦¬ ì‚¬ìš©

```java
package lambda.performance;

/**
 * ëŒë‹¤ ë©”ëª¨ë¦¬ ë¶„ì„
 */
public class LambdaMemoryTest {
    public static void main(String[] args) {
        System.out.println("=== ëŒë‹¤ ë©”ëª¨ë¦¬ ì‚¬ìš© ë¶„ì„ ===\n");

        Runtime runtime = Runtime.getRuntime();

        // GC ì‹¤í–‰
        System.gc();
        long beforeMemory = runtime.totalMemory() - runtime.freeMemory();

        // 1. ìµëª… í´ë˜ìŠ¤ 100,000ê°œ ìƒì„±
        Runnable[] anonymousClasses = new Runnable[100000];
        for (int i = 0; i < 100000; i++) {
            final int index = i;
            anonymousClasses[i] = new Runnable() {
                @Override
                public void run() {
                    System.out.println("Run " + index);
                }
            };
        }

        System.gc();
        long afterAnonymous = runtime.totalMemory() - runtime.freeMemory();
        long anonymousMemory = afterAnonymous - beforeMemory;

        // 2. ëŒë‹¤ 100,000ê°œ ìƒì„±
        Runnable[] lambdas = new Runnable[100000];
        for (int i = 0; i < 100000; i++) {
            final int index = i;
            lambdas[i] = () -> System.out.println("Run " + index);
        }

        System.gc();
        long afterLambda = runtime.totalMemory() - runtime.freeMemory();
        long lambdaMemory = afterLambda - afterAnonymous;

        System.out.println("ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ (100,000ê°œ):");
        System.out.println("ìµëª… í´ë˜ìŠ¤: " + String.format("%.2f", anonymousMemory / 1024.0 / 1024.0) + "MB");
        System.out.println("ëŒë‹¤: " + String.format("%.2f", lambdaMemory / 1024.0 / 1024.0) + "MB");

        System.out.println("\nğŸ“Š ëŒë‹¤ê°€ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ì¸ ì´ìœ :");
        System.out.println("- invokedynamic ëª…ë ¹ì–´ ì‚¬ìš©");
        System.out.println("- ì»´íŒŒì¼ íƒ€ì„ì— í´ë˜ìŠ¤ ìƒì„± ì•ˆ í•¨");
        System.out.println("- ëŸ°íƒ€ì„ì— ë™ì ìœ¼ë¡œ ì—°ê²°");
    }
}
```

---

## ğŸ’ ê³ ê¸‰ í™œìš© ê¸°ë²•

### ğŸ”· ê¸°ë²• 1: ì»¤ë§(Currying)ê³¼ ë¶€ë¶„ ì ìš©

```java
package lambda.advanced;

import java.util.function.Function;

/**
 * ì»¤ë§ (Currying)
 */
public class CurryingDemo {
    public static void main(String[] args) {
        System.out.println("=== ì»¤ë§ (Currying) ===\n");

        // ì¼ë°˜ì ì¸ ë°©ì‹: ëª¨ë“  ë§¤ê°œë³€ìˆ˜ë¥¼ í•œ ë²ˆì— ì „ë‹¬
        int result1 = add(10, 20, 30);
        System.out.println("ì¼ë°˜ ë°©ì‹: add(10, 20, 30) = " + result1);
        System.out.println();

        // ì»¤ë§ ë°©ì‹: ë§¤ê°œë³€ìˆ˜ë¥¼ í•˜ë‚˜ì”© ì „ë‹¬
        Function<Integer, Function<Integer, Function<Integer, Integer>>> curriedAdd =
            a -> b -> c -> a + b + c;

        // ë‹¨ê³„ì ìœ¼ë¡œ ì ìš©
        Function<Integer, Function<Integer, Integer>> step1 = curriedAdd.apply(10);
        Function<Integer, Integer> step2 = step1.apply(20);
        int result2 = step2.apply(30);

        System.out.println("ì»¤ë§ ë°©ì‹:");
        System.out.println("step1 = curriedAdd.apply(10)");
        System.out.println("step2 = step1.apply(20)");
        System.out.println("result = step2.apply(30) = " + result2);
        System.out.println();

        // ë¶€ë¶„ ì ìš© (Partial Application)
        System.out.println("=== ë¶€ë¶„ ì ìš© ===\n");

        // ì¼ë¶€ ë§¤ê°œë³€ìˆ˜ë§Œ ê³ ì •
        Function<Integer, Function<Integer, Integer>> addTo10 = curriedAdd.apply(10);

        int result3 = addTo10.apply(5).apply(3);
        int result4 = addTo10.apply(2).apply(8);

        System.out.println("addTo10 = curriedAdd.apply(10)");
        System.out.println("addTo10.apply(5).apply(3) = " + result3);
        System.out.println("addTo10.apply(2).apply(8) = " + result4);
        System.out.println();

        // ì‹¤ìš© ì˜ˆì‹œ: ë¡œê±° ì„¤ì •
        System.out.println("=== ì‹¤ìš© ì˜ˆì‹œ: ë¡œê±° ===\n");

        // ë¡œê±° íŒ©í† ë¦¬
        Function<String, Function<String, String>> loggerFactory =
            level -> message -> "[" + level + "] " + message;

        // ë ˆë²¨ë³„ ë¡œê±° ìƒì„±
        Function<String, String> infoLogger = loggerFactory.apply("INFO");
        Function<String, String> errorLogger = loggerFactory.apply("ERROR");

        System.out.println(infoLogger.apply("ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘"));
        System.out.println(infoLogger.apply("ë°ì´í„° ë¡œë“œ ì™„ë£Œ"));
        System.out.println(errorLogger.apply("íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ"));
        System.out.println();

        // ì‹¤ìš© ì˜ˆì‹œ: í• ì¸ ê³„ì‚°ê¸°
        System.out.println("=== ì‹¤ìš© ì˜ˆì‹œ: í• ì¸ ê³„ì‚°ê¸° ===\n");

        // í• ì¸ìœ¨ â†’ ì›ê°€ â†’ ìµœì¢… ê°€ê²©
        Function<Double, Function<Integer, Integer>> discountCalculator =
            rate -> price -> (int) (price * (1 - rate));

        // í• ì¸ìœ¨ë³„ ê³„ì‚°ê¸°
        Function<Integer, Integer> discount10 = discountCalculator.apply(0.1);  // 10% í• ì¸
        Function<Integer, Integer> discount20 = discountCalculator.apply(0.2);  // 20% í• ì¸

        System.out.println("ì›ê°€ 10,000ì›:");
        System.out.println("  10% í• ì¸: " + discount10.apply(10000) + "ì›");
        System.out.println("  20% í• ì¸: " + discount20.apply(10000) + "ì›");
    }

    static int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

---

### ğŸ”· ê¸°ë²• 2: í•¨ìˆ˜ í•©ì„± (Function Composition)

```java
package lambda.advanced;

import java.util.function.Function;

/**
 * í•¨ìˆ˜ í•©ì„±
 */
public class FunctionCompositionDemo {
    public static void main(String[] args) {
        System.out.println("=== í•¨ìˆ˜ í•©ì„± (Function Composition) ===\n");

        // ê¸°ë³¸ í•¨ìˆ˜ë“¤
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, String> addExclamation = s -> s + "!!!";

        // andThen: f.andThen(g) = g(f(x))
        Function<String, String> process1 = trim
            .andThen(upperCase)
            .andThen(addExclamation);

        String result1 = process1.apply("  hello world  ");
        System.out.println("andThen ì²´ì¸:");
        System.out.println("  ì…ë ¥: '  hello world  '");
        System.out.println("  ì¶œë ¥: '" + result1 + "'");
        System.out.println("  â†’ trim â†’ upperCase â†’ addExclamation");
        System.out.println();

        // compose: f.compose(g) = f(g(x))
        Function<String, String> process2 = addExclamation
            .compose(upperCase)
            .compose(trim);

        String result2 = process2.apply("  hello world  ");
        System.out.println("compose ì²´ì¸:");
        System.out.println("  ì…ë ¥: '  hello world  '");
        System.out.println("  ì¶œë ¥: '" + result2 + "'");
        System.out.println("  â†’ trim â†’ upperCase â†’ addExclamation");
        System.out.println();

        // ì‹¤ìš© ì˜ˆì‹œ: ë°ì´í„° ì •ì œ íŒŒì´í”„ë¼ì¸
        System.out.println("=== ì‹¤ìš© ì˜ˆì‹œ: ë°ì´í„° ì •ì œ íŒŒì´í”„ë¼ì¸ ===\n");

        Function<String, String> removeSpecialChars = s -> s.replaceAll("[^a-zA-Z0-9\\s]", "");
        Function<String, String> normalizeSpaces = s -> s.replaceAll("\\s+", " ");
        Function<String, String> trimSpaces = String::trim;
        Function<String, String> toLowerCase = String::toLowerCase;

        Function<String, String> cleanupPipeline = trimSpaces
            .andThen(removeSpecialChars)
            .andThen(normalizeSpaces)
            .andThen(toLowerCase);

        String dirty = "  Hello!!!   @World###   123   ";
        String clean = cleanupPipeline.apply(dirty);

        System.out.println("ì›ë³¸: '" + dirty + "'");
        System.out.println("ì •ì œ: '" + clean + "'");
        System.out.println();

        // ì‹¤ìš© ì˜ˆì‹œ: ê°€ê²© ê³„ì‚° íŒŒì´í”„ë¼ì¸
        System.out.println("=== ì‹¤ìš© ì˜ˆì‹œ: ê°€ê²© ê³„ì‚° íŒŒì´í”„ë¼ì¸ ===\n");

        Function<Integer, Integer> applyDiscount = price -> (int) (price * 0.9);  // 10% í• ì¸
        Function<Integer, Integer> applyTax = price -> (int) (price * 1.1);       // 10% ì„¸ê¸ˆ
        Function<Integer, Integer> applyShipping = price -> price + 3000;         // ë°°ì†¡ë¹„

        Function<Integer, Integer> finalPrice = applyDiscount
            .andThen(applyTax)
            .andThen(applyShipping);

        int originalPrice = 10000;
        int calculated = finalPrice.apply(originalPrice);

        System.out.println("ì›ê°€: " + originalPrice + "ì›");
        System.out.println("ìµœì¢… ê°€ê²©: " + calculated + "ì›");
        System.out.println("â†’ í• ì¸ 10% â†’ ì„¸ê¸ˆ 10% â†’ ë°°ì†¡ë¹„ 3,000ì›");
    }
}
```

---

### ğŸ”· ê¸°ë²• 3: ë©”ëª¨ì´ì œì´ì…˜ (Memoization)

```java
package lambda.advanced;

import java.util.*;
import java.util.function.Function;

/**
 * ë©”ëª¨ì´ì œì´ì…˜ (Memoization)
 * í•¨ìˆ˜ í˜¸ì¶œ ê²°ê³¼ë¥¼ ìºì‹±í•˜ì—¬ ì„±ëŠ¥ í–¥ìƒ
 */
public class MemoizationDemo {
    public static void main(String[] args) {
        System.out.println("=== ë©”ëª¨ì´ì œì´ì…˜ (Memoization) ===\n");

        // ì‹œë‚˜ë¦¬ì˜¤ 1: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ (ë©”ëª¨ì´ì œì´ì…˜ ì—†ìŒ)
        System.out.println("ğŸ“ ë©”ëª¨ì´ì œì´ì…˜ ì—†ìŒ (í”¼ë³´ë‚˜ì¹˜):");

        long start1 = System.nanoTime();
        int fib40 = fibonacci(40);
        long end1 = System.nanoTime();

        System.out.println("fibonacci(40) = " + fib40);
        System.out.println("ì†Œìš” ì‹œê°„: " + String.format("%.2f", (end1 - start1) / 1_000_000.0) + "ms");
        System.out.println("â†’ ì¤‘ë³µ ê³„ì‚° ë§ìŒ (ë§¤ìš° ëŠë¦¼)");
        System.out.println();

        // ì‹œë‚˜ë¦¬ì˜¤ 2: í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ (ë©”ëª¨ì´ì œì´ì…˜ ì ìš©)
        System.out.println("ğŸ“ ë©”ëª¨ì´ì œì´ì…˜ ì ìš©:");

        Function<Integer, Integer> memoizedFib = memoize(MemoizationDemo::fibonacci);

        long start2 = System.nanoTime();
        int memoFib40 = memoizedFib.apply(40);
        long end2 = System.nanoTime();

        System.out.println("memoizedFib(40) = " + memoFib40);
        System.out.println("ì†Œìš” ì‹œê°„: " + String.format("%.2f", (end2 - start2) / 1_000_000.0) + "ms");
        System.out.println("â†’ ì¤‘ë³µ ê³„ì‚° ì œê±° (ë§¤ìš° ë¹ ë¦„)");
        System.out.println();

        // ì¬í˜¸ì¶œ ì‹œ ìºì‹œ ì‚¬ìš©
        long start3 = System.nanoTime();
        memoizedFib.apply(40);  // ìºì‹œëœ ê²°ê³¼ ì‚¬ìš©
        long end3 = System.nanoTime();

        System.out.println("ì¬í˜¸ì¶œ ì‹œê°„: " + String.format("%.3f", (end3 - start3) / 1000.0) + "Î¼s");
        System.out.println("â†’ ìºì‹œì—ì„œ ì¦‰ì‹œ ë°˜í™˜");
        System.out.println();

        // ì‹¤ìš© ì˜ˆì‹œ: DB ì¡°íšŒ ìºì‹±
        System.out.println("=== ì‹¤ìš© ì˜ˆì‹œ: DB ì¡°íšŒ ìºì‹± ===\n");

        Function<String, User> findUser = userId -> {
            System.out.println("  [DB ì¡°íšŒ] userId: " + userId);
            // ì‹œë®¬ë ˆì´ì…˜: DB ì¡°íšŒëŠ” ëŠë¦¼
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return new User(userId, "User " + userId);
        };

        Function<String, User> cachedFindUser = memoize(findUser);

        System.out.println("ì²« ë²ˆì§¸ ì¡°íšŒ:");
        long startDb1 = System.currentTimeMillis();
        User user1 = cachedFindUser.apply("USER001");
        long endDb1 = System.currentTimeMillis();
        System.out.println("  ê²°ê³¼: " + user1);
        System.out.println("  ì†Œìš” ì‹œê°„: " + (endDb1 - startDb1) + "ms");
        System.out.println();

        System.out.println("ë‘ ë²ˆì§¸ ì¡°íšŒ (ê°™ì€ ì‚¬ìš©ì):");
        long startDb2 = System.currentTimeMillis();
        User user2 = cachedFindUser.apply("USER001");
        long endDb2 = System.currentTimeMillis();
        System.out.println("  ê²°ê³¼: " + user2);
        System.out.println("  ì†Œìš” ì‹œê°„: " + (endDb2 - startDb2) + "ms");
        System.out.println("  â†’ ìºì‹œ ì‚¬ìš©, DB ì¡°íšŒ ì•ˆ í•¨");
    }

    /**
     * í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´ (ì¬ê·€)
     */
    static int fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    /**
     * ë©”ëª¨ì´ì œì´ì…˜ ë˜í¼
     */
    static <T, R> Function<T, R> memoize(Function<T, R> function) {
        Map<T, R> cache = new HashMap<>();

        return input -> cache.computeIfAbsent(input, function);
    }

    /**
     * ì‚¬ìš©ì í´ë˜ìŠ¤
     */
    static class User {
        String id;
        String name;

        User(String id, String name) {
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "User{id='" + id + "', name='" + name + "'}";
        }
    }
}
```

---

## ğŸ¯ ì‹¤ì „ Best Practices

### âœ… 1. ëŒë‹¤ ê°€ë…ì„± í–¥ìƒ

```java
package lambda.bestpractices;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * ëŒë‹¤ ê°€ë…ì„± í–¥ìƒ ê¸°ë²•
 */
public class ReadabilityDemo {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("ë…¸íŠ¸ë¶", 1500000, true),
            new Product("ë§ˆìš°ìŠ¤", 30000, false),
            new Product("í‚¤ë³´ë“œ", 80000, true),
            new Product("ëª¨ë‹ˆí„°", 500000, false)
        );

        System.out.println("=== ëŒë‹¤ ê°€ë…ì„± í–¥ìƒ ===\n");

        // âŒ ë‚˜ìœ ì˜ˆ: ë³µì¡í•œ ëŒë‹¤ë¥¼ ì¸ë¼ì¸ìœ¼ë¡œ
        List<Product> result1 = products.stream()
            .filter(p -> p.getPrice() > 50000 && p.isAvailable() && p.getName().length() > 3)
            .collect(Collectors.toList());

        // âœ… ì¢‹ì€ ì˜ˆ 1: Predicateë¡œ ì¶”ì¶œ
        Predicate<Product> isExpensive = p -> p.getPrice() > 50000;
        Predicate<Product> isAvailable = Product::isAvailable;
        Predicate<Product> hasLongName = p -> p.getName().length() > 3;

        List<Product> result2 = products.stream()
            .filter(isExpensive.and(isAvailable).and(hasLongName))
            .collect(Collectors.toList());

        System.out.println("Predicate ì¶”ì¶œ:");
        result2.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // âœ… ì¢‹ì€ ì˜ˆ 2: ëª…ëª…ëœ ë©”ì„œë“œë¡œ ì¶”ì¶œ
        List<Product> result3 = products.stream()
            .filter(ReadabilityDemo::isPremiumProduct)
            .collect(Collectors.toList());

        System.out.println("ë©”ì„œë“œ ì¶”ì¶œ:");
        result3.forEach(p -> System.out.println("  " + p));
        System.out.println();

        // âœ… ì¢‹ì€ ì˜ˆ 3: ë³µì¡í•œ ë¡œì§ì€ ë³„ë„ ë©”ì„œë“œë¡œ
        List<Product> result4 = products.stream()
            .map(ReadabilityDemo::applyDiscount)
            .collect(Collectors.toList());

        System.out.println("ë³µì¡í•œ ë³€í™˜ ë¡œì§ ì¶”ì¶œ:");
        result4.forEach(p -> System.out.println("  " + p));
    }

    /**
     * í”„ë¦¬ë¯¸ì—„ ìƒí’ˆ íŒë³„
     */
    static boolean isPremiumProduct(Product product) {
        return product.getPrice() > 50000
            && product.isAvailable()
            && product.getName().length() > 3;
    }

    /**
     * í• ì¸ ì ìš©
     */
    static Product applyDiscount(Product product) {
        if (product.getPrice() > 100000) {
            return new Product(
                product.getName(),
                (int) (product.getPrice() * 0.9),  // 10% í• ì¸
                product.isAvailable()
            );
        }
        return product;
    }

    static class Product {
        String name;
        int price;
        boolean available;

        Product(String name, int price, boolean available) {
            this.name = name;
            this.price = price;
            this.available = available;
        }

        String getName() { return name; }
        int getPrice() { return price; }
        boolean isAvailable() { return available; }

        @Override
        public String toString() {
            return name + " - " + String.format("%,d", price) + "ì›";
        }
    }
}
```

---

### âœ… 2. ëŒë‹¤ ë””ë²„ê¹…

```java
package lambda.bestpractices;

import java.util.*;
import java.util.stream.Collectors;

/**
 * ëŒë‹¤ ë””ë²„ê¹… ê¸°ë²•
 */
public class DebuggingDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        System.out.println("=== ëŒë‹¤ ë””ë²„ê¹… ===\n");

        // âŒ ë””ë²„ê¹… ì–´ë ¤ì›€
        List<Integer> result1 = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * 2)
            .collect(Collectors.toList());

        // âœ… peek()ìœ¼ë¡œ ì¤‘ê°„ ê°’ í™•ì¸
        System.out.println("peek()ìœ¼ë¡œ ë””ë²„ê¹…:");
        List<Integer> result2 = numbers.stream()
            .peek(n -> System.out.println("  ì›ë³¸: " + n))
            .filter(n -> n % 2 == 0)
            .peek(n -> System.out.println("  í•„í„° í›„: " + n))
            .map(n -> n * 2)
            .peek(n -> System.out.println("  ë³€í™˜ í›„: " + n))
            .collect(Collectors.toList());

        System.out.println("ìµœì¢… ê²°ê³¼: " + result2);
        System.out.println();

        // âœ… ë¡œê·¸ ë˜í¼ ì‚¬ìš©
        System.out.println("ë¡œê·¸ ë˜í¼ ì‚¬ìš©:");
        List<Integer> result3 = numbers.stream()
            .filter(logFilter(n -> n % 2 == 0, "ì§ìˆ˜ í•„í„°"))
            .map(logMap(n -> n * 2, "2ë°° ë³€í™˜"))
            .collect(Collectors.toList());

        System.out.println("ìµœì¢… ê²°ê³¼: " + result3);
    }

    /**
     * í•„í„° ë¡œê¹… ë˜í¼
     */
    static <T> java.util.function.Predicate<T> logFilter(
        java.util.function.Predicate<T> predicate,
        String description
    ) {
        return value -> {
            boolean result = predicate.test(value);
            System.out.println("  [" + description + "] " + value + " â†’ " + result);
            return result;
        };
    }

    /**
     * ë³€í™˜ ë¡œê¹… ë˜í¼
     */
    static <T, R> java.util.function.Function<T, R> logMap(
        java.util.function.Function<T, R> function,
        String description
    ) {
        return value -> {
            R result = function.apply(value);
            System.out.println("  [" + description + "] " + value + " â†’ " + result);
            return result;
        };
    }
}
```

---

## ğŸ¤ ë©´ì ‘ ì§ˆë¬¸

### â“ Q1. ëŒë‹¤ í‘œí˜„ì‹ì´ë€ ë¬´ì—‡ì¸ê°€?

**ë‹µë³€**:
```
ëŒë‹¤ í‘œí˜„ì‹ì€ ë©”ì„œë“œë¥¼ í•˜ë‚˜ì˜ ì‹ìœ¼ë¡œ í‘œí˜„í•œ ìµëª… í•¨ìˆ˜ì…ë‹ˆë‹¤.

íŠ¹ì§•:
1. ê°„ê²°í•œ ë¬¸ë²•: (ë§¤ê°œë³€ìˆ˜) -> { ì‹¤í–‰ë¬¸ }
2. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì—ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
3. ì»´íŒŒì¼ëŸ¬ê°€ íƒ€ì… ì¶”ë¡ 

ì˜ˆì‹œ:
// ìµëª… í´ë˜ìŠ¤
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Hello");
    }
};

// ëŒë‹¤
Runnable r2 = () -> System.out.println("Hello");

ì¥ì :
- ì½”ë“œ ê°„ê²°ì„±
- ê°€ë…ì„± í–¥ìƒ
- í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë° ì§€ì›
```

---

### â“ Q2. í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë€?

**ë‹µë³€**:
```
ì¶”ìƒ ë©”ì„œë“œê°€ ì •í™•íˆ 1ê°œì¸ ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.

ì¡°ê±´:
- ì¶”ìƒ ë©”ì„œë“œ 1ê°œ (í•„ìˆ˜)
- default ë©”ì„œë“œ ì—¬ëŸ¬ ê°œ ê°€ëŠ¥
- static ë©”ì„œë“œ ì—¬ëŸ¬ ê°œ ê°€ëŠ¥

@FunctionalInterface ì• ë…¸í…Œì´ì…˜:
- ì»´íŒŒì¼ëŸ¬ê°€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ ê²€ì¦
- ì¶”ìƒ ë©”ì„œë“œê°€ 2ê°œ ì´ìƒì´ë©´ ì»´íŒŒì¼ ì—ëŸ¬

ì˜ˆì‹œ:
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // ì¶”ìƒ ë©”ì„œë“œ 1ê°œ

    default void print() { }      // default ë©”ì„œë“œ OK
    static void log() { }         // static ë©”ì„œë“œ OK
}

ì£¼ìš” í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ (java.util.function):
- Predicate<T>: T â†’ boolean
- Function<T, R>: T â†’ R
- Consumer<T>: T â†’ void
- Supplier<T>: () â†’ T
```

---

### â“ Q3. ëŒë‹¤ì—ì„œ ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìˆ˜ì •í•  ìˆ˜ ì—†ëŠ” ì´ìœ ëŠ”?

**ë‹µë³€**:
```
ëŒë‹¤ëŠ” ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ìº¡ì²˜í•  ë•Œ ê°’ì„ ë³µì‚¬í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

effectively final ê·œì¹™:
- ëŒë‹¤ì—ì„œ ì ‘ê·¼í•˜ëŠ” ì™¸ë¶€ ë³€ìˆ˜ëŠ” finalì´ê±°ë‚˜ ì‚¬ì‹¤ìƒ finalì´ì–´ì•¼ í•¨
- ê°’ì´ ë³€ê²½ë˜ë©´ ì»´íŒŒì¼ ì—ëŸ¬

ì´ìœ :
1. ë©€í‹°ìŠ¤ë ˆë“œ ì•ˆì „ì„±
   - ëŒë‹¤ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë  ìˆ˜ ìˆìŒ
   - ë³€ìˆ˜ ë³€ê²½ ì‹œ ë™ê¸°í™” ë¬¸ì œ ë°œìƒ

2. ì‹œê°„ì  ë¶„ë¦¬
   - ëŒë‹¤ëŠ” ë‚˜ì¤‘ì— ì‹¤í–‰ë  ìˆ˜ ìˆìŒ
   - ë³€ìˆ˜ê°€ ì´ë¯¸ ì‚¬ë¼ì¡Œì„ ìˆ˜ ìˆìŒ

3. ê°’ ìº¡ì²˜
   - ëŒë‹¤ëŠ” ë³€ìˆ˜ì˜ ë³µì‚¬ë³¸ì„ ê°€ì§
   - ì›ë³¸ ë³€ê²½ì´ ëŒë‹¤ì— ë°˜ì˜ ì•ˆ ë¨

í•´ê²°ì±…:
- AtomicInteger ì‚¬ìš©
- ë°°ì—´ ì‚¬ìš© (íŠ¸ë¦­)
- Streamì˜ reduce ì‚¬ìš© (ê¶Œì¥)
```

---

### â“ Q4. ë©”ì„œë“œ ì°¸ì¡°ì˜ ì¢…ë¥˜ëŠ”?

**ë‹µë³€**:
```
ë©”ì„œë“œ ì°¸ì¡°ëŠ” ëŒë‹¤ë¥¼ ë” ê°„ê²°í•˜ê²Œ í‘œí˜„í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤.

4ê°€ì§€ ì¢…ë¥˜:

1. ì •ì  ë©”ì„œë“œ ì°¸ì¡°
   ClassName::staticMethod
   ì˜ˆ: Math::abs
   ëŒë‹¤: x -> Math.abs(x)

2. ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ ì°¸ì¡° (íŠ¹ì • ê°ì²´)
   instance::instanceMethod
   ì˜ˆ: str::length
   ëŒë‹¤: () -> str.length()

3. ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œ ì°¸ì¡° (ì„ì˜ ê°ì²´)
   ClassName::instanceMethod
   ì˜ˆ: String::toUpperCase
   ëŒë‹¤: s -> s.toUpperCase()

4. ìƒì„±ì ì°¸ì¡°
   ClassName::new
   ì˜ˆ: ArrayList::new
   ëŒë‹¤: () -> new ArrayList<>()

ë©”ì„œë“œ ì°¸ì¡° vs ëŒë‹¤:
- ë©”ì„œë“œ ì°¸ì¡°ê°€ ë” ê°„ê²°í•˜ê³  ëª…í™•
- ë‹¨ìˆœ ë©”ì„œë“œ í˜¸ì¶œì€ ë©”ì„œë“œ ì°¸ì¡° ì‚¬ìš© ê¶Œì¥
```

---

### â“ Q5. ëŒë‹¤ì™€ ìµëª… í´ë˜ìŠ¤ì˜ ì°¨ì´ëŠ”?

**ë‹µë³€**:
```
1. this ì°¸ì¡°:
   ìµëª… í´ë˜ìŠ¤: thisëŠ” ìµëª… í´ë˜ìŠ¤ ìì²´
   ëŒë‹¤: thisëŠ” ì™¸ë¶€ í´ë˜ìŠ¤

2. ì‚¬ìš© ê°€ëŠ¥ ë²”ìœ„:
   ìµëª… í´ë˜ìŠ¤: ëª¨ë“  ì¸í„°í˜ì´ìŠ¤/ì¶”ìƒ í´ë˜ìŠ¤
   ëŒë‹¤: í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë§Œ

3. ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜:
   ìµëª… í´ë˜ìŠ¤: ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ ì„ ì–¸ ê°€ëŠ¥
   ëŒë‹¤: ë¶ˆê°€

4. ì»´íŒŒì¼:
   ìµëª… í´ë˜ìŠ¤: .class íŒŒì¼ ìƒì„± (OuterClass$1.class)
   ëŒë‹¤: invokedynamic ì‚¬ìš©, ë³„ë„ í´ë˜ìŠ¤ ìƒì„± ì•ˆ í•¨

5. ì„±ëŠ¥:
   ëŒë‹¤ê°€ ìµëª… í´ë˜ìŠ¤ë³´ë‹¤ ì•½ê°„ ë¹ ë¦„

6. ë©”ëª¨ë¦¬:
   ëŒë‹¤ê°€ ë” íš¨ìœ¨ì 

ì–¸ì œ ì‚¬ìš©?
- í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤: ëŒë‹¤ (ê¶Œì¥)
- ë³µì¡í•œ ë¡œì§, ì—¬ëŸ¬ ë©”ì„œë“œ: ìµëª… í´ë˜ìŠ¤
- ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ í•„ìš”: ìµëª… í´ë˜ìŠ¤
```

---

### â“ Q6. Predicate, Function, Consumerì˜ ì°¨ì´ëŠ”?

**ë‹µë³€**:
```
í‘œì¤€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ì˜ ëŒ€í‘œì ì¸ 3ê°€ì§€:

1. Predicate<T>
   - ì‹œê·¸ë‹ˆì²˜: T â†’ boolean
   - ë©”ì„œë“œ: boolean test(T t)
   - ìš©ë„: ì¡°ê±´ ê²€ì‚¬
   - ì˜ˆì‹œ: x -> x > 10

2. Function<T, R>
   - ì‹œê·¸ë‹ˆì²˜: T â†’ R
   - ë©”ì„œë“œ: R apply(T t)
   - ìš©ë„: ë³€í™˜
   - ì˜ˆì‹œ: s -> s.length()

3. Consumer<T>
   - ì‹œê·¸ë‹ˆì²˜: T â†’ void
   - ë©”ì„œë“œ: void accept(T t)
   - ìš©ë„: ì†Œë¹„ (ì¶œë ¥, ì €ì¥ ë“±)
   - ì˜ˆì‹œ: s -> System.out.println(s)

4. Supplier<T>
   - ì‹œê·¸ë‹ˆì²˜: () â†’ T
   - ë©”ì„œë“œ: T get()
   - ìš©ë„: ê³µê¸‰ (ìƒì„±)
   - ì˜ˆì‹œ: () -> new ArrayList<>()

í™œìš©:
list.stream()
    .filter(predicate)      // Predicate
    .map(function)          // Function
    .forEach(consumer);     // Consumer
```

---

### â“ Q7. ëŒë‹¤ì—ì„œ ì²´í¬ ì˜ˆì™¸ë¥¼ ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë‚˜?

**ë‹µë³€**:
```
í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ëŠ” ì²´í¬ ì˜ˆì™¸ë¥¼ ë˜ì§€ì§€ ì•Šìœ¼ë¯€ë¡œ ë³„ë„ ì²˜ë¦¬ í•„ìš”

ë°©ë²• 1: try-catchë¡œ ê°ì‹¸ê¸°
list.forEach(item -> {
    try {
        riskyOperation(item);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
});

ë°©ë²• 2: ë˜í¼ ë©”ì„œë“œ ì‚¬ìš© (ê¶Œì¥)
public static <T> Consumer<T> wrap(ThrowingConsumer<T> consumer) {
    return t -> {
        try {
            consumer.accept(t);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    };
}

@FunctionalInterface
interface ThrowingConsumer<T> {
    void accept(T t) throws Exception;
}

// ì‚¬ìš©
list.forEach(wrap(item -> riskyOperation(item)));

ë°©ë²• 3: ì»¤ìŠ¤í…€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤
@FunctionalInterface
interface CheckedFunction<T, R> {
    R apply(T t) throws Exception;
}
```

---

### â“ Q8. ëŒë‹¤ ìº¡ì²˜ë§(Capturing)ì´ë€?

**ë‹µë³€**:
```
ëŒë‹¤ê°€ ì™¸ë¶€ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ìº¡ì²˜ë§ì´ë¼ê³  í•©ë‹ˆë‹¤.

ìº¡ì²˜ ë°©ì‹:
- ê°’ ìº¡ì²˜: ì™¸ë¶€ ë³€ìˆ˜ì˜ ê°’ì„ ë³µì‚¬
- ì°¸ì¡° ìº¡ì²˜ ì—†ìŒ (C++ì™€ ë‹¤ë¦„)

ì œì•½ ì‚¬í•­:
1. effectively finalë§Œ ìº¡ì²˜ ê°€ëŠ¥
2. ì§€ì—­ ë³€ìˆ˜ë§Œ ìº¡ì²˜ (ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ” ì œì™¸)

ì˜ˆì‹œ:
int x = 10;  // effectively final

Runnable r = () -> System.out.println(x);  // ìº¡ì²˜ OK

// x = 20;  // ì»´íŒŒì¼ ì—ëŸ¬! effectively final ìœ„ë°˜

ì´ìœ :
- ëŒë‹¤ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë  ìˆ˜ ìˆìŒ
- ë³€ìˆ˜ê°€ ìŠ¤íƒì—ì„œ ì‚¬ë¼ì§ˆ ìˆ˜ ìˆìŒ
- ê°’ì„ ë³µì‚¬í•˜ì—¬ í™ì— ì €ì¥

ì¸ìŠ¤í„´ìŠ¤ ë³€ìˆ˜ëŠ”?
- ìº¡ì²˜ ì œì•½ ì—†ìŒ
- thisë¥¼ í†µí•´ ì ‘ê·¼
- ê°ì²´ê°€ ì‚´ì•„ìˆëŠ” ë™ì•ˆ ìœ íš¨
```

---

### â“ Q9. ëŒë‹¤ì™€ Stream APIì˜ ê´€ê³„ëŠ”?

**ë‹µë³€**:
```
Stream APIëŠ” ëŒë‹¤ë¥¼ ì ê·¹ í™œìš©í•˜ëŠ” ëŒ€í‘œì ì¸ APIì…ë‹ˆë‹¤.

ê´€ê³„:
- Streamì˜ ëŒ€ë¶€ë¶„ ë©”ì„œë“œê°€ í•¨ìˆ˜í˜• ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ
- ëŒë‹¤ ì—†ì´ëŠ” Stream API ì‚¬ìš©ì´ ë¶ˆí¸í•¨

ì£¼ìš” ë©”ì„œë“œì™€ ëŒë‹¤:
1. filter(Predicate<T>)
   stream.filter(x -> x > 10)

2. map(Function<T, R>)
   stream.map(s -> s.toUpperCase())

3. forEach(Consumer<T>)
   stream.forEach(x -> System.out.println(x))

4. reduce(BinaryOperator<T>)
   stream.reduce((a, b) -> a + b)

5. sorted(Comparator<T>)
   stream.sorted((a, b) -> a.compareTo(b))

ëŒë‹¤ ì—†ì´ Stream ì‚¬ìš©:
// ìµëª… í´ë˜ìŠ¤ (ë§¤ìš° ì¥í™©)
stream.filter(new Predicate<Integer>() {
    public boolean test(Integer x) {
        return x > 10;
    }
});

ëŒë‹¤ê°€ Stream APIë¥¼ ê°„ê²°í•˜ê²Œ ë§Œë“¦
```

---

### â“ Q10. ëŒë‹¤ ì„±ëŠ¥ ìµœì í™” ë°©ë²•ì€?

**ë‹µë³€**:
```
1. ëŒë‹¤ ì¬ì‚¬ìš©
   âŒ for (int i = 0; i < 1000; i++) {
       Function<String, String> f = s -> s.toUpperCase();
   }

   âœ… Function<String, String> f = s -> s.toUpperCase();
      for (int i = 0; i < 1000; i++) {
          f.apply(...);
      }

2. ë©”ì„œë“œ ì°¸ì¡° ì‚¬ìš©
   âŒ map(s -> s.toUpperCase())
   âœ… map(String::toUpperCase)

3. Primitive íŠ¹í™” ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©
   âŒ Function<Integer, Integer>  // ë°•ì‹±/ì–¸ë°•ì‹± ë°œìƒ
   âœ… IntUnaryOperator  // primitive ì—°ì‚°

4. Parallel Stream ê³ ë ¤ (ëŒ€ëŸ‰ ë°ì´í„°)
   stream.parallelStream()
       .filter(...)
       .map(...)

5. ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„± í”¼í•˜ê¸°
   âŒ filter(x -> x.toString().equals("value"))
   âœ… filter(x -> "value".equals(x.toString()))

6. ì¤‘ê°„ ì—°ì‚° ìµœì†Œí™”
   âŒ stream.filter(...).filter(...).filter(...)
   âœ… stream.filter(x -> ì¡°ê±´1 && ì¡°ê±´2 && ì¡°ê±´3)

ì„±ëŠ¥ ì¸¡ì •:
- ì†ŒëŸ‰ ë°ì´í„°: forë¬¸ì´ ë¹ ë¥¼ ìˆ˜ ìˆìŒ
- ëŒ€ëŸ‰ ë°ì´í„°: Streamì´ ìœ ë¦¬
- í•­ìƒ í”„ë¡œíŒŒì¼ë§ í›„ ê²°ì •
```

---

## ğŸ“ ì¢…í•© ì •ë¦¬

### ğŸ“Š ëŒë‹¤ ì²´í¬ë¦¬ìŠ¤íŠ¸

```
âœ… ê°„ê²°ì„±
   - ë‹¨ìˆœ ë©”ì„œë“œ í˜¸ì¶œì€ ë©”ì„œë“œ ì°¸ì¡° ì‚¬ìš©
   - ë³µì¡í•œ ë¡œì§ì€ ë³„ë„ ë©”ì„œë“œë¡œ ì¶”ì¶œ

âœ… ê°€ë…ì„±
   - Predicate, Function ë“±ì„ ë³€ìˆ˜ë¡œ ì¶”ì¶œ
   - ì˜ë¯¸ ìˆëŠ” ì´ë¦„ ì‚¬ìš©

âœ… ì„±ëŠ¥
   - ëŒë‹¤ ì¬ì‚¬ìš©
   - Primitive íŠ¹í™” ì¸í„°í˜ì´ìŠ¤ ì‚¬ìš©
   - ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„± í”¼í•˜ê¸°

âœ… ì˜ˆì™¸ ì²˜ë¦¬
   - ë˜í¼ ë©”ì„œë“œ ì‚¬ìš©
   - try-catchë¡œ ê°ì‹¸ê¸°

âœ… ë””ë²„ê¹…
   - peek() í™œìš©
   - ë¡œê·¸ ë˜í¼ ì‚¬ìš©
```

---

### ğŸ’¡ ëŒë‹¤ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤

```java
// 1. ì»¬ë ‰ì…˜ ì •ë ¬
list.sort((a, b) -> a.compareTo(b));
list.sort(Comparator.naturalOrder());

// 2. í•„í„°ë§
list.stream()
    .filter(x -> x > 10)
    .collect(Collectors.toList());

// 3. ë³€í™˜
list.stream()
    .map(String::toUpperCase)
    .collect(Collectors.toList());

// 4. ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
button.setOnAction(event -> handleClick());

// 5. ë¹„ë™ê¸° ì‘ì—…
CompletableFuture.supplyAsync(() -> fetchData())
    .thenApply(data -> process(data))
    .thenAccept(result -> display(result));

// 6. ì¡°ê±´ ì¡°í•©
Predicate<Product> filter =
    isExpensive.and(isAvailable).or(isOnSale);
```

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„ í•™ìŠµ

```
1. Stream API ì‹¬í™”
   - ì¤‘ê°„ ì—°ì‚° vs ìµœì¢… ì—°ì‚°
   - Parallel Stream
   - Collector ì»¤ìŠ¤í„°ë§ˆì´ì§•

2. Optional í™œìš©
   - null ì•ˆì „ì„±
   - í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°

3. CompletableFuture
   - ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë°
   - ì½œë°± ì²´ì´ë‹

4. í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°
   - ë¶ˆë³€ì„±
   - ìˆœìˆ˜ í•¨ìˆ˜
   - ê³ ì°¨ í•¨ìˆ˜
```

---

## ğŸ‰ ì‹œë¦¬ì¦ˆ ì™„ë£Œ!

**Part 1**: 5ê°€ì§€ ì‹¤ìƒí™œ ë¹„ìœ ë¡œ ëŒë‹¤ ì´í•´
**Part 2**: 3ê°œ ê¸°ì—… ì‚¬ë¡€ + 4ê°œ ì£¼ë‹ˆì–´ ì‹¤ìˆ˜
**Part 3**: ì„±ëŠ¥ ìµœì í™” + ê³ ê¸‰ ê¸°ë²• + ë©´ì ‘ ì§ˆë¬¸

ëŒë‹¤ í‘œí˜„ì‹ì„ ì™„ë²½í•˜ê²Œ ë§ˆìŠ¤í„°í–ˆìŠµë‹ˆë‹¤! ğŸŠ
