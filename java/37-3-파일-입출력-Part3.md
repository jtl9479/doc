# 37장 파일 입출력 - Part 3: 면접 질문

> **학습 목표**: 파일 입출력 면접 질문에 완벽하게 대비한다

**⏱️ 예상 학습 시간**: 2-3시간
**난이도**: ⭐⭐⭐⭐☆ (4/5)

---

## 📚 목차
- [주니어/신입 개발자용 면접 질문](#주니어신입-개발자용-면접-질문)
- [중급 개발자용 면접 질문](#중급-개발자용-면접-질문)
- [핵심 정리](#핵심-정리)

---

## 💼 주니어/신입 개발자용 면접 질문

### 📘 1. InputStream과 Reader의 차이는 무엇인가요?

**모범 답안 포인트**
- InputStream/OutputStream: 바이트 스트림 (byte 단위)
- Reader/Writer: 문자 스트림 (char 단위)
- 용도에 따라 선택: 텍스트 vs 바이너리

**예시 답변**
> "InputStream과 OutputStream은 바이트 기반 스트림으로, 이미지나 동영상 같은 바이너리 데이터를 처리할 때 사용합니다. 반면 Reader와 Writer는 문자 기반 스트림으로, 텍스트 파일을 읽고 쓸 때 사용하며 인코딩 처리를 자동으로 해줍니다. 예를 들어 로그 파일을 읽을 때는 FileReader를, 이미지를 복사할 때는 FileInputStream을 사용합니다."

**코드 예시**
```java
// InputStream: 바이너리 파일 (이미지)
try (FileInputStream fis = new FileInputStream("image.jpg");
     FileOutputStream fos = new FileOutputStream("copy.jpg")) {
    byte[] buffer = new byte[1024];
    int bytesRead;
    while ((bytesRead = fis.read(buffer)) != -1) {
        fos.write(buffer, 0, bytesRead);
    }
}

// Reader: 텍스트 파일
try (FileReader fr = new FileReader("text.txt");
     BufferedReader br = new BufferedReader(fr)) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
}
```

**꼬리 질문**
- Q: 텍스트 파일을 InputStream으로 읽으면 어떻게 되나요?
- A: 가능하지만 인코딩 문제가 발생할 수 있습니다. 한글 같은 멀티바이트 문자가 깨질 수 있어 Reader 사용을 권장합니다.

**실무 연관**
- 로그 파일 분석: BufferedReader 사용
- 파일 업로드/다운로드: InputStream/OutputStream 사용
- CSV 파일 처리: BufferedReader로 한 줄씩 읽기

---

### 📘 2. BufferedReader를 사용하는 이유는 무엇인가요?

**모범 답안 포인트**
- 내부 버퍼 사용으로 성능 향상 (100배 빠름)
- 시스템 콜 횟수 감소
- readLine() 편의 기능 제공

**예시 답변**
> "BufferedReader는 내부에 버퍼(기본 8KB)를 가지고 있어서 디스크 I/O 횟수를 대폭 줄여줍니다. FileReader만 사용하면 한 글자 읽을 때마다 디스크에 접근하지만, BufferedReader는 한 번에 8KB를 읽어서 버퍼에 저장한 후 필요할 때마다 버퍼에서 가져옵니다. 그래서 성능이 약 100배 빠릅니다. 또한 readLine() 메서드로 한 줄씩 읽을 수 있어 편리합니다."

**성능 비교 코드**
```java
// 성능 측정
Path file = Paths.get("large.txt");
Files.writeString(file, "A".repeat(1_000_000));  // 1MB 파일

// ❌ FileReader (느림)
long start1 = System.nanoTime();
try (FileReader fr = new FileReader(file.toFile())) {
    while (fr.read() != -1) {}
}
long time1 = System.nanoTime() - start1;
System.out.println("FileReader: " + time1 / 1_000_000 + "ms");
// 약 3000ms

// ✅ BufferedReader (빠름)
long start2 = System.nanoTime();
try (BufferedReader br = Files.newBufferedReader(file)) {
    while (br.readLine() != null) {}
}
long time2 = System.nanoTime() - start2;
System.out.println("BufferedReader: " + time2 / 1_000_000 + "ms");
// 약 30ms (100배 빠름!)
```

**성능 차이 표**
| 방법 | 1MB 파일 | 디스크 I/O 횟수 | 처리 시간 |
|------|----------|----------------|-----------|
| FileReader | read() 1,000,000회 | 1,000,000번 | 3000ms |
| BufferedReader | readLine() 10,000회 | 약 128번 | 30ms |

**꼬리 질문**
- Q: 버퍼 크기를 늘리면 더 빠를까요?
- A: 일정 크기(약 64KB) 이상에서는 효과가 미미합니다. 오히려 메모리 낭비가 될 수 있습니다.

**실무 연관**
- 대용량 로그 파일 분석 시 필수
- CSV 파일 파싱
- 설정 파일 읽기

---

### 📘 3. try-with-resources가 필요한 이유는 무엇인가요?

**모범 답안 포인트**
- 자동으로 close() 호출
- 리소스 누수 방지
- 예외 발생 시에도 close() 보장

**예시 답변**
> "try-with-resources는 Java 7에서 도입된 기능으로, 파일이나 네트워크 같은 리소스를 자동으로 닫아줍니다. 과거에는 finally 블록에서 수동으로 close()를 호출해야 했는데, 이 과정에서 실수로 누락하거나 예외 처리가 복잡해지는 문제가 있었습니다. try-with-resources를 사용하면 try 블록이 끝날 때 자동으로 close()가 호출되므로 파일 핸들 누수나 메모리 누수를 방지할 수 있습니다."

**코드 비교**
```java
// ❌ 수동 close (위험하고 복잡!)
FileReader fr = null;
try {
    fr = new FileReader("file.txt");
    // ... 처리
    fr.close();  // 예외 발생 시 미호출!
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (fr != null) {
        try {
            fr.close();
        } catch (IOException e) {
            // 중첩된 예외 처리...
        }
    }
}

// ✅ try-with-resources (안전하고 간결!)
try (FileReader fr = new FileReader("file.txt")) {
    // ... 처리
    // 자동으로 close() 호출!
} catch (IOException e) {
    e.printStackTrace();
}

// ✅ 여러 리소스도 가능
try (FileReader fr = new FileReader("in.txt");
     BufferedReader br = new BufferedReader(fr);
     FileWriter fw = new FileWriter("out.txt")) {
    // 모두 자동 close!
}
```

**리소스 누수 문제**
```
리소스 누수 발생 시:
1. 파일 핸들 고갈
   - OS는 프로세스당 열 수 있는 파일 수 제한 (보통 1024개)
   - 제한 초과 시: "Too many open files" 에러

2. 메모리 누수
   - 버퍼가 해제되지 않아 메모리 사용량 증가
   - 결국 OutOfMemoryError 발생

3. 파일 잠김
   - Windows에서 파일이 잠겨 다른 프로세스 접근 불가
```

**꼬리 질문**
- Q: close()가 두 번 호출되면 문제가 되나요?
- A: 대부분의 구현에서는 안전하지만, 일반적으로 한 번만 호출되도록 설계해야 합니다.

**실무 연관**
- 모든 파일 I/O 작업
- 데이터베이스 연결 (Connection, Statement)
- 네트워크 소켓

---

### 📘 4. Java 7의 NIO.2가 무엇이고, 왜 사용해야 하나요?

**모범 답안 포인트**
- Java 7에서 도입된 현대적 파일 I/O API
- Path, Files 클래스 제공
- 성능 향상 및 편의성 증대

**예시 답변**
> "NIO.2는 Java 7에서 도입된 새로운 파일 I/O API로, java.nio.file 패키지에 포함되어 있습니다. 기존 java.io.File의 문제점인 느린 성능, 불명확한 에러 처리, 메타데이터 접근 제한 등을 해결했습니다. Path로 파일 경로를 표현하고, Files 클래스로 파일 작업을 수행하는데, 코드가 훨씬 간결하고 성능도 10배 이상 빠릅니다. 또한 Files.walk()로 디렉토리 순회, WatchService로 파일 변경 감지 등 강력한 기능을 제공합니다."

**코드 비교**
```java
// ❌ 구식 (java.io.File) - 복잡하고 느림
File file = new File("data.txt");
if (!file.exists()) {
    file.createNewFile();
}

FileReader fr = new FileReader(file);
BufferedReader br = new BufferedReader(fr);
List<String> lines = new ArrayList<>();
String line;
while ((line = br.readLine()) != null) {
    lines.add(line);
}
br.close();
fr.close();

// ✅ 현대적 (java.nio.file) - 간결하고 빠름
Path path = Paths.get("data.txt");
if (!Files.exists(path)) {
    Files.createFile(path);
}
List<String> lines = Files.readAllLines(path);
```

**NIO.2의 주요 기능**
```java
// 1. 파일 복사 (한 줄!)
Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);

// 2. 디렉토리 재귀 탐색
try (Stream<Path> paths = Files.walk(Paths.get("logs"))) {
    paths.filter(p -> p.toString().endsWith(".log"))
         .forEach(System.out::println);
}

// 3. 파일 쓰기 (한 줄!)
Files.writeString(Paths.get("output.txt"), "Hello, NIO!");

// 4. 파일 속성 읽기
BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
System.out.println("크기: " + attrs.size());
System.out.println("생성일: " + attrs.creationTime());
```

**성능 비교**
| 작업 | java.io.File | java.nio.file.Files | 성능 향상 |
|------|--------------|---------------------|-----------|
| 파일 복사 | 직접 구현 (50줄) | Files.copy() (1줄) | 15배 빠름 |
| 디렉토리 순회 | 재귀 구현 | Files.walk() | 10배 빠름 |
| 파일 읽기 | BufferedReader | Files.readAllLines() | 5배 빠름 |

**꼬리 질문**
- Q: 언제 java.io.File을 사용해야 하나요?
- A: 레거시 라이브러리와의 호환성 때문에만 사용하고, 신규 코드는 무조건 Path와 Files를 사용해야 합니다.

**실무 연관**
- 로그 파일 분석 시스템
- 백업 시스템 (파일 복사)
- 파일 업로드/다운로드 서비스

---

### 📘 5. 파일 인코딩 문제를 어떻게 해결하나요?

**모범 답안 포인트**
- Windows 기본: MS949, Linux 기본: UTF-8
- 명시적으로 UTF-8 지정
- StandardCharsets 사용

**예시 답변**
> "파일 인코딩 문제는 플랫폼마다 기본 인코딩이 다르기 때문에 발생합니다. Windows는 MS949(EUC-KR 확장)를, Linux와 Mac은 UTF-8을 기본으로 사용해서 한글이 깨지는 현상이 발생합니다. 해결 방법은 Files.writeString()과 Files.readString() 사용 시 StandardCharsets.UTF_8을 명시하는 것입니다. 이렇게 하면 모든 플랫폼에서 동일하게 동작합니다."

**문제 상황과 해결**
```java
// ❌ 인코딩 미지정 (플랫폼 의존)
FileWriter writer = new FileWriter("korean.txt");
writer.write("한글 테스트");
writer.close();
// Windows: MS949로 저장
// Linux: UTF-8로 저장
// → Linux에서 만든 파일을 Windows에서 읽으면 깨짐!

// ✅ UTF-8 명시 (모든 플랫폼 동일)
Files.writeString(
    Paths.get("korean.txt"),
    "한글 테스트",
    StandardCharsets.UTF_8
);

// 읽기도 동일
String content = Files.readString(
    Paths.get("korean.txt"),
    StandardCharsets.UTF_8
);
System.out.println(content);  // 한글 정상 출력

// ✅ BufferedReader에도 인코딩 지정
try (BufferedReader br = Files.newBufferedReader(
        Paths.get("korean.txt"),
        StandardCharsets.UTF_8)) {
    String line = br.readLine();
    System.out.println(line);
}
```

**인코딩별 한글 처리**
```
"한글" → 바이트 변환:

UTF-8:
- 한: 0xED 0x95 0x9C (3바이트)
- 글: 0xEA 0xB8 0x80 (3바이트)
- 총 6바이트

MS949 (EUC-KR):
- 한: 0xC7 0xD1 (2바이트)
- 글: 0xB1 0xDB (2바이트)
- 총 4바이트

→ 바이트 수가 달라서 잘못 읽으면 깨짐!
```

**꼬리 질문**
- Q: UTF-8과 UTF-16의 차이는?
- A: UTF-8은 가변 길이 (1-4바이트), UTF-16은 고정/가변 (2 또는 4바이트). 영어가 많으면 UTF-8이 효율적입니다.

**실무 연관**
- CSV 파일 처리 (엑셀 호환성)
- 로그 파일 (서버 간 로그 전송)
- 설정 파일 (properties, yaml)

---

### 📘 6. 대용량 파일을 처리할 때 주의할 점은 무엇인가요?

**모범 답안 포인트**
- readAllLines()는 전체를 메모리에 로드 (OutOfMemoryError)
- Files.lines()로 스트림 처리
- 100MB 이상은 무조건 스트림

**예시 답변**
> "대용량 파일 처리 시 가장 주의할 점은 메모리 관리입니다. Files.readAllLines()는 파일 전체를 메모리에 로드하기 때문에 1GB 파일이면 1GB 메모리가 필요해서 OutOfMemoryError가 발생합니다. 대신 Files.lines()를 사용하면 스트림 방식으로 한 줄씩 읽어서 처리하므로 파일 크기와 무관하게 약 50MB 메모리만 사용합니다. 실무에서는 100MB 이상 파일은 무조건 스트림 처리를 해야 합니다."

**코드 비교**
```java
// ❌ 잘못된 방법 - OutOfMemoryError!
Path bigFile = Paths.get("access.log");  // 1GB
List<String> lines = Files.readAllLines(bigFile);
// 1GB 파일 → 1GB 메모리 사용 → OutOfMemoryError!

for (String line : lines) {
    if (line.contains("ERROR")) {
        System.out.println(line);
    }
}

// ✅ 올바른 방법 - 스트림 처리
try (Stream<String> lines = Files.lines(bigFile)) {
    lines.filter(line -> line.contains("ERROR"))
         .forEach(System.out::println);
    // 1GB 파일이어도 메모리 50MB만 사용!
}

// ✅ 대안: BufferedReader 사용
try (BufferedReader reader = Files.newBufferedReader(bigFile)) {
    String line;
    while ((line = reader.readLine()) != null) {
        if (line.contains("ERROR")) {
            System.out.println(line);
        }
    }
}
```

**메모리 사용량 비교**
| 파일 크기 | readAllLines() | Files.lines() | 메모리 절감 |
|-----------|----------------|---------------|-------------|
| 100MB | 100MB | 50MB | 50% |
| 1GB | OutOfMemoryError | 50MB | 95%+ |
| 10GB | OutOfMemoryError | 50MB | 99%+ |

**스트림 처리 예시**
```java
// 실무 예시: 10GB 로그 파일에서 에러만 추출
try (Stream<String> lines = Files.lines(Paths.get("huge.log"));
     BufferedWriter writer = Files.newBufferedWriter(Paths.get("errors.log"))) {

    lines.filter(line -> line.contains("ERROR"))
         .forEach(line -> {
             try {
                 writer.write(line);
                 writer.newLine();
             } catch (IOException e) {
                 e.printStackTrace();
             }
         });
}
// 10GB 파일도 메모리 100MB로 처리!
```

**꼬리 질문**
- Q: parallelStream()을 사용하면 더 빠를까요?
- A: CPU 집약적 작업에는 도움이 되지만, 파일 I/O는 디스크 속도가 병목이라 효과가 제한적입니다.

**실무 연관**
- 대용량 로그 분석 (수 GB~TB)
- CSV 대용량 데이터 처리
- 웹 크롤링 결과 파일 파싱

---

### 📘 7. close()를 하지 않으면 어떤 문제가 발생하나요?

**모범 답안 포인트**
- 파일 핸들 누수
- 메모리 누수
- 파일 잠김 현상

**예시 답변**
> "close()를 하지 않으면 세 가지 심각한 문제가 발생합니다. 첫째, 파일 핸들 누수로 OS가 프로세스당 열 수 있는 파일 수 제한(보통 1024개)에 도달해 'Too many open files' 에러가 발생합니다. 둘째, 버퍼가 해제되지 않아 메모리 누수가 발생하고 결국 OutOfMemoryError가 발생합니다. 셋째, Windows에서는 파일이 잠겨서 다른 프로세스가 접근할 수 없게 됩니다. 따라서 반드시 try-with-resources를 사용해 자동으로 close()가 호출되도록 해야 합니다."

**문제 발생 예시**
```java
// ❌ 나쁜 예 - close() 누락
public void badExample() throws IOException {
    for (int i = 0; i < 2000; i++) {
        FileReader fr = new FileReader("file.txt");
        // close() 안 함!
    }
    // 1024번째 반복에서 에러:
    // java.io.IOException: Too many open files
}

// ✅ 좋은 예 - try-with-resources
public void goodExample() throws IOException {
    for (int i = 0; i < 2000; i++) {
        try (FileReader fr = new FileReader("file.txt")) {
            // 자동으로 close()!
        }
    }
    // 문제 없음!
}
```

**파일 핸들 누수 테스트**
```java
public class FileHandleLeakDemo {
    public static void main(String[] args) throws Exception {
        System.out.println("파일 핸들 누수 테스트 시작");

        // ❌ close() 없이 파일 열기
        List<FileReader> readers = new ArrayList<>();

        try {
            for (int i = 1; i <= 2000; i++) {
                FileReader fr = new FileReader("test.txt");
                readers.add(fr);

                if (i % 100 == 0) {
                    System.out.println(i + "개 파일 열림");
                }
            }
        } catch (IOException e) {
            System.err.println("에러 발생: " + e.getMessage());
            // 출력: Too many open files
        }

        System.out.println("총 열린 파일: " + readers.size());

        // 정리
        for (FileReader fr : readers) {
            fr.close();
        }
    }
}
```

**문제 유형별 상세**
```
1. 파일 핸들 누수
   증상: Too many open files
   원인: OS의 파일 디스크립터 테이블 고갈
   영향: 파일뿐 아니라 소켓도 열 수 없음
   확인: lsof (Linux), Process Explorer (Windows)

2. 메모리 누수
   증상: OutOfMemoryError
   원인: BufferedReader의 버퍼(8KB)가 해제 안 됨
   영향: 힙 메모리 고갈
   확인: jstat -gc, VisualVM

3. 파일 잠김 (Windows)
   증상: 파일 삭제/수정 불가
   원인: Windows는 파일이 열려있으면 잠금
   영향: 배포 시 파일 교체 불가
   확인: Handle (Sysinternals)
```

**꼬리 질문**
- Q: flush()와 close()의 차이는?
- A: flush()는 버퍼 내용을 파일에 쓰기만 하고, close()는 flush() + 파일 핸들 해제까지 합니다.

**실무 연관**
- 장시간 실행되는 서버 애플리케이션
- 배치 작업 (수천 개 파일 처리)
- 로그 파일 로테이션

---

## 💼 중급 개발자용 면접 질문

### 📗 1. NIO의 Channel과 Buffer의 동작 원리를 설명해주세요

**모범 답안 포인트**
- Channel: 양방향 데이터 통로
- Buffer: 데이터를 담는 컨테이너
- Direct Buffer vs Heap Buffer
- 성능 최적화 원리

**예시 답변**
> "NIO의 Channel은 전통적 I/O의 Stream과 달리 양방향 통신이 가능한 데이터 통로입니다. FileChannel을 통해 데이터를 읽거나 쓸 때 반드시 Buffer를 거치는데, 이는 OS 레벨의 시스템 콜을 최소화하기 위함입니다. Buffer는 크게 Heap Buffer와 Direct Buffer로 나뉘는데, Direct Buffer는 JVM 힙 외부의 네이티브 메모리를 사용해 OS와 직접 통신하므로 복사 오버헤드가 없어 대용량 파일 처리에 유리합니다. 실무에서는 FileChannel.transferTo()를 사용하면 Zero-Copy로 파일을 복사할 수 있어 성능이 일반 I/O 대비 10배 이상 향상됩니다."

**동작 원리 다이어그램**
```
전통적 I/O:
Application → JVM Heap → OS Buffer → Disk
(데이터 복사 3회)

NIO with Direct Buffer:
Application → Direct Buffer → Disk
(데이터 복사 1회, Zero-Copy 가능)

Channel + Buffer 흐름:
1. 읽기:
   FileChannel.read(buffer)
   → OS가 Disk에서 Direct Buffer로 복사
   → Application이 buffer.get()으로 읽기

2. 쓰기:
   buffer.put(data)
   → Application이 Direct Buffer에 쓰기
   → FileChannel.write(buffer)
   → OS가 Direct Buffer에서 Disk로 복사
```

**코드 예시**
```java
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class NIOChannelDemo {
    public static void main(String[] args) throws Exception {
        // 1. FileChannel 열기
        Path source = Paths.get("source.txt");
        Path target = Paths.get("target.txt");

        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel targetChannel = FileChannel.open(target,
                 StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            // 2. Buffer 할당 (Direct Buffer)
            ByteBuffer buffer = ByteBuffer.allocateDirect(1024);

            // 3. 읽기
            int bytesRead;
            while ((bytesRead = sourceChannel.read(buffer)) != -1) {
                // Buffer를 읽기 모드로 전환
                buffer.flip();

                // 4. 쓰기
                while (buffer.hasRemaining()) {
                    targetChannel.write(buffer);
                }

                // Buffer 초기화
                buffer.clear();
            }
        }

        // ✅ Zero-Copy 파일 복사 (더 빠름!)
        try (FileChannel sourceChannel = FileChannel.open(source, StandardOpenOption.READ);
             FileChannel targetChannel = FileChannel.open(Paths.get("target2.txt"),
                 StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {

            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);
            // OS 레벨에서 직접 복사 (Zero-Copy)!
        }
    }
}
```

**성능 비교**
```java
// 성능 측정: 1GB 파일 복사
Path source = Paths.get("1GB.dat");
Path target1 = Paths.get("copy1.dat");
Path target2 = Paths.get("copy2.dat");

// 1. 전통적 I/O
long start1 = System.currentTimeMillis();
try (InputStream in = Files.newInputStream(source);
     OutputStream out = Files.newOutputStream(target1)) {
    byte[] buffer = new byte[8192];
    int bytesRead;
    while ((bytesRead = in.read(buffer)) != -1) {
        out.write(buffer, 0, bytesRead);
    }
}
long time1 = System.currentTimeMillis() - start1;
System.out.println("전통 I/O: " + time1 + "ms");  // 약 5000ms

// 2. NIO Zero-Copy
long start2 = System.currentTimeMillis();
try (FileChannel src = FileChannel.open(source, StandardOpenOption.READ);
     FileChannel dst = FileChannel.open(target2,
         StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
    src.transferTo(0, src.size(), dst);
}
long time2 = System.currentTimeMillis() - start2;
System.out.println("NIO Zero-Copy: " + time2 + "ms");  // 약 500ms (10배 빠름!)
```

**Buffer 상태 관리**
```java
ByteBuffer buffer = ByteBuffer.allocate(10);

// 초기 상태
// position=0, limit=10, capacity=10

// 데이터 쓰기
buffer.put((byte) 'H');
buffer.put((byte) 'E');
buffer.put((byte) 'L');
// position=3, limit=10

// 읽기 모드로 전환
buffer.flip();
// position=0, limit=3

// 데이터 읽기
while (buffer.hasRemaining()) {
    System.out.print((char) buffer.get());
}
// position=3, limit=3

// 버퍼 초기화
buffer.clear();
// position=0, limit=10
```

**꼬리 질문**
- Q: Direct Buffer의 단점은?
- A: 할당/해제 비용이 높고, GC 대상이 아니라 메모리 관리가 어렵습니다. 장시간 사용할 Buffer에만 사용해야 합니다.

**실무 연관**
- 대용량 파일 전송 서비스
- 비디오 스트리밍 서버
- 데이터베이스 백업 시스템

---

### 📗 2. WatchService로 파일 변경 감지를 구현하는 방법과 주의사항은?

**모범 답안 포인트**
- WatchService: 파일 시스템 이벤트 감지
- 이벤트 종류: CREATE, MODIFY, DELETE
- 폴링 방식 vs 이벤트 방식
- 성능 고려사항

**예시 답변**
> "WatchService는 Java 7 NIO.2에서 도입된 파일 시스템 변경 감지 API입니다. 디렉토리를 등록하면 파일 생성, 수정, 삭제 이벤트를 비동기적으로 받을 수 있습니다. 실무에서는 로그 파일 실시간 모니터링, 설정 파일 Hot Reload, 파일 동기화 등에 사용됩니다. 주의사항으로는 하위 디렉토리는 자동 감지되지 않아 재귀적으로 등록해야 하고, 이벤트 순서가 보장되지 않으며, 대량 변경 시 이벤트가 누락될 수 있다는 점입니다. 또한 OS마다 구현이 달라 Windows에서는 즉시 감지되지만 Linux에서는 약간의 지연이 있을 수 있습니다."

**기본 구현**
```java
import java.nio.file.*;
import static java.nio.file.StandardWatchEventKinds.*;

public class FileWatcher {
    public static void main(String[] args) throws Exception {
        // 1. WatchService 생성
        WatchService watcher = FileSystems.getDefault().newWatchService();

        // 2. 감시할 디렉토리 등록
        Path dir = Paths.get("logs");
        dir.register(watcher, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);

        System.out.println("파일 변경 감시 시작: " + dir);

        // 3. 이벤트 감지 루프
        while (true) {
            // 이벤트 대기 (블로킹)
            WatchKey key = watcher.take();

            // 이벤트 처리
            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();

                // 오버플로우 체크
                if (kind == OVERFLOW) {
                    System.out.println("⚠️ 이벤트 오버플로우!");
                    continue;
                }

                // 파일 이름 가져오기
                @SuppressWarnings("unchecked")
                WatchEvent<Path> ev = (WatchEvent<Path>) event;
                Path filename = ev.context();

                System.out.println(kind.name() + ": " + filename);

                // 이벤트별 처리
                if (kind == ENTRY_CREATE) {
                    System.out.println("  → 파일 생성됨");
                } else if (kind == ENTRY_MODIFY) {
                    System.out.println("  → 파일 수정됨");
                } else if (kind == ENTRY_DELETE) {
                    System.out.println("  → 파일 삭제됨");
                }
            }

            // WatchKey 리셋 (중요!)
            boolean valid = key.reset();
            if (!valid) {
                System.out.println("디렉토리가 삭제되었습니다.");
                break;
            }
        }
    }
}
```

**실무 예시: 로그 파일 실시간 모니터링**
```java
import java.nio.file.*;
import java.util.concurrent.*;

public class LogMonitor {
    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    public void startMonitoring(Path logDir) throws Exception {
        WatchService watcher = FileSystems.getDefault().newWatchService();
        logDir.register(watcher, ENTRY_MODIFY);

        System.out.println("로그 모니터링 시작: " + logDir);

        executor.submit(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    WatchKey key = watcher.take();

                    for (WatchEvent<?> event : key.pollEvents()) {
                        if (event.kind() == ENTRY_MODIFY) {
                            Path changedFile = (Path) event.context();

                            if (changedFile.toString().endsWith(".log")) {
                                // 로그 파일 수정됨 → 분석
                                analyzeNewLogs(logDir.resolve(changedFile));
                            }
                        }
                    }

                    key.reset();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } catch (Exception e) {
                e.printStackTrace();
            }
        });
    }

    private void analyzeNewLogs(Path logFile) throws Exception {
        // 파일 끝에 추가된 내용만 읽기
        try (var lines = Files.lines(logFile)) {
            lines.filter(line -> line.contains("ERROR"))
                 .forEach(line -> {
                     System.out.println("🚨 에러 감지: " + line);
                     // 알림 전송 로직...
                 });
        }
    }

    public void stop() {
        executor.shutdownNow();
    }
}
```

**재귀 감시 (하위 디렉토리 포함)**
```java
public class RecursiveWatcher {
    private final WatchService watcher;
    private final Map<WatchKey, Path> keys = new HashMap<>();

    public RecursiveWatcher() throws IOException {
        this.watcher = FileSystems.getDefault().newWatchService();
    }

    // 디렉토리와 모든 하위 디렉토리 등록
    public void registerAll(Path start) throws IOException {
        try (Stream<Path> paths = Files.walk(start)) {
            paths.filter(Files::isDirectory)
                 .forEach(this::register);
        }
    }

    private void register(Path dir) {
        try {
            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
            keys.put(key, dir);
            System.out.println("등록: " + dir);
        } catch (IOException e) {
            System.err.println("등록 실패: " + dir);
        }
    }

    public void processEvents() throws InterruptedException {
        while (true) {
            WatchKey key = watcher.take();
            Path dir = keys.get(key);

            for (WatchEvent<?> event : key.pollEvents()) {
                WatchEvent.Kind<?> kind = event.kind();

                if (kind == OVERFLOW) continue;

                @SuppressWarnings("unchecked")
                Path filename = ((WatchEvent<Path>) event).context();
                Path child = dir.resolve(filename);

                System.out.println(kind.name() + ": " + child);

                // 새 디렉토리 생성 시 자동 등록
                if (kind == ENTRY_CREATE && Files.isDirectory(child)) {
                    registerAll(child);
                }
            }

            if (!key.reset()) {
                keys.remove(key);
                if (keys.isEmpty()) break;
            }
        }
    }
}
```

**성능 고려사항**
```
문제점:
1. 이벤트 누락
   - 짧은 시간에 대량 변경 시 OVERFLOW 발생
   - 해결: 이벤트 큐 크기 조정 또는 폴링 간격 조정

2. 하위 디렉토리 미감지
   - 직접 등록한 디렉토리만 감지
   - 해결: Files.walk()로 재귀 등록

3. OS별 차이
   - Windows: ReadDirectoryChangesW (즉시 감지)
   - Linux: inotify (약간의 지연)
   - macOS: kqueue (성능 이슈)

4. 리소스 사용
   - 디렉토리당 파일 디스크립터 1개 소비
   - 대량 디렉토리 감시 시 리소스 고갈
   - 해결: 필요한 디렉토리만 선별적으로 감시
```

**꼬리 질문**
- Q: 수천 개 디렉토리를 감시해야 한다면?
- A: WatchService보다는 주기적인 파일 스캔(Files.walk() + 타임스탬프 비교)이 더 효율적일 수 있습니다.

**실무 연관**
- 설정 파일 Hot Reload (Spring DevTools)
- 파일 동기화 서비스 (Dropbox, Google Drive)
- 빌드 도구 (Webpack, Gradle 증분 빌드)
- 로그 수집 시스템 (Fluentd, Logstash)

---

### 📗 3. 파일 잠금(File Locking)은 언제 어떻게 사용하나요?

**모범 답안 포인트**
- FileLock: 다중 프로세스 동시 접근 제어
- Exclusive Lock vs Shared Lock
- 플랫폼 의존성
- 데드락 방지

**예시 답변**
> "파일 잠금은 여러 프로세스가 동시에 같은 파일에 접근할 때 데이터 무결성을 보장하기 위해 사용합니다. FileChannel.lock()을 사용하면 OS 레벨에서 파일을 잠글 수 있는데, Exclusive Lock(배타적 잠금)은 쓰기 시, Shared Lock(공유 잠금)은 읽기 시 사용합니다. 실무에서는 설정 파일 업데이트, 로그 파일 로테이션, PID 파일 관리 등에 사용됩니다. 주의할 점은 플랫폼마다 동작이 다르고, 프로세스 간 잠금만 지원하며(스레드 간 X), 데드락 가능성이 있다는 것입니다."

**기본 사용법**
```java
import java.nio.channels.*;
import java.nio.file.*;

public class FileLockingExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("shared.dat");

        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            System.out.println("파일 잠금 시도...");

            // Exclusive Lock (배타적 잠금)
            FileLock lock = channel.lock();
            // 또는: channel.lock(position, size, shared)

            System.out.println("잠금 획득 성공!");
            System.out.println("  - 배타적 잠금: " + !lock.isShared());
            System.out.println("  - 유효: " + lock.isValid());

            // 크리티컬 섹션 (다른 프로세스 접근 불가)
            channel.write(ByteBuffer.wrap("Critical Data".getBytes()));
            Thread.sleep(5000);  // 5초간 잠금 유지

            // 잠금 해제 (try-with-resources로 자동 해제됨)
            lock.release();
            System.out.println("잠금 해제");
        }
    }
}
```

**Shared Lock vs Exclusive Lock**
```java
public class SharedLockExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("data.txt");

        // Reader 1 - Shared Lock
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file, StandardOpenOption.READ)) {
                FileLock lock = ch.lock(0, Long.MAX_VALUE, true);  // shared=true
                System.out.println("Reader 1: Shared Lock 획득");

                ByteBuffer buffer = ByteBuffer.allocate(100);
                ch.read(buffer);

                Thread.sleep(3000);
                lock.release();
                System.out.println("Reader 1: 잠금 해제");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        // Reader 2 - Shared Lock (동시 가능!)
        Thread.sleep(100);
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file, StandardOpenOption.READ)) {
                FileLock lock = ch.lock(0, Long.MAX_VALUE, true);
                System.out.println("Reader 2: Shared Lock 획득 (동시!)");

                Thread.sleep(2000);
                lock.release();
                System.out.println("Reader 2: 잠금 해제");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();

        // Writer - Exclusive Lock (대기...)
        Thread.sleep(500);
        new Thread(() -> {
            try (FileChannel ch = FileChannel.open(file,
                    StandardOpenOption.WRITE, StandardOpenOption.APPEND)) {
                System.out.println("Writer: Exclusive Lock 대기 중...");
                FileLock lock = ch.lock();  // Shared Lock 해제 대기
                System.out.println("Writer: Exclusive Lock 획득!");

                ch.write(ByteBuffer.wrap("New Data".getBytes()));
                Thread.sleep(1000);
                lock.release();
                System.out.println("Writer: 잠금 해제");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

**실무 예시: PID 파일 관리**
```java
public class ProcessLock {
    private static final Path PID_FILE = Paths.get("/var/run/myapp.pid");
    private FileLock lock;
    private FileChannel channel;

    // 싱글톤 인스턴스 보장
    public boolean acquireLock() {
        try {
            channel = FileChannel.open(PID_FILE,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE);

            // 비블로킹 잠금 시도
            lock = channel.tryLock();

            if (lock == null) {
                System.err.println("이미 실행 중인 프로세스가 있습니다!");
                channel.close();
                return false;
            }

            // PID 파일에 현재 프로세스 ID 쓰기
            String pid = String.valueOf(ProcessHandle.current().pid());
            channel.write(ByteBuffer.wrap(pid.getBytes()));
            channel.force(false);

            System.out.println("프로세스 잠금 획득: PID " + pid);

            // JVM 종료 시 자동 해제
            Runtime.getRuntime().addShutdownHook(new Thread(this::releaseLock));

            return true;

        } catch (IOException e) {
            System.err.println("잠금 실패: " + e.getMessage());
            return false;
        }
    }

    public void releaseLock() {
        try {
            if (lock != null && lock.isValid()) {
                lock.release();
            }
            if (channel != null) {
                channel.close();
            }
            Files.deleteIfExists(PID_FILE);
            System.out.println("프로세스 잠금 해제");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        ProcessLock processLock = new ProcessLock();

        if (!processLock.acquireLock()) {
            System.exit(1);
        }

        // 메인 애플리케이션 로직
        System.out.println("애플리케이션 실행 중...");
        Thread.sleep(10000);  // 10초 실행
    }
}
```

**데드락 방지**
```java
public class DeadlockAvoidance {
    // ❌ 나쁜 예 - 데드락 가능
    public void badLocking(Path file1, Path file2) throws Exception {
        try (FileChannel ch1 = FileChannel.open(file1, StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(file2, StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.lock();  // Thread A: file1 잠금
            Thread.sleep(100);
            FileLock lock2 = ch2.lock();  // Thread A: file2 잠금 대기
                                          // Thread B: file2 잠금, file1 대기
                                          // → 데드락!

            // 작업...

            lock2.release();
            lock1.release();
        }
    }

    // ✅ 좋은 예 - 잠금 순서 일관성
    public void goodLocking(Path file1, Path file2) throws Exception {
        // 파일 경로 기준 정렬 (항상 동일한 순서로 잠금)
        List<Path> files = Arrays.asList(file1, file2);
        files.sort(Comparator.comparing(Path::toString));

        try (FileChannel ch1 = FileChannel.open(files.get(0), StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(files.get(1), StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.lock();
            FileLock lock2 = ch2.lock();

            // 작업...

            lock2.release();
            lock1.release();
        }
    }

    // ✅ 더 나은 예 - tryLock() 사용
    public void tryLocking(Path file1, Path file2) throws Exception {
        try (FileChannel ch1 = FileChannel.open(file1, StandardOpenOption.WRITE);
             FileChannel ch2 = FileChannel.open(file2, StandardOpenOption.WRITE)) {

            FileLock lock1 = ch1.tryLock();
            if (lock1 == null) {
                System.out.println("file1 잠금 실패 - 나중에 재시도");
                return;
            }

            FileLock lock2 = ch2.tryLock();
            if (lock2 == null) {
                System.out.println("file2 잠금 실패 - 롤백");
                lock1.release();
                return;
            }

            // 두 파일 모두 잠금 성공!
            // 작업...

            lock2.release();
            lock1.release();
        }
    }
}
```

**플랫폼별 차이**
```
Windows:
- Mandatory Locking (강제 잠금)
- 잠긴 파일은 다른 프로세스가 읽기/쓰기 불가
- FileLock이 확실하게 동작

Linux/Unix:
- Advisory Locking (권고 잠금)
- 협조하는 프로세스만 존중
- 강제하지 않으면 무시 가능
- fcntl() 시스템 콜 사용

Mac OS:
- Advisory Locking
- 일부 파일 시스템(NFS)에서 제한적
```

**꼬리 질문**
- Q: 네트워크 파일 시스템(NFS)에서도 동작하나요?
- A: NFS v4부터는 잠금을 지원하지만, 네트워크 지연으로 인한 문제가 있을 수 있어 권장하지 않습니다. 분산 잠금(Redis, ZooKeeper)을 사용하는 것이 좋습니다.

**실무 연관**
- 멀티 인스턴스 서버 (중복 실행 방지)
- 로그 파일 로테이션
- 설정 파일 Hot Reload
- 배치 작업 (중복 실행 방지)

---

### 📗 4. Memory-Mapped File의 장단점과 사용 시나리오는?

**모범 답안 포인트**
- MappedByteBuffer: 파일을 메모리에 매핑
- Zero-Copy, 빠른 랜덤 액세스
- 대용량 파일, 공유 메모리
- 메모리 제한, GC 이슈

**예시 답변**
> "Memory-Mapped File은 파일을 가상 메모리에 직접 매핑하여 메모리처럼 접근할 수 있게 하는 기술입니다. FileChannel.map()으로 생성하며, OS의 페이지 캐시를 활용해 디스크 I/O 없이 메모리 속도로 파일에 접근할 수 있습니다. 장점은 Zero-Copy로 성능이 매우 빠르고, 여러 프로세스가 공유 메모리로 사용할 수 있으며, 랜덤 액세스가 효율적이라는 것입니다. 단점은 32bit JVM에서는 파일 크기가 약 2GB로 제한되고, GC가 명시적으로 해제하지 않아 메모리 누수 위험이 있으며, 쓰기 시 디스크 동기화 시점을 제어하기 어렵다는 것입니다. 실무에서는 대용량 데이터베이스 인덱스, 로그 파일 분석, 프로세스 간 통신에 사용합니다."

**기본 사용법**
```java
import java.nio.*;
import java.nio.channels.*;
import java.nio.file.*;

public class MemoryMappedFileExample {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("data.bin");

        // 10MB 파일 생성
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            // Memory-Mapped Buffer 생성
            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,                    // 시작 위치
                10 * 1024 * 1024      // 크기 (10MB)
            );

            System.out.println("Memory-Mapped File 생성 완료");

            // 쓰기 (메모리 속도!)
            long start = System.nanoTime();
            for (int i = 0; i < 1_000_000; i++) {
                buffer.putInt(i);
            }
            long writeTime = System.nanoTime() - start;
            System.out.println("쓰기 시간: " + writeTime / 1_000_000 + "ms");

            // 읽기 (랜덤 액세스)
            buffer.position(0);
            start = System.nanoTime();
            int sum = 0;
            for (int i = 0; i < 1_000_000; i++) {
                sum += buffer.getInt();
            }
            long readTime = System.nanoTime() - start;
            System.out.println("읽기 시간: " + readTime / 1_000_000 + "ms");
            System.out.println("합계: " + sum);

            // 강제 디스크 동기화
            buffer.force();
        }
    }
}
```

**성능 비교: Mapped vs 일반 I/O**
```java
public class PerformanceComparison {
    public static void main(String[] args) throws Exception {
        Path file = Paths.get("test.dat");
        int size = 100_000_000;  // 100MB

        // 1. 일반 FileChannel
        long start1 = System.nanoTime();
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE)) {

            ByteBuffer buffer = ByteBuffer.allocate(8192);
            for (int i = 0; i < size; i++) {
                buffer.putInt(i);
                if (!buffer.hasRemaining()) {
                    buffer.flip();
                    channel.write(buffer);
                    buffer.clear();
                }
            }
            buffer.flip();
            channel.write(buffer);
        }
        long time1 = System.nanoTime() - start1;
        System.out.println("일반 I/O: " + time1 / 1_000_000 + "ms");
        // 약 500ms

        // 2. Memory-Mapped File
        long start2 = System.nanoTime();
        try (FileChannel channel = FileChannel.open(file,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            MappedByteBuffer mmap = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,
                size * 4L
            );

            for (int i = 0; i < size; i++) {
                mmap.putInt(i);
            }
            mmap.force();
        }
        long time2 = System.nanoTime() - start2;
        System.out.println("Memory-Mapped: " + time2 / 1_000_000 + "ms");
        // 약 100ms (5배 빠름!)

        Files.delete(file);
    }
}
```

**실무 예시: 프로세스 간 통신 (IPC)**
```java
// Process 1: Writer
public class IPCWriter {
    public static void main(String[] args) throws Exception {
        Path sharedFile = Paths.get("/tmp/shared_memory");

        try (FileChannel channel = FileChannel.open(sharedFile,
                StandardOpenOption.CREATE,
                StandardOpenOption.READ,
                StandardOpenOption.WRITE)) {

            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_WRITE,
                0,
                1024
            );

            // 메시지 쓰기
            String message = "Hello from Process 1";
            buffer.put(message.getBytes());
            buffer.force();

            System.out.println("메시지 전송: " + message);
        }
    }
}

// Process 2: Reader
public class IPCReader {
    public static void main(String[] args) throws Exception {
        Path sharedFile = Paths.get("/tmp/shared_memory");

        try (FileChannel channel = FileChannel.open(sharedFile,
                StandardOpenOption.READ)) {

            MappedByteBuffer buffer = channel.map(
                FileChannel.MapMode.READ_ONLY,
                0,
                1024
            );

            // 메시지 읽기
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            String message = new String(bytes).trim();

            System.out.println("메시지 수신: " + message);
        }
    }
}
```

**대용량 파일 처리**
```java
public class LargeFileProcessor {
    // 1GB 파일을 청크 단위로 처리
    public void processLargeFile(Path file) throws Exception {
        long fileSize = Files.size(file);
        long chunkSize = 100 * 1024 * 1024;  // 100MB 청크

        try (FileChannel channel = FileChannel.open(file, StandardOpenOption.READ)) {
            for (long offset = 0; offset < fileSize; offset += chunkSize) {
                long size = Math.min(chunkSize, fileSize - offset);

                // 청크별로 매핑
                MappedByteBuffer buffer = channel.map(
                    FileChannel.MapMode.READ_ONLY,
                    offset,
                    size
                );

                System.out.println("처리 중: " + offset + " ~ " + (offset + size));
                processChunk(buffer);

                // 명시적 해제 시도 (효과 제한적)
                ((DirectBuffer) buffer).cleaner().clean();
            }
        }
    }

    private void processChunk(MappedByteBuffer buffer) {
        // 데이터 분석 로직
        while (buffer.hasRemaining()) {
            byte b = buffer.get();
            // 처리...
        }
    }
}
```

**장단점 정리**
```
장점:
1. 빠른 성능
   - Zero-Copy: OS 페이지 캐시 직접 접근
   - 일반 I/O 대비 5~10배 빠름

2. 랜덤 액세스
   - 파일 내 임의 위치 접근이 빠름
   - 데이터베이스 인덱스에 이상적

3. 공유 메모리
   - 여러 프로세스가 동일한 파일 공유
   - IPC (프로세스 간 통신) 가능

4. 자동 페이징
   - OS가 페이지 스왑 자동 관리
   - 메모리보다 큰 파일도 처리 가능

단점:
1. 메모리 제한
   - 32bit JVM: 최대 약 2GB
   - 64bit JVM: 이론적 무제한, 실제 OS 제한

2. GC 이슈
   - MappedByteBuffer는 GC 대상 아님
   - 명시적 해제 불가 (cleaner() 해킹 필요)
   - 메모리 누수 위험

3. 디스크 동기화
   - 언제 디스크에 쓰이는지 불명확
   - force() 호출 필요

4. 플랫폼 의존
   - Windows와 Linux에서 동작 차이
   - 에러 처리 복잡
```

**사용 시나리오**
```
✅ 적합한 경우:
- 대용량 파일 (100MB~수GB)
- 랜덤 액세스 많음
- 읽기 위주
- 프로세스 간 공유 메모리

❌ 부적합한 경우:
- 작은 파일 (<10MB)
- 순차 읽기/쓰기만
- 빈번한 파일 닫기/열기
- 정확한 디스크 동기화 필요
```

**꼬리 질문**
- Q: MappedByteBuffer를 명시적으로 해제할 수 있나요?
- A: 공식 API는 없지만, sun.misc.Cleaner를 사용하는 해킹이 있습니다. 하지만 Java 9+에서는 모듈 시스템으로 인해 어렵고, 권장하지 않습니다.

**실무 연관**
- 데이터베이스 엔진 (인덱스 파일)
- 로그 분석 시스템 (대용량 로그)
- 게임 서버 (공유 메모리)
- 빅데이터 처리 (Parquet, ORC 파일)

---

### 📗 5. 파일 시스템의 Symbolic Link와 Hard Link를 어떻게 처리하나요?

**모범 답안 포인트**
- Symbolic Link: 경로 참조
- Hard Link: inode 공유
- Files.isSymbolicLink(), Files.readSymbolicLink()
- 순환 참조 방지

**예시 답변**
> "Symbolic Link는 파일이나 디렉토리의 경로를 가리키는 포인터이고, Hard Link는 동일한 inode를 공유하는 별도의 디렉토리 엔트리입니다. Java NIO.2에서는 Files.isSymbolicLink()로 심볼릭 링크를 감지하고, Files.readSymbolicLink()로 실제 경로를 읽을 수 있습니다. 파일 순회 시 순환 참조를 방지하기 위해 FileVisitOption.FOLLOW_LINKS를 신중하게 사용해야 하며, Files.walk()의 maxDepth를 제한하는 것이 좋습니다. 실무에서는 로그 파일 심볼릭 링크, 버전 관리 시스템, 배포 디렉토리 구조 등에서 링크를 다뤄야 합니다."

**기본 링크 처리**
```java
import java.nio.file.*;
import java.nio.file.attribute.*;

public class LinkHandling {
    public static void main(String[] args) throws Exception {
        Path original = Paths.get("original.txt");
        Path symlink = Paths.get("symlink.txt");
        Path hardlink = Paths.get("hardlink.txt");

        // 원본 파일 생성
        Files.writeString(original, "Original content");

        // Symbolic Link 생성
        Files.createSymbolicLink(symlink, original);
        System.out.println("Symbolic Link 생성: " + symlink);

        // Hard Link 생성 (Windows: NTFS, Linux: ext4)
        Files.createLink(hardlink, original);
        System.out.println("Hard Link 생성: " + hardlink);

        // 링크 확인
        System.out.println("\n=== 링크 정보 ===");
        System.out.println("original 은 심볼릭 링크? " + Files.isSymbolicLink(original));
        System.out.println("symlink 은 심볼릭 링크? " + Files.isSymbolicLink(symlink));
        System.out.println("hardlink 은 심볼릭 링크? " + Files.isSymbolicLink(hardlink));

        // Symbolic Link의 실제 경로 읽기
        if (Files.isSymbolicLink(symlink)) {
            Path target = Files.readSymbolicLink(symlink);
            System.out.println("symlink 가 가리키는 경로: " + target);
        }

        // 실제 파일 경로 (심볼릭 링크 해석)
        Path realPath = symlink.toRealPath();
        System.out.println("symlink 의 실제 경로: " + realPath);

        // 파일 속성 읽기
        System.out.println("\n=== inode 정보 (Linux/Mac) ===");
        printInode(original);
        printInode(symlink);
        printInode(hardlink);
    }

    private static void printInode(Path path) throws Exception {
        if (System.getProperty("os.name").toLowerCase().contains("windows")) {
            return;  // Windows는 inode 없음
        }

        Object fileKey = Files.getAttribute(path, "unix:ino");
        System.out.println(path.getFileName() + " inode: " + fileKey);
    }
}
```

**출력 결과**
```
Symbolic Link 생성: symlink.txt
Hard Link 생성: hardlink.txt

=== 링크 정보 ===
original 은 심볼릭 링크? false
symlink 은 심볼릭 링크? true
hardlink 은 심볼릭 링크? false

symlink 가 가리키는 경로: original.txt
symlink 의 실제 경로: /full/path/to/original.txt

=== inode 정보 (Linux/Mac) ===
original.txt inode: 123456
symlink.txt inode: 789012  (다른 inode)
hardlink.txt inode: 123456  (original과 동일!)
```

**순환 참조 방지**
```java
public class CircularLinkDetection {
    public static void main(String[] args) throws Exception {
        Path dir = Paths.get("/tmp/test");
        Files.createDirectories(dir);

        // 순환 링크 생성
        Path subdir = dir.resolve("subdir");
        Files.createDirectories(subdir);
        Path circularLink = subdir.resolve("parent_link");
        Files.createSymbolicLink(circularLink, dir);

        System.out.println("순환 링크 구조 생성:");
        System.out.println(dir + " → " + subdir + " → " + circularLink + " → " + dir);

        // ❌ 순환 링크를 따라가면 무한 루프!
        try {
            System.out.println("\n무한 순회 시도 (실패할 것)...");
            try (Stream<Path> paths = Files.walk(dir, FileVisitOption.FOLLOW_LINKS)) {
                paths.limit(100)  // 안전을 위해 제한
                     .forEach(System.out::println);
            }
        } catch (FileSystemLoopException e) {
            System.out.println("순환 감지: " + e.getMessage());
        }

        // ✅ 순환 링크를 따라가지 않음 (기본 동작)
        System.out.println("\n심볼릭 링크 무시:");
        try (Stream<Path> paths = Files.walk(dir)) {
            paths.forEach(System.out::println);
        }

        // 정리
        Files.delete(circularLink);
        Files.delete(subdir);
        Files.delete(dir);
    }
}
```

**안전한 링크 순회**
```java
public class SafeLinkWalker {
    private final Set<Path> visited = new HashSet<>();

    public void walkSafely(Path start) throws IOException {
        Files.walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE,
            new SimpleFileVisitor<Path>() {
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                        throws IOException {

                    // 실제 경로로 변환 (심볼릭 링크 해석)
                    Path realPath = file.toRealPath();

                    // 이미 방문했으면 건너뛰기
                    if (!visited.add(realPath)) {
                        System.out.println("순환 감지 (건너뜀): " + file);
                        return FileVisitResult.CONTINUE;
                    }

                    // 심볼릭 링크 표시
                    if (Files.isSymbolicLink(file)) {
                        Path target = Files.readSymbolicLink(file);
                        System.out.println(file + " → " + target);
                    } else {
                        System.out.println(file);
                    }

                    return FileVisitResult.CONTINUE;
                }

                @Override
                public FileVisitResult visitFileFailed(Path file, IOException exc)
                        throws IOException {
                    if (exc instanceof FileSystemLoopException) {
                        System.out.println("순환 링크 감지: " + file);
                        return FileVisitResult.SKIP_SUBTREE;
                    }
                    throw exc;
                }
            });
    }
}
```

**실무 예시: 로그 파일 링크 처리**
```java
public class LogRotationHandler {
    // 로그 로테이션: current.log → current.log.1 → current.log.2
    public void rotateLog(Path logDir) throws IOException {
        Path current = logDir.resolve("current.log");
        Path symlink = logDir.resolve("latest.log");

        // 1. 기존 로그 백업
        if (Files.exists(current)) {
            Path backup = logDir.resolve("current.log." + System.currentTimeMillis());
            Files.move(current, backup);
        }

        // 2. 새 로그 파일 생성
        Files.createFile(current);

        // 3. Symbolic Link 업데이트
        if (Files.exists(symlink)) {
            Files.delete(symlink);
        }
        Files.createSymbolicLink(symlink, current.getFileName());

        System.out.println("로그 로테이션 완료");
        System.out.println("latest.log → " + Files.readSymbolicLink(symlink));
    }

    // 심볼릭 링크를 따라가서 로그 읽기
    public void readLatestLog() throws IOException {
        Path symlink = Paths.get("logs/latest.log");

        // 심볼릭 링크가 아니면 직접 읽기
        if (!Files.isSymbolicLink(symlink)) {
            readLog(symlink);
            return;
        }

        // 심볼릭 링크 → 실제 파일
        Path realFile = symlink.toRealPath();
        System.out.println("실제 로그 파일: " + realFile);
        readLog(realFile);
    }

    private void readLog(Path file) throws IOException {
        try (Stream<String> lines = Files.lines(file)) {
            lines.limit(10).forEach(System.out::println);
        }
    }
}
```

**Symbolic Link vs Hard Link 비교**
```
특징                 | Symbolic Link          | Hard Link
---------------------|------------------------|------------------------
실제 존재            | 새 파일 (포인터)        | 기존 inode 재사용
크기                 | 매우 작음 (경로 길이)   | 원본과 동일
원본 삭제 시          | 끊어진 링크 (깨짐)      | 여전히 접근 가능
디렉토리 링크        | 가능                   | 불가 (순환 방지)
다른 파일 시스템      | 가능                   | 불가 (같은 파일 시스템만)
감지                 | Files.isSymbolicLink() | inode 비교
Windows 지원         | 제한적 (관리자 권한)    | NTFS에서 가능
```

**꼬리 질문**
- Q: Windows에서 심볼릭 링크를 만들 수 있나요?
- A: Windows Vista+ 에서 가능하지만 관리자 권한이 필요하고, NTFS 파일 시스템이어야 합니다. 실무에서는 제한적으로 사용합니다.

**실무 연관**
- 로그 파일 로테이션 (latest.log → access.log.20250110)
- 배포 디렉토리 (releases/v1.0 ← current)
- 개발 환경 설정 (config/dev → config/local)
- 버전 관리 시스템 (Git worktree, SVN externals)

---

## 📝 핵심 정리

### 파일 입출력 필수 지식

| 항목 | 내용 | 사용 시기 |
|------|------|-----------|
| 기본 | FileReader/Writer + try-with-resources | 소규모 텍스트 파일 |
| 성능 | BufferedReader/Writer | 모든 텍스트 I/O |
| 현대적 | Files, Path (Java 7+) | 신규 프로젝트 |
| 대용량 | Files.lines() 스트림 | 100MB 이상 |
| 인코딩 | StandardCharsets.UTF_8 명시 | 항상 |
| 고급 | FileChannel, MappedByteBuffer | 대용량, 고성능 |

### 실무 베스트 프랙티스

#### ✅ 해야 할 것
- [x] NIO.2 (Files, Path) 사용
- [x] try-with-resources로 자동 close
- [x] UTF-8 인코딩 명시
- [x] BufferedReader로 성능 향상
- [x] 대용량 파일은 스트림 처리
- [x] 파일 존재 여부 체크
- [x] 순환 링크 방지

#### ❌ 하지 말아야 할 것
- [x] close() 누락
- [x] 인코딩 미지정
- [x] Buffer 미사용
- [x] 대용량 파일 readAllLines()
- [x] 하드코딩된 경로 (C:\\...)
- [x] 예외 무시
- [x] 플랫폼 의존 코드

### 면접 대비 핵심 포인트

#### 주니어 수준
1. InputStream/Reader 차이 설명 가능
2. BufferedReader 성능 향상 이유
3. try-with-resources 사용법
4. NIO.2 기본 API (Files, Path)
5. 인코딩 문제 해결
6. 대용량 파일 처리 (스트림)
7. close() 누락 시 문제점

#### 중급 수준
1. Channel + Buffer 동작 원리
2. WatchService 실시간 감지
3. 파일 잠금 (FileLock) 사용법
4. Memory-Mapped File 장단점
5. Symbolic/Hard Link 처리
6. Zero-Copy 파일 전송
7. 프로세스 간 통신 (IPC)

---

## 🎉 37장 완료!

**축하합니다!** 파일 입출력을 완전히 마스터했습니다!

**이제 여러분은**:
- ✅ 면접 질문에 자신 있게 답변 가능
- ✅ 주니어 7개 + 중급 5개 질문 완벽 대비
- ✅ 실무 시나리오 대응 가능
- ✅ 대용량 파일 처리 가능
- ✅ 고급 NIO 기능 활용 가능

**다음 장으로**: [38장: 직렬화와 역직렬화 →](38-1-직렬화와-역직렬화-Part1.md)

**이전 Part**: [← 37-2: NIO와 실전 프로젝트](37-2-파일-입출력-Part2.md)

**목차로 돌아가기**: [📚 전체 목차](README.md)
